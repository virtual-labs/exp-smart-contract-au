function DP(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o &&
            Object.defineProperty(
              n,
              i,
              o.get ? o : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const s of o.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const o = {};
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (o.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (o.credentials = "omit")
        : (o.credentials = "same-origin"),
      o
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const o = t(i);
    fetch(i.href, o);
  }
})();
function Tm(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function Hu(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(
        t,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return n[r];
              },
            }
      );
    }),
    t
  );
}
var Sx = { exports: {} },
  sp = {},
  wx = { exports: {} },
  un = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Jw;
function kP() {
  if (Jw) return un;
  Jw = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.forward_ref"),
    u = Symbol.for("react.suspense"),
    f = Symbol.for("react.memo"),
    h = Symbol.for("react.lazy"),
    m = Symbol.iterator;
  function g(B) {
    return B === null || typeof B != "object"
      ? null
      : ((B = (m && B[m]) || B["@@iterator"]),
        typeof B == "function" ? B : null);
  }
  var y = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    _ = Object.assign,
    S = {};
  function x(B, G, te) {
    (this.props = B),
      (this.context = G),
      (this.refs = S),
      (this.updater = te || y);
  }
  (x.prototype.isReactComponent = {}),
    (x.prototype.setState = function (B, G) {
      if (typeof B != "object" && typeof B != "function" && B != null)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, B, G, "setState");
    }),
    (x.prototype.forceUpdate = function (B) {
      this.updater.enqueueForceUpdate(this, B, "forceUpdate");
    });
  function w() {}
  w.prototype = x.prototype;
  function T(B, G, te) {
    (this.props = B),
      (this.context = G),
      (this.refs = S),
      (this.updater = te || y);
  }
  var E = (T.prototype = new w());
  (E.constructor = T), _(E, x.prototype), (E.isPureReactComponent = !0);
  var A = Array.isArray,
    R = Object.prototype.hasOwnProperty,
    D = { current: null },
    I = { key: !0, ref: !0, __self: !0, __source: !0 };
  function U(B, G, te) {
    var le,
      J = {},
      oe = null,
      he = null;
    if (G != null)
      for (le in (G.ref !== void 0 && (he = G.ref),
      G.key !== void 0 && (oe = "" + G.key),
      G))
        R.call(G, le) && !I.hasOwnProperty(le) && (J[le] = G[le]);
    var ae = arguments.length - 2;
    if (ae === 1) J.children = te;
    else if (1 < ae) {
      for (var ue = Array(ae), Ee = 0; Ee < ae; Ee++)
        ue[Ee] = arguments[Ee + 2];
      J.children = ue;
    }
    if (B && B.defaultProps)
      for (le in ((ae = B.defaultProps), ae))
        J[le] === void 0 && (J[le] = ae[le]);
    return {
      $$typeof: n,
      type: B,
      key: oe,
      ref: he,
      props: J,
      _owner: D.current,
    };
  }
  function O(B, G) {
    return {
      $$typeof: n,
      type: B.type,
      key: G,
      ref: B.ref,
      props: B.props,
      _owner: B._owner,
    };
  }
  function L(B) {
    return typeof B == "object" && B !== null && B.$$typeof === n;
  }
  function V(B) {
    var G = { "=": "=0", ":": "=2" };
    return (
      "$" +
      B.replace(/[=:]/g, function (te) {
        return G[te];
      })
    );
  }
  var H = /\/+/g;
  function $(B, G) {
    return typeof B == "object" && B !== null && B.key != null
      ? V("" + B.key)
      : G.toString(36);
  }
  function q(B, G, te, le, J) {
    var oe = typeof B;
    (oe === "undefined" || oe === "boolean") && (B = null);
    var he = !1;
    if (B === null) he = !0;
    else
      switch (oe) {
        case "string":
        case "number":
          he = !0;
          break;
        case "object":
          switch (B.$$typeof) {
            case n:
            case e:
              he = !0;
          }
      }
    if (he)
      return (
        (he = B),
        (J = J(he)),
        (B = le === "" ? "." + $(he, 0) : le),
        A(J)
          ? ((te = ""),
            B != null && (te = B.replace(H, "$&/") + "/"),
            q(J, G, te, "", function (Ee) {
              return Ee;
            }))
          : J != null &&
            (L(J) &&
              (J = O(
                J,
                te +
                  (!J.key || (he && he.key === J.key)
                    ? ""
                    : ("" + J.key).replace(H, "$&/") + "/") +
                  B
              )),
            G.push(J)),
        1
      );
    if (((he = 0), (le = le === "" ? "." : le + ":"), A(B)))
      for (var ae = 0; ae < B.length; ae++) {
        oe = B[ae];
        var ue = le + $(oe, ae);
        he += q(oe, G, te, ue, J);
      }
    else if (((ue = g(B)), typeof ue == "function"))
      for (B = ue.call(B), ae = 0; !(oe = B.next()).done; )
        (oe = oe.value), (ue = le + $(oe, ae++)), (he += q(oe, G, te, ue, J));
    else if (oe === "object")
      throw (
        ((G = String(B)),
        Error(
          "Objects are not valid as a React child (found: " +
            (G === "[object Object]"
              ? "object with keys {" + Object.keys(B).join(", ") + "}"
              : G) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    return he;
  }
  function K(B, G, te) {
    if (B == null) return B;
    var le = [],
      J = 0;
    return (
      q(B, le, "", "", function (oe) {
        return G.call(te, oe, J++);
      }),
      le
    );
  }
  function Y(B) {
    if (B._status === -1) {
      var G = B._result;
      (G = G()),
        G.then(
          function (te) {
            (B._status === 0 || B._status === -1) &&
              ((B._status = 1), (B._result = te));
          },
          function (te) {
            (B._status === 0 || B._status === -1) &&
              ((B._status = 2), (B._result = te));
          }
        ),
        B._status === -1 && ((B._status = 0), (B._result = G));
    }
    if (B._status === 1) return B._result.default;
    throw B._result;
  }
  var ne = { current: null },
    j = { transition: null },
    re = {
      ReactCurrentDispatcher: ne,
      ReactCurrentBatchConfig: j,
      ReactCurrentOwner: D,
    };
  return (
    (un.Children = {
      map: K,
      forEach: function (B, G, te) {
        K(
          B,
          function () {
            G.apply(this, arguments);
          },
          te
        );
      },
      count: function (B) {
        var G = 0;
        return (
          K(B, function () {
            G++;
          }),
          G
        );
      },
      toArray: function (B) {
        return (
          K(B, function (G) {
            return G;
          }) || []
        );
      },
      only: function (B) {
        if (!L(B))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return B;
      },
    }),
    (un.Component = x),
    (un.Fragment = t),
    (un.Profiler = i),
    (un.PureComponent = T),
    (un.StrictMode = r),
    (un.Suspense = u),
    (un.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = re),
    (un.cloneElement = function (B, G, te) {
      if (B == null)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            B +
            "."
        );
      var le = _({}, B.props),
        J = B.key,
        oe = B.ref,
        he = B._owner;
      if (G != null) {
        if (
          (G.ref !== void 0 && ((oe = G.ref), (he = D.current)),
          G.key !== void 0 && (J = "" + G.key),
          B.type && B.type.defaultProps)
        )
          var ae = B.type.defaultProps;
        for (ue in G)
          R.call(G, ue) &&
            !I.hasOwnProperty(ue) &&
            (le[ue] = G[ue] === void 0 && ae !== void 0 ? ae[ue] : G[ue]);
      }
      var ue = arguments.length - 2;
      if (ue === 1) le.children = te;
      else if (1 < ue) {
        ae = Array(ue);
        for (var Ee = 0; Ee < ue; Ee++) ae[Ee] = arguments[Ee + 2];
        le.children = ae;
      }
      return {
        $$typeof: n,
        type: B.type,
        key: J,
        ref: oe,
        props: le,
        _owner: he,
      };
    }),
    (un.createContext = function (B) {
      return (
        (B = {
          $$typeof: s,
          _currentValue: B,
          _currentValue2: B,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (B.Provider = { $$typeof: o, _context: B }),
        (B.Consumer = B)
      );
    }),
    (un.createElement = U),
    (un.createFactory = function (B) {
      var G = U.bind(null, B);
      return (G.type = B), G;
    }),
    (un.createRef = function () {
      return { current: null };
    }),
    (un.forwardRef = function (B) {
      return { $$typeof: l, render: B };
    }),
    (un.isValidElement = L),
    (un.lazy = function (B) {
      return { $$typeof: h, _payload: { _status: -1, _result: B }, _init: Y };
    }),
    (un.memo = function (B, G) {
      return { $$typeof: f, type: B, compare: G === void 0 ? null : G };
    }),
    (un.startTransition = function (B) {
      var G = j.transition;
      j.transition = {};
      try {
        B();
      } finally {
        j.transition = G;
      }
    }),
    (un.unstable_act = function () {
      throw Error("act(...) is not supported in production builds of React.");
    }),
    (un.useCallback = function (B, G) {
      return ne.current.useCallback(B, G);
    }),
    (un.useContext = function (B) {
      return ne.current.useContext(B);
    }),
    (un.useDebugValue = function () {}),
    (un.useDeferredValue = function (B) {
      return ne.current.useDeferredValue(B);
    }),
    (un.useEffect = function (B, G) {
      return ne.current.useEffect(B, G);
    }),
    (un.useId = function () {
      return ne.current.useId();
    }),
    (un.useImperativeHandle = function (B, G, te) {
      return ne.current.useImperativeHandle(B, G, te);
    }),
    (un.useInsertionEffect = function (B, G) {
      return ne.current.useInsertionEffect(B, G);
    }),
    (un.useLayoutEffect = function (B, G) {
      return ne.current.useLayoutEffect(B, G);
    }),
    (un.useMemo = function (B, G) {
      return ne.current.useMemo(B, G);
    }),
    (un.useReducer = function (B, G, te) {
      return ne.current.useReducer(B, G, te);
    }),
    (un.useRef = function (B) {
      return ne.current.useRef(B);
    }),
    (un.useState = function (B) {
      return ne.current.useState(B);
    }),
    (un.useSyncExternalStore = function (B, G, te) {
      return ne.current.useSyncExternalStore(B, G, te);
    }),
    (un.useTransition = function () {
      return ne.current.useTransition();
    }),
    (un.version = "18.2.0"),
    un
  );
}
var Qw;
function hh() {
  return Qw || ((Qw = 1), (wx.exports = kP())), wx.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var eM;
function OP() {
  if (eM) return sp;
  eM = 1;
  var n = hh(),
    e = Symbol.for("react.element"),
    t = Symbol.for("react.fragment"),
    r = Object.prototype.hasOwnProperty,
    i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(l, u, f) {
    var h,
      m = {},
      g = null,
      y = null;
    f !== void 0 && (g = "" + f),
      u.key !== void 0 && (g = "" + u.key),
      u.ref !== void 0 && (y = u.ref);
    for (h in u) r.call(u, h) && !o.hasOwnProperty(h) && (m[h] = u[h]);
    if (l && l.defaultProps)
      for (h in ((u = l.defaultProps), u)) m[h] === void 0 && (m[h] = u[h]);
    return {
      $$typeof: e,
      type: l,
      key: g,
      ref: y,
      props: m,
      _owner: i.current,
    };
  }
  return (sp.Fragment = t), (sp.jsx = s), (sp.jsxs = s), sp;
}
var tM;
function NP() {
  return tM || ((tM = 1), (Sx.exports = OP())), Sx.exports;
}
var ve = NP(),
  ee = hh();
const Ts = Tm(ee),
  c1 = DP({ __proto__: null, default: Ts }, [ee]);
var Ug = {},
  Mx = { exports: {} },
  Lo = {},
  bx = { exports: {} },
  Ex = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var nM;
function UP() {
  return (
    nM ||
      ((nM = 1),
      (function (n) {
        function e(j, re) {
          var B = j.length;
          j.push(re);
          e: for (; 0 < B; ) {
            var G = (B - 1) >>> 1,
              te = j[G];
            if (0 < i(te, re)) (j[G] = re), (j[B] = te), (B = G);
            else break e;
          }
        }
        function t(j) {
          return j.length === 0 ? null : j[0];
        }
        function r(j) {
          if (j.length === 0) return null;
          var re = j[0],
            B = j.pop();
          if (B !== re) {
            j[0] = B;
            e: for (var G = 0, te = j.length, le = te >>> 1; G < le; ) {
              var J = 2 * (G + 1) - 1,
                oe = j[J],
                he = J + 1,
                ae = j[he];
              if (0 > i(oe, B))
                he < te && 0 > i(ae, oe)
                  ? ((j[G] = ae), (j[he] = B), (G = he))
                  : ((j[G] = oe), (j[J] = B), (G = J));
              else if (he < te && 0 > i(ae, B))
                (j[G] = ae), (j[he] = B), (G = he);
              else break e;
            }
          }
          return re;
        }
        function i(j, re) {
          var B = j.sortIndex - re.sortIndex;
          return B !== 0 ? B : j.id - re.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var s = Date,
            l = s.now();
          n.unstable_now = function () {
            return s.now() - l;
          };
        }
        var u = [],
          f = [],
          h = 1,
          m = null,
          g = 3,
          y = !1,
          _ = !1,
          S = !1,
          x = typeof setTimeout == "function" ? setTimeout : null,
          w = typeof clearTimeout == "function" ? clearTimeout : null,
          T = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function E(j) {
          for (var re = t(f); re !== null; ) {
            if (re.callback === null) r(f);
            else if (re.startTime <= j)
              r(f), (re.sortIndex = re.expirationTime), e(u, re);
            else break;
            re = t(f);
          }
        }
        function A(j) {
          if (((S = !1), E(j), !_))
            if (t(u) !== null) (_ = !0), Y(R);
            else {
              var re = t(f);
              re !== null && ne(A, re.startTime - j);
            }
        }
        function R(j, re) {
          (_ = !1), S && ((S = !1), w(U), (U = -1)), (y = !0);
          var B = g;
          try {
            for (
              E(re), m = t(u);
              m !== null && (!(m.expirationTime > re) || (j && !V()));

            ) {
              var G = m.callback;
              if (typeof G == "function") {
                (m.callback = null), (g = m.priorityLevel);
                var te = G(m.expirationTime <= re);
                (re = n.unstable_now()),
                  typeof te == "function"
                    ? (m.callback = te)
                    : m === t(u) && r(u),
                  E(re);
              } else r(u);
              m = t(u);
            }
            if (m !== null) var le = !0;
            else {
              var J = t(f);
              J !== null && ne(A, J.startTime - re), (le = !1);
            }
            return le;
          } finally {
            (m = null), (g = B), (y = !1);
          }
        }
        var D = !1,
          I = null,
          U = -1,
          O = 5,
          L = -1;
        function V() {
          return !(n.unstable_now() - L < O);
        }
        function H() {
          if (I !== null) {
            var j = n.unstable_now();
            L = j;
            var re = !0;
            try {
              re = I(!0, j);
            } finally {
              re ? $() : ((D = !1), (I = null));
            }
          } else D = !1;
        }
        var $;
        if (typeof T == "function")
          $ = function () {
            T(H);
          };
        else if (typeof MessageChannel < "u") {
          var q = new MessageChannel(),
            K = q.port2;
          (q.port1.onmessage = H),
            ($ = function () {
              K.postMessage(null);
            });
        } else
          $ = function () {
            x(H, 0);
          };
        function Y(j) {
          (I = j), D || ((D = !0), $());
        }
        function ne(j, re) {
          U = x(function () {
            j(n.unstable_now());
          }, re);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (j) {
            j.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            _ || y || ((_ = !0), Y(R));
          }),
          (n.unstable_forceFrameRate = function (j) {
            0 > j || 125 < j
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (O = 0 < j ? Math.floor(1e3 / j) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(u);
          }),
          (n.unstable_next = function (j) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var re = 3;
                break;
              default:
                re = g;
            }
            var B = g;
            g = re;
            try {
              return j();
            } finally {
              g = B;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (j, re) {
            switch (j) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                j = 3;
            }
            var B = g;
            g = j;
            try {
              return re();
            } finally {
              g = B;
            }
          }),
          (n.unstable_scheduleCallback = function (j, re, B) {
            var G = n.unstable_now();
            switch (
              (typeof B == "object" && B !== null
                ? ((B = B.delay),
                  (B = typeof B == "number" && 0 < B ? G + B : G))
                : (B = G),
              j)
            ) {
              case 1:
                var te = -1;
                break;
              case 2:
                te = 250;
                break;
              case 5:
                te = 1073741823;
                break;
              case 4:
                te = 1e4;
                break;
              default:
                te = 5e3;
            }
            return (
              (te = B + te),
              (j = {
                id: h++,
                callback: re,
                priorityLevel: j,
                startTime: B,
                expirationTime: te,
                sortIndex: -1,
              }),
              B > G
                ? ((j.sortIndex = B),
                  e(f, j),
                  t(u) === null &&
                    j === t(f) &&
                    (S ? (w(U), (U = -1)) : (S = !0), ne(A, B - G)))
                : ((j.sortIndex = te), e(u, j), _ || y || ((_ = !0), Y(R))),
              j
            );
          }),
          (n.unstable_shouldYield = V),
          (n.unstable_wrapCallback = function (j) {
            var re = g;
            return function () {
              var B = g;
              g = re;
              try {
                return j.apply(this, arguments);
              } finally {
                g = B;
              }
            };
          });
      })(Ex)),
    Ex
  );
}
var rM;
function FP() {
  return rM || ((rM = 1), (bx.exports = UP())), bx.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var iM;
function zP() {
  if (iM) return Lo;
  iM = 1;
  var n = hh(),
    e = FP();
  function t(a) {
    for (
      var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + a,
        v = 1;
      v < arguments.length;
      v++
    )
      c += "&args[]=" + encodeURIComponent(arguments[v]);
    return (
      "Minified React error #" +
      a +
      "; visit " +
      c +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var r = new Set(),
    i = {};
  function o(a, c) {
    s(a, c), s(a + "Capture", c);
  }
  function s(a, c) {
    for (i[a] = c, a = 0; a < c.length; a++) r.add(c[a]);
  }
  var l = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    u = Object.prototype.hasOwnProperty,
    f =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    h = {},
    m = {};
  function g(a) {
    return u.call(m, a)
      ? !0
      : u.call(h, a)
      ? !1
      : f.test(a)
      ? (m[a] = !0)
      : ((h[a] = !0), !1);
  }
  function y(a, c, v, b) {
    if (v !== null && v.type === 0) return !1;
    switch (typeof c) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return b
          ? !1
          : v !== null
          ? !v.acceptsBooleans
          : ((a = a.toLowerCase().slice(0, 5)), a !== "data-" && a !== "aria-");
      default:
        return !1;
    }
  }
  function _(a, c, v, b) {
    if (c === null || typeof c > "u" || y(a, c, v, b)) return !0;
    if (b) return !1;
    if (v !== null)
      switch (v.type) {
        case 3:
          return !c;
        case 4:
          return c === !1;
        case 5:
          return isNaN(c);
        case 6:
          return isNaN(c) || 1 > c;
      }
    return !1;
  }
  function S(a, c, v, b, P, N, X) {
    (this.acceptsBooleans = c === 2 || c === 3 || c === 4),
      (this.attributeName = b),
      (this.attributeNamespace = P),
      (this.mustUseProperty = v),
      (this.propertyName = a),
      (this.type = c),
      (this.sanitizeURL = N),
      (this.removeEmptyString = X);
  }
  var x = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (a) {
      x[a] = new S(a, 0, !1, a, null, !1, !1);
    }),
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (a) {
      var c = a[0];
      x[c] = new S(c, 1, !1, a[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (
      a
    ) {
      x[a] = new S(a, 2, !1, a.toLowerCase(), null, !1, !1);
    }),
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (a) {
      x[a] = new S(a, 2, !1, a, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (a) {
        x[a] = new S(a, 3, !1, a.toLowerCase(), null, !1, !1);
      }),
    ["checked", "multiple", "muted", "selected"].forEach(function (a) {
      x[a] = new S(a, 3, !0, a, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (a) {
      x[a] = new S(a, 4, !1, a, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (a) {
      x[a] = new S(a, 6, !1, a, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (a) {
      x[a] = new S(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
  var w = /[\-:]([a-z])/g;
  function T(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (a) {
      var c = a.replace(w, T);
      x[c] = new S(c, 1, !1, a, null, !1, !1);
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (a) {
        var c = a.replace(w, T);
        x[c] = new S(c, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
      }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
      var c = a.replace(w, T);
      x[c] = new S(c, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (a) {
      x[a] = new S(a, 1, !1, a.toLowerCase(), null, !1, !1);
    }),
    (x.xlinkHref = new S(
      "xlinkHref",
      1,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    )),
    ["src", "href", "action", "formAction"].forEach(function (a) {
      x[a] = new S(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
  function E(a, c, v, b) {
    var P = x.hasOwnProperty(c) ? x[c] : null;
    (P !== null
      ? P.type !== 0
      : b ||
        !(2 < c.length) ||
        (c[0] !== "o" && c[0] !== "O") ||
        (c[1] !== "n" && c[1] !== "N")) &&
      (_(c, v, P, b) && (v = null),
      b || P === null
        ? g(c) &&
          (v === null ? a.removeAttribute(c) : a.setAttribute(c, "" + v))
        : P.mustUseProperty
        ? (a[P.propertyName] = v === null ? (P.type === 3 ? !1 : "") : v)
        : ((c = P.attributeName),
          (b = P.attributeNamespace),
          v === null
            ? a.removeAttribute(c)
            : ((P = P.type),
              (v = P === 3 || (P === 4 && v === !0) ? "" : "" + v),
              b ? a.setAttributeNS(b, c, v) : a.setAttribute(c, v))));
  }
  var A = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    R = Symbol.for("react.element"),
    D = Symbol.for("react.portal"),
    I = Symbol.for("react.fragment"),
    U = Symbol.for("react.strict_mode"),
    O = Symbol.for("react.profiler"),
    L = Symbol.for("react.provider"),
    V = Symbol.for("react.context"),
    H = Symbol.for("react.forward_ref"),
    $ = Symbol.for("react.suspense"),
    q = Symbol.for("react.suspense_list"),
    K = Symbol.for("react.memo"),
    Y = Symbol.for("react.lazy"),
    ne = Symbol.for("react.offscreen"),
    j = Symbol.iterator;
  function re(a) {
    return a === null || typeof a != "object"
      ? null
      : ((a = (j && a[j]) || a["@@iterator"]),
        typeof a == "function" ? a : null);
  }
  var B = Object.assign,
    G;
  function te(a) {
    if (G === void 0)
      try {
        throw Error();
      } catch (v) {
        var c = v.stack.trim().match(/\n( *(at )?)/);
        G = (c && c[1]) || "";
      }
    return (
      `
` +
      G +
      a
    );
  }
  var le = !1;
  function J(a, c) {
    if (!a || le) return "";
    le = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c)
        if (
          ((c = function () {
            throw Error();
          }),
          Object.defineProperty(c.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(c, []);
          } catch (je) {
            var b = je;
          }
          Reflect.construct(a, [], c);
        } else {
          try {
            c.call();
          } catch (je) {
            b = je;
          }
          a.call(c.prototype);
        }
      else {
        try {
          throw Error();
        } catch (je) {
          b = je;
        }
        a();
      }
    } catch (je) {
      if (je && b && typeof je.stack == "string") {
        for (
          var P = je.stack.split(`
`),
            N = b.stack.split(`
`),
            X = P.length - 1,
            fe = N.length - 1;
          1 <= X && 0 <= fe && P[X] !== N[fe];

        )
          fe--;
        for (; 1 <= X && 0 <= fe; X--, fe--)
          if (P[X] !== N[fe]) {
            if (X !== 1 || fe !== 1)
              do
                if ((X--, fe--, 0 > fe || P[X] !== N[fe])) {
                  var ge =
                    `
` + P[X].replace(" at new ", " at ");
                  return (
                    a.displayName &&
                      ge.includes("<anonymous>") &&
                      (ge = ge.replace("<anonymous>", a.displayName)),
                    ge
                  );
                }
              while (1 <= X && 0 <= fe);
            break;
          }
      }
    } finally {
      (le = !1), (Error.prepareStackTrace = v);
    }
    return (a = a ? a.displayName || a.name : "") ? te(a) : "";
  }
  function oe(a) {
    switch (a.tag) {
      case 5:
        return te(a.type);
      case 16:
        return te("Lazy");
      case 13:
        return te("Suspense");
      case 19:
        return te("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (a = J(a.type, !1)), a;
      case 11:
        return (a = J(a.type.render, !1)), a;
      case 1:
        return (a = J(a.type, !0)), a;
      default:
        return "";
    }
  }
  function he(a) {
    if (a == null) return null;
    if (typeof a == "function") return a.displayName || a.name || null;
    if (typeof a == "string") return a;
    switch (a) {
      case I:
        return "Fragment";
      case D:
        return "Portal";
      case O:
        return "Profiler";
      case U:
        return "StrictMode";
      case $:
        return "Suspense";
      case q:
        return "SuspenseList";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case V:
          return (a.displayName || "Context") + ".Consumer";
        case L:
          return (a._context.displayName || "Context") + ".Provider";
        case H:
          var c = a.render;
          return (
            (a = a.displayName),
            a ||
              ((a = c.displayName || c.name || ""),
              (a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef")),
            a
          );
        case K:
          return (
            (c = a.displayName || null), c !== null ? c : he(a.type) || "Memo"
          );
        case Y:
          (c = a._payload), (a = a._init);
          try {
            return he(a(c));
          } catch {}
      }
    return null;
  }
  function ae(a) {
    var c = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (a = c.render),
          (a = a.displayName || a.name || ""),
          c.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return he(c);
      case 8:
        return c === U ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function") return c.displayName || c.name || null;
        if (typeof c == "string") return c;
    }
    return null;
  }
  function ue(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ee(a) {
    var c = a.type;
    return (
      (a = a.nodeName) &&
      a.toLowerCase() === "input" &&
      (c === "checkbox" || c === "radio")
    );
  }
  function Ne(a) {
    var c = Ee(a) ? "checked" : "value",
      v = Object.getOwnPropertyDescriptor(a.constructor.prototype, c),
      b = "" + a[c];
    if (
      !a.hasOwnProperty(c) &&
      typeof v < "u" &&
      typeof v.get == "function" &&
      typeof v.set == "function"
    ) {
      var P = v.get,
        N = v.set;
      return (
        Object.defineProperty(a, c, {
          configurable: !0,
          get: function () {
            return P.call(this);
          },
          set: function (X) {
            (b = "" + X), N.call(this, X);
          },
        }),
        Object.defineProperty(a, c, { enumerable: v.enumerable }),
        {
          getValue: function () {
            return b;
          },
          setValue: function (X) {
            b = "" + X;
          },
          stopTracking: function () {
            (a._valueTracker = null), delete a[c];
          },
        }
      );
    }
  }
  function Ae(a) {
    a._valueTracker || (a._valueTracker = Ne(a));
  }
  function W(a) {
    if (!a) return !1;
    var c = a._valueTracker;
    if (!c) return !0;
    var v = c.getValue(),
      b = "";
    return (
      a && (b = Ee(a) ? (a.checked ? "true" : "false") : a.value),
      (a = b),
      a !== v ? (c.setValue(a), !0) : !1
    );
  }
  function _e(a) {
    if (
      ((a = a || (typeof document < "u" ? document : void 0)), typeof a > "u")
    )
      return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  function Te(a, c) {
    var v = c.checked;
    return B({}, c, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: v ?? a._wrapperState.initialChecked,
    });
  }
  function ke(a, c) {
    var v = c.defaultValue == null ? "" : c.defaultValue,
      b = c.checked != null ? c.checked : c.defaultChecked;
    (v = ue(c.value != null ? c.value : v)),
      (a._wrapperState = {
        initialChecked: b,
        initialValue: v,
        controlled:
          c.type === "checkbox" || c.type === "radio"
            ? c.checked != null
            : c.value != null,
      });
  }
  function Pe(a, c) {
    (c = c.checked), c != null && E(a, "checked", c, !1);
  }
  function rt(a, c) {
    Pe(a, c);
    var v = ue(c.value),
      b = c.type;
    if (v != null)
      b === "number"
        ? ((v === 0 && a.value === "") || a.value != v) && (a.value = "" + v)
        : a.value !== "" + v && (a.value = "" + v);
    else if (b === "submit" || b === "reset") {
      a.removeAttribute("value");
      return;
    }
    c.hasOwnProperty("value")
      ? Xe(a, c.type, v)
      : c.hasOwnProperty("defaultValue") && Xe(a, c.type, ue(c.defaultValue)),
      c.checked == null &&
        c.defaultChecked != null &&
        (a.defaultChecked = !!c.defaultChecked);
  }
  function Le(a, c, v) {
    if (c.hasOwnProperty("value") || c.hasOwnProperty("defaultValue")) {
      var b = c.type;
      if (
        !(
          (b !== "submit" && b !== "reset") ||
          (c.value !== void 0 && c.value !== null)
        )
      )
        return;
      (c = "" + a._wrapperState.initialValue),
        v || c === a.value || (a.value = c),
        (a.defaultValue = c);
    }
    (v = a.name),
      v !== "" && (a.name = ""),
      (a.defaultChecked = !!a._wrapperState.initialChecked),
      v !== "" && (a.name = v);
  }
  function Xe(a, c, v) {
    (c !== "number" || _e(a.ownerDocument) !== a) &&
      (v == null
        ? (a.defaultValue = "" + a._wrapperState.initialValue)
        : a.defaultValue !== "" + v && (a.defaultValue = "" + v));
  }
  var Z = Array.isArray;
  function F(a, c, v, b) {
    if (((a = a.options), c)) {
      c = {};
      for (var P = 0; P < v.length; P++) c["$" + v[P]] = !0;
      for (v = 0; v < a.length; v++)
        (P = c.hasOwnProperty("$" + a[v].value)),
          a[v].selected !== P && (a[v].selected = P),
          P && b && (a[v].defaultSelected = !0);
    } else {
      for (v = "" + ue(v), c = null, P = 0; P < a.length; P++) {
        if (a[P].value === v) {
          (a[P].selected = !0), b && (a[P].defaultSelected = !0);
          return;
        }
        c !== null || a[P].disabled || (c = a[P]);
      }
      c !== null && (c.selected = !0);
    }
  }
  function me(a, c) {
    if (c.dangerouslySetInnerHTML != null) throw Error(t(91));
    return B({}, c, {
      value: void 0,
      defaultValue: void 0,
      children: "" + a._wrapperState.initialValue,
    });
  }
  function xe(a, c) {
    var v = c.value;
    if (v == null) {
      if (((v = c.children), (c = c.defaultValue), v != null)) {
        if (c != null) throw Error(t(92));
        if (Z(v)) {
          if (1 < v.length) throw Error(t(93));
          v = v[0];
        }
        c = v;
      }
      c == null && (c = ""), (v = c);
    }
    a._wrapperState = { initialValue: ue(v) };
  }
  function ye(a, c) {
    var v = ue(c.value),
      b = ue(c.defaultValue);
    v != null &&
      ((v = "" + v),
      v !== a.value && (a.value = v),
      c.defaultValue == null && a.defaultValue !== v && (a.defaultValue = v)),
      b != null && (a.defaultValue = "" + b);
  }
  function Me(a) {
    var c = a.textContent;
    c === a._wrapperState.initialValue &&
      c !== "" &&
      c !== null &&
      (a.value = c);
  }
  function at(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Fe(a, c) {
    return a == null || a === "http://www.w3.org/1999/xhtml"
      ? at(c)
      : a === "http://www.w3.org/2000/svg" && c === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : a;
  }
  var ze,
    We = (function (a) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (c, v, b, P) {
            MSApp.execUnsafeLocalFunction(function () {
              return a(c, v, b, P);
            });
          }
        : a;
    })(function (a, c) {
      if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
        a.innerHTML = c;
      else {
        for (
          ze = ze || document.createElement("div"),
            ze.innerHTML = "<svg>" + c.valueOf().toString() + "</svg>",
            c = ze.firstChild;
          a.firstChild;

        )
          a.removeChild(a.firstChild);
        for (; c.firstChild; ) a.appendChild(c.firstChild);
      }
    });
  function Ye(a, c) {
    if (c) {
      var v = a.firstChild;
      if (v && v === a.lastChild && v.nodeType === 3) {
        v.nodeValue = c;
        return;
      }
    }
    a.textContent = c;
  }
  var nt = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    yt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(nt).forEach(function (a) {
    yt.forEach(function (c) {
      (c = c + a.charAt(0).toUpperCase() + a.substring(1)), (nt[c] = nt[a]);
    });
  });
  function $e(a, c, v) {
    return c == null || typeof c == "boolean" || c === ""
      ? ""
      : v || typeof c != "number" || c === 0 || (nt.hasOwnProperty(a) && nt[a])
      ? ("" + c).trim()
      : c + "px";
  }
  function qe(a, c) {
    a = a.style;
    for (var v in c)
      if (c.hasOwnProperty(v)) {
        var b = v.indexOf("--") === 0,
          P = $e(v, c[v], b);
        v === "float" && (v = "cssFloat"), b ? a.setProperty(v, P) : (a[v] = P);
      }
  }
  var et = B(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    }
  );
  function ce(a, c) {
    if (c) {
      if (et[a] && (c.children != null || c.dangerouslySetInnerHTML != null))
        throw Error(t(137, a));
      if (c.dangerouslySetInnerHTML != null) {
        if (c.children != null) throw Error(t(60));
        if (
          typeof c.dangerouslySetInnerHTML != "object" ||
          !("__html" in c.dangerouslySetInnerHTML)
        )
          throw Error(t(61));
      }
      if (c.style != null && typeof c.style != "object") throw Error(t(62));
    }
  }
  function Je(a, c) {
    if (a.indexOf("-") === -1) return typeof c.is == "string";
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var de = null;
  function He(a) {
    return (
      (a = a.target || a.srcElement || window),
      a.correspondingUseElement && (a = a.correspondingUseElement),
      a.nodeType === 3 ? a.parentNode : a
    );
  }
  var Ce = null,
    Ue = null,
    it = null;
  function mt(a) {
    if ((a = Vs(a))) {
      if (typeof Ce != "function") throw Error(t(280));
      var c = a.stateNode;
      c && ((c = Gf(c)), Ce(a.stateNode, a.type, c));
    }
  }
  function gt(a) {
    Ue ? (it ? it.push(a) : (it = [a])) : (Ue = a);
  }
  function Ot() {
    if (Ue) {
      var a = Ue,
        c = it;
      if (((it = Ue = null), mt(a), c)) for (a = 0; a < c.length; a++) mt(c[a]);
    }
  }
  function Nt(a, c) {
    return a(c);
  }
  function ht() {}
  var jt = !1;
  function an(a, c, v) {
    if (jt) return a(c, v);
    jt = !0;
    try {
      return Nt(a, c, v);
    } finally {
      (jt = !1), (Ue !== null || it !== null) && (ht(), Ot());
    }
  }
  function _n(a, c) {
    var v = a.stateNode;
    if (v === null) return null;
    var b = Gf(v);
    if (b === null) return null;
    v = b[c];
    e: switch (c) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (b = !b.disabled) ||
          ((a = a.type),
          (b = !(
            a === "button" ||
            a === "input" ||
            a === "select" ||
            a === "textarea"
          ))),
          (a = !b);
        break e;
      default:
        a = !1;
    }
    if (a) return null;
    if (v && typeof v != "function") throw Error(t(231, c, typeof v));
    return v;
  }
  var mn = !1;
  if (l)
    try {
      var ir = {};
      Object.defineProperty(ir, "passive", {
        get: function () {
          mn = !0;
        },
      }),
        window.addEventListener("test", ir, ir),
        window.removeEventListener("test", ir, ir);
    } catch {
      mn = !1;
    }
  function Oi(a, c, v, b, P, N, X, fe, ge) {
    var je = Array.prototype.slice.call(arguments, 3);
    try {
      c.apply(v, je);
    } catch (st) {
      this.onError(st);
    }
  }
  var mr = !1,
    Nr = null,
    Er = !1,
    Ur = null,
    gr = {
      onError: function (a) {
        (mr = !0), (Nr = a);
      },
    };
  function go(a, c, v, b, P, N, X, fe, ge) {
    (mr = !1), (Nr = null), Oi.apply(gr, arguments);
  }
  function Fl(a, c, v, b, P, N, X, fe, ge) {
    if ((go.apply(this, arguments), mr)) {
      if (mr) {
        var je = Nr;
        (mr = !1), (Nr = null);
      } else throw Error(t(198));
      Er || ((Er = !0), (Ur = je));
    }
  }
  function eo(a) {
    var c = a,
      v = a;
    if (a.alternate) for (; c.return; ) c = c.return;
    else {
      a = c;
      do (c = a), (c.flags & 4098) !== 0 && (v = c.return), (a = c.return);
      while (a);
    }
    return c.tag === 3 ? v : null;
  }
  function zl(a) {
    if (a.tag === 13) {
      var c = a.memoizedState;
      if (
        (c === null && ((a = a.alternate), a !== null && (c = a.memoizedState)),
        c !== null)
      )
        return c.dehydrated;
    }
    return null;
  }
  function Q(a) {
    if (eo(a) !== a) throw Error(t(188));
  }
  function be(a) {
    var c = a.alternate;
    if (!c) {
      if (((c = eo(a)), c === null)) throw Error(t(188));
      return c !== a ? null : a;
    }
    for (var v = a, b = c; ; ) {
      var P = v.return;
      if (P === null) break;
      var N = P.alternate;
      if (N === null) {
        if (((b = P.return), b !== null)) {
          v = b;
          continue;
        }
        break;
      }
      if (P.child === N.child) {
        for (N = P.child; N; ) {
          if (N === v) return Q(P), a;
          if (N === b) return Q(P), c;
          N = N.sibling;
        }
        throw Error(t(188));
      }
      if (v.return !== b.return) (v = P), (b = N);
      else {
        for (var X = !1, fe = P.child; fe; ) {
          if (fe === v) {
            (X = !0), (v = P), (b = N);
            break;
          }
          if (fe === b) {
            (X = !0), (b = P), (v = N);
            break;
          }
          fe = fe.sibling;
        }
        if (!X) {
          for (fe = N.child; fe; ) {
            if (fe === v) {
              (X = !0), (v = N), (b = P);
              break;
            }
            if (fe === b) {
              (X = !0), (b = N), (v = P);
              break;
            }
            fe = fe.sibling;
          }
          if (!X) throw Error(t(189));
        }
      }
      if (v.alternate !== b) throw Error(t(190));
    }
    if (v.tag !== 3) throw Error(t(188));
    return v.stateNode.current === v ? a : c;
  }
  function Be(a) {
    return (a = be(a)), a !== null ? Ge(a) : null;
  }
  function Ge(a) {
    if (a.tag === 5 || a.tag === 6) return a;
    for (a = a.child; a !== null; ) {
      var c = Ge(a);
      if (c !== null) return c;
      a = a.sibling;
    }
    return null;
  }
  var Ie = e.unstable_scheduleCallback,
    ut = e.unstable_cancelCallback,
    vt = e.unstable_shouldYield,
    Et = e.unstable_requestPaint,
    Ke = e.unstable_now,
    Dt = e.unstable_getCurrentPriorityLevel,
    Ut = e.unstable_ImmediatePriority,
    At = e.unstable_UserBlockingPriority,
    tn = e.unstable_NormalPriority,
    Tn = e.unstable_LowPriority,
    dn = e.unstable_IdlePriority,
    Sn = null,
    wt = null;
  function dt(a) {
    if (wt && typeof wt.onCommitFiberRoot == "function")
      try {
        wt.onCommitFiberRoot(Sn, a, void 0, (a.current.flags & 128) === 128);
      } catch {}
  }
  var Zt = Math.clz32 ? Math.clz32 : ni,
    Bt = Math.log,
    wn = Math.LN2;
  function ni(a) {
    return (a >>>= 0), a === 0 ? 32 : (31 - ((Bt(a) / wn) | 0)) | 0;
  }
  var Cn = 64,
    Bn = 4194304;
  function ln(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function Fr(a, c) {
    var v = a.pendingLanes;
    if (v === 0) return 0;
    var b = 0,
      P = a.suspendedLanes,
      N = a.pingedLanes,
      X = v & 268435455;
    if (X !== 0) {
      var fe = X & ~P;
      fe !== 0 ? (b = ln(fe)) : ((N &= X), N !== 0 && (b = ln(N)));
    } else (X = v & ~P), X !== 0 ? (b = ln(X)) : N !== 0 && (b = ln(N));
    if (b === 0) return 0;
    if (
      c !== 0 &&
      c !== b &&
      (c & P) === 0 &&
      ((P = b & -b), (N = c & -c), P >= N || (P === 16 && (N & 4194240) !== 0))
    )
      return c;
    if (((b & 4) !== 0 && (b |= v & 16), (c = a.entangledLanes), c !== 0))
      for (a = a.entanglements, c &= b; 0 < c; )
        (v = 31 - Zt(c)), (P = 1 << v), (b |= a[v]), (c &= ~P);
    return b;
  }
  function as(a, c) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function or(a, c) {
    for (
      var v = a.suspendedLanes,
        b = a.pingedLanes,
        P = a.expirationTimes,
        N = a.pendingLanes;
      0 < N;

    ) {
      var X = 31 - Zt(N),
        fe = 1 << X,
        ge = P[X];
      ge === -1
        ? ((fe & v) === 0 || (fe & b) !== 0) && (P[X] = as(fe, c))
        : ge <= c && (a.expiredLanes |= fe),
        (N &= ~fe);
    }
  }
  function Tr(a) {
    return (
      (a = a.pendingLanes & -1073741825),
      a !== 0 ? a : a & 1073741824 ? 1073741824 : 0
    );
  }
  function ci() {
    var a = Cn;
    return (Cn <<= 1), (Cn & 4194240) === 0 && (Cn = 64), a;
  }
  function Uo(a) {
    for (var c = [], v = 0; 31 > v; v++) c.push(a);
    return c;
  }
  function Fo(a, c, v) {
    (a.pendingLanes |= c),
      c !== 536870912 && ((a.suspendedLanes = 0), (a.pingedLanes = 0)),
      (a = a.eventTimes),
      (c = 31 - Zt(c)),
      (a[c] = v);
  }
  function vf(a, c) {
    var v = a.pendingLanes & ~c;
    (a.pendingLanes = c),
      (a.suspendedLanes = 0),
      (a.pingedLanes = 0),
      (a.expiredLanes &= c),
      (a.mutableReadLanes &= c),
      (a.entangledLanes &= c),
      (c = a.entanglements);
    var b = a.eventTimes;
    for (a = a.expirationTimes; 0 < v; ) {
      var P = 31 - Zt(v),
        N = 1 << P;
      (c[P] = 0), (b[P] = -1), (a[P] = -1), (v &= ~N);
    }
  }
  function zo(a, c) {
    var v = (a.entangledLanes |= c);
    for (a = a.entanglements; v; ) {
      var b = 31 - Zt(v),
        P = 1 << b;
      (P & c) | (a[b] & c) && (a[b] |= c), (v &= ~P);
    }
  }
  var sn = 0;
  function ls(a) {
    return (
      (a &= -a),
      1 < a ? (4 < a ? ((a & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
    );
  }
  var fa,
    Bl,
    Vl,
    us,
    $a,
    vo = !1,
    Bo = [],
    ri = null,
    $t = null,
    yo = null,
    to = new Map(),
    cs = new Map(),
    xo = [],
    yf =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
  function Gn(a, c) {
    switch (a) {
      case "focusin":
      case "focusout":
        ri = null;
        break;
      case "dragenter":
      case "dragleave":
        $t = null;
        break;
      case "mouseover":
      case "mouseout":
        yo = null;
        break;
      case "pointerover":
      case "pointerout":
        to.delete(c.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        cs.delete(c.pointerId);
    }
  }
  function Vo(a, c, v, b, P, N) {
    return a === null || a.nativeEvent !== N
      ? ((a = {
          blockedOn: c,
          domEventName: v,
          eventSystemFlags: b,
          nativeEvent: N,
          targetContainers: [P],
        }),
        c !== null && ((c = Vs(c)), c !== null && Bl(c)),
        a)
      : ((a.eventSystemFlags |= b),
        (c = a.targetContainers),
        P !== null && c.indexOf(P) === -1 && c.push(P),
        a);
  }
  function xf(a, c, v, b, P) {
    switch (c) {
      case "focusin":
        return (ri = Vo(ri, a, c, v, b, P)), !0;
      case "dragenter":
        return ($t = Vo($t, a, c, v, b, P)), !0;
      case "mouseover":
        return (yo = Vo(yo, a, c, v, b, P)), !0;
      case "pointerover":
        var N = P.pointerId;
        return to.set(N, Vo(to.get(N) || null, a, c, v, b, P)), !0;
      case "gotpointercapture":
        return (
          (N = P.pointerId), cs.set(N, Vo(cs.get(N) || null, a, c, v, b, P)), !0
        );
    }
    return !1;
  }
  function fi(a) {
    var c = Ma(a.target);
    if (c !== null) {
      var v = eo(c);
      if (v !== null) {
        if (((c = v.tag), c === 13)) {
          if (((c = zl(v)), c !== null)) {
            (a.blockedOn = c),
              $a(a.priority, function () {
                Vl(v);
              });
            return;
          }
        } else if (c === 3 && v.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = v.tag === 3 ? v.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function da(a) {
    if (a.blockedOn !== null) return !1;
    for (var c = a.targetContainers; 0 < c.length; ) {
      var v = di(a.domEventName, a.eventSystemFlags, c[0], a.nativeEvent);
      if (v === null) {
        v = a.nativeEvent;
        var b = new v.constructor(v.type, v);
        (de = b), v.target.dispatchEvent(b), (de = null);
      } else return (c = Vs(v)), c !== null && Bl(c), (a.blockedOn = v), !1;
      c.shift();
    }
    return !0;
  }
  function ha(a, c, v) {
    da(a) && v.delete(c);
  }
  function no() {
    (vo = !1),
      ri !== null && da(ri) && (ri = null),
      $t !== null && da($t) && ($t = null),
      yo !== null && da(yo) && (yo = null),
      to.forEach(ha),
      cs.forEach(ha);
  }
  function Ps(a, c) {
    a.blockedOn === c &&
      ((a.blockedOn = null),
      vo ||
        ((vo = !0),
        e.unstable_scheduleCallback(e.unstable_NormalPriority, no)));
  }
  function pa(a) {
    function c(P) {
      return Ps(P, a);
    }
    if (0 < Bo.length) {
      Ps(Bo[0], a);
      for (var v = 1; v < Bo.length; v++) {
        var b = Bo[v];
        b.blockedOn === a && (b.blockedOn = null);
      }
    }
    for (
      ri !== null && Ps(ri, a),
        $t !== null && Ps($t, a),
        yo !== null && Ps(yo, a),
        to.forEach(c),
        cs.forEach(c),
        v = 0;
      v < xo.length;
      v++
    )
      (b = xo[v]), b.blockedOn === a && (b.blockedOn = null);
    for (; 0 < xo.length && ((v = xo[0]), v.blockedOn === null); )
      fi(v), v.blockedOn === null && xo.shift();
  }
  var zr = A.ReactCurrentBatchConfig,
    Br = !0;
  function fs(a, c, v, b) {
    var P = sn,
      N = zr.transition;
    zr.transition = null;
    try {
      (sn = 1), Xa(a, c, v, b);
    } finally {
      (sn = P), (zr.transition = N);
    }
  }
  function _o(a, c, v, b) {
    var P = sn,
      N = zr.transition;
    zr.transition = null;
    try {
      (sn = 4), Xa(a, c, v, b);
    } finally {
      (sn = P), (zr.transition = N);
    }
  }
  function Xa(a, c, v, b) {
    if (Br) {
      var P = di(a, c, v, b);
      if (P === null) Uf(a, c, b, ma, v), Gn(a, b);
      else if (xf(P, a, c, v, b)) b.stopPropagation();
      else if ((Gn(a, b), c & 4 && -1 < yf.indexOf(a))) {
        for (; P !== null; ) {
          var N = Vs(P);
          if (
            (N !== null && fa(N),
            (N = di(a, c, v, b)),
            N === null && Uf(a, c, b, ma, v),
            N === P)
          )
            break;
          P = N;
        }
        P !== null && b.stopPropagation();
      } else Uf(a, c, b, null, v);
    }
  }
  var ma = null;
  function di(a, c, v, b) {
    if (((ma = null), (a = He(b)), (a = Ma(a)), a !== null))
      if (((c = eo(a)), c === null)) a = null;
      else if (((v = c.tag), v === 13)) {
        if (((a = zl(c)), a !== null)) return a;
        a = null;
      } else if (v === 3) {
        if (c.stateNode.current.memoizedState.isDehydrated)
          return c.tag === 3 ? c.stateNode.containerInfo : null;
        a = null;
      } else c !== a && (a = null);
    return (ma = a), null;
  }
  function ga(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Dt()) {
          case Ut:
            return 1;
          case At:
            return 4;
          case tn:
          case Tn:
            return 16;
          case dn:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ni = null,
    Is = null,
    Vr = null;
  function Cr() {
    if (Vr) return Vr;
    var a,
      c = Is,
      v = c.length,
      b,
      P = "value" in Ni ? Ni.value : Ni.textContent,
      N = P.length;
    for (a = 0; a < v && c[a] === P[a]; a++);
    var X = v - a;
    for (b = 1; b <= X && c[v - b] === P[N - b]; b++);
    return (Vr = P.slice(a, 1 < b ? 1 - b : void 0));
  }
  function Ls(a) {
    var c = a.keyCode;
    return (
      "charCode" in a
        ? ((a = a.charCode), a === 0 && c === 13 && (a = 13))
        : (a = c),
      a === 10 && (a = 13),
      32 <= a || a === 13 ? a : 0
    );
  }
  function Ui() {
    return !0;
  }
  function Ds() {
    return !1;
  }
  function Hr(a) {
    function c(v, b, P, N, X) {
      (this._reactName = v),
        (this._targetInst = P),
        (this.type = b),
        (this.nativeEvent = N),
        (this.target = X),
        (this.currentTarget = null);
      for (var fe in a)
        a.hasOwnProperty(fe) && ((v = a[fe]), (this[fe] = v ? v(N) : N[fe]));
      return (
        (this.isDefaultPrevented = (
          N.defaultPrevented != null ? N.defaultPrevented : N.returnValue === !1
        )
          ? Ui
          : Ds),
        (this.isPropagationStopped = Ds),
        this
      );
    }
    return (
      B(c.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var v = this.nativeEvent;
          v &&
            (v.preventDefault
              ? v.preventDefault()
              : typeof v.returnValue != "unknown" && (v.returnValue = !1),
            (this.isDefaultPrevented = Ui));
        },
        stopPropagation: function () {
          var v = this.nativeEvent;
          v &&
            (v.stopPropagation
              ? v.stopPropagation()
              : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0),
            (this.isPropagationStopped = Ui));
        },
        persist: function () {},
        isPersistent: Ui,
      }),
      c
    );
  }
  var ks = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    vr = Hr(ks),
    Ar = B({}, ks, { view: 0, detail: 0 }),
    sr = Hr(Ar),
    Yn,
    _i,
    So,
    Hl = B({}, Ar, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: ya,
      button: 0,
      buttons: 0,
      relatedTarget: function (a) {
        return a.relatedTarget === void 0
          ? a.fromElement === a.srcElement
            ? a.toElement
            : a.fromElement
          : a.relatedTarget;
      },
      movementX: function (a) {
        return "movementX" in a
          ? a.movementX
          : (a !== So &&
              (So && a.type === "mousemove"
                ? ((Yn = a.screenX - So.screenX), (_i = a.screenY - So.screenY))
                : (_i = Yn = 0),
              (So = a)),
            Yn);
      },
      movementY: function (a) {
        return "movementY" in a ? a.movementY : _i;
      },
    }),
    wh = Hr(Hl),
    Os = B({}, Hl, { dataTransfer: 0 }),
    va = Hr(Os),
    _f = B({}, Ar, { relatedTarget: 0 }),
    Sf = Hr(_f),
    wf = B({}, ks, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    jm = Hr(wf),
    $m = B({}, ks, {
      clipboardData: function (a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      },
    }),
    Mh = Hr($m),
    Mf = B({}, ks, { data: 0 }),
    bh = Hr(Mf),
    Xm = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    Ym = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    Eh = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function Gl(a) {
    var c = this.nativeEvent;
    return c.getModifierState
      ? c.getModifierState(a)
      : (a = Eh[a])
      ? !!c[a]
      : !1;
  }
  function ya() {
    return Gl;
  }
  var bf = B({}, Ar, {
      key: function (a) {
        if (a.key) {
          var c = Xm[a.key] || a.key;
          if (c !== "Unidentified") return c;
        }
        return a.type === "keypress"
          ? ((a = Ls(a)), a === 13 ? "Enter" : String.fromCharCode(a))
          : a.type === "keydown" || a.type === "keyup"
          ? Ym[a.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: ya,
      charCode: function (a) {
        return a.type === "keypress" ? Ls(a) : 0;
      },
      keyCode: function (a) {
        return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      },
      which: function (a) {
        return a.type === "keypress"
          ? Ls(a)
          : a.type === "keydown" || a.type === "keyup"
          ? a.keyCode
          : 0;
      },
    }),
    Ef = Hr(bf),
    wo = B({}, Hl, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    ro = Hr(wo),
    Ya = B({}, Ar, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: ya,
    }),
    Ns = Hr(Ya),
    Us = B({}, ks, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    qa = Hr(Us),
    qm = B({}, Hl, {
      deltaX: function (a) {
        return "deltaX" in a
          ? a.deltaX
          : "wheelDeltaX" in a
          ? -a.wheelDeltaX
          : 0;
      },
      deltaY: function (a) {
        return "deltaY" in a
          ? a.deltaY
          : "wheelDeltaY" in a
          ? -a.wheelDeltaY
          : "wheelDelta" in a
          ? -a.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    Th = Hr(qm),
    Ch = [9, 13, 27, 32],
    Si = l && "CompositionEvent" in window,
    ii = null;
  l && "documentMode" in document && (ii = document.documentMode);
  var Wn = l && "TextEvent" in window && !ii,
    Wl = l && (!Si || (ii && 8 < ii && 11 >= ii)),
    Mo = " ",
    Ah = !1;
  function Rh(a, c) {
    switch (a) {
      case "keyup":
        return Ch.indexOf(c.keyCode) !== -1;
      case "keydown":
        return c.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Tf(a) {
    return (a = a.detail), typeof a == "object" && "data" in a ? a.data : null;
  }
  var xa = !1;
  function Km(a, c) {
    switch (a) {
      case "compositionend":
        return Tf(c);
      case "keypress":
        return c.which !== 32 ? null : ((Ah = !0), Mo);
      case "textInput":
        return (a = c.data), a === Mo && Ah ? null : a;
      default:
        return null;
    }
  }
  function Xu(a, c) {
    if (xa)
      return a === "compositionend" || (!Si && Rh(a, c))
        ? ((a = Cr()), (Vr = Is = Ni = null), (xa = !1), a)
        : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(c.ctrlKey || c.altKey || c.metaKey) || (c.ctrlKey && c.altKey)) {
          if (c.char && 1 < c.char.length) return c.char;
          if (c.which) return String.fromCharCode(c.which);
        }
        return null;
      case "compositionend":
        return Wl && c.locale !== "ko" ? null : c.data;
      default:
        return null;
    }
  }
  var jl = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function Cf(a) {
    var c = a && a.nodeName && a.nodeName.toLowerCase();
    return c === "input" ? !!jl[a.type] : c === "textarea";
  }
  function $l(a, c, v, b) {
    gt(b),
      (c = Ff(c, "onChange")),
      0 < c.length &&
        ((v = new vr("onChange", "change", null, v, b)),
        a.push({ event: v, listeners: c }));
  }
  var _a = null,
    Xl = null;
  function Zm(a) {
    Zl(a, 0);
  }
  function Fs(a) {
    var c = ar(a);
    if (W(c)) return a;
  }
  function Jm(a, c) {
    if (a === "change") return c;
  }
  var Yl = !1;
  if (l) {
    var Fi;
    if (l) {
      var Ka = "oninput" in document;
      if (!Ka) {
        var Za = document.createElement("div");
        Za.setAttribute("oninput", "return;"),
          (Ka = typeof Za.oninput == "function");
      }
      Fi = Ka;
    } else Fi = !1;
    Yl = Fi && (!document.documentMode || 9 < document.documentMode);
  }
  function Ho() {
    _a && (_a.detachEvent("onpropertychange", Af), (Xl = _a = null));
  }
  function Af(a) {
    if (a.propertyName === "value" && Fs(Xl)) {
      var c = [];
      $l(c, Xl, a, He(a)), an(Zm, c);
    }
  }
  function ql(a, c, v) {
    a === "focusin"
      ? (Ho(), (_a = c), (Xl = v), _a.attachEvent("onpropertychange", Af))
      : a === "focusout" && Ho();
  }
  function Qm(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return Fs(Xl);
  }
  function Ph(a, c) {
    if (a === "click") return Fs(c);
  }
  function qn(a, c) {
    if (a === "input" || a === "change") return Fs(c);
  }
  function Rf(a, c) {
    return (a === c && (a !== 0 || 1 / a === 1 / c)) || (a !== a && c !== c);
  }
  var io = typeof Object.is == "function" ? Object.is : Rf;
  function Ja(a, c) {
    if (io(a, c)) return !0;
    if (
      typeof a != "object" ||
      a === null ||
      typeof c != "object" ||
      c === null
    )
      return !1;
    var v = Object.keys(a),
      b = Object.keys(c);
    if (v.length !== b.length) return !1;
    for (b = 0; b < v.length; b++) {
      var P = v[b];
      if (!u.call(c, P) || !io(a[P], c[P])) return !1;
    }
    return !0;
  }
  function Yu(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function oo(a, c) {
    var v = Yu(a);
    a = 0;
    for (var b; v; ) {
      if (v.nodeType === 3) {
        if (((b = a + v.textContent.length), a <= c && b >= c))
          return { node: v, offset: c - a };
        a = b;
      }
      e: {
        for (; v; ) {
          if (v.nextSibling) {
            v = v.nextSibling;
            break e;
          }
          v = v.parentNode;
        }
        v = void 0;
      }
      v = Yu(v);
    }
  }
  function Qa(a, c) {
    return a && c
      ? a === c
        ? !0
        : a && a.nodeType === 3
        ? !1
        : c && c.nodeType === 3
        ? Qa(a, c.parentNode)
        : "contains" in a
        ? a.contains(c)
        : a.compareDocumentPosition
        ? !!(a.compareDocumentPosition(c) & 16)
        : !1
      : !1;
  }
  function Kn() {
    for (var a = window, c = _e(); c instanceof a.HTMLIFrameElement; ) {
      try {
        var v = typeof c.contentWindow.location.href == "string";
      } catch {
        v = !1;
      }
      if (v) a = c.contentWindow;
      else break;
      c = _e(a.document);
    }
    return c;
  }
  function Gr(a) {
    var c = a && a.nodeName && a.nodeName.toLowerCase();
    return (
      c &&
      ((c === "input" &&
        (a.type === "text" ||
          a.type === "search" ||
          a.type === "tel" ||
          a.type === "url" ||
          a.type === "password")) ||
        c === "textarea" ||
        a.contentEditable === "true")
    );
  }
  function Wr(a) {
    var c = Kn(),
      v = a.focusedElem,
      b = a.selectionRange;
    if (
      c !== v &&
      v &&
      v.ownerDocument &&
      Qa(v.ownerDocument.documentElement, v)
    ) {
      if (b !== null && Gr(v)) {
        if (
          ((c = b.start),
          (a = b.end),
          a === void 0 && (a = c),
          "selectionStart" in v)
        )
          (v.selectionStart = c),
            (v.selectionEnd = Math.min(a, v.value.length));
        else if (
          ((a = ((c = v.ownerDocument || document) && c.defaultView) || window),
          a.getSelection)
        ) {
          a = a.getSelection();
          var P = v.textContent.length,
            N = Math.min(b.start, P);
          (b = b.end === void 0 ? N : Math.min(b.end, P)),
            !a.extend && N > b && ((P = b), (b = N), (N = P)),
            (P = oo(v, N));
          var X = oo(v, b);
          P &&
            X &&
            (a.rangeCount !== 1 ||
              a.anchorNode !== P.node ||
              a.anchorOffset !== P.offset ||
              a.focusNode !== X.node ||
              a.focusOffset !== X.offset) &&
            ((c = c.createRange()),
            c.setStart(P.node, P.offset),
            a.removeAllRanges(),
            N > b
              ? (a.addRange(c), a.extend(X.node, X.offset))
              : (c.setEnd(X.node, X.offset), a.addRange(c)));
        }
      }
      for (c = [], a = v; (a = a.parentNode); )
        a.nodeType === 1 &&
          c.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      for (typeof v.focus == "function" && v.focus(), v = 0; v < c.length; v++)
        (a = c[v]),
          (a.element.scrollLeft = a.left),
          (a.element.scrollTop = a.top);
    }
  }
  var Pf = l && "documentMode" in document && 11 >= document.documentMode,
    ds = null,
    el = null,
    qu = null,
    jr = !1;
  function If(a, c, v) {
    var b =
      v.window === v ? v.document : v.nodeType === 9 ? v : v.ownerDocument;
    jr ||
      ds == null ||
      ds !== _e(b) ||
      ((b = ds),
      "selectionStart" in b && Gr(b)
        ? (b = { start: b.selectionStart, end: b.selectionEnd })
        : ((b = (
            (b.ownerDocument && b.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (b = {
            anchorNode: b.anchorNode,
            anchorOffset: b.anchorOffset,
            focusNode: b.focusNode,
            focusOffset: b.focusOffset,
          })),
      (qu && Ja(qu, b)) ||
        ((qu = b),
        (b = Ff(el, "onSelect")),
        0 < b.length &&
          ((c = new vr("onSelect", "select", null, c, v)),
          a.push({ event: c, listeners: b }),
          (c.target = ds))));
  }
  function Kl(a, c) {
    var v = {};
    return (
      (v[a.toLowerCase()] = c.toLowerCase()),
      (v["Webkit" + a] = "webkit" + c),
      (v["Moz" + a] = "moz" + c),
      v
    );
  }
  var Sa = {
      animationend: Kl("Animation", "AnimationEnd"),
      animationiteration: Kl("Animation", "AnimationIteration"),
      animationstart: Kl("Animation", "AnimationStart"),
      transitionend: Kl("Transition", "TransitionEnd"),
    },
    Go = {},
    Wo = {};
  l &&
    ((Wo = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete Sa.animationend.animation,
      delete Sa.animationiteration.animation,
      delete Sa.animationstart.animation),
    "TransitionEvent" in window || delete Sa.transitionend.transition);
  function hs(a) {
    if (Go[a]) return Go[a];
    if (!Sa[a]) return a;
    var c = Sa[a],
      v;
    for (v in c) if (c.hasOwnProperty(v) && v in Wo) return (Go[a] = c[v]);
    return a;
  }
  var Ku = hs("animationend"),
    Zu = hs("animationiteration"),
    Ih = hs("animationstart"),
    Lh = hs("transitionend"),
    Dh = new Map(),
    kh =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  function zs(a, c) {
    Dh.set(a, c), o(c, [a]);
  }
  for (var Lf = 0; Lf < kh.length; Lf++) {
    var Ju = kh[Lf],
      Qu = Ju.toLowerCase(),
      eg = Ju[0].toUpperCase() + Ju.slice(1);
    zs(Qu, "on" + eg);
  }
  zs(Ku, "onAnimationEnd"),
    zs(Zu, "onAnimationIteration"),
    zs(Ih, "onAnimationStart"),
    zs("dblclick", "onDoubleClick"),
    zs("focusin", "onFocus"),
    zs("focusout", "onBlur"),
    zs(Lh, "onTransitionEnd"),
    s("onMouseEnter", ["mouseout", "mouseover"]),
    s("onMouseLeave", ["mouseout", "mouseover"]),
    s("onPointerEnter", ["pointerout", "pointerover"]),
    s("onPointerLeave", ["pointerout", "pointerover"]),
    o(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    o(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    o(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var wa =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    Df = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(wa)
    );
  function kf(a, c, v) {
    var b = a.type || "unknown-event";
    (a.currentTarget = v), Fl(b, c, void 0, a), (a.currentTarget = null);
  }
  function Zl(a, c) {
    c = (c & 4) !== 0;
    for (var v = 0; v < a.length; v++) {
      var b = a[v],
        P = b.event;
      b = b.listeners;
      e: {
        var N = void 0;
        if (c)
          for (var X = b.length - 1; 0 <= X; X--) {
            var fe = b[X],
              ge = fe.instance,
              je = fe.currentTarget;
            if (((fe = fe.listener), ge !== N && P.isPropagationStopped()))
              break e;
            kf(P, fe, je), (N = ge);
          }
        else
          for (X = 0; X < b.length; X++) {
            if (
              ((fe = b[X]),
              (ge = fe.instance),
              (je = fe.currentTarget),
              (fe = fe.listener),
              ge !== N && P.isPropagationStopped())
            )
              break e;
            kf(P, fe, je), (N = ge);
          }
      }
    }
    if (Er) throw ((a = Ur), (Er = !1), (Ur = null), a);
  }
  function On(a, c) {
    var v = c[rl];
    v === void 0 && (v = c[rl] = new Set());
    var b = a + "__bubble";
    v.has(b) || (Nf(c, a, 2, !1), v.add(b));
  }
  function Of(a, c, v) {
    var b = 0;
    c && (b |= 4), Nf(v, a, b, c);
  }
  var ec = "_reactListening" + Math.random().toString(36).slice(2);
  function Jl(a) {
    if (!a[ec]) {
      (a[ec] = !0),
        r.forEach(function (v) {
          v !== "selectionchange" && (Df.has(v) || Of(v, !1, a), Of(v, !0, a));
        });
      var c = a.nodeType === 9 ? a : a.ownerDocument;
      c === null || c[ec] || ((c[ec] = !0), Of("selectionchange", !1, c));
    }
  }
  function Nf(a, c, v, b) {
    switch (ga(c)) {
      case 1:
        var P = fs;
        break;
      case 4:
        P = _o;
        break;
      default:
        P = Xa;
    }
    (v = P.bind(null, c, v, a)),
      (P = void 0),
      !mn ||
        (c !== "touchstart" && c !== "touchmove" && c !== "wheel") ||
        (P = !0),
      b
        ? P !== void 0
          ? a.addEventListener(c, v, { capture: !0, passive: P })
          : a.addEventListener(c, v, !0)
        : P !== void 0
        ? a.addEventListener(c, v, { passive: P })
        : a.addEventListener(c, v, !1);
  }
  function Uf(a, c, v, b, P) {
    var N = b;
    if ((c & 1) === 0 && (c & 2) === 0 && b !== null)
      e: for (;;) {
        if (b === null) return;
        var X = b.tag;
        if (X === 3 || X === 4) {
          var fe = b.stateNode.containerInfo;
          if (fe === P || (fe.nodeType === 8 && fe.parentNode === P)) break;
          if (X === 4)
            for (X = b.return; X !== null; ) {
              var ge = X.tag;
              if (
                (ge === 3 || ge === 4) &&
                ((ge = X.stateNode.containerInfo),
                ge === P || (ge.nodeType === 8 && ge.parentNode === P))
              )
                return;
              X = X.return;
            }
          for (; fe !== null; ) {
            if (((X = Ma(fe)), X === null)) return;
            if (((ge = X.tag), ge === 5 || ge === 6)) {
              b = N = X;
              continue e;
            }
            fe = fe.parentNode;
          }
        }
        b = b.return;
      }
    an(function () {
      var je = N,
        st = He(v),
        lt = [];
      e: {
        var ot = Dh.get(a);
        if (ot !== void 0) {
          var bt = vr,
            Rt = a;
          switch (a) {
            case "keypress":
              if (Ls(v) === 0) break e;
            case "keydown":
            case "keyup":
              bt = Ef;
              break;
            case "focusin":
              (Rt = "focus"), (bt = Sf);
              break;
            case "focusout":
              (Rt = "blur"), (bt = Sf);
              break;
            case "beforeblur":
            case "afterblur":
              bt = Sf;
              break;
            case "click":
              if (v.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              bt = wh;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              bt = va;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              bt = Ns;
              break;
            case Ku:
            case Zu:
            case Ih:
              bt = jm;
              break;
            case Lh:
              bt = qa;
              break;
            case "scroll":
              bt = sr;
              break;
            case "wheel":
              bt = Th;
              break;
            case "copy":
            case "cut":
            case "paste":
              bt = Mh;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              bt = ro;
          }
          var It = (c & 4) !== 0,
            Ir = !It && a === "scroll",
            De = It ? (ot !== null ? ot + "Capture" : null) : ot;
          It = [];
          for (var Se = je, Oe; Se !== null; ) {
            Oe = Se;
            var ft = Oe.stateNode;
            if (
              (Oe.tag === 5 &&
                ft !== null &&
                ((Oe = ft),
                De !== null &&
                  ((ft = _n(Se, De)), ft != null && It.push(Ql(Se, ft, Oe)))),
              Ir)
            )
              break;
            Se = Se.return;
          }
          0 < It.length &&
            ((ot = new bt(ot, Rt, null, v, st)),
            lt.push({ event: ot, listeners: It }));
        }
      }
      if ((c & 7) === 0) {
        e: {
          if (
            ((ot = a === "mouseover" || a === "pointerover"),
            (bt = a === "mouseout" || a === "pointerout"),
            ot &&
              v !== de &&
              (Rt = v.relatedTarget || v.fromElement) &&
              (Ma(Rt) || Rt[so]))
          )
            break e;
          if (
            (bt || ot) &&
            ((ot =
              st.window === st
                ? st
                : (ot = st.ownerDocument)
                ? ot.defaultView || ot.parentWindow
                : window),
            bt
              ? ((Rt = v.relatedTarget || v.toElement),
                (bt = je),
                (Rt = Rt ? Ma(Rt) : null),
                Rt !== null &&
                  ((Ir = eo(Rt)),
                  Rt !== Ir || (Rt.tag !== 5 && Rt.tag !== 6)) &&
                  (Rt = null))
              : ((bt = null), (Rt = je)),
            bt !== Rt)
          ) {
            if (
              ((It = wh),
              (ft = "onMouseLeave"),
              (De = "onMouseEnter"),
              (Se = "mouse"),
              (a === "pointerout" || a === "pointerover") &&
                ((It = ro),
                (ft = "onPointerLeave"),
                (De = "onPointerEnter"),
                (Se = "pointer")),
              (Ir = bt == null ? ot : ar(bt)),
              (Oe = Rt == null ? ot : ar(Rt)),
              (ot = new It(ft, Se + "leave", bt, v, st)),
              (ot.target = Ir),
              (ot.relatedTarget = Oe),
              (ft = null),
              Ma(st) === je &&
                ((It = new It(De, Se + "enter", Rt, v, st)),
                (It.target = Oe),
                (It.relatedTarget = Ir),
                (ft = It)),
              (Ir = ft),
              bt && Rt)
            )
              t: {
                for (It = bt, De = Rt, Se = 0, Oe = It; Oe; Oe = tl(Oe)) Se++;
                for (Oe = 0, ft = De; ft; ft = tl(ft)) Oe++;
                for (; 0 < Se - Oe; ) (It = tl(It)), Se--;
                for (; 0 < Oe - Se; ) (De = tl(De)), Oe--;
                for (; Se--; ) {
                  if (It === De || (De !== null && It === De.alternate))
                    break t;
                  (It = tl(It)), (De = tl(De));
                }
                It = null;
              }
            else It = null;
            bt !== null && tg(lt, ot, bt, It, !1),
              Rt !== null && Ir !== null && tg(lt, Ir, Rt, It, !0);
          }
        }
        e: {
          if (
            ((ot = je ? ar(je) : window),
            (bt = ot.nodeName && ot.nodeName.toLowerCase()),
            bt === "select" || (bt === "input" && ot.type === "file"))
          )
            var kt = Jm;
          else if (Cf(ot))
            if (Yl) kt = qn;
            else {
              kt = Qm;
              var Vt = ql;
            }
          else
            (bt = ot.nodeName) &&
              bt.toLowerCase() === "input" &&
              (ot.type === "checkbox" || ot.type === "radio") &&
              (kt = Ph);
          if (kt && (kt = kt(a, je))) {
            $l(lt, kt, v, st);
            break e;
          }
          Vt && Vt(a, ot, je),
            a === "focusout" &&
              (Vt = ot._wrapperState) &&
              Vt.controlled &&
              ot.type === "number" &&
              Xe(ot, "number", ot.value);
        }
        switch (((Vt = je ? ar(je) : window), a)) {
          case "focusin":
            (Cf(Vt) || Vt.contentEditable === "true") &&
              ((ds = Vt), (el = je), (qu = null));
            break;
          case "focusout":
            qu = el = ds = null;
            break;
          case "mousedown":
            jr = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (jr = !1), If(lt, v, st);
            break;
          case "selectionchange":
            if (Pf) break;
          case "keydown":
          case "keyup":
            If(lt, v, st);
        }
        var Ht;
        if (Si)
          e: {
            switch (a) {
              case "compositionstart":
                var Yt = "onCompositionStart";
                break e;
              case "compositionend":
                Yt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Yt = "onCompositionUpdate";
                break e;
            }
            Yt = void 0;
          }
        else
          xa
            ? Rh(a, v) && (Yt = "onCompositionEnd")
            : a === "keydown" &&
              v.keyCode === 229 &&
              (Yt = "onCompositionStart");
        Yt &&
          (Wl &&
            v.locale !== "ko" &&
            (xa || Yt !== "onCompositionStart"
              ? Yt === "onCompositionEnd" && xa && (Ht = Cr())
              : ((Ni = st),
                (Is = "value" in Ni ? Ni.value : Ni.textContent),
                (xa = !0))),
          (Vt = Ff(je, Yt)),
          0 < Vt.length &&
            ((Yt = new bh(Yt, a, null, v, st)),
            lt.push({ event: Yt, listeners: Vt }),
            Ht
              ? (Yt.data = Ht)
              : ((Ht = Tf(v)), Ht !== null && (Yt.data = Ht)))),
          (Ht = Wn ? Km(a, v) : Xu(a, v)) &&
            ((je = Ff(je, "onBeforeInput")),
            0 < je.length &&
              ((st = new bh("onBeforeInput", "beforeinput", null, v, st)),
              lt.push({ event: st, listeners: je }),
              (st.data = Ht)));
      }
      Zl(lt, c);
    });
  }
  function Ql(a, c, v) {
    return { instance: a, listener: c, currentTarget: v };
  }
  function Ff(a, c) {
    for (var v = c + "Capture", b = []; a !== null; ) {
      var P = a,
        N = P.stateNode;
      P.tag === 5 &&
        N !== null &&
        ((P = N),
        (N = _n(a, v)),
        N != null && b.unshift(Ql(a, N, P)),
        (N = _n(a, c)),
        N != null && b.push(Ql(a, N, P))),
        (a = a.return);
    }
    return b;
  }
  function tl(a) {
    if (a === null) return null;
    do a = a.return;
    while (a && a.tag !== 5);
    return a || null;
  }
  function tg(a, c, v, b, P) {
    for (var N = c._reactName, X = []; v !== null && v !== b; ) {
      var fe = v,
        ge = fe.alternate,
        je = fe.stateNode;
      if (ge !== null && ge === b) break;
      fe.tag === 5 &&
        je !== null &&
        ((fe = je),
        P
          ? ((ge = _n(v, N)), ge != null && X.unshift(Ql(v, ge, fe)))
          : P || ((ge = _n(v, N)), ge != null && X.push(Ql(v, ge, fe)))),
        (v = v.return);
    }
    X.length !== 0 && a.push({ event: c, listeners: X });
  }
  var Yy = /\r\n?/g,
    ng = /\u0000|\uFFFD/g;
  function Oh(a) {
    return (typeof a == "string" ? a : "" + a)
      .replace(
        Yy,
        `
`
      )
      .replace(ng, "");
  }
  function tc(a, c, v) {
    if (((c = Oh(c)), Oh(a) !== c && v)) throw Error(t(425));
  }
  function nc() {}
  var eu = null,
    Nh = null;
  function Uh(a, c) {
    return (
      a === "textarea" ||
      a === "noscript" ||
      typeof c.children == "string" ||
      typeof c.children == "number" ||
      (typeof c.dangerouslySetInnerHTML == "object" &&
        c.dangerouslySetInnerHTML !== null &&
        c.dangerouslySetInnerHTML.__html != null)
    );
  }
  var Fh = typeof setTimeout == "function" ? setTimeout : void 0,
    zh = typeof clearTimeout == "function" ? clearTimeout : void 0,
    zf = typeof Promise == "function" ? Promise : void 0,
    qy =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof zf < "u"
        ? function (a) {
            return zf.resolve(null).then(a).catch(rg);
          }
        : Fh;
  function rg(a) {
    setTimeout(function () {
      throw a;
    });
  }
  function Bf(a, c) {
    var v = c,
      b = 0;
    do {
      var P = v.nextSibling;
      if ((a.removeChild(v), P && P.nodeType === 8))
        if (((v = P.data), v === "/$")) {
          if (b === 0) {
            a.removeChild(P), pa(c);
            return;
          }
          b--;
        } else (v !== "$" && v !== "$?" && v !== "$!") || b++;
      v = P;
    } while (v);
    pa(c);
  }
  function Bs(a) {
    for (; a != null; a = a.nextSibling) {
      var c = a.nodeType;
      if (c === 1 || c === 3) break;
      if (c === 8) {
        if (((c = a.data), c === "$" || c === "$!" || c === "$?")) break;
        if (c === "/$") return null;
      }
    }
    return a;
  }
  function Bh(a) {
    a = a.previousSibling;
    for (var c = 0; a; ) {
      if (a.nodeType === 8) {
        var v = a.data;
        if (v === "$" || v === "$!" || v === "$?") {
          if (c === 0) return a;
          c--;
        } else v === "/$" && c++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var nl = Math.random().toString(36).slice(2),
    Rr = "__reactFiber$" + nl,
    tu = "__reactProps$" + nl,
    so = "__reactContainer$" + nl,
    rl = "__reactEvents$" + nl,
    Vf = "__reactListeners$" + nl,
    Hf = "__reactHandles$" + nl;
  function Ma(a) {
    var c = a[Rr];
    if (c) return c;
    for (var v = a.parentNode; v; ) {
      if ((c = v[so] || v[Rr])) {
        if (
          ((v = c.alternate),
          c.child !== null || (v !== null && v.child !== null))
        )
          for (a = Bh(a); a !== null; ) {
            if ((v = a[Rr])) return v;
            a = Bh(a);
          }
        return c;
      }
      (a = v), (v = a.parentNode);
    }
    return null;
  }
  function Vs(a) {
    return (
      (a = a[Rr] || a[so]),
      !a || (a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3)
        ? null
        : a
    );
  }
  function ar(a) {
    if (a.tag === 5 || a.tag === 6) return a.stateNode;
    throw Error(t(33));
  }
  function Gf(a) {
    return a[tu] || null;
  }
  var Vh = [],
    $r = -1;
  function Qn(a) {
    return { current: a };
  }
  function Nn(a) {
    0 > $r || ((a.current = Vh[$r]), (Vh[$r] = null), $r--);
  }
  function Dn(a, c) {
    $r++, (Vh[$r] = a.current), (a.current = c);
  }
  var Hs = {},
    oi = Qn(Hs),
    wi = Qn(!1),
    Gs = Hs;
  function il(a, c) {
    var v = a.type.contextTypes;
    if (!v) return Hs;
    var b = a.stateNode;
    if (b && b.__reactInternalMemoizedUnmaskedChildContext === c)
      return b.__reactInternalMemoizedMaskedChildContext;
    var P = {},
      N;
    for (N in v) P[N] = c[N];
    return (
      b &&
        ((a = a.stateNode),
        (a.__reactInternalMemoizedUnmaskedChildContext = c),
        (a.__reactInternalMemoizedMaskedChildContext = P)),
      P
    );
  }
  function hi(a) {
    return (a = a.childContextTypes), a != null;
  }
  function rc() {
    Nn(wi), Nn(oi);
  }
  function Hh(a, c, v) {
    if (oi.current !== Hs) throw Error(t(168));
    Dn(oi, c), Dn(wi, v);
  }
  function ic(a, c, v) {
    var b = a.stateNode;
    if (((c = c.childContextTypes), typeof b.getChildContext != "function"))
      return v;
    b = b.getChildContext();
    for (var P in b) if (!(P in c)) throw Error(t(108, ae(a) || "Unknown", P));
    return B({}, v, b);
  }
  function ol(a) {
    return (
      (a =
        ((a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext) ||
        Hs),
      (Gs = oi.current),
      Dn(oi, a),
      Dn(wi, wi.current),
      !0
    );
  }
  function Gh(a, c, v) {
    var b = a.stateNode;
    if (!b) throw Error(t(169));
    v
      ? ((a = ic(a, c, Gs)),
        (b.__reactInternalMemoizedMergedChildContext = a),
        Nn(wi),
        Nn(oi),
        Dn(oi, a))
      : Nn(wi),
      Dn(wi, v);
  }
  var jo = null,
    oc = !1,
    Wf = !1;
  function sc(a) {
    jo === null ? (jo = [a]) : jo.push(a);
  }
  function ig(a) {
    (oc = !0), sc(a);
  }
  function ps() {
    if (!Wf && jo !== null) {
      Wf = !0;
      var a = 0,
        c = sn;
      try {
        var v = jo;
        for (sn = 1; a < v.length; a++) {
          var b = v[a];
          do b = b(!0);
          while (b !== null);
        }
        (jo = null), (oc = !1);
      } catch (P) {
        throw (jo !== null && (jo = jo.slice(a + 1)), Ie(Ut, ps), P);
      } finally {
        (sn = c), (Wf = !1);
      }
    }
    return null;
  }
  var sl = [],
    zi = 0,
    jf = null,
    $f = 0,
    Mi = [],
    Xr = 0,
    al = null,
    pt = 1,
    bo = "";
  function Ws(a, c) {
    (sl[zi++] = $f), (sl[zi++] = jf), (jf = a), ($f = c);
  }
  function Wh(a, c, v) {
    (Mi[Xr++] = pt), (Mi[Xr++] = bo), (Mi[Xr++] = al), (al = a);
    var b = pt;
    a = bo;
    var P = 32 - Zt(b) - 1;
    (b &= ~(1 << P)), (v += 1);
    var N = 32 - Zt(c) + P;
    if (30 < N) {
      var X = P - (P % 5);
      (N = (b & ((1 << X) - 1)).toString(32)),
        (b >>= X),
        (P -= X),
        (pt = (1 << (32 - Zt(c) + P)) | (v << P) | b),
        (bo = N + a);
    } else (pt = (1 << N) | (v << P) | b), (bo = a);
  }
  function jh(a) {
    a.return !== null && (Ws(a, 1), Wh(a, 1, 0));
  }
  function js(a) {
    for (; a === jf; )
      (jf = sl[--zi]), (sl[zi] = null), ($f = sl[--zi]), (sl[zi] = null);
    for (; a === al; )
      (al = Mi[--Xr]),
        (Mi[Xr] = null),
        (bo = Mi[--Xr]),
        (Mi[Xr] = null),
        (pt = Mi[--Xr]),
        (Mi[Xr] = null);
  }
  var si = null,
    bi = null,
    Vn = !1,
    Eo = null;
  function $h(a, c) {
    var v = _s(5, null, null, 0);
    (v.elementType = "DELETED"),
      (v.stateNode = c),
      (v.return = a),
      (c = a.deletions),
      c === null ? ((a.deletions = [v]), (a.flags |= 16)) : c.push(v);
  }
  function Xh(a, c) {
    switch (a.tag) {
      case 5:
        var v = a.type;
        return (
          (c =
            c.nodeType !== 1 || v.toLowerCase() !== c.nodeName.toLowerCase()
              ? null
              : c),
          c !== null
            ? ((a.stateNode = c), (si = a), (bi = Bs(c.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (c = a.pendingProps === "" || c.nodeType !== 3 ? null : c),
          c !== null ? ((a.stateNode = c), (si = a), (bi = null), !0) : !1
        );
      case 13:
        return (
          (c = c.nodeType !== 8 ? null : c),
          c !== null
            ? ((v = al !== null ? { id: pt, overflow: bo } : null),
              (a.memoizedState = {
                dehydrated: c,
                treeContext: v,
                retryLane: 1073741824,
              }),
              (v = _s(18, null, null, 0)),
              (v.stateNode = c),
              (v.return = a),
              (a.child = v),
              (si = a),
              (bi = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function Xf(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function Yf(a) {
    if (Vn) {
      var c = bi;
      if (c) {
        var v = c;
        if (!Xh(a, c)) {
          if (Xf(a)) throw Error(t(418));
          c = Bs(v.nextSibling);
          var b = si;
          c && Xh(a, c)
            ? $h(b, v)
            : ((a.flags = (a.flags & -4097) | 2), (Vn = !1), (si = a));
        }
      } else {
        if (Xf(a)) throw Error(t(418));
        (a.flags = (a.flags & -4097) | 2), (Vn = !1), (si = a);
      }
    }
  }
  function qf(a) {
    for (
      a = a.return;
      a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13;

    )
      a = a.return;
    si = a;
  }
  function nu(a) {
    if (a !== si) return !1;
    if (!Vn) return qf(a), (Vn = !0), !1;
    var c;
    if (
      ((c = a.tag !== 3) &&
        !(c = a.tag !== 5) &&
        ((c = a.type),
        (c = c !== "head" && c !== "body" && !Uh(a.type, a.memoizedProps))),
      c && (c = bi))
    ) {
      if (Xf(a)) throw (Yh(), Error(t(418)));
      for (; c; ) $h(a, c), (c = Bs(c.nextSibling));
    }
    if ((qf(a), a.tag === 13)) {
      if (((a = a.memoizedState), (a = a !== null ? a.dehydrated : null), !a))
        throw Error(t(317));
      e: {
        for (a = a.nextSibling, c = 0; a; ) {
          if (a.nodeType === 8) {
            var v = a.data;
            if (v === "/$") {
              if (c === 0) {
                bi = Bs(a.nextSibling);
                break e;
              }
              c--;
            } else (v !== "$" && v !== "$!" && v !== "$?") || c++;
          }
          a = a.nextSibling;
        }
        bi = null;
      }
    } else bi = si ? Bs(a.stateNode.nextSibling) : null;
    return !0;
  }
  function Yh() {
    for (var a = bi; a; ) a = Bs(a.nextSibling);
  }
  function ba() {
    (bi = si = null), (Vn = !1);
  }
  function ru(a) {
    Eo === null ? (Eo = [a]) : Eo.push(a);
  }
  var Ky = A.ReactCurrentBatchConfig;
  function $o(a, c) {
    if (a && a.defaultProps) {
      (c = B({}, c)), (a = a.defaultProps);
      for (var v in a) c[v] === void 0 && (c[v] = a[v]);
      return c;
    }
    return c;
  }
  var ac = Qn(null),
    lc = null,
    ll = null,
    Kf = null;
  function iu() {
    Kf = ll = lc = null;
  }
  function ou(a) {
    var c = ac.current;
    Nn(ac), (a._currentValue = c);
  }
  function su(a, c, v) {
    for (; a !== null; ) {
      var b = a.alternate;
      if (
        ((a.childLanes & c) !== c
          ? ((a.childLanes |= c), b !== null && (b.childLanes |= c))
          : b !== null && (b.childLanes & c) !== c && (b.childLanes |= c),
        a === v)
      )
        break;
      a = a.return;
    }
  }
  function $s(a, c) {
    (lc = a),
      (Kf = ll = null),
      (a = a.dependencies),
      a !== null &&
        a.firstContext !== null &&
        ((a.lanes & c) !== 0 && (Mt = !0), (a.firstContext = null));
  }
  function Ei(a) {
    var c = a._currentValue;
    if (Kf !== a)
      if (((a = { context: a, memoizedValue: c, next: null }), ll === null)) {
        if (lc === null) throw Error(t(308));
        (ll = a), (lc.dependencies = { lanes: 0, firstContext: a });
      } else ll = ll.next = a;
    return c;
  }
  var Xo = null;
  function uc(a) {
    Xo === null ? (Xo = [a]) : Xo.push(a);
  }
  function Zf(a, c, v, b) {
    var P = c.interleaved;
    return (
      P === null ? ((v.next = v), uc(c)) : ((v.next = P.next), (P.next = v)),
      (c.interleaved = v),
      Yo(a, b)
    );
  }
  function Yo(a, c) {
    a.lanes |= c;
    var v = a.alternate;
    for (v !== null && (v.lanes |= c), v = a, a = a.return; a !== null; )
      (a.childLanes |= c),
        (v = a.alternate),
        v !== null && (v.childLanes |= c),
        (v = a),
        (a = a.return);
    return v.tag === 3 ? v.stateNode : null;
  }
  var Xs = !1;
  function cc(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function og(a, c) {
    (a = a.updateQueue),
      c.updateQueue === a &&
        (c.updateQueue = {
          baseState: a.baseState,
          firstBaseUpdate: a.firstBaseUpdate,
          lastBaseUpdate: a.lastBaseUpdate,
          shared: a.shared,
          effects: a.effects,
        });
  }
  function To(a, c) {
    return {
      eventTime: a,
      lane: c,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function ms(a, c, v) {
    var b = a.updateQueue;
    if (b === null) return null;
    if (((b = b.shared), (gn & 2) !== 0)) {
      var P = b.pending;
      return (
        P === null ? (c.next = c) : ((c.next = P.next), (P.next = c)),
        (b.pending = c),
        Yo(a, v)
      );
    }
    return (
      (P = b.interleaved),
      P === null ? ((c.next = c), uc(b)) : ((c.next = P.next), (P.next = c)),
      (b.interleaved = c),
      Yo(a, v)
    );
  }
  function jn(a, c, v) {
    if (
      ((c = c.updateQueue), c !== null && ((c = c.shared), (v & 4194240) !== 0))
    ) {
      var b = c.lanes;
      (b &= a.pendingLanes), (v |= b), (c.lanes = v), zo(a, v);
    }
  }
  function nn(a, c) {
    var v = a.updateQueue,
      b = a.alternate;
    if (b !== null && ((b = b.updateQueue), v === b)) {
      var P = null,
        N = null;
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var X = {
            eventTime: v.eventTime,
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null,
          };
          N === null ? (P = N = X) : (N = N.next = X), (v = v.next);
        } while (v !== null);
        N === null ? (P = N = c) : (N = N.next = c);
      } else P = N = c;
      (v = {
        baseState: b.baseState,
        firstBaseUpdate: P,
        lastBaseUpdate: N,
        shared: b.shared,
        effects: b.effects,
      }),
        (a.updateQueue = v);
      return;
    }
    (a = v.lastBaseUpdate),
      a === null ? (v.firstBaseUpdate = c) : (a.next = c),
      (v.lastBaseUpdate = c);
  }
  function Zn(a, c, v, b) {
    var P = a.updateQueue;
    Xs = !1;
    var N = P.firstBaseUpdate,
      X = P.lastBaseUpdate,
      fe = P.shared.pending;
    if (fe !== null) {
      P.shared.pending = null;
      var ge = fe,
        je = ge.next;
      (ge.next = null), X === null ? (N = je) : (X.next = je), (X = ge);
      var st = a.alternate;
      st !== null &&
        ((st = st.updateQueue),
        (fe = st.lastBaseUpdate),
        fe !== X &&
          (fe === null ? (st.firstBaseUpdate = je) : (fe.next = je),
          (st.lastBaseUpdate = ge)));
    }
    if (N !== null) {
      var lt = P.baseState;
      (X = 0), (st = je = ge = null), (fe = N);
      do {
        var ot = fe.lane,
          bt = fe.eventTime;
        if ((b & ot) === ot) {
          st !== null &&
            (st = st.next =
              {
                eventTime: bt,
                lane: 0,
                tag: fe.tag,
                payload: fe.payload,
                callback: fe.callback,
                next: null,
              });
          e: {
            var Rt = a,
              It = fe;
            switch (((ot = c), (bt = v), It.tag)) {
              case 1:
                if (((Rt = It.payload), typeof Rt == "function")) {
                  lt = Rt.call(bt, lt, ot);
                  break e;
                }
                lt = Rt;
                break e;
              case 3:
                Rt.flags = (Rt.flags & -65537) | 128;
              case 0:
                if (
                  ((Rt = It.payload),
                  (ot = typeof Rt == "function" ? Rt.call(bt, lt, ot) : Rt),
                  ot == null)
                )
                  break e;
                lt = B({}, lt, ot);
                break e;
              case 2:
                Xs = !0;
            }
          }
          fe.callback !== null &&
            fe.lane !== 0 &&
            ((a.flags |= 64),
            (ot = P.effects),
            ot === null ? (P.effects = [fe]) : ot.push(fe));
        } else
          (bt = {
            eventTime: bt,
            lane: ot,
            tag: fe.tag,
            payload: fe.payload,
            callback: fe.callback,
            next: null,
          }),
            st === null ? ((je = st = bt), (ge = lt)) : (st = st.next = bt),
            (X |= ot);
        if (((fe = fe.next), fe === null)) {
          if (((fe = P.shared.pending), fe === null)) break;
          (ot = fe),
            (fe = ot.next),
            (ot.next = null),
            (P.lastBaseUpdate = ot),
            (P.shared.pending = null);
        }
      } while (!0);
      if (
        (st === null && (ge = lt),
        (P.baseState = ge),
        (P.firstBaseUpdate = je),
        (P.lastBaseUpdate = st),
        (c = P.shared.interleaved),
        c !== null)
      ) {
        P = c;
        do (X |= P.lane), (P = P.next);
        while (P !== c);
      } else N === null && (P.shared.lanes = 0);
      (vc |= X), (a.lanes = X), (a.memoizedState = lt);
    }
  }
  function lr(a, c, v) {
    if (((a = c.effects), (c.effects = null), a !== null))
      for (c = 0; c < a.length; c++) {
        var b = a[c],
          P = b.callback;
        if (P !== null) {
          if (((b.callback = null), (b = v), typeof P != "function"))
            throw Error(t(191, P));
          P.call(b);
        }
      }
  }
  var Yr = new n.Component().refs;
  function Ti(a, c, v, b) {
    (c = a.memoizedState),
      (v = v(b, c)),
      (v = v == null ? c : B({}, c, v)),
      (a.memoizedState = v),
      a.lanes === 0 && (a.updateQueue.baseState = v);
  }
  var Ys = {
    isMounted: function (a) {
      return (a = a._reactInternals) ? eo(a) === a : !1;
    },
    enqueueSetState: function (a, c, v) {
      a = a._reactInternals;
      var b = co(),
        P = vu(a),
        N = To(b, P);
      (N.payload = c),
        v != null && (N.callback = v),
        (c = ms(a, N, P)),
        c !== null && (Js(c, a, P, b), jn(c, a, P));
    },
    enqueueReplaceState: function (a, c, v) {
      a = a._reactInternals;
      var b = co(),
        P = vu(a),
        N = To(b, P);
      (N.tag = 1),
        (N.payload = c),
        v != null && (N.callback = v),
        (c = ms(a, N, P)),
        c !== null && (Js(c, a, P, b), jn(c, a, P));
    },
    enqueueForceUpdate: function (a, c) {
      a = a._reactInternals;
      var v = co(),
        b = vu(a),
        P = To(v, b);
      (P.tag = 2),
        c != null && (P.callback = c),
        (c = ms(a, P, b)),
        c !== null && (Js(c, a, b, v), jn(c, a, b));
    },
  };
  function yr(a, c, v, b, P, N, X) {
    return (
      (a = a.stateNode),
      typeof a.shouldComponentUpdate == "function"
        ? a.shouldComponentUpdate(b, N, X)
        : c.prototype && c.prototype.isPureReactComponent
        ? !Ja(v, b) || !Ja(P, N)
        : !0
    );
  }
  function au(a, c, v) {
    var b = !1,
      P = Hs,
      N = c.contextType;
    return (
      typeof N == "object" && N !== null
        ? (N = Ei(N))
        : ((P = hi(c) ? Gs : oi.current),
          (b = c.contextTypes),
          (N = (b = b != null) ? il(a, P) : Hs)),
      (c = new c(v, N)),
      (a.memoizedState =
        c.state !== null && c.state !== void 0 ? c.state : null),
      (c.updater = Ys),
      (a.stateNode = c),
      (c._reactInternals = a),
      b &&
        ((a = a.stateNode),
        (a.__reactInternalMemoizedUnmaskedChildContext = P),
        (a.__reactInternalMemoizedMaskedChildContext = N)),
      c
    );
  }
  function ul(a, c, v, b) {
    (a = c.state),
      typeof c.componentWillReceiveProps == "function" &&
        c.componentWillReceiveProps(v, b),
      typeof c.UNSAFE_componentWillReceiveProps == "function" &&
        c.UNSAFE_componentWillReceiveProps(v, b),
      c.state !== a && Ys.enqueueReplaceState(c, c.state, null);
  }
  function lu(a, c, v, b) {
    var P = a.stateNode;
    (P.props = v), (P.state = a.memoizedState), (P.refs = Yr), cc(a);
    var N = c.contextType;
    typeof N == "object" && N !== null
      ? (P.context = Ei(N))
      : ((N = hi(c) ? Gs : oi.current), (P.context = il(a, N))),
      (P.state = a.memoizedState),
      (N = c.getDerivedStateFromProps),
      typeof N == "function" && (Ti(a, c, N, v), (P.state = a.memoizedState)),
      typeof c.getDerivedStateFromProps == "function" ||
        typeof P.getSnapshotBeforeUpdate == "function" ||
        (typeof P.UNSAFE_componentWillMount != "function" &&
          typeof P.componentWillMount != "function") ||
        ((c = P.state),
        typeof P.componentWillMount == "function" && P.componentWillMount(),
        typeof P.UNSAFE_componentWillMount == "function" &&
          P.UNSAFE_componentWillMount(),
        c !== P.state && Ys.enqueueReplaceState(P, P.state, null),
        Zn(a, v, P, b),
        (P.state = a.memoizedState)),
      typeof P.componentDidMount == "function" && (a.flags |= 4194308);
  }
  function cl(a, c, v) {
    if (
      ((a = v.ref),
      a !== null && typeof a != "function" && typeof a != "object")
    ) {
      if (v._owner) {
        if (((v = v._owner), v)) {
          if (v.tag !== 1) throw Error(t(309));
          var b = v.stateNode;
        }
        if (!b) throw Error(t(147, a));
        var P = b,
          N = "" + a;
        return c !== null &&
          c.ref !== null &&
          typeof c.ref == "function" &&
          c.ref._stringRef === N
          ? c.ref
          : ((c = function (X) {
              var fe = P.refs;
              fe === Yr && (fe = P.refs = {}),
                X === null ? delete fe[N] : (fe[N] = X);
            }),
            (c._stringRef = N),
            c);
      }
      if (typeof a != "string") throw Error(t(284));
      if (!v._owner) throw Error(t(290, a));
    }
    return a;
  }
  function Ea(a, c) {
    throw (
      ((a = Object.prototype.toString.call(c)),
      Error(
        t(
          31,
          a === "[object Object]"
            ? "object with keys {" + Object.keys(c).join(", ") + "}"
            : a
        )
      ))
    );
  }
  function Ci(a) {
    var c = a._init;
    return c(a._payload);
  }
  function Jf(a) {
    function c(De, Se) {
      if (a) {
        var Oe = De.deletions;
        Oe === null ? ((De.deletions = [Se]), (De.flags |= 16)) : Oe.push(Se);
      }
    }
    function v(De, Se) {
      if (!a) return null;
      for (; Se !== null; ) c(De, Se), (Se = Se.sibling);
      return null;
    }
    function b(De, Se) {
      for (De = new Map(); Se !== null; )
        Se.key !== null ? De.set(Se.key, Se) : De.set(Se.index, Se),
          (Se = Se.sibling);
      return De;
    }
    function P(De, Se) {
      return (De = xu(De, Se)), (De.index = 0), (De.sibling = null), De;
    }
    function N(De, Se, Oe) {
      return (
        (De.index = Oe),
        a
          ? ((Oe = De.alternate),
            Oe !== null
              ? ((Oe = Oe.index), Oe < Se ? ((De.flags |= 2), Se) : Oe)
              : ((De.flags |= 2), Se))
          : ((De.flags |= 1048576), Se)
      );
    }
    function X(De) {
      return a && De.alternate === null && (De.flags |= 2), De;
    }
    function fe(De, Se, Oe, ft) {
      return Se === null || Se.tag !== 6
        ? ((Se = mx(Oe, De.mode, ft)), (Se.return = De), Se)
        : ((Se = P(Se, Oe)), (Se.return = De), Se);
    }
    function ge(De, Se, Oe, ft) {
      var kt = Oe.type;
      return kt === I
        ? st(De, Se, Oe.props.children, ft, Oe.key)
        : Se !== null &&
          (Se.elementType === kt ||
            (typeof kt == "object" &&
              kt !== null &&
              kt.$$typeof === Y &&
              Ci(kt) === Se.type))
        ? ((ft = P(Se, Oe.props)),
          (ft.ref = cl(De, Se, Oe)),
          (ft.return = De),
          ft)
        : ((ft = Rg(Oe.type, Oe.key, Oe.props, null, De.mode, ft)),
          (ft.ref = cl(De, Se, Oe)),
          (ft.return = De),
          ft);
    }
    function je(De, Se, Oe, ft) {
      return Se === null ||
        Se.tag !== 4 ||
        Se.stateNode.containerInfo !== Oe.containerInfo ||
        Se.stateNode.implementation !== Oe.implementation
        ? ((Se = gx(Oe, De.mode, ft)), (Se.return = De), Se)
        : ((Se = P(Se, Oe.children || [])), (Se.return = De), Se);
    }
    function st(De, Se, Oe, ft, kt) {
      return Se === null || Se.tag !== 7
        ? ((Se = Sc(Oe, De.mode, ft, kt)), (Se.return = De), Se)
        : ((Se = P(Se, Oe)), (Se.return = De), Se);
    }
    function lt(De, Se, Oe) {
      if ((typeof Se == "string" && Se !== "") || typeof Se == "number")
        return (Se = mx("" + Se, De.mode, Oe)), (Se.return = De), Se;
      if (typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case R:
            return (
              (Oe = Rg(Se.type, Se.key, Se.props, null, De.mode, Oe)),
              (Oe.ref = cl(De, null, Se)),
              (Oe.return = De),
              Oe
            );
          case D:
            return (Se = gx(Se, De.mode, Oe)), (Se.return = De), Se;
          case Y:
            var ft = Se._init;
            return lt(De, ft(Se._payload), Oe);
        }
        if (Z(Se) || re(Se))
          return (Se = Sc(Se, De.mode, Oe, null)), (Se.return = De), Se;
        Ea(De, Se);
      }
      return null;
    }
    function ot(De, Se, Oe, ft) {
      var kt = Se !== null ? Se.key : null;
      if ((typeof Oe == "string" && Oe !== "") || typeof Oe == "number")
        return kt !== null ? null : fe(De, Se, "" + Oe, ft);
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case R:
            return Oe.key === kt ? ge(De, Se, Oe, ft) : null;
          case D:
            return Oe.key === kt ? je(De, Se, Oe, ft) : null;
          case Y:
            return (kt = Oe._init), ot(De, Se, kt(Oe._payload), ft);
        }
        if (Z(Oe) || re(Oe))
          return kt !== null ? null : st(De, Se, Oe, ft, null);
        Ea(De, Oe);
      }
      return null;
    }
    function bt(De, Se, Oe, ft, kt) {
      if ((typeof ft == "string" && ft !== "") || typeof ft == "number")
        return (De = De.get(Oe) || null), fe(Se, De, "" + ft, kt);
      if (typeof ft == "object" && ft !== null) {
        switch (ft.$$typeof) {
          case R:
            return (
              (De = De.get(ft.key === null ? Oe : ft.key) || null),
              ge(Se, De, ft, kt)
            );
          case D:
            return (
              (De = De.get(ft.key === null ? Oe : ft.key) || null),
              je(Se, De, ft, kt)
            );
          case Y:
            var Vt = ft._init;
            return bt(De, Se, Oe, Vt(ft._payload), kt);
        }
        if (Z(ft) || re(ft))
          return (De = De.get(Oe) || null), st(Se, De, ft, kt, null);
        Ea(Se, ft);
      }
      return null;
    }
    function Rt(De, Se, Oe, ft) {
      for (
        var kt = null, Vt = null, Ht = Se, Yt = (Se = 0), gi = null;
        Ht !== null && Yt < Oe.length;
        Yt++
      ) {
        Ht.index > Yt ? ((gi = Ht), (Ht = null)) : (gi = Ht.sibling);
        var bn = ot(De, Ht, Oe[Yt], ft);
        if (bn === null) {
          Ht === null && (Ht = gi);
          break;
        }
        a && Ht && bn.alternate === null && c(De, Ht),
          (Se = N(bn, Se, Yt)),
          Vt === null ? (kt = bn) : (Vt.sibling = bn),
          (Vt = bn),
          (Ht = gi);
      }
      if (Yt === Oe.length) return v(De, Ht), Vn && Ws(De, Yt), kt;
      if (Ht === null) {
        for (; Yt < Oe.length; Yt++)
          (Ht = lt(De, Oe[Yt], ft)),
            Ht !== null &&
              ((Se = N(Ht, Se, Yt)),
              Vt === null ? (kt = Ht) : (Vt.sibling = Ht),
              (Vt = Ht));
        return Vn && Ws(De, Yt), kt;
      }
      for (Ht = b(De, Ht); Yt < Oe.length; Yt++)
        (gi = bt(Ht, De, Yt, Oe[Yt], ft)),
          gi !== null &&
            (a &&
              gi.alternate !== null &&
              Ht.delete(gi.key === null ? Yt : gi.key),
            (Se = N(gi, Se, Yt)),
            Vt === null ? (kt = gi) : (Vt.sibling = gi),
            (Vt = gi));
      return (
        a &&
          Ht.forEach(function (_u) {
            return c(De, _u);
          }),
        Vn && Ws(De, Yt),
        kt
      );
    }
    function It(De, Se, Oe, ft) {
      var kt = re(Oe);
      if (typeof kt != "function") throw Error(t(150));
      if (((Oe = kt.call(Oe)), Oe == null)) throw Error(t(151));
      for (
        var Vt = (kt = null), Ht = Se, Yt = (Se = 0), gi = null, bn = Oe.next();
        Ht !== null && !bn.done;
        Yt++, bn = Oe.next()
      ) {
        Ht.index > Yt ? ((gi = Ht), (Ht = null)) : (gi = Ht.sibling);
        var _u = ot(De, Ht, bn.value, ft);
        if (_u === null) {
          Ht === null && (Ht = gi);
          break;
        }
        a && Ht && _u.alternate === null && c(De, Ht),
          (Se = N(_u, Se, Yt)),
          Vt === null ? (kt = _u) : (Vt.sibling = _u),
          (Vt = _u),
          (Ht = gi);
      }
      if (bn.done) return v(De, Ht), Vn && Ws(De, Yt), kt;
      if (Ht === null) {
        for (; !bn.done; Yt++, bn = Oe.next())
          (bn = lt(De, bn.value, ft)),
            bn !== null &&
              ((Se = N(bn, Se, Yt)),
              Vt === null ? (kt = bn) : (Vt.sibling = bn),
              (Vt = bn));
        return Vn && Ws(De, Yt), kt;
      }
      for (Ht = b(De, Ht); !bn.done; Yt++, bn = Oe.next())
        (bn = bt(Ht, De, Yt, bn.value, ft)),
          bn !== null &&
            (a &&
              bn.alternate !== null &&
              Ht.delete(bn.key === null ? Yt : bn.key),
            (Se = N(bn, Se, Yt)),
            Vt === null ? (kt = bn) : (Vt.sibling = bn),
            (Vt = bn));
      return (
        a &&
          Ht.forEach(function (LP) {
            return c(De, LP);
          }),
        Vn && Ws(De, Yt),
        kt
      );
    }
    function Ir(De, Se, Oe, ft) {
      if (
        (typeof Oe == "object" &&
          Oe !== null &&
          Oe.type === I &&
          Oe.key === null &&
          (Oe = Oe.props.children),
        typeof Oe == "object" && Oe !== null)
      ) {
        switch (Oe.$$typeof) {
          case R:
            e: {
              for (var kt = Oe.key, Vt = Se; Vt !== null; ) {
                if (Vt.key === kt) {
                  if (((kt = Oe.type), kt === I)) {
                    if (Vt.tag === 7) {
                      v(De, Vt.sibling),
                        (Se = P(Vt, Oe.props.children)),
                        (Se.return = De),
                        (De = Se);
                      break e;
                    }
                  } else if (
                    Vt.elementType === kt ||
                    (typeof kt == "object" &&
                      kt !== null &&
                      kt.$$typeof === Y &&
                      Ci(kt) === Vt.type)
                  ) {
                    v(De, Vt.sibling),
                      (Se = P(Vt, Oe.props)),
                      (Se.ref = cl(De, Vt, Oe)),
                      (Se.return = De),
                      (De = Se);
                    break e;
                  }
                  v(De, Vt);
                  break;
                } else c(De, Vt);
                Vt = Vt.sibling;
              }
              Oe.type === I
                ? ((Se = Sc(Oe.props.children, De.mode, ft, Oe.key)),
                  (Se.return = De),
                  (De = Se))
                : ((ft = Rg(Oe.type, Oe.key, Oe.props, null, De.mode, ft)),
                  (ft.ref = cl(De, Se, Oe)),
                  (ft.return = De),
                  (De = ft));
            }
            return X(De);
          case D:
            e: {
              for (Vt = Oe.key; Se !== null; ) {
                if (Se.key === Vt)
                  if (
                    Se.tag === 4 &&
                    Se.stateNode.containerInfo === Oe.containerInfo &&
                    Se.stateNode.implementation === Oe.implementation
                  ) {
                    v(De, Se.sibling),
                      (Se = P(Se, Oe.children || [])),
                      (Se.return = De),
                      (De = Se);
                    break e;
                  } else {
                    v(De, Se);
                    break;
                  }
                else c(De, Se);
                Se = Se.sibling;
              }
              (Se = gx(Oe, De.mode, ft)), (Se.return = De), (De = Se);
            }
            return X(De);
          case Y:
            return (Vt = Oe._init), Ir(De, Se, Vt(Oe._payload), ft);
        }
        if (Z(Oe)) return Rt(De, Se, Oe, ft);
        if (re(Oe)) return It(De, Se, Oe, ft);
        Ea(De, Oe);
      }
      return (typeof Oe == "string" && Oe !== "") || typeof Oe == "number"
        ? ((Oe = "" + Oe),
          Se !== null && Se.tag === 6
            ? (v(De, Se.sibling), (Se = P(Se, Oe)), (Se.return = De), (De = Se))
            : (v(De, Se),
              (Se = mx(Oe, De.mode, ft)),
              (Se.return = De),
              (De = Se)),
          X(De))
        : v(De, Se);
    }
    return Ir;
  }
  var Ta = Jf(!0),
    fl = Jf(!1),
    Ca = {},
    Co = Qn(Ca),
    Ao = Qn(Ca),
    Aa = Qn(Ca);
  function Bi(a) {
    if (a === Ca) throw Error(t(174));
    return a;
  }
  function uu(a, c) {
    switch ((Dn(Aa, c), Dn(Ao, a), Dn(Co, Ca), (a = c.nodeType), a)) {
      case 9:
      case 11:
        c = (c = c.documentElement) ? c.namespaceURI : Fe(null, "");
        break;
      default:
        (a = a === 8 ? c.parentNode : c),
          (c = a.namespaceURI || null),
          (a = a.tagName),
          (c = Fe(c, a));
    }
    Nn(Co), Dn(Co, c);
  }
  function gs() {
    Nn(Co), Nn(Ao), Nn(Aa);
  }
  function Qf(a) {
    Bi(Aa.current);
    var c = Bi(Co.current),
      v = Fe(c, a.type);
    c !== v && (Dn(Ao, a), Dn(Co, v));
  }
  function cu(a) {
    Ao.current === a && (Nn(Co), Nn(Ao));
  }
  var Un = Qn(0);
  function qr(a) {
    for (var c = a; c !== null; ) {
      if (c.tag === 13) {
        var v = c.memoizedState;
        if (
          v !== null &&
          ((v = v.dehydrated), v === null || v.data === "$?" || v.data === "$!")
        )
          return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if ((c.flags & 128) !== 0) return c;
      } else if (c.child !== null) {
        (c.child.return = c), (c = c.child);
        continue;
      }
      if (c === a) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === a) return null;
        c = c.return;
      }
      (c.sibling.return = c.return), (c = c.sibling);
    }
    return null;
  }
  var vs = [];
  function Vi() {
    for (var a = 0; a < vs.length; a++)
      vs[a]._workInProgressVersionPrimary = null;
    vs.length = 0;
  }
  var dl = A.ReactCurrentDispatcher,
    pi = A.ReactCurrentBatchConfig,
    Ra = 0,
    Hn = null,
    ur = null,
    Kr = null,
    qo = !1,
    fu = !1,
    du = 0,
    qh = 0;
  function er() {
    throw Error(t(321));
  }
  function ed(a, c) {
    if (c === null) return !1;
    for (var v = 0; v < c.length && v < a.length; v++)
      if (!io(a[v], c[v])) return !1;
    return !0;
  }
  function td(a, c, v, b, P, N) {
    if (
      ((Ra = N),
      (Hn = c),
      (c.memoizedState = null),
      (c.updateQueue = null),
      (c.lanes = 0),
      (dl.current = a === null || a.memoizedState === null ? p : M),
      (a = v(b, P)),
      fu)
    ) {
      N = 0;
      do {
        if (((fu = !1), (du = 0), 25 <= N)) throw Error(t(301));
        (N += 1),
          (Kr = ur = null),
          (c.updateQueue = null),
          (dl.current = C),
          (a = v(b, P));
      } while (fu);
    }
    if (
      ((dl.current = d),
      (c = ur !== null && ur.next !== null),
      (Ra = 0),
      (Kr = ur = Hn = null),
      (qo = !1),
      c)
    )
      throw Error(t(300));
    return a;
  }
  function fc() {
    var a = du !== 0;
    return (du = 0), a;
  }
  function ao() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Kr === null ? (Hn.memoizedState = Kr = a) : (Kr = Kr.next = a), Kr;
  }
  function Ro() {
    if (ur === null) {
      var a = Hn.alternate;
      a = a !== null ? a.memoizedState : null;
    } else a = ur.next;
    var c = Kr === null ? Hn.memoizedState : Kr.next;
    if (c !== null) (Kr = c), (ur = a);
    else {
      if (a === null) throw Error(t(310));
      (ur = a),
        (a = {
          memoizedState: ur.memoizedState,
          baseState: ur.baseState,
          baseQueue: ur.baseQueue,
          queue: ur.queue,
          next: null,
        }),
        Kr === null ? (Hn.memoizedState = Kr = a) : (Kr = Kr.next = a);
    }
    return Kr;
  }
  function dc(a, c) {
    return typeof c == "function" ? c(a) : c;
  }
  function nd(a) {
    var c = Ro(),
      v = c.queue;
    if (v === null) throw Error(t(311));
    v.lastRenderedReducer = a;
    var b = ur,
      P = b.baseQueue,
      N = v.pending;
    if (N !== null) {
      if (P !== null) {
        var X = P.next;
        (P.next = N.next), (N.next = X);
      }
      (b.baseQueue = P = N), (v.pending = null);
    }
    if (P !== null) {
      (N = P.next), (b = b.baseState);
      var fe = (X = null),
        ge = null,
        je = N;
      do {
        var st = je.lane;
        if ((Ra & st) === st)
          ge !== null &&
            (ge = ge.next =
              {
                lane: 0,
                action: je.action,
                hasEagerState: je.hasEagerState,
                eagerState: je.eagerState,
                next: null,
              }),
            (b = je.hasEagerState ? je.eagerState : a(b, je.action));
        else {
          var lt = {
            lane: st,
            action: je.action,
            hasEagerState: je.hasEagerState,
            eagerState: je.eagerState,
            next: null,
          };
          ge === null ? ((fe = ge = lt), (X = b)) : (ge = ge.next = lt),
            (Hn.lanes |= st),
            (vc |= st);
        }
        je = je.next;
      } while (je !== null && je !== N);
      ge === null ? (X = b) : (ge.next = fe),
        io(b, c.memoizedState) || (Mt = !0),
        (c.memoizedState = b),
        (c.baseState = X),
        (c.baseQueue = ge),
        (v.lastRenderedState = b);
    }
    if (((a = v.interleaved), a !== null)) {
      P = a;
      do (N = P.lane), (Hn.lanes |= N), (vc |= N), (P = P.next);
      while (P !== a);
    } else P === null && (v.lanes = 0);
    return [c.memoizedState, v.dispatch];
  }
  function rd(a) {
    var c = Ro(),
      v = c.queue;
    if (v === null) throw Error(t(311));
    v.lastRenderedReducer = a;
    var b = v.dispatch,
      P = v.pending,
      N = c.memoizedState;
    if (P !== null) {
      v.pending = null;
      var X = (P = P.next);
      do (N = a(N, X.action)), (X = X.next);
      while (X !== P);
      io(N, c.memoizedState) || (Mt = !0),
        (c.memoizedState = N),
        c.baseQueue === null && (c.baseState = N),
        (v.lastRenderedState = N);
    }
    return [N, b];
  }
  function Pa() {}
  function sg(a, c) {
    var v = Hn,
      b = Ro(),
      P = c(),
      N = !io(b.memoizedState, P);
    if (
      (N && ((b.memoizedState = P), (Mt = !0)),
      (b = b.queue),
      mc(Ai.bind(null, v, b, a), [a]),
      b.getSnapshot !== c || N || (Kr !== null && Kr.memoizedState.tag & 1))
    ) {
      if (
        ((v.flags |= 2048),
        hc(9, Kh.bind(null, v, b, P, c), void 0, null),
        mi === null)
      )
        throw Error(t(349));
      (Ra & 30) !== 0 || Ia(v, c, P);
    }
    return P;
  }
  function Ia(a, c, v) {
    (a.flags |= 16384),
      (a = { getSnapshot: c, value: v }),
      (c = Hn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (Hn.updateQueue = c),
          (c.stores = [a]))
        : ((v = c.stores), v === null ? (c.stores = [a]) : v.push(a));
  }
  function Kh(a, c, v, b) {
    (c.value = v), (c.getSnapshot = b), ag(c) && Zh(a);
  }
  function Ai(a, c, v) {
    return v(function () {
      ag(c) && Zh(a);
    });
  }
  function ag(a) {
    var c = a.getSnapshot;
    a = a.value;
    try {
      var v = c();
      return !io(a, v);
    } catch {
      return !0;
    }
  }
  function Zh(a) {
    var c = Yo(a, 1);
    c !== null && Js(c, a, 1, -1);
  }
  function lg(a) {
    var c = ao();
    return (
      typeof a == "function" && (a = a()),
      (c.memoizedState = c.baseState = a),
      (a = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: dc,
        lastRenderedState: a,
      }),
      (c.queue = a),
      (a = a.dispatch = hg.bind(null, Hn, a)),
      [c.memoizedState, a]
    );
  }
  function hc(a, c, v, b) {
    return (
      (a = { tag: a, create: c, destroy: v, deps: b, next: null }),
      (c = Hn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (Hn.updateQueue = c),
          (c.lastEffect = a.next = a))
        : ((v = c.lastEffect),
          v === null
            ? (c.lastEffect = a.next = a)
            : ((b = v.next), (v.next = a), (a.next = b), (c.lastEffect = a))),
      a
    );
  }
  function Jh() {
    return Ro().memoizedState;
  }
  function pc(a, c, v, b) {
    var P = ao();
    (Hn.flags |= a),
      (P.memoizedState = hc(1 | c, v, void 0, b === void 0 ? null : b));
  }
  function id(a, c, v, b) {
    var P = Ro();
    b = b === void 0 ? null : b;
    var N = void 0;
    if (ur !== null) {
      var X = ur.memoizedState;
      if (((N = X.destroy), b !== null && ed(b, X.deps))) {
        P.memoizedState = hc(c, v, N, b);
        return;
      }
    }
    (Hn.flags |= a), (P.memoizedState = hc(1 | c, v, N, b));
  }
  function lo(a, c) {
    return pc(8390656, 8, a, c);
  }
  function mc(a, c) {
    return id(2048, 8, a, c);
  }
  function ug(a, c) {
    return id(4, 2, a, c);
  }
  function qs(a, c) {
    return id(4, 4, a, c);
  }
  function gc(a, c) {
    if (typeof c == "function")
      return (
        (a = a()),
        c(a),
        function () {
          c(null);
        }
      );
    if (c != null)
      return (
        (a = a()),
        (c.current = a),
        function () {
          c.current = null;
        }
      );
  }
  function La(a, c, v) {
    return (
      (v = v != null ? v.concat([a]) : null), id(4, 4, gc.bind(null, c, a), v)
    );
  }
  function hu() {}
  function od(a, c) {
    var v = Ro();
    c = c === void 0 ? null : c;
    var b = v.memoizedState;
    return b !== null && c !== null && ed(c, b[1])
      ? b[0]
      : ((v.memoizedState = [a, c]), a);
  }
  function sd(a, c) {
    var v = Ro();
    c = c === void 0 ? null : c;
    var b = v.memoizedState;
    return b !== null && c !== null && ed(c, b[1])
      ? b[0]
      : ((a = a()), (v.memoizedState = [a, c]), a);
  }
  function cg(a, c, v) {
    return (Ra & 21) === 0
      ? (a.baseState && ((a.baseState = !1), (Mt = !0)), (a.memoizedState = v))
      : (io(v, c) ||
          ((v = ci()), (Hn.lanes |= v), (vc |= v), (a.baseState = !0)),
        c);
  }
  function fg(a, c) {
    var v = sn;
    (sn = v !== 0 && 4 > v ? v : 4), a(!0);
    var b = pi.transition;
    pi.transition = {};
    try {
      a(!1), c();
    } finally {
      (sn = v), (pi.transition = b);
    }
  }
  function Qh() {
    return Ro().memoizedState;
  }
  function dg(a, c, v) {
    var b = vu(a);
    if (
      ((v = {
        lane: b,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      ad(a))
    )
      pg(c, v);
    else if (((v = Zf(a, c, v, b)), v !== null)) {
      var P = co();
      Js(v, a, b, P), mg(v, c, b);
    }
  }
  function hg(a, c, v) {
    var b = vu(a),
      P = {
        lane: b,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (ad(a)) pg(c, P);
    else {
      var N = a.alternate;
      if (
        a.lanes === 0 &&
        (N === null || N.lanes === 0) &&
        ((N = c.lastRenderedReducer), N !== null)
      )
        try {
          var X = c.lastRenderedState,
            fe = N(X, v);
          if (((P.hasEagerState = !0), (P.eagerState = fe), io(fe, X))) {
            var ge = c.interleaved;
            ge === null
              ? ((P.next = P), uc(c))
              : ((P.next = ge.next), (ge.next = P)),
              (c.interleaved = P);
            return;
          }
        } catch {
        } finally {
        }
      (v = Zf(a, c, P, b)),
        v !== null && ((P = co()), Js(v, a, b, P), mg(v, c, b));
    }
  }
  function ad(a) {
    var c = a.alternate;
    return a === Hn || (c !== null && c === Hn);
  }
  function pg(a, c) {
    fu = qo = !0;
    var v = a.pending;
    v === null ? (c.next = c) : ((c.next = v.next), (v.next = c)),
      (a.pending = c);
  }
  function mg(a, c, v) {
    if ((v & 4194240) !== 0) {
      var b = c.lanes;
      (b &= a.pendingLanes), (v |= b), (c.lanes = v), zo(a, v);
    }
  }
  var d = {
      readContext: Ei,
      useCallback: er,
      useContext: er,
      useEffect: er,
      useImperativeHandle: er,
      useInsertionEffect: er,
      useLayoutEffect: er,
      useMemo: er,
      useReducer: er,
      useRef: er,
      useState: er,
      useDebugValue: er,
      useDeferredValue: er,
      useTransition: er,
      useMutableSource: er,
      useSyncExternalStore: er,
      useId: er,
      unstable_isNewReconciler: !1,
    },
    p = {
      readContext: Ei,
      useCallback: function (a, c) {
        return (ao().memoizedState = [a, c === void 0 ? null : c]), a;
      },
      useContext: Ei,
      useEffect: lo,
      useImperativeHandle: function (a, c, v) {
        return (
          (v = v != null ? v.concat([a]) : null),
          pc(4194308, 4, gc.bind(null, c, a), v)
        );
      },
      useLayoutEffect: function (a, c) {
        return pc(4194308, 4, a, c);
      },
      useInsertionEffect: function (a, c) {
        return pc(4, 2, a, c);
      },
      useMemo: function (a, c) {
        var v = ao();
        return (
          (c = c === void 0 ? null : c),
          (a = a()),
          (v.memoizedState = [a, c]),
          a
        );
      },
      useReducer: function (a, c, v) {
        var b = ao();
        return (
          (c = v !== void 0 ? v(c) : c),
          (b.memoizedState = b.baseState = c),
          (a = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: a,
            lastRenderedState: c,
          }),
          (b.queue = a),
          (a = a.dispatch = dg.bind(null, Hn, a)),
          [b.memoizedState, a]
        );
      },
      useRef: function (a) {
        var c = ao();
        return (a = { current: a }), (c.memoizedState = a);
      },
      useState: lg,
      useDebugValue: hu,
      useDeferredValue: function (a) {
        return (ao().memoizedState = a);
      },
      useTransition: function () {
        var a = lg(!1),
          c = a[0];
        return (a = fg.bind(null, a[1])), (ao().memoizedState = a), [c, a];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (a, c, v) {
        var b = Hn,
          P = ao();
        if (Vn) {
          if (v === void 0) throw Error(t(407));
          v = v();
        } else {
          if (((v = c()), mi === null)) throw Error(t(349));
          (Ra & 30) !== 0 || Ia(b, c, v);
        }
        P.memoizedState = v;
        var N = { value: v, getSnapshot: c };
        return (
          (P.queue = N),
          lo(Ai.bind(null, b, N, a), [a]),
          (b.flags |= 2048),
          hc(9, Kh.bind(null, b, N, v, c), void 0, null),
          v
        );
      },
      useId: function () {
        var a = ao(),
          c = mi.identifierPrefix;
        if (Vn) {
          var v = bo,
            b = pt;
          (v = (b & ~(1 << (32 - Zt(b) - 1))).toString(32) + v),
            (c = ":" + c + "R" + v),
            (v = du++),
            0 < v && (c += "H" + v.toString(32)),
            (c += ":");
        } else (v = qh++), (c = ":" + c + "r" + v.toString(32) + ":");
        return (a.memoizedState = c);
      },
      unstable_isNewReconciler: !1,
    },
    M = {
      readContext: Ei,
      useCallback: od,
      useContext: Ei,
      useEffect: mc,
      useImperativeHandle: La,
      useInsertionEffect: ug,
      useLayoutEffect: qs,
      useMemo: sd,
      useReducer: nd,
      useRef: Jh,
      useState: function () {
        return nd(dc);
      },
      useDebugValue: hu,
      useDeferredValue: function (a) {
        var c = Ro();
        return cg(c, ur.memoizedState, a);
      },
      useTransition: function () {
        var a = nd(dc)[0],
          c = Ro().memoizedState;
        return [a, c];
      },
      useMutableSource: Pa,
      useSyncExternalStore: sg,
      useId: Qh,
      unstable_isNewReconciler: !1,
    },
    C = {
      readContext: Ei,
      useCallback: od,
      useContext: Ei,
      useEffect: mc,
      useImperativeHandle: La,
      useInsertionEffect: ug,
      useLayoutEffect: qs,
      useMemo: sd,
      useReducer: rd,
      useRef: Jh,
      useState: function () {
        return rd(dc);
      },
      useDebugValue: hu,
      useDeferredValue: function (a) {
        var c = Ro();
        return ur === null ? (c.memoizedState = a) : cg(c, ur.memoizedState, a);
      },
      useTransition: function () {
        var a = rd(dc)[0],
          c = Ro().memoizedState;
        return [a, c];
      },
      useMutableSource: Pa,
      useSyncExternalStore: sg,
      useId: Qh,
      unstable_isNewReconciler: !1,
    };
  function k(a, c) {
    try {
      var v = "",
        b = c;
      do (v += oe(b)), (b = b.return);
      while (b);
      var P = v;
    } catch (N) {
      P =
        `
Error generating stack: ` +
        N.message +
        `
` +
        N.stack;
    }
    return { value: a, source: c, stack: P, digest: null };
  }
  function z(a, c, v) {
    return { value: a, source: null, stack: v ?? null, digest: c ?? null };
  }
  function se(a, c) {
    try {
      console.error(c.value);
    } catch (v) {
      setTimeout(function () {
        throw v;
      });
    }
  }
  var we = typeof WeakMap == "function" ? WeakMap : Map;
  function Qe(a, c, v) {
    (v = To(-1, v)), (v.tag = 3), (v.payload = { element: null });
    var b = c.value;
    return (
      (v.callback = function () {
        Mg || ((Mg = !0), (ax = b)), se(a, c);
      }),
      v
    );
  }
  function ct(a, c, v) {
    (v = To(-1, v)), (v.tag = 3);
    var b = a.type.getDerivedStateFromError;
    if (typeof b == "function") {
      var P = c.value;
      (v.payload = function () {
        return b(P);
      }),
        (v.callback = function () {
          se(a, c);
        });
    }
    var N = a.stateNode;
    return (
      N !== null &&
        typeof N.componentDidCatch == "function" &&
        (v.callback = function () {
          se(a, c),
            typeof b != "function" &&
              (mu === null ? (mu = new Set([this])) : mu.add(this));
          var X = c.stack;
          this.componentDidCatch(c.value, {
            componentStack: X !== null ? X : "",
          });
        }),
      v
    );
  }
  function Tt(a, c, v) {
    var b = a.pingCache;
    if (b === null) {
      b = a.pingCache = new we();
      var P = new Set();
      b.set(c, P);
    } else (P = b.get(c)), P === void 0 && ((P = new Set()), b.set(c, P));
    P.has(v) || (P.add(v), (a = SP.bind(null, a, c, v)), c.then(a, a));
  }
  function qt(a) {
    do {
      var c;
      if (
        ((c = a.tag === 13) &&
          ((c = a.memoizedState),
          (c = c !== null ? c.dehydrated !== null : !0)),
        c)
      )
        return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function zt(a, c, v, b, P) {
    return (a.mode & 1) === 0
      ? (a === c
          ? (a.flags |= 65536)
          : ((a.flags |= 128),
            (v.flags |= 131072),
            (v.flags &= -52805),
            v.tag === 1 &&
              (v.alternate === null
                ? (v.tag = 17)
                : ((c = To(-1, 1)), (c.tag = 2), ms(v, c, 1))),
            (v.lanes |= 1)),
        a)
      : ((a.flags |= 65536), (a.lanes = P), a);
  }
  var kn = A.ReactCurrentOwner,
    Mt = !1;
  function Mn(a, c, v, b) {
    c.child = a === null ? fl(c, null, v, b) : Ta(c, a.child, v, b);
  }
  function uo(a, c, v, b, P) {
    v = v.render;
    var N = c.ref;
    return (
      $s(c, P),
      (b = td(a, c, v, b, N, P)),
      (v = fc()),
      a !== null && !Mt
        ? ((c.updateQueue = a.updateQueue),
          (c.flags &= -2053),
          (a.lanes &= ~P),
          hl(a, c, P))
        : (Vn && v && jh(c), (c.flags |= 1), Mn(a, c, b, P), c.child)
    );
  }
  function Ve(a, c, v, b, P) {
    if (a === null) {
      var N = v.type;
      return typeof N == "function" &&
        !px(N) &&
        N.defaultProps === void 0 &&
        v.compare === null &&
        v.defaultProps === void 0
        ? ((c.tag = 15), (c.type = N), Re(a, c, N, b, P))
        : ((a = Rg(v.type, null, b, c, c.mode, P)),
          (a.ref = c.ref),
          (a.return = c),
          (c.child = a));
    }
    if (((N = a.child), (a.lanes & P) === 0)) {
      var X = N.memoizedProps;
      if (
        ((v = v.compare), (v = v !== null ? v : Ja), v(X, b) && a.ref === c.ref)
      )
        return hl(a, c, P);
    }
    return (
      (c.flags |= 1),
      (a = xu(N, b)),
      (a.ref = c.ref),
      (a.return = c),
      (c.child = a)
    );
  }
  function Re(a, c, v, b, P) {
    if (a !== null) {
      var N = a.memoizedProps;
      if (Ja(N, b) && a.ref === c.ref)
        if (((Mt = !1), (c.pendingProps = b = N), (a.lanes & P) !== 0))
          (a.flags & 131072) !== 0 && (Mt = !0);
        else return (c.lanes = a.lanes), hl(a, c, P);
    }
    return Pt(a, c, v, b, P);
  }
  function Ze(a, c, v) {
    var b = c.pendingProps,
      P = b.children,
      N = a !== null ? a.memoizedState : null;
    if (b.mode === "hidden")
      if ((c.mode & 1) === 0)
        (c.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          Dn(ud, Ko),
          (Ko |= v);
      else {
        if ((v & 1073741824) === 0)
          return (
            (a = N !== null ? N.baseLanes | v : v),
            (c.lanes = c.childLanes = 1073741824),
            (c.memoizedState = {
              baseLanes: a,
              cachePool: null,
              transitions: null,
            }),
            (c.updateQueue = null),
            Dn(ud, Ko),
            (Ko |= a),
            null
          );
        (c.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (b = N !== null ? N.baseLanes : v),
          Dn(ud, Ko),
          (Ko |= b);
      }
    else
      N !== null ? ((b = N.baseLanes | v), (c.memoizedState = null)) : (b = v),
        Dn(ud, Ko),
        (Ko |= b);
    return Mn(a, c, P, v), c.child;
  }
  function _t(a, c) {
    var v = c.ref;
    ((a === null && v !== null) || (a !== null && a.ref !== v)) &&
      ((c.flags |= 512), (c.flags |= 2097152));
  }
  function Pt(a, c, v, b, P) {
    var N = hi(v) ? Gs : oi.current;
    return (
      (N = il(c, N)),
      $s(c, P),
      (v = td(a, c, v, b, N, P)),
      (b = fc()),
      a !== null && !Mt
        ? ((c.updateQueue = a.updateQueue),
          (c.flags &= -2053),
          (a.lanes &= ~P),
          hl(a, c, P))
        : (Vn && b && jh(c), (c.flags |= 1), Mn(a, c, v, P), c.child)
    );
  }
  function Jt(a, c, v, b, P) {
    if (hi(v)) {
      var N = !0;
      ol(c);
    } else N = !1;
    if (($s(c, P), c.stateNode === null))
      yg(a, c), au(c, v, b), lu(c, v, b, P), (b = !0);
    else if (a === null) {
      var X = c.stateNode,
        fe = c.memoizedProps;
      X.props = fe;
      var ge = X.context,
        je = v.contextType;
      typeof je == "object" && je !== null
        ? (je = Ei(je))
        : ((je = hi(v) ? Gs : oi.current), (je = il(c, je)));
      var st = v.getDerivedStateFromProps,
        lt =
          typeof st == "function" ||
          typeof X.getSnapshotBeforeUpdate == "function";
      lt ||
        (typeof X.UNSAFE_componentWillReceiveProps != "function" &&
          typeof X.componentWillReceiveProps != "function") ||
        ((fe !== b || ge !== je) && ul(c, X, b, je)),
        (Xs = !1);
      var ot = c.memoizedState;
      (X.state = ot),
        Zn(c, b, X, P),
        (ge = c.memoizedState),
        fe !== b || ot !== ge || wi.current || Xs
          ? (typeof st == "function" &&
              (Ti(c, v, st, b), (ge = c.memoizedState)),
            (fe = Xs || yr(c, v, fe, b, ot, ge, je))
              ? (lt ||
                  (typeof X.UNSAFE_componentWillMount != "function" &&
                    typeof X.componentWillMount != "function") ||
                  (typeof X.componentWillMount == "function" &&
                    X.componentWillMount(),
                  typeof X.UNSAFE_componentWillMount == "function" &&
                    X.UNSAFE_componentWillMount()),
                typeof X.componentDidMount == "function" &&
                  (c.flags |= 4194308))
              : (typeof X.componentDidMount == "function" &&
                  (c.flags |= 4194308),
                (c.memoizedProps = b),
                (c.memoizedState = ge)),
            (X.props = b),
            (X.state = ge),
            (X.context = je),
            (b = fe))
          : (typeof X.componentDidMount == "function" && (c.flags |= 4194308),
            (b = !1));
    } else {
      (X = c.stateNode),
        og(a, c),
        (fe = c.memoizedProps),
        (je = c.type === c.elementType ? fe : $o(c.type, fe)),
        (X.props = je),
        (lt = c.pendingProps),
        (ot = X.context),
        (ge = v.contextType),
        typeof ge == "object" && ge !== null
          ? (ge = Ei(ge))
          : ((ge = hi(v) ? Gs : oi.current), (ge = il(c, ge)));
      var bt = v.getDerivedStateFromProps;
      (st =
        typeof bt == "function" ||
        typeof X.getSnapshotBeforeUpdate == "function") ||
        (typeof X.UNSAFE_componentWillReceiveProps != "function" &&
          typeof X.componentWillReceiveProps != "function") ||
        ((fe !== lt || ot !== ge) && ul(c, X, b, ge)),
        (Xs = !1),
        (ot = c.memoizedState),
        (X.state = ot),
        Zn(c, b, X, P);
      var Rt = c.memoizedState;
      fe !== lt || ot !== Rt || wi.current || Xs
        ? (typeof bt == "function" && (Ti(c, v, bt, b), (Rt = c.memoizedState)),
          (je = Xs || yr(c, v, je, b, ot, Rt, ge) || !1)
            ? (st ||
                (typeof X.UNSAFE_componentWillUpdate != "function" &&
                  typeof X.componentWillUpdate != "function") ||
                (typeof X.componentWillUpdate == "function" &&
                  X.componentWillUpdate(b, Rt, ge),
                typeof X.UNSAFE_componentWillUpdate == "function" &&
                  X.UNSAFE_componentWillUpdate(b, Rt, ge)),
              typeof X.componentDidUpdate == "function" && (c.flags |= 4),
              typeof X.getSnapshotBeforeUpdate == "function" &&
                (c.flags |= 1024))
            : (typeof X.componentDidUpdate != "function" ||
                (fe === a.memoizedProps && ot === a.memoizedState) ||
                (c.flags |= 4),
              typeof X.getSnapshotBeforeUpdate != "function" ||
                (fe === a.memoizedProps && ot === a.memoizedState) ||
                (c.flags |= 1024),
              (c.memoizedProps = b),
              (c.memoizedState = Rt)),
          (X.props = b),
          (X.state = Rt),
          (X.context = ge),
          (b = je))
        : (typeof X.componentDidUpdate != "function" ||
            (fe === a.memoizedProps && ot === a.memoizedState) ||
            (c.flags |= 4),
          typeof X.getSnapshotBeforeUpdate != "function" ||
            (fe === a.memoizedProps && ot === a.memoizedState) ||
            (c.flags |= 1024),
          (b = !1));
    }
    return Xt(a, c, v, b, N, P);
  }
  function Xt(a, c, v, b, P, N) {
    _t(a, c);
    var X = (c.flags & 128) !== 0;
    if (!b && !X) return P && Gh(c, v, !1), hl(a, c, N);
    (b = c.stateNode), (kn.current = c);
    var fe =
      X && typeof v.getDerivedStateFromError != "function" ? null : b.render();
    return (
      (c.flags |= 1),
      a !== null && X
        ? ((c.child = Ta(c, a.child, null, N)), (c.child = Ta(c, null, fe, N)))
        : Mn(a, c, fe, N),
      (c.memoizedState = b.state),
      P && Gh(c, v, !0),
      c.child
    );
  }
  function pn(a) {
    var c = a.stateNode;
    c.pendingContext
      ? Hh(a, c.pendingContext, c.pendingContext !== c.context)
      : c.context && Hh(a, c.context, !1),
      uu(a, c.containerInfo);
  }
  function Pr(a, c, v, b, P) {
    return ba(), ru(P), (c.flags |= 256), Mn(a, c, v, b), c.child;
  }
  var hn = { dehydrated: null, treeContext: null, retryLane: 0 };
  function ys(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function gg(a, c, v) {
    var b = c.pendingProps,
      P = Un.current,
      N = !1,
      X = (c.flags & 128) !== 0,
      fe;
    if (
      ((fe = X) ||
        (fe = a !== null && a.memoizedState === null ? !1 : (P & 2) !== 0),
      fe
        ? ((N = !0), (c.flags &= -129))
        : (a === null || a.memoizedState !== null) && (P |= 1),
      Dn(Un, P & 1),
      a === null)
    )
      return (
        Yf(c),
        (a = c.memoizedState),
        a !== null && ((a = a.dehydrated), a !== null)
          ? ((c.mode & 1) === 0
              ? (c.lanes = 1)
              : a.data === "$!"
              ? (c.lanes = 8)
              : (c.lanes = 1073741824),
            null)
          : ((X = b.children),
            (a = b.fallback),
            N
              ? ((b = c.mode),
                (N = c.child),
                (X = { mode: "hidden", children: X }),
                (b & 1) === 0 && N !== null
                  ? ((N.childLanes = 0), (N.pendingProps = X))
                  : (N = Pg(X, b, 0, null)),
                (a = Sc(a, b, v, null)),
                (N.return = c),
                (a.return = c),
                (N.sibling = a),
                (c.child = N),
                (c.child.memoizedState = ys(v)),
                (c.memoizedState = hn),
                a)
              : Zy(c, X))
      );
    if (
      ((P = a.memoizedState), P !== null && ((fe = P.dehydrated), fe !== null))
    )
      return uP(a, c, X, b, fe, P, v);
    if (N) {
      (N = b.fallback), (X = c.mode), (P = a.child), (fe = P.sibling);
      var ge = { mode: "hidden", children: b.children };
      return (
        (X & 1) === 0 && c.child !== P
          ? ((b = c.child),
            (b.childLanes = 0),
            (b.pendingProps = ge),
            (c.deletions = null))
          : ((b = xu(P, ge)), (b.subtreeFlags = P.subtreeFlags & 14680064)),
        fe !== null
          ? (N = xu(fe, N))
          : ((N = Sc(N, X, v, null)), (N.flags |= 2)),
        (N.return = c),
        (b.return = c),
        (b.sibling = N),
        (c.child = b),
        (b = N),
        (N = c.child),
        (X = a.child.memoizedState),
        (X =
          X === null
            ? ys(v)
            : {
                baseLanes: X.baseLanes | v,
                cachePool: null,
                transitions: X.transitions,
              }),
        (N.memoizedState = X),
        (N.childLanes = a.childLanes & ~v),
        (c.memoizedState = hn),
        b
      );
    }
    return (
      (N = a.child),
      (a = N.sibling),
      (b = xu(N, { mode: "visible", children: b.children })),
      (c.mode & 1) === 0 && (b.lanes = v),
      (b.return = c),
      (b.sibling = null),
      a !== null &&
        ((v = c.deletions),
        v === null ? ((c.deletions = [a]), (c.flags |= 16)) : v.push(a)),
      (c.child = b),
      (c.memoizedState = null),
      b
    );
  }
  function Zy(a, c) {
    return (
      (c = Pg({ mode: "visible", children: c }, a.mode, 0, null)),
      (c.return = a),
      (a.child = c)
    );
  }
  function vg(a, c, v, b) {
    return (
      b !== null && ru(b),
      Ta(c, a.child, null, v),
      (a = Zy(c, c.pendingProps.children)),
      (a.flags |= 2),
      (c.memoizedState = null),
      a
    );
  }
  function uP(a, c, v, b, P, N, X) {
    if (v)
      return c.flags & 256
        ? ((c.flags &= -257), (b = z(Error(t(422)))), vg(a, c, X, b))
        : c.memoizedState !== null
        ? ((c.child = a.child), (c.flags |= 128), null)
        : ((N = b.fallback),
          (P = c.mode),
          (b = Pg({ mode: "visible", children: b.children }, P, 0, null)),
          (N = Sc(N, P, X, null)),
          (N.flags |= 2),
          (b.return = c),
          (N.return = c),
          (b.sibling = N),
          (c.child = b),
          (c.mode & 1) !== 0 && Ta(c, a.child, null, X),
          (c.child.memoizedState = ys(X)),
          (c.memoizedState = hn),
          N);
    if ((c.mode & 1) === 0) return vg(a, c, X, null);
    if (P.data === "$!") {
      if (((b = P.nextSibling && P.nextSibling.dataset), b)) var fe = b.dgst;
      return (
        (b = fe), (N = Error(t(419))), (b = z(N, b, void 0)), vg(a, c, X, b)
      );
    }
    if (((fe = (X & a.childLanes) !== 0), Mt || fe)) {
      if (((b = mi), b !== null)) {
        switch (X & -X) {
          case 4:
            P = 2;
            break;
          case 16:
            P = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            P = 32;
            break;
          case 536870912:
            P = 268435456;
            break;
          default:
            P = 0;
        }
        (P = (P & (b.suspendedLanes | X)) !== 0 ? 0 : P),
          P !== 0 &&
            P !== N.retryLane &&
            ((N.retryLane = P), Yo(a, P), Js(b, a, P, -1));
      }
      return hx(), (b = z(Error(t(421)))), vg(a, c, X, b);
    }
    return P.data === "$?"
      ? ((c.flags |= 128),
        (c.child = a.child),
        (c = wP.bind(null, a)),
        (P._reactRetry = c),
        null)
      : ((a = N.treeContext),
        (bi = Bs(P.nextSibling)),
        (si = c),
        (Vn = !0),
        (Eo = null),
        a !== null &&
          ((Mi[Xr++] = pt),
          (Mi[Xr++] = bo),
          (Mi[Xr++] = al),
          (pt = a.id),
          (bo = a.overflow),
          (al = c)),
        (c = Zy(c, b.children)),
        (c.flags |= 4096),
        c);
  }
  function Sw(a, c, v) {
    a.lanes |= c;
    var b = a.alternate;
    b !== null && (b.lanes |= c), su(a.return, c, v);
  }
  function Jy(a, c, v, b, P) {
    var N = a.memoizedState;
    N === null
      ? (a.memoizedState = {
          isBackwards: c,
          rendering: null,
          renderingStartTime: 0,
          last: b,
          tail: v,
          tailMode: P,
        })
      : ((N.isBackwards = c),
        (N.rendering = null),
        (N.renderingStartTime = 0),
        (N.last = b),
        (N.tail = v),
        (N.tailMode = P));
  }
  function ww(a, c, v) {
    var b = c.pendingProps,
      P = b.revealOrder,
      N = b.tail;
    if ((Mn(a, c, b.children, v), (b = Un.current), (b & 2) !== 0))
      (b = (b & 1) | 2), (c.flags |= 128);
    else {
      if (a !== null && (a.flags & 128) !== 0)
        e: for (a = c.child; a !== null; ) {
          if (a.tag === 13) a.memoizedState !== null && Sw(a, v, c);
          else if (a.tag === 19) Sw(a, v, c);
          else if (a.child !== null) {
            (a.child.return = a), (a = a.child);
            continue;
          }
          if (a === c) break e;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === c) break e;
            a = a.return;
          }
          (a.sibling.return = a.return), (a = a.sibling);
        }
      b &= 1;
    }
    if ((Dn(Un, b), (c.mode & 1) === 0)) c.memoizedState = null;
    else
      switch (P) {
        case "forwards":
          for (v = c.child, P = null; v !== null; )
            (a = v.alternate),
              a !== null && qr(a) === null && (P = v),
              (v = v.sibling);
          (v = P),
            v === null
              ? ((P = c.child), (c.child = null))
              : ((P = v.sibling), (v.sibling = null)),
            Jy(c, !1, P, v, N);
          break;
        case "backwards":
          for (v = null, P = c.child, c.child = null; P !== null; ) {
            if (((a = P.alternate), a !== null && qr(a) === null)) {
              c.child = P;
              break;
            }
            (a = P.sibling), (P.sibling = v), (v = P), (P = a);
          }
          Jy(c, !0, v, null, N);
          break;
        case "together":
          Jy(c, !1, null, null, void 0);
          break;
        default:
          c.memoizedState = null;
      }
    return c.child;
  }
  function yg(a, c) {
    (c.mode & 1) === 0 &&
      a !== null &&
      ((a.alternate = null), (c.alternate = null), (c.flags |= 2));
  }
  function hl(a, c, v) {
    if (
      (a !== null && (c.dependencies = a.dependencies),
      (vc |= c.lanes),
      (v & c.childLanes) === 0)
    )
      return null;
    if (a !== null && c.child !== a.child) throw Error(t(153));
    if (c.child !== null) {
      for (
        a = c.child, v = xu(a, a.pendingProps), c.child = v, v.return = c;
        a.sibling !== null;

      )
        (a = a.sibling),
          (v = v.sibling = xu(a, a.pendingProps)),
          (v.return = c);
      v.sibling = null;
    }
    return c.child;
  }
  function cP(a, c, v) {
    switch (c.tag) {
      case 3:
        pn(c), ba();
        break;
      case 5:
        Qf(c);
        break;
      case 1:
        hi(c.type) && ol(c);
        break;
      case 4:
        uu(c, c.stateNode.containerInfo);
        break;
      case 10:
        var b = c.type._context,
          P = c.memoizedProps.value;
        Dn(ac, b._currentValue), (b._currentValue = P);
        break;
      case 13:
        if (((b = c.memoizedState), b !== null))
          return b.dehydrated !== null
            ? (Dn(Un, Un.current & 1), (c.flags |= 128), null)
            : (v & c.child.childLanes) !== 0
            ? gg(a, c, v)
            : (Dn(Un, Un.current & 1),
              (a = hl(a, c, v)),
              a !== null ? a.sibling : null);
        Dn(Un, Un.current & 1);
        break;
      case 19:
        if (((b = (v & c.childLanes) !== 0), (a.flags & 128) !== 0)) {
          if (b) return ww(a, c, v);
          c.flags |= 128;
        }
        if (
          ((P = c.memoizedState),
          P !== null &&
            ((P.rendering = null), (P.tail = null), (P.lastEffect = null)),
          Dn(Un, Un.current),
          b)
        )
          break;
        return null;
      case 22:
      case 23:
        return (c.lanes = 0), Ze(a, c, v);
    }
    return hl(a, c, v);
  }
  var Mw, Qy, bw, Ew;
  (Mw = function (a, c) {
    for (var v = c.child; v !== null; ) {
      if (v.tag === 5 || v.tag === 6) a.appendChild(v.stateNode);
      else if (v.tag !== 4 && v.child !== null) {
        (v.child.return = v), (v = v.child);
        continue;
      }
      if (v === c) break;
      for (; v.sibling === null; ) {
        if (v.return === null || v.return === c) return;
        v = v.return;
      }
      (v.sibling.return = v.return), (v = v.sibling);
    }
  }),
    (Qy = function () {}),
    (bw = function (a, c, v, b) {
      var P = a.memoizedProps;
      if (P !== b) {
        (a = c.stateNode), Bi(Co.current);
        var N = null;
        switch (v) {
          case "input":
            (P = Te(a, P)), (b = Te(a, b)), (N = []);
            break;
          case "select":
            (P = B({}, P, { value: void 0 })),
              (b = B({}, b, { value: void 0 })),
              (N = []);
            break;
          case "textarea":
            (P = me(a, P)), (b = me(a, b)), (N = []);
            break;
          default:
            typeof P.onClick != "function" &&
              typeof b.onClick == "function" &&
              (a.onclick = nc);
        }
        ce(v, b);
        var X;
        v = null;
        for (je in P)
          if (!b.hasOwnProperty(je) && P.hasOwnProperty(je) && P[je] != null)
            if (je === "style") {
              var fe = P[je];
              for (X in fe)
                fe.hasOwnProperty(X) && (v || (v = {}), (v[X] = ""));
            } else
              je !== "dangerouslySetInnerHTML" &&
                je !== "children" &&
                je !== "suppressContentEditableWarning" &&
                je !== "suppressHydrationWarning" &&
                je !== "autoFocus" &&
                (i.hasOwnProperty(je)
                  ? N || (N = [])
                  : (N = N || []).push(je, null));
        for (je in b) {
          var ge = b[je];
          if (
            ((fe = P != null ? P[je] : void 0),
            b.hasOwnProperty(je) && ge !== fe && (ge != null || fe != null))
          )
            if (je === "style")
              if (fe) {
                for (X in fe)
                  !fe.hasOwnProperty(X) ||
                    (ge && ge.hasOwnProperty(X)) ||
                    (v || (v = {}), (v[X] = ""));
                for (X in ge)
                  ge.hasOwnProperty(X) &&
                    fe[X] !== ge[X] &&
                    (v || (v = {}), (v[X] = ge[X]));
              } else v || (N || (N = []), N.push(je, v)), (v = ge);
            else
              je === "dangerouslySetInnerHTML"
                ? ((ge = ge ? ge.__html : void 0),
                  (fe = fe ? fe.__html : void 0),
                  ge != null && fe !== ge && (N = N || []).push(je, ge))
                : je === "children"
                ? (typeof ge != "string" && typeof ge != "number") ||
                  (N = N || []).push(je, "" + ge)
                : je !== "suppressContentEditableWarning" &&
                  je !== "suppressHydrationWarning" &&
                  (i.hasOwnProperty(je)
                    ? (ge != null && je === "onScroll" && On("scroll", a),
                      N || fe === ge || (N = []))
                    : (N = N || []).push(je, ge));
        }
        v && (N = N || []).push("style", v);
        var je = N;
        (c.updateQueue = je) && (c.flags |= 4);
      }
    }),
    (Ew = function (a, c, v, b) {
      v !== b && (c.flags |= 4);
    });
  function ep(a, c) {
    if (!Vn)
      switch (a.tailMode) {
        case "hidden":
          c = a.tail;
          for (var v = null; c !== null; )
            c.alternate !== null && (v = c), (c = c.sibling);
          v === null ? (a.tail = null) : (v.sibling = null);
          break;
        case "collapsed":
          v = a.tail;
          for (var b = null; v !== null; )
            v.alternate !== null && (b = v), (v = v.sibling);
          b === null
            ? c || a.tail === null
              ? (a.tail = null)
              : (a.tail.sibling = null)
            : (b.sibling = null);
      }
  }
  function Hi(a) {
    var c = a.alternate !== null && a.alternate.child === a.child,
      v = 0,
      b = 0;
    if (c)
      for (var P = a.child; P !== null; )
        (v |= P.lanes | P.childLanes),
          (b |= P.subtreeFlags & 14680064),
          (b |= P.flags & 14680064),
          (P.return = a),
          (P = P.sibling);
    else
      for (P = a.child; P !== null; )
        (v |= P.lanes | P.childLanes),
          (b |= P.subtreeFlags),
          (b |= P.flags),
          (P.return = a),
          (P = P.sibling);
    return (a.subtreeFlags |= b), (a.childLanes = v), c;
  }
  function fP(a, c, v) {
    var b = c.pendingProps;
    switch ((js(c), c.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Hi(c), null;
      case 1:
        return hi(c.type) && rc(), Hi(c), null;
      case 3:
        return (
          (b = c.stateNode),
          gs(),
          Nn(wi),
          Nn(oi),
          Vi(),
          b.pendingContext &&
            ((b.context = b.pendingContext), (b.pendingContext = null)),
          (a === null || a.child === null) &&
            (nu(c)
              ? (c.flags |= 4)
              : a === null ||
                (a.memoizedState.isDehydrated && (c.flags & 256) === 0) ||
                ((c.flags |= 1024), Eo !== null && (cx(Eo), (Eo = null)))),
          Qy(a, c),
          Hi(c),
          null
        );
      case 5:
        cu(c);
        var P = Bi(Aa.current);
        if (((v = c.type), a !== null && c.stateNode != null))
          bw(a, c, v, b, P),
            a.ref !== c.ref && ((c.flags |= 512), (c.flags |= 2097152));
        else {
          if (!b) {
            if (c.stateNode === null) throw Error(t(166));
            return Hi(c), null;
          }
          if (((a = Bi(Co.current)), nu(c))) {
            (b = c.stateNode), (v = c.type);
            var N = c.memoizedProps;
            switch (((b[Rr] = c), (b[tu] = N), (a = (c.mode & 1) !== 0), v)) {
              case "dialog":
                On("cancel", b), On("close", b);
                break;
              case "iframe":
              case "object":
              case "embed":
                On("load", b);
                break;
              case "video":
              case "audio":
                for (P = 0; P < wa.length; P++) On(wa[P], b);
                break;
              case "source":
                On("error", b);
                break;
              case "img":
              case "image":
              case "link":
                On("error", b), On("load", b);
                break;
              case "details":
                On("toggle", b);
                break;
              case "input":
                ke(b, N), On("invalid", b);
                break;
              case "select":
                (b._wrapperState = { wasMultiple: !!N.multiple }),
                  On("invalid", b);
                break;
              case "textarea":
                xe(b, N), On("invalid", b);
            }
            ce(v, N), (P = null);
            for (var X in N)
              if (N.hasOwnProperty(X)) {
                var fe = N[X];
                X === "children"
                  ? typeof fe == "string"
                    ? b.textContent !== fe &&
                      (N.suppressHydrationWarning !== !0 &&
                        tc(b.textContent, fe, a),
                      (P = ["children", fe]))
                    : typeof fe == "number" &&
                      b.textContent !== "" + fe &&
                      (N.suppressHydrationWarning !== !0 &&
                        tc(b.textContent, fe, a),
                      (P = ["children", "" + fe]))
                  : i.hasOwnProperty(X) &&
                    fe != null &&
                    X === "onScroll" &&
                    On("scroll", b);
              }
            switch (v) {
              case "input":
                Ae(b), Le(b, N, !0);
                break;
              case "textarea":
                Ae(b), Me(b);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof N.onClick == "function" && (b.onclick = nc);
            }
            (b = P), (c.updateQueue = b), b !== null && (c.flags |= 4);
          } else {
            (X = P.nodeType === 9 ? P : P.ownerDocument),
              a === "http://www.w3.org/1999/xhtml" && (a = at(v)),
              a === "http://www.w3.org/1999/xhtml"
                ? v === "script"
                  ? ((a = X.createElement("div")),
                    (a.innerHTML = "<script></script>"),
                    (a = a.removeChild(a.firstChild)))
                  : typeof b.is == "string"
                  ? (a = X.createElement(v, { is: b.is }))
                  : ((a = X.createElement(v)),
                    v === "select" &&
                      ((X = a),
                      b.multiple
                        ? (X.multiple = !0)
                        : b.size && (X.size = b.size)))
                : (a = X.createElementNS(a, v)),
              (a[Rr] = c),
              (a[tu] = b),
              Mw(a, c, !1, !1),
              (c.stateNode = a);
            e: {
              switch (((X = Je(v, b)), v)) {
                case "dialog":
                  On("cancel", a), On("close", a), (P = b);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  On("load", a), (P = b);
                  break;
                case "video":
                case "audio":
                  for (P = 0; P < wa.length; P++) On(wa[P], a);
                  P = b;
                  break;
                case "source":
                  On("error", a), (P = b);
                  break;
                case "img":
                case "image":
                case "link":
                  On("error", a), On("load", a), (P = b);
                  break;
                case "details":
                  On("toggle", a), (P = b);
                  break;
                case "input":
                  ke(a, b), (P = Te(a, b)), On("invalid", a);
                  break;
                case "option":
                  P = b;
                  break;
                case "select":
                  (a._wrapperState = { wasMultiple: !!b.multiple }),
                    (P = B({}, b, { value: void 0 })),
                    On("invalid", a);
                  break;
                case "textarea":
                  xe(a, b), (P = me(a, b)), On("invalid", a);
                  break;
                default:
                  P = b;
              }
              ce(v, P), (fe = P);
              for (N in fe)
                if (fe.hasOwnProperty(N)) {
                  var ge = fe[N];
                  N === "style"
                    ? qe(a, ge)
                    : N === "dangerouslySetInnerHTML"
                    ? ((ge = ge ? ge.__html : void 0), ge != null && We(a, ge))
                    : N === "children"
                    ? typeof ge == "string"
                      ? (v !== "textarea" || ge !== "") && Ye(a, ge)
                      : typeof ge == "number" && Ye(a, "" + ge)
                    : N !== "suppressContentEditableWarning" &&
                      N !== "suppressHydrationWarning" &&
                      N !== "autoFocus" &&
                      (i.hasOwnProperty(N)
                        ? ge != null && N === "onScroll" && On("scroll", a)
                        : ge != null && E(a, N, ge, X));
                }
              switch (v) {
                case "input":
                  Ae(a), Le(a, b, !1);
                  break;
                case "textarea":
                  Ae(a), Me(a);
                  break;
                case "option":
                  b.value != null && a.setAttribute("value", "" + ue(b.value));
                  break;
                case "select":
                  (a.multiple = !!b.multiple),
                    (N = b.value),
                    N != null
                      ? F(a, !!b.multiple, N, !1)
                      : b.defaultValue != null &&
                        F(a, !!b.multiple, b.defaultValue, !0);
                  break;
                default:
                  typeof P.onClick == "function" && (a.onclick = nc);
              }
              switch (v) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  b = !!b.autoFocus;
                  break e;
                case "img":
                  b = !0;
                  break e;
                default:
                  b = !1;
              }
            }
            b && (c.flags |= 4);
          }
          c.ref !== null && ((c.flags |= 512), (c.flags |= 2097152));
        }
        return Hi(c), null;
      case 6:
        if (a && c.stateNode != null) Ew(a, c, a.memoizedProps, b);
        else {
          if (typeof b != "string" && c.stateNode === null) throw Error(t(166));
          if (((v = Bi(Aa.current)), Bi(Co.current), nu(c))) {
            if (
              ((b = c.stateNode),
              (v = c.memoizedProps),
              (b[Rr] = c),
              (N = b.nodeValue !== v) && ((a = si), a !== null))
            )
              switch (a.tag) {
                case 3:
                  tc(b.nodeValue, v, (a.mode & 1) !== 0);
                  break;
                case 5:
                  a.memoizedProps.suppressHydrationWarning !== !0 &&
                    tc(b.nodeValue, v, (a.mode & 1) !== 0);
              }
            N && (c.flags |= 4);
          } else
            (b = (v.nodeType === 9 ? v : v.ownerDocument).createTextNode(b)),
              (b[Rr] = c),
              (c.stateNode = b);
        }
        return Hi(c), null;
      case 13:
        if (
          (Nn(Un),
          (b = c.memoizedState),
          a === null ||
            (a.memoizedState !== null && a.memoizedState.dehydrated !== null))
        ) {
          if (Vn && bi !== null && (c.mode & 1) !== 0 && (c.flags & 128) === 0)
            Yh(), ba(), (c.flags |= 98560), (N = !1);
          else if (((N = nu(c)), b !== null && b.dehydrated !== null)) {
            if (a === null) {
              if (!N) throw Error(t(318));
              if (
                ((N = c.memoizedState),
                (N = N !== null ? N.dehydrated : null),
                !N)
              )
                throw Error(t(317));
              N[Rr] = c;
            } else
              ba(),
                (c.flags & 128) === 0 && (c.memoizedState = null),
                (c.flags |= 4);
            Hi(c), (N = !1);
          } else Eo !== null && (cx(Eo), (Eo = null)), (N = !0);
          if (!N) return c.flags & 65536 ? c : null;
        }
        return (c.flags & 128) !== 0
          ? ((c.lanes = v), c)
          : ((b = b !== null),
            b !== (a !== null && a.memoizedState !== null) &&
              b &&
              ((c.child.flags |= 8192),
              (c.mode & 1) !== 0 &&
                (a === null || (Un.current & 1) !== 0
                  ? ai === 0 && (ai = 3)
                  : hx())),
            c.updateQueue !== null && (c.flags |= 4),
            Hi(c),
            null);
      case 4:
        return (
          gs(),
          Qy(a, c),
          a === null && Jl(c.stateNode.containerInfo),
          Hi(c),
          null
        );
      case 10:
        return ou(c.type._context), Hi(c), null;
      case 17:
        return hi(c.type) && rc(), Hi(c), null;
      case 19:
        if ((Nn(Un), (N = c.memoizedState), N === null)) return Hi(c), null;
        if (((b = (c.flags & 128) !== 0), (X = N.rendering), X === null))
          if (b) ep(N, !1);
          else {
            if (ai !== 0 || (a !== null && (a.flags & 128) !== 0))
              for (a = c.child; a !== null; ) {
                if (((X = qr(a)), X !== null)) {
                  for (
                    c.flags |= 128,
                      ep(N, !1),
                      b = X.updateQueue,
                      b !== null && ((c.updateQueue = b), (c.flags |= 4)),
                      c.subtreeFlags = 0,
                      b = v,
                      v = c.child;
                    v !== null;

                  )
                    (N = v),
                      (a = b),
                      (N.flags &= 14680066),
                      (X = N.alternate),
                      X === null
                        ? ((N.childLanes = 0),
                          (N.lanes = a),
                          (N.child = null),
                          (N.subtreeFlags = 0),
                          (N.memoizedProps = null),
                          (N.memoizedState = null),
                          (N.updateQueue = null),
                          (N.dependencies = null),
                          (N.stateNode = null))
                        : ((N.childLanes = X.childLanes),
                          (N.lanes = X.lanes),
                          (N.child = X.child),
                          (N.subtreeFlags = 0),
                          (N.deletions = null),
                          (N.memoizedProps = X.memoizedProps),
                          (N.memoizedState = X.memoizedState),
                          (N.updateQueue = X.updateQueue),
                          (N.type = X.type),
                          (a = X.dependencies),
                          (N.dependencies =
                            a === null
                              ? null
                              : {
                                  lanes: a.lanes,
                                  firstContext: a.firstContext,
                                })),
                      (v = v.sibling);
                  return Dn(Un, (Un.current & 1) | 2), c.child;
                }
                a = a.sibling;
              }
            N.tail !== null &&
              Ke() > cd &&
              ((c.flags |= 128), (b = !0), ep(N, !1), (c.lanes = 4194304));
          }
        else {
          if (!b)
            if (((a = qr(X)), a !== null)) {
              if (
                ((c.flags |= 128),
                (b = !0),
                (v = a.updateQueue),
                v !== null && ((c.updateQueue = v), (c.flags |= 4)),
                ep(N, !0),
                N.tail === null &&
                  N.tailMode === "hidden" &&
                  !X.alternate &&
                  !Vn)
              )
                return Hi(c), null;
            } else
              2 * Ke() - N.renderingStartTime > cd &&
                v !== 1073741824 &&
                ((c.flags |= 128), (b = !0), ep(N, !1), (c.lanes = 4194304));
          N.isBackwards
            ? ((X.sibling = c.child), (c.child = X))
            : ((v = N.last),
              v !== null ? (v.sibling = X) : (c.child = X),
              (N.last = X));
        }
        return N.tail !== null
          ? ((c = N.tail),
            (N.rendering = c),
            (N.tail = c.sibling),
            (N.renderingStartTime = Ke()),
            (c.sibling = null),
            (v = Un.current),
            Dn(Un, b ? (v & 1) | 2 : v & 1),
            c)
          : (Hi(c), null);
      case 22:
      case 23:
        return (
          dx(),
          (b = c.memoizedState !== null),
          a !== null && (a.memoizedState !== null) !== b && (c.flags |= 8192),
          b && (c.mode & 1) !== 0
            ? (Ko & 1073741824) !== 0 &&
              (Hi(c), c.subtreeFlags & 6 && (c.flags |= 8192))
            : Hi(c),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, c.tag));
  }
  function dP(a, c) {
    switch ((js(c), c.tag)) {
      case 1:
        return (
          hi(c.type) && rc(),
          (a = c.flags),
          a & 65536 ? ((c.flags = (a & -65537) | 128), c) : null
        );
      case 3:
        return (
          gs(),
          Nn(wi),
          Nn(oi),
          Vi(),
          (a = c.flags),
          (a & 65536) !== 0 && (a & 128) === 0
            ? ((c.flags = (a & -65537) | 128), c)
            : null
        );
      case 5:
        return cu(c), null;
      case 13:
        if (
          (Nn(Un), (a = c.memoizedState), a !== null && a.dehydrated !== null)
        ) {
          if (c.alternate === null) throw Error(t(340));
          ba();
        }
        return (
          (a = c.flags), a & 65536 ? ((c.flags = (a & -65537) | 128), c) : null
        );
      case 19:
        return Nn(Un), null;
      case 4:
        return gs(), null;
      case 10:
        return ou(c.type._context), null;
      case 22:
      case 23:
        return dx(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var xg = !1,
    Gi = !1,
    hP = typeof WeakSet == "function" ? WeakSet : Set,
    Ct = null;
  function ld(a, c) {
    var v = a.ref;
    if (v !== null)
      if (typeof v == "function")
        try {
          v(null);
        } catch (b) {
          xr(a, c, b);
        }
      else v.current = null;
  }
  function ex(a, c, v) {
    try {
      v();
    } catch (b) {
      xr(a, c, b);
    }
  }
  var Tw = !1;
  function pP(a, c) {
    if (((eu = Br), (a = Kn()), Gr(a))) {
      if ("selectionStart" in a)
        var v = { start: a.selectionStart, end: a.selectionEnd };
      else
        e: {
          v = ((v = a.ownerDocument) && v.defaultView) || window;
          var b = v.getSelection && v.getSelection();
          if (b && b.rangeCount !== 0) {
            v = b.anchorNode;
            var P = b.anchorOffset,
              N = b.focusNode;
            b = b.focusOffset;
            try {
              v.nodeType, N.nodeType;
            } catch {
              v = null;
              break e;
            }
            var X = 0,
              fe = -1,
              ge = -1,
              je = 0,
              st = 0,
              lt = a,
              ot = null;
            t: for (;;) {
              for (
                var bt;
                lt !== v || (P !== 0 && lt.nodeType !== 3) || (fe = X + P),
                  lt !== N || (b !== 0 && lt.nodeType !== 3) || (ge = X + b),
                  lt.nodeType === 3 && (X += lt.nodeValue.length),
                  (bt = lt.firstChild) !== null;

              )
                (ot = lt), (lt = bt);
              for (;;) {
                if (lt === a) break t;
                if (
                  (ot === v && ++je === P && (fe = X),
                  ot === N && ++st === b && (ge = X),
                  (bt = lt.nextSibling) !== null)
                )
                  break;
                (lt = ot), (ot = lt.parentNode);
              }
              lt = bt;
            }
            v = fe === -1 || ge === -1 ? null : { start: fe, end: ge };
          } else v = null;
        }
      v = v || { start: 0, end: 0 };
    } else v = null;
    for (
      Nh = { focusedElem: a, selectionRange: v }, Br = !1, Ct = c;
      Ct !== null;

    )
      if (
        ((c = Ct), (a = c.child), (c.subtreeFlags & 1028) !== 0 && a !== null)
      )
        (a.return = c), (Ct = a);
      else
        for (; Ct !== null; ) {
          c = Ct;
          try {
            var Rt = c.alternate;
            if ((c.flags & 1024) !== 0)
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Rt !== null) {
                    var It = Rt.memoizedProps,
                      Ir = Rt.memoizedState,
                      De = c.stateNode,
                      Se = De.getSnapshotBeforeUpdate(
                        c.elementType === c.type ? It : $o(c.type, It),
                        Ir
                      );
                    De.__reactInternalSnapshotBeforeUpdate = Se;
                  }
                  break;
                case 3:
                  var Oe = c.stateNode.containerInfo;
                  Oe.nodeType === 1
                    ? (Oe.textContent = "")
                    : Oe.nodeType === 9 &&
                      Oe.documentElement &&
                      Oe.removeChild(Oe.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (ft) {
            xr(c, c.return, ft);
          }
          if (((a = c.sibling), a !== null)) {
            (a.return = c.return), (Ct = a);
            break;
          }
          Ct = c.return;
        }
    return (Rt = Tw), (Tw = !1), Rt;
  }
  function tp(a, c, v) {
    var b = c.updateQueue;
    if (((b = b !== null ? b.lastEffect : null), b !== null)) {
      var P = (b = b.next);
      do {
        if ((P.tag & a) === a) {
          var N = P.destroy;
          (P.destroy = void 0), N !== void 0 && ex(c, v, N);
        }
        P = P.next;
      } while (P !== b);
    }
  }
  function _g(a, c) {
    if (
      ((c = c.updateQueue), (c = c !== null ? c.lastEffect : null), c !== null)
    ) {
      var v = (c = c.next);
      do {
        if ((v.tag & a) === a) {
          var b = v.create;
          v.destroy = b();
        }
        v = v.next;
      } while (v !== c);
    }
  }
  function tx(a) {
    var c = a.ref;
    if (c !== null) {
      var v = a.stateNode;
      switch (a.tag) {
        case 5:
          a = v;
          break;
        default:
          a = v;
      }
      typeof c == "function" ? c(a) : (c.current = a);
    }
  }
  function Cw(a) {
    var c = a.alternate;
    c !== null && ((a.alternate = null), Cw(c)),
      (a.child = null),
      (a.deletions = null),
      (a.sibling = null),
      a.tag === 5 &&
        ((c = a.stateNode),
        c !== null &&
          (delete c[Rr],
          delete c[tu],
          delete c[rl],
          delete c[Vf],
          delete c[Hf])),
      (a.stateNode = null),
      (a.return = null),
      (a.dependencies = null),
      (a.memoizedProps = null),
      (a.memoizedState = null),
      (a.pendingProps = null),
      (a.stateNode = null),
      (a.updateQueue = null);
  }
  function Aw(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function Rw(a) {
    e: for (;;) {
      for (; a.sibling === null; ) {
        if (a.return === null || Aw(a.return)) return null;
        a = a.return;
      }
      for (
        a.sibling.return = a.return, a = a.sibling;
        a.tag !== 5 && a.tag !== 6 && a.tag !== 18;

      ) {
        if (a.flags & 2 || a.child === null || a.tag === 4) continue e;
        (a.child.return = a), (a = a.child);
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function nx(a, c, v) {
    var b = a.tag;
    if (b === 5 || b === 6)
      (a = a.stateNode),
        c
          ? v.nodeType === 8
            ? v.parentNode.insertBefore(a, c)
            : v.insertBefore(a, c)
          : (v.nodeType === 8
              ? ((c = v.parentNode), c.insertBefore(a, v))
              : ((c = v), c.appendChild(a)),
            (v = v._reactRootContainer),
            v != null || c.onclick !== null || (c.onclick = nc));
    else if (b !== 4 && ((a = a.child), a !== null))
      for (nx(a, c, v), a = a.sibling; a !== null; )
        nx(a, c, v), (a = a.sibling);
  }
  function rx(a, c, v) {
    var b = a.tag;
    if (b === 5 || b === 6)
      (a = a.stateNode), c ? v.insertBefore(a, c) : v.appendChild(a);
    else if (b !== 4 && ((a = a.child), a !== null))
      for (rx(a, c, v), a = a.sibling; a !== null; )
        rx(a, c, v), (a = a.sibling);
  }
  var Ri = null,
    Ks = !1;
  function pu(a, c, v) {
    for (v = v.child; v !== null; ) Pw(a, c, v), (v = v.sibling);
  }
  function Pw(a, c, v) {
    if (wt && typeof wt.onCommitFiberUnmount == "function")
      try {
        wt.onCommitFiberUnmount(Sn, v);
      } catch {}
    switch (v.tag) {
      case 5:
        Gi || ld(v, c);
      case 6:
        var b = Ri,
          P = Ks;
        (Ri = null),
          pu(a, c, v),
          (Ri = b),
          (Ks = P),
          Ri !== null &&
            (Ks
              ? ((a = Ri),
                (v = v.stateNode),
                a.nodeType === 8
                  ? a.parentNode.removeChild(v)
                  : a.removeChild(v))
              : Ri.removeChild(v.stateNode));
        break;
      case 18:
        Ri !== null &&
          (Ks
            ? ((a = Ri),
              (v = v.stateNode),
              a.nodeType === 8
                ? Bf(a.parentNode, v)
                : a.nodeType === 1 && Bf(a, v),
              pa(a))
            : Bf(Ri, v.stateNode));
        break;
      case 4:
        (b = Ri),
          (P = Ks),
          (Ri = v.stateNode.containerInfo),
          (Ks = !0),
          pu(a, c, v),
          (Ri = b),
          (Ks = P);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !Gi &&
          ((b = v.updateQueue), b !== null && ((b = b.lastEffect), b !== null))
        ) {
          P = b = b.next;
          do {
            var N = P,
              X = N.destroy;
            (N = N.tag),
              X !== void 0 && ((N & 2) !== 0 || (N & 4) !== 0) && ex(v, c, X),
              (P = P.next);
          } while (P !== b);
        }
        pu(a, c, v);
        break;
      case 1:
        if (
          !Gi &&
          (ld(v, c),
          (b = v.stateNode),
          typeof b.componentWillUnmount == "function")
        )
          try {
            (b.props = v.memoizedProps),
              (b.state = v.memoizedState),
              b.componentWillUnmount();
          } catch (fe) {
            xr(v, c, fe);
          }
        pu(a, c, v);
        break;
      case 21:
        pu(a, c, v);
        break;
      case 22:
        v.mode & 1
          ? ((Gi = (b = Gi) || v.memoizedState !== null), pu(a, c, v), (Gi = b))
          : pu(a, c, v);
        break;
      default:
        pu(a, c, v);
    }
  }
  function Iw(a) {
    var c = a.updateQueue;
    if (c !== null) {
      a.updateQueue = null;
      var v = a.stateNode;
      v === null && (v = a.stateNode = new hP()),
        c.forEach(function (b) {
          var P = MP.bind(null, a, b);
          v.has(b) || (v.add(b), b.then(P, P));
        });
    }
  }
  function Zs(a, c) {
    var v = c.deletions;
    if (v !== null)
      for (var b = 0; b < v.length; b++) {
        var P = v[b];
        try {
          var N = a,
            X = c,
            fe = X;
          e: for (; fe !== null; ) {
            switch (fe.tag) {
              case 5:
                (Ri = fe.stateNode), (Ks = !1);
                break e;
              case 3:
                (Ri = fe.stateNode.containerInfo), (Ks = !0);
                break e;
              case 4:
                (Ri = fe.stateNode.containerInfo), (Ks = !0);
                break e;
            }
            fe = fe.return;
          }
          if (Ri === null) throw Error(t(160));
          Pw(N, X, P), (Ri = null), (Ks = !1);
          var ge = P.alternate;
          ge !== null && (ge.return = null), (P.return = null);
        } catch (je) {
          xr(P, c, je);
        }
      }
    if (c.subtreeFlags & 12854)
      for (c = c.child; c !== null; ) Lw(c, a), (c = c.sibling);
  }
  function Lw(a, c) {
    var v = a.alternate,
      b = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((Zs(c, a), Da(a), b & 4)) {
          try {
            tp(3, a, a.return), _g(3, a);
          } catch (It) {
            xr(a, a.return, It);
          }
          try {
            tp(5, a, a.return);
          } catch (It) {
            xr(a, a.return, It);
          }
        }
        break;
      case 1:
        Zs(c, a), Da(a), b & 512 && v !== null && ld(v, v.return);
        break;
      case 5:
        if (
          (Zs(c, a),
          Da(a),
          b & 512 && v !== null && ld(v, v.return),
          a.flags & 32)
        ) {
          var P = a.stateNode;
          try {
            Ye(P, "");
          } catch (It) {
            xr(a, a.return, It);
          }
        }
        if (b & 4 && ((P = a.stateNode), P != null)) {
          var N = a.memoizedProps,
            X = v !== null ? v.memoizedProps : N,
            fe = a.type,
            ge = a.updateQueue;
          if (((a.updateQueue = null), ge !== null))
            try {
              fe === "input" &&
                N.type === "radio" &&
                N.name != null &&
                Pe(P, N),
                Je(fe, X);
              var je = Je(fe, N);
              for (X = 0; X < ge.length; X += 2) {
                var st = ge[X],
                  lt = ge[X + 1];
                st === "style"
                  ? qe(P, lt)
                  : st === "dangerouslySetInnerHTML"
                  ? We(P, lt)
                  : st === "children"
                  ? Ye(P, lt)
                  : E(P, st, lt, je);
              }
              switch (fe) {
                case "input":
                  rt(P, N);
                  break;
                case "textarea":
                  ye(P, N);
                  break;
                case "select":
                  var ot = P._wrapperState.wasMultiple;
                  P._wrapperState.wasMultiple = !!N.multiple;
                  var bt = N.value;
                  bt != null
                    ? F(P, !!N.multiple, bt, !1)
                    : ot !== !!N.multiple &&
                      (N.defaultValue != null
                        ? F(P, !!N.multiple, N.defaultValue, !0)
                        : F(P, !!N.multiple, N.multiple ? [] : "", !1));
              }
              P[tu] = N;
            } catch (It) {
              xr(a, a.return, It);
            }
        }
        break;
      case 6:
        if ((Zs(c, a), Da(a), b & 4)) {
          if (a.stateNode === null) throw Error(t(162));
          (P = a.stateNode), (N = a.memoizedProps);
          try {
            P.nodeValue = N;
          } catch (It) {
            xr(a, a.return, It);
          }
        }
        break;
      case 3:
        if (
          (Zs(c, a), Da(a), b & 4 && v !== null && v.memoizedState.isDehydrated)
        )
          try {
            pa(c.containerInfo);
          } catch (It) {
            xr(a, a.return, It);
          }
        break;
      case 4:
        Zs(c, a), Da(a);
        break;
      case 13:
        Zs(c, a),
          Da(a),
          (P = a.child),
          P.flags & 8192 &&
            ((N = P.memoizedState !== null),
            (P.stateNode.isHidden = N),
            !N ||
              (P.alternate !== null && P.alternate.memoizedState !== null) ||
              (sx = Ke())),
          b & 4 && Iw(a);
        break;
      case 22:
        if (
          ((st = v !== null && v.memoizedState !== null),
          a.mode & 1 ? ((Gi = (je = Gi) || st), Zs(c, a), (Gi = je)) : Zs(c, a),
          Da(a),
          b & 8192)
        ) {
          if (
            ((je = a.memoizedState !== null),
            (a.stateNode.isHidden = je) && !st && (a.mode & 1) !== 0)
          )
            for (Ct = a, st = a.child; st !== null; ) {
              for (lt = Ct = st; Ct !== null; ) {
                switch (((ot = Ct), (bt = ot.child), ot.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    tp(4, ot, ot.return);
                    break;
                  case 1:
                    ld(ot, ot.return);
                    var Rt = ot.stateNode;
                    if (typeof Rt.componentWillUnmount == "function") {
                      (b = ot), (v = ot.return);
                      try {
                        (c = b),
                          (Rt.props = c.memoizedProps),
                          (Rt.state = c.memoizedState),
                          Rt.componentWillUnmount();
                      } catch (It) {
                        xr(b, v, It);
                      }
                    }
                    break;
                  case 5:
                    ld(ot, ot.return);
                    break;
                  case 22:
                    if (ot.memoizedState !== null) {
                      Ow(lt);
                      continue;
                    }
                }
                bt !== null ? ((bt.return = ot), (Ct = bt)) : Ow(lt);
              }
              st = st.sibling;
            }
          e: for (st = null, lt = a; ; ) {
            if (lt.tag === 5) {
              if (st === null) {
                st = lt;
                try {
                  (P = lt.stateNode),
                    je
                      ? ((N = P.style),
                        typeof N.setProperty == "function"
                          ? N.setProperty("display", "none", "important")
                          : (N.display = "none"))
                      : ((fe = lt.stateNode),
                        (ge = lt.memoizedProps.style),
                        (X =
                          ge != null && ge.hasOwnProperty("display")
                            ? ge.display
                            : null),
                        (fe.style.display = $e("display", X)));
                } catch (It) {
                  xr(a, a.return, It);
                }
              }
            } else if (lt.tag === 6) {
              if (st === null)
                try {
                  lt.stateNode.nodeValue = je ? "" : lt.memoizedProps;
                } catch (It) {
                  xr(a, a.return, It);
                }
            } else if (
              ((lt.tag !== 22 && lt.tag !== 23) ||
                lt.memoizedState === null ||
                lt === a) &&
              lt.child !== null
            ) {
              (lt.child.return = lt), (lt = lt.child);
              continue;
            }
            if (lt === a) break e;
            for (; lt.sibling === null; ) {
              if (lt.return === null || lt.return === a) break e;
              st === lt && (st = null), (lt = lt.return);
            }
            st === lt && (st = null),
              (lt.sibling.return = lt.return),
              (lt = lt.sibling);
          }
        }
        break;
      case 19:
        Zs(c, a), Da(a), b & 4 && Iw(a);
        break;
      case 21:
        break;
      default:
        Zs(c, a), Da(a);
    }
  }
  function Da(a) {
    var c = a.flags;
    if (c & 2) {
      try {
        e: {
          for (var v = a.return; v !== null; ) {
            if (Aw(v)) {
              var b = v;
              break e;
            }
            v = v.return;
          }
          throw Error(t(160));
        }
        switch (b.tag) {
          case 5:
            var P = b.stateNode;
            b.flags & 32 && (Ye(P, ""), (b.flags &= -33));
            var N = Rw(a);
            rx(a, N, P);
            break;
          case 3:
          case 4:
            var X = b.stateNode.containerInfo,
              fe = Rw(a);
            nx(a, fe, X);
            break;
          default:
            throw Error(t(161));
        }
      } catch (ge) {
        xr(a, a.return, ge);
      }
      a.flags &= -3;
    }
    c & 4096 && (a.flags &= -4097);
  }
  function mP(a, c, v) {
    (Ct = a), Dw(a);
  }
  function Dw(a, c, v) {
    for (var b = (a.mode & 1) !== 0; Ct !== null; ) {
      var P = Ct,
        N = P.child;
      if (P.tag === 22 && b) {
        var X = P.memoizedState !== null || xg;
        if (!X) {
          var fe = P.alternate,
            ge = (fe !== null && fe.memoizedState !== null) || Gi;
          fe = xg;
          var je = Gi;
          if (((xg = X), (Gi = ge) && !je))
            for (Ct = P; Ct !== null; )
              (X = Ct),
                (ge = X.child),
                X.tag === 22 && X.memoizedState !== null
                  ? Nw(P)
                  : ge !== null
                  ? ((ge.return = X), (Ct = ge))
                  : Nw(P);
          for (; N !== null; ) (Ct = N), Dw(N), (N = N.sibling);
          (Ct = P), (xg = fe), (Gi = je);
        }
        kw(a);
      } else
        (P.subtreeFlags & 8772) !== 0 && N !== null
          ? ((N.return = P), (Ct = N))
          : kw(a);
    }
  }
  function kw(a) {
    for (; Ct !== null; ) {
      var c = Ct;
      if ((c.flags & 8772) !== 0) {
        var v = c.alternate;
        try {
          if ((c.flags & 8772) !== 0)
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                Gi || _g(5, c);
                break;
              case 1:
                var b = c.stateNode;
                if (c.flags & 4 && !Gi)
                  if (v === null) b.componentDidMount();
                  else {
                    var P =
                      c.elementType === c.type
                        ? v.memoizedProps
                        : $o(c.type, v.memoizedProps);
                    b.componentDidUpdate(
                      P,
                      v.memoizedState,
                      b.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var N = c.updateQueue;
                N !== null && lr(c, N, b);
                break;
              case 3:
                var X = c.updateQueue;
                if (X !== null) {
                  if (((v = null), c.child !== null))
                    switch (c.child.tag) {
                      case 5:
                        v = c.child.stateNode;
                        break;
                      case 1:
                        v = c.child.stateNode;
                    }
                  lr(c, X, v);
                }
                break;
              case 5:
                var fe = c.stateNode;
                if (v === null && c.flags & 4) {
                  v = fe;
                  var ge = c.memoizedProps;
                  switch (c.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ge.autoFocus && v.focus();
                      break;
                    case "img":
                      ge.src && (v.src = ge.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (c.memoizedState === null) {
                  var je = c.alternate;
                  if (je !== null) {
                    var st = je.memoizedState;
                    if (st !== null) {
                      var lt = st.dehydrated;
                      lt !== null && pa(lt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          Gi || (c.flags & 512 && tx(c));
        } catch (ot) {
          xr(c, c.return, ot);
        }
      }
      if (c === a) {
        Ct = null;
        break;
      }
      if (((v = c.sibling), v !== null)) {
        (v.return = c.return), (Ct = v);
        break;
      }
      Ct = c.return;
    }
  }
  function Ow(a) {
    for (; Ct !== null; ) {
      var c = Ct;
      if (c === a) {
        Ct = null;
        break;
      }
      var v = c.sibling;
      if (v !== null) {
        (v.return = c.return), (Ct = v);
        break;
      }
      Ct = c.return;
    }
  }
  function Nw(a) {
    for (; Ct !== null; ) {
      var c = Ct;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var v = c.return;
            try {
              _g(4, c);
            } catch (ge) {
              xr(c, v, ge);
            }
            break;
          case 1:
            var b = c.stateNode;
            if (typeof b.componentDidMount == "function") {
              var P = c.return;
              try {
                b.componentDidMount();
              } catch (ge) {
                xr(c, P, ge);
              }
            }
            var N = c.return;
            try {
              tx(c);
            } catch (ge) {
              xr(c, N, ge);
            }
            break;
          case 5:
            var X = c.return;
            try {
              tx(c);
            } catch (ge) {
              xr(c, X, ge);
            }
        }
      } catch (ge) {
        xr(c, c.return, ge);
      }
      if (c === a) {
        Ct = null;
        break;
      }
      var fe = c.sibling;
      if (fe !== null) {
        (fe.return = c.return), (Ct = fe);
        break;
      }
      Ct = c.return;
    }
  }
  var gP = Math.ceil,
    Sg = A.ReactCurrentDispatcher,
    ix = A.ReactCurrentOwner,
    xs = A.ReactCurrentBatchConfig,
    gn = 0,
    mi = null,
    Zr = null,
    Pi = 0,
    Ko = 0,
    ud = Qn(0),
    ai = 0,
    np = null,
    vc = 0,
    wg = 0,
    ox = 0,
    rp = null,
    Po = null,
    sx = 0,
    cd = 1 / 0,
    pl = null,
    Mg = !1,
    ax = null,
    mu = null,
    bg = !1,
    gu = null,
    Eg = 0,
    ip = 0,
    lx = null,
    Tg = -1,
    Cg = 0;
  function co() {
    return (gn & 6) !== 0 ? Ke() : Tg !== -1 ? Tg : (Tg = Ke());
  }
  function vu(a) {
    return (a.mode & 1) === 0
      ? 1
      : (gn & 2) !== 0 && Pi !== 0
      ? Pi & -Pi
      : Ky.transition !== null
      ? (Cg === 0 && (Cg = ci()), Cg)
      : ((a = sn),
        a !== 0 || ((a = window.event), (a = a === void 0 ? 16 : ga(a.type))),
        a);
  }
  function Js(a, c, v, b) {
    if (50 < ip) throw ((ip = 0), (lx = null), Error(t(185)));
    Fo(a, v, b),
      ((gn & 2) === 0 || a !== mi) &&
        (a === mi && ((gn & 2) === 0 && (wg |= v), ai === 4 && yu(a, Pi)),
        Io(a, b),
        v === 1 &&
          gn === 0 &&
          (c.mode & 1) === 0 &&
          ((cd = Ke() + 500), oc && ps()));
  }
  function Io(a, c) {
    var v = a.callbackNode;
    or(a, c);
    var b = Fr(a, a === mi ? Pi : 0);
    if (b === 0)
      v !== null && ut(v), (a.callbackNode = null), (a.callbackPriority = 0);
    else if (((c = b & -b), a.callbackPriority !== c)) {
      if ((v != null && ut(v), c === 1))
        a.tag === 0 ? ig(Fw.bind(null, a)) : sc(Fw.bind(null, a)),
          qy(function () {
            (gn & 6) === 0 && ps();
          }),
          (v = null);
      else {
        switch (ls(b)) {
          case 1:
            v = Ut;
            break;
          case 4:
            v = At;
            break;
          case 16:
            v = tn;
            break;
          case 536870912:
            v = dn;
            break;
          default:
            v = tn;
        }
        v = $w(v, Uw.bind(null, a));
      }
      (a.callbackPriority = c), (a.callbackNode = v);
    }
  }
  function Uw(a, c) {
    if (((Tg = -1), (Cg = 0), (gn & 6) !== 0)) throw Error(t(327));
    var v = a.callbackNode;
    if (fd() && a.callbackNode !== v) return null;
    var b = Fr(a, a === mi ? Pi : 0);
    if (b === 0) return null;
    if ((b & 30) !== 0 || (b & a.expiredLanes) !== 0 || c) c = Ag(a, b);
    else {
      c = b;
      var P = gn;
      gn |= 2;
      var N = Bw();
      (mi !== a || Pi !== c) && ((pl = null), (cd = Ke() + 500), xc(a, c));
      do
        try {
          xP();
          break;
        } catch (fe) {
          zw(a, fe);
        }
      while (!0);
      iu(),
        (Sg.current = N),
        (gn = P),
        Zr !== null ? (c = 0) : ((mi = null), (Pi = 0), (c = ai));
    }
    if (c !== 0) {
      if (
        (c === 2 && ((P = Tr(a)), P !== 0 && ((b = P), (c = ux(a, P)))),
        c === 1)
      )
        throw ((v = np), xc(a, 0), yu(a, b), Io(a, Ke()), v);
      if (c === 6) yu(a, b);
      else {
        if (
          ((P = a.current.alternate),
          (b & 30) === 0 &&
            !vP(P) &&
            ((c = Ag(a, b)),
            c === 2 && ((N = Tr(a)), N !== 0 && ((b = N), (c = ux(a, N)))),
            c === 1))
        )
          throw ((v = np), xc(a, 0), yu(a, b), Io(a, Ke()), v);
        switch (((a.finishedWork = P), (a.finishedLanes = b), c)) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            _c(a, Po, pl);
            break;
          case 3:
            if (
              (yu(a, b),
              (b & 130023424) === b && ((c = sx + 500 - Ke()), 10 < c))
            ) {
              if (Fr(a, 0) !== 0) break;
              if (((P = a.suspendedLanes), (P & b) !== b)) {
                co(), (a.pingedLanes |= a.suspendedLanes & P);
                break;
              }
              a.timeoutHandle = Fh(_c.bind(null, a, Po, pl), c);
              break;
            }
            _c(a, Po, pl);
            break;
          case 4:
            if ((yu(a, b), (b & 4194240) === b)) break;
            for (c = a.eventTimes, P = -1; 0 < b; ) {
              var X = 31 - Zt(b);
              (N = 1 << X), (X = c[X]), X > P && (P = X), (b &= ~N);
            }
            if (
              ((b = P),
              (b = Ke() - b),
              (b =
                (120 > b
                  ? 120
                  : 480 > b
                  ? 480
                  : 1080 > b
                  ? 1080
                  : 1920 > b
                  ? 1920
                  : 3e3 > b
                  ? 3e3
                  : 4320 > b
                  ? 4320
                  : 1960 * gP(b / 1960)) - b),
              10 < b)
            ) {
              a.timeoutHandle = Fh(_c.bind(null, a, Po, pl), b);
              break;
            }
            _c(a, Po, pl);
            break;
          case 5:
            _c(a, Po, pl);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return Io(a, Ke()), a.callbackNode === v ? Uw.bind(null, a) : null;
  }
  function ux(a, c) {
    var v = rp;
    return (
      a.current.memoizedState.isDehydrated && (xc(a, c).flags |= 256),
      (a = Ag(a, c)),
      a !== 2 && ((c = Po), (Po = v), c !== null && cx(c)),
      a
    );
  }
  function cx(a) {
    Po === null ? (Po = a) : Po.push.apply(Po, a);
  }
  function vP(a) {
    for (var c = a; ; ) {
      if (c.flags & 16384) {
        var v = c.updateQueue;
        if (v !== null && ((v = v.stores), v !== null))
          for (var b = 0; b < v.length; b++) {
            var P = v[b],
              N = P.getSnapshot;
            P = P.value;
            try {
              if (!io(N(), P)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((v = c.child), c.subtreeFlags & 16384 && v !== null))
        (v.return = c), (c = v);
      else {
        if (c === a) break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === a) return !0;
          c = c.return;
        }
        (c.sibling.return = c.return), (c = c.sibling);
      }
    }
    return !0;
  }
  function yu(a, c) {
    for (
      c &= ~ox,
        c &= ~wg,
        a.suspendedLanes |= c,
        a.pingedLanes &= ~c,
        a = a.expirationTimes;
      0 < c;

    ) {
      var v = 31 - Zt(c),
        b = 1 << v;
      (a[v] = -1), (c &= ~b);
    }
  }
  function Fw(a) {
    if ((gn & 6) !== 0) throw Error(t(327));
    fd();
    var c = Fr(a, 0);
    if ((c & 1) === 0) return Io(a, Ke()), null;
    var v = Ag(a, c);
    if (a.tag !== 0 && v === 2) {
      var b = Tr(a);
      b !== 0 && ((c = b), (v = ux(a, b)));
    }
    if (v === 1) throw ((v = np), xc(a, 0), yu(a, c), Io(a, Ke()), v);
    if (v === 6) throw Error(t(345));
    return (
      (a.finishedWork = a.current.alternate),
      (a.finishedLanes = c),
      _c(a, Po, pl),
      Io(a, Ke()),
      null
    );
  }
  function fx(a, c) {
    var v = gn;
    gn |= 1;
    try {
      return a(c);
    } finally {
      (gn = v), gn === 0 && ((cd = Ke() + 500), oc && ps());
    }
  }
  function yc(a) {
    gu !== null && gu.tag === 0 && (gn & 6) === 0 && fd();
    var c = gn;
    gn |= 1;
    var v = xs.transition,
      b = sn;
    try {
      if (((xs.transition = null), (sn = 1), a)) return a();
    } finally {
      (sn = b), (xs.transition = v), (gn = c), (gn & 6) === 0 && ps();
    }
  }
  function dx() {
    (Ko = ud.current), Nn(ud);
  }
  function xc(a, c) {
    (a.finishedWork = null), (a.finishedLanes = 0);
    var v = a.timeoutHandle;
    if ((v !== -1 && ((a.timeoutHandle = -1), zh(v)), Zr !== null))
      for (v = Zr.return; v !== null; ) {
        var b = v;
        switch ((js(b), b.tag)) {
          case 1:
            (b = b.type.childContextTypes), b != null && rc();
            break;
          case 3:
            gs(), Nn(wi), Nn(oi), Vi();
            break;
          case 5:
            cu(b);
            break;
          case 4:
            gs();
            break;
          case 13:
            Nn(Un);
            break;
          case 19:
            Nn(Un);
            break;
          case 10:
            ou(b.type._context);
            break;
          case 22:
          case 23:
            dx();
        }
        v = v.return;
      }
    if (
      ((mi = a),
      (Zr = a = xu(a.current, null)),
      (Pi = Ko = c),
      (ai = 0),
      (np = null),
      (ox = wg = vc = 0),
      (Po = rp = null),
      Xo !== null)
    ) {
      for (c = 0; c < Xo.length; c++)
        if (((v = Xo[c]), (b = v.interleaved), b !== null)) {
          v.interleaved = null;
          var P = b.next,
            N = v.pending;
          if (N !== null) {
            var X = N.next;
            (N.next = P), (b.next = X);
          }
          v.pending = b;
        }
      Xo = null;
    }
    return a;
  }
  function zw(a, c) {
    do {
      var v = Zr;
      try {
        if ((iu(), (dl.current = d), qo)) {
          for (var b = Hn.memoizedState; b !== null; ) {
            var P = b.queue;
            P !== null && (P.pending = null), (b = b.next);
          }
          qo = !1;
        }
        if (
          ((Ra = 0),
          (Kr = ur = Hn = null),
          (fu = !1),
          (du = 0),
          (ix.current = null),
          v === null || v.return === null)
        ) {
          (ai = 1), (np = c), (Zr = null);
          break;
        }
        e: {
          var N = a,
            X = v.return,
            fe = v,
            ge = c;
          if (
            ((c = Pi),
            (fe.flags |= 32768),
            ge !== null &&
              typeof ge == "object" &&
              typeof ge.then == "function")
          ) {
            var je = ge,
              st = fe,
              lt = st.tag;
            if ((st.mode & 1) === 0 && (lt === 0 || lt === 11 || lt === 15)) {
              var ot = st.alternate;
              ot
                ? ((st.updateQueue = ot.updateQueue),
                  (st.memoizedState = ot.memoizedState),
                  (st.lanes = ot.lanes))
                : ((st.updateQueue = null), (st.memoizedState = null));
            }
            var bt = qt(X);
            if (bt !== null) {
              (bt.flags &= -257),
                zt(bt, X, fe, N, c),
                bt.mode & 1 && Tt(N, je, c),
                (c = bt),
                (ge = je);
              var Rt = c.updateQueue;
              if (Rt === null) {
                var It = new Set();
                It.add(ge), (c.updateQueue = It);
              } else Rt.add(ge);
              break e;
            } else {
              if ((c & 1) === 0) {
                Tt(N, je, c), hx();
                break e;
              }
              ge = Error(t(426));
            }
          } else if (Vn && fe.mode & 1) {
            var Ir = qt(X);
            if (Ir !== null) {
              (Ir.flags & 65536) === 0 && (Ir.flags |= 256),
                zt(Ir, X, fe, N, c),
                ru(k(ge, fe));
              break e;
            }
          }
          (N = ge = k(ge, fe)),
            ai !== 4 && (ai = 2),
            rp === null ? (rp = [N]) : rp.push(N),
            (N = X);
          do {
            switch (N.tag) {
              case 3:
                (N.flags |= 65536), (c &= -c), (N.lanes |= c);
                var De = Qe(N, ge, c);
                nn(N, De);
                break e;
              case 1:
                fe = ge;
                var Se = N.type,
                  Oe = N.stateNode;
                if (
                  (N.flags & 128) === 0 &&
                  (typeof Se.getDerivedStateFromError == "function" ||
                    (Oe !== null &&
                      typeof Oe.componentDidCatch == "function" &&
                      (mu === null || !mu.has(Oe))))
                ) {
                  (N.flags |= 65536), (c &= -c), (N.lanes |= c);
                  var ft = ct(N, fe, c);
                  nn(N, ft);
                  break e;
                }
            }
            N = N.return;
          } while (N !== null);
        }
        Hw(v);
      } catch (kt) {
        (c = kt), Zr === v && v !== null && (Zr = v = v.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Bw() {
    var a = Sg.current;
    return (Sg.current = d), a === null ? d : a;
  }
  function hx() {
    (ai === 0 || ai === 3 || ai === 2) && (ai = 4),
      mi === null ||
        ((vc & 268435455) === 0 && (wg & 268435455) === 0) ||
        yu(mi, Pi);
  }
  function Ag(a, c) {
    var v = gn;
    gn |= 2;
    var b = Bw();
    (mi !== a || Pi !== c) && ((pl = null), xc(a, c));
    do
      try {
        yP();
        break;
      } catch (P) {
        zw(a, P);
      }
    while (!0);
    if ((iu(), (gn = v), (Sg.current = b), Zr !== null)) throw Error(t(261));
    return (mi = null), (Pi = 0), ai;
  }
  function yP() {
    for (; Zr !== null; ) Vw(Zr);
  }
  function xP() {
    for (; Zr !== null && !vt(); ) Vw(Zr);
  }
  function Vw(a) {
    var c = jw(a.alternate, a, Ko);
    (a.memoizedProps = a.pendingProps),
      c === null ? Hw(a) : (Zr = c),
      (ix.current = null);
  }
  function Hw(a) {
    var c = a;
    do {
      var v = c.alternate;
      if (((a = c.return), (c.flags & 32768) === 0)) {
        if (((v = fP(v, c, Ko)), v !== null)) {
          Zr = v;
          return;
        }
      } else {
        if (((v = dP(v, c)), v !== null)) {
          (v.flags &= 32767), (Zr = v);
          return;
        }
        if (a !== null)
          (a.flags |= 32768), (a.subtreeFlags = 0), (a.deletions = null);
        else {
          (ai = 6), (Zr = null);
          return;
        }
      }
      if (((c = c.sibling), c !== null)) {
        Zr = c;
        return;
      }
      Zr = c = a;
    } while (c !== null);
    ai === 0 && (ai = 5);
  }
  function _c(a, c, v) {
    var b = sn,
      P = xs.transition;
    try {
      (xs.transition = null), (sn = 1), _P(a, c, v, b);
    } finally {
      (xs.transition = P), (sn = b);
    }
    return null;
  }
  function _P(a, c, v, b) {
    do fd();
    while (gu !== null);
    if ((gn & 6) !== 0) throw Error(t(327));
    v = a.finishedWork;
    var P = a.finishedLanes;
    if (v === null) return null;
    if (((a.finishedWork = null), (a.finishedLanes = 0), v === a.current))
      throw Error(t(177));
    (a.callbackNode = null), (a.callbackPriority = 0);
    var N = v.lanes | v.childLanes;
    if (
      (vf(a, N),
      a === mi && ((Zr = mi = null), (Pi = 0)),
      ((v.subtreeFlags & 2064) === 0 && (v.flags & 2064) === 0) ||
        bg ||
        ((bg = !0),
        $w(tn, function () {
          return fd(), null;
        })),
      (N = (v.flags & 15990) !== 0),
      (v.subtreeFlags & 15990) !== 0 || N)
    ) {
      (N = xs.transition), (xs.transition = null);
      var X = sn;
      sn = 1;
      var fe = gn;
      (gn |= 4),
        (ix.current = null),
        pP(a, v),
        Lw(v, a),
        Wr(Nh),
        (Br = !!eu),
        (Nh = eu = null),
        (a.current = v),
        mP(v),
        Et(),
        (gn = fe),
        (sn = X),
        (xs.transition = N);
    } else a.current = v;
    if (
      (bg && ((bg = !1), (gu = a), (Eg = P)),
      (N = a.pendingLanes),
      N === 0 && (mu = null),
      dt(v.stateNode),
      Io(a, Ke()),
      c !== null)
    )
      for (b = a.onRecoverableError, v = 0; v < c.length; v++)
        (P = c[v]), b(P.value, { componentStack: P.stack, digest: P.digest });
    if (Mg) throw ((Mg = !1), (a = ax), (ax = null), a);
    return (
      (Eg & 1) !== 0 && a.tag !== 0 && fd(),
      (N = a.pendingLanes),
      (N & 1) !== 0 ? (a === lx ? ip++ : ((ip = 0), (lx = a))) : (ip = 0),
      ps(),
      null
    );
  }
  function fd() {
    if (gu !== null) {
      var a = ls(Eg),
        c = xs.transition,
        v = sn;
      try {
        if (((xs.transition = null), (sn = 16 > a ? 16 : a), gu === null))
          var b = !1;
        else {
          if (((a = gu), (gu = null), (Eg = 0), (gn & 6) !== 0))
            throw Error(t(331));
          var P = gn;
          for (gn |= 4, Ct = a.current; Ct !== null; ) {
            var N = Ct,
              X = N.child;
            if ((Ct.flags & 16) !== 0) {
              var fe = N.deletions;
              if (fe !== null) {
                for (var ge = 0; ge < fe.length; ge++) {
                  var je = fe[ge];
                  for (Ct = je; Ct !== null; ) {
                    var st = Ct;
                    switch (st.tag) {
                      case 0:
                      case 11:
                      case 15:
                        tp(8, st, N);
                    }
                    var lt = st.child;
                    if (lt !== null) (lt.return = st), (Ct = lt);
                    else
                      for (; Ct !== null; ) {
                        st = Ct;
                        var ot = st.sibling,
                          bt = st.return;
                        if ((Cw(st), st === je)) {
                          Ct = null;
                          break;
                        }
                        if (ot !== null) {
                          (ot.return = bt), (Ct = ot);
                          break;
                        }
                        Ct = bt;
                      }
                  }
                }
                var Rt = N.alternate;
                if (Rt !== null) {
                  var It = Rt.child;
                  if (It !== null) {
                    Rt.child = null;
                    do {
                      var Ir = It.sibling;
                      (It.sibling = null), (It = Ir);
                    } while (It !== null);
                  }
                }
                Ct = N;
              }
            }
            if ((N.subtreeFlags & 2064) !== 0 && X !== null)
              (X.return = N), (Ct = X);
            else
              e: for (; Ct !== null; ) {
                if (((N = Ct), (N.flags & 2048) !== 0))
                  switch (N.tag) {
                    case 0:
                    case 11:
                    case 15:
                      tp(9, N, N.return);
                  }
                var De = N.sibling;
                if (De !== null) {
                  (De.return = N.return), (Ct = De);
                  break e;
                }
                Ct = N.return;
              }
          }
          var Se = a.current;
          for (Ct = Se; Ct !== null; ) {
            X = Ct;
            var Oe = X.child;
            if ((X.subtreeFlags & 2064) !== 0 && Oe !== null)
              (Oe.return = X), (Ct = Oe);
            else
              e: for (X = Se; Ct !== null; ) {
                if (((fe = Ct), (fe.flags & 2048) !== 0))
                  try {
                    switch (fe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        _g(9, fe);
                    }
                  } catch (kt) {
                    xr(fe, fe.return, kt);
                  }
                if (fe === X) {
                  Ct = null;
                  break e;
                }
                var ft = fe.sibling;
                if (ft !== null) {
                  (ft.return = fe.return), (Ct = ft);
                  break e;
                }
                Ct = fe.return;
              }
          }
          if (
            ((gn = P),
            ps(),
            wt && typeof wt.onPostCommitFiberRoot == "function")
          )
            try {
              wt.onPostCommitFiberRoot(Sn, a);
            } catch {}
          b = !0;
        }
        return b;
      } finally {
        (sn = v), (xs.transition = c);
      }
    }
    return !1;
  }
  function Gw(a, c, v) {
    (c = k(v, c)),
      (c = Qe(a, c, 1)),
      (a = ms(a, c, 1)),
      (c = co()),
      a !== null && (Fo(a, 1, c), Io(a, c));
  }
  function xr(a, c, v) {
    if (a.tag === 3) Gw(a, a, v);
    else
      for (; c !== null; ) {
        if (c.tag === 3) {
          Gw(c, a, v);
          break;
        } else if (c.tag === 1) {
          var b = c.stateNode;
          if (
            typeof c.type.getDerivedStateFromError == "function" ||
            (typeof b.componentDidCatch == "function" &&
              (mu === null || !mu.has(b)))
          ) {
            (a = k(v, a)),
              (a = ct(c, a, 1)),
              (c = ms(c, a, 1)),
              (a = co()),
              c !== null && (Fo(c, 1, a), Io(c, a));
            break;
          }
        }
        c = c.return;
      }
  }
  function SP(a, c, v) {
    var b = a.pingCache;
    b !== null && b.delete(c),
      (c = co()),
      (a.pingedLanes |= a.suspendedLanes & v),
      mi === a &&
        (Pi & v) === v &&
        (ai === 4 || (ai === 3 && (Pi & 130023424) === Pi && 500 > Ke() - sx)
          ? xc(a, 0)
          : (ox |= v)),
      Io(a, c);
  }
  function Ww(a, c) {
    c === 0 &&
      ((a.mode & 1) === 0
        ? (c = 1)
        : ((c = Bn), (Bn <<= 1), (Bn & 130023424) === 0 && (Bn = 4194304)));
    var v = co();
    (a = Yo(a, c)), a !== null && (Fo(a, c, v), Io(a, v));
  }
  function wP(a) {
    var c = a.memoizedState,
      v = 0;
    c !== null && (v = c.retryLane), Ww(a, v);
  }
  function MP(a, c) {
    var v = 0;
    switch (a.tag) {
      case 13:
        var b = a.stateNode,
          P = a.memoizedState;
        P !== null && (v = P.retryLane);
        break;
      case 19:
        b = a.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    b !== null && b.delete(c), Ww(a, v);
  }
  var jw;
  jw = function (a, c, v) {
    if (a !== null)
      if (a.memoizedProps !== c.pendingProps || wi.current) Mt = !0;
      else {
        if ((a.lanes & v) === 0 && (c.flags & 128) === 0)
          return (Mt = !1), cP(a, c, v);
        Mt = (a.flags & 131072) !== 0;
      }
    else (Mt = !1), Vn && (c.flags & 1048576) !== 0 && Wh(c, $f, c.index);
    switch (((c.lanes = 0), c.tag)) {
      case 2:
        var b = c.type;
        yg(a, c), (a = c.pendingProps);
        var P = il(c, oi.current);
        $s(c, v), (P = td(null, c, b, a, P, v));
        var N = fc();
        return (
          (c.flags |= 1),
          typeof P == "object" &&
          P !== null &&
          typeof P.render == "function" &&
          P.$$typeof === void 0
            ? ((c.tag = 1),
              (c.memoizedState = null),
              (c.updateQueue = null),
              hi(b) ? ((N = !0), ol(c)) : (N = !1),
              (c.memoizedState =
                P.state !== null && P.state !== void 0 ? P.state : null),
              cc(c),
              (P.updater = Ys),
              (c.stateNode = P),
              (P._reactInternals = c),
              lu(c, b, a, v),
              (c = Xt(null, c, b, !0, N, v)))
            : ((c.tag = 0), Vn && N && jh(c), Mn(null, c, P, v), (c = c.child)),
          c
        );
      case 16:
        b = c.elementType;
        e: {
          switch (
            (yg(a, c),
            (a = c.pendingProps),
            (P = b._init),
            (b = P(b._payload)),
            (c.type = b),
            (P = c.tag = EP(b)),
            (a = $o(b, a)),
            P)
          ) {
            case 0:
              c = Pt(null, c, b, a, v);
              break e;
            case 1:
              c = Jt(null, c, b, a, v);
              break e;
            case 11:
              c = uo(null, c, b, a, v);
              break e;
            case 14:
              c = Ve(null, c, b, $o(b.type, a), v);
              break e;
          }
          throw Error(t(306, b, ""));
        }
        return c;
      case 0:
        return (
          (b = c.type),
          (P = c.pendingProps),
          (P = c.elementType === b ? P : $o(b, P)),
          Pt(a, c, b, P, v)
        );
      case 1:
        return (
          (b = c.type),
          (P = c.pendingProps),
          (P = c.elementType === b ? P : $o(b, P)),
          Jt(a, c, b, P, v)
        );
      case 3:
        e: {
          if ((pn(c), a === null)) throw Error(t(387));
          (b = c.pendingProps),
            (N = c.memoizedState),
            (P = N.element),
            og(a, c),
            Zn(c, b, null, v);
          var X = c.memoizedState;
          if (((b = X.element), N.isDehydrated))
            if (
              ((N = {
                element: b,
                isDehydrated: !1,
                cache: X.cache,
                pendingSuspenseBoundaries: X.pendingSuspenseBoundaries,
                transitions: X.transitions,
              }),
              (c.updateQueue.baseState = N),
              (c.memoizedState = N),
              c.flags & 256)
            ) {
              (P = k(Error(t(423)), c)), (c = Pr(a, c, b, v, P));
              break e;
            } else if (b !== P) {
              (P = k(Error(t(424)), c)), (c = Pr(a, c, b, v, P));
              break e;
            } else
              for (
                bi = Bs(c.stateNode.containerInfo.firstChild),
                  si = c,
                  Vn = !0,
                  Eo = null,
                  v = fl(c, null, b, v),
                  c.child = v;
                v;

              )
                (v.flags = (v.flags & -3) | 4096), (v = v.sibling);
          else {
            if ((ba(), b === P)) {
              c = hl(a, c, v);
              break e;
            }
            Mn(a, c, b, v);
          }
          c = c.child;
        }
        return c;
      case 5:
        return (
          Qf(c),
          a === null && Yf(c),
          (b = c.type),
          (P = c.pendingProps),
          (N = a !== null ? a.memoizedProps : null),
          (X = P.children),
          Uh(b, P) ? (X = null) : N !== null && Uh(b, N) && (c.flags |= 32),
          _t(a, c),
          Mn(a, c, X, v),
          c.child
        );
      case 6:
        return a === null && Yf(c), null;
      case 13:
        return gg(a, c, v);
      case 4:
        return (
          uu(c, c.stateNode.containerInfo),
          (b = c.pendingProps),
          a === null ? (c.child = Ta(c, null, b, v)) : Mn(a, c, b, v),
          c.child
        );
      case 11:
        return (
          (b = c.type),
          (P = c.pendingProps),
          (P = c.elementType === b ? P : $o(b, P)),
          uo(a, c, b, P, v)
        );
      case 7:
        return Mn(a, c, c.pendingProps, v), c.child;
      case 8:
        return Mn(a, c, c.pendingProps.children, v), c.child;
      case 12:
        return Mn(a, c, c.pendingProps.children, v), c.child;
      case 10:
        e: {
          if (
            ((b = c.type._context),
            (P = c.pendingProps),
            (N = c.memoizedProps),
            (X = P.value),
            Dn(ac, b._currentValue),
            (b._currentValue = X),
            N !== null)
          )
            if (io(N.value, X)) {
              if (N.children === P.children && !wi.current) {
                c = hl(a, c, v);
                break e;
              }
            } else
              for (N = c.child, N !== null && (N.return = c); N !== null; ) {
                var fe = N.dependencies;
                if (fe !== null) {
                  X = N.child;
                  for (var ge = fe.firstContext; ge !== null; ) {
                    if (ge.context === b) {
                      if (N.tag === 1) {
                        (ge = To(-1, v & -v)), (ge.tag = 2);
                        var je = N.updateQueue;
                        if (je !== null) {
                          je = je.shared;
                          var st = je.pending;
                          st === null
                            ? (ge.next = ge)
                            : ((ge.next = st.next), (st.next = ge)),
                            (je.pending = ge);
                        }
                      }
                      (N.lanes |= v),
                        (ge = N.alternate),
                        ge !== null && (ge.lanes |= v),
                        su(N.return, v, c),
                        (fe.lanes |= v);
                      break;
                    }
                    ge = ge.next;
                  }
                } else if (N.tag === 10) X = N.type === c.type ? null : N.child;
                else if (N.tag === 18) {
                  if (((X = N.return), X === null)) throw Error(t(341));
                  (X.lanes |= v),
                    (fe = X.alternate),
                    fe !== null && (fe.lanes |= v),
                    su(X, v, c),
                    (X = N.sibling);
                } else X = N.child;
                if (X !== null) X.return = N;
                else
                  for (X = N; X !== null; ) {
                    if (X === c) {
                      X = null;
                      break;
                    }
                    if (((N = X.sibling), N !== null)) {
                      (N.return = X.return), (X = N);
                      break;
                    }
                    X = X.return;
                  }
                N = X;
              }
          Mn(a, c, P.children, v), (c = c.child);
        }
        return c;
      case 9:
        return (
          (P = c.type),
          (b = c.pendingProps.children),
          $s(c, v),
          (P = Ei(P)),
          (b = b(P)),
          (c.flags |= 1),
          Mn(a, c, b, v),
          c.child
        );
      case 14:
        return (
          (b = c.type),
          (P = $o(b, c.pendingProps)),
          (P = $o(b.type, P)),
          Ve(a, c, b, P, v)
        );
      case 15:
        return Re(a, c, c.type, c.pendingProps, v);
      case 17:
        return (
          (b = c.type),
          (P = c.pendingProps),
          (P = c.elementType === b ? P : $o(b, P)),
          yg(a, c),
          (c.tag = 1),
          hi(b) ? ((a = !0), ol(c)) : (a = !1),
          $s(c, v),
          au(c, b, P),
          lu(c, b, P, v),
          Xt(null, c, b, !0, a, v)
        );
      case 19:
        return ww(a, c, v);
      case 22:
        return Ze(a, c, v);
    }
    throw Error(t(156, c.tag));
  };
  function $w(a, c) {
    return Ie(a, c);
  }
  function bP(a, c, v, b) {
    (this.tag = a),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = c),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = b),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function _s(a, c, v, b) {
    return new bP(a, c, v, b);
  }
  function px(a) {
    return (a = a.prototype), !(!a || !a.isReactComponent);
  }
  function EP(a) {
    if (typeof a == "function") return px(a) ? 1 : 0;
    if (a != null) {
      if (((a = a.$$typeof), a === H)) return 11;
      if (a === K) return 14;
    }
    return 2;
  }
  function xu(a, c) {
    var v = a.alternate;
    return (
      v === null
        ? ((v = _s(a.tag, c, a.key, a.mode)),
          (v.elementType = a.elementType),
          (v.type = a.type),
          (v.stateNode = a.stateNode),
          (v.alternate = a),
          (a.alternate = v))
        : ((v.pendingProps = c),
          (v.type = a.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = a.flags & 14680064),
      (v.childLanes = a.childLanes),
      (v.lanes = a.lanes),
      (v.child = a.child),
      (v.memoizedProps = a.memoizedProps),
      (v.memoizedState = a.memoizedState),
      (v.updateQueue = a.updateQueue),
      (c = a.dependencies),
      (v.dependencies =
        c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }),
      (v.sibling = a.sibling),
      (v.index = a.index),
      (v.ref = a.ref),
      v
    );
  }
  function Rg(a, c, v, b, P, N) {
    var X = 2;
    if (((b = a), typeof a == "function")) px(a) && (X = 1);
    else if (typeof a == "string") X = 5;
    else
      e: switch (a) {
        case I:
          return Sc(v.children, P, N, c);
        case U:
          (X = 8), (P |= 8);
          break;
        case O:
          return (
            (a = _s(12, v, c, P | 2)), (a.elementType = O), (a.lanes = N), a
          );
        case $:
          return (a = _s(13, v, c, P)), (a.elementType = $), (a.lanes = N), a;
        case q:
          return (a = _s(19, v, c, P)), (a.elementType = q), (a.lanes = N), a;
        case ne:
          return Pg(v, P, N, c);
        default:
          if (typeof a == "object" && a !== null)
            switch (a.$$typeof) {
              case L:
                X = 10;
                break e;
              case V:
                X = 9;
                break e;
              case H:
                X = 11;
                break e;
              case K:
                X = 14;
                break e;
              case Y:
                (X = 16), (b = null);
                break e;
            }
          throw Error(t(130, a == null ? a : typeof a, ""));
      }
    return (
      (c = _s(X, v, c, P)), (c.elementType = a), (c.type = b), (c.lanes = N), c
    );
  }
  function Sc(a, c, v, b) {
    return (a = _s(7, a, b, c)), (a.lanes = v), a;
  }
  function Pg(a, c, v, b) {
    return (
      (a = _s(22, a, b, c)),
      (a.elementType = ne),
      (a.lanes = v),
      (a.stateNode = { isHidden: !1 }),
      a
    );
  }
  function mx(a, c, v) {
    return (a = _s(6, a, null, c)), (a.lanes = v), a;
  }
  function gx(a, c, v) {
    return (
      (c = _s(4, a.children !== null ? a.children : [], a.key, c)),
      (c.lanes = v),
      (c.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        implementation: a.implementation,
      }),
      c
    );
  }
  function TP(a, c, v, b, P) {
    (this.tag = c),
      (this.containerInfo = a),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Uo(0)),
      (this.expirationTimes = Uo(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Uo(0)),
      (this.identifierPrefix = b),
      (this.onRecoverableError = P),
      (this.mutableSourceEagerHydrationData = null);
  }
  function vx(a, c, v, b, P, N, X, fe, ge) {
    return (
      (a = new TP(a, c, v, fe, ge)),
      c === 1 ? ((c = 1), N === !0 && (c |= 8)) : (c = 0),
      (N = _s(3, null, null, c)),
      (a.current = N),
      (N.stateNode = a),
      (N.memoizedState = {
        element: b,
        isDehydrated: v,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      cc(N),
      a
    );
  }
  function CP(a, c, v) {
    var b =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: D,
      key: b == null ? null : "" + b,
      children: a,
      containerInfo: c,
      implementation: v,
    };
  }
  function Xw(a) {
    if (!a) return Hs;
    a = a._reactInternals;
    e: {
      if (eo(a) !== a || a.tag !== 1) throw Error(t(170));
      var c = a;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (hi(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(t(171));
    }
    if (a.tag === 1) {
      var v = a.type;
      if (hi(v)) return ic(a, v, c);
    }
    return c;
  }
  function Yw(a, c, v, b, P, N, X, fe, ge) {
    return (
      (a = vx(v, b, !0, a, P, N, X, fe, ge)),
      (a.context = Xw(null)),
      (v = a.current),
      (b = co()),
      (P = vu(v)),
      (N = To(b, P)),
      (N.callback = c ?? null),
      ms(v, N, P),
      (a.current.lanes = P),
      Fo(a, P, b),
      Io(a, b),
      a
    );
  }
  function Ig(a, c, v, b) {
    var P = c.current,
      N = co(),
      X = vu(P);
    return (
      (v = Xw(v)),
      c.context === null ? (c.context = v) : (c.pendingContext = v),
      (c = To(N, X)),
      (c.payload = { element: a }),
      (b = b === void 0 ? null : b),
      b !== null && (c.callback = b),
      (a = ms(P, c, X)),
      a !== null && (Js(a, P, X, N), jn(a, P, X)),
      X
    );
  }
  function Lg(a) {
    if (((a = a.current), !a.child)) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function qw(a, c) {
    if (((a = a.memoizedState), a !== null && a.dehydrated !== null)) {
      var v = a.retryLane;
      a.retryLane = v !== 0 && v < c ? v : c;
    }
  }
  function yx(a, c) {
    qw(a, c), (a = a.alternate) && qw(a, c);
  }
  function AP() {
    return null;
  }
  var Kw =
    typeof reportError == "function"
      ? reportError
      : function (a) {
          console.error(a);
        };
  function xx(a) {
    this._internalRoot = a;
  }
  (Dg.prototype.render = xx.prototype.render =
    function (a) {
      var c = this._internalRoot;
      if (c === null) throw Error(t(409));
      Ig(a, c, null, null);
    }),
    (Dg.prototype.unmount = xx.prototype.unmount =
      function () {
        var a = this._internalRoot;
        if (a !== null) {
          this._internalRoot = null;
          var c = a.containerInfo;
          yc(function () {
            Ig(null, a, null, null);
          }),
            (c[so] = null);
        }
      });
  function Dg(a) {
    this._internalRoot = a;
  }
  Dg.prototype.unstable_scheduleHydration = function (a) {
    if (a) {
      var c = us();
      a = { blockedOn: null, target: a, priority: c };
      for (var v = 0; v < xo.length && c !== 0 && c < xo[v].priority; v++);
      xo.splice(v, 0, a), v === 0 && fi(a);
    }
  };
  function _x(a) {
    return !(!a || (a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11));
  }
  function kg(a) {
    return !(
      !a ||
      (a.nodeType !== 1 &&
        a.nodeType !== 9 &&
        a.nodeType !== 11 &&
        (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function Zw() {}
  function RP(a, c, v, b, P) {
    if (P) {
      if (typeof b == "function") {
        var N = b;
        b = function () {
          var je = Lg(X);
          N.call(je);
        };
      }
      var X = Yw(c, b, a, 0, null, !1, !1, "", Zw);
      return (
        (a._reactRootContainer = X),
        (a[so] = X.current),
        Jl(a.nodeType === 8 ? a.parentNode : a),
        yc(),
        X
      );
    }
    for (; (P = a.lastChild); ) a.removeChild(P);
    if (typeof b == "function") {
      var fe = b;
      b = function () {
        var je = Lg(ge);
        fe.call(je);
      };
    }
    var ge = vx(a, 0, !1, null, null, !1, !1, "", Zw);
    return (
      (a._reactRootContainer = ge),
      (a[so] = ge.current),
      Jl(a.nodeType === 8 ? a.parentNode : a),
      yc(function () {
        Ig(c, ge, v, b);
      }),
      ge
    );
  }
  function Og(a, c, v, b, P) {
    var N = v._reactRootContainer;
    if (N) {
      var X = N;
      if (typeof P == "function") {
        var fe = P;
        P = function () {
          var ge = Lg(X);
          fe.call(ge);
        };
      }
      Ig(c, X, a, P);
    } else X = RP(v, c, a, P, b);
    return Lg(X);
  }
  (fa = function (a) {
    switch (a.tag) {
      case 3:
        var c = a.stateNode;
        if (c.current.memoizedState.isDehydrated) {
          var v = ln(c.pendingLanes);
          v !== 0 &&
            (zo(c, v | 1),
            Io(c, Ke()),
            (gn & 6) === 0 && ((cd = Ke() + 500), ps()));
        }
        break;
      case 13:
        yc(function () {
          var b = Yo(a, 1);
          if (b !== null) {
            var P = co();
            Js(b, a, 1, P);
          }
        }),
          yx(a, 1);
    }
  }),
    (Bl = function (a) {
      if (a.tag === 13) {
        var c = Yo(a, 134217728);
        if (c !== null) {
          var v = co();
          Js(c, a, 134217728, v);
        }
        yx(a, 134217728);
      }
    }),
    (Vl = function (a) {
      if (a.tag === 13) {
        var c = vu(a),
          v = Yo(a, c);
        if (v !== null) {
          var b = co();
          Js(v, a, c, b);
        }
        yx(a, c);
      }
    }),
    (us = function () {
      return sn;
    }),
    ($a = function (a, c) {
      var v = sn;
      try {
        return (sn = a), c();
      } finally {
        sn = v;
      }
    }),
    (Ce = function (a, c, v) {
      switch (c) {
        case "input":
          if ((rt(a, v), (c = v.name), v.type === "radio" && c != null)) {
            for (v = a; v.parentNode; ) v = v.parentNode;
            for (
              v = v.querySelectorAll(
                "input[name=" + JSON.stringify("" + c) + '][type="radio"]'
              ),
                c = 0;
              c < v.length;
              c++
            ) {
              var b = v[c];
              if (b !== a && b.form === a.form) {
                var P = Gf(b);
                if (!P) throw Error(t(90));
                W(b), rt(b, P);
              }
            }
          }
          break;
        case "textarea":
          ye(a, v);
          break;
        case "select":
          (c = v.value), c != null && F(a, !!v.multiple, c, !1);
      }
    }),
    (Nt = fx),
    (ht = yc);
  var PP = { usingClientEntryPoint: !1, Events: [Vs, ar, Gf, gt, Ot, fx] },
    op = {
      findFiberByHostInstance: Ma,
      bundleType: 0,
      version: "18.2.0",
      rendererPackageName: "react-dom",
    },
    IP = {
      bundleType: op.bundleType,
      version: op.version,
      rendererPackageName: op.rendererPackageName,
      rendererConfig: op.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: A.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (a) {
        return (a = Be(a)), a === null ? null : a.stateNode;
      },
      findFiberByHostInstance: op.findFiberByHostInstance || AP,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ng = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ng.isDisabled && Ng.supportsFiber)
      try {
        (Sn = Ng.inject(IP)), (wt = Ng);
      } catch {}
  }
  return (
    (Lo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = PP),
    (Lo.createPortal = function (a, c) {
      var v =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!_x(c)) throw Error(t(200));
      return CP(a, c, null, v);
    }),
    (Lo.createRoot = function (a, c) {
      if (!_x(a)) throw Error(t(299));
      var v = !1,
        b = "",
        P = Kw;
      return (
        c != null &&
          (c.unstable_strictMode === !0 && (v = !0),
          c.identifierPrefix !== void 0 && (b = c.identifierPrefix),
          c.onRecoverableError !== void 0 && (P = c.onRecoverableError)),
        (c = vx(a, 1, !1, null, null, v, !1, b, P)),
        (a[so] = c.current),
        Jl(a.nodeType === 8 ? a.parentNode : a),
        new xx(c)
      );
    }),
    (Lo.findDOMNode = function (a) {
      if (a == null) return null;
      if (a.nodeType === 1) return a;
      var c = a._reactInternals;
      if (c === void 0)
        throw typeof a.render == "function"
          ? Error(t(188))
          : ((a = Object.keys(a).join(",")), Error(t(268, a)));
      return (a = Be(c)), (a = a === null ? null : a.stateNode), a;
    }),
    (Lo.flushSync = function (a) {
      return yc(a);
    }),
    (Lo.hydrate = function (a, c, v) {
      if (!kg(c)) throw Error(t(200));
      return Og(null, a, c, !0, v);
    }),
    (Lo.hydrateRoot = function (a, c, v) {
      if (!_x(a)) throw Error(t(405));
      var b = (v != null && v.hydratedSources) || null,
        P = !1,
        N = "",
        X = Kw;
      if (
        (v != null &&
          (v.unstable_strictMode === !0 && (P = !0),
          v.identifierPrefix !== void 0 && (N = v.identifierPrefix),
          v.onRecoverableError !== void 0 && (X = v.onRecoverableError)),
        (c = Yw(c, null, a, 1, v ?? null, P, !1, N, X)),
        (a[so] = c.current),
        Jl(a),
        b)
      )
        for (a = 0; a < b.length; a++)
          (v = b[a]),
            (P = v._getVersion),
            (P = P(v._source)),
            c.mutableSourceEagerHydrationData == null
              ? (c.mutableSourceEagerHydrationData = [v, P])
              : c.mutableSourceEagerHydrationData.push(v, P);
      return new Dg(c);
    }),
    (Lo.render = function (a, c, v) {
      if (!kg(c)) throw Error(t(200));
      return Og(null, a, c, !1, v);
    }),
    (Lo.unmountComponentAtNode = function (a) {
      if (!kg(a)) throw Error(t(40));
      return a._reactRootContainer
        ? (yc(function () {
            Og(null, null, a, !1, function () {
              (a._reactRootContainer = null), (a[so] = null);
            });
          }),
          !0)
        : !1;
    }),
    (Lo.unstable_batchedUpdates = fx),
    (Lo.unstable_renderSubtreeIntoContainer = function (a, c, v, b) {
      if (!kg(v)) throw Error(t(200));
      if (a == null || a._reactInternals === void 0) throw Error(t(38));
      return Og(a, c, v, !1, b);
    }),
    (Lo.version = "18.2.0-next-9e3b772b8-20220608"),
    Lo
  );
}
var oM;
function iC() {
  if (oM) return Mx.exports;
  oM = 1;
  function n() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
  }
  return n(), (Mx.exports = zP()), Mx.exports;
}
var sM;
function BP() {
  if (sM) return Ug;
  sM = 1;
  var n = iC();
  return (Ug.createRoot = n.createRoot), (Ug.hydrateRoot = n.hydrateRoot), Ug;
}
var VP = BP();
const HP = Tm(VP);
var Tx = { exports: {} },
  Cx = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var aM;
function GP() {
  if (aM) return Cx;
  aM = 1;
  var n = hh();
  function e(m, g) {
    return (m === g && (m !== 0 || 1 / m === 1 / g)) || (m !== m && g !== g);
  }
  var t = typeof Object.is == "function" ? Object.is : e,
    r = n.useState,
    i = n.useEffect,
    o = n.useLayoutEffect,
    s = n.useDebugValue;
  function l(m, g) {
    var y = g(),
      _ = r({ inst: { value: y, getSnapshot: g } }),
      S = _[0].inst,
      x = _[1];
    return (
      o(
        function () {
          (S.value = y), (S.getSnapshot = g), u(S) && x({ inst: S });
        },
        [m, y, g]
      ),
      i(
        function () {
          return (
            u(S) && x({ inst: S }),
            m(function () {
              u(S) && x({ inst: S });
            })
          );
        },
        [m]
      ),
      s(y),
      y
    );
  }
  function u(m) {
    var g = m.getSnapshot;
    m = m.value;
    try {
      var y = g();
      return !t(m, y);
    } catch {
      return !0;
    }
  }
  function f(m, g) {
    return g();
  }
  var h =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? f
      : l;
  return (
    (Cx.useSyncExternalStore =
      n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : h),
    Cx
  );
}
var lM;
function oC() {
  return lM || ((lM = 1), (Tx.exports = GP())), Tx.exports;
}
oC();
var Ax = { exports: {} },
  Rx = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var uM;
function WP() {
  if (uM) return Rx;
  uM = 1;
  var n = hh(),
    e = oC();
  function t(f, h) {
    return (f === h && (f !== 0 || 1 / f === 1 / h)) || (f !== f && h !== h);
  }
  var r = typeof Object.is == "function" ? Object.is : t,
    i = e.useSyncExternalStore,
    o = n.useRef,
    s = n.useEffect,
    l = n.useMemo,
    u = n.useDebugValue;
  return (
    (Rx.useSyncExternalStoreWithSelector = function (f, h, m, g, y) {
      var _ = o(null);
      if (_.current === null) {
        var S = { hasValue: !1, value: null };
        _.current = S;
      } else S = _.current;
      _ = l(
        function () {
          function w(D) {
            if (!T) {
              if (((T = !0), (E = D), (D = g(D)), y !== void 0 && S.hasValue)) {
                var I = S.value;
                if (y(I, D)) return (A = I);
              }
              return (A = D);
            }
            if (((I = A), r(E, D))) return I;
            var U = g(D);
            return y !== void 0 && y(I, U) ? ((E = D), I) : ((E = D), (A = U));
          }
          var T = !1,
            E,
            A,
            R = m === void 0 ? null : m;
          return [
            function () {
              return w(h());
            },
            R === null
              ? void 0
              : function () {
                  return w(R());
                },
          ];
        },
        [h, m, g, y]
      );
      var x = i(f, _[0], _[1]);
      return (
        s(
          function () {
            (S.hasValue = !0), (S.value = x);
          },
          [x]
        ),
        u(x),
        x
      );
    }),
    Rx
  );
}
var cM;
function jP() {
  return cM || ((cM = 1), (Ax.exports = WP())), Ax.exports;
}
var $P = jP(),
  Q1 = iC();
const Fg = Tm(Q1);
function XP(n) {
  n();
}
let sC = XP;
const YP = (n) => (sC = n),
  qP = () => sC,
  fM = Symbol.for("react-redux-context"),
  dM = typeof globalThis < "u" ? globalThis : {};
function KP() {
  var n;
  if (!ee.createContext) return {};
  const e = (n = dM[fM]) != null ? n : (dM[fM] = new Map());
  let t = e.get(ee.createContext);
  return t || ((t = ee.createContext(null)), e.set(ee.createContext, t)), t;
}
const Uu = KP();
function eS(n = Uu) {
  return function () {
    return ee.useContext(n);
  };
}
const aC = eS(),
  ZP = () => {
    throw new Error("uSES not initialized!");
  };
let lC = ZP;
const JP = (n) => {
    lC = n;
  },
  QP = (n, e) => n === e;
function e3(n = Uu) {
  const e = n === Uu ? aC : eS(n);
  return function (r, i = {}) {
    const {
        equalityFn: o = QP,
        stabilityCheck: s = void 0,
        noopCheck: l = void 0,
      } = typeof i == "function" ? { equalityFn: i } : i,
      {
        store: u,
        subscription: f,
        getServerState: h,
        stabilityCheck: m,
        noopCheck: g,
      } = e();
    ee.useRef(!0);
    const y = ee.useCallback(
        {
          [r.name](S) {
            return r(S);
          },
        }[r.name],
        [r, m, s]
      ),
      _ = lC(f.addNestedSub, u.getState, h || u.getState, y, o);
    return ee.useDebugValue(_), _;
  };
}
const W0 = e3();
function pe() {
  return (
    (pe = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    pe.apply(null, arguments)
  );
}
function Ft(n, e) {
  if (n == null) return {};
  var t = {};
  for (var r in n)
    if ({}.hasOwnProperty.call(n, r)) {
      if (e.indexOf(r) !== -1) continue;
      t[r] = n[r];
    }
  return t;
}
var Px = { exports: {} },
  Pn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hM;
function t3() {
  if (hM) return Pn;
  hM = 1;
  var n = typeof Symbol == "function" && Symbol.for,
    e = n ? Symbol.for("react.element") : 60103,
    t = n ? Symbol.for("react.portal") : 60106,
    r = n ? Symbol.for("react.fragment") : 60107,
    i = n ? Symbol.for("react.strict_mode") : 60108,
    o = n ? Symbol.for("react.profiler") : 60114,
    s = n ? Symbol.for("react.provider") : 60109,
    l = n ? Symbol.for("react.context") : 60110,
    u = n ? Symbol.for("react.async_mode") : 60111,
    f = n ? Symbol.for("react.concurrent_mode") : 60111,
    h = n ? Symbol.for("react.forward_ref") : 60112,
    m = n ? Symbol.for("react.suspense") : 60113,
    g = n ? Symbol.for("react.suspense_list") : 60120,
    y = n ? Symbol.for("react.memo") : 60115,
    _ = n ? Symbol.for("react.lazy") : 60116,
    S = n ? Symbol.for("react.block") : 60121,
    x = n ? Symbol.for("react.fundamental") : 60117,
    w = n ? Symbol.for("react.responder") : 60118,
    T = n ? Symbol.for("react.scope") : 60119;
  function E(R) {
    if (typeof R == "object" && R !== null) {
      var D = R.$$typeof;
      switch (D) {
        case e:
          switch (((R = R.type), R)) {
            case u:
            case f:
            case r:
            case o:
            case i:
            case m:
              return R;
            default:
              switch (((R = R && R.$$typeof), R)) {
                case l:
                case h:
                case _:
                case y:
                case s:
                  return R;
                default:
                  return D;
              }
          }
        case t:
          return D;
      }
    }
  }
  function A(R) {
    return E(R) === f;
  }
  return (
    (Pn.AsyncMode = u),
    (Pn.ConcurrentMode = f),
    (Pn.ContextConsumer = l),
    (Pn.ContextProvider = s),
    (Pn.Element = e),
    (Pn.ForwardRef = h),
    (Pn.Fragment = r),
    (Pn.Lazy = _),
    (Pn.Memo = y),
    (Pn.Portal = t),
    (Pn.Profiler = o),
    (Pn.StrictMode = i),
    (Pn.Suspense = m),
    (Pn.isAsyncMode = function (R) {
      return A(R) || E(R) === u;
    }),
    (Pn.isConcurrentMode = A),
    (Pn.isContextConsumer = function (R) {
      return E(R) === l;
    }),
    (Pn.isContextProvider = function (R) {
      return E(R) === s;
    }),
    (Pn.isElement = function (R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }),
    (Pn.isForwardRef = function (R) {
      return E(R) === h;
    }),
    (Pn.isFragment = function (R) {
      return E(R) === r;
    }),
    (Pn.isLazy = function (R) {
      return E(R) === _;
    }),
    (Pn.isMemo = function (R) {
      return E(R) === y;
    }),
    (Pn.isPortal = function (R) {
      return E(R) === t;
    }),
    (Pn.isProfiler = function (R) {
      return E(R) === o;
    }),
    (Pn.isStrictMode = function (R) {
      return E(R) === i;
    }),
    (Pn.isSuspense = function (R) {
      return E(R) === m;
    }),
    (Pn.isValidElementType = function (R) {
      return (
        typeof R == "string" ||
        typeof R == "function" ||
        R === r ||
        R === f ||
        R === o ||
        R === i ||
        R === m ||
        R === g ||
        (typeof R == "object" &&
          R !== null &&
          (R.$$typeof === _ ||
            R.$$typeof === y ||
            R.$$typeof === s ||
            R.$$typeof === l ||
            R.$$typeof === h ||
            R.$$typeof === x ||
            R.$$typeof === w ||
            R.$$typeof === T ||
            R.$$typeof === S))
      );
    }),
    (Pn.typeOf = E),
    Pn
  );
}
var pM;
function n3() {
  return pM || ((pM = 1), (Px.exports = t3())), Px.exports;
}
var Ix, mM;
function r3() {
  if (mM) return Ix;
  mM = 1;
  var n = n3(),
    e = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0,
    },
    t = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0,
    },
    r = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
    },
    i = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0,
    },
    o = {};
  (o[n.ForwardRef] = r), (o[n.Memo] = i);
  function s(_) {
    return n.isMemo(_) ? i : o[_.$$typeof] || e;
  }
  var l = Object.defineProperty,
    u = Object.getOwnPropertyNames,
    f = Object.getOwnPropertySymbols,
    h = Object.getOwnPropertyDescriptor,
    m = Object.getPrototypeOf,
    g = Object.prototype;
  function y(_, S, x) {
    if (typeof S != "string") {
      if (g) {
        var w = m(S);
        w && w !== g && y(_, w, x);
      }
      var T = u(S);
      f && (T = T.concat(f(S)));
      for (var E = s(_), A = s(S), R = 0; R < T.length; ++R) {
        var D = T[R];
        if (!t[D] && !(x && x[D]) && !(A && A[D]) && !(E && E[D])) {
          var I = h(S, D);
          try {
            l(_, D, I);
          } catch {}
        }
      }
    }
    return _;
  }
  return (Ix = y), Ix;
}
r3();
var Lx = { exports: {} },
  In = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gM;
function i3() {
  if (gM) return In;
  gM = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.server_context"),
    u = Symbol.for("react.forward_ref"),
    f = Symbol.for("react.suspense"),
    h = Symbol.for("react.suspense_list"),
    m = Symbol.for("react.memo"),
    g = Symbol.for("react.lazy"),
    y = Symbol.for("react.offscreen"),
    _;
  _ = Symbol.for("react.module.reference");
  function S(x) {
    if (typeof x == "object" && x !== null) {
      var w = x.$$typeof;
      switch (w) {
        case n:
          switch (((x = x.type), x)) {
            case t:
            case i:
            case r:
            case f:
            case h:
              return x;
            default:
              switch (((x = x && x.$$typeof), x)) {
                case l:
                case s:
                case u:
                case g:
                case m:
                case o:
                  return x;
                default:
                  return w;
              }
          }
        case e:
          return w;
      }
    }
  }
  return (
    (In.ContextConsumer = s),
    (In.ContextProvider = o),
    (In.Element = n),
    (In.ForwardRef = u),
    (In.Fragment = t),
    (In.Lazy = g),
    (In.Memo = m),
    (In.Portal = e),
    (In.Profiler = i),
    (In.StrictMode = r),
    (In.Suspense = f),
    (In.SuspenseList = h),
    (In.isAsyncMode = function () {
      return !1;
    }),
    (In.isConcurrentMode = function () {
      return !1;
    }),
    (In.isContextConsumer = function (x) {
      return S(x) === s;
    }),
    (In.isContextProvider = function (x) {
      return S(x) === o;
    }),
    (In.isElement = function (x) {
      return typeof x == "object" && x !== null && x.$$typeof === n;
    }),
    (In.isForwardRef = function (x) {
      return S(x) === u;
    }),
    (In.isFragment = function (x) {
      return S(x) === t;
    }),
    (In.isLazy = function (x) {
      return S(x) === g;
    }),
    (In.isMemo = function (x) {
      return S(x) === m;
    }),
    (In.isPortal = function (x) {
      return S(x) === e;
    }),
    (In.isProfiler = function (x) {
      return S(x) === i;
    }),
    (In.isStrictMode = function (x) {
      return S(x) === r;
    }),
    (In.isSuspense = function (x) {
      return S(x) === f;
    }),
    (In.isSuspenseList = function (x) {
      return S(x) === h;
    }),
    (In.isValidElementType = function (x) {
      return (
        typeof x == "string" ||
        typeof x == "function" ||
        x === t ||
        x === i ||
        x === r ||
        x === f ||
        x === h ||
        x === y ||
        (typeof x == "object" &&
          x !== null &&
          (x.$$typeof === g ||
            x.$$typeof === m ||
            x.$$typeof === o ||
            x.$$typeof === s ||
            x.$$typeof === u ||
            x.$$typeof === _ ||
            x.getModuleId !== void 0))
      );
    }),
    (In.typeOf = S),
    In
  );
}
var vM;
function o3() {
  return vM || ((vM = 1), (Lx.exports = i3())), Lx.exports;
}
o3();
function s3() {
  const n = qP();
  let e = null,
    t = null;
  return {
    clear() {
      (e = null), (t = null);
    },
    notify() {
      n(() => {
        let r = e;
        for (; r; ) r.callback(), (r = r.next);
      });
    },
    get() {
      let r = [],
        i = e;
      for (; i; ) r.push(i), (i = i.next);
      return r;
    },
    subscribe(r) {
      let i = !0,
        o = (t = { callback: r, next: null, prev: t });
      return (
        o.prev ? (o.prev.next = o) : (e = o),
        function () {
          !i ||
            e === null ||
            ((i = !1),
            o.next ? (o.next.prev = o.prev) : (t = o.prev),
            o.prev ? (o.prev.next = o.next) : (e = o.next));
        }
      );
    },
  };
}
const yM = { notify() {}, get: () => [] };
function a3(n, e) {
  let t,
    r = yM,
    i = 0,
    o = !1;
  function s(S) {
    h();
    const x = r.subscribe(S);
    let w = !1;
    return () => {
      w || ((w = !0), x(), m());
    };
  }
  function l() {
    r.notify();
  }
  function u() {
    _.onStateChange && _.onStateChange();
  }
  function f() {
    return o;
  }
  function h() {
    i++, t || ((t = n.subscribe(u)), (r = s3()));
  }
  function m() {
    i--, t && i === 0 && (t(), (t = void 0), r.clear(), (r = yM));
  }
  function g() {
    o || ((o = !0), h());
  }
  function y() {
    o && ((o = !1), m());
  }
  const _ = {
    addNestedSub: s,
    notifyNestedSubs: l,
    handleChangeWrapper: u,
    isSubscribed: f,
    trySubscribe: g,
    tryUnsubscribe: y,
    getListeners: () => r,
  };
  return _;
}
const l3 =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  u3 = l3 ? ee.useLayoutEffect : ee.useEffect;
function c3({
  store: n,
  context: e,
  children: t,
  serverState: r,
  stabilityCheck: i = "once",
  noopCheck: o = "once",
}) {
  const s = ee.useMemo(() => {
      const f = a3(n);
      return {
        store: n,
        subscription: f,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        noopCheck: o,
      };
    }, [n, r, i, o]),
    l = ee.useMemo(() => n.getState(), [n]);
  u3(() => {
    const { subscription: f } = s;
    return (
      (f.onStateChange = f.notifyNestedSubs),
      f.trySubscribe(),
      l !== n.getState() && f.notifyNestedSubs(),
      () => {
        f.tryUnsubscribe(), (f.onStateChange = void 0);
      }
    );
  }, [s, l]);
  const u = e || Uu;
  return ee.createElement(u.Provider, { value: s }, t);
}
function uC(n = Uu) {
  const e = n === Uu ? aC : eS(n);
  return function () {
    const { store: r } = e();
    return r;
  };
}
const f3 = uC();
function d3(n = Uu) {
  const e = n === Uu ? f3 : uC(n);
  return function () {
    return e().dispatch;
  };
}
const cC = d3();
JP($P.useSyncExternalStoreWithSelector);
YP(Q1.unstable_batchedUpdates);
const Zp = { black: "#000", white: "#fff" },
  dd = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828",
  },
  hd = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2",
  },
  pd = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0",
  },
  md = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b",
  },
  gd = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
  },
  ap = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100",
  },
  h3 = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161",
  };
function Rl(n) {
  let e = "https://mui.com/production-error/?code=" + n;
  for (let t = 1; t < arguments.length; t += 1)
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified MUI error #" + n + "; visit " + e + " for the full message.";
}
const p3 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: Rl },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  j0 = "$$material";
function fC(n) {
  var e = Object.create(null);
  return function (t) {
    return e[t] === void 0 && (e[t] = n(t)), e[t];
  };
}
var m3 =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  g3 = fC(function (n) {
    return (
      m3.test(n) ||
      (n.charCodeAt(0) === 111 &&
        n.charCodeAt(1) === 110 &&
        n.charCodeAt(2) < 91)
    );
  });
function v3(n) {
  if (n.sheet) return n.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === n) return document.styleSheets[e];
}
function y3(n) {
  var e = document.createElement("style");
  return (
    e.setAttribute("data-emotion", n.key),
    n.nonce !== void 0 && e.setAttribute("nonce", n.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
  );
}
var x3 = (function () {
    function n(t) {
      var r = this;
      (this._insertTag = function (i) {
        var o;
        r.tags.length === 0
          ? r.insertionPoint
            ? (o = r.insertionPoint.nextSibling)
            : r.prepend
            ? (o = r.container.firstChild)
            : (o = r.before)
          : (o = r.tags[r.tags.length - 1].nextSibling),
          r.container.insertBefore(i, o),
          r.tags.push(i);
      }),
        (this.isSpeedy = t.speedy === void 0 ? !0 : t.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = t.nonce),
        (this.key = t.key),
        (this.container = t.container),
        (this.prepend = t.prepend),
        (this.insertionPoint = t.insertionPoint),
        (this.before = null);
    }
    var e = n.prototype;
    return (
      (e.hydrate = function (r) {
        r.forEach(this._insertTag);
      }),
      (e.insert = function (r) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(y3(this));
        var i = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var o = v3(i);
          try {
            o.insertRule(r, o.cssRules.length);
          } catch {}
        } else i.appendChild(document.createTextNode(r));
        this.ctr++;
      }),
      (e.flush = function () {
        this.tags.forEach(function (r) {
          var i;
          return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      n
    );
  })(),
  Yi = "-ms-",
  Jv = "-moz-",
  An = "-webkit-",
  dC = "comm",
  tS = "rule",
  nS = "decl",
  _3 = "@import",
  hC = "@keyframes",
  S3 = "@layer",
  w3 = Math.abs,
  $0 = String.fromCharCode,
  M3 = Object.assign;
function b3(n, e) {
  return Li(n, 0) ^ 45
    ? (((((((e << 2) ^ Li(n, 0)) << 2) ^ Li(n, 1)) << 2) ^ Li(n, 2)) << 2) ^
        Li(n, 3)
    : 0;
}
function pC(n) {
  return n.trim();
}
function E3(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function Rn(n, e, t) {
  return n.replace(e, t);
}
function f1(n, e) {
  return n.indexOf(e);
}
function Li(n, e) {
  return n.charCodeAt(e) | 0;
}
function Jp(n, e, t) {
  return n.slice(e, t);
}
function ka(n) {
  return n.length;
}
function rS(n) {
  return n.length;
}
function zg(n, e) {
  return e.push(n), n;
}
function T3(n, e) {
  return n.map(e).join("");
}
var X0 = 1,
  oh = 1,
  mC = 0,
  Oo = 0,
  ei = 0,
  ph = "";
function Y0(n, e, t, r, i, o, s) {
  return {
    value: n,
    root: e,
    parent: t,
    type: r,
    props: i,
    children: o,
    line: X0,
    column: oh,
    length: s,
    return: "",
  };
}
function lp(n, e) {
  return M3(Y0("", null, null, "", null, null, 0), n, { length: -n.length }, e);
}
function C3() {
  return ei;
}
function A3() {
  return (
    (ei = Oo > 0 ? Li(ph, --Oo) : 0), oh--, ei === 10 && ((oh = 1), X0--), ei
  );
}
function ns() {
  return (
    (ei = Oo < mC ? Li(ph, Oo++) : 0), oh++, ei === 10 && ((oh = 1), X0++), ei
  );
}
function Fa() {
  return Li(ph, Oo);
}
function Hv() {
  return Oo;
}
function Cm(n, e) {
  return Jp(ph, n, e);
}
function Qp(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function gC(n) {
  return (X0 = oh = 1), (mC = ka((ph = n))), (Oo = 0), [];
}
function vC(n) {
  return (ph = ""), n;
}
function Gv(n) {
  return pC(Cm(Oo - 1, d1(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function R3(n) {
  for (; (ei = Fa()) && ei < 33; ) ns();
  return Qp(n) > 2 || Qp(ei) > 3 ? "" : " ";
}
function P3(n, e) {
  for (
    ;
    --e &&
    ns() &&
    !(ei < 48 || ei > 102 || (ei > 57 && ei < 65) || (ei > 70 && ei < 97));

  );
  return Cm(n, Hv() + (e < 6 && Fa() == 32 && ns() == 32));
}
function d1(n) {
  for (; ns(); )
    switch (ei) {
      case n:
        return Oo;
      case 34:
      case 39:
        n !== 34 && n !== 39 && d1(ei);
        break;
      case 40:
        n === 41 && d1(n);
        break;
      case 92:
        ns();
        break;
    }
  return Oo;
}
function I3(n, e) {
  for (; ns() && n + ei !== 57; ) if (n + ei === 84 && Fa() === 47) break;
  return "/*" + Cm(e, Oo - 1) + "*" + $0(n === 47 ? n : ns());
}
function L3(n) {
  for (; !Qp(Fa()); ) ns();
  return Cm(n, Oo);
}
function D3(n) {
  return vC(Wv("", null, null, null, [""], (n = gC(n)), 0, [0], n));
}
function Wv(n, e, t, r, i, o, s, l, u) {
  for (
    var f = 0,
      h = 0,
      m = s,
      g = 0,
      y = 0,
      _ = 0,
      S = 1,
      x = 1,
      w = 1,
      T = 0,
      E = "",
      A = i,
      R = o,
      D = r,
      I = E;
    x;

  )
    switch (((_ = T), (T = ns()))) {
      case 40:
        if (_ != 108 && Li(I, m - 1) == 58) {
          f1((I += Rn(Gv(T), "&", "&\f")), "&\f") != -1 && (w = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        I += Gv(T);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        I += R3(_);
        break;
      case 92:
        I += P3(Hv() - 1, 7);
        continue;
      case 47:
        switch (Fa()) {
          case 42:
          case 47:
            zg(k3(I3(ns(), Hv()), e, t), u);
            break;
          default:
            I += "/";
        }
        break;
      case 123 * S:
        l[f++] = ka(I) * w;
      case 125 * S:
      case 59:
      case 0:
        switch (T) {
          case 0:
          case 125:
            x = 0;
          case 59 + h:
            w == -1 && (I = Rn(I, /\f/g, "")),
              y > 0 &&
                ka(I) - m &&
                zg(
                  y > 32
                    ? _M(I + ";", r, t, m - 1)
                    : _M(Rn(I, " ", "") + ";", r, t, m - 2),
                  u
                );
            break;
          case 59:
            I += ";";
          default:
            if (
              (zg((D = xM(I, e, t, f, h, i, l, E, (A = []), (R = []), m)), o),
              T === 123)
            )
              if (h === 0) Wv(I, e, D, D, A, o, m, l, R);
              else
                switch (g === 99 && Li(I, 3) === 110 ? 100 : g) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Wv(
                      n,
                      D,
                      D,
                      r && zg(xM(n, D, D, 0, 0, i, l, E, i, (A = []), m), R),
                      i,
                      R,
                      m,
                      l,
                      r ? A : R
                    );
                    break;
                  default:
                    Wv(I, D, D, D, [""], R, 0, l, R);
                }
        }
        (f = h = y = 0), (S = w = 1), (E = I = ""), (m = s);
        break;
      case 58:
        (m = 1 + ka(I)), (y = _);
      default:
        if (S < 1) {
          if (T == 123) --S;
          else if (T == 125 && S++ == 0 && A3() == 125) continue;
        }
        switch (((I += $0(T)), T * S)) {
          case 38:
            w = h > 0 ? 1 : ((I += "\f"), -1);
            break;
          case 44:
            (l[f++] = (ka(I) - 1) * w), (w = 1);
            break;
          case 64:
            Fa() === 45 && (I += Gv(ns())),
              (g = Fa()),
              (h = m = ka((E = I += L3(Hv())))),
              T++;
            break;
          case 45:
            _ === 45 && ka(I) == 2 && (S = 0);
        }
    }
  return o;
}
function xM(n, e, t, r, i, o, s, l, u, f, h) {
  for (
    var m = i - 1, g = i === 0 ? o : [""], y = rS(g), _ = 0, S = 0, x = 0;
    _ < r;
    ++_
  )
    for (var w = 0, T = Jp(n, m + 1, (m = w3((S = s[_])))), E = n; w < y; ++w)
      (E = pC(S > 0 ? g[w] + " " + T : Rn(T, /&\f/g, g[w]))) && (u[x++] = E);
  return Y0(n, e, t, i === 0 ? tS : l, u, f, h);
}
function k3(n, e, t) {
  return Y0(n, e, t, dC, $0(C3()), Jp(n, 2, -2), 0);
}
function _M(n, e, t, r) {
  return Y0(n, e, t, nS, Jp(n, 0, r), Jp(n, r + 1, -1), r);
}
function Qd(n, e) {
  for (var t = "", r = rS(n), i = 0; i < r; i++) t += e(n[i], i, n, e) || "";
  return t;
}
function O3(n, e, t, r) {
  switch (n.type) {
    case S3:
      if (n.children.length) break;
    case _3:
    case nS:
      return (n.return = n.return || n.value);
    case dC:
      return "";
    case hC:
      return (n.return = n.value + "{" + Qd(n.children, r) + "}");
    case tS:
      n.value = n.props.join(",");
  }
  return ka((t = Qd(n.children, r)))
    ? (n.return = n.value + "{" + t + "}")
    : "";
}
function N3(n) {
  var e = rS(n);
  return function (t, r, i, o) {
    for (var s = "", l = 0; l < e; l++) s += n[l](t, r, i, o) || "";
    return s;
  };
}
function U3(n) {
  return function (e) {
    e.root || ((e = e.return) && n(e));
  };
}
var F3 = function (e, t, r) {
    for (
      var i = 0, o = 0;
      (i = o), (o = Fa()), i === 38 && o === 12 && (t[r] = 1), !Qp(o);

    )
      ns();
    return Cm(e, Oo);
  },
  z3 = function (e, t) {
    var r = -1,
      i = 44;
    do
      switch (Qp(i)) {
        case 0:
          i === 38 && Fa() === 12 && (t[r] = 1), (e[r] += F3(Oo - 1, t, r));
          break;
        case 2:
          e[r] += Gv(i);
          break;
        case 4:
          if (i === 44) {
            (e[++r] = Fa() === 58 ? "&\f" : ""), (t[r] = e[r].length);
            break;
          }
        default:
          e[r] += $0(i);
      }
    while ((i = ns()));
    return e;
  },
  B3 = function (e, t) {
    return vC(z3(gC(e), t));
  },
  SM = new WeakMap(),
  V3 = function (e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (
        var t = e.value,
          r = e.parent,
          i = e.column === r.column && e.line === r.line;
        r.type !== "rule";

      )
        if (((r = r.parent), !r)) return;
      if (
        !(e.props.length === 1 && t.charCodeAt(0) !== 58 && !SM.get(r)) &&
        !i
      ) {
        SM.set(e, !0);
        for (
          var o = [], s = B3(t, o), l = r.props, u = 0, f = 0;
          u < s.length;
          u++
        )
          for (var h = 0; h < l.length; h++, f++)
            e.props[f] = o[u] ? s[u].replace(/&\f/g, l[h]) : l[h] + " " + s[u];
      }
    }
  },
  H3 = function (e) {
    if (e.type === "decl") {
      var t = e.value;
      t.charCodeAt(0) === 108 &&
        t.charCodeAt(2) === 98 &&
        ((e.return = ""), (e.value = ""));
    }
  };
function yC(n, e) {
  switch (b3(n, e)) {
    case 5103:
      return An + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return An + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return An + n + Jv + n + Yi + n + n;
    case 6828:
    case 4268:
      return An + n + Yi + n + n;
    case 6165:
      return An + n + Yi + "flex-" + n + n;
    case 5187:
      return (
        An + n + Rn(n, /(\w+).+(:[^]+)/, An + "box-$1$2" + Yi + "flex-$1$2") + n
      );
    case 5443:
      return An + n + Yi + "flex-item-" + Rn(n, /flex-|-self/, "") + n;
    case 4675:
      return (
        An +
        n +
        Yi +
        "flex-line-pack" +
        Rn(n, /align-content|flex-|-self/, "") +
        n
      );
    case 5548:
      return An + n + Yi + Rn(n, "shrink", "negative") + n;
    case 5292:
      return An + n + Yi + Rn(n, "basis", "preferred-size") + n;
    case 6060:
      return (
        An +
        "box-" +
        Rn(n, "-grow", "") +
        An +
        n +
        Yi +
        Rn(n, "grow", "positive") +
        n
      );
    case 4554:
      return An + Rn(n, /([^-])(transform)/g, "$1" + An + "$2") + n;
    case 6187:
      return (
        Rn(
          Rn(Rn(n, /(zoom-|grab)/, An + "$1"), /(image-set)/, An + "$1"),
          n,
          ""
        ) + n
      );
    case 5495:
    case 3959:
      return Rn(n, /(image-set\([^]*)/, An + "$1$`$1");
    case 4968:
      return (
        Rn(
          Rn(n, /(.+:)(flex-)?(.*)/, An + "box-pack:$3" + Yi + "flex-pack:$3"),
          /s.+-b[^;]+/,
          "justify"
        ) +
        An +
        n +
        n
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Rn(n, /(.+)-inline(.+)/, An + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (ka(n) - 1 - e > 6)
        switch (Li(n, e + 1)) {
          case 109:
            if (Li(n, e + 4) !== 45) break;
          case 102:
            return (
              Rn(
                n,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  An +
                  "$2-$3$1" +
                  Jv +
                  (Li(n, e + 3) == 108 ? "$3" : "$2-$3")
              ) + n
            );
          case 115:
            return ~f1(n, "stretch")
              ? yC(Rn(n, "stretch", "fill-available"), e) + n
              : n;
        }
      break;
    case 4949:
      if (Li(n, e + 1) !== 115) break;
    case 6444:
      switch (Li(n, ka(n) - 3 - (~f1(n, "!important") && 10))) {
        case 107:
          return Rn(n, ":", ":" + An) + n;
        case 101:
          return (
            Rn(
              n,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                An +
                (Li(n, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                An +
                "$2$3$1" +
                Yi +
                "$2box$3"
            ) + n
          );
      }
      break;
    case 5936:
      switch (Li(n, e + 11)) {
        case 114:
          return An + n + Yi + Rn(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return An + n + Yi + Rn(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return An + n + Yi + Rn(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
      return An + n + Yi + n + n;
  }
  return n;
}
var G3 = function (e, t, r, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case nS:
          e.return = yC(e.value, e.length);
          break;
        case hC:
          return Qd([lp(e, { value: Rn(e.value, "@", "@" + An) })], i);
        case tS:
          if (e.length)
            return T3(e.props, function (o) {
              switch (E3(o, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return Qd(
                    [lp(e, { props: [Rn(o, /:(read-\w+)/, ":" + Jv + "$1")] })],
                    i
                  );
                case "::placeholder":
                  return Qd(
                    [
                      lp(e, {
                        props: [Rn(o, /:(plac\w+)/, ":" + An + "input-$1")],
                      }),
                      lp(e, { props: [Rn(o, /:(plac\w+)/, ":" + Jv + "$1")] }),
                      lp(e, { props: [Rn(o, /:(plac\w+)/, Yi + "input-$1")] }),
                    ],
                    i
                  );
              }
              return "";
            });
      }
  },
  W3 = [G3],
  xC = function (e) {
    var t = e.key;
    if (t === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function (S) {
        var x = S.getAttribute("data-emotion");
        x.indexOf(" ") !== -1 &&
          (document.head.appendChild(S), S.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || W3,
      o = {},
      s,
      l = [];
    (s = e.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
        function (S) {
          for (
            var x = S.getAttribute("data-emotion").split(" "), w = 1;
            w < x.length;
            w++
          )
            o[x[w]] = !0;
          l.push(S);
        }
      );
    var u,
      f = [V3, H3];
    {
      var h,
        m = [
          O3,
          U3(function (S) {
            h.insert(S);
          }),
        ],
        g = N3(f.concat(i, m)),
        y = function (x) {
          return Qd(D3(x), g);
        };
      u = function (x, w, T, E) {
        (h = T),
          y(x ? x + "{" + w.styles + "}" : w.styles),
          E && (_.inserted[w.name] = !0);
      };
    }
    var _ = {
      key: t,
      sheet: new x3({
        key: t,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint,
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: u,
    };
    return _.sheet.hydrate(l), _;
  },
  j3 = !0;
function $3(n, e, t) {
  var r = "";
  return (
    t.split(" ").forEach(function (i) {
      n[i] !== void 0 ? e.push(n[i] + ";") : i && (r += i + " ");
    }),
    r
  );
}
var _C = function (e, t, r) {
    var i = e.key + "-" + t.name;
    (r === !1 || j3 === !1) &&
      e.registered[i] === void 0 &&
      (e.registered[i] = t.styles);
  },
  SC = function (e, t, r) {
    _C(e, t, r);
    var i = e.key + "-" + t.name;
    if (e.inserted[t.name] === void 0) {
      var o = t;
      do e.insert(t === o ? "." + i : "", o, e.sheet, !0), (o = o.next);
      while (o !== void 0);
    }
  };
function X3(n) {
  for (var e = 0, t, r = 0, i = n.length; i >= 4; ++r, i -= 4)
    (t =
      (n.charCodeAt(r) & 255) |
      ((n.charCodeAt(++r) & 255) << 8) |
      ((n.charCodeAt(++r) & 255) << 16) |
      ((n.charCodeAt(++r) & 255) << 24)),
      (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)),
      (t ^= t >>> 24),
      (e =
        ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (n.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (n.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= n.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
var Y3 = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  q3 = /[A-Z]|^ms/g,
  K3 = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  wC = function (e) {
    return e.charCodeAt(1) === 45;
  },
  wM = function (e) {
    return e != null && typeof e != "boolean";
  },
  Dx = fC(function (n) {
    return wC(n) ? n : n.replace(q3, "-$&").toLowerCase();
  }),
  MM = function (e, t) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof t == "string")
          return t.replace(K3, function (r, i, o) {
            return (Oa = { name: i, styles: o, next: Oa }), i;
          });
    }
    return Y3[e] !== 1 && !wC(e) && typeof t == "number" && t !== 0
      ? t + "px"
      : t;
  };
function em(n, e, t) {
  if (t == null) return "";
  var r = t;
  if (r.__emotion_styles !== void 0) return r;
  switch (typeof t) {
    case "boolean":
      return "";
    case "object": {
      var i = t;
      if (i.anim === 1)
        return (Oa = { name: i.name, styles: i.styles, next: Oa }), i.name;
      var o = t;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            (Oa = { name: s.name, styles: s.styles, next: Oa }), (s = s.next);
        var l = o.styles + ";";
        return l;
      }
      return Z3(n, e, t);
    }
    case "function": {
      if (n !== void 0) {
        var u = Oa,
          f = t(n);
        return (Oa = u), em(n, e, f);
      }
      break;
    }
  }
  var h = t;
  if (e == null) return h;
  var m = e[h];
  return m !== void 0 ? m : h;
}
function Z3(n, e, t) {
  var r = "";
  if (Array.isArray(t))
    for (var i = 0; i < t.length; i++) r += em(n, e, t[i]) + ";";
  else
    for (var o in t) {
      var s = t[o];
      if (typeof s != "object") {
        var l = s;
        e != null && e[l] !== void 0
          ? (r += o + "{" + e[l] + "}")
          : wM(l) && (r += Dx(o) + ":" + MM(o, l) + ";");
      } else if (
        Array.isArray(s) &&
        typeof s[0] == "string" &&
        (e == null || e[s[0]] === void 0)
      )
        for (var u = 0; u < s.length; u++)
          wM(s[u]) && (r += Dx(o) + ":" + MM(o, s[u]) + ";");
      else {
        var f = em(n, e, s);
        switch (o) {
          case "animation":
          case "animationName": {
            r += Dx(o) + ":" + f + ";";
            break;
          }
          default:
            r += o + "{" + f + "}";
        }
      }
    }
  return r;
}
var bM = /label:\s*([^\s;{]+)\s*(;|$)/g,
  Oa;
function iS(n, e, t) {
  if (
    n.length === 1 &&
    typeof n[0] == "object" &&
    n[0] !== null &&
    n[0].styles !== void 0
  )
    return n[0];
  var r = !0,
    i = "";
  Oa = void 0;
  var o = n[0];
  if (o == null || o.raw === void 0) (r = !1), (i += em(t, e, o));
  else {
    var s = o;
    i += s[0];
  }
  for (var l = 1; l < n.length; l++)
    if (((i += em(t, e, n[l])), r)) {
      var u = o;
      i += u[l];
    }
  bM.lastIndex = 0;
  for (var f = "", h; (h = bM.exec(i)) !== null; ) f += "-" + h[1];
  var m = X3(i) + f;
  return { name: m, styles: i, next: Oa };
}
var J3 = function (e) {
    return e();
  },
  MC = c1.useInsertionEffect ? c1.useInsertionEffect : !1,
  Q3 = MC || J3,
  EM = MC || ee.useLayoutEffect,
  bC = ee.createContext(typeof HTMLElement < "u" ? xC({ key: "css" }) : null),
  eI = bC.Provider,
  EC = function (e) {
    return ee.forwardRef(function (t, r) {
      var i = ee.useContext(bC);
      return e(t, i, r);
    });
  },
  q0 = ee.createContext({}),
  tI = EC(function (n, e) {
    var t = n.styles,
      r = iS([t], void 0, ee.useContext(q0)),
      i = ee.useRef();
    return (
      EM(
        function () {
          var o = e.key + "-global",
            s = new e.sheet.constructor({
              key: o,
              nonce: e.sheet.nonce,
              container: e.sheet.container,
              speedy: e.sheet.isSpeedy,
            }),
            l = !1,
            u = document.querySelector(
              'style[data-emotion="' + o + " " + r.name + '"]'
            );
          return (
            e.sheet.tags.length && (s.before = e.sheet.tags[0]),
            u !== null &&
              ((l = !0), u.setAttribute("data-emotion", o), s.hydrate([u])),
            (i.current = [s, l]),
            function () {
              s.flush();
            }
          );
        },
        [e]
      ),
      EM(
        function () {
          var o = i.current,
            s = o[0],
            l = o[1];
          if (l) {
            o[1] = !1;
            return;
          }
          if ((r.next !== void 0 && SC(e, r.next, !0), s.tags.length)) {
            var u = s.tags[s.tags.length - 1].nextElementSibling;
            (s.before = u), s.flush();
          }
          e.insert("", r, s, !1);
        },
        [e, r.name]
      ),
      null
    );
  });
function oS() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return iS(e);
}
var Am = function () {
    var e = oS.apply(void 0, arguments),
      t = "animation-" + e.name;
    return {
      name: t,
      styles: "@keyframes " + t + "{" + e.styles + "}",
      anim: 1,
      toString: function () {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      },
    };
  },
  nI = g3,
  rI = function (e) {
    return e !== "theme";
  },
  TM = function (e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? nI : rI;
  },
  CM = function (e, t, r) {
    var i;
    if (t) {
      var o = t.shouldForwardProp;
      i =
        e.__emotion_forwardProp && o
          ? function (s) {
              return e.__emotion_forwardProp(s) && o(s);
            }
          : o;
    }
    return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
  },
  iI = function (e) {
    var t = e.cache,
      r = e.serialized,
      i = e.isStringTag;
    return (
      _C(t, r, i),
      Q3(function () {
        return SC(t, r, i);
      }),
      null
    );
  },
  oI = function n(e, t) {
    var r = e.__emotion_real === e,
      i = (r && e.__emotion_base) || e,
      o,
      s;
    t !== void 0 && ((o = t.label), (s = t.target));
    var l = CM(e, t, r),
      u = l || TM(i),
      f = !u("as");
    return function () {
      var h = arguments,
        m =
          r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (
        (o !== void 0 && m.push("label:" + o + ";"),
        h[0] == null || h[0].raw === void 0)
      )
        m.push.apply(m, h);
      else {
        m.push(h[0][0]);
        for (var g = h.length, y = 1; y < g; y++) m.push(h[y], h[0][y]);
      }
      var _ = EC(function (S, x, w) {
        var T = (f && S.as) || i,
          E = "",
          A = [],
          R = S;
        if (S.theme == null) {
          R = {};
          for (var D in S) R[D] = S[D];
          R.theme = ee.useContext(q0);
        }
        typeof S.className == "string"
          ? (E = $3(x.registered, A, S.className))
          : S.className != null && (E = S.className + " ");
        var I = iS(m.concat(A), x.registered, R);
        (E += x.key + "-" + I.name), s !== void 0 && (E += " " + s);
        var U = f && l === void 0 ? TM(T) : u,
          O = {};
        for (var L in S) (f && L === "as") || (U(L) && (O[L] = S[L]));
        return (
          (O.className = E),
          w && (O.ref = w),
          ee.createElement(
            ee.Fragment,
            null,
            ee.createElement(iI, {
              cache: x,
              serialized: I,
              isStringTag: typeof T == "string",
            }),
            ee.createElement(T, O)
          )
        );
      });
      return (
        (_.displayName =
          o !== void 0
            ? o
            : "Styled(" +
              (typeof i == "string"
                ? i
                : i.displayName || i.name || "Component") +
              ")"),
        (_.defaultProps = e.defaultProps),
        (_.__emotion_real = _),
        (_.__emotion_base = i),
        (_.__emotion_styles = m),
        (_.__emotion_forwardProp = l),
        Object.defineProperty(_, "toString", {
          value: function () {
            return "." + s;
          },
        }),
        (_.withComponent = function (S, x) {
          return n(S, pe({}, t, x, { shouldForwardProp: CM(_, x, !0) })).apply(
            void 0,
            m
          );
        }),
        _
      );
    };
  },
  sI = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  h1 = oI.bind();
sI.forEach(function (n) {
  h1[n] = h1(n);
});
let p1;
typeof document == "object" && (p1 = xC({ key: "css", prepend: !0 }));
function aI(n) {
  const { injectFirst: e, children: t } = n;
  return e && p1 ? ve.jsx(eI, { value: p1, children: t }) : t;
}
function lI(n) {
  return n == null || Object.keys(n).length === 0;
}
function TC(n) {
  const { styles: e, defaultTheme: t = {} } = n,
    r = typeof e == "function" ? (i) => e(lI(i) ? t : i) : e;
  return ve.jsx(tI, { styles: r });
}
function sS(n, e) {
  return h1(n, e);
}
const CC = (n, e) => {
    Array.isArray(n.__emotion_styles) &&
      (n.__emotion_styles = e(n.__emotion_styles));
  },
  uI = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        GlobalStyles: TC,
        StyledEngineProvider: aI,
        ThemeContext: q0,
        css: oS,
        default: sS,
        internal_processStyles: CC,
        keyframes: Am,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
function Ml(n) {
  if (typeof n != "object" || n === null) return !1;
  const e = Object.getPrototypeOf(n);
  return (
    (e === null ||
      e === Object.prototype ||
      Object.getPrototypeOf(e) === null) &&
    !(Symbol.toStringTag in n) &&
    !(Symbol.iterator in n)
  );
}
function AC(n) {
  if (ee.isValidElement(n) || !Ml(n)) return n;
  const e = {};
  return (
    Object.keys(n).forEach((t) => {
      e[t] = AC(n[t]);
    }),
    e
  );
}
function ti(n, e, t = { clone: !0 }) {
  const r = t.clone ? pe({}, n) : n;
  return (
    Ml(n) &&
      Ml(e) &&
      Object.keys(e).forEach((i) => {
        ee.isValidElement(e[i])
          ? (r[i] = e[i])
          : Ml(e[i]) && Object.prototype.hasOwnProperty.call(n, i) && Ml(n[i])
          ? (r[i] = ti(n[i], e[i], t))
          : t.clone
          ? (r[i] = Ml(e[i]) ? AC(e[i]) : e[i])
          : (r[i] = e[i]);
      }),
    r
  );
}
const cI = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: ti, isPlainObject: Ml },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  fI = ["values", "unit", "step"],
  dI = (n) => {
    const e = Object.keys(n).map((t) => ({ key: t, val: n[t] })) || [];
    return (
      e.sort((t, r) => t.val - r.val),
      e.reduce((t, r) => pe({}, t, { [r.key]: r.val }), {})
    );
  };
function aS(n) {
  const {
      values: e = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
      unit: t = "px",
      step: r = 5,
    } = n,
    i = Ft(n, fI),
    o = dI(e),
    s = Object.keys(o);
  function l(g) {
    return `@media (min-width:${typeof e[g] == "number" ? e[g] : g}${t})`;
  }
  function u(g) {
    return `@media (max-width:${
      (typeof e[g] == "number" ? e[g] : g) - r / 100
    }${t})`;
  }
  function f(g, y) {
    const _ = s.indexOf(y);
    return `@media (min-width:${
      typeof e[g] == "number" ? e[g] : g
    }${t}) and (max-width:${
      (_ !== -1 && typeof e[s[_]] == "number" ? e[s[_]] : y) - r / 100
    }${t})`;
  }
  function h(g) {
    return s.indexOf(g) + 1 < s.length ? f(g, s[s.indexOf(g) + 1]) : l(g);
  }
  function m(g) {
    const y = s.indexOf(g);
    return y === 0
      ? l(s[1])
      : y === s.length - 1
      ? u(s[y])
      : f(g, s[s.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return pe(
    {
      keys: s,
      values: o,
      up: l,
      down: u,
      between: f,
      only: h,
      not: m,
      unit: t,
    },
    i
  );
}
const hI = { borderRadius: 4 };
function Op(n, e) {
  return e ? ti(n, e, { clone: !1 }) : n;
}
const lS = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
  AM = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (n) => `@media (min-width:${lS[n]}px)`,
  };
function oa(n, e, t) {
  const r = n.theme || {};
  if (Array.isArray(e)) {
    const o = r.breakpoints || AM;
    return e.reduce((s, l, u) => ((s[o.up(o.keys[u])] = t(e[u])), s), {});
  }
  if (typeof e == "object") {
    const o = r.breakpoints || AM;
    return Object.keys(e).reduce((s, l) => {
      if (Object.keys(o.values || lS).indexOf(l) !== -1) {
        const u = o.up(l);
        s[u] = t(e[l], l);
      } else {
        const u = l;
        s[u] = e[u];
      }
      return s;
    }, {});
  }
  return t(e);
}
function RC(n = {}) {
  var e;
  return (
    ((e = n.keys) == null
      ? void 0
      : e.reduce((r, i) => {
          const o = n.up(i);
          return (r[o] = {}), r;
        }, {})) || {}
  );
}
function PC(n, e) {
  return n.reduce((t, r) => {
    const i = t[r];
    return (!i || Object.keys(i).length === 0) && delete t[r], t;
  }, e);
}
function pI(n, ...e) {
  const t = RC(n),
    r = [t, ...e].reduce((i, o) => ti(i, o), {});
  return PC(Object.keys(t), r);
}
function mI(n, e) {
  if (typeof n != "object") return {};
  const t = {},
    r = Object.keys(e);
  return (
    Array.isArray(n)
      ? r.forEach((i, o) => {
          o < n.length && (t[i] = !0);
        })
      : r.forEach((i) => {
          n[i] != null && (t[i] = !0);
        }),
    t
  );
}
function kx({ values: n, breakpoints: e, base: t }) {
  const r = t || mI(n, e),
    i = Object.keys(r);
  if (i.length === 0) return n;
  let o;
  return i.reduce(
    (s, l, u) => (
      Array.isArray(n)
        ? ((s[l] = n[u] != null ? n[u] : n[o]), (o = u))
        : typeof n == "object"
        ? ((s[l] = n[l] != null ? n[l] : n[o]), (o = l))
        : (s[l] = n),
      s
    ),
    {}
  );
}
function fn(n) {
  if (typeof n != "string") throw new Error(Rl(7));
  return n.charAt(0).toUpperCase() + n.slice(1);
}
const gI = Object.freeze(
  Object.defineProperty({ __proto__: null, default: fn }, Symbol.toStringTag, {
    value: "Module",
  })
);
function K0(n, e, t = !0) {
  if (!e || typeof e != "string") return null;
  if (n && n.vars && t) {
    const r = `vars.${e}`
      .split(".")
      .reduce((i, o) => (i && i[o] ? i[o] : null), n);
    if (r != null) return r;
  }
  return e.split(".").reduce((r, i) => (r && r[i] != null ? r[i] : null), n);
}
function Qv(n, e, t, r = t) {
  let i;
  return (
    typeof n == "function"
      ? (i = n(t))
      : Array.isArray(n)
      ? (i = n[t] || r)
      : (i = K0(n, t) || r),
    e && (i = e(i, r, n)),
    i
  );
}
function kr(n) {
  const { prop: e, cssProperty: t = n.prop, themeKey: r, transform: i } = n,
    o = (s) => {
      if (s[e] == null) return null;
      const l = s[e],
        u = s.theme,
        f = K0(u, r) || {};
      return oa(s, l, (m) => {
        let g = Qv(f, i, m);
        return (
          m === g &&
            typeof m == "string" &&
            (g = Qv(f, i, `${e}${m === "default" ? "" : fn(m)}`, m)),
          t === !1 ? g : { [t]: g }
        );
      });
    };
  return (o.propTypes = {}), (o.filterProps = [e]), o;
}
function vI(n) {
  const e = {};
  return (t) => (e[t] === void 0 && (e[t] = n(t)), e[t]);
}
const yI = { m: "margin", p: "padding" },
  xI = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"],
  },
  RM = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" },
  _I = vI((n) => {
    if (n.length > 2)
      if (RM[n]) n = RM[n];
      else return [n];
    const [e, t] = n.split(""),
      r = yI[e],
      i = xI[t] || "";
    return Array.isArray(i) ? i.map((o) => r + o) : [r + i];
  }),
  uS = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",
    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",
  ],
  cS = [
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
  ];
[...uS, ...cS];
function Rm(n, e, t, r) {
  var i;
  const o = (i = K0(n, e, !1)) != null ? i : t;
  return typeof o == "number"
    ? (s) => (typeof s == "string" ? s : o * s)
    : Array.isArray(o)
    ? (s) => (typeof s == "string" ? s : o[s])
    : typeof o == "function"
    ? o
    : () => {};
}
function fS(n) {
  return Rm(n, "spacing", 8);
}
function rf(n, e) {
  if (typeof e == "string" || e == null) return e;
  const t = Math.abs(e),
    r = n(t);
  return e >= 0 ? r : typeof r == "number" ? -r : `-${r}`;
}
function SI(n, e) {
  return (t) => n.reduce((r, i) => ((r[i] = rf(e, t)), r), {});
}
function wI(n, e, t, r) {
  if (e.indexOf(t) === -1) return null;
  const i = _I(t),
    o = SI(i, r),
    s = n[t];
  return oa(n, s, o);
}
function IC(n, e) {
  const t = fS(n.theme);
  return Object.keys(n)
    .map((r) => wI(n, e, r, t))
    .reduce(Op, {});
}
function Sr(n) {
  return IC(n, uS);
}
Sr.propTypes = {};
Sr.filterProps = uS;
function wr(n) {
  return IC(n, cS);
}
wr.propTypes = {};
wr.filterProps = cS;
function LC(n = 8) {
  if (n.mui) return n;
  const e = fS({ spacing: n }),
    t = (...r) =>
      (r.length === 0 ? [1] : r)
        .map((o) => {
          const s = e(o);
          return typeof s == "number" ? `${s}px` : s;
        })
        .join(" ");
  return (t.mui = !0), t;
}
function Z0(...n) {
  const e = n.reduce(
      (r, i) => (
        i.filterProps.forEach((o) => {
          r[o] = i;
        }),
        r
      ),
      {}
    ),
    t = (r) => Object.keys(r).reduce((i, o) => (e[o] ? Op(i, e[o](r)) : i), {});
  return (
    (t.propTypes = {}),
    (t.filterProps = n.reduce((r, i) => r.concat(i.filterProps), [])),
    t
  );
}
function bs(n) {
  return typeof n != "number" ? n : `${n}px solid`;
}
function As(n, e) {
  return kr({ prop: n, themeKey: "borders", transform: e });
}
const MI = As("border", bs),
  bI = As("borderTop", bs),
  EI = As("borderRight", bs),
  TI = As("borderBottom", bs),
  CI = As("borderLeft", bs),
  AI = As("borderColor"),
  RI = As("borderTopColor"),
  PI = As("borderRightColor"),
  II = As("borderBottomColor"),
  LI = As("borderLeftColor"),
  DI = As("outline", bs),
  kI = As("outlineColor"),
  J0 = (n) => {
    if (n.borderRadius !== void 0 && n.borderRadius !== null) {
      const e = Rm(n.theme, "shape.borderRadius", 4),
        t = (r) => ({ borderRadius: rf(e, r) });
      return oa(n, n.borderRadius, t);
    }
    return null;
  };
J0.propTypes = {};
J0.filterProps = ["borderRadius"];
Z0(MI, bI, EI, TI, CI, AI, RI, PI, II, LI, J0, DI, kI);
const Q0 = (n) => {
  if (n.gap !== void 0 && n.gap !== null) {
    const e = Rm(n.theme, "spacing", 8),
      t = (r) => ({ gap: rf(e, r) });
    return oa(n, n.gap, t);
  }
  return null;
};
Q0.propTypes = {};
Q0.filterProps = ["gap"];
const ey = (n) => {
  if (n.columnGap !== void 0 && n.columnGap !== null) {
    const e = Rm(n.theme, "spacing", 8),
      t = (r) => ({ columnGap: rf(e, r) });
    return oa(n, n.columnGap, t);
  }
  return null;
};
ey.propTypes = {};
ey.filterProps = ["columnGap"];
const ty = (n) => {
  if (n.rowGap !== void 0 && n.rowGap !== null) {
    const e = Rm(n.theme, "spacing", 8),
      t = (r) => ({ rowGap: rf(e, r) });
    return oa(n, n.rowGap, t);
  }
  return null;
};
ty.propTypes = {};
ty.filterProps = ["rowGap"];
const OI = kr({ prop: "gridColumn" }),
  NI = kr({ prop: "gridRow" }),
  UI = kr({ prop: "gridAutoFlow" }),
  FI = kr({ prop: "gridAutoColumns" }),
  zI = kr({ prop: "gridAutoRows" }),
  BI = kr({ prop: "gridTemplateColumns" }),
  VI = kr({ prop: "gridTemplateRows" }),
  HI = kr({ prop: "gridTemplateAreas" }),
  GI = kr({ prop: "gridArea" });
Z0(Q0, ey, ty, OI, NI, UI, FI, zI, BI, VI, HI, GI);
function eh(n, e) {
  return e === "grey" ? e : n;
}
const WI = kr({ prop: "color", themeKey: "palette", transform: eh }),
  jI = kr({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: eh,
  }),
  $I = kr({ prop: "backgroundColor", themeKey: "palette", transform: eh });
Z0(WI, jI, $I);
function Qo(n) {
  return n <= 1 && n !== 0 ? `${n * 100}%` : n;
}
const XI = kr({ prop: "width", transform: Qo }),
  dS = (n) => {
    if (n.maxWidth !== void 0 && n.maxWidth !== null) {
      const e = (t) => {
        var r, i;
        const o =
          ((r = n.theme) == null ||
          (r = r.breakpoints) == null ||
          (r = r.values) == null
            ? void 0
            : r[t]) || lS[t];
        return o
          ? ((i = n.theme) == null || (i = i.breakpoints) == null
              ? void 0
              : i.unit) !== "px"
            ? { maxWidth: `${o}${n.theme.breakpoints.unit}` }
            : { maxWidth: o }
          : { maxWidth: Qo(t) };
      };
      return oa(n, n.maxWidth, e);
    }
    return null;
  };
dS.filterProps = ["maxWidth"];
const YI = kr({ prop: "minWidth", transform: Qo }),
  qI = kr({ prop: "height", transform: Qo }),
  KI = kr({ prop: "maxHeight", transform: Qo }),
  ZI = kr({ prop: "minHeight", transform: Qo });
kr({ prop: "size", cssProperty: "width", transform: Qo });
kr({ prop: "size", cssProperty: "height", transform: Qo });
const JI = kr({ prop: "boxSizing" });
Z0(XI, dS, YI, qI, KI, ZI, JI);
const mh = {
  border: { themeKey: "borders", transform: bs },
  borderTop: { themeKey: "borders", transform: bs },
  borderRight: { themeKey: "borders", transform: bs },
  borderBottom: { themeKey: "borders", transform: bs },
  borderLeft: { themeKey: "borders", transform: bs },
  borderColor: { themeKey: "palette" },
  borderTopColor: { themeKey: "palette" },
  borderRightColor: { themeKey: "palette" },
  borderBottomColor: { themeKey: "palette" },
  borderLeftColor: { themeKey: "palette" },
  outline: { themeKey: "borders", transform: bs },
  outlineColor: { themeKey: "palette" },
  borderRadius: { themeKey: "shape.borderRadius", style: J0 },
  color: { themeKey: "palette", transform: eh },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: eh,
  },
  backgroundColor: { themeKey: "palette", transform: eh },
  p: { style: wr },
  pt: { style: wr },
  pr: { style: wr },
  pb: { style: wr },
  pl: { style: wr },
  px: { style: wr },
  py: { style: wr },
  padding: { style: wr },
  paddingTop: { style: wr },
  paddingRight: { style: wr },
  paddingBottom: { style: wr },
  paddingLeft: { style: wr },
  paddingX: { style: wr },
  paddingY: { style: wr },
  paddingInline: { style: wr },
  paddingInlineStart: { style: wr },
  paddingInlineEnd: { style: wr },
  paddingBlock: { style: wr },
  paddingBlockStart: { style: wr },
  paddingBlockEnd: { style: wr },
  m: { style: Sr },
  mt: { style: Sr },
  mr: { style: Sr },
  mb: { style: Sr },
  ml: { style: Sr },
  mx: { style: Sr },
  my: { style: Sr },
  margin: { style: Sr },
  marginTop: { style: Sr },
  marginRight: { style: Sr },
  marginBottom: { style: Sr },
  marginLeft: { style: Sr },
  marginX: { style: Sr },
  marginY: { style: Sr },
  marginInline: { style: Sr },
  marginInlineStart: { style: Sr },
  marginInlineEnd: { style: Sr },
  marginBlock: { style: Sr },
  marginBlockStart: { style: Sr },
  marginBlockEnd: { style: Sr },
  displayPrint: {
    cssProperty: !1,
    transform: (n) => ({ "@media print": { display: n } }),
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  gap: { style: Q0 },
  rowGap: { style: ty },
  columnGap: { style: ey },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  position: {},
  zIndex: { themeKey: "zIndex" },
  top: {},
  right: {},
  bottom: {},
  left: {},
  boxShadow: { themeKey: "shadows" },
  width: { transform: Qo },
  maxWidth: { style: dS },
  minWidth: { transform: Qo },
  height: { transform: Qo },
  maxHeight: { transform: Qo },
  minHeight: { transform: Qo },
  boxSizing: {},
  fontFamily: { themeKey: "typography" },
  fontSize: { themeKey: "typography" },
  fontStyle: { themeKey: "typography" },
  fontWeight: { themeKey: "typography" },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: { cssProperty: !1, themeKey: "typography" },
};
function QI(...n) {
  const e = n.reduce((r, i) => r.concat(Object.keys(i)), []),
    t = new Set(e);
  return n.every((r) => t.size === Object.keys(r).length);
}
function eL(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function DC() {
  function n(t, r, i, o) {
    const s = { [t]: r, theme: i },
      l = o[t];
    if (!l) return { [t]: r };
    const { cssProperty: u = t, themeKey: f, transform: h, style: m } = l;
    if (r == null) return null;
    if (f === "typography" && r === "inherit") return { [t]: r };
    const g = K0(i, f) || {};
    return m
      ? m(s)
      : oa(s, r, (_) => {
          let S = Qv(g, h, _);
          return (
            _ === S &&
              typeof _ == "string" &&
              (S = Qv(g, h, `${t}${_ === "default" ? "" : fn(_)}`, _)),
            u === !1 ? S : { [u]: S }
          );
        });
  }
  function e(t) {
    var r;
    const { sx: i, theme: o = {} } = t || {};
    if (!i) return null;
    const s = (r = o.unstable_sxConfig) != null ? r : mh;
    function l(u) {
      let f = u;
      if (typeof u == "function") f = u(o);
      else if (typeof u != "object") return u;
      if (!f) return null;
      const h = RC(o.breakpoints),
        m = Object.keys(h);
      let g = h;
      return (
        Object.keys(f).forEach((y) => {
          const _ = eL(f[y], o);
          if (_ != null)
            if (typeof _ == "object")
              if (s[y]) g = Op(g, n(y, _, o, s));
              else {
                const S = oa({ theme: o }, _, (x) => ({ [y]: x }));
                QI(S, _) ? (g[y] = e({ sx: _, theme: o })) : (g = Op(g, S));
              }
            else g = Op(g, n(y, _, o, s));
        }),
        PC(m, g)
      );
    }
    return Array.isArray(i) ? i.map(l) : l(i);
  }
  return e;
}
const df = DC();
df.filterProps = ["sx"];
function hS(n, e) {
  const t = this;
  return t.vars && typeof t.getColorSchemeSelector == "function"
    ? {
        [t.getColorSchemeSelector(n).replace(/(\[[^\]]+\])/, "*:where($1)")]: e,
      }
    : t.palette.mode === n
    ? e
    : {};
}
const tL = ["breakpoints", "palette", "spacing", "shape"];
function Pm(n = {}, ...e) {
  const { breakpoints: t = {}, palette: r = {}, spacing: i, shape: o = {} } = n,
    s = Ft(n, tL),
    l = aS(t),
    u = LC(i);
  let f = ti(
    {
      breakpoints: l,
      direction: "ltr",
      components: {},
      palette: pe({ mode: "light" }, r),
      spacing: u,
      shape: pe({}, hI, o),
    },
    s
  );
  return (
    (f.applyStyles = hS),
    (f = e.reduce((h, m) => ti(h, m), f)),
    (f.unstable_sxConfig = pe(
      {},
      mh,
      s == null ? void 0 : s.unstable_sxConfig
    )),
    (f.unstable_sx = function (m) {
      return df({ sx: m, theme: this });
    }),
    f
  );
}
const nL = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      default: Pm,
      private_createBreakpoints: aS,
      unstable_applyStyles: hS,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
function rL(n) {
  return Object.keys(n).length === 0;
}
function iL(n = null) {
  const e = ee.useContext(q0);
  return !e || rL(e) ? n : e;
}
const oL = Pm();
function ny(n = oL) {
  return iL(n);
}
function sL({ styles: n, themeId: e, defaultTheme: t = {} }) {
  const r = ny(t),
    i = typeof n == "function" ? n((e && r[e]) || r) : n;
  return ve.jsx(TC, { styles: i });
}
const aL = ["sx"],
  lL = (n) => {
    var e, t;
    const r = { systemProps: {}, otherProps: {} },
      i =
        (e =
          n == null || (t = n.theme) == null ? void 0 : t.unstable_sxConfig) !=
        null
          ? e
          : mh;
    return (
      Object.keys(n).forEach((o) => {
        i[o] ? (r.systemProps[o] = n[o]) : (r.otherProps[o] = n[o]);
      }),
      r
    );
  };
function ry(n) {
  const { sx: e } = n,
    t = Ft(n, aL),
    { systemProps: r, otherProps: i } = lL(t);
  let o;
  return (
    Array.isArray(e)
      ? (o = [r, ...e])
      : typeof e == "function"
      ? (o = (...s) => {
          const l = e(...s);
          return Ml(l) ? pe({}, r, l) : r;
        })
      : (o = pe({}, r, e)),
    pe({}, i, { sx: o })
  );
}
const uL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        default: df,
        extendSxProp: ry,
        unstable_createStyleFunctionSx: DC,
        unstable_defaultSxConfig: mh,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  PM = (n) => n,
  cL = () => {
    let n = PM;
    return {
      configure(e) {
        n = e;
      },
      generate(e) {
        return n(e);
      },
      reset() {
        n = PM;
      },
    };
  },
  kC = cL();
function OC(n) {
  var e,
    t,
    r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object")
    if (Array.isArray(n)) {
      var i = n.length;
      for (e = 0; e < i; e++)
        n[e] && (t = OC(n[e])) && (r && (r += " "), (r += t));
    } else for (t in n) n[t] && (r && (r += " "), (r += t));
  return r;
}
function cn() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++)
    (n = arguments[t]) && (e = OC(n)) && (r && (r += " "), (r += e));
  return r;
}
const fL = ["className", "component"];
function dL(n = {}) {
  const {
      themeId: e,
      defaultTheme: t,
      defaultClassName: r = "MuiBox-root",
      generateClassName: i,
    } = n,
    o = sS("div", {
      shouldForwardProp: (l) => l !== "theme" && l !== "sx" && l !== "as",
    })(df);
  return ee.forwardRef(function (u, f) {
    const h = ny(t),
      m = ry(u),
      { className: g, component: y = "div" } = m,
      _ = Ft(m, fL);
    return ve.jsx(
      o,
      pe(
        {
          as: y,
          ref: f,
          className: cn(g, i ? i(r) : r),
          theme: (e && h[e]) || h,
        },
        _
      )
    );
  });
}
const hL = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected",
};
function hr(n, e, t = "Mui") {
  const r = hL[e];
  return r ? `${t}-${r}` : `${kC.generate(n)}-${e}`;
}
function Xn(n, e, t = "Mui") {
  const r = {};
  return (
    e.forEach((i) => {
      r[i] = hr(n, i, t);
    }),
    r
  );
}
var Ox = { exports: {} },
  Fn = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var IM;
function pL() {
  if (IM) return Fn;
  IM = 1;
  var n = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.consumer"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.forward_ref"),
    u = Symbol.for("react.suspense"),
    f = Symbol.for("react.suspense_list"),
    h = Symbol.for("react.memo"),
    m = Symbol.for("react.lazy"),
    g = Symbol.for("react.view_transition"),
    y = Symbol.for("react.client.reference");
  function _(S) {
    if (typeof S == "object" && S !== null) {
      var x = S.$$typeof;
      switch (x) {
        case n:
          switch (((S = S.type), S)) {
            case t:
            case i:
            case r:
            case u:
            case f:
            case g:
              return S;
            default:
              switch (((S = S && S.$$typeof), S)) {
                case s:
                case l:
                case m:
                case h:
                  return S;
                case o:
                  return S;
                default:
                  return x;
              }
          }
        case e:
          return x;
      }
    }
  }
  return (
    (Fn.ContextConsumer = o),
    (Fn.ContextProvider = s),
    (Fn.Element = n),
    (Fn.ForwardRef = l),
    (Fn.Fragment = t),
    (Fn.Lazy = m),
    (Fn.Memo = h),
    (Fn.Portal = e),
    (Fn.Profiler = i),
    (Fn.StrictMode = r),
    (Fn.Suspense = u),
    (Fn.SuspenseList = f),
    (Fn.isContextConsumer = function (S) {
      return _(S) === o;
    }),
    (Fn.isContextProvider = function (S) {
      return _(S) === s;
    }),
    (Fn.isElement = function (S) {
      return typeof S == "object" && S !== null && S.$$typeof === n;
    }),
    (Fn.isForwardRef = function (S) {
      return _(S) === l;
    }),
    (Fn.isFragment = function (S) {
      return _(S) === t;
    }),
    (Fn.isLazy = function (S) {
      return _(S) === m;
    }),
    (Fn.isMemo = function (S) {
      return _(S) === h;
    }),
    (Fn.isPortal = function (S) {
      return _(S) === e;
    }),
    (Fn.isProfiler = function (S) {
      return _(S) === i;
    }),
    (Fn.isStrictMode = function (S) {
      return _(S) === r;
    }),
    (Fn.isSuspense = function (S) {
      return _(S) === u;
    }),
    (Fn.isSuspenseList = function (S) {
      return _(S) === f;
    }),
    (Fn.isValidElementType = function (S) {
      return (
        typeof S == "string" ||
        typeof S == "function" ||
        S === t ||
        S === i ||
        S === r ||
        S === u ||
        S === f ||
        (typeof S == "object" &&
          S !== null &&
          (S.$$typeof === m ||
            S.$$typeof === h ||
            S.$$typeof === s ||
            S.$$typeof === o ||
            S.$$typeof === l ||
            S.$$typeof === y ||
            S.getModuleId !== void 0))
      );
    }),
    (Fn.typeOf = _),
    Fn
  );
}
var LM;
function mL() {
  return LM || ((LM = 1), (Ox.exports = pL())), Ox.exports;
}
var DM = mL();
const gL = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function NC(n) {
  const e = `${n}`.match(gL);
  return (e && e[1]) || "";
}
function UC(n, e = "") {
  return n.displayName || n.name || NC(n) || e;
}
function kM(n, e, t) {
  const r = UC(e);
  return n.displayName || (r !== "" ? `${t}(${r})` : t);
}
function vL(n) {
  if (n != null) {
    if (typeof n == "string") return n;
    if (typeof n == "function") return UC(n, "Component");
    if (typeof n == "object")
      switch (n.$$typeof) {
        case DM.ForwardRef:
          return kM(n, n.render, "ForwardRef");
        case DM.Memo:
          return kM(n, n.type, "memo");
        default:
          return;
      }
  }
}
const yL = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: vL, getFunctionName: NC },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  xL = ["ownerState"],
  _L = ["variants"],
  SL = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function wL(n) {
  return Object.keys(n).length === 0;
}
function ML(n) {
  return typeof n == "string" && n.charCodeAt(0) > 96;
}
function Nx(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
const bL = Pm(),
  EL = (n) => n && n.charAt(0).toLowerCase() + n.slice(1);
function Bg({ defaultTheme: n, theme: e, themeId: t }) {
  return wL(e) ? n : e[t] || e;
}
function TL(n) {
  return n ? (e, t) => t[n] : null;
}
function jv(n, e) {
  let { ownerState: t } = e,
    r = Ft(e, xL);
  const i = typeof n == "function" ? n(pe({ ownerState: t }, r)) : n;
  if (Array.isArray(i))
    return i.flatMap((o) => jv(o, pe({ ownerState: t }, r)));
  if (i && typeof i == "object" && Array.isArray(i.variants)) {
    const { variants: o = [] } = i;
    let l = Ft(i, _L);
    return (
      o.forEach((u) => {
        let f = !0;
        typeof u.props == "function"
          ? (f = u.props(pe({ ownerState: t }, r, t)))
          : Object.keys(u.props).forEach((h) => {
              (t == null ? void 0 : t[h]) !== u.props[h] &&
                r[h] !== u.props[h] &&
                (f = !1);
            }),
          f &&
            (Array.isArray(l) || (l = [l]),
            l.push(
              typeof u.style == "function"
                ? u.style(pe({ ownerState: t }, r, t))
                : u.style
            ));
      }),
      l
    );
  }
  return i;
}
function FC(n = {}) {
  const {
      themeId: e,
      defaultTheme: t = bL,
      rootShouldForwardProp: r = Nx,
      slotShouldForwardProp: i = Nx,
    } = n,
    o = (s) =>
      df(pe({}, s, { theme: Bg(pe({}, s, { defaultTheme: t, themeId: e })) }));
  return (
    (o.__mui_systemSx = !0),
    (s, l = {}) => {
      CC(s, (R) => R.filter((D) => !(D != null && D.__mui_systemSx)));
      const {
          name: u,
          slot: f,
          skipVariantsResolver: h,
          skipSx: m,
          overridesResolver: g = TL(EL(f)),
        } = l,
        y = Ft(l, SL),
        _ = h !== void 0 ? h : (f && f !== "Root" && f !== "root") || !1,
        S = m || !1;
      let x,
        w = Nx;
      f === "Root" || f === "root"
        ? (w = r)
        : f
        ? (w = i)
        : ML(s) && (w = void 0);
      const T = sS(s, pe({ shouldForwardProp: w, label: x }, y)),
        E = (R) =>
          (typeof R == "function" && R.__emotion_real !== R) || Ml(R)
            ? (D) =>
                jv(
                  R,
                  pe({}, D, {
                    theme: Bg({ theme: D.theme, defaultTheme: t, themeId: e }),
                  })
                )
            : R,
        A = (R, ...D) => {
          let I = E(R);
          const U = D ? D.map(E) : [];
          u &&
            g &&
            U.push((V) => {
              const H = Bg(pe({}, V, { defaultTheme: t, themeId: e }));
              if (
                !H.components ||
                !H.components[u] ||
                !H.components[u].styleOverrides
              )
                return null;
              const $ = H.components[u].styleOverrides,
                q = {};
              return (
                Object.entries($).forEach(([K, Y]) => {
                  q[K] = jv(Y, pe({}, V, { theme: H }));
                }),
                g(V, q)
              );
            }),
            u &&
              !_ &&
              U.push((V) => {
                var H;
                const $ = Bg(pe({}, V, { defaultTheme: t, themeId: e })),
                  q =
                    $ == null ||
                    (H = $.components) == null ||
                    (H = H[u]) == null
                      ? void 0
                      : H.variants;
                return jv({ variants: q }, pe({}, V, { theme: $ }));
              }),
            S || U.push(o);
          const O = U.length - D.length;
          if (Array.isArray(R) && O > 0) {
            const V = new Array(O).fill("");
            (I = [...R, ...V]), (I.raw = [...R.raw, ...V]);
          }
          const L = T(I, ...U);
          return s.muiName && (L.muiName = s.muiName), L;
        };
      return T.withConfig && (A.withConfig = T.withConfig), A;
    }
  );
}
const CL = FC();
function tm(n, e) {
  const t = pe({}, e);
  return (
    Object.keys(n).forEach((r) => {
      if (r.toString().match(/^(components|slots)$/)) t[r] = pe({}, n[r], t[r]);
      else if (r.toString().match(/^(componentsProps|slotProps)$/)) {
        const i = n[r] || {},
          o = e[r];
        (t[r] = {}),
          !o || !Object.keys(o)
            ? (t[r] = i)
            : !i || !Object.keys(i)
            ? (t[r] = o)
            : ((t[r] = pe({}, o)),
              Object.keys(i).forEach((s) => {
                t[r][s] = tm(i[s], o[s]);
              }));
      } else t[r] === void 0 && (t[r] = n[r]);
    }),
    t
  );
}
function AL(n) {
  const { theme: e, name: t, props: r } = n;
  return !e ||
    !e.components ||
    !e.components[t] ||
    !e.components[t].defaultProps
    ? r
    : tm(e.components[t].defaultProps, r);
}
function zC({ props: n, name: e, defaultTheme: t, themeId: r }) {
  let i = ny(t);
  return r && (i = i[r] || i), AL({ theme: i, name: e, props: n });
}
const Fu = typeof window < "u" ? ee.useLayoutEffect : ee.useEffect;
function RL(n, e = Number.MIN_SAFE_INTEGER, t = Number.MAX_SAFE_INTEGER) {
  return Math.max(e, Math.min(n, t));
}
const PL = Object.freeze(
  Object.defineProperty({ __proto__: null, default: RL }, Symbol.toStringTag, {
    value: "Module",
  })
);
function IL(n) {
  n = n.slice(1);
  const e = new RegExp(`.{1,${n.length >= 6 ? 2 : 1}}`, "g");
  let t = n.match(e);
  return (
    t && t[0].length === 1 && (t = t.map((r) => r + r)),
    t
      ? `rgb${t.length === 4 ? "a" : ""}(${t
          .map((r, i) =>
            i < 3
              ? parseInt(r, 16)
              : Math.round((parseInt(r, 16) / 255) * 1e3) / 1e3
          )
          .join(", ")})`
      : ""
  );
}
function BC(n) {
  if (n.type) return n;
  if (n.charAt(0) === "#") return BC(IL(n));
  const e = n.indexOf("("),
    t = n.substring(0, e);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(t) === -1)
    throw new Error(Rl(9, n));
  let r = n.substring(e + 1, n.length - 1),
    i;
  if (t === "color") {
    if (
      ((r = r.split(" ")),
      (i = r.shift()),
      r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)),
      ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(
        i
      ) === -1)
    )
      throw new Error(Rl(10, i));
  } else r = r.split(",");
  return (
    (r = r.map((o) => parseFloat(o))), { type: t, values: r, colorSpace: i }
  );
}
const wc = (n) => {
  const e = BC(n);
  return e.values
    .slice(0, 3)
    .map((t, r) => (e.type.indexOf("hsl") !== -1 && r !== 0 ? `${t}%` : t))
    .join(" ");
};
function OM(...n) {
  return n.reduce(
    (e, t) =>
      t == null
        ? e
        : function (...i) {
            e.apply(this, i), t.apply(this, i);
          },
    () => {}
  );
}
function VC(n, e = 166) {
  let t;
  function r(...i) {
    const o = () => {
      n.apply(this, i);
    };
    clearTimeout(t), (t = setTimeout(o, e));
  }
  return (
    (r.clear = () => {
      clearTimeout(t);
    }),
    r
  );
}
function Ux(n, e) {
  var t, r;
  return (
    ee.isValidElement(n) &&
    e.indexOf(
      (t = n.type.muiName) != null
        ? t
        : (r = n.type) == null ||
          (r = r._payload) == null ||
          (r = r.value) == null
        ? void 0
        : r.muiName
    ) !== -1
  );
}
function rs(n) {
  return (n && n.ownerDocument) || document;
}
function of(n) {
  return rs(n).defaultView || window;
}
function m1(n, e) {
  typeof n == "function" ? n(e) : n && (n.current = e);
}
let NM = 0;
function LL(n) {
  const [e, t] = ee.useState(n),
    r = e;
  return (
    ee.useEffect(() => {
      e == null && ((NM += 1), t(`mui-${NM}`));
    }, [e]),
    r
  );
}
const UM = c1.useId;
function DL(n) {
  return UM !== void 0 ? UM() : LL(n);
}
function FM({ controlled: n, default: e, name: t, state: r = "value" }) {
  const { current: i } = ee.useRef(n !== void 0),
    [o, s] = ee.useState(e),
    l = i ? n : o,
    u = ee.useCallback((f) => {
      i || s(f);
    }, []);
  return [l, u];
}
function $d(n) {
  const e = ee.useRef(n);
  return (
    Fu(() => {
      e.current = n;
    }),
    ee.useRef((...t) => (0, e.current)(...t)).current
  );
}
function xi(...n) {
  return ee.useMemo(
    () =>
      n.every((e) => e == null)
        ? null
        : (e) => {
            n.forEach((t) => {
              m1(t, e);
            });
          },
    n
  );
}
const zM = {};
function kL(n, e) {
  const t = ee.useRef(zM);
  return t.current === zM && (t.current = n(e)), t;
}
const OL = [];
function NL(n) {
  ee.useEffect(n, OL);
}
class iy {
  constructor() {
    (this.currentId = null),
      (this.clear = () => {
        this.currentId !== null &&
          (clearTimeout(this.currentId), (this.currentId = null));
      }),
      (this.disposeEffect = () => this.clear);
  }
  static create() {
    return new iy();
  }
  start(e, t) {
    this.clear(),
      (this.currentId = setTimeout(() => {
        (this.currentId = null), t();
      }, e));
  }
}
function HC() {
  const n = kL(iy.create).current;
  return NL(n.disposeEffect), n;
}
let oy = !0,
  g1 = !1;
const UL = new iy(),
  FL = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    "datetime-local": !0,
  };
function zL(n) {
  const { type: e, tagName: t } = n;
  return !!(
    (t === "INPUT" && FL[e] && !n.readOnly) ||
    (t === "TEXTAREA" && !n.readOnly) ||
    n.isContentEditable
  );
}
function BL(n) {
  n.metaKey || n.altKey || n.ctrlKey || (oy = !0);
}
function Fx() {
  oy = !1;
}
function VL() {
  this.visibilityState === "hidden" && g1 && (oy = !0);
}
function HL(n) {
  n.addEventListener("keydown", BL, !0),
    n.addEventListener("mousedown", Fx, !0),
    n.addEventListener("pointerdown", Fx, !0),
    n.addEventListener("touchstart", Fx, !0),
    n.addEventListener("visibilitychange", VL, !0);
}
function GL(n) {
  const { target: e } = n;
  try {
    return e.matches(":focus-visible");
  } catch {}
  return oy || zL(e);
}
function GC() {
  const n = ee.useCallback((i) => {
      i != null && HL(i.ownerDocument);
    }, []),
    e = ee.useRef(!1);
  function t() {
    return e.current
      ? ((g1 = !0),
        UL.start(100, () => {
          g1 = !1;
        }),
        (e.current = !1),
        !0)
      : !1;
  }
  function r(i) {
    return GL(i) ? ((e.current = !0), !0) : !1;
  }
  return { isFocusVisibleRef: e, onFocus: r, onBlur: t, ref: n };
}
function WC(n) {
  const e = n.documentElement.clientWidth;
  return Math.abs(window.innerWidth - e);
}
function pr(n, e, t = void 0) {
  const r = {};
  return (
    Object.keys(n).forEach((i) => {
      r[i] = n[i]
        .reduce((o, s) => {
          if (s) {
            const l = e(s);
            l !== "" && o.push(l), t && t[s] && o.push(t[s]);
          }
          return o;
        }, [])
        .join(" ");
    }),
    r
  );
}
function e0(n) {
  return typeof n == "string";
}
function jC(n, e, t) {
  return n === void 0 || e0(n)
    ? e
    : pe({}, e, { ownerState: pe({}, e.ownerState, t) });
}
function t0(n, e = []) {
  if (n === void 0) return {};
  const t = {};
  return (
    Object.keys(n)
      .filter(
        (r) =>
          r.match(/^on[A-Z]/) && typeof n[r] == "function" && !e.includes(r)
      )
      .forEach((r) => {
        t[r] = n[r];
      }),
    t
  );
}
function BM(n) {
  if (n === void 0) return {};
  const e = {};
  return (
    Object.keys(n)
      .filter((t) => !(t.match(/^on[A-Z]/) && typeof n[t] == "function"))
      .forEach((t) => {
        e[t] = n[t];
      }),
    e
  );
}
function $C(n) {
  const {
    getSlotProps: e,
    additionalProps: t,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: o,
  } = n;
  if (!e) {
    const y = cn(
        t == null ? void 0 : t.className,
        o,
        i == null ? void 0 : i.className,
        r == null ? void 0 : r.className
      ),
      _ = pe(
        {},
        t == null ? void 0 : t.style,
        i == null ? void 0 : i.style,
        r == null ? void 0 : r.style
      ),
      S = pe({}, t, i, r);
    return (
      y.length > 0 && (S.className = y),
      Object.keys(_).length > 0 && (S.style = _),
      { props: S, internalRef: void 0 }
    );
  }
  const s = t0(pe({}, i, r)),
    l = BM(r),
    u = BM(i),
    f = e(s),
    h = cn(
      f == null ? void 0 : f.className,
      t == null ? void 0 : t.className,
      o,
      i == null ? void 0 : i.className,
      r == null ? void 0 : r.className
    ),
    m = pe(
      {},
      f == null ? void 0 : f.style,
      t == null ? void 0 : t.style,
      i == null ? void 0 : i.style,
      r == null ? void 0 : r.style
    ),
    g = pe({}, f, t, u, l);
  return (
    h.length > 0 && (g.className = h),
    Object.keys(m).length > 0 && (g.style = m),
    { props: g, internalRef: f.ref }
  );
}
function XC(n, e, t) {
  return typeof n == "function" ? n(e, t) : n;
}
const WL = [
  "elementType",
  "externalSlotProps",
  "ownerState",
  "skipResolvingSlotProps",
];
function sh(n) {
  var e;
  const {
      elementType: t,
      externalSlotProps: r,
      ownerState: i,
      skipResolvingSlotProps: o = !1,
    } = n,
    s = Ft(n, WL),
    l = o ? {} : XC(r, i),
    { props: u, internalRef: f } = $C(pe({}, s, { externalSlotProps: l })),
    h = xi(
      f,
      l == null ? void 0 : l.ref,
      (e = n.additionalProps) == null ? void 0 : e.ref
    );
  return jC(t, pe({}, u, { ref: h }), i);
}
const jL = ee.createContext(),
  $L = () => {
    const n = ee.useContext(jL);
    return n ?? !1;
  },
  XL = ee.createContext(void 0);
function YL(n) {
  const { theme: e, name: t, props: r } = n;
  if (!e || !e.components || !e.components[t]) return r;
  const i = e.components[t];
  return i.defaultProps
    ? tm(i.defaultProps, r)
    : !i.styleOverrides && !i.variants
    ? tm(i, r)
    : r;
}
function qL({ props: n, name: e }) {
  const t = ee.useContext(XL);
  return YL({ props: n, name: e, theme: { components: t } });
}
function KL(n = "") {
  function e(...r) {
    if (!r.length) return "";
    const i = r[0];
    return typeof i == "string" &&
      !i.match(
        /(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/
      )
      ? `, var(--${n ? `${n}-` : ""}${i}${e(...r.slice(1))})`
      : `, ${i}`;
  }
  return (r, ...i) => `var(--${n ? `${n}-` : ""}${r}${e(...i)})`;
}
const VM = (n, e, t, r = []) => {
    let i = n;
    e.forEach((o, s) => {
      s === e.length - 1
        ? Array.isArray(i)
          ? (i[Number(o)] = t)
          : i && typeof i == "object" && (i[o] = t)
        : i &&
          typeof i == "object" &&
          (i[o] || (i[o] = r.includes(o) ? [] : {}), (i = i[o]));
    });
  },
  ZL = (n, e, t) => {
    function r(i, o = [], s = []) {
      Object.entries(i).forEach(([l, u]) => {
        (!t || (t && !t([...o, l]))) &&
          u != null &&
          (typeof u == "object" && Object.keys(u).length > 0
            ? r(u, [...o, l], Array.isArray(u) ? [...s, l] : s)
            : e([...o, l], u, s));
      });
    }
    r(n);
  },
  JL = (n, e) =>
    typeof e == "number"
      ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) =>
          n.includes(r)
        ) || n[n.length - 1].toLowerCase().indexOf("opacity") >= 0
        ? e
        : `${e}px`
      : e;
function zx(n, e) {
  const { prefix: t, shouldSkipGeneratingVar: r } = e || {},
    i = {},
    o = {},
    s = {};
  return (
    ZL(
      n,
      (l, u, f) => {
        if (
          (typeof u == "string" || typeof u == "number") &&
          (!r || !r(l, u))
        ) {
          const h = `--${t ? `${t}-` : ""}${l.join("-")}`;
          Object.assign(i, { [h]: JL(l, u) }),
            VM(o, l, `var(${h})`, f),
            VM(s, l, `var(${h}, ${u})`, f);
        }
      },
      (l) => l[0] === "vars"
    ),
    { css: i, vars: o, varsWithDefaults: s }
  );
}
function nm(n) {
  "@babel/helpers - typeof";
  return (
    (nm =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    nm(n)
  );
}
function QL(n, e) {
  if (nm(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e);
    if (nm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function YC(n) {
  var e = QL(n, "string");
  return nm(e) == "symbol" ? e : e + "";
}
const eD = ["colorSchemes", "components", "defaultColorScheme"];
function tD(n, e) {
  const { colorSchemes: t = {}, defaultColorScheme: r = "light" } = n,
    i = Ft(n, eD),
    { vars: o, css: s, varsWithDefaults: l } = zx(i, e);
  let u = l;
  const f = {},
    { [r]: h } = t,
    m = Ft(t, [r].map(YC));
  if (
    (Object.entries(m || {}).forEach(([y, _]) => {
      const { vars: S, css: x, varsWithDefaults: w } = zx(_, e);
      (u = ti(u, w)), (f[y] = { css: x, vars: S });
    }),
    h)
  ) {
    const { css: y, vars: _, varsWithDefaults: S } = zx(h, e);
    (u = ti(u, S)), (f[r] = { css: y, vars: _ });
  }
  return {
    vars: u,
    generateCssVars: (y) => {
      var _;
      if (!y) {
        var S;
        const w = pe({}, s);
        return {
          css: w,
          vars: o,
          selector:
            (e == null || (S = e.getSelector) == null
              ? void 0
              : S.call(e, y, w)) || ":root",
        };
      }
      const x = pe({}, f[y].css);
      return {
        css: x,
        vars: f[y].vars,
        selector:
          (e == null || (_ = e.getSelector) == null
            ? void 0
            : _.call(e, y, x)) || ":root",
      };
    },
  };
}
const nD = [
    "component",
    "direction",
    "spacing",
    "divider",
    "children",
    "className",
    "useFlexGap",
  ],
  rD = Pm(),
  iD = CL("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  });
function oD(n) {
  return zC({ props: n, name: "MuiStack", defaultTheme: rD });
}
function sD(n, e) {
  const t = ee.Children.toArray(n).filter(Boolean);
  return t.reduce(
    (r, i, o) => (
      r.push(i),
      o < t.length - 1 && r.push(ee.cloneElement(e, { key: `separator-${o}` })),
      r
    ),
    []
  );
}
const aD = (n) =>
    ({
      row: "Left",
      "row-reverse": "Right",
      column: "Top",
      "column-reverse": "Bottom",
    }[n]),
  lD = ({ ownerState: n, theme: e }) => {
    let t = pe(
      { display: "flex", flexDirection: "column" },
      oa(
        { theme: e },
        kx({ values: n.direction, breakpoints: e.breakpoints.values }),
        (r) => ({ flexDirection: r })
      )
    );
    if (n.spacing) {
      const r = fS(e),
        i = Object.keys(e.breakpoints.values).reduce(
          (u, f) => (
            ((typeof n.spacing == "object" && n.spacing[f] != null) ||
              (typeof n.direction == "object" && n.direction[f] != null)) &&
              (u[f] = !0),
            u
          ),
          {}
        ),
        o = kx({ values: n.direction, base: i }),
        s = kx({ values: n.spacing, base: i });
      typeof o == "object" &&
        Object.keys(o).forEach((u, f, h) => {
          if (!o[u]) {
            const g = f > 0 ? o[h[f - 1]] : "column";
            o[u] = g;
          }
        }),
        (t = ti(
          t,
          oa({ theme: e }, s, (u, f) =>
            n.useFlexGap
              ? { gap: rf(r, u) }
              : {
                  "& > :not(style):not(style)": { margin: 0 },
                  "& > :not(style) ~ :not(style)": {
                    [`margin${aD(f ? o[f] : n.direction)}`]: rf(r, u),
                  },
                }
          )
        ));
    }
    return (t = pI(e.breakpoints, t)), t;
  };
function uD(n = {}) {
  const {
      createStyledComponent: e = iD,
      useThemeProps: t = oD,
      componentName: r = "MuiStack",
    } = n,
    i = () => pr({ root: ["root"] }, (u) => hr(r, u), {}),
    o = e(lD);
  return ee.forwardRef(function (u, f) {
    const h = t(u),
      m = ry(h),
      {
        component: g = "div",
        direction: y = "column",
        spacing: _ = 0,
        divider: S,
        children: x,
        className: w,
        useFlexGap: T = !1,
      } = m,
      E = Ft(m, nD),
      A = { direction: y, spacing: _, useFlexGap: T },
      R = i();
    return ve.jsx(
      o,
      pe({ as: g, ownerState: A, ref: f, className: cn(R.root, w) }, E, {
        children: S ? sD(x, S) : x,
      })
    );
  });
}
function cD(n, e) {
  return pe(
    {
      toolbar: {
        minHeight: 56,
        [n.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
        [n.up("sm")]: { minHeight: 64 },
      },
    },
    e
  );
}
var cr = {},
  Bx = { exports: {} },
  HM;
function qC() {
  return (
    HM ||
      ((HM = 1),
      (function (n) {
        function e(t) {
          return t && t.__esModule ? t : { default: t };
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(Bx)),
    Bx.exports
  );
}
const fD = Hu(p3),
  dD = Hu(PL);
var GM;
function hD() {
  if (GM) return cr;
  GM = 1;
  var n = qC();
  Object.defineProperty(cr, "__esModule", { value: !0 }),
    (cr.alpha = _),
    (cr.blend = D),
    (cr.colorChannel = void 0),
    (cr.darken = x),
    (cr.decomposeColor = s),
    (cr.emphasize = A),
    (cr.getContrastRatio = y),
    (cr.getLuminance = g),
    (cr.hexToRgb = i),
    (cr.hslToRgb = m),
    (cr.lighten = T),
    (cr.private_safeAlpha = S),
    (cr.private_safeColorChannel = void 0),
    (cr.private_safeDarken = w),
    (cr.private_safeEmphasize = R),
    (cr.private_safeLighten = E),
    (cr.recomposeColor = f),
    (cr.rgbToHex = h);
  var e = n(fD),
    t = n(dD);
  function r(I, U = 0, O = 1) {
    return (0, t.default)(I, U, O);
  }
  function i(I) {
    I = I.slice(1);
    const U = new RegExp(`.{1,${I.length >= 6 ? 2 : 1}}`, "g");
    let O = I.match(U);
    return (
      O && O[0].length === 1 && (O = O.map((L) => L + L)),
      O
        ? `rgb${O.length === 4 ? "a" : ""}(${O.map((L, V) =>
            V < 3
              ? parseInt(L, 16)
              : Math.round((parseInt(L, 16) / 255) * 1e3) / 1e3
          ).join(", ")})`
        : ""
    );
  }
  function o(I) {
    const U = I.toString(16);
    return U.length === 1 ? `0${U}` : U;
  }
  function s(I) {
    if (I.type) return I;
    if (I.charAt(0) === "#") return s(i(I));
    const U = I.indexOf("("),
      O = I.substring(0, U);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(O) === -1)
      throw new Error((0, e.default)(9, I));
    let L = I.substring(U + 1, I.length - 1),
      V;
    if (O === "color") {
      if (
        ((L = L.split(" ")),
        (V = L.shift()),
        L.length === 4 && L[3].charAt(0) === "/" && (L[3] = L[3].slice(1)),
        ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(
          V
        ) === -1)
      )
        throw new Error((0, e.default)(10, V));
    } else L = L.split(",");
    return (
      (L = L.map((H) => parseFloat(H))), { type: O, values: L, colorSpace: V }
    );
  }
  const l = (I) => {
    const U = s(I);
    return U.values
      .slice(0, 3)
      .map((O, L) => (U.type.indexOf("hsl") !== -1 && L !== 0 ? `${O}%` : O))
      .join(" ");
  };
  cr.colorChannel = l;
  const u = (I, U) => {
    try {
      return l(I);
    } catch {
      return I;
    }
  };
  cr.private_safeColorChannel = u;
  function f(I) {
    const { type: U, colorSpace: O } = I;
    let { values: L } = I;
    return (
      U.indexOf("rgb") !== -1
        ? (L = L.map((V, H) => (H < 3 ? parseInt(V, 10) : V)))
        : U.indexOf("hsl") !== -1 && ((L[1] = `${L[1]}%`), (L[2] = `${L[2]}%`)),
      U.indexOf("color") !== -1
        ? (L = `${O} ${L.join(" ")}`)
        : (L = `${L.join(", ")}`),
      `${U}(${L})`
    );
  }
  function h(I) {
    if (I.indexOf("#") === 0) return I;
    const { values: U } = s(I);
    return `#${U.map((O, L) => o(L === 3 ? Math.round(255 * O) : O)).join("")}`;
  }
  function m(I) {
    I = s(I);
    const { values: U } = I,
      O = U[0],
      L = U[1] / 100,
      V = U[2] / 100,
      H = L * Math.min(V, 1 - V),
      $ = (Y, ne = (Y + O / 30) % 12) =>
        V - H * Math.max(Math.min(ne - 3, 9 - ne, 1), -1);
    let q = "rgb";
    const K = [
      Math.round($(0) * 255),
      Math.round($(8) * 255),
      Math.round($(4) * 255),
    ];
    return (
      I.type === "hsla" && ((q += "a"), K.push(U[3])), f({ type: q, values: K })
    );
  }
  function g(I) {
    I = s(I);
    let U = I.type === "hsl" || I.type === "hsla" ? s(m(I)).values : I.values;
    return (
      (U = U.map(
        (O) => (
          I.type !== "color" && (O /= 255),
          O <= 0.03928 ? O / 12.92 : ((O + 0.055) / 1.055) ** 2.4
        )
      )),
      Number((0.2126 * U[0] + 0.7152 * U[1] + 0.0722 * U[2]).toFixed(3))
    );
  }
  function y(I, U) {
    const O = g(I),
      L = g(U);
    return (Math.max(O, L) + 0.05) / (Math.min(O, L) + 0.05);
  }
  function _(I, U) {
    return (
      (I = s(I)),
      (U = r(U)),
      (I.type === "rgb" || I.type === "hsl") && (I.type += "a"),
      I.type === "color" ? (I.values[3] = `/${U}`) : (I.values[3] = U),
      f(I)
    );
  }
  function S(I, U, O) {
    try {
      return _(I, U);
    } catch {
      return I;
    }
  }
  function x(I, U) {
    if (((I = s(I)), (U = r(U)), I.type.indexOf("hsl") !== -1))
      I.values[2] *= 1 - U;
    else if (I.type.indexOf("rgb") !== -1 || I.type.indexOf("color") !== -1)
      for (let O = 0; O < 3; O += 1) I.values[O] *= 1 - U;
    return f(I);
  }
  function w(I, U, O) {
    try {
      return x(I, U);
    } catch {
      return I;
    }
  }
  function T(I, U) {
    if (((I = s(I)), (U = r(U)), I.type.indexOf("hsl") !== -1))
      I.values[2] += (100 - I.values[2]) * U;
    else if (I.type.indexOf("rgb") !== -1)
      for (let O = 0; O < 3; O += 1) I.values[O] += (255 - I.values[O]) * U;
    else if (I.type.indexOf("color") !== -1)
      for (let O = 0; O < 3; O += 1) I.values[O] += (1 - I.values[O]) * U;
    return f(I);
  }
  function E(I, U, O) {
    try {
      return T(I, U);
    } catch {
      return I;
    }
  }
  function A(I, U = 0.15) {
    return g(I) > 0.5 ? x(I, U) : T(I, U);
  }
  function R(I, U, O) {
    try {
      return A(I, U);
    } catch {
      return I;
    }
  }
  function D(I, U, O, L = 1) {
    const V = (K, Y) =>
        Math.round((K ** (1 / L) * (1 - O) + Y ** (1 / L) * O) ** L),
      H = s(I),
      $ = s(U),
      q = [
        V(H.values[0], $.values[0]),
        V(H.values[1], $.values[1]),
        V(H.values[2], $.values[2]),
      ];
    return f({ type: "rgb", values: q });
  }
  return cr;
}
var ts = hD();
const pD = ["mode", "contrastThreshold", "tonalOffset"],
  WM = {
    text: {
      primary: "rgba(0, 0, 0, 0.87)",
      secondary: "rgba(0, 0, 0, 0.6)",
      disabled: "rgba(0, 0, 0, 0.38)",
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: { paper: Zp.white, default: Zp.white },
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  },
  Vx = {
    text: {
      primary: Zp.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)",
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: { paper: "#121212", default: "#121212" },
    action: {
      active: Zp.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  };
function jM(n, e, t, r) {
  const i = r.light || r,
    o = r.dark || r * 1.5;
  n[e] ||
    (n.hasOwnProperty(t)
      ? (n[e] = n[t])
      : e === "light"
      ? (n.light = ts.lighten(n.main, i))
      : e === "dark" && (n.dark = ts.darken(n.main, o)));
}
function mD(n = "light") {
  return n === "dark"
    ? { main: pd[200], light: pd[50], dark: pd[400] }
    : { main: pd[700], light: pd[400], dark: pd[800] };
}
function gD(n = "light") {
  return n === "dark"
    ? { main: hd[200], light: hd[50], dark: hd[400] }
    : { main: hd[500], light: hd[300], dark: hd[700] };
}
function vD(n = "light") {
  return n === "dark"
    ? { main: dd[500], light: dd[300], dark: dd[700] }
    : { main: dd[700], light: dd[400], dark: dd[800] };
}
function yD(n = "light") {
  return n === "dark"
    ? { main: md[400], light: md[300], dark: md[700] }
    : { main: md[700], light: md[500], dark: md[900] };
}
function xD(n = "light") {
  return n === "dark"
    ? { main: gd[400], light: gd[300], dark: gd[700] }
    : { main: gd[800], light: gd[500], dark: gd[900] };
}
function _D(n = "light") {
  return n === "dark"
    ? { main: ap[400], light: ap[300], dark: ap[700] }
    : { main: "#ed6c02", light: ap[500], dark: ap[900] };
}
function SD(n) {
  const {
      mode: e = "light",
      contrastThreshold: t = 3,
      tonalOffset: r = 0.2,
    } = n,
    i = Ft(n, pD),
    o = n.primary || mD(e),
    s = n.secondary || gD(e),
    l = n.error || vD(e),
    u = n.info || yD(e),
    f = n.success || xD(e),
    h = n.warning || _D(e);
  function m(S) {
    return ts.getContrastRatio(S, Vx.text.primary) >= t
      ? Vx.text.primary
      : WM.text.primary;
  }
  const g = ({
      color: S,
      name: x,
      mainShade: w = 500,
      lightShade: T = 300,
      darkShade: E = 700,
    }) => {
      if (
        ((S = pe({}, S)),
        !S.main && S[w] && (S.main = S[w]),
        !S.hasOwnProperty("main"))
      )
        throw new Error(Rl(11, x ? ` (${x})` : "", w));
      if (typeof S.main != "string")
        throw new Error(Rl(12, x ? ` (${x})` : "", JSON.stringify(S.main)));
      return (
        jM(S, "light", T, r),
        jM(S, "dark", E, r),
        S.contrastText || (S.contrastText = m(S.main)),
        S
      );
    },
    y = { dark: Vx, light: WM };
  return ti(
    pe(
      {
        common: pe({}, Zp),
        mode: e,
        primary: g({ color: o, name: "primary" }),
        secondary: g({
          color: s,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700",
        }),
        error: g({ color: l, name: "error" }),
        warning: g({ color: h, name: "warning" }),
        info: g({ color: u, name: "info" }),
        success: g({ color: f, name: "success" }),
        grey: h3,
        contrastThreshold: t,
        getContrastText: m,
        augmentColor: g,
        tonalOffset: r,
      },
      y[e]
    ),
    i
  );
}
const wD = [
  "fontFamily",
  "fontSize",
  "fontWeightLight",
  "fontWeightRegular",
  "fontWeightMedium",
  "fontWeightBold",
  "htmlFontSize",
  "allVariants",
  "pxToRem",
];
function MD(n) {
  return Math.round(n * 1e5) / 1e5;
}
const $M = { textTransform: "uppercase" },
  XM = '"Roboto", "Helvetica", "Arial", sans-serif';
function bD(n, e) {
  const t = typeof e == "function" ? e(n) : e,
    {
      fontFamily: r = XM,
      fontSize: i = 14,
      fontWeightLight: o = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: l = 500,
      fontWeightBold: u = 700,
      htmlFontSize: f = 16,
      allVariants: h,
      pxToRem: m,
    } = t,
    g = Ft(t, wD),
    y = i / 14,
    _ = m || ((w) => `${(w / f) * y}rem`),
    S = (w, T, E, A, R) =>
      pe(
        { fontFamily: r, fontWeight: w, fontSize: _(T), lineHeight: E },
        r === XM ? { letterSpacing: `${MD(A / T)}em` } : {},
        R,
        h
      ),
    x = {
      h1: S(o, 96, 1.167, -1.5),
      h2: S(o, 60, 1.2, -0.5),
      h3: S(s, 48, 1.167, 0),
      h4: S(s, 34, 1.235, 0.25),
      h5: S(s, 24, 1.334, 0),
      h6: S(l, 20, 1.6, 0.15),
      subtitle1: S(s, 16, 1.75, 0.15),
      subtitle2: S(l, 14, 1.57, 0.1),
      body1: S(s, 16, 1.5, 0.15),
      body2: S(s, 14, 1.43, 0.15),
      button: S(l, 14, 1.75, 0.4, $M),
      caption: S(s, 12, 1.66, 0.4),
      overline: S(s, 12, 2.66, 1, $M),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit",
      },
    };
  return ti(
    pe(
      {
        htmlFontSize: f,
        pxToRem: _,
        fontFamily: r,
        fontSize: i,
        fontWeightLight: o,
        fontWeightRegular: s,
        fontWeightMedium: l,
        fontWeightBold: u,
      },
      x
    ),
    g,
    { clone: !1 }
  );
}
const ED = 0.2,
  TD = 0.14,
  CD = 0.12;
function tr(...n) {
  return [
    `${n[0]}px ${n[1]}px ${n[2]}px ${n[3]}px rgba(0,0,0,${ED})`,
    `${n[4]}px ${n[5]}px ${n[6]}px ${n[7]}px rgba(0,0,0,${TD})`,
    `${n[8]}px ${n[9]}px ${n[10]}px ${n[11]}px rgba(0,0,0,${CD})`,
  ].join(",");
}
const AD = [
    "none",
    tr(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    tr(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    tr(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    tr(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    tr(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    tr(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    tr(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    tr(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    tr(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    tr(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    tr(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    tr(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    tr(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    tr(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    tr(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    tr(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    tr(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    tr(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    tr(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    tr(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    tr(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    tr(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    tr(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    tr(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  RD = ["duration", "easing", "delay"],
  PD = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
  },
  ID = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195,
  };
function YM(n) {
  return `${Math.round(n)}ms`;
}
function LD(n) {
  if (!n) return 0;
  const e = n / 36;
  return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
}
function DD(n) {
  const e = pe({}, PD, n.easing),
    t = pe({}, ID, n.duration);
  return pe(
    {
      getAutoHeightDuration: LD,
      create: (i = ["all"], o = {}) => {
        const {
          duration: s = t.standard,
          easing: l = e.easeInOut,
          delay: u = 0,
        } = o;
        return (
          Ft(o, RD),
          (Array.isArray(i) ? i : [i])
            .map(
              (f) =>
                `${f} ${typeof s == "string" ? s : YM(s)} ${l} ${
                  typeof u == "string" ? u : YM(u)
                }`
            )
            .join(",")
        );
      },
    },
    n,
    { easing: e, duration: t }
  );
}
const kD = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500,
  },
  OD = [
    "breakpoints",
    "mixins",
    "spacing",
    "palette",
    "transitions",
    "typography",
    "shape",
  ];
function KC(n = {}, ...e) {
  const {
      mixins: t = {},
      palette: r = {},
      transitions: i = {},
      typography: o = {},
    } = n,
    s = Ft(n, OD);
  if (n.vars) throw new Error(Rl(18));
  const l = SD(r),
    u = Pm(n);
  let f = ti(u, {
    mixins: cD(u.breakpoints, t),
    palette: l,
    shadows: AD.slice(),
    typography: bD(l, o),
    transitions: DD(i),
    zIndex: pe({}, kD),
  });
  return (
    (f = ti(f, s)),
    (f = e.reduce((h, m) => ti(h, m), f)),
    (f.unstable_sxConfig = pe(
      {},
      mh,
      s == null ? void 0 : s.unstable_sxConfig
    )),
    (f.unstable_sx = function (m) {
      return df({ sx: m, theme: this });
    }),
    f
  );
}
const pS = KC();
function ZC() {
  const n = ny(pS);
  return n[j0] || n;
}
var Mc = {},
  Hx = { exports: {} },
  qM;
function ND() {
  return (
    qM ||
      ((qM = 1),
      (function (n) {
        function e() {
          return (
            (n.exports = e =
              Object.assign
                ? Object.assign.bind()
                : function (t) {
                    for (var r = 1; r < arguments.length; r++) {
                      var i = arguments[r];
                      for (var o in i)
                        ({}).hasOwnProperty.call(i, o) && (t[o] = i[o]);
                    }
                    return t;
                  }),
            (n.exports.__esModule = !0),
            (n.exports.default = n.exports),
            e.apply(null, arguments)
          );
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(Hx)),
    Hx.exports
  );
}
var Gx = { exports: {} },
  KM;
function UD() {
  return (
    KM ||
      ((KM = 1),
      (function (n) {
        function e(t, r) {
          if (t == null) return {};
          var i = {};
          for (var o in t)
            if ({}.hasOwnProperty.call(t, o)) {
              if (r.indexOf(o) !== -1) continue;
              i[o] = t[o];
            }
          return i;
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(Gx)),
    Gx.exports
  );
}
const FD = Hu(uI),
  zD = Hu(cI),
  BD = Hu(gI),
  VD = Hu(yL),
  HD = Hu(nL),
  GD = Hu(uL);
var ZM;
function WD() {
  if (ZM) return Mc;
  ZM = 1;
  var n = qC();
  Object.defineProperty(Mc, "__esModule", { value: !0 }),
    (Mc.default = A),
    (Mc.shouldForwardProp = _),
    (Mc.systemDefaultTheme = void 0);
  var e = n(ND()),
    t = n(UD()),
    r = m(FD),
    i = zD;
  n(BD), n(VD);
  var o = n(HD),
    s = n(GD);
  const l = ["ownerState"],
    u = ["variants"],
    f = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function h(R) {
    if (typeof WeakMap != "function") return null;
    var D = new WeakMap(),
      I = new WeakMap();
    return (h = function (U) {
      return U ? I : D;
    })(R);
  }
  function m(R, D) {
    if (R && R.__esModule) return R;
    if (R === null || (typeof R != "object" && typeof R != "function"))
      return { default: R };
    var I = h(D);
    if (I && I.has(R)) return I.get(R);
    var U = { __proto__: null },
      O = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var L in R)
      if (L !== "default" && Object.prototype.hasOwnProperty.call(R, L)) {
        var V = O ? Object.getOwnPropertyDescriptor(R, L) : null;
        V && (V.get || V.set) ? Object.defineProperty(U, L, V) : (U[L] = R[L]);
      }
    return (U.default = R), I && I.set(R, U), U;
  }
  function g(R) {
    return Object.keys(R).length === 0;
  }
  function y(R) {
    return typeof R == "string" && R.charCodeAt(0) > 96;
  }
  function _(R) {
    return R !== "ownerState" && R !== "theme" && R !== "sx" && R !== "as";
  }
  const S = (Mc.systemDefaultTheme = (0, o.default)()),
    x = (R) => R && R.charAt(0).toLowerCase() + R.slice(1);
  function w({ defaultTheme: R, theme: D, themeId: I }) {
    return g(D) ? R : D[I] || D;
  }
  function T(R) {
    return R ? (D, I) => I[R] : null;
  }
  function E(R, D) {
    let { ownerState: I } = D,
      U = (0, t.default)(D, l);
    const O =
      typeof R == "function" ? R((0, e.default)({ ownerState: I }, U)) : R;
    if (Array.isArray(O))
      return O.flatMap((L) => E(L, (0, e.default)({ ownerState: I }, U)));
    if (O && typeof O == "object" && Array.isArray(O.variants)) {
      const { variants: L = [] } = O;
      let H = (0, t.default)(O, u);
      return (
        L.forEach(($) => {
          let q = !0;
          typeof $.props == "function"
            ? (q = $.props((0, e.default)({ ownerState: I }, U, I)))
            : Object.keys($.props).forEach((K) => {
                (I == null ? void 0 : I[K]) !== $.props[K] &&
                  U[K] !== $.props[K] &&
                  (q = !1);
              }),
            q &&
              (Array.isArray(H) || (H = [H]),
              H.push(
                typeof $.style == "function"
                  ? $.style((0, e.default)({ ownerState: I }, U, I))
                  : $.style
              ));
        }),
        H
      );
    }
    return O;
  }
  function A(R = {}) {
    const {
        themeId: D,
        defaultTheme: I = S,
        rootShouldForwardProp: U = _,
        slotShouldForwardProp: O = _,
      } = R,
      L = (V) =>
        (0, s.default)(
          (0, e.default)({}, V, {
            theme: w((0, e.default)({}, V, { defaultTheme: I, themeId: D })),
          })
        );
    return (
      (L.__mui_systemSx = !0),
      (V, H = {}) => {
        (0, r.internal_processStyles)(V, (he) =>
          he.filter((ae) => !(ae != null && ae.__mui_systemSx))
        );
        const {
            name: $,
            slot: q,
            skipVariantsResolver: K,
            skipSx: Y,
            overridesResolver: ne = T(x(q)),
          } = H,
          j = (0, t.default)(H, f),
          re = K !== void 0 ? K : (q && q !== "Root" && q !== "root") || !1,
          B = Y || !1;
        let G,
          te = _;
        q === "Root" || q === "root"
          ? (te = U)
          : q
          ? (te = O)
          : y(V) && (te = void 0);
        const le = (0, r.default)(
            V,
            (0, e.default)({ shouldForwardProp: te, label: G }, j)
          ),
          J = (he) =>
            (typeof he == "function" && he.__emotion_real !== he) ||
            (0, i.isPlainObject)(he)
              ? (ae) =>
                  E(
                    he,
                    (0, e.default)({}, ae, {
                      theme: w({
                        theme: ae.theme,
                        defaultTheme: I,
                        themeId: D,
                      }),
                    })
                  )
              : he,
          oe = (he, ...ae) => {
            let ue = J(he);
            const Ee = ae ? ae.map(J) : [];
            $ &&
              ne &&
              Ee.push((W) => {
                const _e = w(
                  (0, e.default)({}, W, { defaultTheme: I, themeId: D })
                );
                if (
                  !_e.components ||
                  !_e.components[$] ||
                  !_e.components[$].styleOverrides
                )
                  return null;
                const Te = _e.components[$].styleOverrides,
                  ke = {};
                return (
                  Object.entries(Te).forEach(([Pe, rt]) => {
                    ke[Pe] = E(rt, (0, e.default)({}, W, { theme: _e }));
                  }),
                  ne(W, ke)
                );
              }),
              $ &&
                !re &&
                Ee.push((W) => {
                  var _e;
                  const Te = w(
                      (0, e.default)({}, W, { defaultTheme: I, themeId: D })
                    ),
                    ke =
                      Te == null ||
                      (_e = Te.components) == null ||
                      (_e = _e[$]) == null
                        ? void 0
                        : _e.variants;
                  return E(
                    { variants: ke },
                    (0, e.default)({}, W, { theme: Te })
                  );
                }),
              B || Ee.push(L);
            const Ne = Ee.length - ae.length;
            if (Array.isArray(he) && Ne > 0) {
              const W = new Array(Ne).fill("");
              (ue = [...he, ...W]), (ue.raw = [...he.raw, ...W]);
            }
            const Ae = le(ue, ...Ee);
            return V.muiName && (Ae.muiName = V.muiName), Ae;
          };
        return le.withConfig && (oe.withConfig = le.withConfig), oe;
      }
    );
  }
  return Mc;
}
var jD = WD();
const $D = Tm(jD);
function JC(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
const Rs = (n) => JC(n) && n !== "classes",
  en = $D({ themeId: j0, defaultTheme: pS, rootShouldForwardProp: Rs }),
  JM = (n) => {
    let e;
    return (
      n < 1 ? (e = 5.11916 * n ** 2) : (e = 4.5 * Math.log(n + 1) + 2),
      (e / 100).toFixed(2)
    );
  };
function Or(n) {
  return qL(n);
}
function XD(n) {
  return hr("MuiSvgIcon", n);
}
Xn("MuiSvgIcon", [
  "root",
  "colorPrimary",
  "colorSecondary",
  "colorAction",
  "colorError",
  "colorDisabled",
  "fontSizeInherit",
  "fontSizeSmall",
  "fontSizeMedium",
  "fontSizeLarge",
]);
const YD = [
    "children",
    "className",
    "color",
    "component",
    "fontSize",
    "htmlColor",
    "inheritViewBox",
    "titleAccess",
    "viewBox",
  ],
  qD = (n) => {
    const { color: e, fontSize: t, classes: r } = n,
      i = {
        root: ["root", e !== "inherit" && `color${fn(e)}`, `fontSize${fn(t)}`],
      };
    return pr(i, XD, r);
  },
  KD = en("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.color !== "inherit" && e[`color${fn(t.color)}`],
        e[`fontSize${fn(t.fontSize)}`],
      ];
    },
  })(({ theme: n, ownerState: e }) => {
    var t, r, i, o, s, l, u, f, h, m, g, y, _;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: e.hasSvgAsChild ? void 0 : "currentColor",
      flexShrink: 0,
      transition:
        (t = n.transitions) == null || (r = t.create) == null
          ? void 0
          : r.call(t, "fill", {
              duration:
                (i = n.transitions) == null || (i = i.duration) == null
                  ? void 0
                  : i.shorter,
            }),
      fontSize: {
        inherit: "inherit",
        small:
          ((o = n.typography) == null || (s = o.pxToRem) == null
            ? void 0
            : s.call(o, 20)) || "1.25rem",
        medium:
          ((l = n.typography) == null || (u = l.pxToRem) == null
            ? void 0
            : u.call(l, 24)) || "1.5rem",
        large:
          ((f = n.typography) == null || (h = f.pxToRem) == null
            ? void 0
            : h.call(f, 35)) || "2.1875rem",
      }[e.fontSize],
      color:
        (m =
          (g = (n.vars || n).palette) == null || (g = g[e.color]) == null
            ? void 0
            : g.main) != null
          ? m
          : {
              action:
                (y = (n.vars || n).palette) == null || (y = y.action) == null
                  ? void 0
                  : y.active,
              disabled:
                (_ = (n.vars || n).palette) == null || (_ = _.action) == null
                  ? void 0
                  : _.disabled,
              inherit: void 0,
            }[e.color],
    };
  }),
  v1 = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiSvgIcon" }),
      {
        children: i,
        className: o,
        color: s = "inherit",
        component: l = "svg",
        fontSize: u = "medium",
        htmlColor: f,
        inheritViewBox: h = !1,
        titleAccess: m,
        viewBox: g = "0 0 24 24",
      } = r,
      y = Ft(r, YD),
      _ = ee.isValidElement(i) && i.type === "svg",
      S = pe({}, r, {
        color: s,
        component: l,
        fontSize: u,
        instanceFontSize: e.fontSize,
        inheritViewBox: h,
        viewBox: g,
        hasSvgAsChild: _,
      }),
      x = {};
    h || (x.viewBox = g);
    const w = qD(S);
    return ve.jsxs(
      KD,
      pe(
        {
          as: l,
          className: cn(w.root, o),
          focusable: "false",
          color: f,
          "aria-hidden": m ? void 0 : !0,
          role: m ? "img" : void 0,
          ref: t,
        },
        x,
        y,
        _ && i.props,
        {
          ownerState: S,
          children: [
            _ ? i.props.children : i,
            m ? ve.jsx("title", { children: m }) : null,
          ],
        }
      )
    );
  });
v1.muiName = "SvgIcon";
function QC(n, e) {
  function t(r, i) {
    return ve.jsx(
      v1,
      pe({ "data-testid": `${e}Icon`, ref: i }, r, { children: n })
    );
  }
  return (t.muiName = v1.muiName), ee.memo(ee.forwardRef(t));
}
var Wx = { exports: {} },
  Ln = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var QM;
function ZD() {
  if (QM) return Ln;
  QM = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.server_context"),
    u = Symbol.for("react.forward_ref"),
    f = Symbol.for("react.suspense"),
    h = Symbol.for("react.suspense_list"),
    m = Symbol.for("react.memo"),
    g = Symbol.for("react.lazy"),
    y = Symbol.for("react.offscreen"),
    _;
  _ = Symbol.for("react.module.reference");
  function S(x) {
    if (typeof x == "object" && x !== null) {
      var w = x.$$typeof;
      switch (w) {
        case n:
          switch (((x = x.type), x)) {
            case t:
            case i:
            case r:
            case f:
            case h:
              return x;
            default:
              switch (((x = x && x.$$typeof), x)) {
                case l:
                case s:
                case u:
                case g:
                case m:
                case o:
                  return x;
                default:
                  return w;
              }
          }
        case e:
          return w;
      }
    }
  }
  return (
    (Ln.ContextConsumer = s),
    (Ln.ContextProvider = o),
    (Ln.Element = n),
    (Ln.ForwardRef = u),
    (Ln.Fragment = t),
    (Ln.Lazy = g),
    (Ln.Memo = m),
    (Ln.Portal = e),
    (Ln.Profiler = i),
    (Ln.StrictMode = r),
    (Ln.Suspense = f),
    (Ln.SuspenseList = h),
    (Ln.isAsyncMode = function () {
      return !1;
    }),
    (Ln.isConcurrentMode = function () {
      return !1;
    }),
    (Ln.isContextConsumer = function (x) {
      return S(x) === s;
    }),
    (Ln.isContextProvider = function (x) {
      return S(x) === o;
    }),
    (Ln.isElement = function (x) {
      return typeof x == "object" && x !== null && x.$$typeof === n;
    }),
    (Ln.isForwardRef = function (x) {
      return S(x) === u;
    }),
    (Ln.isFragment = function (x) {
      return S(x) === t;
    }),
    (Ln.isLazy = function (x) {
      return S(x) === g;
    }),
    (Ln.isMemo = function (x) {
      return S(x) === m;
    }),
    (Ln.isPortal = function (x) {
      return S(x) === e;
    }),
    (Ln.isProfiler = function (x) {
      return S(x) === i;
    }),
    (Ln.isStrictMode = function (x) {
      return S(x) === r;
    }),
    (Ln.isSuspense = function (x) {
      return S(x) === f;
    }),
    (Ln.isSuspenseList = function (x) {
      return S(x) === h;
    }),
    (Ln.isValidElementType = function (x) {
      return (
        typeof x == "string" ||
        typeof x == "function" ||
        x === t ||
        x === i ||
        x === r ||
        x === f ||
        x === h ||
        x === y ||
        (typeof x == "object" &&
          x !== null &&
          (x.$$typeof === g ||
            x.$$typeof === m ||
            x.$$typeof === o ||
            x.$$typeof === s ||
            x.$$typeof === u ||
            x.$$typeof === _ ||
            x.getModuleId !== void 0))
      );
    }),
    (Ln.typeOf = S),
    Ln
  );
}
var eb;
function JD() {
  return eb || ((eb = 1), (Wx.exports = ZD())), Wx.exports;
}
JD();
function y1(n, e) {
  return (
    (y1 = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (t, r) {
          return (t.__proto__ = r), t;
        }),
    y1(n, e)
  );
}
function e2(n, e) {
  (n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    y1(n, e);
}
const tb = { disabled: !1 },
  n0 = Ts.createContext(null);
var QD = function (e) {
    return e.scrollTop;
  },
  Pp = "unmounted",
  Fc = "exited",
  zc = "entering",
  Gd = "entered",
  x1 = "exiting",
  Wa = (function (n) {
    e2(e, n);
    function e(r, i) {
      var o;
      o = n.call(this, r, i) || this;
      var s = i,
        l = s && !s.isMounting ? r.enter : r.appear,
        u;
      return (
        (o.appearStatus = null),
        r.in
          ? l
            ? ((u = Fc), (o.appearStatus = zc))
            : (u = Gd)
          : r.unmountOnExit || r.mountOnEnter
          ? (u = Pp)
          : (u = Fc),
        (o.state = { status: u }),
        (o.nextCallback = null),
        o
      );
    }
    e.getDerivedStateFromProps = function (i, o) {
      var s = i.in;
      return s && o.status === Pp ? { status: Fc } : null;
    };
    var t = e.prototype;
    return (
      (t.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (t.componentDidUpdate = function (i) {
        var o = null;
        if (i !== this.props) {
          var s = this.state.status;
          this.props.in
            ? s !== zc && s !== Gd && (o = zc)
            : (s === zc || s === Gd) && (o = x1);
        }
        this.updateStatus(!1, o);
      }),
      (t.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (t.getTimeouts = function () {
        var i = this.props.timeout,
          o,
          s,
          l;
        return (
          (o = s = l = i),
          i != null &&
            typeof i != "number" &&
            ((o = i.exit),
            (s = i.enter),
            (l = i.appear !== void 0 ? i.appear : s)),
          { exit: o, enter: s, appear: l }
        );
      }),
      (t.updateStatus = function (i, o) {
        if ((i === void 0 && (i = !1), o !== null))
          if ((this.cancelNextCallback(), o === zc)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var s = this.props.nodeRef
                ? this.props.nodeRef.current
                : Fg.findDOMNode(this);
              s && QD(s);
            }
            this.performEnter(i);
          } else this.performExit();
        else
          this.props.unmountOnExit &&
            this.state.status === Fc &&
            this.setState({ status: Pp });
      }),
      (t.performEnter = function (i) {
        var o = this,
          s = this.props.enter,
          l = this.context ? this.context.isMounting : i,
          u = this.props.nodeRef ? [l] : [Fg.findDOMNode(this), l],
          f = u[0],
          h = u[1],
          m = this.getTimeouts(),
          g = l ? m.appear : m.enter;
        if ((!i && !s) || tb.disabled) {
          this.safeSetState({ status: Gd }, function () {
            o.props.onEntered(f);
          });
          return;
        }
        this.props.onEnter(f, h),
          this.safeSetState({ status: zc }, function () {
            o.props.onEntering(f, h),
              o.onTransitionEnd(g, function () {
                o.safeSetState({ status: Gd }, function () {
                  o.props.onEntered(f, h);
                });
              });
          });
      }),
      (t.performExit = function () {
        var i = this,
          o = this.props.exit,
          s = this.getTimeouts(),
          l = this.props.nodeRef ? void 0 : Fg.findDOMNode(this);
        if (!o || tb.disabled) {
          this.safeSetState({ status: Fc }, function () {
            i.props.onExited(l);
          });
          return;
        }
        this.props.onExit(l),
          this.safeSetState({ status: x1 }, function () {
            i.props.onExiting(l),
              i.onTransitionEnd(s.exit, function () {
                i.safeSetState({ status: Fc }, function () {
                  i.props.onExited(l);
                });
              });
          });
      }),
      (t.cancelNextCallback = function () {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (t.safeSetState = function (i, o) {
        (o = this.setNextCallback(o)), this.setState(i, o);
      }),
      (t.setNextCallback = function (i) {
        var o = this,
          s = !0;
        return (
          (this.nextCallback = function (l) {
            s && ((s = !1), (o.nextCallback = null), i(l));
          }),
          (this.nextCallback.cancel = function () {
            s = !1;
          }),
          this.nextCallback
        );
      }),
      (t.onTransitionEnd = function (i, o) {
        this.setNextCallback(o);
        var s = this.props.nodeRef
            ? this.props.nodeRef.current
            : Fg.findDOMNode(this),
          l = i == null && !this.props.addEndListener;
        if (!s || l) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var u = this.props.nodeRef
              ? [this.nextCallback]
              : [s, this.nextCallback],
            f = u[0],
            h = u[1];
          this.props.addEndListener(f, h);
        }
        i != null && setTimeout(this.nextCallback, i);
      }),
      (t.render = function () {
        var i = this.state.status;
        if (i === Pp) return null;
        var o = this.props,
          s = o.children;
        o.in,
          o.mountOnEnter,
          o.unmountOnExit,
          o.appear,
          o.enter,
          o.exit,
          o.timeout,
          o.addEndListener,
          o.onEnter,
          o.onEntering,
          o.onEntered,
          o.onExit,
          o.onExiting,
          o.onExited,
          o.nodeRef;
        var l = Ft(o, [
          "children",
          "in",
          "mountOnEnter",
          "unmountOnExit",
          "appear",
          "enter",
          "exit",
          "timeout",
          "addEndListener",
          "onEnter",
          "onEntering",
          "onEntered",
          "onExit",
          "onExiting",
          "onExited",
          "nodeRef",
        ]);
        return Ts.createElement(
          n0.Provider,
          { value: null },
          typeof s == "function"
            ? s(i, l)
            : Ts.cloneElement(Ts.Children.only(s), l)
        );
      }),
      e
    );
  })(Ts.Component);
Wa.contextType = n0;
Wa.propTypes = {};
function vd() {}
Wa.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: vd,
  onEntering: vd,
  onEntered: vd,
  onExit: vd,
  onExiting: vd,
  onExited: vd,
};
Wa.UNMOUNTED = Pp;
Wa.EXITED = Fc;
Wa.ENTERING = zc;
Wa.ENTERED = Gd;
Wa.EXITING = x1;
function ek(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function mS(n, e) {
  var t = function (o) {
      return e && ee.isValidElement(o) ? e(o) : o;
    },
    r = Object.create(null);
  return (
    n &&
      ee.Children.map(n, function (i) {
        return i;
      }).forEach(function (i) {
        r[i.key] = t(i);
      }),
    r
  );
}
function tk(n, e) {
  (n = n || {}), (e = e || {});
  function t(h) {
    return h in e ? e[h] : n[h];
  }
  var r = Object.create(null),
    i = [];
  for (var o in n) o in e ? i.length && ((r[o] = i), (i = [])) : i.push(o);
  var s,
    l = {};
  for (var u in e) {
    if (r[u])
      for (s = 0; s < r[u].length; s++) {
        var f = r[u][s];
        l[r[u][s]] = t(f);
      }
    l[u] = t(u);
  }
  for (s = 0; s < i.length; s++) l[i[s]] = t(i[s]);
  return l;
}
function $c(n, e, t) {
  return t[e] != null ? t[e] : n.props[e];
}
function nk(n, e) {
  return mS(n.children, function (t) {
    return ee.cloneElement(t, {
      onExited: e.bind(null, t),
      in: !0,
      appear: $c(t, "appear", n),
      enter: $c(t, "enter", n),
      exit: $c(t, "exit", n),
    });
  });
}
function rk(n, e, t) {
  var r = mS(n.children),
    i = tk(e, r);
  return (
    Object.keys(i).forEach(function (o) {
      var s = i[o];
      if (ee.isValidElement(s)) {
        var l = o in e,
          u = o in r,
          f = e[o],
          h = ee.isValidElement(f) && !f.props.in;
        u && (!l || h)
          ? (i[o] = ee.cloneElement(s, {
              onExited: t.bind(null, s),
              in: !0,
              exit: $c(s, "exit", n),
              enter: $c(s, "enter", n),
            }))
          : !u && l && !h
          ? (i[o] = ee.cloneElement(s, { in: !1 }))
          : u &&
            l &&
            ee.isValidElement(f) &&
            (i[o] = ee.cloneElement(s, {
              onExited: t.bind(null, s),
              in: f.props.in,
              exit: $c(s, "exit", n),
              enter: $c(s, "enter", n),
            }));
      }
    }),
    i
  );
}
var ik =
    Object.values ||
    function (n) {
      return Object.keys(n).map(function (e) {
        return n[e];
      });
    },
  ok = {
    component: "div",
    childFactory: function (e) {
      return e;
    },
  },
  gS = (function (n) {
    e2(e, n);
    function e(r, i) {
      var o;
      o = n.call(this, r, i) || this;
      var s = o.handleExited.bind(ek(o));
      return (
        (o.state = {
          contextValue: { isMounting: !0 },
          handleExited: s,
          firstRender: !0,
        }),
        o
      );
    }
    var t = e.prototype;
    return (
      (t.componentDidMount = function () {
        (this.mounted = !0),
          this.setState({ contextValue: { isMounting: !1 } });
      }),
      (t.componentWillUnmount = function () {
        this.mounted = !1;
      }),
      (e.getDerivedStateFromProps = function (i, o) {
        var s = o.children,
          l = o.handleExited,
          u = o.firstRender;
        return { children: u ? nk(i, l) : rk(i, s, l), firstRender: !1 };
      }),
      (t.handleExited = function (i, o) {
        var s = mS(this.props.children);
        i.key in s ||
          (i.props.onExited && i.props.onExited(o),
          this.mounted &&
            this.setState(function (l) {
              var u = pe({}, l.children);
              return delete u[i.key], { children: u };
            }));
      }),
      (t.render = function () {
        var i = this.props,
          o = i.component,
          s = i.childFactory,
          l = Ft(i, ["component", "childFactory"]),
          u = this.state.contextValue,
          f = ik(this.state.children).map(s);
        return (
          delete l.appear,
          delete l.enter,
          delete l.exit,
          o === null
            ? Ts.createElement(n0.Provider, { value: u }, f)
            : Ts.createElement(
                n0.Provider,
                { value: u },
                Ts.createElement(o, l, f)
              )
        );
      }),
      e
    );
  })(Ts.Component);
gS.propTypes = {};
gS.defaultProps = ok;
const t2 = (n) => n.scrollTop;
function r0(n, e) {
  var t, r;
  const { timeout: i, easing: o, style: s = {} } = n;
  return {
    duration:
      (t = s.transitionDuration) != null
        ? t
        : typeof i == "number"
        ? i
        : i[e.mode] || 0,
    easing:
      (r = s.transitionTimingFunction) != null
        ? r
        : typeof o == "object"
        ? o[e.mode]
        : o,
    delay: s.transitionDelay,
  };
}
function sk(n) {
  return hr("MuiPaper", n);
}
Xn("MuiPaper", [
  "root",
  "rounded",
  "outlined",
  "elevation",
  "elevation0",
  "elevation1",
  "elevation2",
  "elevation3",
  "elevation4",
  "elevation5",
  "elevation6",
  "elevation7",
  "elevation8",
  "elevation9",
  "elevation10",
  "elevation11",
  "elevation12",
  "elevation13",
  "elevation14",
  "elevation15",
  "elevation16",
  "elevation17",
  "elevation18",
  "elevation19",
  "elevation20",
  "elevation21",
  "elevation22",
  "elevation23",
  "elevation24",
]);
const ak = ["className", "component", "elevation", "square", "variant"],
  lk = (n) => {
    const { square: e, elevation: t, variant: r, classes: i } = n,
      o = {
        root: [
          "root",
          r,
          !e && "rounded",
          r === "elevation" && `elevation${t}`,
        ],
      };
    return pr(o, sk, i);
  },
  uk = en("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        e[t.variant],
        !t.square && e.rounded,
        t.variant === "elevation" && e[`elevation${t.elevation}`],
      ];
    },
  })(({ theme: n, ownerState: e }) => {
    var t;
    return pe(
      {
        backgroundColor: (n.vars || n).palette.background.paper,
        color: (n.vars || n).palette.text.primary,
        transition: n.transitions.create("box-shadow"),
      },
      !e.square && { borderRadius: n.shape.borderRadius },
      e.variant === "outlined" && {
        border: `1px solid ${(n.vars || n).palette.divider}`,
      },
      e.variant === "elevation" &&
        pe(
          { boxShadow: (n.vars || n).shadows[e.elevation] },
          !n.vars &&
            n.palette.mode === "dark" && {
              backgroundImage: `linear-gradient(${ts.alpha(
                "#fff",
                JM(e.elevation)
              )}, ${ts.alpha("#fff", JM(e.elevation))})`,
            },
          n.vars && {
            backgroundImage:
              (t = n.vars.overlays) == null ? void 0 : t[e.elevation],
          }
        )
    );
  }),
  ck = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiPaper" }),
      {
        className: i,
        component: o = "div",
        elevation: s = 1,
        square: l = !1,
        variant: u = "elevation",
      } = r,
      f = Ft(r, ak),
      h = pe({}, r, { component: o, elevation: s, square: l, variant: u }),
      m = lk(h);
    return ve.jsx(
      uk,
      pe({ as: o, ownerState: h, className: cn(m.root, i), ref: t }, f)
    );
  });
function fk(n) {
  const {
      className: e,
      classes: t,
      pulsate: r = !1,
      rippleX: i,
      rippleY: o,
      rippleSize: s,
      in: l,
      onExited: u,
      timeout: f,
    } = n,
    [h, m] = ee.useState(!1),
    g = cn(e, t.ripple, t.rippleVisible, r && t.ripplePulsate),
    y = { width: s, height: s, top: -(s / 2) + o, left: -(s / 2) + i },
    _ = cn(t.child, h && t.childLeaving, r && t.childPulsate);
  return (
    !l && !h && m(!0),
    ee.useEffect(() => {
      if (!l && u != null) {
        const S = setTimeout(u, f);
        return () => {
          clearTimeout(S);
        };
      }
    }, [u, l, f]),
    ve.jsx("span", {
      className: g,
      style: y,
      children: ve.jsx("span", { className: _ }),
    })
  );
}
const ws = Xn("MuiTouchRipple", [
    "root",
    "ripple",
    "rippleVisible",
    "ripplePulsate",
    "child",
    "childLeaving",
    "childPulsate",
  ]),
  dk = ["center", "classes", "className"];
let sy = (n) => n,
  nb,
  rb,
  ib,
  ob;
const _1 = 550,
  hk = 80,
  pk = Am(
    nb ||
      (nb = sy`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
  ),
  mk = Am(
    rb ||
      (rb = sy`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
  ),
  gk = Am(
    ib ||
      (ib = sy`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
  ),
  vk = en("span", { name: "MuiTouchRipple", slot: "Root" })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit",
  }),
  yk = en(fk, { name: "MuiTouchRipple", slot: "Ripple" })(
    ob ||
      (ob = sy`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
    ws.rippleVisible,
    pk,
    _1,
    ({ theme: n }) => n.transitions.easing.easeInOut,
    ws.ripplePulsate,
    ({ theme: n }) => n.transitions.duration.shorter,
    ws.child,
    ws.childLeaving,
    mk,
    _1,
    ({ theme: n }) => n.transitions.easing.easeInOut,
    ws.childPulsate,
    gk,
    ({ theme: n }) => n.transitions.easing.easeInOut
  ),
  xk = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiTouchRipple" }),
      { center: i = !1, classes: o = {}, className: s } = r,
      l = Ft(r, dk),
      [u, f] = ee.useState([]),
      h = ee.useRef(0),
      m = ee.useRef(null);
    ee.useEffect(() => {
      m.current && (m.current(), (m.current = null));
    }, [u]);
    const g = ee.useRef(!1),
      y = HC(),
      _ = ee.useRef(null),
      S = ee.useRef(null),
      x = ee.useCallback(
        (A) => {
          const {
            pulsate: R,
            rippleX: D,
            rippleY: I,
            rippleSize: U,
            cb: O,
          } = A;
          f((L) => [
            ...L,
            ve.jsx(
              yk,
              {
                classes: {
                  ripple: cn(o.ripple, ws.ripple),
                  rippleVisible: cn(o.rippleVisible, ws.rippleVisible),
                  ripplePulsate: cn(o.ripplePulsate, ws.ripplePulsate),
                  child: cn(o.child, ws.child),
                  childLeaving: cn(o.childLeaving, ws.childLeaving),
                  childPulsate: cn(o.childPulsate, ws.childPulsate),
                },
                timeout: _1,
                pulsate: R,
                rippleX: D,
                rippleY: I,
                rippleSize: U,
              },
              h.current
            ),
          ]),
            (h.current += 1),
            (m.current = O);
        },
        [o]
      ),
      w = ee.useCallback(
        (A = {}, R = {}, D = () => {}) => {
          const {
            pulsate: I = !1,
            center: U = i || R.pulsate,
            fakeElement: O = !1,
          } = R;
          if ((A == null ? void 0 : A.type) === "mousedown" && g.current) {
            g.current = !1;
            return;
          }
          (A == null ? void 0 : A.type) === "touchstart" && (g.current = !0);
          const L = O ? null : S.current,
            V = L
              ? L.getBoundingClientRect()
              : { width: 0, height: 0, left: 0, top: 0 };
          let H, $, q;
          if (
            U ||
            A === void 0 ||
            (A.clientX === 0 && A.clientY === 0) ||
            (!A.clientX && !A.touches)
          )
            (H = Math.round(V.width / 2)), ($ = Math.round(V.height / 2));
          else {
            const { clientX: K, clientY: Y } =
              A.touches && A.touches.length > 0 ? A.touches[0] : A;
            (H = Math.round(K - V.left)), ($ = Math.round(Y - V.top));
          }
          if (U)
            (q = Math.sqrt((2 * V.width ** 2 + V.height ** 2) / 3)),
              q % 2 === 0 && (q += 1);
          else {
            const K =
                Math.max(Math.abs((L ? L.clientWidth : 0) - H), H) * 2 + 2,
              Y = Math.max(Math.abs((L ? L.clientHeight : 0) - $), $) * 2 + 2;
            q = Math.sqrt(K ** 2 + Y ** 2);
          }
          A != null && A.touches
            ? _.current === null &&
              ((_.current = () => {
                x({ pulsate: I, rippleX: H, rippleY: $, rippleSize: q, cb: D });
              }),
              y.start(hk, () => {
                _.current && (_.current(), (_.current = null));
              }))
            : x({ pulsate: I, rippleX: H, rippleY: $, rippleSize: q, cb: D });
        },
        [i, x, y]
      ),
      T = ee.useCallback(() => {
        w({}, { pulsate: !0 });
      }, [w]),
      E = ee.useCallback(
        (A, R) => {
          if (
            (y.clear(),
            (A == null ? void 0 : A.type) === "touchend" && _.current)
          ) {
            _.current(),
              (_.current = null),
              y.start(0, () => {
                E(A, R);
              });
            return;
          }
          (_.current = null),
            f((D) => (D.length > 0 ? D.slice(1) : D)),
            (m.current = R);
        },
        [y]
      );
    return (
      ee.useImperativeHandle(t, () => ({ pulsate: T, start: w, stop: E }), [
        T,
        w,
        E,
      ]),
      ve.jsx(
        vk,
        pe({ className: cn(ws.root, o.root, s), ref: S }, l, {
          children: ve.jsx(gS, { component: null, exit: !0, children: u }),
        })
      )
    );
  });
function _k(n) {
  return hr("MuiButtonBase", n);
}
const Sk = Xn("MuiButtonBase", ["root", "disabled", "focusVisible"]),
  wk = [
    "action",
    "centerRipple",
    "children",
    "className",
    "component",
    "disabled",
    "disableRipple",
    "disableTouchRipple",
    "focusRipple",
    "focusVisibleClassName",
    "LinkComponent",
    "onBlur",
    "onClick",
    "onContextMenu",
    "onDragLeave",
    "onFocus",
    "onFocusVisible",
    "onKeyDown",
    "onKeyUp",
    "onMouseDown",
    "onMouseLeave",
    "onMouseUp",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "tabIndex",
    "TouchRippleProps",
    "touchRippleRef",
    "type",
  ],
  Mk = (n) => {
    const {
        disabled: e,
        focusVisible: t,
        focusVisibleClassName: r,
        classes: i,
      } = n,
      s = pr({ root: ["root", e && "disabled", t && "focusVisible"] }, _k, i);
    return t && r && (s.root += ` ${r}`), s;
  },
  bk = en("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": { borderStyle: "none" },
    [`&.${Sk.disabled}`]: { pointerEvents: "none", cursor: "default" },
    "@media print": { colorAdjust: "exact" },
  }),
  n2 = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiButtonBase" }),
      {
        action: i,
        centerRipple: o = !1,
        children: s,
        className: l,
        component: u = "button",
        disabled: f = !1,
        disableRipple: h = !1,
        disableTouchRipple: m = !1,
        focusRipple: g = !1,
        LinkComponent: y = "a",
        onBlur: _,
        onClick: S,
        onContextMenu: x,
        onDragLeave: w,
        onFocus: T,
        onFocusVisible: E,
        onKeyDown: A,
        onKeyUp: R,
        onMouseDown: D,
        onMouseLeave: I,
        onMouseUp: U,
        onTouchEnd: O,
        onTouchMove: L,
        onTouchStart: V,
        tabIndex: H = 0,
        TouchRippleProps: $,
        touchRippleRef: q,
        type: K,
      } = r,
      Y = Ft(r, wk),
      ne = ee.useRef(null),
      j = ee.useRef(null),
      re = xi(j, q),
      { isFocusVisibleRef: B, onFocus: G, onBlur: te, ref: le } = GC(),
      [J, oe] = ee.useState(!1);
    f && J && oe(!1),
      ee.useImperativeHandle(
        i,
        () => ({
          focusVisible: () => {
            oe(!0), ne.current.focus();
          },
        }),
        []
      );
    const [he, ae] = ee.useState(!1);
    ee.useEffect(() => {
      ae(!0);
    }, []);
    const ue = he && !h && !f;
    ee.useEffect(() => {
      J && g && !h && he && j.current.pulsate();
    }, [h, g, J, he]);
    function Ee(We, Ye, nt = m) {
      return $d(
        (yt) => (Ye && Ye(yt), !nt && j.current && j.current[We](yt), !0)
      );
    }
    const Ne = Ee("start", D),
      Ae = Ee("stop", x),
      W = Ee("stop", w),
      _e = Ee("stop", U),
      Te = Ee("stop", (We) => {
        J && We.preventDefault(), I && I(We);
      }),
      ke = Ee("start", V),
      Pe = Ee("stop", O),
      rt = Ee("stop", L),
      Le = Ee(
        "stop",
        (We) => {
          te(We), B.current === !1 && oe(!1), _ && _(We);
        },
        !1
      ),
      Xe = $d((We) => {
        ne.current || (ne.current = We.currentTarget),
          G(We),
          B.current === !0 && (oe(!0), E && E(We)),
          T && T(We);
      }),
      Z = () => {
        const We = ne.current;
        return u && u !== "button" && !(We.tagName === "A" && We.href);
      },
      F = ee.useRef(!1),
      me = $d((We) => {
        g &&
          !F.current &&
          J &&
          j.current &&
          We.key === " " &&
          ((F.current = !0),
          j.current.stop(We, () => {
            j.current.start(We);
          })),
          We.target === We.currentTarget &&
            Z() &&
            We.key === " " &&
            We.preventDefault(),
          A && A(We),
          We.target === We.currentTarget &&
            Z() &&
            We.key === "Enter" &&
            !f &&
            (We.preventDefault(), S && S(We));
      }),
      xe = $d((We) => {
        g &&
          We.key === " " &&
          j.current &&
          J &&
          !We.defaultPrevented &&
          ((F.current = !1),
          j.current.stop(We, () => {
            j.current.pulsate(We);
          })),
          R && R(We),
          S &&
            We.target === We.currentTarget &&
            Z() &&
            We.key === " " &&
            !We.defaultPrevented &&
            S(We);
      });
    let ye = u;
    ye === "button" && (Y.href || Y.to) && (ye = y);
    const Me = {};
    ye === "button"
      ? ((Me.type = K === void 0 ? "button" : K), (Me.disabled = f))
      : (!Y.href && !Y.to && (Me.role = "button"),
        f && (Me["aria-disabled"] = f));
    const at = xi(t, le, ne),
      Fe = pe({}, r, {
        centerRipple: o,
        component: u,
        disabled: f,
        disableRipple: h,
        disableTouchRipple: m,
        focusRipple: g,
        tabIndex: H,
        focusVisible: J,
      }),
      ze = Mk(Fe);
    return ve.jsxs(
      bk,
      pe(
        {
          as: ye,
          className: cn(ze.root, l),
          ownerState: Fe,
          onBlur: Le,
          onClick: S,
          onContextMenu: Ae,
          onFocus: Xe,
          onKeyDown: me,
          onKeyUp: xe,
          onMouseDown: Ne,
          onMouseLeave: Te,
          onMouseUp: _e,
          onDragLeave: W,
          onTouchEnd: Pe,
          onTouchMove: rt,
          onTouchStart: ke,
          ref: at,
          tabIndex: f ? -1 : H,
          type: K,
        },
        Me,
        Y,
        { children: [s, ue ? ve.jsx(xk, pe({ ref: re, center: o }, $)) : null] }
      )
    );
  });
function Ek(n) {
  return hr("MuiTypography", n);
}
Xn("MuiTypography", [
  "root",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "subtitle1",
  "subtitle2",
  "body1",
  "body2",
  "inherit",
  "button",
  "caption",
  "overline",
  "alignLeft",
  "alignRight",
  "alignCenter",
  "alignJustify",
  "noWrap",
  "gutterBottom",
  "paragraph",
]);
const Tk = [
    "align",
    "className",
    "component",
    "gutterBottom",
    "noWrap",
    "paragraph",
    "variant",
    "variantMapping",
  ],
  Ck = (n) => {
    const {
        align: e,
        gutterBottom: t,
        noWrap: r,
        paragraph: i,
        variant: o,
        classes: s,
      } = n,
      l = {
        root: [
          "root",
          o,
          n.align !== "inherit" && `align${fn(e)}`,
          t && "gutterBottom",
          r && "noWrap",
          i && "paragraph",
        ],
      };
    return pr(l, Ek, s);
  },
  Ak = en("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.variant && e[t.variant],
        t.align !== "inherit" && e[`align${fn(t.align)}`],
        t.noWrap && e.noWrap,
        t.gutterBottom && e.gutterBottom,
        t.paragraph && e.paragraph,
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    pe(
      { margin: 0 },
      e.variant === "inherit" && { font: "inherit" },
      e.variant !== "inherit" && n.typography[e.variant],
      e.align !== "inherit" && { textAlign: e.align },
      e.noWrap && {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
      },
      e.gutterBottom && { marginBottom: "0.35em" },
      e.paragraph && { marginBottom: 16 }
    )
  ),
  sb = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p",
  },
  Rk = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main",
  },
  Pk = (n) => Rk[n] || n,
  Np = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiTypography" }),
      i = Pk(r.color),
      o = ry(pe({}, r, { color: i })),
      {
        align: s = "inherit",
        className: l,
        component: u,
        gutterBottom: f = !1,
        noWrap: h = !1,
        paragraph: m = !1,
        variant: g = "body1",
        variantMapping: y = sb,
      } = o,
      _ = Ft(o, Tk),
      S = pe({}, o, {
        align: s,
        color: i,
        className: l,
        component: u,
        gutterBottom: f,
        noWrap: h,
        paragraph: m,
        variant: g,
        variantMapping: y,
      }),
      x = u || (m ? "p" : y[g] || sb[g]) || "span",
      w = Ck(S);
    return ve.jsx(
      Ak,
      pe({ as: x, ref: t, ownerState: S, className: cn(w.root, l) }, _)
    );
  });
function Ik(n) {
  return typeof n == "function" ? n() : n;
}
const Lk = ee.forwardRef(function (e, t) {
    const { children: r, container: i, disablePortal: o = !1 } = e,
      [s, l] = ee.useState(null),
      u = xi(ee.isValidElement(r) ? r.ref : null, t);
    if (
      (Fu(() => {
        o || l(Ik(i) || document.body);
      }, [i, o]),
      Fu(() => {
        if (s && !o)
          return (
            m1(t, s),
            () => {
              m1(t, null);
            }
          );
      }, [t, s, o]),
      o)
    ) {
      if (ee.isValidElement(r)) {
        const f = { ref: u };
        return ee.cloneElement(r, f);
      }
      return ve.jsx(ee.Fragment, { children: r });
    }
    return ve.jsx(ee.Fragment, { children: s && Q1.createPortal(r, s) });
  }),
  Dk = ["onChange", "maxRows", "minRows", "style", "value"];
function Vg(n) {
  return parseInt(n, 10) || 0;
}
const kk = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)",
  },
};
function Ok(n) {
  return (
    n == null ||
    Object.keys(n).length === 0 ||
    (n.outerHeightStyle === 0 && !n.overflowing)
  );
}
const Nk = ee.forwardRef(function (e, t) {
  const { onChange: r, maxRows: i, minRows: o = 1, style: s, value: l } = e,
    u = Ft(e, Dk),
    { current: f } = ee.useRef(l != null),
    h = ee.useRef(null),
    m = xi(t, h),
    g = ee.useRef(null),
    y = ee.useRef(null),
    _ = ee.useCallback(() => {
      const w = h.current,
        E = of(w).getComputedStyle(w);
      if (E.width === "0px") return { outerHeightStyle: 0, overflowing: !1 };
      const A = y.current;
      (A.style.width = E.width),
        (A.value = w.value || e.placeholder || "x"),
        A.value.slice(-1) ===
          `
` && (A.value += " ");
      const R = E.boxSizing,
        D = Vg(E.paddingBottom) + Vg(E.paddingTop),
        I = Vg(E.borderBottomWidth) + Vg(E.borderTopWidth),
        U = A.scrollHeight;
      A.value = "x";
      const O = A.scrollHeight;
      let L = U;
      o && (L = Math.max(Number(o) * O, L)),
        i && (L = Math.min(Number(i) * O, L)),
        (L = Math.max(L, O));
      const V = L + (R === "border-box" ? D + I : 0),
        H = Math.abs(L - U) <= 1;
      return { outerHeightStyle: V, overflowing: H };
    }, [i, o, e.placeholder]),
    S = ee.useCallback(() => {
      const w = _();
      if (Ok(w)) return;
      const T = w.outerHeightStyle,
        E = h.current;
      g.current !== T && ((g.current = T), (E.style.height = `${T}px`)),
        (E.style.overflow = w.overflowing ? "hidden" : "");
    }, [_]);
  Fu(() => {
    const w = () => {
      S();
    };
    let T;
    const E = VC(w),
      A = h.current,
      R = of(A);
    R.addEventListener("resize", E);
    let D;
    return (
      typeof ResizeObserver < "u" &&
        ((D = new ResizeObserver(w)), D.observe(A)),
      () => {
        E.clear(),
          cancelAnimationFrame(T),
          R.removeEventListener("resize", E),
          D && D.disconnect();
      }
    );
  }, [_, S]),
    Fu(() => {
      S();
    });
  const x = (w) => {
    f || S(), r && r(w);
  };
  return ve.jsxs(ee.Fragment, {
    children: [
      ve.jsx(
        "textarea",
        pe({ value: l, onChange: x, ref: m, rows: o, style: s }, u)
      ),
      ve.jsx("textarea", {
        "aria-hidden": !0,
        className: e.className,
        readOnly: !0,
        ref: y,
        tabIndex: -1,
        style: pe({}, kk.shadow, s, { paddingTop: 0, paddingBottom: 0 }),
      }),
    ],
  });
});
function Im({ props: n, states: e, muiFormControl: t }) {
  return e.reduce(
    (r, i) => ((r[i] = n[i]), t && typeof n[i] > "u" && (r[i] = t[i]), r),
    {}
  );
}
const vS = ee.createContext(void 0);
function Lm() {
  return ee.useContext(vS);
}
function Uk(n) {
  return ve.jsx(sL, pe({}, n, { defaultTheme: pS, themeId: j0 }));
}
function ab(n) {
  return n != null && !(Array.isArray(n) && n.length === 0);
}
function i0(n, e = !1) {
  return (
    n &&
    ((ab(n.value) && n.value !== "") ||
      (e && ab(n.defaultValue) && n.defaultValue !== ""))
  );
}
function Fk(n) {
  return n.startAdornment;
}
function zk(n) {
  return hr("MuiInputBase", n);
}
const ah = Xn("MuiInputBase", [
    "root",
    "formControl",
    "focused",
    "disabled",
    "adornedStart",
    "adornedEnd",
    "error",
    "sizeSmall",
    "multiline",
    "colorSecondary",
    "fullWidth",
    "hiddenLabel",
    "readOnly",
    "input",
    "inputSizeSmall",
    "inputMultiline",
    "inputTypeSearch",
    "inputAdornedStart",
    "inputAdornedEnd",
    "inputHiddenLabel",
  ]),
  Bk = [
    "aria-describedby",
    "autoComplete",
    "autoFocus",
    "className",
    "color",
    "components",
    "componentsProps",
    "defaultValue",
    "disabled",
    "disableInjectingGlobalStyles",
    "endAdornment",
    "error",
    "fullWidth",
    "id",
    "inputComponent",
    "inputProps",
    "inputRef",
    "margin",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onClick",
    "onFocus",
    "onKeyDown",
    "onKeyUp",
    "placeholder",
    "readOnly",
    "renderSuffix",
    "rows",
    "size",
    "slotProps",
    "slots",
    "startAdornment",
    "type",
    "value",
  ],
  ay = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.formControl && e.formControl,
      t.startAdornment && e.adornedStart,
      t.endAdornment && e.adornedEnd,
      t.error && e.error,
      t.size === "small" && e.sizeSmall,
      t.multiline && e.multiline,
      t.color && e[`color${fn(t.color)}`],
      t.fullWidth && e.fullWidth,
      t.hiddenLabel && e.hiddenLabel,
    ];
  },
  ly = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.input,
      t.size === "small" && e.inputSizeSmall,
      t.multiline && e.inputMultiline,
      t.type === "search" && e.inputTypeSearch,
      t.startAdornment && e.inputAdornedStart,
      t.endAdornment && e.inputAdornedEnd,
      t.hiddenLabel && e.inputHiddenLabel,
    ];
  },
  Vk = (n) => {
    const {
        classes: e,
        color: t,
        disabled: r,
        error: i,
        endAdornment: o,
        focused: s,
        formControl: l,
        fullWidth: u,
        hiddenLabel: f,
        multiline: h,
        readOnly: m,
        size: g,
        startAdornment: y,
        type: _,
      } = n,
      S = {
        root: [
          "root",
          `color${fn(t)}`,
          r && "disabled",
          i && "error",
          u && "fullWidth",
          s && "focused",
          l && "formControl",
          g && g !== "medium" && `size${fn(g)}`,
          h && "multiline",
          y && "adornedStart",
          o && "adornedEnd",
          f && "hiddenLabel",
          m && "readOnly",
        ],
        input: [
          "input",
          r && "disabled",
          _ === "search" && "inputTypeSearch",
          h && "inputMultiline",
          g === "small" && "inputSizeSmall",
          f && "inputHiddenLabel",
          y && "inputAdornedStart",
          o && "inputAdornedEnd",
          m && "readOnly",
        ],
      };
    return pr(S, zk, e);
  },
  uy = en("div", { name: "MuiInputBase", slot: "Root", overridesResolver: ay })(
    ({ theme: n, ownerState: e }) =>
      pe(
        {},
        n.typography.body1,
        {
          color: (n.vars || n).palette.text.primary,
          lineHeight: "1.4375em",
          boxSizing: "border-box",
          position: "relative",
          cursor: "text",
          display: "inline-flex",
          alignItems: "center",
          [`&.${ah.disabled}`]: {
            color: (n.vars || n).palette.text.disabled,
            cursor: "default",
          },
        },
        e.multiline &&
          pe({ padding: "4px 0 5px" }, e.size === "small" && { paddingTop: 1 }),
        e.fullWidth && { width: "100%" }
      )
  ),
  cy = en("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: ly,
  })(({ theme: n, ownerState: e }) => {
    const t = n.palette.mode === "light",
      r = pe(
        { color: "currentColor" },
        n.vars
          ? { opacity: n.vars.opacity.inputPlaceholder }
          : { opacity: t ? 0.42 : 0.5 },
        {
          transition: n.transitions.create("opacity", {
            duration: n.transitions.duration.shorter,
          }),
        }
      ),
      i = { opacity: "0 !important" },
      o = n.vars
        ? { opacity: n.vars.opacity.inputPlaceholder }
        : { opacity: t ? 0.42 : 0.5 };
    return pe(
      {
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": r,
        "&::-moz-placeholder": r,
        "&:-ms-input-placeholder": r,
        "&::-ms-input-placeholder": r,
        "&:focus": { outline: 0 },
        "&:invalid": { boxShadow: "none" },
        "&::-webkit-search-decoration": { WebkitAppearance: "none" },
        [`label[data-shrink=false] + .${ah.formControl} &`]: {
          "&::-webkit-input-placeholder": i,
          "&::-moz-placeholder": i,
          "&:-ms-input-placeholder": i,
          "&::-ms-input-placeholder": i,
          "&:focus::-webkit-input-placeholder": o,
          "&:focus::-moz-placeholder": o,
          "&:focus:-ms-input-placeholder": o,
          "&:focus::-ms-input-placeholder": o,
        },
        [`&.${ah.disabled}`]: {
          opacity: 1,
          WebkitTextFillColor: (n.vars || n).palette.text.disabled,
        },
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill",
        },
      },
      e.size === "small" && { paddingTop: 1 },
      e.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0,
      },
      e.type === "search" && { MozAppearance: "textfield" }
    );
  }),
  Hk = ve.jsx(Uk, {
    styles: {
      "@keyframes mui-auto-fill": { from: { display: "block" } },
      "@keyframes mui-auto-fill-cancel": { from: { display: "block" } },
    },
  }),
  yS = ee.forwardRef(function (e, t) {
    var r;
    const i = Or({ props: e, name: "MuiInputBase" }),
      {
        "aria-describedby": o,
        autoComplete: s,
        autoFocus: l,
        className: u,
        components: f = {},
        componentsProps: h = {},
        defaultValue: m,
        disabled: g,
        disableInjectingGlobalStyles: y,
        endAdornment: _,
        fullWidth: S = !1,
        id: x,
        inputComponent: w = "input",
        inputProps: T = {},
        inputRef: E,
        maxRows: A,
        minRows: R,
        multiline: D = !1,
        name: I,
        onBlur: U,
        onChange: O,
        onClick: L,
        onFocus: V,
        onKeyDown: H,
        onKeyUp: $,
        placeholder: q,
        readOnly: K,
        renderSuffix: Y,
        rows: ne,
        slotProps: j = {},
        slots: re = {},
        startAdornment: B,
        type: G = "text",
        value: te,
      } = i,
      le = Ft(i, Bk),
      J = T.value != null ? T.value : te,
      { current: oe } = ee.useRef(J != null),
      he = ee.useRef(),
      ae = ee.useCallback((ze) => {}, []),
      ue = xi(he, E, T.ref, ae),
      [Ee, Ne] = ee.useState(!1),
      Ae = Lm(),
      W = Im({
        props: i,
        muiFormControl: Ae,
        states: [
          "color",
          "disabled",
          "error",
          "hiddenLabel",
          "size",
          "required",
          "filled",
        ],
      });
    (W.focused = Ae ? Ae.focused : Ee),
      ee.useEffect(() => {
        !Ae && g && Ee && (Ne(!1), U && U());
      }, [Ae, g, Ee, U]);
    const _e = Ae && Ae.onFilled,
      Te = Ae && Ae.onEmpty,
      ke = ee.useCallback(
        (ze) => {
          i0(ze) ? _e && _e() : Te && Te();
        },
        [_e, Te]
      );
    Fu(() => {
      oe && ke({ value: J });
    }, [J, ke, oe]);
    const Pe = (ze) => {
        if (W.disabled) {
          ze.stopPropagation();
          return;
        }
        V && V(ze),
          T.onFocus && T.onFocus(ze),
          Ae && Ae.onFocus ? Ae.onFocus(ze) : Ne(!0);
      },
      rt = (ze) => {
        U && U(ze),
          T.onBlur && T.onBlur(ze),
          Ae && Ae.onBlur ? Ae.onBlur(ze) : Ne(!1);
      },
      Le = (ze, ...We) => {
        if (!oe) {
          const Ye = ze.target || he.current;
          if (Ye == null) throw new Error(Rl(1));
          ke({ value: Ye.value });
        }
        T.onChange && T.onChange(ze, ...We), O && O(ze, ...We);
      };
    ee.useEffect(() => {
      ke(he.current);
    }, []);
    const Xe = (ze) => {
      he.current && ze.currentTarget === ze.target && he.current.focus(),
        L && L(ze);
    };
    let Z = w,
      F = T;
    D &&
      Z === "input" &&
      (ne
        ? (F = pe({ type: void 0, minRows: ne, maxRows: ne }, F))
        : (F = pe({ type: void 0, maxRows: A, minRows: R }, F)),
      (Z = Nk));
    const me = (ze) => {
      ke(
        ze.animationName === "mui-auto-fill-cancel"
          ? he.current
          : { value: "x" }
      );
    };
    ee.useEffect(() => {
      Ae && Ae.setAdornedStart(!!B);
    }, [Ae, B]);
    const xe = pe({}, i, {
        color: W.color || "primary",
        disabled: W.disabled,
        endAdornment: _,
        error: W.error,
        focused: W.focused,
        formControl: Ae,
        fullWidth: S,
        hiddenLabel: W.hiddenLabel,
        multiline: D,
        size: W.size,
        startAdornment: B,
        type: G,
      }),
      ye = Vk(xe),
      Me = re.root || f.Root || uy,
      at = j.root || h.root || {},
      Fe = re.input || f.Input || cy;
    return (
      (F = pe({}, F, (r = j.input) != null ? r : h.input)),
      ve.jsxs(ee.Fragment, {
        children: [
          !y && Hk,
          ve.jsxs(
            Me,
            pe(
              {},
              at,
              !e0(Me) && { ownerState: pe({}, xe, at.ownerState) },
              { ref: t, onClick: Xe },
              le,
              {
                className: cn(
                  ye.root,
                  at.className,
                  u,
                  K && "MuiInputBase-readOnly"
                ),
                children: [
                  B,
                  ve.jsx(vS.Provider, {
                    value: null,
                    children: ve.jsx(
                      Fe,
                      pe(
                        {
                          ownerState: xe,
                          "aria-invalid": W.error,
                          "aria-describedby": o,
                          autoComplete: s,
                          autoFocus: l,
                          defaultValue: m,
                          disabled: W.disabled,
                          id: x,
                          onAnimationStart: me,
                          name: I,
                          placeholder: q,
                          readOnly: K,
                          required: W.required,
                          rows: ne,
                          value: J,
                          onKeyDown: H,
                          onKeyUp: $,
                          type: G,
                        },
                        F,
                        !e0(Fe) && {
                          as: Z,
                          ownerState: pe({}, xe, F.ownerState),
                        },
                        {
                          ref: ue,
                          className: cn(
                            ye.input,
                            F.className,
                            K && "MuiInputBase-readOnly"
                          ),
                          onBlur: rt,
                          onChange: Le,
                          onFocus: Pe,
                        }
                      )
                    ),
                  }),
                  _,
                  Y ? Y(pe({}, W, { startAdornment: B })) : null,
                ],
              }
            )
          ),
        ],
      })
    );
  });
function Gk(n) {
  return hr("MuiInput", n);
}
const up = pe({}, ah, Xn("MuiInput", ["root", "underline", "input"]));
function Wk(n) {
  return hr("MuiOutlinedInput", n);
}
const Su = pe(
  {},
  ah,
  Xn("MuiOutlinedInput", ["root", "notchedOutline", "input"])
);
function jk(n) {
  return hr("MuiFilledInput", n);
}
const bc = pe({}, ah, Xn("MuiFilledInput", ["root", "underline", "input"])),
  $k = QC(ve.jsx("path", { d: "M7 10l5 5 5-5z" }), "ArrowDropDown"),
  Xk = [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    "TransitionComponent",
  ],
  Yk = { entering: { opacity: 1 }, entered: { opacity: 1 } },
  qk = ee.forwardRef(function (e, t) {
    const r = ZC(),
      i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen,
      },
      {
        addEndListener: o,
        appear: s = !0,
        children: l,
        easing: u,
        in: f,
        onEnter: h,
        onEntered: m,
        onEntering: g,
        onExit: y,
        onExited: _,
        onExiting: S,
        style: x,
        timeout: w = i,
        TransitionComponent: T = Wa,
      } = e,
      E = Ft(e, Xk),
      A = ee.useRef(null),
      R = xi(A, l.ref, t),
      D = (q) => (K) => {
        if (q) {
          const Y = A.current;
          K === void 0 ? q(Y) : q(Y, K);
        }
      },
      I = D(g),
      U = D((q, K) => {
        t2(q);
        const Y = r0({ style: x, timeout: w, easing: u }, { mode: "enter" });
        (q.style.webkitTransition = r.transitions.create("opacity", Y)),
          (q.style.transition = r.transitions.create("opacity", Y)),
          h && h(q, K);
      }),
      O = D(m),
      L = D(S),
      V = D((q) => {
        const K = r0({ style: x, timeout: w, easing: u }, { mode: "exit" });
        (q.style.webkitTransition = r.transitions.create("opacity", K)),
          (q.style.transition = r.transitions.create("opacity", K)),
          y && y(q);
      }),
      H = D(_),
      $ = (q) => {
        o && o(A.current, q);
      };
    return ve.jsx(
      T,
      pe(
        {
          appear: s,
          in: f,
          nodeRef: A,
          onEnter: U,
          onEntered: O,
          onEntering: I,
          onExit: V,
          onExited: H,
          onExiting: L,
          addEndListener: $,
          timeout: w,
        },
        E,
        {
          children: (q, K) =>
            ee.cloneElement(
              l,
              pe(
                {
                  style: pe(
                    {
                      opacity: 0,
                      visibility: q === "exited" && !f ? "hidden" : void 0,
                    },
                    Yk[q],
                    x,
                    l.props.style
                  ),
                  ref: R,
                },
                K
              )
            ),
        }
      )
    );
  });
function Kk(n) {
  return hr("MuiBackdrop", n);
}
Xn("MuiBackdrop", ["root", "invisible"]);
const Zk = [
    "children",
    "className",
    "component",
    "components",
    "componentsProps",
    "invisible",
    "open",
    "slotProps",
    "slots",
    "TransitionComponent",
    "transitionDuration",
  ],
  Jk = (n) => {
    const { classes: e, invisible: t } = n;
    return pr({ root: ["root", t && "invisible"] }, Kk, e);
  },
  Qk = en("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, t.invisible && e.invisible];
    },
  })(({ ownerState: n }) =>
    pe(
      {
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        WebkitTapHighlightColor: "transparent",
      },
      n.invisible && { backgroundColor: "transparent" }
    )
  ),
  eO = ee.forwardRef(function (e, t) {
    var r, i, o;
    const s = Or({ props: e, name: "MuiBackdrop" }),
      {
        children: l,
        className: u,
        component: f = "div",
        components: h = {},
        componentsProps: m = {},
        invisible: g = !1,
        open: y,
        slotProps: _ = {},
        slots: S = {},
        TransitionComponent: x = qk,
        transitionDuration: w,
      } = s,
      T = Ft(s, Zk),
      E = pe({}, s, { component: f, invisible: g }),
      A = Jk(E),
      R = (r = _.root) != null ? r : m.root;
    return ve.jsx(
      x,
      pe({ in: y, timeout: w }, T, {
        children: ve.jsx(
          Qk,
          pe({ "aria-hidden": !0 }, R, {
            as: (i = (o = S.root) != null ? o : h.Root) != null ? i : f,
            className: cn(A.root, u, R == null ? void 0 : R.className),
            ownerState: pe({}, E, R == null ? void 0 : R.ownerState),
            classes: A,
            ref: t,
            children: l,
          })
        ),
      })
    );
  }),
  tO = Xn("MuiBox", ["root"]),
  nO = KC(),
  Qr = dL({
    themeId: j0,
    defaultTheme: nO,
    defaultClassName: tO.root,
    generateClassName: kC.generate,
  });
function rO(n) {
  return hr("MuiButton", n);
}
const Hg = Xn("MuiButton", [
    "root",
    "text",
    "textInherit",
    "textPrimary",
    "textSecondary",
    "textSuccess",
    "textError",
    "textInfo",
    "textWarning",
    "outlined",
    "outlinedInherit",
    "outlinedPrimary",
    "outlinedSecondary",
    "outlinedSuccess",
    "outlinedError",
    "outlinedInfo",
    "outlinedWarning",
    "contained",
    "containedInherit",
    "containedPrimary",
    "containedSecondary",
    "containedSuccess",
    "containedError",
    "containedInfo",
    "containedWarning",
    "disableElevation",
    "focusVisible",
    "disabled",
    "colorInherit",
    "colorPrimary",
    "colorSecondary",
    "colorSuccess",
    "colorError",
    "colorInfo",
    "colorWarning",
    "textSizeSmall",
    "textSizeMedium",
    "textSizeLarge",
    "outlinedSizeSmall",
    "outlinedSizeMedium",
    "outlinedSizeLarge",
    "containedSizeSmall",
    "containedSizeMedium",
    "containedSizeLarge",
    "sizeMedium",
    "sizeSmall",
    "sizeLarge",
    "fullWidth",
    "startIcon",
    "endIcon",
    "icon",
    "iconSizeSmall",
    "iconSizeMedium",
    "iconSizeLarge",
  ]),
  iO = ee.createContext({}),
  oO = ee.createContext(void 0),
  sO = [
    "children",
    "color",
    "component",
    "className",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "endIcon",
    "focusVisibleClassName",
    "fullWidth",
    "size",
    "startIcon",
    "type",
    "variant",
  ],
  aO = (n) => {
    const {
        color: e,
        disableElevation: t,
        fullWidth: r,
        size: i,
        variant: o,
        classes: s,
      } = n,
      l = {
        root: [
          "root",
          o,
          `${o}${fn(e)}`,
          `size${fn(i)}`,
          `${o}Size${fn(i)}`,
          `color${fn(e)}`,
          t && "disableElevation",
          r && "fullWidth",
        ],
        label: ["label"],
        startIcon: ["icon", "startIcon", `iconSize${fn(i)}`],
        endIcon: ["icon", "endIcon", `iconSize${fn(i)}`],
      },
      u = pr(l, rO, s);
    return pe({}, s, u);
  },
  r2 = (n) =>
    pe(
      {},
      n.size === "small" && { "& > *:nth-of-type(1)": { fontSize: 18 } },
      n.size === "medium" && { "& > *:nth-of-type(1)": { fontSize: 20 } },
      n.size === "large" && { "& > *:nth-of-type(1)": { fontSize: 22 } }
    ),
  lO = en(n2, {
    shouldForwardProp: (n) => Rs(n) || n === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        e[t.variant],
        e[`${t.variant}${fn(t.color)}`],
        e[`size${fn(t.size)}`],
        e[`${t.variant}Size${fn(t.size)}`],
        t.color === "inherit" && e.colorInherit,
        t.disableElevation && e.disableElevation,
        t.fullWidth && e.fullWidth,
      ];
    },
  })(
    ({ theme: n, ownerState: e }) => {
      var t, r;
      const i =
          n.palette.mode === "light"
            ? n.palette.grey[300]
            : n.palette.grey[800],
        o =
          n.palette.mode === "light"
            ? n.palette.grey.A100
            : n.palette.grey[700];
      return pe(
        {},
        n.typography.button,
        {
          minWidth: 64,
          padding: "6px 16px",
          borderRadius: (n.vars || n).shape.borderRadius,
          transition: n.transitions.create(
            ["background-color", "box-shadow", "border-color", "color"],
            { duration: n.transitions.duration.short }
          ),
          "&:hover": pe(
            {
              textDecoration: "none",
              backgroundColor: n.vars
                ? `rgba(${n.vars.palette.text.primaryChannel} / ${n.vars.palette.action.hoverOpacity})`
                : ts.alpha(
                    n.palette.text.primary,
                    n.palette.action.hoverOpacity
                  ),
              "@media (hover: none)": { backgroundColor: "transparent" },
            },
            e.variant === "text" &&
              e.color !== "inherit" && {
                backgroundColor: n.vars
                  ? `rgba(${n.vars.palette[e.color].mainChannel} / ${
                      n.vars.palette.action.hoverOpacity
                    })`
                  : ts.alpha(
                      n.palette[e.color].main,
                      n.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            e.variant === "outlined" &&
              e.color !== "inherit" && {
                border: `1px solid ${(n.vars || n).palette[e.color].main}`,
                backgroundColor: n.vars
                  ? `rgba(${n.vars.palette[e.color].mainChannel} / ${
                      n.vars.palette.action.hoverOpacity
                    })`
                  : ts.alpha(
                      n.palette[e.color].main,
                      n.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            e.variant === "contained" && {
              backgroundColor: n.vars
                ? n.vars.palette.Button.inheritContainedHoverBg
                : o,
              boxShadow: (n.vars || n).shadows[4],
              "@media (hover: none)": {
                boxShadow: (n.vars || n).shadows[2],
                backgroundColor: (n.vars || n).palette.grey[300],
              },
            },
            e.variant === "contained" &&
              e.color !== "inherit" && {
                backgroundColor: (n.vars || n).palette[e.color].dark,
                "@media (hover: none)": {
                  backgroundColor: (n.vars || n).palette[e.color].main,
                },
              }
          ),
          "&:active": pe(
            {},
            e.variant === "contained" && { boxShadow: (n.vars || n).shadows[8] }
          ),
          [`&.${Hg.focusVisible}`]: pe(
            {},
            e.variant === "contained" && { boxShadow: (n.vars || n).shadows[6] }
          ),
          [`&.${Hg.disabled}`]: pe(
            { color: (n.vars || n).palette.action.disabled },
            e.variant === "outlined" && {
              border: `1px solid ${
                (n.vars || n).palette.action.disabledBackground
              }`,
            },
            e.variant === "contained" && {
              color: (n.vars || n).palette.action.disabled,
              boxShadow: (n.vars || n).shadows[0],
              backgroundColor: (n.vars || n).palette.action.disabledBackground,
            }
          ),
        },
        e.variant === "text" && { padding: "6px 8px" },
        e.variant === "text" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].main,
          },
        e.variant === "outlined" && {
          padding: "5px 15px",
          border: "1px solid currentColor",
        },
        e.variant === "outlined" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].main,
            border: n.vars
              ? `1px solid rgba(${n.vars.palette[e.color].mainChannel} / 0.5)`
              : `1px solid ${ts.alpha(n.palette[e.color].main, 0.5)}`,
          },
        e.variant === "contained" && {
          color: n.vars
            ? n.vars.palette.text.primary
            : (t = (r = n.palette).getContrastText) == null
            ? void 0
            : t.call(r, n.palette.grey[300]),
          backgroundColor: n.vars
            ? n.vars.palette.Button.inheritContainedBg
            : i,
          boxShadow: (n.vars || n).shadows[2],
        },
        e.variant === "contained" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].contrastText,
            backgroundColor: (n.vars || n).palette[e.color].main,
          },
        e.color === "inherit" && {
          color: "inherit",
          borderColor: "currentColor",
        },
        e.size === "small" &&
          e.variant === "text" && {
            padding: "4px 5px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "text" && {
            padding: "8px 11px",
            fontSize: n.typography.pxToRem(15),
          },
        e.size === "small" &&
          e.variant === "outlined" && {
            padding: "3px 9px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "outlined" && {
            padding: "7px 21px",
            fontSize: n.typography.pxToRem(15),
          },
        e.size === "small" &&
          e.variant === "contained" && {
            padding: "4px 10px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "contained" && {
            padding: "8px 22px",
            fontSize: n.typography.pxToRem(15),
          },
        e.fullWidth && { width: "100%" }
      );
    },
    ({ ownerState: n }) =>
      n.disableElevation && {
        boxShadow: "none",
        "&:hover": { boxShadow: "none" },
        [`&.${Hg.focusVisible}`]: { boxShadow: "none" },
        "&:active": { boxShadow: "none" },
        [`&.${Hg.disabled}`]: { boxShadow: "none" },
      }
  ),
  uO = en("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.startIcon, e[`iconSize${fn(t.size)}`]];
    },
  })(({ ownerState: n }) =>
    pe(
      { display: "inherit", marginRight: 8, marginLeft: -4 },
      n.size === "small" && { marginLeft: -2 },
      r2(n)
    )
  ),
  cO = en("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.endIcon, e[`iconSize${fn(t.size)}`]];
    },
  })(({ ownerState: n }) =>
    pe(
      { display: "inherit", marginRight: -4, marginLeft: 8 },
      n.size === "small" && { marginRight: -2 },
      r2(n)
    )
  ),
  lb = ee.forwardRef(function (e, t) {
    const r = ee.useContext(iO),
      i = ee.useContext(oO),
      o = tm(r, e),
      s = Or({ props: o, name: "MuiButton" }),
      {
        children: l,
        color: u = "primary",
        component: f = "button",
        className: h,
        disabled: m = !1,
        disableElevation: g = !1,
        disableFocusRipple: y = !1,
        endIcon: _,
        focusVisibleClassName: S,
        fullWidth: x = !1,
        size: w = "medium",
        startIcon: T,
        type: E,
        variant: A = "text",
      } = s,
      R = Ft(s, sO),
      D = pe({}, s, {
        color: u,
        component: f,
        disabled: m,
        disableElevation: g,
        disableFocusRipple: y,
        fullWidth: x,
        size: w,
        type: E,
        variant: A,
      }),
      I = aO(D),
      U =
        T && ve.jsx(uO, { className: I.startIcon, ownerState: D, children: T }),
      O = _ && ve.jsx(cO, { className: I.endIcon, ownerState: D, children: _ }),
      L = i || "";
    return ve.jsxs(
      lO,
      pe(
        {
          ownerState: D,
          className: cn(r.className, I.root, h, L),
          component: f,
          disabled: m,
          focusRipple: !y,
          focusVisibleClassName: cn(I.focusVisible, S),
          ref: t,
          type: E,
        },
        R,
        { classes: I, children: [U, l, O] }
      )
    );
  });
function fO(n) {
  const e = rs(n);
  return e.body === n
    ? of(n).innerWidth > e.documentElement.clientWidth
    : n.scrollHeight > n.clientHeight;
}
function Up(n, e) {
  e ? n.setAttribute("aria-hidden", "true") : n.removeAttribute("aria-hidden");
}
function ub(n) {
  return parseInt(of(n).getComputedStyle(n).paddingRight, 10) || 0;
}
function dO(n) {
  const t =
      [
        "TEMPLATE",
        "SCRIPT",
        "STYLE",
        "LINK",
        "MAP",
        "META",
        "NOSCRIPT",
        "PICTURE",
        "COL",
        "COLGROUP",
        "PARAM",
        "SLOT",
        "SOURCE",
        "TRACK",
      ].indexOf(n.tagName) !== -1,
    r = n.tagName === "INPUT" && n.getAttribute("type") === "hidden";
  return t || r;
}
function cb(n, e, t, r, i) {
  const o = [e, t, ...r];
  [].forEach.call(n.children, (s) => {
    const l = o.indexOf(s) === -1,
      u = !dO(s);
    l && u && Up(s, i);
  });
}
function jx(n, e) {
  let t = -1;
  return n.some((r, i) => (e(r) ? ((t = i), !0) : !1)), t;
}
function hO(n, e) {
  const t = [],
    r = n.container;
  if (!e.disableScrollLock) {
    if (fO(r)) {
      const s = WC(rs(r));
      t.push({ value: r.style.paddingRight, property: "padding-right", el: r }),
        (r.style.paddingRight = `${ub(r) + s}px`);
      const l = rs(r).querySelectorAll(".mui-fixed");
      [].forEach.call(l, (u) => {
        t.push({
          value: u.style.paddingRight,
          property: "padding-right",
          el: u,
        }),
          (u.style.paddingRight = `${ub(u) + s}px`);
      });
    }
    let o;
    if (r.parentNode instanceof DocumentFragment) o = rs(r).body;
    else {
      const s = r.parentElement,
        l = of(r);
      o =
        (s == null ? void 0 : s.nodeName) === "HTML" &&
        l.getComputedStyle(s).overflowY === "scroll"
          ? s
          : r;
    }
    t.push(
      { value: o.style.overflow, property: "overflow", el: o },
      { value: o.style.overflowX, property: "overflow-x", el: o },
      { value: o.style.overflowY, property: "overflow-y", el: o }
    ),
      (o.style.overflow = "hidden");
  }
  return () => {
    t.forEach(({ value: o, el: s, property: l }) => {
      o ? s.style.setProperty(l, o) : s.style.removeProperty(l);
    });
  };
}
function pO(n) {
  const e = [];
  return (
    [].forEach.call(n.children, (t) => {
      t.getAttribute("aria-hidden") === "true" && e.push(t);
    }),
    e
  );
}
class mO {
  constructor() {
    (this.containers = void 0),
      (this.modals = void 0),
      (this.modals = []),
      (this.containers = []);
  }
  add(e, t) {
    let r = this.modals.indexOf(e);
    if (r !== -1) return r;
    (r = this.modals.length),
      this.modals.push(e),
      e.modalRef && Up(e.modalRef, !1);
    const i = pO(t);
    cb(t, e.mount, e.modalRef, i, !0);
    const o = jx(this.containers, (s) => s.container === t);
    return o !== -1
      ? (this.containers[o].modals.push(e), r)
      : (this.containers.push({
          modals: [e],
          container: t,
          restore: null,
          hiddenSiblings: i,
        }),
        r);
  }
  mount(e, t) {
    const r = jx(this.containers, (o) => o.modals.indexOf(e) !== -1),
      i = this.containers[r];
    i.restore || (i.restore = hO(i, t));
  }
  remove(e, t = !0) {
    const r = this.modals.indexOf(e);
    if (r === -1) return r;
    const i = jx(this.containers, (s) => s.modals.indexOf(e) !== -1),
      o = this.containers[i];
    if (
      (o.modals.splice(o.modals.indexOf(e), 1),
      this.modals.splice(r, 1),
      o.modals.length === 0)
    )
      o.restore && o.restore(),
        e.modalRef && Up(e.modalRef, t),
        cb(o.container, e.mount, e.modalRef, o.hiddenSiblings, !1),
        this.containers.splice(i, 1);
    else {
      const s = o.modals[o.modals.length - 1];
      s.modalRef && Up(s.modalRef, !1);
    }
    return r;
  }
  isTopModal(e) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === e;
  }
}
const gO = [
  "input",
  "select",
  "textarea",
  "a[href]",
  "button",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable="false"])',
].join(",");
function vO(n) {
  const e = parseInt(n.getAttribute("tabindex") || "", 10);
  return Number.isNaN(e)
    ? n.contentEditable === "true" ||
      ((n.nodeName === "AUDIO" ||
        n.nodeName === "VIDEO" ||
        n.nodeName === "DETAILS") &&
        n.getAttribute("tabindex") === null)
      ? 0
      : n.tabIndex
    : e;
}
function yO(n) {
  if (n.tagName !== "INPUT" || n.type !== "radio" || !n.name) return !1;
  const e = (r) => n.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let t = e(`[name="${n.name}"]:checked`);
  return t || (t = e(`[name="${n.name}"]`)), t !== n;
}
function xO(n) {
  return !(
    n.disabled ||
    (n.tagName === "INPUT" && n.type === "hidden") ||
    yO(n)
  );
}
function _O(n) {
  const e = [],
    t = [];
  return (
    Array.from(n.querySelectorAll(gO)).forEach((r, i) => {
      const o = vO(r);
      o === -1 ||
        !xO(r) ||
        (o === 0
          ? e.push(r)
          : t.push({ documentOrder: i, tabIndex: o, node: r }));
    }),
    t
      .sort((r, i) =>
        r.tabIndex === i.tabIndex
          ? r.documentOrder - i.documentOrder
          : r.tabIndex - i.tabIndex
      )
      .map((r) => r.node)
      .concat(e)
  );
}
function SO() {
  return !0;
}
function wO(n) {
  const {
      children: e,
      disableAutoFocus: t = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: i = !1,
      getTabbable: o = _O,
      isEnabled: s = SO,
      open: l,
    } = n,
    u = ee.useRef(!1),
    f = ee.useRef(null),
    h = ee.useRef(null),
    m = ee.useRef(null),
    g = ee.useRef(null),
    y = ee.useRef(!1),
    _ = ee.useRef(null),
    S = xi(e.ref, _),
    x = ee.useRef(null);
  ee.useEffect(() => {
    !l || !_.current || (y.current = !t);
  }, [t, l]),
    ee.useEffect(() => {
      if (!l || !_.current) return;
      const E = rs(_.current);
      return (
        _.current.contains(E.activeElement) ||
          (_.current.hasAttribute("tabIndex") ||
            _.current.setAttribute("tabIndex", "-1"),
          y.current && _.current.focus()),
        () => {
          i ||
            (m.current &&
              m.current.focus &&
              ((u.current = !0), m.current.focus()),
            (m.current = null));
        }
      );
    }, [l]),
    ee.useEffect(() => {
      if (!l || !_.current) return;
      const E = rs(_.current),
        A = (I) => {
          (x.current = I),
            !(r || !s() || I.key !== "Tab") &&
              E.activeElement === _.current &&
              I.shiftKey &&
              ((u.current = !0), h.current && h.current.focus());
        },
        R = () => {
          const I = _.current;
          if (I === null) return;
          if (!E.hasFocus() || !s() || u.current) {
            u.current = !1;
            return;
          }
          if (
            I.contains(E.activeElement) ||
            (r &&
              E.activeElement !== f.current &&
              E.activeElement !== h.current)
          )
            return;
          if (E.activeElement !== g.current) g.current = null;
          else if (g.current !== null) return;
          if (!y.current) return;
          let U = [];
          if (
            ((E.activeElement === f.current || E.activeElement === h.current) &&
              (U = o(_.current)),
            U.length > 0)
          ) {
            var O, L;
            const V = !!(
                (O = x.current) != null &&
                O.shiftKey &&
                ((L = x.current) == null ? void 0 : L.key) === "Tab"
              ),
              H = U[0],
              $ = U[U.length - 1];
            typeof H != "string" &&
              typeof $ != "string" &&
              (V ? $.focus() : H.focus());
          } else I.focus();
        };
      E.addEventListener("focusin", R), E.addEventListener("keydown", A, !0);
      const D = setInterval(() => {
        E.activeElement && E.activeElement.tagName === "BODY" && R();
      }, 50);
      return () => {
        clearInterval(D),
          E.removeEventListener("focusin", R),
          E.removeEventListener("keydown", A, !0);
      };
    }, [t, r, i, s, l, o]);
  const w = (E) => {
      m.current === null && (m.current = E.relatedTarget),
        (y.current = !0),
        (g.current = E.target);
      const A = e.props.onFocus;
      A && A(E);
    },
    T = (E) => {
      m.current === null && (m.current = E.relatedTarget), (y.current = !0);
    };
  return ve.jsxs(ee.Fragment, {
    children: [
      ve.jsx("div", {
        tabIndex: l ? 0 : -1,
        onFocus: T,
        ref: f,
        "data-testid": "sentinelStart",
      }),
      ee.cloneElement(e, { ref: S, onFocus: w }),
      ve.jsx("div", {
        tabIndex: l ? 0 : -1,
        onFocus: T,
        ref: h,
        "data-testid": "sentinelEnd",
      }),
    ],
  });
}
function MO(n) {
  return typeof n == "function" ? n() : n;
}
function bO(n) {
  return n ? n.props.hasOwnProperty("in") : !1;
}
const EO = new mO();
function TO(n) {
  const {
      container: e,
      disableEscapeKeyDown: t = !1,
      disableScrollLock: r = !1,
      manager: i = EO,
      closeAfterTransition: o = !1,
      onTransitionEnter: s,
      onTransitionExited: l,
      children: u,
      onClose: f,
      open: h,
      rootRef: m,
    } = n,
    g = ee.useRef({}),
    y = ee.useRef(null),
    _ = ee.useRef(null),
    S = xi(_, m),
    [x, w] = ee.useState(!h),
    T = bO(u);
  let E = !0;
  (n["aria-hidden"] === "false" || n["aria-hidden"] === !1) && (E = !1);
  const A = () => rs(y.current),
    R = () => (
      (g.current.modalRef = _.current), (g.current.mount = y.current), g.current
    ),
    D = () => {
      i.mount(R(), { disableScrollLock: r }),
        _.current && (_.current.scrollTop = 0);
    },
    I = $d(() => {
      const Y = MO(e) || A().body;
      i.add(R(), Y), _.current && D();
    }),
    U = ee.useCallback(() => i.isTopModal(R()), [i]),
    O = $d((Y) => {
      (y.current = Y), Y && (h && U() ? D() : _.current && Up(_.current, E));
    }),
    L = ee.useCallback(() => {
      i.remove(R(), E);
    }, [E, i]);
  ee.useEffect(
    () => () => {
      L();
    },
    [L]
  ),
    ee.useEffect(() => {
      h ? I() : (!T || !o) && L();
    }, [h, L, T, o, I]);
  const V = (Y) => (ne) => {
      var j;
      (j = Y.onKeyDown) == null || j.call(Y, ne),
        !(ne.key !== "Escape" || ne.which === 229 || !U()) &&
          (t || (ne.stopPropagation(), f && f(ne, "escapeKeyDown")));
    },
    H = (Y) => (ne) => {
      var j;
      (j = Y.onClick) == null || j.call(Y, ne),
        ne.target === ne.currentTarget && f && f(ne, "backdropClick");
    };
  return {
    getRootProps: (Y = {}) => {
      const ne = t0(n);
      delete ne.onTransitionEnter, delete ne.onTransitionExited;
      const j = pe({}, ne, Y);
      return pe({ role: "presentation" }, j, { onKeyDown: V(j), ref: S });
    },
    getBackdropProps: (Y = {}) => {
      const ne = Y;
      return pe({ "aria-hidden": !0 }, ne, { onClick: H(ne), open: h });
    },
    getTransitionProps: () => {
      const Y = () => {
          w(!1), s && s();
        },
        ne = () => {
          w(!0), l && l(), o && L();
        };
      return {
        onEnter: OM(Y, u == null ? void 0 : u.props.onEnter),
        onExited: OM(ne, u == null ? void 0 : u.props.onExited),
      };
    },
    rootRef: S,
    portalRef: O,
    isTopModal: U,
    exited: x,
    hasTransition: T,
  };
}
function CO(n) {
  return hr("MuiModal", n);
}
Xn("MuiModal", ["root", "hidden", "backdrop"]);
const AO = [
    "BackdropComponent",
    "BackdropProps",
    "classes",
    "className",
    "closeAfterTransition",
    "children",
    "container",
    "component",
    "components",
    "componentsProps",
    "disableAutoFocus",
    "disableEnforceFocus",
    "disableEscapeKeyDown",
    "disablePortal",
    "disableRestoreFocus",
    "disableScrollLock",
    "hideBackdrop",
    "keepMounted",
    "onBackdropClick",
    "onClose",
    "onTransitionEnter",
    "onTransitionExited",
    "open",
    "slotProps",
    "slots",
    "theme",
  ],
  RO = (n) => {
    const { open: e, exited: t, classes: r } = n;
    return pr(
      { root: ["root", !e && t && "hidden"], backdrop: ["backdrop"] },
      CO,
      r
    );
  },
  PO = en("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, !t.open && t.exited && e.hidden];
    },
  })(({ theme: n, ownerState: e }) =>
    pe(
      {
        position: "fixed",
        zIndex: (n.vars || n).zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
      },
      !e.open && e.exited && { visibility: "hidden" }
    )
  ),
  IO = en(eO, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (n, e) => e.backdrop,
  })({ zIndex: -1 }),
  LO = ee.forwardRef(function (e, t) {
    var r, i, o, s, l, u;
    const f = Or({ name: "MuiModal", props: e }),
      {
        BackdropComponent: h = IO,
        BackdropProps: m,
        className: g,
        closeAfterTransition: y = !1,
        children: _,
        container: S,
        component: x,
        components: w = {},
        componentsProps: T = {},
        disableAutoFocus: E = !1,
        disableEnforceFocus: A = !1,
        disableEscapeKeyDown: R = !1,
        disablePortal: D = !1,
        disableRestoreFocus: I = !1,
        disableScrollLock: U = !1,
        hideBackdrop: O = !1,
        keepMounted: L = !1,
        onBackdropClick: V,
        open: H,
        slotProps: $,
        slots: q,
      } = f,
      K = Ft(f, AO),
      Y = pe({}, f, {
        closeAfterTransition: y,
        disableAutoFocus: E,
        disableEnforceFocus: A,
        disableEscapeKeyDown: R,
        disablePortal: D,
        disableRestoreFocus: I,
        disableScrollLock: U,
        hideBackdrop: O,
        keepMounted: L,
      }),
      {
        getRootProps: ne,
        getBackdropProps: j,
        getTransitionProps: re,
        portalRef: B,
        isTopModal: G,
        exited: te,
        hasTransition: le,
      } = TO(pe({}, Y, { rootRef: t })),
      J = pe({}, Y, { exited: te }),
      oe = RO(J),
      he = {};
    if ((_.props.tabIndex === void 0 && (he.tabIndex = "-1"), le)) {
      const { onEnter: _e, onExited: Te } = re();
      (he.onEnter = _e), (he.onExited = Te);
    }
    const ae =
        (r = (i = q == null ? void 0 : q.root) != null ? i : w.Root) != null
          ? r
          : PO,
      ue =
        (o = (s = q == null ? void 0 : q.backdrop) != null ? s : w.Backdrop) !=
        null
          ? o
          : h,
      Ee = (l = $ == null ? void 0 : $.root) != null ? l : T.root,
      Ne = (u = $ == null ? void 0 : $.backdrop) != null ? u : T.backdrop,
      Ae = sh({
        elementType: ae,
        externalSlotProps: Ee,
        externalForwardedProps: K,
        getSlotProps: ne,
        additionalProps: { ref: t, as: x },
        ownerState: J,
        className: cn(
          g,
          Ee == null ? void 0 : Ee.className,
          oe == null ? void 0 : oe.root,
          !J.open && J.exited && (oe == null ? void 0 : oe.hidden)
        ),
      }),
      W = sh({
        elementType: ue,
        externalSlotProps: Ne,
        additionalProps: m,
        getSlotProps: (_e) =>
          j(
            pe({}, _e, {
              onClick: (Te) => {
                V && V(Te), _e != null && _e.onClick && _e.onClick(Te);
              },
            })
          ),
        className: cn(
          Ne == null ? void 0 : Ne.className,
          m == null ? void 0 : m.className,
          oe == null ? void 0 : oe.backdrop
        ),
        ownerState: J,
      });
    return !L && !H && (!le || te)
      ? null
      : ve.jsx(Lk, {
          ref: B,
          container: S,
          disablePortal: D,
          children: ve.jsxs(
            ae,
            pe({}, Ae, {
              children: [
                !O && h ? ve.jsx(ue, pe({}, W)) : null,
                ve.jsx(wO, {
                  disableEnforceFocus: A,
                  disableAutoFocus: E,
                  disableRestoreFocus: I,
                  isEnabled: G,
                  open: H,
                  children: ee.cloneElement(_, he),
                }),
              ],
            })
          ),
        });
  }),
  fb = Xn("MuiDivider", [
    "root",
    "absolute",
    "fullWidth",
    "inset",
    "middle",
    "flexItem",
    "light",
    "vertical",
    "withChildren",
    "withChildrenVertical",
    "textAlignRight",
    "textAlignLeft",
    "wrapper",
    "wrapperVertical",
  ]),
  DO = [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "hiddenLabel",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type",
  ],
  kO = (n) => {
    const { classes: e, disableUnderline: t } = n,
      i = pr({ root: ["root", !t && "underline"], input: ["input"] }, jk, e);
    return pe({}, e, i);
  },
  OO = en(uy, {
    shouldForwardProp: (n) => Rs(n) || n === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [...ay(n, e), !t.disableUnderline && e.underline];
    },
  })(({ theme: n, ownerState: e }) => {
    var t;
    const r = n.palette.mode === "light",
      i = r ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
      o = r ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
      s = r ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
      l = r ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return pe(
      {
        position: "relative",
        backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
        borderTopLeftRadius: (n.vars || n).shape.borderRadius,
        borderTopRightRadius: (n.vars || n).shape.borderRadius,
        transition: n.transitions.create("background-color", {
          duration: n.transitions.duration.shorter,
          easing: n.transitions.easing.easeOut,
        }),
        "&:hover": {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.hoverBg : s,
          "@media (hover: none)": {
            backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
          },
        },
        [`&.${bc.focused}`]: {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
        },
        [`&.${bc.disabled}`]: {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.disabledBg : l,
        },
      },
      !e.disableUnderline && {
        "&::after": {
          borderBottom: `2px solid ${
            (t = (n.vars || n).palette[e.color || "primary"]) == null
              ? void 0
              : t.main
          }`,
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: n.transitions.create("transform", {
            duration: n.transitions.duration.shorter,
            easing: n.transitions.easing.easeOut,
          }),
          pointerEvents: "none",
        },
        [`&.${bc.focused}:after`]: { transform: "scaleX(1) translateX(0)" },
        [`&.${bc.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (n.vars || n).palette.error.main,
          },
        },
        "&::before": {
          borderBottom: `1px solid ${
            n.vars
              ? `rgba(${n.vars.palette.common.onBackgroundChannel} / ${n.vars.opacity.inputUnderline})`
              : i
          }`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: n.transitions.create("border-bottom-color", {
            duration: n.transitions.duration.shorter,
          }),
          pointerEvents: "none",
        },
        [`&:hover:not(.${bc.disabled}, .${bc.error}):before`]: {
          borderBottom: `1px solid ${(n.vars || n).palette.text.primary}`,
        },
        [`&.${bc.disabled}:before`]: { borderBottomStyle: "dotted" },
      },
      e.startAdornment && { paddingLeft: 12 },
      e.endAdornment && { paddingRight: 12 },
      e.multiline &&
        pe(
          { padding: "25px 12px 8px" },
          e.size === "small" && { paddingTop: 21, paddingBottom: 4 },
          e.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
          e.hiddenLabel &&
            e.size === "small" && { paddingTop: 8, paddingBottom: 9 }
        )
    );
  }),
  NO = en(cy, { name: "MuiFilledInput", slot: "Input", overridesResolver: ly })(
    ({ theme: n, ownerState: e }) =>
      pe(
        { paddingTop: 25, paddingRight: 12, paddingBottom: 8, paddingLeft: 12 },
        !n.vars && {
          "&:-webkit-autofill": {
            WebkitBoxShadow:
              n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
            caretColor: n.palette.mode === "light" ? null : "#fff",
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit",
          },
        },
        n.vars && {
          "&:-webkit-autofill": {
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit",
          },
          [n.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
              WebkitBoxShadow: "0 0 0 100px #266798 inset",
              WebkitTextFillColor: "#fff",
              caretColor: "#fff",
            },
          },
        },
        e.size === "small" && { paddingTop: 21, paddingBottom: 4 },
        e.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
        e.startAdornment && { paddingLeft: 0 },
        e.endAdornment && { paddingRight: 0 },
        e.hiddenLabel &&
          e.size === "small" && { paddingTop: 8, paddingBottom: 9 },
        e.multiline && {
          paddingTop: 0,
          paddingBottom: 0,
          paddingLeft: 0,
          paddingRight: 0,
        }
      )
  ),
  i2 = ee.forwardRef(function (e, t) {
    var r, i, o, s;
    const l = Or({ props: e, name: "MuiFilledInput" }),
      {
        components: u = {},
        componentsProps: f,
        fullWidth: h = !1,
        inputComponent: m = "input",
        multiline: g = !1,
        slotProps: y,
        slots: _ = {},
        type: S = "text",
      } = l,
      x = Ft(l, DO),
      w = pe({}, l, { fullWidth: h, inputComponent: m, multiline: g, type: S }),
      T = kO(l),
      E = { root: { ownerState: w }, input: { ownerState: w } },
      A = y ?? f ? ti(E, y ?? f) : E,
      R = (r = (i = _.root) != null ? i : u.Root) != null ? r : OO,
      D = (o = (s = _.input) != null ? s : u.Input) != null ? o : NO;
    return ve.jsx(
      yS,
      pe(
        {
          slots: { root: R, input: D },
          componentsProps: A,
          fullWidth: h,
          inputComponent: m,
          multiline: g,
          ref: t,
          type: S,
        },
        x,
        { classes: T }
      )
    );
  });
i2.muiName = "Input";
function UO(n) {
  return hr("MuiFormControl", n);
}
Xn("MuiFormControl", [
  "root",
  "marginNone",
  "marginNormal",
  "marginDense",
  "fullWidth",
  "disabled",
]);
const FO = [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "focused",
    "fullWidth",
    "hiddenLabel",
    "margin",
    "required",
    "size",
    "variant",
  ],
  zO = (n) => {
    const { classes: e, margin: t, fullWidth: r } = n,
      i = {
        root: ["root", t !== "none" && `margin${fn(t)}`, r && "fullWidth"],
      };
    return pr(i, UO, e);
  },
  BO = en("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({ ownerState: n }, e) =>
      pe({}, e.root, e[`margin${fn(n.margin)}`], n.fullWidth && e.fullWidth),
  })(({ ownerState: n }) =>
    pe(
      {
        display: "inline-flex",
        flexDirection: "column",
        position: "relative",
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: "top",
      },
      n.margin === "normal" && { marginTop: 16, marginBottom: 8 },
      n.margin === "dense" && { marginTop: 8, marginBottom: 4 },
      n.fullWidth && { width: "100%" }
    )
  ),
  $x = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiFormControl" }),
      {
        children: i,
        className: o,
        color: s = "primary",
        component: l = "div",
        disabled: u = !1,
        error: f = !1,
        focused: h,
        fullWidth: m = !1,
        hiddenLabel: g = !1,
        margin: y = "none",
        required: _ = !1,
        size: S = "medium",
        variant: x = "outlined",
      } = r,
      w = Ft(r, FO),
      T = pe({}, r, {
        color: s,
        component: l,
        disabled: u,
        error: f,
        fullWidth: m,
        hiddenLabel: g,
        margin: y,
        required: _,
        size: S,
        variant: x,
      }),
      E = zO(T),
      [A, R] = ee.useState(() => {
        let $ = !1;
        return (
          i &&
            ee.Children.forEach(i, (q) => {
              if (!Ux(q, ["Input", "Select"])) return;
              const K = Ux(q, ["Select"]) ? q.props.input : q;
              K && Fk(K.props) && ($ = !0);
            }),
          $
        );
      }),
      [D, I] = ee.useState(() => {
        let $ = !1;
        return (
          i &&
            ee.Children.forEach(i, (q) => {
              Ux(q, ["Input", "Select"]) &&
                (i0(q.props, !0) || i0(q.props.inputProps, !0)) &&
                ($ = !0);
            }),
          $
        );
      }),
      [U, O] = ee.useState(!1);
    u && U && O(!1);
    const L = h !== void 0 && !u ? h : U;
    let V;
    const H = ee.useMemo(
      () => ({
        adornedStart: A,
        setAdornedStart: R,
        color: s,
        disabled: u,
        error: f,
        filled: D,
        focused: L,
        fullWidth: m,
        hiddenLabel: g,
        size: S,
        onBlur: () => {
          O(!1);
        },
        onEmpty: () => {
          I(!1);
        },
        onFilled: () => {
          I(!0);
        },
        onFocus: () => {
          O(!0);
        },
        registerEffect: V,
        required: _,
        variant: x,
      }),
      [A, s, u, f, D, L, m, g, V, _, S, x]
    );
    return ve.jsx(vS.Provider, {
      value: H,
      children: ve.jsx(
        BO,
        pe({ as: l, ownerState: T, className: cn(E.root, o), ref: t }, w, {
          children: i,
        })
      ),
    });
  }),
  o2 = uD({
    createStyledComponent: en("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (n, e) => e.root,
    }),
    useThemeProps: (n) => Or({ props: n, name: "MuiStack" }),
  });
function VO(n) {
  return hr("MuiFormLabel", n);
}
const Fp = Xn("MuiFormLabel", [
    "root",
    "colorSecondary",
    "focused",
    "disabled",
    "error",
    "filled",
    "required",
    "asterisk",
  ]),
  HO = [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "required",
  ],
  GO = (n) => {
    const {
        classes: e,
        color: t,
        focused: r,
        disabled: i,
        error: o,
        filled: s,
        required: l,
      } = n,
      u = {
        root: [
          "root",
          `color${fn(t)}`,
          i && "disabled",
          o && "error",
          s && "filled",
          r && "focused",
          l && "required",
        ],
        asterisk: ["asterisk", o && "error"],
      };
    return pr(u, VO, e);
  },
  WO = en("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: ({ ownerState: n }, e) =>
      pe(
        {},
        e.root,
        n.color === "secondary" && e.colorSecondary,
        n.filled && e.filled
      ),
  })(({ theme: n, ownerState: e }) =>
    pe({ color: (n.vars || n).palette.text.secondary }, n.typography.body1, {
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      [`&.${Fp.focused}`]: { color: (n.vars || n).palette[e.color].main },
      [`&.${Fp.disabled}`]: { color: (n.vars || n).palette.text.disabled },
      [`&.${Fp.error}`]: { color: (n.vars || n).palette.error.main },
    })
  ),
  jO = en("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (n, e) => e.asterisk,
  })(({ theme: n }) => ({
    [`&.${Fp.error}`]: { color: (n.vars || n).palette.error.main },
  })),
  $O = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiFormLabel" }),
      { children: i, className: o, component: s = "label" } = r,
      l = Ft(r, HO),
      u = Lm(),
      f = Im({
        props: r,
        muiFormControl: u,
        states: ["color", "required", "focused", "disabled", "error", "filled"],
      }),
      h = pe({}, r, {
        color: f.color || "primary",
        component: s,
        disabled: f.disabled,
        error: f.error,
        filled: f.filled,
        focused: f.focused,
        required: f.required,
      }),
      m = GO(h);
    return ve.jsxs(
      WO,
      pe({ as: s, ownerState: h, className: cn(m.root, o), ref: t }, l, {
        children: [
          i,
          f.required &&
            ve.jsxs(jO, {
              ownerState: h,
              "aria-hidden": !0,
              className: m.asterisk,
              children: [" ", "*"],
            }),
        ],
      })
    );
  }),
  XO = [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    "TransitionComponent",
  ];
function S1(n) {
  return `scale(${n}, ${n ** 2})`;
}
const YO = {
    entering: { opacity: 1, transform: S1(1) },
    entered: { opacity: 1, transform: "none" },
  },
  Xx =
    typeof navigator < "u" &&
    /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
    /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  s2 = ee.forwardRef(function (e, t) {
    const {
        addEndListener: r,
        appear: i = !0,
        children: o,
        easing: s,
        in: l,
        onEnter: u,
        onEntered: f,
        onEntering: h,
        onExit: m,
        onExited: g,
        onExiting: y,
        style: _,
        timeout: S = "auto",
        TransitionComponent: x = Wa,
      } = e,
      w = Ft(e, XO),
      T = HC(),
      E = ee.useRef(),
      A = ZC(),
      R = ee.useRef(null),
      D = xi(R, o.ref, t),
      I = (K) => (Y) => {
        if (K) {
          const ne = R.current;
          Y === void 0 ? K(ne) : K(ne, Y);
        }
      },
      U = I(h),
      O = I((K, Y) => {
        t2(K);
        const {
          duration: ne,
          delay: j,
          easing: re,
        } = r0({ style: _, timeout: S, easing: s }, { mode: "enter" });
        let B;
        S === "auto"
          ? ((B = A.transitions.getAutoHeightDuration(K.clientHeight)),
            (E.current = B))
          : (B = ne),
          (K.style.transition = [
            A.transitions.create("opacity", { duration: B, delay: j }),
            A.transitions.create("transform", {
              duration: Xx ? B : B * 0.666,
              delay: j,
              easing: re,
            }),
          ].join(",")),
          u && u(K, Y);
      }),
      L = I(f),
      V = I(y),
      H = I((K) => {
        const {
          duration: Y,
          delay: ne,
          easing: j,
        } = r0({ style: _, timeout: S, easing: s }, { mode: "exit" });
        let re;
        S === "auto"
          ? ((re = A.transitions.getAutoHeightDuration(K.clientHeight)),
            (E.current = re))
          : (re = Y),
          (K.style.transition = [
            A.transitions.create("opacity", { duration: re, delay: ne }),
            A.transitions.create("transform", {
              duration: Xx ? re : re * 0.666,
              delay: Xx ? ne : ne || re * 0.333,
              easing: j,
            }),
          ].join(",")),
          (K.style.opacity = 0),
          (K.style.transform = S1(0.75)),
          m && m(K);
      }),
      $ = I(g),
      q = (K) => {
        S === "auto" && T.start(E.current || 0, K), r && r(R.current, K);
      };
    return ve.jsx(
      x,
      pe(
        {
          appear: i,
          in: l,
          nodeRef: R,
          onEnter: O,
          onEntered: L,
          onEntering: U,
          onExit: H,
          onExited: $,
          onExiting: V,
          addEndListener: q,
          timeout: S === "auto" ? null : S,
        },
        w,
        {
          children: (K, Y) =>
            ee.cloneElement(
              o,
              pe(
                {
                  style: pe(
                    {
                      opacity: 0,
                      transform: S1(0.75),
                      visibility: K === "exited" && !l ? "hidden" : void 0,
                    },
                    YO[K],
                    _,
                    o.props.style
                  ),
                  ref: D,
                },
                Y
              )
            ),
        }
      )
    );
  });
s2.muiSupportAuto = !0;
const qO = [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type",
  ],
  KO = (n) => {
    const { classes: e, disableUnderline: t } = n,
      i = pr({ root: ["root", !t && "underline"], input: ["input"] }, Gk, e);
    return pe({}, e, i);
  },
  ZO = en(uy, {
    shouldForwardProp: (n) => Rs(n) || n === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [...ay(n, e), !t.disableUnderline && e.underline];
    },
  })(({ theme: n, ownerState: e }) => {
    let r =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.42)"
        : "rgba(255, 255, 255, 0.7)";
    return (
      n.vars &&
        (r = `rgba(${n.vars.palette.common.onBackgroundChannel} / ${n.vars.opacity.inputUnderline})`),
      pe(
        { position: "relative" },
        e.formControl && { "label + &": { marginTop: 16 } },
        !e.disableUnderline && {
          "&::after": {
            borderBottom: `2px solid ${(n.vars || n).palette[e.color].main}`,
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: n.transitions.create("transform", {
              duration: n.transitions.duration.shorter,
              easing: n.transitions.easing.easeOut,
            }),
            pointerEvents: "none",
          },
          [`&.${up.focused}:after`]: { transform: "scaleX(1) translateX(0)" },
          [`&.${up.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (n.vars || n).palette.error.main,
            },
          },
          "&::before": {
            borderBottom: `1px solid ${r}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: n.transitions.create("border-bottom-color", {
              duration: n.transitions.duration.shorter,
            }),
            pointerEvents: "none",
          },
          [`&:hover:not(.${up.disabled}, .${up.error}):before`]: {
            borderBottom: `2px solid ${(n.vars || n).palette.text.primary}`,
            "@media (hover: none)": { borderBottom: `1px solid ${r}` },
          },
          [`&.${up.disabled}:before`]: { borderBottomStyle: "dotted" },
        }
      )
    );
  }),
  JO = en(cy, { name: "MuiInput", slot: "Input", overridesResolver: ly })({}),
  a2 = ee.forwardRef(function (e, t) {
    var r, i, o, s;
    const l = Or({ props: e, name: "MuiInput" }),
      {
        disableUnderline: u,
        components: f = {},
        componentsProps: h,
        fullWidth: m = !1,
        inputComponent: g = "input",
        multiline: y = !1,
        slotProps: _,
        slots: S = {},
        type: x = "text",
      } = l,
      w = Ft(l, qO),
      T = KO(l),
      A = { root: { ownerState: { disableUnderline: u } } },
      R = _ ?? h ? ti(_ ?? h, A) : A,
      D = (r = (i = S.root) != null ? i : f.Root) != null ? r : ZO,
      I = (o = (s = S.input) != null ? s : f.Input) != null ? o : JO;
    return ve.jsx(
      yS,
      pe(
        {
          slots: { root: D, input: I },
          slotProps: R,
          fullWidth: m,
          inputComponent: g,
          multiline: y,
          ref: t,
          type: x,
        },
        w,
        { classes: T }
      )
    );
  });
a2.muiName = "Input";
function QO(n) {
  return hr("MuiInputLabel", n);
}
Xn("MuiInputLabel", [
  "root",
  "focused",
  "disabled",
  "error",
  "required",
  "asterisk",
  "formControl",
  "sizeSmall",
  "shrink",
  "animated",
  "standard",
  "filled",
  "outlined",
]);
const eN = ["disableAnimation", "margin", "shrink", "variant", "className"],
  tN = (n) => {
    const {
        classes: e,
        formControl: t,
        size: r,
        shrink: i,
        disableAnimation: o,
        variant: s,
        required: l,
      } = n,
      u = {
        root: [
          "root",
          t && "formControl",
          !o && "animated",
          i && "shrink",
          r && r !== "normal" && `size${fn(r)}`,
          s,
        ],
        asterisk: [l && "asterisk"],
      },
      f = pr(u, QO, e);
    return pe({}, e, f);
  },
  nN = en($O, {
    shouldForwardProp: (n) => Rs(n) || n === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`& .${Fp.asterisk}`]: e.asterisk },
        e.root,
        t.formControl && e.formControl,
        t.size === "small" && e.sizeSmall,
        t.shrink && e.shrink,
        !t.disableAnimation && e.animated,
        t.focused && e.focused,
        e[t.variant],
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    pe(
      {
        display: "block",
        transformOrigin: "top left",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        maxWidth: "100%",
      },
      e.formControl && {
        position: "absolute",
        left: 0,
        top: 0,
        transform: "translate(0, 20px) scale(1)",
      },
      e.size === "small" && { transform: "translate(0, 17px) scale(1)" },
      e.shrink && {
        transform: "translate(0, -1.5px) scale(0.75)",
        transformOrigin: "top left",
        maxWidth: "133%",
      },
      !e.disableAnimation && {
        transition: n.transitions.create(["color", "transform", "max-width"], {
          duration: n.transitions.duration.shorter,
          easing: n.transitions.easing.easeOut,
        }),
      },
      e.variant === "filled" &&
        pe(
          {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(12px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
          e.size === "small" && { transform: "translate(12px, 13px) scale(1)" },
          e.shrink &&
            pe(
              {
                userSelect: "none",
                pointerEvents: "auto",
                transform: "translate(12px, 7px) scale(0.75)",
                maxWidth: "calc(133% - 24px)",
              },
              e.size === "small" && {
                transform: "translate(12px, 4px) scale(0.75)",
              }
            )
        ),
      e.variant === "outlined" &&
        pe(
          {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(14px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
          e.size === "small" && { transform: "translate(14px, 9px) scale(1)" },
          e.shrink && {
            userSelect: "none",
            pointerEvents: "auto",
            maxWidth: "calc(133% - 32px)",
            transform: "translate(14px, -9px) scale(0.75)",
          }
        )
    )
  ),
  Yx = ee.forwardRef(function (e, t) {
    const r = Or({ name: "MuiInputLabel", props: e }),
      { disableAnimation: i = !1, shrink: o, className: s } = r,
      l = Ft(r, eN),
      u = Lm();
    let f = o;
    typeof f > "u" && u && (f = u.filled || u.focused || u.adornedStart);
    const h = Im({
        props: r,
        muiFormControl: u,
        states: ["size", "variant", "required", "focused"],
      }),
      m = pe({}, r, {
        disableAnimation: i,
        formControl: u,
        shrink: f,
        size: h.size,
        variant: h.variant,
        required: h.required,
        focused: h.focused,
      }),
      g = tN(m);
    return ve.jsx(
      nN,
      pe(
        { "data-shrink": f, ownerState: m, ref: t, className: cn(g.root, s) },
        l,
        { classes: g }
      )
    );
  }),
  w1 = ee.createContext({});
function rN(n) {
  return hr("MuiList", n);
}
Xn("MuiList", ["root", "padding", "dense", "subheader"]);
const iN = [
    "children",
    "className",
    "component",
    "dense",
    "disablePadding",
    "subheader",
  ],
  oN = (n) => {
    const { classes: e, disablePadding: t, dense: r, subheader: i } = n;
    return pr(
      { root: ["root", !t && "padding", r && "dense", i && "subheader"] },
      rN,
      e
    );
  },
  sN = en("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        !t.disablePadding && e.padding,
        t.dense && e.dense,
        t.subheader && e.subheader,
      ];
    },
  })(({ ownerState: n }) =>
    pe(
      { listStyle: "none", margin: 0, padding: 0, position: "relative" },
      !n.disablePadding && { paddingTop: 8, paddingBottom: 8 },
      n.subheader && { paddingTop: 0 }
    )
  ),
  aN = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiList" }),
      {
        children: i,
        className: o,
        component: s = "ul",
        dense: l = !1,
        disablePadding: u = !1,
        subheader: f,
      } = r,
      h = Ft(r, iN),
      m = ee.useMemo(() => ({ dense: l }), [l]),
      g = pe({}, r, { component: s, dense: l, disablePadding: u }),
      y = oN(g);
    return ve.jsx(w1.Provider, {
      value: m,
      children: ve.jsxs(
        sN,
        pe({ as: s, className: cn(y.root, o), ref: t, ownerState: g }, h, {
          children: [f, i],
        })
      ),
    });
  }),
  db = Xn("MuiListItemIcon", ["root", "alignItemsFlexStart"]),
  hb = Xn("MuiListItemText", [
    "root",
    "multiline",
    "dense",
    "inset",
    "primary",
    "secondary",
  ]),
  lN = [
    "actions",
    "autoFocus",
    "autoFocusItem",
    "children",
    "className",
    "disabledItemsFocusable",
    "disableListWrap",
    "onKeyDown",
    "variant",
  ];
function qx(n, e, t) {
  return n === e
    ? n.firstChild
    : e && e.nextElementSibling
    ? e.nextElementSibling
    : t
    ? null
    : n.firstChild;
}
function pb(n, e, t) {
  return n === e
    ? t
      ? n.firstChild
      : n.lastChild
    : e && e.previousElementSibling
    ? e.previousElementSibling
    : t
    ? null
    : n.lastChild;
}
function l2(n, e) {
  if (e === void 0) return !0;
  let t = n.innerText;
  return (
    t === void 0 && (t = n.textContent),
    (t = t.trim().toLowerCase()),
    t.length === 0
      ? !1
      : e.repeating
      ? t[0] === e.keys[0]
      : t.indexOf(e.keys.join("")) === 0
  );
}
function cp(n, e, t, r, i, o) {
  let s = !1,
    l = i(n, e, e ? t : !1);
  for (; l; ) {
    if (l === n.firstChild) {
      if (s) return !1;
      s = !0;
    }
    const u = r ? !1 : l.disabled || l.getAttribute("aria-disabled") === "true";
    if (!l.hasAttribute("tabindex") || !l2(l, o) || u) l = i(n, l, t);
    else return l.focus(), !0;
  }
  return !1;
}
const uN = ee.forwardRef(function (e, t) {
  const {
      actions: r,
      autoFocus: i = !1,
      autoFocusItem: o = !1,
      children: s,
      className: l,
      disabledItemsFocusable: u = !1,
      disableListWrap: f = !1,
      onKeyDown: h,
      variant: m = "selectedMenu",
    } = e,
    g = Ft(e, lN),
    y = ee.useRef(null),
    _ = ee.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null,
    });
  Fu(() => {
    i && y.current.focus();
  }, [i]),
    ee.useImperativeHandle(
      r,
      () => ({
        adjustStyleForScrollbar: (E, { direction: A }) => {
          const R = !y.current.style.width;
          if (E.clientHeight < y.current.clientHeight && R) {
            const D = `${WC(rs(E))}px`;
            (y.current.style[A === "rtl" ? "paddingLeft" : "paddingRight"] = D),
              (y.current.style.width = `calc(100% + ${D})`);
          }
          return y.current;
        },
      }),
      []
    );
  const S = (E) => {
      const A = y.current,
        R = E.key,
        D = rs(A).activeElement;
      if (R === "ArrowDown") E.preventDefault(), cp(A, D, f, u, qx);
      else if (R === "ArrowUp") E.preventDefault(), cp(A, D, f, u, pb);
      else if (R === "Home") E.preventDefault(), cp(A, null, f, u, qx);
      else if (R === "End") E.preventDefault(), cp(A, null, f, u, pb);
      else if (R.length === 1) {
        const I = _.current,
          U = R.toLowerCase(),
          O = performance.now();
        I.keys.length > 0 &&
          (O - I.lastTime > 500
            ? ((I.keys = []), (I.repeating = !0), (I.previousKeyMatched = !0))
            : I.repeating && U !== I.keys[0] && (I.repeating = !1)),
          (I.lastTime = O),
          I.keys.push(U);
        const L = D && !I.repeating && l2(D, I);
        I.previousKeyMatched && (L || cp(A, D, !1, u, qx, I))
          ? E.preventDefault()
          : (I.previousKeyMatched = !1);
      }
      h && h(E);
    },
    x = xi(y, t);
  let w = -1;
  ee.Children.forEach(s, (E, A) => {
    if (!ee.isValidElement(E)) {
      w === A && ((w += 1), w >= s.length && (w = -1));
      return;
    }
    E.props.disabled ||
      (((m === "selectedMenu" && E.props.selected) || w === -1) && (w = A)),
      w === A &&
        (E.props.disabled ||
          E.props.muiSkipListHighlight ||
          E.type.muiSkipListHighlight) &&
        ((w += 1), w >= s.length && (w = -1));
  });
  const T = ee.Children.map(s, (E, A) => {
    if (A === w) {
      const R = {};
      return (
        o && (R.autoFocus = !0),
        E.props.tabIndex === void 0 && m === "selectedMenu" && (R.tabIndex = 0),
        ee.cloneElement(E, R)
      );
    }
    return E;
  });
  return ve.jsx(
    aN,
    pe(
      {
        role: "menu",
        ref: x,
        className: l,
        onKeyDown: S,
        tabIndex: i ? 0 : -1,
      },
      g,
      { children: T }
    )
  );
});
function cN(n) {
  return hr("MuiPopover", n);
}
Xn("MuiPopover", ["root", "paper"]);
const fN = ["onEntering"],
  dN = [
    "action",
    "anchorEl",
    "anchorOrigin",
    "anchorPosition",
    "anchorReference",
    "children",
    "className",
    "container",
    "elevation",
    "marginThreshold",
    "open",
    "PaperProps",
    "slots",
    "slotProps",
    "transformOrigin",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps",
    "disableScrollLock",
  ],
  hN = ["slotProps"];
function mb(n, e) {
  let t = 0;
  return (
    typeof e == "number"
      ? (t = e)
      : e === "center"
      ? (t = n.height / 2)
      : e === "bottom" && (t = n.height),
    t
  );
}
function gb(n, e) {
  let t = 0;
  return (
    typeof e == "number"
      ? (t = e)
      : e === "center"
      ? (t = n.width / 2)
      : e === "right" && (t = n.width),
    t
  );
}
function vb(n) {
  return [n.horizontal, n.vertical]
    .map((e) => (typeof e == "number" ? `${e}px` : e))
    .join(" ");
}
function Kx(n) {
  return typeof n == "function" ? n() : n;
}
const pN = (n) => {
    const { classes: e } = n;
    return pr({ root: ["root"], paper: ["paper"] }, cN, e);
  },
  mN = en(LO, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  u2 = en(ck, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (n, e) => e.paper,
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0,
  }),
  gN = ee.forwardRef(function (e, t) {
    var r, i, o;
    const s = Or({ props: e, name: "MuiPopover" }),
      {
        action: l,
        anchorEl: u,
        anchorOrigin: f = { vertical: "top", horizontal: "left" },
        anchorPosition: h,
        anchorReference: m = "anchorEl",
        children: g,
        className: y,
        container: _,
        elevation: S = 8,
        marginThreshold: x = 16,
        open: w,
        PaperProps: T = {},
        slots: E,
        slotProps: A,
        transformOrigin: R = { vertical: "top", horizontal: "left" },
        TransitionComponent: D = s2,
        transitionDuration: I = "auto",
        TransitionProps: { onEntering: U } = {},
        disableScrollLock: O = !1,
      } = s,
      L = Ft(s.TransitionProps, fN),
      V = Ft(s, dN),
      H = (r = A == null ? void 0 : A.paper) != null ? r : T,
      $ = ee.useRef(),
      q = xi($, H.ref),
      K = pe({}, s, {
        anchorOrigin: f,
        anchorReference: m,
        elevation: S,
        marginThreshold: x,
        externalPaperSlotProps: H,
        transformOrigin: R,
        TransitionComponent: D,
        transitionDuration: I,
        TransitionProps: L,
      }),
      Y = pN(K),
      ne = ee.useCallback(() => {
        if (m === "anchorPosition") return h;
        const _e = Kx(u),
          ke = (
            _e && _e.nodeType === 1 ? _e : rs($.current).body
          ).getBoundingClientRect();
        return {
          top: ke.top + mb(ke, f.vertical),
          left: ke.left + gb(ke, f.horizontal),
        };
      }, [u, f.horizontal, f.vertical, h, m]),
      j = ee.useCallback(
        (_e) => ({
          vertical: mb(_e, R.vertical),
          horizontal: gb(_e, R.horizontal),
        }),
        [R.horizontal, R.vertical]
      ),
      re = ee.useCallback(
        (_e) => {
          const Te = { width: _e.offsetWidth, height: _e.offsetHeight },
            ke = j(Te);
          if (m === "none")
            return { top: null, left: null, transformOrigin: vb(ke) };
          const Pe = ne();
          let rt = Pe.top - ke.vertical,
            Le = Pe.left - ke.horizontal;
          const Xe = rt + Te.height,
            Z = Le + Te.width,
            F = of(Kx(u)),
            me = F.innerHeight - x,
            xe = F.innerWidth - x;
          if (x !== null && rt < x) {
            const ye = rt - x;
            (rt -= ye), (ke.vertical += ye);
          } else if (x !== null && Xe > me) {
            const ye = Xe - me;
            (rt -= ye), (ke.vertical += ye);
          }
          if (x !== null && Le < x) {
            const ye = Le - x;
            (Le -= ye), (ke.horizontal += ye);
          } else if (Z > xe) {
            const ye = Z - xe;
            (Le -= ye), (ke.horizontal += ye);
          }
          return {
            top: `${Math.round(rt)}px`,
            left: `${Math.round(Le)}px`,
            transformOrigin: vb(ke),
          };
        },
        [u, m, ne, j, x]
      ),
      [B, G] = ee.useState(w),
      te = ee.useCallback(() => {
        const _e = $.current;
        if (!_e) return;
        const Te = re(_e);
        Te.top !== null && (_e.style.top = Te.top),
          Te.left !== null && (_e.style.left = Te.left),
          (_e.style.transformOrigin = Te.transformOrigin),
          G(!0);
      }, [re]);
    ee.useEffect(
      () => (
        O && window.addEventListener("scroll", te),
        () => window.removeEventListener("scroll", te)
      ),
      [u, O, te]
    );
    const le = (_e, Te) => {
        U && U(_e, Te), te();
      },
      J = () => {
        G(!1);
      };
    ee.useEffect(() => {
      w && te();
    }),
      ee.useImperativeHandle(
        l,
        () =>
          w
            ? {
                updatePosition: () => {
                  te();
                },
              }
            : null,
        [w, te]
      ),
      ee.useEffect(() => {
        if (!w) return;
        const _e = VC(() => {
            te();
          }),
          Te = of(u);
        return (
          Te.addEventListener("resize", _e),
          () => {
            _e.clear(), Te.removeEventListener("resize", _e);
          }
        );
      }, [u, w, te]);
    let oe = I;
    I === "auto" && !D.muiSupportAuto && (oe = void 0);
    const he = _ || (u ? rs(Kx(u)).body : void 0),
      ae = (i = E == null ? void 0 : E.root) != null ? i : mN,
      ue = (o = E == null ? void 0 : E.paper) != null ? o : u2,
      Ee = sh({
        elementType: ue,
        externalSlotProps: pe({}, H, {
          style: B ? H.style : pe({}, H.style, { opacity: 0 }),
        }),
        additionalProps: { elevation: S, ref: q },
        ownerState: K,
        className: cn(Y.paper, H == null ? void 0 : H.className),
      }),
      Ne = sh({
        elementType: ae,
        externalSlotProps: (A == null ? void 0 : A.root) || {},
        externalForwardedProps: V,
        additionalProps: {
          ref: t,
          slotProps: { backdrop: { invisible: !0 } },
          container: he,
          open: w,
        },
        ownerState: K,
        className: cn(Y.root, y),
      }),
      { slotProps: Ae } = Ne,
      W = Ft(Ne, hN);
    return ve.jsx(
      ae,
      pe({}, W, !e0(ae) && { slotProps: Ae, disableScrollLock: O }, {
        children: ve.jsx(
          D,
          pe(
            { appear: !0, in: w, onEntering: le, onExited: J, timeout: oe },
            L,
            { children: ve.jsx(ue, pe({}, Ee, { children: g })) }
          )
        ),
      })
    );
  });
function vN(n) {
  return hr("MuiMenu", n);
}
Xn("MuiMenu", ["root", "paper", "list"]);
const yN = ["onEntering"],
  xN = [
    "autoFocus",
    "children",
    "className",
    "disableAutoFocusItem",
    "MenuListProps",
    "onClose",
    "open",
    "PaperProps",
    "PopoverClasses",
    "transitionDuration",
    "TransitionProps",
    "variant",
    "slots",
    "slotProps",
  ],
  _N = { vertical: "top", horizontal: "right" },
  SN = { vertical: "top", horizontal: "left" },
  wN = (n) => {
    const { classes: e } = n;
    return pr({ root: ["root"], paper: ["paper"], list: ["list"] }, vN, e);
  },
  MN = en(gN, {
    shouldForwardProp: (n) => Rs(n) || n === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  bN = en(u2, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (n, e) => e.paper,
  })({ maxHeight: "calc(100% - 96px)", WebkitOverflowScrolling: "touch" }),
  EN = en(uN, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (n, e) => e.list,
  })({ outline: 0 }),
  TN = ee.forwardRef(function (e, t) {
    var r, i;
    const o = Or({ props: e, name: "MuiMenu" }),
      {
        autoFocus: s = !0,
        children: l,
        className: u,
        disableAutoFocusItem: f = !1,
        MenuListProps: h = {},
        onClose: m,
        open: g,
        PaperProps: y = {},
        PopoverClasses: _,
        transitionDuration: S = "auto",
        TransitionProps: { onEntering: x } = {},
        variant: w = "selectedMenu",
        slots: T = {},
        slotProps: E = {},
      } = o,
      A = Ft(o.TransitionProps, yN),
      R = Ft(o, xN),
      D = $L(),
      I = pe({}, o, {
        autoFocus: s,
        disableAutoFocusItem: f,
        MenuListProps: h,
        onEntering: x,
        PaperProps: y,
        transitionDuration: S,
        TransitionProps: A,
        variant: w,
      }),
      U = wN(I),
      O = s && !f && g,
      L = ee.useRef(null),
      V = (j, re) => {
        L.current &&
          L.current.adjustStyleForScrollbar(j, {
            direction: D ? "rtl" : "ltr",
          }),
          x && x(j, re);
      },
      H = (j) => {
        j.key === "Tab" && (j.preventDefault(), m && m(j, "tabKeyDown"));
      };
    let $ = -1;
    ee.Children.map(l, (j, re) => {
      ee.isValidElement(j) &&
        (j.props.disabled ||
          (((w === "selectedMenu" && j.props.selected) || $ === -1) &&
            ($ = re)));
    });
    const q = (r = T.paper) != null ? r : bN,
      K = (i = E.paper) != null ? i : y,
      Y = sh({
        elementType: T.root,
        externalSlotProps: E.root,
        ownerState: I,
        className: [U.root, u],
      }),
      ne = sh({
        elementType: q,
        externalSlotProps: K,
        ownerState: I,
        className: U.paper,
      });
    return ve.jsx(
      MN,
      pe(
        {
          onClose: m,
          anchorOrigin: {
            vertical: "bottom",
            horizontal: D ? "right" : "left",
          },
          transformOrigin: D ? _N : SN,
          slots: { paper: q, root: T.root },
          slotProps: { root: Y, paper: ne },
          open: g,
          ref: t,
          transitionDuration: S,
          TransitionProps: pe({ onEntering: V }, A),
          ownerState: I,
        },
        R,
        {
          classes: _,
          children: ve.jsx(
            EN,
            pe(
              {
                onKeyDown: H,
                actions: L,
                autoFocus: s && ($ === -1 || f),
                autoFocusItem: O,
                variant: w,
              },
              h,
              { className: cn(U.list, h.className), children: l }
            )
          ),
        }
      )
    );
  });
function CN(n) {
  return hr("MuiMenuItem", n);
}
const fp = Xn("MuiMenuItem", [
    "root",
    "focusVisible",
    "dense",
    "disabled",
    "divider",
    "gutters",
    "selected",
  ]),
  AN = [
    "autoFocus",
    "component",
    "dense",
    "divider",
    "disableGutters",
    "focusVisibleClassName",
    "role",
    "tabIndex",
    "className",
  ],
  RN = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.dense && e.dense,
      t.divider && e.divider,
      !t.disableGutters && e.gutters,
    ];
  },
  PN = (n) => {
    const {
        disabled: e,
        dense: t,
        divider: r,
        disableGutters: i,
        selected: o,
        classes: s,
      } = n,
      u = pr(
        {
          root: [
            "root",
            t && "dense",
            e && "disabled",
            !i && "gutters",
            r && "divider",
            o && "selected",
          ],
        },
        CN,
        s
      );
    return pe({}, s, u);
  },
  IN = en(n2, {
    shouldForwardProp: (n) => Rs(n) || n === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: RN,
  })(({ theme: n, ownerState: e }) =>
    pe(
      {},
      n.typography.body1,
      {
        display: "flex",
        justifyContent: "flex-start",
        alignItems: "center",
        position: "relative",
        textDecoration: "none",
        minHeight: 48,
        paddingTop: 6,
        paddingBottom: 6,
        boxSizing: "border-box",
        whiteSpace: "nowrap",
      },
      !e.disableGutters && { paddingLeft: 16, paddingRight: 16 },
      e.divider && {
        borderBottom: `1px solid ${(n.vars || n).palette.divider}`,
        backgroundClip: "padding-box",
      },
      {
        "&:hover": {
          textDecoration: "none",
          backgroundColor: (n.vars || n).palette.action.hover,
          "@media (hover: none)": { backgroundColor: "transparent" },
        },
        [`&.${fp.selected}`]: {
          backgroundColor: n.vars
            ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
            : ts.alpha(
                n.palette.primary.main,
                n.palette.action.selectedOpacity
              ),
          [`&.${fp.focusVisible}`]: {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.focusOpacity}))`
              : ts.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity +
                    n.palette.action.focusOpacity
                ),
          },
        },
        [`&.${fp.selected}:hover`]: {
          backgroundColor: n.vars
            ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.hoverOpacity}))`
            : ts.alpha(
                n.palette.primary.main,
                n.palette.action.selectedOpacity + n.palette.action.hoverOpacity
              ),
          "@media (hover: none)": {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
              : ts.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity
                ),
          },
        },
        [`&.${fp.focusVisible}`]: {
          backgroundColor: (n.vars || n).palette.action.focus,
        },
        [`&.${fp.disabled}`]: {
          opacity: (n.vars || n).palette.action.disabledOpacity,
        },
        [`& + .${fb.root}`]: {
          marginTop: n.spacing(1),
          marginBottom: n.spacing(1),
        },
        [`& + .${fb.inset}`]: { marginLeft: 52 },
        [`& .${hb.root}`]: { marginTop: 0, marginBottom: 0 },
        [`& .${hb.inset}`]: { paddingLeft: 36 },
        [`& .${db.root}`]: { minWidth: 36 },
      },
      !e.dense && { [n.breakpoints.up("sm")]: { minHeight: "auto" } },
      e.dense &&
        pe(
          { minHeight: 32, paddingTop: 4, paddingBottom: 4 },
          n.typography.body2,
          { [`& .${db.root} svg`]: { fontSize: "1.25rem" } }
        )
    )
  ),
  Zx = ee.forwardRef(function (e, t) {
    const r = Or({ props: e, name: "MuiMenuItem" }),
      {
        autoFocus: i = !1,
        component: o = "li",
        dense: s = !1,
        divider: l = !1,
        disableGutters: u = !1,
        focusVisibleClassName: f,
        role: h = "menuitem",
        tabIndex: m,
        className: g,
      } = r,
      y = Ft(r, AN),
      _ = ee.useContext(w1),
      S = ee.useMemo(
        () => ({ dense: s || _.dense || !1, disableGutters: u }),
        [_.dense, s, u]
      ),
      x = ee.useRef(null);
    Fu(() => {
      i && x.current && x.current.focus();
    }, [i]);
    const w = pe({}, r, { dense: S.dense, divider: l, disableGutters: u }),
      T = PN(r),
      E = xi(x, t);
    let A;
    return (
      r.disabled || (A = m !== void 0 ? m : -1),
      ve.jsx(w1.Provider, {
        value: S,
        children: ve.jsx(
          IN,
          pe(
            {
              ref: E,
              role: h,
              tabIndex: A,
              component: o,
              focusVisibleClassName: cn(T.focusVisible, f),
              className: cn(T.root, g),
            },
            y,
            { ownerState: w, classes: T }
          )
        ),
      })
    );
  });
function LN(n) {
  return hr("MuiNativeSelect", n);
}
const xS = Xn("MuiNativeSelect", [
    "root",
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
  ]),
  DN = [
    "className",
    "disabled",
    "error",
    "IconComponent",
    "inputRef",
    "variant",
  ],
  kN = (n) => {
    const {
        classes: e,
        variant: t,
        disabled: r,
        multiple: i,
        open: o,
        error: s,
      } = n,
      l = {
        select: ["select", t, r && "disabled", i && "multiple", s && "error"],
        icon: ["icon", `icon${fn(t)}`, o && "iconOpen", r && "disabled"],
      };
    return pr(l, LN, e);
  },
  c2 = ({ ownerState: n, theme: e }) =>
    pe(
      {
        MozAppearance: "none",
        WebkitAppearance: "none",
        userSelect: "none",
        borderRadius: 0,
        cursor: "pointer",
        "&:focus": pe(
          {},
          e.vars
            ? {
                backgroundColor: `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.05)`,
              }
            : {
                backgroundColor:
                  e.palette.mode === "light"
                    ? "rgba(0, 0, 0, 0.05)"
                    : "rgba(255, 255, 255, 0.05)",
              },
          { borderRadius: 0 }
        ),
        "&::-ms-expand": { display: "none" },
        [`&.${xS.disabled}`]: { cursor: "default" },
        "&[multiple]": { height: "auto" },
        "&:not([multiple]) option, &:not([multiple]) optgroup": {
          backgroundColor: (e.vars || e).palette.background.paper,
        },
        "&&&": { paddingRight: 24, minWidth: 16 },
      },
      n.variant === "filled" && { "&&&": { paddingRight: 32 } },
      n.variant === "outlined" && {
        borderRadius: (e.vars || e).shape.borderRadius,
        "&:focus": { borderRadius: (e.vars || e).shape.borderRadius },
        "&&&": { paddingRight: 32 },
      }
    ),
  ON = en("select", {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: Rs,
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.select,
        e[t.variant],
        t.error && e.error,
        { [`&.${xS.multiple}`]: e.multiple },
      ];
    },
  })(c2),
  f2 = ({ ownerState: n, theme: e }) =>
    pe(
      {
        position: "absolute",
        right: 0,
        top: "calc(50% - .5em)",
        pointerEvents: "none",
        color: (e.vars || e).palette.action.active,
        [`&.${xS.disabled}`]: { color: (e.vars || e).palette.action.disabled },
      },
      n.open && { transform: "rotate(180deg)" },
      n.variant === "filled" && { right: 7 },
      n.variant === "outlined" && { right: 7 }
    ),
  NN = en("svg", {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.icon,
        t.variant && e[`icon${fn(t.variant)}`],
        t.open && e.iconOpen,
      ];
    },
  })(f2),
  UN = ee.forwardRef(function (e, t) {
    const {
        className: r,
        disabled: i,
        error: o,
        IconComponent: s,
        inputRef: l,
        variant: u = "standard",
      } = e,
      f = Ft(e, DN),
      h = pe({}, e, { disabled: i, variant: u, error: o }),
      m = kN(h);
    return ve.jsxs(ee.Fragment, {
      children: [
        ve.jsx(
          ON,
          pe(
            {
              ownerState: h,
              className: cn(m.select, r),
              disabled: i,
              ref: l || t,
            },
            f
          )
        ),
        e.multiple
          ? null
          : ve.jsx(NN, { as: s, ownerState: h, className: m.icon }),
      ],
    });
  });
var yb;
const FN = ["children", "classes", "className", "label", "notched"],
  zN = en("fieldset", { shouldForwardProp: Rs })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
  }),
  BN = en("legend", { shouldForwardProp: Rs })(({ ownerState: n, theme: e }) =>
    pe(
      { float: "unset", width: "auto", overflow: "hidden" },
      !n.withLabel && {
        padding: 0,
        lineHeight: "11px",
        transition: e.transitions.create("width", {
          duration: 150,
          easing: e.transitions.easing.easeOut,
        }),
      },
      n.withLabel &&
        pe(
          {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: 0.01,
            transition: e.transitions.create("max-width", {
              duration: 50,
              easing: e.transitions.easing.easeOut,
            }),
            whiteSpace: "nowrap",
            "& > span": {
              paddingLeft: 5,
              paddingRight: 5,
              display: "inline-block",
              opacity: 0,
              visibility: "visible",
            },
          },
          n.notched && {
            maxWidth: "100%",
            transition: e.transitions.create("max-width", {
              duration: 100,
              easing: e.transitions.easing.easeOut,
              delay: 50,
            }),
          }
        )
    )
  );
function VN(n) {
  const { className: e, label: t, notched: r } = n,
    i = Ft(n, FN),
    o = t != null && t !== "",
    s = pe({}, n, { notched: r, withLabel: o });
  return ve.jsx(
    zN,
    pe({ "aria-hidden": !0, className: e, ownerState: s }, i, {
      children: ve.jsx(BN, {
        ownerState: s,
        children: o
          ? ve.jsx("span", { children: t })
          : yb ||
            (yb = ve.jsx("span", { className: "notranslate", children: "​" })),
      }),
    })
  );
}
const HN = [
    "components",
    "fullWidth",
    "inputComponent",
    "label",
    "multiline",
    "notched",
    "slots",
    "type",
  ],
  GN = (n) => {
    const { classes: e } = n,
      r = pr(
        {
          root: ["root"],
          notchedOutline: ["notchedOutline"],
          input: ["input"],
        },
        Wk,
        e
      );
    return pe({}, e, r);
  },
  WN = en(uy, {
    shouldForwardProp: (n) => Rs(n) || n === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: ay,
  })(({ theme: n, ownerState: e }) => {
    const t =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.23)"
        : "rgba(255, 255, 255, 0.23)";
    return pe(
      {
        position: "relative",
        borderRadius: (n.vars || n).shape.borderRadius,
        [`&:hover .${Su.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.text.primary,
        },
        "@media (hover: none)": {
          [`&:hover .${Su.notchedOutline}`]: {
            borderColor: n.vars
              ? `rgba(${n.vars.palette.common.onBackgroundChannel} / 0.23)`
              : t,
          },
        },
        [`&.${Su.focused} .${Su.notchedOutline}`]: {
          borderColor: (n.vars || n).palette[e.color].main,
          borderWidth: 2,
        },
        [`&.${Su.error} .${Su.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.error.main,
        },
        [`&.${Su.disabled} .${Su.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.action.disabled,
        },
      },
      e.startAdornment && { paddingLeft: 14 },
      e.endAdornment && { paddingRight: 14 },
      e.multiline &&
        pe(
          { padding: "16.5px 14px" },
          e.size === "small" && { padding: "8.5px 14px" }
        )
    );
  }),
  jN = en(VN, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (n, e) => e.notchedOutline,
  })(({ theme: n }) => {
    const e =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.23)"
        : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: n.vars
        ? `rgba(${n.vars.palette.common.onBackgroundChannel} / 0.23)`
        : e,
    };
  }),
  $N = en(cy, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: ly,
  })(({ theme: n, ownerState: e }) =>
    pe(
      { padding: "16.5px 14px" },
      !n.vars && {
        "&:-webkit-autofill": {
          WebkitBoxShadow:
            n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
          WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
          caretColor: n.palette.mode === "light" ? null : "#fff",
          borderRadius: "inherit",
        },
      },
      n.vars && {
        "&:-webkit-autofill": { borderRadius: "inherit" },
        [n.getColorSchemeSelector("dark")]: {
          "&:-webkit-autofill": {
            WebkitBoxShadow: "0 0 0 100px #266798 inset",
            WebkitTextFillColor: "#fff",
            caretColor: "#fff",
          },
        },
      },
      e.size === "small" && { padding: "8.5px 14px" },
      e.multiline && { padding: 0 },
      e.startAdornment && { paddingLeft: 0 },
      e.endAdornment && { paddingRight: 0 }
    )
  ),
  d2 = ee.forwardRef(function (e, t) {
    var r, i, o, s, l;
    const u = Or({ props: e, name: "MuiOutlinedInput" }),
      {
        components: f = {},
        fullWidth: h = !1,
        inputComponent: m = "input",
        label: g,
        multiline: y = !1,
        notched: _,
        slots: S = {},
        type: x = "text",
      } = u,
      w = Ft(u, HN),
      T = GN(u),
      E = Lm(),
      A = Im({
        props: u,
        muiFormControl: E,
        states: [
          "color",
          "disabled",
          "error",
          "focused",
          "hiddenLabel",
          "size",
          "required",
        ],
      }),
      R = pe({}, u, {
        color: A.color || "primary",
        disabled: A.disabled,
        error: A.error,
        focused: A.focused,
        formControl: E,
        fullWidth: h,
        hiddenLabel: A.hiddenLabel,
        multiline: y,
        size: A.size,
        type: x,
      }),
      D = (r = (i = S.root) != null ? i : f.Root) != null ? r : WN,
      I = (o = (s = S.input) != null ? s : f.Input) != null ? o : $N;
    return ve.jsx(
      yS,
      pe(
        {
          slots: { root: D, input: I },
          renderSuffix: (U) =>
            ve.jsx(jN, {
              ownerState: R,
              className: T.notchedOutline,
              label:
                g != null && g !== "" && A.required
                  ? l || (l = ve.jsxs(ee.Fragment, { children: [g, " ", "*"] }))
                  : g,
              notched:
                typeof _ < "u"
                  ? _
                  : !!(U.startAdornment || U.filled || U.focused),
            }),
          fullWidth: h,
          inputComponent: m,
          multiline: y,
          ref: t,
          type: x,
        },
        w,
        { classes: pe({}, T, { notchedOutline: null }) }
      )
    );
  });
d2.muiName = "Input";
function XN(n) {
  return hr("MuiSelect", n);
}
const dp = Xn("MuiSelect", [
  "root",
  "select",
  "multiple",
  "filled",
  "outlined",
  "standard",
  "disabled",
  "focused",
  "icon",
  "iconOpen",
  "iconFilled",
  "iconOutlined",
  "iconStandard",
  "nativeInput",
  "error",
]);
var xb;
const YN = [
    "aria-describedby",
    "aria-label",
    "autoFocus",
    "autoWidth",
    "children",
    "className",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "displayEmpty",
    "error",
    "IconComponent",
    "inputRef",
    "labelId",
    "MenuProps",
    "multiple",
    "name",
    "onBlur",
    "onChange",
    "onClose",
    "onFocus",
    "onOpen",
    "open",
    "readOnly",
    "renderValue",
    "SelectDisplayProps",
    "tabIndex",
    "type",
    "value",
    "variant",
  ],
  qN = en("div", {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`&.${dp.select}`]: e.select },
        { [`&.${dp.select}`]: e[t.variant] },
        { [`&.${dp.error}`]: e.error },
        { [`&.${dp.multiple}`]: e.multiple },
      ];
    },
  })(c2, {
    [`&.${dp.select}`]: {
      height: "auto",
      minHeight: "1.4375em",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
    },
  }),
  KN = en("svg", {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.icon,
        t.variant && e[`icon${fn(t.variant)}`],
        t.open && e.iconOpen,
      ];
    },
  })(f2),
  ZN = en("input", {
    shouldForwardProp: (n) => JC(n) && n !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (n, e) => e.nativeInput,
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box",
  });
function _b(n, e) {
  return typeof e == "object" && e !== null ? n === e : String(n) === String(e);
}
function JN(n) {
  return n == null || (typeof n == "string" && !n.trim());
}
const QN = (n) => {
    const {
        classes: e,
        variant: t,
        disabled: r,
        multiple: i,
        open: o,
        error: s,
      } = n,
      l = {
        select: ["select", t, r && "disabled", i && "multiple", s && "error"],
        icon: ["icon", `icon${fn(t)}`, o && "iconOpen", r && "disabled"],
        nativeInput: ["nativeInput"],
      };
    return pr(l, XN, e);
  },
  eU = ee.forwardRef(function (e, t) {
    var r;
    const {
        "aria-describedby": i,
        "aria-label": o,
        autoFocus: s,
        autoWidth: l,
        children: u,
        className: f,
        defaultOpen: h,
        defaultValue: m,
        disabled: g,
        displayEmpty: y,
        error: _ = !1,
        IconComponent: S,
        inputRef: x,
        labelId: w,
        MenuProps: T = {},
        multiple: E,
        name: A,
        onBlur: R,
        onChange: D,
        onClose: I,
        onFocus: U,
        onOpen: O,
        open: L,
        readOnly: V,
        renderValue: H,
        SelectDisplayProps: $ = {},
        tabIndex: q,
        value: K,
        variant: Y = "standard",
      } = e,
      ne = Ft(e, YN),
      [j, re] = FM({ controlled: K, default: m, name: "Select" }),
      [B, G] = FM({ controlled: L, default: h, name: "Select" }),
      te = ee.useRef(null),
      le = ee.useRef(null),
      [J, oe] = ee.useState(null),
      { current: he } = ee.useRef(L != null),
      [ae, ue] = ee.useState(),
      Ee = xi(t, x),
      Ne = ee.useCallback(($e) => {
        (le.current = $e), $e && oe($e);
      }, []),
      Ae = J == null ? void 0 : J.parentNode;
    ee.useImperativeHandle(
      Ee,
      () => ({
        focus: () => {
          le.current.focus();
        },
        node: te.current,
        value: j,
      }),
      [j]
    ),
      ee.useEffect(() => {
        h &&
          B &&
          J &&
          !he &&
          (ue(l ? null : Ae.clientWidth), le.current.focus());
      }, [J, l]),
      ee.useEffect(() => {
        s && le.current.focus();
      }, [s]),
      ee.useEffect(() => {
        if (!w) return;
        const $e = rs(le.current).getElementById(w);
        if ($e) {
          const qe = () => {
            getSelection().isCollapsed && le.current.focus();
          };
          return (
            $e.addEventListener("click", qe),
            () => {
              $e.removeEventListener("click", qe);
            }
          );
        }
      }, [w]);
    const W = ($e, qe) => {
        $e ? O && O(qe) : I && I(qe),
          he || (ue(l ? null : Ae.clientWidth), G($e));
      },
      _e = ($e) => {
        $e.button === 0 && ($e.preventDefault(), le.current.focus(), W(!0, $e));
      },
      Te = ($e) => {
        W(!1, $e);
      },
      ke = ee.Children.toArray(u),
      Pe = ($e) => {
        const qe = ke.find((et) => et.props.value === $e.target.value);
        qe !== void 0 && (re(qe.props.value), D && D($e, qe));
      },
      rt = ($e) => (qe) => {
        let et;
        if (qe.currentTarget.hasAttribute("tabindex")) {
          if (E) {
            et = Array.isArray(j) ? j.slice() : [];
            const ce = j.indexOf($e.props.value);
            ce === -1 ? et.push($e.props.value) : et.splice(ce, 1);
          } else et = $e.props.value;
          if (
            ($e.props.onClick && $e.props.onClick(qe), j !== et && (re(et), D))
          ) {
            const ce = qe.nativeEvent || qe,
              Je = new ce.constructor(ce.type, ce);
            Object.defineProperty(Je, "target", {
              writable: !0,
              value: { value: et, name: A },
            }),
              D(Je, $e);
          }
          E || W(!1, qe);
        }
      },
      Le = ($e) => {
        V ||
          ([" ", "ArrowUp", "ArrowDown", "Enter"].indexOf($e.key) !== -1 &&
            ($e.preventDefault(), W(!0, $e)));
      },
      Xe = J !== null && B,
      Z = ($e) => {
        !Xe &&
          R &&
          (Object.defineProperty($e, "target", {
            writable: !0,
            value: { value: j, name: A },
          }),
          R($e));
      };
    delete ne["aria-invalid"];
    let F, me;
    const xe = [];
    let ye = !1;
    (i0({ value: j }) || y) && (H ? (F = H(j)) : (ye = !0));
    const Me = ke.map(($e) => {
      if (!ee.isValidElement($e)) return null;
      let qe;
      if (E) {
        if (!Array.isArray(j)) throw new Error(Rl(2));
        (qe = j.some((et) => _b(et, $e.props.value))),
          qe && ye && xe.push($e.props.children);
      } else (qe = _b(j, $e.props.value)), qe && ye && (me = $e.props.children);
      return ee.cloneElement($e, {
        "aria-selected": qe ? "true" : "false",
        onClick: rt($e),
        onKeyUp: (et) => {
          et.key === " " && et.preventDefault(),
            $e.props.onKeyUp && $e.props.onKeyUp(et);
        },
        role: "option",
        selected: qe,
        value: void 0,
        "data-value": $e.props.value,
      });
    });
    ye &&
      (E
        ? xe.length === 0
          ? (F = null)
          : (F = xe.reduce(
              ($e, qe, et) => (
                $e.push(qe), et < xe.length - 1 && $e.push(", "), $e
              ),
              []
            ))
        : (F = me));
    let at = ae;
    !l && he && J && (at = Ae.clientWidth);
    let Fe;
    typeof q < "u" ? (Fe = q) : (Fe = g ? null : 0);
    const ze = $.id || (A ? `mui-component-select-${A}` : void 0),
      We = pe({}, e, { variant: Y, value: j, open: Xe, error: _ }),
      Ye = QN(We),
      nt = pe({}, T.PaperProps, (r = T.slotProps) == null ? void 0 : r.paper),
      yt = DL();
    return ve.jsxs(ee.Fragment, {
      children: [
        ve.jsx(
          qN,
          pe(
            {
              ref: Ne,
              tabIndex: Fe,
              role: "combobox",
              "aria-controls": yt,
              "aria-disabled": g ? "true" : void 0,
              "aria-expanded": Xe ? "true" : "false",
              "aria-haspopup": "listbox",
              "aria-label": o,
              "aria-labelledby": [w, ze].filter(Boolean).join(" ") || void 0,
              "aria-describedby": i,
              onKeyDown: Le,
              onMouseDown: g || V ? null : _e,
              onBlur: Z,
              onFocus: U,
            },
            $,
            {
              ownerState: We,
              className: cn($.className, Ye.select, f),
              id: ze,
              children: JN(F)
                ? xb ||
                  (xb = ve.jsx("span", {
                    className: "notranslate",
                    children: "​",
                  }))
                : F,
            }
          )
        ),
        ve.jsx(
          ZN,
          pe(
            {
              "aria-invalid": _,
              value: Array.isArray(j) ? j.join(",") : j,
              name: A,
              ref: te,
              "aria-hidden": !0,
              onChange: Pe,
              tabIndex: -1,
              disabled: g,
              className: Ye.nativeInput,
              autoFocus: s,
              ownerState: We,
            },
            ne
          )
        ),
        ve.jsx(KN, { as: S, className: Ye.icon, ownerState: We }),
        ve.jsx(
          TN,
          pe(
            {
              id: `menu-${A || ""}`,
              anchorEl: Ae,
              open: Xe,
              onClose: Te,
              anchorOrigin: { vertical: "bottom", horizontal: "center" },
              transformOrigin: { vertical: "top", horizontal: "center" },
            },
            T,
            {
              MenuListProps: pe(
                {
                  "aria-labelledby": w,
                  role: "listbox",
                  "aria-multiselectable": E ? "true" : void 0,
                  disableListWrap: !0,
                  id: yt,
                },
                T.MenuListProps
              ),
              slotProps: pe({}, T.slotProps, {
                paper: pe({}, nt, {
                  style: pe({ minWidth: at }, nt != null ? nt.style : null),
                }),
              }),
              children: Me,
            }
          )
        ),
      ],
    });
  }),
  tU = [
    "autoWidth",
    "children",
    "classes",
    "className",
    "defaultOpen",
    "displayEmpty",
    "IconComponent",
    "id",
    "input",
    "inputProps",
    "label",
    "labelId",
    "MenuProps",
    "multiple",
    "native",
    "onClose",
    "onOpen",
    "open",
    "renderValue",
    "SelectDisplayProps",
    "variant",
  ],
  nU = ["root"],
  rU = (n) => {
    const { classes: e } = n;
    return e;
  },
  _S = {
    name: "MuiSelect",
    overridesResolver: (n, e) => e.root,
    shouldForwardProp: (n) => Rs(n) && n !== "variant",
    slot: "Root",
  },
  iU = en(a2, _S)(""),
  oU = en(d2, _S)(""),
  sU = en(i2, _S)(""),
  $v = ee.forwardRef(function (e, t) {
    const r = Or({ name: "MuiSelect", props: e }),
      {
        autoWidth: i = !1,
        children: o,
        classes: s = {},
        className: l,
        defaultOpen: u = !1,
        displayEmpty: f = !1,
        IconComponent: h = $k,
        id: m,
        input: g,
        inputProps: y,
        label: _,
        labelId: S,
        MenuProps: x,
        multiple: w = !1,
        native: T = !1,
        onClose: E,
        onOpen: A,
        open: R,
        renderValue: D,
        SelectDisplayProps: I,
        variant: U = "outlined",
      } = r,
      O = Ft(r, tU),
      L = T ? UN : eU,
      V = Lm(),
      H = Im({ props: r, muiFormControl: V, states: ["variant", "error"] }),
      $ = H.variant || U,
      q = pe({}, r, { variant: $, classes: s }),
      K = rU(q),
      Y = Ft(K, nU),
      ne =
        g ||
        {
          standard: ve.jsx(iU, { ownerState: q }),
          outlined: ve.jsx(oU, { label: _, ownerState: q }),
          filled: ve.jsx(sU, { ownerState: q }),
        }[$],
      j = xi(t, ne.ref);
    return ve.jsx(ee.Fragment, {
      children: ee.cloneElement(
        ne,
        pe(
          {
            inputComponent: L,
            inputProps: pe(
              {
                children: o,
                error: H.error,
                IconComponent: h,
                variant: $,
                type: void 0,
                multiple: w,
              },
              T
                ? { id: m }
                : {
                    autoWidth: i,
                    defaultOpen: u,
                    displayEmpty: f,
                    labelId: S,
                    MenuProps: x,
                    onClose: E,
                    onOpen: A,
                    open: R,
                    renderValue: D,
                    SelectDisplayProps: pe({ id: m }, I),
                  },
              y,
              { classes: y ? ti(Y, y.classes) : Y },
              g ? g.props.inputProps : {}
            ),
          },
          ((w && T) || f) && $ === "outlined" ? { notched: !0 } : {},
          { ref: j, className: cn(ne.props.className, l, K.root) },
          !g && { variant: $ },
          O
        )
      ),
    });
  });
$v.muiName = "Select";
function ia(n) {
  for (
    var e = arguments.length, t = Array(e > 1 ? e - 1 : 0), r = 1;
    r < e;
    r++
  )
    t[r - 1] = arguments[r];
  throw Error(
    "[Immer] minified error nr: " +
      n +
      (t.length
        ? " " +
          t
            .map(function (i) {
              return "'" + i + "'";
            })
            .join(",")
        : "") +
      ". Find the full error at: https://bit.ly/3cXEKWf"
  );
}
function zu(n) {
  return !!n && !!n[nr];
}
function Pl(n) {
  var e;
  return (
    !!n &&
    ((function (t) {
      if (!t || typeof t != "object") return !1;
      var r = Object.getPrototypeOf(t);
      if (r === null) return !0;
      var i = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
      return (
        i === Object ||
        (typeof i == "function" && Function.toString.call(i) === mU)
      );
    })(n) ||
      Array.isArray(n) ||
      !!n[Cb] ||
      !!(!((e = n.constructor) === null || e === void 0) && e[Cb]) ||
      SS(n) ||
      wS(n))
  );
}
function sf(n, e, t) {
  t === void 0 && (t = !1),
    gh(n) === 0
      ? (t ? Object.keys : nh)(n).forEach(function (r) {
          (t && typeof r == "symbol") || e(r, n[r], n);
        })
      : n.forEach(function (r, i) {
          return e(i, r, n);
        });
}
function gh(n) {
  var e = n[nr];
  return e
    ? e.i > 3
      ? e.i - 4
      : e.i
    : Array.isArray(n)
    ? 1
    : SS(n)
    ? 2
    : wS(n)
    ? 3
    : 0;
}
function th(n, e) {
  return gh(n) === 2 ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e);
}
function aU(n, e) {
  return gh(n) === 2 ? n.get(e) : n[e];
}
function h2(n, e, t) {
  var r = gh(n);
  r === 2 ? n.set(e, t) : r === 3 ? n.add(t) : (n[e] = t);
}
function p2(n, e) {
  return n === e ? n !== 0 || 1 / n == 1 / e : n != n && e != e;
}
function SS(n) {
  return hU && n instanceof Map;
}
function wS(n) {
  return pU && n instanceof Set;
}
function Bc(n) {
  return n.o || n.t;
}
function MS(n) {
  if (Array.isArray(n)) return Array.prototype.slice.call(n);
  var e = g2(n);
  delete e[nr];
  for (var t = nh(e), r = 0; r < t.length; r++) {
    var i = t[r],
      o = e[i];
    o.writable === !1 && ((o.writable = !0), (o.configurable = !0)),
      (o.get || o.set) &&
        (e[i] = {
          configurable: !0,
          writable: !0,
          enumerable: o.enumerable,
          value: n[i],
        });
  }
  return Object.create(Object.getPrototypeOf(n), e);
}
function bS(n, e) {
  return (
    e === void 0 && (e = !1),
    ES(n) ||
      zu(n) ||
      !Pl(n) ||
      (gh(n) > 1 && (n.set = n.add = n.clear = n.delete = lU),
      Object.freeze(n),
      e &&
        sf(
          n,
          function (t, r) {
            return bS(r, !0);
          },
          !0
        )),
    n
  );
}
function lU() {
  ia(2);
}
function ES(n) {
  return n == null || typeof n != "object" || Object.isFrozen(n);
}
function za(n) {
  var e = T1[n];
  return e || ia(18, n), e;
}
function uU(n, e) {
  T1[n] || (T1[n] = e);
}
function M1() {
  return rm;
}
function Jx(n, e) {
  e && (za("Patches"), (n.u = []), (n.s = []), (n.v = e));
}
function o0(n) {
  b1(n), n.p.forEach(cU), (n.p = null);
}
function b1(n) {
  n === rm && (rm = n.l);
}
function Sb(n) {
  return (rm = { p: [], l: rm, h: n, m: !0, _: 0 });
}
function cU(n) {
  var e = n[nr];
  e.i === 0 || e.i === 1 ? e.j() : (e.g = !0);
}
function Qx(n, e) {
  e._ = e.p.length;
  var t = e.p[0],
    r = n !== void 0 && n !== t;
  return (
    e.h.O || za("ES5").S(e, n, r),
    r
      ? (t[nr].P && (o0(e), ia(4)),
        Pl(n) && ((n = s0(e, n)), e.l || a0(e, n)),
        e.u && za("Patches").M(t[nr].t, n, e.u, e.s))
      : (n = s0(e, t, [])),
    o0(e),
    e.u && e.v(e.u, e.s),
    n !== m2 ? n : void 0
  );
}
function s0(n, e, t) {
  if (ES(e)) return e;
  var r = e[nr];
  if (!r)
    return (
      sf(
        e,
        function (l, u) {
          return wb(n, r, e, l, u, t);
        },
        !0
      ),
      e
    );
  if (r.A !== n) return e;
  if (!r.P) return a0(n, r.t, !0), r.t;
  if (!r.I) {
    (r.I = !0), r.A._--;
    var i = r.i === 4 || r.i === 5 ? (r.o = MS(r.k)) : r.o,
      o = i,
      s = !1;
    r.i === 3 && ((o = new Set(i)), i.clear(), (s = !0)),
      sf(o, function (l, u) {
        return wb(n, r, i, l, u, t, s);
      }),
      a0(n, i, !1),
      t && n.u && za("Patches").N(r, t, n.u, n.s);
  }
  return r.o;
}
function wb(n, e, t, r, i, o, s) {
  if (zu(i)) {
    var l = s0(n, i, o && e && e.i !== 3 && !th(e.R, r) ? o.concat(r) : void 0);
    if ((h2(t, r, l), !zu(l))) return;
    n.m = !1;
  } else s && t.add(i);
  if (Pl(i) && !ES(i)) {
    if (!n.h.D && n._ < 1) return;
    s0(n, i), (e && e.A.l) || a0(n, i);
  }
}
function a0(n, e, t) {
  t === void 0 && (t = !1), !n.l && n.h.D && n.m && bS(e, t);
}
function e_(n, e) {
  var t = n[nr];
  return (t ? Bc(t) : n)[e];
}
function Mb(n, e) {
  if (e in n)
    for (var t = Object.getPrototypeOf(n); t; ) {
      var r = Object.getOwnPropertyDescriptor(t, e);
      if (r) return r;
      t = Object.getPrototypeOf(t);
    }
}
function Iu(n) {
  n.P || ((n.P = !0), n.l && Iu(n.l));
}
function t_(n) {
  n.o || (n.o = MS(n.t));
}
function E1(n, e, t) {
  var r = SS(e)
    ? za("MapSet").F(e, t)
    : wS(e)
    ? za("MapSet").T(e, t)
    : n.O
    ? (function (i, o) {
        var s = Array.isArray(i),
          l = {
            i: s ? 1 : 0,
            A: o ? o.A : M1(),
            P: !1,
            I: !1,
            R: {},
            l: o,
            t: i,
            k: null,
            o: null,
            j: null,
            C: !1,
          },
          u = l,
          f = im;
        s && ((u = [l]), (f = Ip));
        var h = Proxy.revocable(u, f),
          m = h.revoke,
          g = h.proxy;
        return (l.k = g), (l.j = m), g;
      })(e, t)
    : za("ES5").J(e, t);
  return (t ? t.A : M1()).p.push(r), r;
}
function fU(n) {
  return (
    zu(n) || ia(22, n),
    (function e(t) {
      if (!Pl(t)) return t;
      var r,
        i = t[nr],
        o = gh(t);
      if (i) {
        if (!i.P && (i.i < 4 || !za("ES5").K(i))) return i.t;
        (i.I = !0), (r = bb(t, o)), (i.I = !1);
      } else r = bb(t, o);
      return (
        sf(r, function (s, l) {
          (i && aU(i.t, s) === l) || h2(r, s, e(l));
        }),
        o === 3 ? new Set(r) : r
      );
    })(n)
  );
}
function bb(n, e) {
  switch (e) {
    case 2:
      return new Map(n);
    case 3:
      return Array.from(n);
  }
  return MS(n);
}
function dU() {
  function n(o, s) {
    var l = i[o];
    return (
      l
        ? (l.enumerable = s)
        : (i[o] = l =
            {
              configurable: !0,
              enumerable: s,
              get: function () {
                var u = this[nr];
                return im.get(u, o);
              },
              set: function (u) {
                var f = this[nr];
                im.set(f, o, u);
              },
            }),
      l
    );
  }
  function e(o) {
    for (var s = o.length - 1; s >= 0; s--) {
      var l = o[s][nr];
      if (!l.P)
        switch (l.i) {
          case 5:
            r(l) && Iu(l);
            break;
          case 4:
            t(l) && Iu(l);
        }
    }
  }
  function t(o) {
    for (var s = o.t, l = o.k, u = nh(l), f = u.length - 1; f >= 0; f--) {
      var h = u[f];
      if (h !== nr) {
        var m = s[h];
        if (m === void 0 && !th(s, h)) return !0;
        var g = l[h],
          y = g && g[nr];
        if (y ? y.t !== m : !p2(g, m)) return !0;
      }
    }
    var _ = !!s[nr];
    return u.length !== nh(s).length + (_ ? 0 : 1);
  }
  function r(o) {
    var s = o.k;
    if (s.length !== o.t.length) return !0;
    var l = Object.getOwnPropertyDescriptor(s, s.length - 1);
    if (l && !l.get) return !0;
    for (var u = 0; u < s.length; u++) if (!s.hasOwnProperty(u)) return !0;
    return !1;
  }
  var i = {};
  uU("ES5", {
    J: function (o, s) {
      var l = Array.isArray(o),
        u = (function (h, m) {
          if (h) {
            for (var g = Array(m.length), y = 0; y < m.length; y++)
              Object.defineProperty(g, "" + y, n(y, !0));
            return g;
          }
          var _ = g2(m);
          delete _[nr];
          for (var S = nh(_), x = 0; x < S.length; x++) {
            var w = S[x];
            _[w] = n(w, h || !!_[w].enumerable);
          }
          return Object.create(Object.getPrototypeOf(m), _);
        })(l, o),
        f = {
          i: l ? 5 : 4,
          A: s ? s.A : M1(),
          P: !1,
          I: !1,
          R: {},
          l: s,
          t: o,
          k: u,
          o: null,
          g: !1,
          C: !1,
        };
      return Object.defineProperty(u, nr, { value: f, writable: !0 }), u;
    },
    S: function (o, s, l) {
      l
        ? zu(s) && s[nr].A === o && e(o.p)
        : (o.u &&
            (function u(f) {
              if (f && typeof f == "object") {
                var h = f[nr];
                if (h) {
                  var m = h.t,
                    g = h.k,
                    y = h.R,
                    _ = h.i;
                  if (_ === 4)
                    sf(g, function (E) {
                      E !== nr &&
                        (m[E] !== void 0 || th(m, E)
                          ? y[E] || u(g[E])
                          : ((y[E] = !0), Iu(h)));
                    }),
                      sf(m, function (E) {
                        g[E] !== void 0 || th(g, E) || ((y[E] = !1), Iu(h));
                      });
                  else if (_ === 5) {
                    if ((r(h) && (Iu(h), (y.length = !0)), g.length < m.length))
                      for (var S = g.length; S < m.length; S++) y[S] = !1;
                    else for (var x = m.length; x < g.length; x++) y[x] = !0;
                    for (
                      var w = Math.min(g.length, m.length), T = 0;
                      T < w;
                      T++
                    )
                      g.hasOwnProperty(T) || (y[T] = !0),
                        y[T] === void 0 && u(g[T]);
                  }
                }
              }
            })(o.p[0]),
          e(o.p));
    },
    K: function (o) {
      return o.i === 4 ? t(o) : r(o);
    },
  });
}
var Eb,
  rm,
  TS = typeof Symbol < "u" && typeof Symbol("x") == "symbol",
  hU = typeof Map < "u",
  pU = typeof Set < "u",
  Tb = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u",
  m2 = TS
    ? Symbol.for("immer-nothing")
    : (((Eb = {})["immer-nothing"] = !0), Eb),
  Cb = TS ? Symbol.for("immer-draftable") : "__$immer_draftable",
  nr = TS ? Symbol.for("immer-state") : "__$immer_state",
  mU = "" + Object.prototype.constructor,
  nh =
    typeof Reflect < "u" && Reflect.ownKeys
      ? Reflect.ownKeys
      : Object.getOwnPropertySymbols !== void 0
      ? function (n) {
          return Object.getOwnPropertyNames(n).concat(
            Object.getOwnPropertySymbols(n)
          );
        }
      : Object.getOwnPropertyNames,
  g2 =
    Object.getOwnPropertyDescriptors ||
    function (n) {
      var e = {};
      return (
        nh(n).forEach(function (t) {
          e[t] = Object.getOwnPropertyDescriptor(n, t);
        }),
        e
      );
    },
  T1 = {},
  im = {
    get: function (n, e) {
      if (e === nr) return n;
      var t = Bc(n);
      if (!th(t, e))
        return (function (i, o, s) {
          var l,
            u = Mb(o, s);
          return u
            ? "value" in u
              ? u.value
              : (l = u.get) === null || l === void 0
              ? void 0
              : l.call(i.k)
            : void 0;
        })(n, t, e);
      var r = t[e];
      return n.I || !Pl(r)
        ? r
        : r === e_(n.t, e)
        ? (t_(n), (n.o[e] = E1(n.A.h, r, n)))
        : r;
    },
    has: function (n, e) {
      return e in Bc(n);
    },
    ownKeys: function (n) {
      return Reflect.ownKeys(Bc(n));
    },
    set: function (n, e, t) {
      var r = Mb(Bc(n), e);
      if (r != null && r.set) return r.set.call(n.k, t), !0;
      if (!n.P) {
        var i = e_(Bc(n), e),
          o = i == null ? void 0 : i[nr];
        if (o && o.t === t) return (n.o[e] = t), (n.R[e] = !1), !0;
        if (p2(t, i) && (t !== void 0 || th(n.t, e))) return !0;
        t_(n), Iu(n);
      }
      return (
        (n.o[e] === t && (t !== void 0 || e in n.o)) ||
          (Number.isNaN(t) && Number.isNaN(n.o[e])) ||
          ((n.o[e] = t), (n.R[e] = !0)),
        !0
      );
    },
    deleteProperty: function (n, e) {
      return (
        e_(n.t, e) !== void 0 || e in n.t
          ? ((n.R[e] = !1), t_(n), Iu(n))
          : delete n.R[e],
        n.o && delete n.o[e],
        !0
      );
    },
    getOwnPropertyDescriptor: function (n, e) {
      var t = Bc(n),
        r = Reflect.getOwnPropertyDescriptor(t, e);
      return (
        r && {
          writable: !0,
          configurable: n.i !== 1 || e !== "length",
          enumerable: r.enumerable,
          value: t[e],
        }
      );
    },
    defineProperty: function () {
      ia(11);
    },
    getPrototypeOf: function (n) {
      return Object.getPrototypeOf(n.t);
    },
    setPrototypeOf: function () {
      ia(12);
    },
  },
  Ip = {};
sf(im, function (n, e) {
  Ip[n] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
}),
  (Ip.deleteProperty = function (n, e) {
    return Ip.set.call(this, n, e, void 0);
  }),
  (Ip.set = function (n, e, t) {
    return im.set.call(this, n[0], e, t, n[0]);
  });
var gU = (function () {
    function n(t) {
      var r = this;
      (this.O = Tb),
        (this.D = !0),
        (this.produce = function (i, o, s) {
          if (typeof i == "function" && typeof o != "function") {
            var l = o;
            o = i;
            var u = r;
            return function (S) {
              var x = this;
              S === void 0 && (S = l);
              for (
                var w = arguments.length, T = Array(w > 1 ? w - 1 : 0), E = 1;
                E < w;
                E++
              )
                T[E - 1] = arguments[E];
              return u.produce(S, function (A) {
                var R;
                return (R = o).call.apply(R, [x, A].concat(T));
              });
            };
          }
          var f;
          if (
            (typeof o != "function" && ia(6),
            s !== void 0 && typeof s != "function" && ia(7),
            Pl(i))
          ) {
            var h = Sb(r),
              m = E1(r, i, void 0),
              g = !0;
            try {
              (f = o(m)), (g = !1);
            } finally {
              g ? o0(h) : b1(h);
            }
            return typeof Promise < "u" && f instanceof Promise
              ? f.then(
                  function (S) {
                    return Jx(h, s), Qx(S, h);
                  },
                  function (S) {
                    throw (o0(h), S);
                  }
                )
              : (Jx(h, s), Qx(f, h));
          }
          if (!i || typeof i != "object") {
            if (
              ((f = o(i)) === void 0 && (f = i),
              f === m2 && (f = void 0),
              r.D && bS(f, !0),
              s)
            ) {
              var y = [],
                _ = [];
              za("Patches").M(i, f, y, _), s(y, _);
            }
            return f;
          }
          ia(21, i);
        }),
        (this.produceWithPatches = function (i, o) {
          if (typeof i == "function")
            return function (f) {
              for (
                var h = arguments.length, m = Array(h > 1 ? h - 1 : 0), g = 1;
                g < h;
                g++
              )
                m[g - 1] = arguments[g];
              return r.produceWithPatches(f, function (y) {
                return i.apply(void 0, [y].concat(m));
              });
            };
          var s,
            l,
            u = r.produce(i, o, function (f, h) {
              (s = f), (l = h);
            });
          return typeof Promise < "u" && u instanceof Promise
            ? u.then(function (f) {
                return [f, s, l];
              })
            : [u, s, l];
        }),
        typeof (t == null ? void 0 : t.useProxies) == "boolean" &&
          this.setUseProxies(t.useProxies),
        typeof (t == null ? void 0 : t.autoFreeze) == "boolean" &&
          this.setAutoFreeze(t.autoFreeze);
    }
    var e = n.prototype;
    return (
      (e.createDraft = function (t) {
        Pl(t) || ia(8), zu(t) && (t = fU(t));
        var r = Sb(this),
          i = E1(this, t, void 0);
        return (i[nr].C = !0), b1(r), i;
      }),
      (e.finishDraft = function (t, r) {
        var i = t && t[nr],
          o = i.A;
        return Jx(o, r), Qx(void 0, o);
      }),
      (e.setAutoFreeze = function (t) {
        this.D = t;
      }),
      (e.setUseProxies = function (t) {
        t && !Tb && ia(20), (this.O = t);
      }),
      (e.applyPatches = function (t, r) {
        var i;
        for (i = r.length - 1; i >= 0; i--) {
          var o = r[i];
          if (o.path.length === 0 && o.op === "replace") {
            t = o.value;
            break;
          }
        }
        i > -1 && (r = r.slice(i + 1));
        var s = za("Patches").$;
        return zu(t)
          ? s(t, r)
          : this.produce(t, function (l) {
              return s(l, r);
            });
      }),
      n
    );
  })(),
  os = new gU(),
  v2 = os.produce;
os.produceWithPatches.bind(os);
os.setAutoFreeze.bind(os);
os.setUseProxies.bind(os);
os.applyPatches.bind(os);
os.createDraft.bind(os);
os.finishDraft.bind(os);
function vU(n, e, t) {
  return (
    (e = YC(e)) in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function Ab(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable;
      })),
      t.push.apply(t, r);
  }
  return t;
}
function Rb(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? Ab(Object(t), !0).forEach(function (r) {
          vU(n, r, t[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : Ab(Object(t)).forEach(function (r) {
          Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
        });
  }
  return n;
}
function qi(n) {
  return (
    "Minified Redux error #" +
    n +
    "; visit https://redux.js.org/Errors?code=" +
    n +
    " for the full message or use the non-minified dev environment for full errors. "
  );
}
var Pb = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })(),
  n_ = function () {
    return Math.random().toString(36).substring(7).split("").join(".");
  },
  l0 = {
    INIT: "@@redux/INIT" + n_(),
    REPLACE: "@@redux/REPLACE" + n_(),
    PROBE_UNKNOWN_ACTION: function () {
      return "@@redux/PROBE_UNKNOWN_ACTION" + n_();
    },
  };
function yU(n) {
  if (typeof n != "object" || n === null) return !1;
  for (var e = n; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(n) === e;
}
function y2(n, e, t) {
  var r;
  if (
    (typeof e == "function" && typeof t == "function") ||
    (typeof t == "function" && typeof arguments[3] == "function")
  )
    throw new Error(qi(0));
  if (
    (typeof e == "function" && typeof t > "u" && ((t = e), (e = void 0)),
    typeof t < "u")
  ) {
    if (typeof t != "function") throw new Error(qi(1));
    return t(y2)(n, e);
  }
  if (typeof n != "function") throw new Error(qi(2));
  var i = n,
    o = e,
    s = [],
    l = s,
    u = !1;
  function f() {
    l === s && (l = s.slice());
  }
  function h() {
    if (u) throw new Error(qi(3));
    return o;
  }
  function m(S) {
    if (typeof S != "function") throw new Error(qi(4));
    if (u) throw new Error(qi(5));
    var x = !0;
    return (
      f(),
      l.push(S),
      function () {
        if (x) {
          if (u) throw new Error(qi(6));
          (x = !1), f();
          var T = l.indexOf(S);
          l.splice(T, 1), (s = null);
        }
      }
    );
  }
  function g(S) {
    if (!yU(S)) throw new Error(qi(7));
    if (typeof S.type > "u") throw new Error(qi(8));
    if (u) throw new Error(qi(9));
    try {
      (u = !0), (o = i(o, S));
    } finally {
      u = !1;
    }
    for (var x = (s = l), w = 0; w < x.length; w++) {
      var T = x[w];
      T();
    }
    return S;
  }
  function y(S) {
    if (typeof S != "function") throw new Error(qi(10));
    (i = S), g({ type: l0.REPLACE });
  }
  function _() {
    var S,
      x = m;
    return (
      (S = {
        subscribe: function (T) {
          if (typeof T != "object" || T === null) throw new Error(qi(11));
          function E() {
            T.next && T.next(h());
          }
          E();
          var A = x(E);
          return { unsubscribe: A };
        },
      }),
      (S[Pb] = function () {
        return this;
      }),
      S
    );
  }
  return (
    g({ type: l0.INIT }),
    (r = { dispatch: g, subscribe: m, getState: h, replaceReducer: y }),
    (r[Pb] = _),
    r
  );
}
function xU(n) {
  Object.keys(n).forEach(function (e) {
    var t = n[e],
      r = t(void 0, { type: l0.INIT });
    if (typeof r > "u") throw new Error(qi(12));
    if (typeof t(void 0, { type: l0.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(qi(13));
  });
}
function _U(n) {
  for (var e = Object.keys(n), t = {}, r = 0; r < e.length; r++) {
    var i = e[r];
    typeof n[i] == "function" && (t[i] = n[i]);
  }
  var o = Object.keys(t),
    s;
  try {
    xU(t);
  } catch (l) {
    s = l;
  }
  return function (u, f) {
    if ((u === void 0 && (u = {}), s)) throw s;
    for (var h = !1, m = {}, g = 0; g < o.length; g++) {
      var y = o[g],
        _ = t[y],
        S = u[y],
        x = _(S, f);
      if (typeof x > "u") throw (f && f.type, new Error(qi(14)));
      (m[y] = x), (h = h || x !== S);
    }
    return (h = h || o.length !== Object.keys(u).length), h ? m : u;
  };
}
function u0() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return e.length === 0
    ? function (r) {
        return r;
      }
    : e.length === 1
    ? e[0]
    : e.reduce(function (r, i) {
        return function () {
          return r(i.apply(void 0, arguments));
        };
      });
}
function SU() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return function (r) {
    return function () {
      var i = r.apply(void 0, arguments),
        o = function () {
          throw new Error(qi(15));
        },
        s = {
          getState: i.getState,
          dispatch: function () {
            return o.apply(void 0, arguments);
          },
        },
        l = e.map(function (u) {
          return u(s);
        });
      return (
        (o = u0.apply(void 0, l)(i.dispatch)),
        Rb(Rb({}, i), {}, { dispatch: o })
      );
    };
  };
}
function x2(n) {
  var e = function (r) {
    var i = r.dispatch,
      o = r.getState;
    return function (s) {
      return function (l) {
        return typeof l == "function" ? l(i, o, n) : s(l);
      };
    };
  };
  return e;
}
var C1 = x2();
C1.withExtraArgument = x2;
var _2 = (function () {
    var n = function (e, t) {
      return (
        (n =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
          }),
        n(e, t)
      );
    };
    return function (e, t) {
      if (typeof t != "function" && t !== null)
        throw new TypeError(
          "Class extends value " + String(t) + " is not a constructor or null"
        );
      n(e, t);
      function r() {
        this.constructor = e;
      }
      e.prototype =
        t === null ? Object.create(t) : ((r.prototype = t.prototype), new r());
    };
  })(),
  wU = function (n, e) {
    var t = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      s;
    return (
      (s = { next: l(0), throw: l(1), return: l(2) }),
      typeof Symbol == "function" &&
        (s[Symbol.iterator] = function () {
          return this;
        }),
      s
    );
    function l(f) {
      return function (h) {
        return u([f, h]);
      };
    }
    function u(f) {
      if (r) throw new TypeError("Generator is already executing.");
      for (; t; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                f[0] & 2
                  ? i.return
                  : f[0]
                  ? i.throw || ((o = i.return) && o.call(i), 0)
                  : i.next) &&
              !(o = o.call(i, f[1])).done)
          )
            return o;
          switch (((i = 0), o && (f = [f[0] & 2, o.value]), f[0])) {
            case 0:
            case 1:
              o = f;
              break;
            case 4:
              return t.label++, { value: f[1], done: !1 };
            case 5:
              t.label++, (i = f[1]), (f = [0]);
              continue;
            case 7:
              (f = t.ops.pop()), t.trys.pop();
              continue;
            default:
              if (
                ((o = t.trys),
                !(o = o.length > 0 && o[o.length - 1]) &&
                  (f[0] === 6 || f[0] === 2))
              ) {
                t = 0;
                continue;
              }
              if (f[0] === 3 && (!o || (f[1] > o[0] && f[1] < o[3]))) {
                t.label = f[1];
                break;
              }
              if (f[0] === 6 && t.label < o[1]) {
                (t.label = o[1]), (o = f);
                break;
              }
              if (o && t.label < o[2]) {
                (t.label = o[2]), t.ops.push(f);
                break;
              }
              o[2] && t.ops.pop(), t.trys.pop();
              continue;
          }
          f = e.call(n, t);
        } catch (h) {
          (f = [6, h]), (i = 0);
        } finally {
          r = o = 0;
        }
      if (f[0] & 5) throw f[1];
      return { value: f[0] ? f[1] : void 0, done: !0 };
    }
  },
  lh = function (n, e) {
    for (var t = 0, r = e.length, i = n.length; t < r; t++, i++) n[i] = e[t];
    return n;
  },
  MU = Object.defineProperty,
  bU = Object.defineProperties,
  EU = Object.getOwnPropertyDescriptors,
  Ib = Object.getOwnPropertySymbols,
  TU = Object.prototype.hasOwnProperty,
  CU = Object.prototype.propertyIsEnumerable,
  Lb = function (n, e, t) {
    return e in n
      ? MU(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t);
  },
  ku = function (n, e) {
    for (var t in e || (e = {})) TU.call(e, t) && Lb(n, t, e[t]);
    if (Ib)
      for (var r = 0, i = Ib(e); r < i.length; r++) {
        var t = i[r];
        CU.call(e, t) && Lb(n, t, e[t]);
      }
    return n;
  },
  r_ = function (n, e) {
    return bU(n, EU(e));
  },
  AU = function (n, e, t) {
    return new Promise(function (r, i) {
      var o = function (u) {
          try {
            l(t.next(u));
          } catch (f) {
            i(f);
          }
        },
        s = function (u) {
          try {
            l(t.throw(u));
          } catch (f) {
            i(f);
          }
        },
        l = function (u) {
          return u.done ? r(u.value) : Promise.resolve(u.value).then(o, s);
        };
      l((t = t.apply(n, e)).next());
    });
  },
  RU =
    typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == "object"
              ? u0
              : u0.apply(null, arguments);
        };
function PU(n) {
  if (typeof n != "object" || n === null) return !1;
  var e = Object.getPrototypeOf(n);
  if (e === null) return !0;
  for (var t = e; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return e === t;
}
function Ou(n, e) {
  function t() {
    for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
    if (e) {
      var o = e.apply(void 0, r);
      if (!o) throw new Error("prepareAction did not return an object");
      return ku(
        ku({ type: n, payload: o.payload }, "meta" in o && { meta: o.meta }),
        "error" in o && { error: o.error }
      );
    }
    return { type: n, payload: r[0] };
  }
  return (
    (t.toString = function () {
      return "" + n;
    }),
    (t.type = n),
    (t.match = function (r) {
      return r.type === n;
    }),
    t
  );
}
var IU = (function (n) {
    _2(e, n);
    function e() {
      for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
      var i = n.apply(this, t) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return n.prototype.concat.apply(this, t);
      }),
      (e.prototype.prepend = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return t.length === 1 && Array.isArray(t[0])
          ? new (e.bind.apply(e, lh([void 0], t[0].concat(this))))()
          : new (e.bind.apply(e, lh([void 0], t.concat(this))))();
      }),
      e
    );
  })(Array),
  LU = (function (n) {
    _2(e, n);
    function e() {
      for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
      var i = n.apply(this, t) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return n.prototype.concat.apply(this, t);
      }),
      (e.prototype.prepend = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return t.length === 1 && Array.isArray(t[0])
          ? new (e.bind.apply(e, lh([void 0], t[0].concat(this))))()
          : new (e.bind.apply(e, lh([void 0], t.concat(this))))();
      }),
      e
    );
  })(Array);
function A1(n) {
  return Pl(n) ? v2(n, function () {}) : n;
}
function DU(n) {
  return typeof n == "boolean";
}
function kU() {
  return function (e) {
    return OU(e);
  };
}
function OU(n) {
  n === void 0 && (n = {});
  var e = n.thunk,
    t = e === void 0 ? !0 : e;
  n.immutableCheck, n.serializableCheck, n.actionCreatorCheck;
  var r = new IU();
  return (
    t && (DU(t) ? r.push(C1) : r.push(C1.withExtraArgument(t.extraArgument))), r
  );
}
function NU(n) {
  var e = kU(),
    t = n || {},
    r = t.reducer,
    i = r === void 0 ? void 0 : r,
    o = t.middleware,
    s = o === void 0 ? e() : o,
    l = t.devTools,
    u = l === void 0 ? !0 : l,
    f = t.preloadedState,
    h = f === void 0 ? void 0 : f,
    m = t.enhancers,
    g = m === void 0 ? void 0 : m,
    y;
  if (typeof i == "function") y = i;
  else if (PU(i)) y = _U(i);
  else
    throw new Error(
      '"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'
    );
  var _ = s;
  typeof _ == "function" && (_ = _(e));
  var S = SU.apply(void 0, _),
    x = u0;
  u && (x = RU(ku({ trace: !1 }, typeof u == "object" && u)));
  var w = new LU(S),
    T = w;
  Array.isArray(g) ? (T = lh([S], g)) : typeof g == "function" && (T = g(w));
  var E = x.apply(void 0, T);
  return y2(y, h, E);
}
function S2(n) {
  var e = {},
    t = [],
    r,
    i = {
      addCase: function (o, s) {
        var l = typeof o == "string" ? o : o.type;
        if (!l)
          throw new Error(
            "`builder.addCase` cannot be called with an empty action type"
          );
        if (l in e)
          throw new Error(
            "`builder.addCase` cannot be called with two reducers for the same action type"
          );
        return (e[l] = s), i;
      },
      addMatcher: function (o, s) {
        return t.push({ matcher: o, reducer: s }), i;
      },
      addDefaultCase: function (o) {
        return (r = o), i;
      },
    };
  return n(i), [e, t, r];
}
function UU(n) {
  return typeof n == "function";
}
function FU(n, e, t, r) {
  t === void 0 && (t = []);
  var i = typeof e == "function" ? S2(e) : [e, t, r],
    o = i[0],
    s = i[1],
    l = i[2],
    u;
  if (UU(n))
    u = function () {
      return A1(n());
    };
  else {
    var f = A1(n);
    u = function () {
      return f;
    };
  }
  function h(m, g) {
    m === void 0 && (m = u());
    var y = lh(
      [o[g.type]],
      s
        .filter(function (_) {
          var S = _.matcher;
          return S(g);
        })
        .map(function (_) {
          var S = _.reducer;
          return S;
        })
    );
    return (
      y.filter(function (_) {
        return !!_;
      }).length === 0 && (y = [l]),
      y.reduce(function (_, S) {
        if (S)
          if (zu(_)) {
            var x = _,
              w = S(x, g);
            return w === void 0 ? _ : w;
          } else {
            if (Pl(_))
              return v2(_, function (T) {
                return S(T, g);
              });
            var w = S(_, g);
            if (w === void 0) {
              if (_ === null) return _;
              throw Error(
                "A case reducer on a non-draftable value must not return undefined"
              );
            }
            return w;
          }
        return _;
      }, m)
    );
  }
  return (h.getInitialState = u), h;
}
function zU(n, e) {
  return n + "/" + e;
}
function BU(n) {
  var e = n.name,
    t =
      typeof n.initialState == "function" ? n.initialState : A1(n.initialState),
    r = n.reducers || {},
    i = Object.keys(r),
    o = {},
    s = {},
    l = {};
  i.forEach(function (h) {
    var m = r[h],
      g = zU(e, h),
      y,
      _;
    "reducer" in m ? ((y = m.reducer), (_ = m.prepare)) : (y = m),
      (o[h] = y),
      (s[g] = y),
      (l[h] = _ ? Ou(g, _) : Ou(g));
  });
  function u() {
    var h =
        typeof n.extraReducers == "function"
          ? S2(n.extraReducers)
          : [n.extraReducers],
      m = h[0],
      g = m === void 0 ? {} : m,
      y = h[1],
      _ = y === void 0 ? [] : y,
      S = h[2],
      x = S === void 0 ? void 0 : S,
      w = ku(ku({}, g), s);
    return FU(t, function (T) {
      for (var E in w) T.addCase(E, w[E]);
      for (var A = 0, R = _; A < R.length; A++) {
        var D = R[A];
        T.addMatcher(D.matcher, D.reducer);
      }
      x && T.addDefaultCase(x);
    });
  }
  var f;
  return {
    name: e,
    reducer: function (h, m) {
      return f || (f = u()), f(h, m);
    },
    actions: l,
    caseReducers: o,
    getInitialState: function () {
      return f || (f = u()), f.getInitialState();
    },
  };
}
var VU = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  HU = function (n) {
    n === void 0 && (n = 21);
    for (var e = "", t = n; t--; ) e += VU[(Math.random() * 64) | 0];
    return e;
  },
  GU = ["name", "message", "stack", "code"],
  i_ = (function () {
    function n(e, t) {
      (this.payload = e), (this.meta = t);
    }
    return n;
  })(),
  Db = (function () {
    function n(e, t) {
      (this.payload = e), (this.meta = t);
    }
    return n;
  })(),
  WU = function (n) {
    if (typeof n == "object" && n !== null) {
      for (var e = {}, t = 0, r = GU; t < r.length; t++) {
        var i = r[t];
        typeof n[i] == "string" && (e[i] = n[i]);
      }
      return e;
    }
    return { message: String(n) };
  };
(function () {
  function n(e, t, r) {
    var i = Ou(e + "/fulfilled", function (f, h, m, g) {
        return {
          payload: f,
          meta: r_(ku({}, g || {}), {
            arg: m,
            requestId: h,
            requestStatus: "fulfilled",
          }),
        };
      }),
      o = Ou(e + "/pending", function (f, h, m) {
        return {
          payload: void 0,
          meta: r_(ku({}, m || {}), {
            arg: h,
            requestId: f,
            requestStatus: "pending",
          }),
        };
      }),
      s = Ou(e + "/rejected", function (f, h, m, g, y) {
        return {
          payload: g,
          error: ((r && r.serializeError) || WU)(f || "Rejected"),
          meta: r_(ku({}, y || {}), {
            arg: m,
            requestId: h,
            rejectedWithValue: !!g,
            requestStatus: "rejected",
            aborted: (f == null ? void 0 : f.name) === "AbortError",
            condition: (f == null ? void 0 : f.name) === "ConditionError",
          }),
        };
      }),
      l =
        typeof AbortController < "u"
          ? AbortController
          : (function () {
              function f() {
                this.signal = {
                  aborted: !1,
                  addEventListener: function () {},
                  dispatchEvent: function () {
                    return !1;
                  },
                  onabort: function () {},
                  removeEventListener: function () {},
                  reason: void 0,
                  throwIfAborted: function () {},
                };
              }
              return (f.prototype.abort = function () {}), f;
            })();
    function u(f) {
      return function (h, m, g) {
        var y = r != null && r.idGenerator ? r.idGenerator(f) : HU(),
          _ = new l(),
          S;
        function x(T) {
          (S = T), _.abort();
        }
        var w = (function () {
          return AU(this, null, function () {
            var T, E, A, R, D, I, U;
            return wU(this, function (O) {
              switch (O.label) {
                case 0:
                  return (
                    O.trys.push([0, 4, , 5]),
                    (R =
                      (T = r == null ? void 0 : r.condition) == null
                        ? void 0
                        : T.call(r, f, { getState: m, extra: g })),
                    $U(R) ? [4, R] : [3, 2]
                  );
                case 1:
                  (R = O.sent()), (O.label = 2);
                case 2:
                  if (R === !1 || _.signal.aborted)
                    throw {
                      name: "ConditionError",
                      message:
                        "Aborted due to condition callback returning false.",
                    };
                  return (
                    (D = new Promise(function (L, V) {
                      return _.signal.addEventListener("abort", function () {
                        return V({
                          name: "AbortError",
                          message: S || "Aborted",
                        });
                      });
                    })),
                    h(
                      o(
                        y,
                        f,
                        (E = r == null ? void 0 : r.getPendingMeta) == null
                          ? void 0
                          : E.call(
                              r,
                              { requestId: y, arg: f },
                              { getState: m, extra: g }
                            )
                      )
                    ),
                    [
                      4,
                      Promise.race([
                        D,
                        Promise.resolve(
                          t(f, {
                            dispatch: h,
                            getState: m,
                            extra: g,
                            requestId: y,
                            signal: _.signal,
                            abort: x,
                            rejectWithValue: function (L, V) {
                              return new i_(L, V);
                            },
                            fulfillWithValue: function (L, V) {
                              return new Db(L, V);
                            },
                          })
                        ).then(function (L) {
                          if (L instanceof i_) throw L;
                          return L instanceof Db
                            ? i(L.payload, y, f, L.meta)
                            : i(L, y, f);
                        }),
                      ]),
                    ]
                  );
                case 3:
                  return (A = O.sent()), [3, 5];
                case 4:
                  return (
                    (I = O.sent()),
                    (A =
                      I instanceof i_
                        ? s(null, y, f, I.payload, I.meta)
                        : s(I, y, f)),
                    [3, 5]
                  );
                case 5:
                  return (
                    (U =
                      r &&
                      !r.dispatchConditionRejection &&
                      s.match(A) &&
                      A.meta.condition),
                    U || h(A),
                    [2, A]
                  );
              }
            });
          });
        })();
        return Object.assign(w, {
          abort: x,
          requestId: y,
          arg: f,
          unwrap: function () {
            return w.then(jU);
          },
        });
      };
    }
    return Object.assign(u, {
      pending: o,
      rejected: s,
      fulfilled: i,
      typePrefix: e,
    });
  }
  return (
    (n.withTypes = function () {
      return n;
    }),
    n
  );
})();
function jU(n) {
  if (n.meta && n.meta.rejectedWithValue) throw n.payload;
  if (n.error) throw n.error;
  return n.payload;
}
function $U(n) {
  return n !== null && typeof n == "object" && typeof n.then == "function";
}
var CS = "listenerMiddleware";
Ou(CS + "/add");
Ou(CS + "/removeAll");
Ou(CS + "/remove");
var kb;
typeof queueMicrotask == "function" &&
  queueMicrotask.bind(
    typeof window < "u" ? window : typeof global < "u" ? global : globalThis
  );
dU();
const XU = {
    sender: null,
    receiver: null,
    validator: null,
    phase: "idle",
    transactionProgress: 0,
  },
  w2 = BU({
    name: "simulation",
    initialState: XU,
    reducers: {
      setSender: (n, e) => {
        (n.sender = e.payload), (n.validator = null);
      },
      setReceiver: (n, e) => {
        (n.receiver = e.payload), (n.validator = null);
      },
      setValidator: (n, e) => {
        n.validator = e.payload;
      },
      startTransaction: (n) => {
        (n.phase = "transaction"), (n.transactionProgress = 0);
      },
      updateTransactionProgress: (n, e) => {
        (n.transactionProgress = e.payload),
          n.transactionProgress >= 1 && (n.phase = "validation");
      },
      startValidation: (n) => {
        n.phase = "validation";
      },
      startBroadcast: (n) => {
        n.phase = "broadcast";
      },
      completeSimulation: (n) => {
        n.phase = "complete";
      },
      resetSimulation: (n) => {
        (n.sender = null),
          (n.receiver = null),
          (n.validator = null),
          (n.phase = "idle"),
          (n.transactionProgress = 0);
      },
    },
  }),
  {
    setSender: YU,
    setReceiver: qU,
    setValidator: KU,
    startTransaction: ZU,
    updateTransactionProgress: o_,
    startValidation: JU,
    startBroadcast: QU,
    completeSimulation: eF,
    resetSimulation: tF,
  } = w2.actions,
  nF = w2.reducer,
  rF = NU({ reducer: { simulation: nF } }),
  s_ = Array.from({ length: 10 }, (n, e) => ({ id: e, name: `User ${e + 1}` }));
function iF() {
  const n = cC(),
    {
      sender: e,
      receiver: t,
      validator: r,
      phase: i,
    } = W0((u) => u.simulation),
    o = () => {
      e !== null && t !== null && r !== null && n(ZU());
    },
    s = () => {
      n(tF()), onReset();
    },
    l = s_.filter((u) => u.id !== e && u.id !== t);
  return ve.jsx(Qr, {
    sx: {
      width: "100%",
      height: "100%",
      bgcolor: "#f5f5f5",
      p: 2,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
    },
    children: ve.jsxs(Qr, {
      sx: {
        maxWidth: "320px",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        gap: 3,
        mx: "auto",
      },
      children: [
        ve.jsxs($x, {
          fullWidth: !0,
          disabled: i !== "idle",
          sx: {
            "& .MuiOutlinedInput-root": {
              borderRadius: "8px",
              bgcolor: "#fafafa",
              border: "1px solid #e0e0e0",
              transition: "all 0.3s ease",
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "#0288d1",
              },
              "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "#0288d1",
                boxShadow: "0 0 10px rgba(2, 136, 209, 0.4)",
              },
              "& .MuiSelect-select": { py: 1.5 },
            },
            "& .MuiInputLabel-root": {
              color: "#424242",
              fontSize: "1rem",
              fontWeight: 600,
              "&.Mui-disabled": { color: "#90a4ae" },
            },
          },
          children: [
            ve.jsx(Yx, { sx: { fontSize: "1rem" }, children: "Sender" }),
            ve.jsx($v, {
              value: e !== null ? e : "",
              onChange: (u) => n(YU(u.target.value)),
              label: "Sender",
              "aria-label": "Select sender node",
              MenuProps: {
                PaperProps: {
                  sx: {
                    boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                    maxHeight: "200px",
                  },
                },
              },
              children: s_.map((u) =>
                ve.jsx(
                  Zx,
                  {
                    value: u.id,
                    disabled: u.id === t,
                    sx: {
                      fontSize: "1rem",
                      py: 1.2,
                      transition: "background-color 0.2s ease",
                      "&:hover": { bgcolor: "#e3f2fd" },
                      "&.Mui-selected": { bgcolor: "#bbdefb" },
                    },
                    children: u.name,
                  },
                  u.id
                )
              ),
            }),
          ],
        }),
        ve.jsxs($x, {
          fullWidth: !0,
          disabled: i !== "idle",
          sx: {
            "& .MuiOutlinedInput-root": {
              borderRadius: "8px",
              bgcolor: "#fafafa",
              border: "1px solid #e0e0e0",
              transition: "all 0.3s ease",
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "#0288d1",
              },
              "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "#0288d1",
                boxShadow: "0 0 10px rgba(2, 136, 209, 0.4)",
              },
              "& .MuiSelect-select": { py: 1.5 },
            },
            "& .MuiInputLabel-root": {
              color: "#424242",
              fontSize: "1rem",
              fontWeight: 600,
              "&.Mui-disabled": { color: "#90a4ae" },
            },
          },
          children: [
            ve.jsx(Yx, { sx: { fontSize: "1rem" }, children: "Receiver" }),
            ve.jsx($v, {
              value: t !== null ? t : "",
              onChange: (u) => n(qU(u.target.value)),
              label: "Receiver",
              "aria-label": "Select receiver node",
              MenuProps: {
                PaperProps: {
                  sx: {
                    boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                    maxHeight: "200px",
                  },
                },
              },
              children: s_.map((u) =>
                ve.jsx(
                  Zx,
                  {
                    value: u.id,
                    disabled: u.id === e,
                    sx: {
                      fontSize: "1rem",
                      py: 1.2,
                      transition: "background-color 0.2s ease",
                      "&:hover": { bgcolor: "#e3f2fd" },
                      "&.Mui-selected": { bgcolor: "#bbdefb" },
                    },
                    children: u.name,
                  },
                  u.id
                )
              ),
            }),
          ],
        }),
        ve.jsxs($x, {
          fullWidth: !0,
          disabled: e === null || t === null || i !== "idle",
          sx: {
            "& .MuiOutlinedInput-root": {
              borderRadius: "8px",
              bgcolor: "#fafafa",
              border: "1px solid #e0e0e0",
              transition: "all 0.3s ease",
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "#0288d1",
              },
              "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "#0288d1",
                boxShadow: "0 0 10px rgba(2, 136, 209, 0.4)",
              },
              "& .MuiSelect-select": { py: 1.5 },
            },
            "& .MuiInputLabel-root": {
              color: "#424242",
              fontSize: "1rem",
              fontWeight: 600,
              "&.Mui-disabled": { color: "#90a4ae" },
            },
          },
          children: [
            ve.jsx(Yx, { sx: { fontSize: "1rem" }, children: "Validator" }),
            ve.jsx($v, {
              value: r !== null ? r : "",
              onChange: (u) => n(KU(u.target.value)),
              label: "Validator",
              "aria-label": "Select validator node",
              MenuProps: {
                PaperProps: {
                  sx: {
                    boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                    maxHeight: "200px",
                  },
                },
              },
              children: l.map((u) =>
                ve.jsx(
                  Zx,
                  {
                    value: u.id,
                    sx: {
                      fontSize: "1rem",
                      py: 1.2,
                      transition: "background-color 0.2s ease",
                      "&:hover": { bgcolor: "#e3f2fd" },
                      "&.Mui-selected": { bgcolor: "#bbdefb" },
                    },
                    children: u.name,
                  },
                  u.id
                )
              ),
            }),
          ],
        }),
        ve.jsxs(Qr, {
          sx: { display: "flex", gap: 3, justifyContent: "center" },
          children: [
            ve.jsx(lb, {
              variant: "contained",
              onClick: o,
              disabled: e === null || t === null || r === null || i !== "idle",
              sx: {
                bgcolor: "#26a69a",
                color: "#ffffff",
                px: 4,
                py: 2,
                borderRadius: "8px",
                boxShadow: "0 3px 10px rgba(0, 0, 0, 0.2)",
                textTransform: "none",
                fontWeight: 600,
                "&:hover": {
                  bgcolor: "#00897b",
                  boxShadow: "0 5px 15px rgba(0, 0, 0, 0.3)",
                },
                "&:disabled": {
                  bgcolor: "#b0bec5",
                  color: "#ffffff",
                  opacity: 0.7,
                },
                transition: "all 0.3s ease",
              },
              children: "Submit",
            }),
            ve.jsx(lb, {
              variant: "outlined",
              onClick: s,
              disabled: i === "idle",
              sx: {
                borderColor: "#ab47bc",
                color: "#ab47bc",
                px: 4,
                py: 2,
                borderRadius: "8px",
                boxShadow: "0 3px 10px rgba(0, 0, 0, 0.2)",
                textTransform: "none",
                fontWeight: 600,
                "&:hover": {
                  bgcolor: "#f3e5f5",
                  borderColor: "#8e24aa",
                  color: "#8e24aa",
                },
                "&:disabled": {
                  borderColor: "#b0bec5",
                  color: "#b0bec5",
                  opacity: 0.7,
                },
                transition: "all 0.3s ease",
              },
              children: "Reset",
            }),
          ],
        }),
      ],
    }),
  });
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const fy = "167",
  Vc = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Hc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  M2 = 0,
  R1 = 1,
  b2 = 2,
  oF = 3,
  E2 = 0,
  dy = 1,
  zp = 2,
  na = 3,
  Ga = 0,
  Zi = 1,
  Es = 2,
  Al = 0,
  Zc = 1,
  P1 = 2,
  I1 = 3,
  L1 = 4,
  T2 = 5,
  Lu = 100,
  C2 = 101,
  A2 = 102,
  R2 = 103,
  P2 = 104,
  I2 = 200,
  L2 = 201,
  D2 = 202,
  k2 = 203,
  c0 = 204,
  f0 = 205,
  O2 = 206,
  N2 = 207,
  U2 = 208,
  F2 = 209,
  z2 = 210,
  B2 = 211,
  V2 = 212,
  H2 = 213,
  G2 = 214,
  W2 = 0,
  j2 = 1,
  $2 = 2,
  om = 3,
  X2 = 4,
  Y2 = 5,
  q2 = 6,
  K2 = 7,
  Dm = 0,
  Z2 = 1,
  J2 = 2,
  Ba = 0,
  Q2 = 1,
  eA = 2,
  tA = 3,
  AS = 4,
  nA = 5,
  rA = 6,
  iA = 7,
  D1 = "attached",
  oA = "detached",
  hy = 300,
  Il = 301,
  Bu = 302,
  sm = 303,
  am = 304,
  vh = 306,
  lm = 1e3,
  Cs = 1001,
  um = 1002,
  yi = 1003,
  RS = 1004,
  sF = 1004,
  Xd = 1005,
  aF = 1005,
  br = 1006,
  Bp = 1007,
  lF = 1007,
  Na = 1008,
  uF = 1008,
  sa = 1009,
  PS = 1010,
  IS = 1011,
  uh = 1012,
  py = 1013,
  Ll = 1014,
  ko = 1015,
  yh = 1016,
  my = 1017,
  gy = 1018,
  af = 1020,
  LS = 35902,
  DS = 1021,
  kS = 1022,
  Ki = 1023,
  OS = 1024,
  NS = 1025,
  Jc = 1026,
  lf = 1027,
  vy = 1028,
  km = 1029,
  US = 1030,
  yy = 1031,
  cF = 1032,
  xy = 1033,
  Vp = 33776,
  Hp = 33777,
  Gp = 33778,
  Wp = 33779,
  d0 = 35840,
  h0 = 35841,
  p0 = 35842,
  m0 = 35843,
  g0 = 36196,
  v0 = 37492,
  y0 = 37496,
  x0 = 37808,
  _0 = 37809,
  S0 = 37810,
  w0 = 37811,
  M0 = 37812,
  b0 = 37813,
  E0 = 37814,
  T0 = 37815,
  C0 = 37816,
  A0 = 37817,
  R0 = 37818,
  P0 = 37819,
  I0 = 37820,
  L0 = 37821,
  jp = 36492,
  D0 = 36494,
  k0 = 36495,
  FS = 36283,
  O0 = 36284,
  N0 = 36285,
  U0 = 36286,
  sA = 2200,
  aA = 2201,
  lA = 2202,
  cm = 2300,
  F0 = 2301,
  Xv = 2302,
  Xc = 2400,
  Yc = 2401,
  fm = 2402,
  _y = 2500,
  zS = 2501,
  fF = 0,
  dF = 1,
  hF = 2,
  uA = 3200,
  BS = 3201,
  pF = 3202,
  mF = 3203,
  Gu = 0,
  cA = 1,
  bl = "",
  Ms = "srgb",
  kl = "srgb-linear",
  Sy = "display-p3",
  Om = "display-p3-linear",
  dm = "linear",
  $n = "srgb",
  hm = "rec709",
  pm = "p3",
  gF = 0,
  Gc = 7680,
  vF = 7681,
  yF = 7682,
  xF = 7683,
  _F = 34055,
  SF = 34056,
  wF = 5386,
  MF = 512,
  bF = 513,
  EF = 514,
  TF = 515,
  CF = 516,
  AF = 517,
  RF = 518,
  k1 = 519,
  fA = 512,
  dA = 513,
  hA = 514,
  VS = 515,
  pA = 516,
  mA = 517,
  gA = 518,
  vA = 519,
  mm = 35044,
  PF = 35048,
  IF = 35040,
  LF = 35045,
  DF = 35049,
  kF = 35041,
  OF = 35046,
  NF = 35050,
  UF = 35042,
  FF = "100",
  O1 = "300 es",
  Ua = 2e3,
  gm = 2001;
let Ol = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
};
const Wi = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let Ob = 1234567;
const Qc = Math.PI / 180,
  ch = 180 / Math.PI;
function is() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Wi[n & 255] +
    Wi[(n >> 8) & 255] +
    Wi[(n >> 16) & 255] +
    Wi[(n >> 24) & 255] +
    "-" +
    Wi[e & 255] +
    Wi[(e >> 8) & 255] +
    "-" +
    Wi[((e >> 16) & 15) | 64] +
    Wi[(e >> 24) & 255] +
    "-" +
    Wi[(t & 63) | 128] +
    Wi[(t >> 8) & 255] +
    "-" +
    Wi[(t >> 16) & 255] +
    Wi[(t >> 24) & 255] +
    Wi[r & 255] +
    Wi[(r >> 8) & 255] +
    Wi[(r >> 16) & 255] +
    Wi[(r >> 24) & 255]
  ).toLowerCase();
}
function Mr(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function HS(n, e) {
  return ((n % e) + e) % e;
}
function zF(n, e, t, r, i) {
  return r + ((n - e) * (i - r)) / (t - e);
}
function BF(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function $p(n, e, t) {
  return (1 - t) * n + t * e;
}
function VF(n, e, t, r) {
  return $p(n, e, 1 - Math.exp(-t * r));
}
function HF(n, e = 1) {
  return e - Math.abs(HS(n, e * 2) - e);
}
function GF(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function WF(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function jF(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function $F(n, e) {
  return n + Math.random() * (e - n);
}
function XF(n) {
  return n * (0.5 - Math.random());
}
function YF(n) {
  n !== void 0 && (Ob = n);
  let e = (Ob += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function qF(n) {
  return n * Qc;
}
function KF(n) {
  return n * ch;
}
function ZF(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function JF(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function QF(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function e4(n, e, t, r, i) {
  const o = Math.cos,
    s = Math.sin,
    l = o(t / 2),
    u = s(t / 2),
    f = o((e + r) / 2),
    h = s((e + r) / 2),
    m = o((e - r) / 2),
    g = s((e - r) / 2),
    y = o((r - e) / 2),
    _ = s((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(l * h, u * m, u * g, l * f);
      break;
    case "YZY":
      n.set(u * g, l * h, u * m, l * f);
      break;
    case "ZXZ":
      n.set(u * m, u * g, l * h, l * f);
      break;
    case "XZX":
      n.set(l * h, u * _, u * y, l * f);
      break;
    case "YXY":
      n.set(u * y, l * h, u * _, l * f);
      break;
    case "ZYZ":
      n.set(u * _, u * y, l * h, l * f);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function po(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function on(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const t4 = {
  DEG2RAD: Qc,
  RAD2DEG: ch,
  generateUUID: is,
  clamp: Mr,
  euclideanModulo: HS,
  mapLinear: zF,
  inverseLerp: BF,
  lerp: $p,
  damp: VF,
  pingpong: HF,
  smoothstep: GF,
  smootherstep: WF,
  randInt: jF,
  randFloat: $F,
  randFloatSpread: XF,
  seededRandom: YF,
  degToRad: qF,
  radToDeg: KF,
  isPowerOfTwo: ZF,
  ceilPowerOfTwo: JF,
  floorPowerOfTwo: QF,
  setQuaternionFromProperEuler: e4,
  normalize: on,
  denormalize: po,
};
class tt {
  constructor(e = 0, t = 0) {
    (tt.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * r + i[6]),
      (this.y = i[1] * t + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Mr(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      o = this.x - e.x,
      s = this.y - e.y;
    return (this.x = o * r - s * i + e.x), (this.y = o * i + s * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Qt {
  constructor(e, t, r, i, o, s, l, u, f) {
    (Qt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, o, s, l, u, f);
  }
  set(e, t, r, i, o, s, l, u, f) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = i),
      (h[2] = l),
      (h[3] = t),
      (h[4] = o),
      (h[5] = u),
      (h[6] = r),
      (h[7] = s),
      (h[8] = f),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      o = this.elements,
      s = r[0],
      l = r[3],
      u = r[6],
      f = r[1],
      h = r[4],
      m = r[7],
      g = r[2],
      y = r[5],
      _ = r[8],
      S = i[0],
      x = i[3],
      w = i[6],
      T = i[1],
      E = i[4],
      A = i[7],
      R = i[2],
      D = i[5],
      I = i[8];
    return (
      (o[0] = s * S + l * T + u * R),
      (o[3] = s * x + l * E + u * D),
      (o[6] = s * w + l * A + u * I),
      (o[1] = f * S + h * T + m * R),
      (o[4] = f * x + h * E + m * D),
      (o[7] = f * w + h * A + m * I),
      (o[2] = g * S + y * T + _ * R),
      (o[5] = g * x + y * E + _ * D),
      (o[8] = g * w + y * A + _ * I),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      l = e[5],
      u = e[6],
      f = e[7],
      h = e[8];
    return (
      t * s * h - t * l * f - r * o * h + r * l * u + i * o * f - i * s * u
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      l = e[5],
      u = e[6],
      f = e[7],
      h = e[8],
      m = h * s - l * f,
      g = l * u - h * o,
      y = f * o - s * u,
      _ = t * m + r * g + i * y;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / _;
    return (
      (e[0] = m * S),
      (e[1] = (i * f - h * r) * S),
      (e[2] = (l * r - i * s) * S),
      (e[3] = g * S),
      (e[4] = (h * t - i * u) * S),
      (e[5] = (i * o - l * t) * S),
      (e[6] = y * S),
      (e[7] = (r * u - f * t) * S),
      (e[8] = (s * t - r * o) * S),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, i, o, s, l) {
    const u = Math.cos(o),
      f = Math.sin(o);
    return (
      this.set(
        r * u,
        r * f,
        -r * (u * s + f * l) + s + e,
        -i * f,
        i * u,
        -i * (-f * s + u * l) + l + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(a_.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(a_.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(a_.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const a_ = new Qt();
function yA(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const n4 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Yd(n, e) {
  return new n4[n](e);
}
function vm(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function xA() {
  const n = vm("canvas");
  return (n.style.display = "block"), n;
}
const Nb = {};
function rh(n) {
  n in Nb || ((Nb[n] = !0), console.warn(n));
}
function r4(n, e, t) {
  return new Promise(function (r, i) {
    function o() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          i();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(o, t);
          break;
        default:
          r();
      }
    }
    setTimeout(o, t);
  });
}
const Ub = new Qt().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  Fb = new Qt().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  hp = {
    [kl]: {
      transfer: dm,
      primaries: hm,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (n) => n,
      fromReference: (n) => n,
    },
    [Ms]: {
      transfer: $n,
      primaries: hm,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (n) => n.convertSRGBToLinear(),
      fromReference: (n) => n.convertLinearToSRGB(),
    },
    [Om]: {
      transfer: dm,
      primaries: pm,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (n) => n.applyMatrix3(Fb),
      fromReference: (n) => n.applyMatrix3(Ub),
    },
    [Sy]: {
      transfer: $n,
      primaries: pm,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (n) => n.convertSRGBToLinear().applyMatrix3(Fb),
      fromReference: (n) => n.applyMatrix3(Ub).convertLinearToSRGB(),
    },
  },
  i4 = new Set([kl, Om]),
  yn = {
    enabled: !0,
    _workingColorSpace: kl,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(n) {
      if (!i4.has(n))
        throw new Error(`Unsupported working color space, "${n}".`);
      this._workingColorSpace = n;
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const r = hp[e].toReference,
        i = hp[t].fromReference;
      return i(r(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this._workingColorSpace);
    },
    getPrimaries: function (n) {
      return hp[n].primaries;
    },
    getTransfer: function (n) {
      return n === bl ? dm : hp[n].transfer;
    },
    getLuminanceCoefficients: function (n, e = this._workingColorSpace) {
      return n.fromArray(hp[e].luminanceCoefficients);
    },
  };
function ih(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function l_(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let yd;
class _A {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      yd === void 0 && (yd = vm("canvas")),
        (yd.width = e.width),
        (yd.height = e.height);
      const r = yd.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (t = yd);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = vm("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        o = i.data;
      for (let s = 0; s < o.length; s++) o[s] = ih(o[s] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(ih(t[r] / 255) * 255))
          : (t[r] = ih(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let o4 = 0;
class qc {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: o4++ }),
      (this.uuid = is()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let s = 0, l = i.length; s < l; s++)
          i[s].isDataTexture ? o.push(u_(i[s].image)) : o.push(u_(i[s]));
      } else o = u_(i);
      r.url = o;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function u_(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? _A.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let s4 = 0;
class rr extends Ol {
  constructor(
    e = rr.DEFAULT_IMAGE,
    t = rr.DEFAULT_MAPPING,
    r = Cs,
    i = Cs,
    o = br,
    s = Na,
    l = Ki,
    u = sa,
    f = rr.DEFAULT_ANISOTROPY,
    h = bl
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: s4++ }),
      (this.uuid = is()),
      (this.name = ""),
      (this.source = new qc(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = o),
      (this.minFilter = s),
      (this.anisotropy = f),
      (this.format = l),
      (this.internalFormat = null),
      (this.type = u),
      (this.offset = new tt(0, 0)),
      (this.repeat = new tt(1, 1)),
      (this.center = new tt(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Qt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== hy) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case lm:
          e.x = e.x - Math.floor(e.x);
          break;
        case Cs:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case um:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case lm:
          e.y = e.y - Math.floor(e.y);
          break;
        case Cs:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case um:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
rr.DEFAULT_IMAGE = null;
rr.DEFAULT_MAPPING = hy;
rr.DEFAULT_ANISOTROPY = 1;
class En {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (En.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = this.w,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * r + s[8] * i + s[12] * o),
      (this.y = s[1] * t + s[5] * r + s[9] * i + s[13] * o),
      (this.z = s[2] * t + s[6] * r + s[10] * i + s[14] * o),
      (this.w = s[3] * t + s[7] * r + s[11] * i + s[15] * o),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, o;
    const u = e.elements,
      f = u[0],
      h = u[4],
      m = u[8],
      g = u[1],
      y = u[5],
      _ = u[9],
      S = u[2],
      x = u[6],
      w = u[10];
    if (
      Math.abs(h - g) < 0.01 &&
      Math.abs(m - S) < 0.01 &&
      Math.abs(_ - x) < 0.01
    ) {
      if (
        Math.abs(h + g) < 0.1 &&
        Math.abs(m + S) < 0.1 &&
        Math.abs(_ + x) < 0.1 &&
        Math.abs(f + y + w - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const E = (f + 1) / 2,
        A = (y + 1) / 2,
        R = (w + 1) / 2,
        D = (h + g) / 4,
        I = (m + S) / 4,
        U = (_ + x) / 4;
      return (
        E > A && E > R
          ? E < 0.01
            ? ((r = 0), (i = 0.707106781), (o = 0.707106781))
            : ((r = Math.sqrt(E)), (i = D / r), (o = I / r))
          : A > R
          ? A < 0.01
            ? ((r = 0.707106781), (i = 0), (o = 0.707106781))
            : ((i = Math.sqrt(A)), (r = D / i), (o = U / i))
          : R < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (o = 0))
          : ((o = Math.sqrt(R)), (r = I / o), (i = U / o)),
        this.set(r, i, o, t),
        this
      );
    }
    let T = Math.sqrt(
      (x - _) * (x - _) + (m - S) * (m - S) + (g - h) * (g - h)
    );
    return (
      Math.abs(T) < 0.001 && (T = 1),
      (this.x = (x - _) / T),
      (this.y = (m - S) / T),
      (this.z = (g - h) / T),
      (this.w = Math.acos((f + y + w - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class SA extends Ol {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new En(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new En(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    r = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: br,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      r
    );
    const o = new rr(
      i,
      r.mapping,
      r.wrapS,
      r.wrapT,
      r.magFilter,
      r.minFilter,
      r.format,
      r.type,
      r.anisotropy,
      r.colorSpace
    );
    (o.flipY = !1),
      (o.generateMipmaps = r.generateMipmaps),
      (o.internalFormat = r.internalFormat),
      (this.textures = []);
    const s = r.count;
    for (let l = 0; l < s; l++)
      (this.textures[l] = o.clone()),
        (this.textures[l].isRenderTargetTexture = !0);
    (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.resolveDepthBuffer = r.resolveDepthBuffer),
      (this.resolveStencilBuffer = r.resolveStencilBuffer),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      (this.width = e), (this.height = t), (this.depth = r);
      for (let i = 0, o = this.textures.length; i < o; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let r = 0, i = e.textures.length; r < i; r++)
      (this.textures[r] = e.textures[r].clone()),
        (this.textures[r].isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new qc(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class aa extends SA {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), (this.isWebGLRenderTarget = !0);
  }
}
class wy extends rr {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = yi),
      (this.minFilter = yi),
      (this.wrapR = Cs),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class a4 extends aa {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new wy(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class GS extends rr {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = yi),
      (this.minFilter = yi),
      (this.wrapR = Cs),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class l4 extends aa {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new GS(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Ji {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, t, r, i, o, s, l) {
    let u = r[i + 0],
      f = r[i + 1],
      h = r[i + 2],
      m = r[i + 3];
    const g = o[s + 0],
      y = o[s + 1],
      _ = o[s + 2],
      S = o[s + 3];
    if (l === 0) {
      (e[t + 0] = u), (e[t + 1] = f), (e[t + 2] = h), (e[t + 3] = m);
      return;
    }
    if (l === 1) {
      (e[t + 0] = g), (e[t + 1] = y), (e[t + 2] = _), (e[t + 3] = S);
      return;
    }
    if (m !== S || u !== g || f !== y || h !== _) {
      let x = 1 - l;
      const w = u * g + f * y + h * _ + m * S,
        T = w >= 0 ? 1 : -1,
        E = 1 - w * w;
      if (E > Number.EPSILON) {
        const R = Math.sqrt(E),
          D = Math.atan2(R, w * T);
        (x = Math.sin(x * D) / R), (l = Math.sin(l * D) / R);
      }
      const A = l * T;
      if (
        ((u = u * x + g * A),
        (f = f * x + y * A),
        (h = h * x + _ * A),
        (m = m * x + S * A),
        x === 1 - l)
      ) {
        const R = 1 / Math.sqrt(u * u + f * f + h * h + m * m);
        (u *= R), (f *= R), (h *= R), (m *= R);
      }
    }
    (e[t] = u), (e[t + 1] = f), (e[t + 2] = h), (e[t + 3] = m);
  }
  static multiplyQuaternionsFlat(e, t, r, i, o, s) {
    const l = r[i],
      u = r[i + 1],
      f = r[i + 2],
      h = r[i + 3],
      m = o[s],
      g = o[s + 1],
      y = o[s + 2],
      _ = o[s + 3];
    return (
      (e[t] = l * _ + h * m + u * y - f * g),
      (e[t + 1] = u * _ + h * g + f * m - l * y),
      (e[t + 2] = f * _ + h * y + l * g - u * m),
      (e[t + 3] = h * _ - l * m - u * g - f * y),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._order,
      l = Math.cos,
      u = Math.sin,
      f = l(r / 2),
      h = l(i / 2),
      m = l(o / 2),
      g = u(r / 2),
      y = u(i / 2),
      _ = u(o / 2);
    switch (s) {
      case "XYZ":
        (this._x = g * h * m + f * y * _),
          (this._y = f * y * m - g * h * _),
          (this._z = f * h * _ + g * y * m),
          (this._w = f * h * m - g * y * _);
        break;
      case "YXZ":
        (this._x = g * h * m + f * y * _),
          (this._y = f * y * m - g * h * _),
          (this._z = f * h * _ - g * y * m),
          (this._w = f * h * m + g * y * _);
        break;
      case "ZXY":
        (this._x = g * h * m - f * y * _),
          (this._y = f * y * m + g * h * _),
          (this._z = f * h * _ + g * y * m),
          (this._w = f * h * m - g * y * _);
        break;
      case "ZYX":
        (this._x = g * h * m - f * y * _),
          (this._y = f * y * m + g * h * _),
          (this._z = f * h * _ - g * y * m),
          (this._w = f * h * m + g * y * _);
        break;
      case "YZX":
        (this._x = g * h * m + f * y * _),
          (this._y = f * y * m + g * h * _),
          (this._z = f * h * _ - g * y * m),
          (this._w = f * h * m - g * y * _);
        break;
      case "XZY":
        (this._x = g * h * m - f * y * _),
          (this._y = f * y * m - g * h * _),
          (this._z = f * h * _ + g * y * m),
          (this._w = f * h * m + g * y * _);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      i = t[4],
      o = t[8],
      s = t[1],
      l = t[5],
      u = t[9],
      f = t[2],
      h = t[6],
      m = t[10],
      g = r + l + m;
    if (g > 0) {
      const y = 0.5 / Math.sqrt(g + 1);
      (this._w = 0.25 / y),
        (this._x = (h - u) * y),
        (this._y = (o - f) * y),
        (this._z = (s - i) * y);
    } else if (r > l && r > m) {
      const y = 2 * Math.sqrt(1 + r - l - m);
      (this._w = (h - u) / y),
        (this._x = 0.25 * y),
        (this._y = (i + s) / y),
        (this._z = (o + f) / y);
    } else if (l > m) {
      const y = 2 * Math.sqrt(1 + l - r - m);
      (this._w = (o - f) / y),
        (this._x = (i + s) / y),
        (this._y = 0.25 * y),
        (this._z = (u + h) / y);
    } else {
      const y = 2 * Math.sqrt(1 + m - r - l);
      (this._w = (s - i) / y),
        (this._x = (o + f) / y),
        (this._y = (u + h) / y),
        (this._z = 0.25 * y);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Mr(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._w,
      l = t._x,
      u = t._y,
      f = t._z,
      h = t._w;
    return (
      (this._x = r * h + s * l + i * f - o * u),
      (this._y = i * h + s * u + o * l - r * f),
      (this._z = o * h + s * f + r * u - i * l),
      (this._w = s * h - r * l - i * u - o * f),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      o = this._z,
      s = this._w;
    let l = s * e._w + r * e._x + i * e._y + o * e._z;
    if (
      (l < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (l = -l))
        : this.copy(e),
      l >= 1)
    )
      return (this._w = s), (this._x = r), (this._y = i), (this._z = o), this;
    const u = 1 - l * l;
    if (u <= Number.EPSILON) {
      const y = 1 - t;
      return (
        (this._w = y * s + t * this._w),
        (this._x = y * r + t * this._x),
        (this._y = y * i + t * this._y),
        (this._z = y * o + t * this._z),
        this.normalize(),
        this
      );
    }
    const f = Math.sqrt(u),
      h = Math.atan2(f, l),
      m = Math.sin((1 - t) * h) / f,
      g = Math.sin(t * h) / f;
    return (
      (this._w = s * m + this._w * g),
      (this._x = r * m + this._x * g),
      (this._y = i * m + this._y * g),
      (this._z = o * m + this._z * g),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      r = Math.random(),
      i = Math.sqrt(1 - r),
      o = Math.sqrt(r);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      o * Math.sin(t),
      o * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ie {
  constructor(e = 0, t = 0, r = 0) {
    (ie.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(zb.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(zb.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[3] * r + o[6] * i),
      (this.y = o[1] * t + o[4] * r + o[7] * i),
      (this.z = o[2] * t + o[5] * r + o[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements,
      s = 1 / (o[3] * t + o[7] * r + o[11] * i + o[15]);
    return (
      (this.x = (o[0] * t + o[4] * r + o[8] * i + o[12]) * s),
      (this.y = (o[1] * t + o[5] * r + o[9] * i + o[13]) * s),
      (this.z = (o[2] * t + o[6] * r + o[10] * i + o[14]) * s),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.x,
      s = e.y,
      l = e.z,
      u = e.w,
      f = 2 * (s * i - l * r),
      h = 2 * (l * t - o * i),
      m = 2 * (o * r - s * t);
    return (
      (this.x = t + u * f + s * m - l * h),
      (this.y = r + u * h + l * f - o * m),
      (this.z = i + u * m + o * h - s * f),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * r + o[8] * i),
      (this.y = o[1] * t + o[5] * r + o[9] * i),
      (this.z = o[2] * t + o[6] * r + o[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = t.x,
      l = t.y,
      u = t.z;
    return (
      (this.x = i * u - o * l),
      (this.y = o * s - r * u),
      (this.z = r * l - i * s),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return c_.copy(this).projectOnVector(e), this.sub(c_);
  }
  reflect(e) {
    return this.sub(c_.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Mr(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      r = Math.sqrt(1 - t * t);
    return (
      (this.x = r * Math.cos(e)), (this.y = t), (this.z = r * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const c_ = new ie(),
  zb = new Ji();
class Qi {
  constructor(
    e = new ie(1 / 0, 1 / 0, 1 / 0),
    t = new ie(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(Qs.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(Qs.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = Qs.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const o = r.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let s = 0, l = o.count; s < l; s++)
          e.isMesh === !0
            ? e.getVertexPosition(s, Qs)
            : Qs.fromBufferAttribute(o, s),
            Qs.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Qs);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            Gg.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            Gg.copy(r.boundingBox)),
          Gg.applyMatrix4(e.matrixWorld),
          this.union(Gg);
    }
    const i = e.children;
    for (let o = 0, s = i.length; o < s; o++) this.expandByObject(i[o], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Qs),
      Qs.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(pp),
      Wg.subVectors(this.max, pp),
      xd.subVectors(e.a, pp),
      _d.subVectors(e.b, pp),
      Sd.subVectors(e.c, pp),
      wu.subVectors(_d, xd),
      Mu.subVectors(Sd, _d),
      Ec.subVectors(xd, Sd);
    let t = [
      0,
      -wu.z,
      wu.y,
      0,
      -Mu.z,
      Mu.y,
      0,
      -Ec.z,
      Ec.y,
      wu.z,
      0,
      -wu.x,
      Mu.z,
      0,
      -Mu.x,
      Ec.z,
      0,
      -Ec.x,
      -wu.y,
      wu.x,
      0,
      -Mu.y,
      Mu.x,
      0,
      -Ec.y,
      Ec.x,
      0,
    ];
    return !f_(t, xd, _d, Sd, Wg) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !f_(t, xd, _d, Sd, Wg))
      ? !1
      : (jg.crossVectors(wu, Mu),
        (t = [jg.x, jg.y, jg.z]),
        f_(t, xd, _d, Sd, Wg));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Qs).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Qs).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (ml[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        ml[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        ml[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        ml[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        ml[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        ml[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        ml[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        ml[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(ml),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const ml = [
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
  ],
  Qs = new ie(),
  Gg = new Qi(),
  xd = new ie(),
  _d = new ie(),
  Sd = new ie(),
  wu = new ie(),
  Mu = new ie(),
  Ec = new ie(),
  pp = new ie(),
  Wg = new ie(),
  jg = new ie(),
  Tc = new ie();
function f_(n, e, t, r, i) {
  for (let o = 0, s = n.length - 3; o <= s; o += 3) {
    Tc.fromArray(n, o);
    const l =
        i.x * Math.abs(Tc.x) + i.y * Math.abs(Tc.y) + i.z * Math.abs(Tc.z),
      u = e.dot(Tc),
      f = t.dot(Tc),
      h = r.dot(Tc);
    if (Math.max(-Math.max(u, f, h), Math.min(u, f, h)) > l) return !1;
  }
  return !0;
}
const u4 = new Qi(),
  mp = new ie(),
  d_ = new ie();
class Di {
  constructor(e = new ie(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : u4.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let o = 0, s = e.length; o < s; o++)
      i = Math.max(i, r.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    mp.subVectors(e, this.center);
    const t = mp.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(mp, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (d_.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(mp.copy(e.center).add(d_)),
            this.expandByPoint(mp.copy(e.center).sub(d_))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const gl = new ie(),
  h_ = new ie(),
  $g = new ie(),
  bu = new ie(),
  p_ = new ie(),
  Xg = new ie(),
  m_ = new ie();
class hf {
  constructor(e = new ie(), t = new ie(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, gl)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = gl.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (gl.copy(this.origin).addScaledVector(this.direction, t),
        gl.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    h_.copy(e).add(t).multiplyScalar(0.5),
      $g.copy(t).sub(e).normalize(),
      bu.copy(this.origin).sub(h_);
    const o = e.distanceTo(t) * 0.5,
      s = -this.direction.dot($g),
      l = bu.dot(this.direction),
      u = -bu.dot($g),
      f = bu.lengthSq(),
      h = Math.abs(1 - s * s);
    let m, g, y, _;
    if (h > 0)
      if (((m = s * u - l), (g = s * l - u), (_ = o * h), m >= 0))
        if (g >= -_)
          if (g <= _) {
            const S = 1 / h;
            (m *= S),
              (g *= S),
              (y = m * (m + s * g + 2 * l) + g * (s * m + g + 2 * u) + f);
          } else
            (g = o),
              (m = Math.max(0, -(s * g + l))),
              (y = -m * m + g * (g + 2 * u) + f);
        else
          (g = -o),
            (m = Math.max(0, -(s * g + l))),
            (y = -m * m + g * (g + 2 * u) + f);
      else
        g <= -_
          ? ((m = Math.max(0, -(-s * o + l))),
            (g = m > 0 ? -o : Math.min(Math.max(-o, -u), o)),
            (y = -m * m + g * (g + 2 * u) + f))
          : g <= _
          ? ((m = 0),
            (g = Math.min(Math.max(-o, -u), o)),
            (y = g * (g + 2 * u) + f))
          : ((m = Math.max(0, -(s * o + l))),
            (g = m > 0 ? o : Math.min(Math.max(-o, -u), o)),
            (y = -m * m + g * (g + 2 * u) + f));
    else
      (g = s > 0 ? -o : o),
        (m = Math.max(0, -(s * g + l))),
        (y = -m * m + g * (g + 2 * u) + f);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, m),
      i && i.copy(h_).addScaledVector($g, g),
      y
    );
  }
  intersectSphere(e, t) {
    gl.subVectors(e.center, this.origin);
    const r = gl.dot(this.direction),
      i = gl.dot(gl) - r * r,
      o = e.radius * e.radius;
    if (i > o) return null;
    const s = Math.sqrt(o - i),
      l = r - s,
      u = r + s;
    return u < 0 ? null : l < 0 ? this.at(u, t) : this.at(l, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, o, s, l, u;
    const f = 1 / this.direction.x,
      h = 1 / this.direction.y,
      m = 1 / this.direction.z,
      g = this.origin;
    return (
      f >= 0
        ? ((r = (e.min.x - g.x) * f), (i = (e.max.x - g.x) * f))
        : ((r = (e.max.x - g.x) * f), (i = (e.min.x - g.x) * f)),
      h >= 0
        ? ((o = (e.min.y - g.y) * h), (s = (e.max.y - g.y) * h))
        : ((o = (e.max.y - g.y) * h), (s = (e.min.y - g.y) * h)),
      r > s ||
      o > i ||
      ((o > r || isNaN(r)) && (r = o),
      (s < i || isNaN(i)) && (i = s),
      m >= 0
        ? ((l = (e.min.z - g.z) * m), (u = (e.max.z - g.z) * m))
        : ((l = (e.max.z - g.z) * m), (u = (e.min.z - g.z) * m)),
      r > u || l > i) ||
      ((l > r || r !== r) && (r = l), (u < i || i !== i) && (i = u), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, gl) !== null;
  }
  intersectTriangle(e, t, r, i, o) {
    p_.subVectors(t, e), Xg.subVectors(r, e), m_.crossVectors(p_, Xg);
    let s = this.direction.dot(m_),
      l;
    if (s > 0) {
      if (i) return null;
      l = 1;
    } else if (s < 0) (l = -1), (s = -s);
    else return null;
    bu.subVectors(this.origin, e);
    const u = l * this.direction.dot(Xg.crossVectors(bu, Xg));
    if (u < 0) return null;
    const f = l * this.direction.dot(p_.cross(bu));
    if (f < 0 || u + f > s) return null;
    const h = -l * bu.dot(m_);
    return h < 0 ? null : this.at(h / s, o);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Wt {
  constructor(e, t, r, i, o, s, l, u, f, h, m, g, y, _, S, x) {
    (Wt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, o, s, l, u, f, h, m, g, y, _, S, x);
  }
  set(e, t, r, i, o, s, l, u, f, h, m, g, y, _, S, x) {
    const w = this.elements;
    return (
      (w[0] = e),
      (w[4] = t),
      (w[8] = r),
      (w[12] = i),
      (w[1] = o),
      (w[5] = s),
      (w[9] = l),
      (w[13] = u),
      (w[2] = f),
      (w[6] = h),
      (w[10] = m),
      (w[14] = g),
      (w[3] = y),
      (w[7] = _),
      (w[11] = S),
      (w[15] = x),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Wt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      i = 1 / wd.setFromMatrixColumn(e, 0).length(),
      o = 1 / wd.setFromMatrixColumn(e, 1).length(),
      s = 1 / wd.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * i),
      (t[1] = r[1] * i),
      (t[2] = r[2] * i),
      (t[3] = 0),
      (t[4] = r[4] * o),
      (t[5] = r[5] * o),
      (t[6] = r[6] * o),
      (t[7] = 0),
      (t[8] = r[8] * s),
      (t[9] = r[9] * s),
      (t[10] = r[10] * s),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      o = e.z,
      s = Math.cos(r),
      l = Math.sin(r),
      u = Math.cos(i),
      f = Math.sin(i),
      h = Math.cos(o),
      m = Math.sin(o);
    if (e.order === "XYZ") {
      const g = s * h,
        y = s * m,
        _ = l * h,
        S = l * m;
      (t[0] = u * h),
        (t[4] = -u * m),
        (t[8] = f),
        (t[1] = y + _ * f),
        (t[5] = g - S * f),
        (t[9] = -l * u),
        (t[2] = S - g * f),
        (t[6] = _ + y * f),
        (t[10] = s * u);
    } else if (e.order === "YXZ") {
      const g = u * h,
        y = u * m,
        _ = f * h,
        S = f * m;
      (t[0] = g + S * l),
        (t[4] = _ * l - y),
        (t[8] = s * f),
        (t[1] = s * m),
        (t[5] = s * h),
        (t[9] = -l),
        (t[2] = y * l - _),
        (t[6] = S + g * l),
        (t[10] = s * u);
    } else if (e.order === "ZXY") {
      const g = u * h,
        y = u * m,
        _ = f * h,
        S = f * m;
      (t[0] = g - S * l),
        (t[4] = -s * m),
        (t[8] = _ + y * l),
        (t[1] = y + _ * l),
        (t[5] = s * h),
        (t[9] = S - g * l),
        (t[2] = -s * f),
        (t[6] = l),
        (t[10] = s * u);
    } else if (e.order === "ZYX") {
      const g = s * h,
        y = s * m,
        _ = l * h,
        S = l * m;
      (t[0] = u * h),
        (t[4] = _ * f - y),
        (t[8] = g * f + S),
        (t[1] = u * m),
        (t[5] = S * f + g),
        (t[9] = y * f - _),
        (t[2] = -f),
        (t[6] = l * u),
        (t[10] = s * u);
    } else if (e.order === "YZX") {
      const g = s * u,
        y = s * f,
        _ = l * u,
        S = l * f;
      (t[0] = u * h),
        (t[4] = S - g * m),
        (t[8] = _ * m + y),
        (t[1] = m),
        (t[5] = s * h),
        (t[9] = -l * h),
        (t[2] = -f * h),
        (t[6] = y * m + _),
        (t[10] = g - S * m);
    } else if (e.order === "XZY") {
      const g = s * u,
        y = s * f,
        _ = l * u,
        S = l * f;
      (t[0] = u * h),
        (t[4] = -m),
        (t[8] = f * h),
        (t[1] = g * m + S),
        (t[5] = s * h),
        (t[9] = y * m - _),
        (t[2] = _ * m - y),
        (t[6] = l * h),
        (t[10] = S * m + g);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(c4, e, f4);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return (
      Zo.subVectors(e, t),
      Zo.lengthSq() === 0 && (Zo.z = 1),
      Zo.normalize(),
      Eu.crossVectors(r, Zo),
      Eu.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (Zo.x += 1e-4) : (Zo.z += 1e-4),
        Zo.normalize(),
        Eu.crossVectors(r, Zo)),
      Eu.normalize(),
      Yg.crossVectors(Zo, Eu),
      (i[0] = Eu.x),
      (i[4] = Yg.x),
      (i[8] = Zo.x),
      (i[1] = Eu.y),
      (i[5] = Yg.y),
      (i[9] = Zo.y),
      (i[2] = Eu.z),
      (i[6] = Yg.z),
      (i[10] = Zo.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      o = this.elements,
      s = r[0],
      l = r[4],
      u = r[8],
      f = r[12],
      h = r[1],
      m = r[5],
      g = r[9],
      y = r[13],
      _ = r[2],
      S = r[6],
      x = r[10],
      w = r[14],
      T = r[3],
      E = r[7],
      A = r[11],
      R = r[15],
      D = i[0],
      I = i[4],
      U = i[8],
      O = i[12],
      L = i[1],
      V = i[5],
      H = i[9],
      $ = i[13],
      q = i[2],
      K = i[6],
      Y = i[10],
      ne = i[14],
      j = i[3],
      re = i[7],
      B = i[11],
      G = i[15];
    return (
      (o[0] = s * D + l * L + u * q + f * j),
      (o[4] = s * I + l * V + u * K + f * re),
      (o[8] = s * U + l * H + u * Y + f * B),
      (o[12] = s * O + l * $ + u * ne + f * G),
      (o[1] = h * D + m * L + g * q + y * j),
      (o[5] = h * I + m * V + g * K + y * re),
      (o[9] = h * U + m * H + g * Y + y * B),
      (o[13] = h * O + m * $ + g * ne + y * G),
      (o[2] = _ * D + S * L + x * q + w * j),
      (o[6] = _ * I + S * V + x * K + w * re),
      (o[10] = _ * U + S * H + x * Y + w * B),
      (o[14] = _ * O + S * $ + x * ne + w * G),
      (o[3] = T * D + E * L + A * q + R * j),
      (o[7] = T * I + E * V + A * K + R * re),
      (o[11] = T * U + E * H + A * Y + R * B),
      (o[15] = T * O + E * $ + A * ne + R * G),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      i = e[8],
      o = e[12],
      s = e[1],
      l = e[5],
      u = e[9],
      f = e[13],
      h = e[2],
      m = e[6],
      g = e[10],
      y = e[14],
      _ = e[3],
      S = e[7],
      x = e[11],
      w = e[15];
    return (
      _ *
        (+o * u * m -
          i * f * m -
          o * l * g +
          r * f * g +
          i * l * y -
          r * u * y) +
      S *
        (+t * u * y -
          t * f * g +
          o * s * g -
          i * s * y +
          i * f * h -
          o * u * h) +
      x *
        (+t * f * m -
          t * l * y -
          o * s * m +
          r * s * y +
          o * l * h -
          r * f * h) +
      w *
        (-i * l * h - t * u * m + t * l * g + i * s * m - r * s * g + r * u * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      l = e[5],
      u = e[6],
      f = e[7],
      h = e[8],
      m = e[9],
      g = e[10],
      y = e[11],
      _ = e[12],
      S = e[13],
      x = e[14],
      w = e[15],
      T = m * x * f - S * g * f + S * u * y - l * x * y - m * u * w + l * g * w,
      E = _ * g * f - h * x * f - _ * u * y + s * x * y + h * u * w - s * g * w,
      A = h * S * f - _ * m * f + _ * l * y - s * S * y - h * l * w + s * m * w,
      R = _ * m * u - h * S * u - _ * l * g + s * S * g + h * l * x - s * m * x,
      D = t * T + r * E + i * A + o * R;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const I = 1 / D;
    return (
      (e[0] = T * I),
      (e[1] =
        (S * g * o -
          m * x * o -
          S * i * y +
          r * x * y +
          m * i * w -
          r * g * w) *
        I),
      (e[2] =
        (l * x * o -
          S * u * o +
          S * i * f -
          r * x * f -
          l * i * w +
          r * u * w) *
        I),
      (e[3] =
        (m * u * o -
          l * g * o -
          m * i * f +
          r * g * f +
          l * i * y -
          r * u * y) *
        I),
      (e[4] = E * I),
      (e[5] =
        (h * x * o -
          _ * g * o +
          _ * i * y -
          t * x * y -
          h * i * w +
          t * g * w) *
        I),
      (e[6] =
        (_ * u * o -
          s * x * o -
          _ * i * f +
          t * x * f +
          s * i * w -
          t * u * w) *
        I),
      (e[7] =
        (s * g * o -
          h * u * o +
          h * i * f -
          t * g * f -
          s * i * y +
          t * u * y) *
        I),
      (e[8] = A * I),
      (e[9] =
        (_ * m * o -
          h * S * o -
          _ * r * y +
          t * S * y +
          h * r * w -
          t * m * w) *
        I),
      (e[10] =
        (s * S * o -
          _ * l * o +
          _ * r * f -
          t * S * f -
          s * r * w +
          t * l * w) *
        I),
      (e[11] =
        (h * l * o -
          s * m * o -
          h * r * f +
          t * m * f +
          s * r * y -
          t * l * y) *
        I),
      (e[12] = R * I),
      (e[13] =
        (h * S * i -
          _ * m * i +
          _ * r * g -
          t * S * g -
          h * r * x +
          t * m * x) *
        I),
      (e[14] =
        (_ * l * i -
          s * S * i -
          _ * r * u +
          t * S * u +
          s * r * x -
          t * l * x) *
        I),
      (e[15] =
        (s * m * i -
          h * l * i +
          h * r * u -
          t * m * u -
          s * r * g +
          t * l * g) *
        I),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      o = e.z;
    return (
      (t[0] *= r),
      (t[4] *= i),
      (t[8] *= o),
      (t[1] *= r),
      (t[5] *= i),
      (t[9] *= o),
      (t[2] *= r),
      (t[6] *= i),
      (t[10] *= o),
      (t[3] *= r),
      (t[7] *= i),
      (t[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      o = 1 - r,
      s = e.x,
      l = e.y,
      u = e.z,
      f = o * s,
      h = o * l;
    return (
      this.set(
        f * s + r,
        f * l - i * u,
        f * u + i * l,
        0,
        f * l + i * u,
        h * l + r,
        h * u - i * s,
        0,
        f * u - i * l,
        h * u + i * s,
        o * u * u + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, i, o, s) {
    return this.set(1, r, o, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const i = this.elements,
      o = t._x,
      s = t._y,
      l = t._z,
      u = t._w,
      f = o + o,
      h = s + s,
      m = l + l,
      g = o * f,
      y = o * h,
      _ = o * m,
      S = s * h,
      x = s * m,
      w = l * m,
      T = u * f,
      E = u * h,
      A = u * m,
      R = r.x,
      D = r.y,
      I = r.z;
    return (
      (i[0] = (1 - (S + w)) * R),
      (i[1] = (y + A) * R),
      (i[2] = (_ - E) * R),
      (i[3] = 0),
      (i[4] = (y - A) * D),
      (i[5] = (1 - (g + w)) * D),
      (i[6] = (x + T) * D),
      (i[7] = 0),
      (i[8] = (_ + E) * I),
      (i[9] = (x - T) * I),
      (i[10] = (1 - (g + S)) * I),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const i = this.elements;
    let o = wd.set(i[0], i[1], i[2]).length();
    const s = wd.set(i[4], i[5], i[6]).length(),
      l = wd.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      ea.copy(this);
    const f = 1 / o,
      h = 1 / s,
      m = 1 / l;
    return (
      (ea.elements[0] *= f),
      (ea.elements[1] *= f),
      (ea.elements[2] *= f),
      (ea.elements[4] *= h),
      (ea.elements[5] *= h),
      (ea.elements[6] *= h),
      (ea.elements[8] *= m),
      (ea.elements[9] *= m),
      (ea.elements[10] *= m),
      t.setFromRotationMatrix(ea),
      (r.x = o),
      (r.y = s),
      (r.z = l),
      this
    );
  }
  makePerspective(e, t, r, i, o, s, l = Ua) {
    const u = this.elements,
      f = (2 * o) / (t - e),
      h = (2 * o) / (r - i),
      m = (t + e) / (t - e),
      g = (r + i) / (r - i);
    let y, _;
    if (l === Ua) (y = -(s + o) / (s - o)), (_ = (-2 * s * o) / (s - o));
    else if (l === gm) (y = -s / (s - o)), (_ = (-s * o) / (s - o));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l
      );
    return (
      (u[0] = f),
      (u[4] = 0),
      (u[8] = m),
      (u[12] = 0),
      (u[1] = 0),
      (u[5] = h),
      (u[9] = g),
      (u[13] = 0),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = y),
      (u[14] = _),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = -1),
      (u[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, i, o, s, l = Ua) {
    const u = this.elements,
      f = 1 / (t - e),
      h = 1 / (r - i),
      m = 1 / (s - o),
      g = (t + e) * f,
      y = (r + i) * h;
    let _, S;
    if (l === Ua) (_ = (s + o) * m), (S = -2 * m);
    else if (l === gm) (_ = o * m), (S = -1 * m);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l
      );
    return (
      (u[0] = 2 * f),
      (u[4] = 0),
      (u[8] = 0),
      (u[12] = -g),
      (u[1] = 0),
      (u[5] = 2 * h),
      (u[9] = 0),
      (u[13] = -y),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = S),
      (u[14] = -_),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = 0),
      (u[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const wd = new ie(),
  ea = new Wt(),
  c4 = new ie(0, 0, 0),
  f4 = new ie(1, 1, 1),
  Eu = new ie(),
  Yg = new ie(),
  Zo = new ie(),
  Bb = new Wt(),
  Vb = new Ji();
class ss {
  constructor(e = 0, t = 0, r = 0, i = ss.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements,
      o = i[0],
      s = i[4],
      l = i[8],
      u = i[1],
      f = i[5],
      h = i[9],
      m = i[2],
      g = i[6],
      y = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Mr(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, y)), (this._z = Math.atan2(-s, o)))
            : ((this._x = Math.atan2(g, f)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Mr(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(l, y)), (this._z = Math.atan2(u, f)))
            : ((this._y = Math.atan2(-m, o)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Mr(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._y = Math.atan2(-m, y)), (this._z = Math.atan2(-s, f)))
            : ((this._y = 0), (this._z = Math.atan2(u, o)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Mr(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._x = Math.atan2(g, y)), (this._z = Math.atan2(u, o)))
            : ((this._x = 0), (this._z = Math.atan2(-s, f)));
        break;
      case "YZX":
        (this._z = Math.asin(Mr(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-h, f)), (this._y = Math.atan2(-m, o)))
            : ((this._x = 0), (this._y = Math.atan2(l, y)));
        break;
      case "XZY":
        (this._z = Math.asin(-Mr(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(g, f)), (this._y = Math.atan2(l, o)))
            : ((this._x = Math.atan2(-h, y)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      Bb.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Bb, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Vb.setFromEuler(this), this.setFromQuaternion(Vb, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ss.DEFAULT_ORDER = "XYZ";
class ef {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let d4 = 0;
const Hb = new ie(),
  Md = new Ji(),
  vl = new Wt(),
  qg = new ie(),
  gp = new ie(),
  h4 = new ie(),
  p4 = new Ji(),
  Gb = new ie(1, 0, 0),
  Wb = new ie(0, 1, 0),
  jb = new ie(0, 0, 1),
  $b = { type: "added" },
  m4 = { type: "removed" },
  bd = { type: "childadded", child: null },
  g_ = { type: "childremoved", child: null };
class xn extends Ol {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: d4++ }),
      (this.uuid = is()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = xn.DEFAULT_UP.clone());
    const e = new ie(),
      t = new ss(),
      r = new Ji(),
      i = new ie(1, 1, 1);
    function o() {
      r.setFromEuler(t, !1);
    }
    function s() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(o),
      r._onChange(s),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Wt() },
        normalMatrix: { value: new Qt() },
      }),
      (this.matrix = new Wt()),
      (this.matrixWorld = new Wt()),
      (this.matrixAutoUpdate = xn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = xn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new ef()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Md.setFromAxisAngle(e, t), this.quaternion.multiply(Md), this;
  }
  rotateOnWorldAxis(e, t) {
    return Md.setFromAxisAngle(e, t), this.quaternion.premultiply(Md), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Gb, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Wb, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(jb, e);
  }
  translateOnAxis(e, t) {
    return (
      Hb.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Hb.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Gb, e);
  }
  translateY(e) {
    return this.translateOnAxis(Wb, e);
  }
  translateZ(e) {
    return this.translateOnAxis(jb, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(vl.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? qg.copy(e) : qg.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      gp.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? vl.lookAt(gp, qg, this.up)
        : vl.lookAt(qg, gp, this.up),
      this.quaternion.setFromRotationMatrix(vl),
      i &&
        (vl.extractRotation(i.matrixWorld),
        Md.setFromRotationMatrix(vl),
        this.quaternion.premultiply(Md.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent($b),
            (bd.child = e),
            this.dispatchEvent(bd),
            (bd.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(m4),
        (g_.child = e),
        this.dispatchEvent(g_),
        (g_.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      vl.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), vl.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(vl),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent($b),
      (bd.child = e),
      this.dispatchEvent(bd),
      (bd.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const s = this.children[r].getObjectByProperty(e, t);
      if (s !== void 0) return s;
    }
  }
  getObjectsByProperty(e, t, r = []) {
    this[e] === t && r.push(this);
    const i = this.children;
    for (let o = 0, s = i.length; o < s; o++)
      i[o].getObjectsByProperty(e, t, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(gp, e, h4), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(gp, p4, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const i = this.children;
      for (let o = 0, s = i.length; o < s; o++) i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((l) => ({
          boxInitialized: l.boxInitialized,
          boxMin: l.box.min.toArray(),
          boxMax: l.box.max.toArray(),
          sphereInitialized: l.sphereInitialized,
          sphereRadius: l.sphere.radius,
          sphereCenter: l.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function o(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let f = 0, h = u.length; f < h; f++) {
            const m = u[f];
            o(e.shapes, m);
          }
        else o(e.shapes, u);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, f = this.material.length; u < f; u++)
          l.push(o(e.materials, this.material[u]));
        i.material = l;
      } else i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let l = 0; l < this.children.length; l++)
        i.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        i.animations.push(o(e.animations, u));
      }
    }
    if (t) {
      const l = s(e.geometries),
        u = s(e.materials),
        f = s(e.textures),
        h = s(e.images),
        m = s(e.shapes),
        g = s(e.skeletons),
        y = s(e.animations),
        _ = s(e.nodes);
      l.length > 0 && (r.geometries = l),
        u.length > 0 && (r.materials = u),
        f.length > 0 && (r.textures = f),
        h.length > 0 && (r.images = h),
        m.length > 0 && (r.shapes = m),
        g.length > 0 && (r.skeletons = g),
        y.length > 0 && (r.animations = y),
        _.length > 0 && (r.nodes = _);
    }
    return (r.object = i), r;
    function s(l) {
      const u = [];
      for (const f in l) {
        const h = l[f];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
xn.DEFAULT_UP = new ie(0, 1, 0);
xn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
xn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ta = new ie(),
  yl = new ie(),
  v_ = new ie(),
  xl = new ie(),
  Ed = new ie(),
  Td = new ie(),
  Xb = new ie(),
  y_ = new ie(),
  x_ = new ie(),
  __ = new ie();
class es {
  constructor(e = new ie(), t = new ie(), r = new ie()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), ta.subVectors(e, t), i.cross(ta);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, o) {
    ta.subVectors(i, t), yl.subVectors(r, t), v_.subVectors(e, t);
    const s = ta.dot(ta),
      l = ta.dot(yl),
      u = ta.dot(v_),
      f = yl.dot(yl),
      h = yl.dot(v_),
      m = s * f - l * l;
    if (m === 0) return o.set(0, 0, 0), null;
    const g = 1 / m,
      y = (f * u - l * h) * g,
      _ = (s * h - l * u) * g;
    return o.set(1 - y - _, _, y);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, xl) === null
      ? !1
      : xl.x >= 0 && xl.y >= 0 && xl.x + xl.y <= 1;
  }
  static getInterpolation(e, t, r, i, o, s, l, u) {
    return this.getBarycoord(e, t, r, i, xl) === null
      ? ((u.x = 0),
        (u.y = 0),
        "z" in u && (u.z = 0),
        "w" in u && (u.w = 0),
        null)
      : (u.setScalar(0),
        u.addScaledVector(o, xl.x),
        u.addScaledVector(s, xl.y),
        u.addScaledVector(l, xl.z),
        u);
  }
  static isFrontFacing(e, t, r, i) {
    return ta.subVectors(r, t), yl.subVectors(e, t), ta.cross(yl).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      ta.subVectors(this.c, this.b),
      yl.subVectors(this.a, this.b),
      ta.cross(yl).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return es.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return es.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, r, i, o) {
    return es.getInterpolation(e, this.a, this.b, this.c, t, r, i, o);
  }
  containsPoint(e) {
    return es.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return es.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      i = this.b,
      o = this.c;
    let s, l;
    Ed.subVectors(i, r), Td.subVectors(o, r), y_.subVectors(e, r);
    const u = Ed.dot(y_),
      f = Td.dot(y_);
    if (u <= 0 && f <= 0) return t.copy(r);
    x_.subVectors(e, i);
    const h = Ed.dot(x_),
      m = Td.dot(x_);
    if (h >= 0 && m <= h) return t.copy(i);
    const g = u * m - h * f;
    if (g <= 0 && u >= 0 && h <= 0)
      return (s = u / (u - h)), t.copy(r).addScaledVector(Ed, s);
    __.subVectors(e, o);
    const y = Ed.dot(__),
      _ = Td.dot(__);
    if (_ >= 0 && y <= _) return t.copy(o);
    const S = y * f - u * _;
    if (S <= 0 && f >= 0 && _ <= 0)
      return (l = f / (f - _)), t.copy(r).addScaledVector(Td, l);
    const x = h * _ - y * m;
    if (x <= 0 && m - h >= 0 && y - _ >= 0)
      return (
        Xb.subVectors(o, i),
        (l = (m - h) / (m - h + (y - _))),
        t.copy(i).addScaledVector(Xb, l)
      );
    const w = 1 / (x + S + g);
    return (
      (s = S * w),
      (l = g * w),
      t.copy(r).addScaledVector(Ed, s).addScaledVector(Td, l)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const wA = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Tu = { h: 0, s: 0, l: 0 },
  Kg = { h: 0, s: 0, l: 0 };
function S_(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class St {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Ms) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      yn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, r, i = yn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      yn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, r, i = yn.workingColorSpace) {
    if (((e = HS(e, 1)), (t = Mr(t, 0, 1)), (r = Mr(r, 0, 1)), t === 0))
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        s = 2 * r - o;
      (this.r = S_(s, o, e + 1 / 3)),
        (this.g = S_(s, o, e)),
        (this.b = S_(s, o, e - 1 / 3));
    }
    return yn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Ms) {
    function r(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let o;
      const s = i[1],
        l = i[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (
            (o =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(255, parseInt(o[1], 10)) / 255,
                Math.min(255, parseInt(o[2], 10)) / 255,
                Math.min(255, parseInt(o[3], 10)) / 255,
                t
              )
            );
          if (
            (o =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(100, parseInt(o[1], 10)) / 100,
                Math.min(100, parseInt(o[2], 10)) / 100,
                Math.min(100, parseInt(o[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setHSL(
                parseFloat(o[1]) / 360,
                parseFloat(o[2]) / 100,
                parseFloat(o[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = i[1],
        s = o.length;
      if (s === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (s === 6) return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Ms) {
    const r = wA[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = ih(e.r)), (this.g = ih(e.g)), (this.b = ih(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = l_(e.r)), (this.g = l_(e.g)), (this.b = l_(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Ms) {
    return (
      yn.fromWorkingColorSpace(ji.copy(this), e),
      Math.round(Mr(ji.r * 255, 0, 255)) * 65536 +
        Math.round(Mr(ji.g * 255, 0, 255)) * 256 +
        Math.round(Mr(ji.b * 255, 0, 255))
    );
  }
  getHexString(e = Ms) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = yn.workingColorSpace) {
    yn.fromWorkingColorSpace(ji.copy(this), t);
    const r = ji.r,
      i = ji.g,
      o = ji.b,
      s = Math.max(r, i, o),
      l = Math.min(r, i, o);
    let u, f;
    const h = (l + s) / 2;
    if (l === s) (u = 0), (f = 0);
    else {
      const m = s - l;
      switch (((f = h <= 0.5 ? m / (s + l) : m / (2 - s - l)), s)) {
        case r:
          u = (i - o) / m + (i < o ? 6 : 0);
          break;
        case i:
          u = (o - r) / m + 2;
          break;
        case o:
          u = (r - i) / m + 4;
          break;
      }
      u /= 6;
    }
    return (e.h = u), (e.s = f), (e.l = h), e;
  }
  getRGB(e, t = yn.workingColorSpace) {
    return (
      yn.fromWorkingColorSpace(ji.copy(this), t),
      (e.r = ji.r),
      (e.g = ji.g),
      (e.b = ji.b),
      e
    );
  }
  getStyle(e = Ms) {
    yn.fromWorkingColorSpace(ji.copy(this), e);
    const t = ji.r,
      r = ji.g,
      i = ji.b;
    return e !== Ms
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(Tu), this.setHSL(Tu.h + e, Tu.s + t, Tu.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Tu), e.getHSL(Kg);
    const r = $p(Tu.h, Kg.h, t),
      i = $p(Tu.s, Kg.s, t),
      o = $p(Tu.l, Kg.l, t);
    return this.setHSL(r, i, o), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      i = this.b,
      o = e.elements;
    return (
      (this.r = o[0] * t + o[3] * r + o[6] * i),
      (this.g = o[1] * t + o[4] * r + o[7] * i),
      (this.b = o[2] * t + o[5] * r + o[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ji = new St();
St.NAMES = wA;
let g4 = 0;
class ki extends Ol {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: g4++ }),
      (this.uuid = is()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Zc),
      (this.side = Ga),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = c0),
      (this.blendDst = f0),
      (this.blendEquation = Lu),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new St(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = om),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = k1),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Gc),
      (this.stencilZFail = Gc),
      (this.stencilZPass = Gc),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (r.dispersion = this.dispersion),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (r.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Zc && (r.blending = this.blending),
      this.side !== Ga && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== c0 && (r.blendSrc = this.blendSrc),
      this.blendDst !== f0 && (r.blendDst = this.blendDst),
      this.blendEquation !== Lu && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== om && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== k1 && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Gc && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== Gc && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Gc && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(o) {
      const s = [];
      for (const l in o) {
        const u = o[l];
        delete u.metadata, s.push(u);
      }
      return s;
    }
    if (t) {
      const o = i(e.textures),
        s = i(e.images);
      o.length > 0 && (r.textures = o), s.length > 0 && (r.images = s);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let o = 0; o !== i; ++o) r[o] = t[o].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
  onBeforeRender() {
    console.warn("Material: onBeforeRender() has been removed.");
  }
}
class Nl extends ki {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ss()),
      (this.combine = Dm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const El = v4();
function v4() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const f = u - 127;
    f < -27
      ? ((r[u] = 0), (r[u | 256] = 32768), (i[u] = 24), (i[u | 256] = 24))
      : f < -14
      ? ((r[u] = 1024 >> (-f - 14)),
        (r[u | 256] = (1024 >> (-f - 14)) | 32768),
        (i[u] = -f - 1),
        (i[u | 256] = -f - 1))
      : f <= 15
      ? ((r[u] = (f + 15) << 10),
        (r[u | 256] = ((f + 15) << 10) | 32768),
        (i[u] = 13),
        (i[u | 256] = 13))
      : f < 128
      ? ((r[u] = 31744), (r[u | 256] = 64512), (i[u] = 24), (i[u | 256] = 24))
      : ((r[u] = 31744), (r[u | 256] = 64512), (i[u] = 13), (i[u | 256] = 13));
  }
  const o = new Uint32Array(2048),
    s = new Uint32Array(64),
    l = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let f = u << 13,
      h = 0;
    for (; (f & 8388608) === 0; ) (f <<= 1), (h -= 8388608);
    (f &= -8388609), (h += 947912704), (o[u] = f | h);
  }
  for (let u = 1024; u < 2048; ++u) o[u] = 939524096 + ((u - 1024) << 13);
  for (let u = 1; u < 31; ++u) s[u] = u << 23;
  (s[31] = 1199570944), (s[32] = 2147483648);
  for (let u = 33; u < 63; ++u) s[u] = 2147483648 + ((u - 32) << 23);
  s[63] = 3347054592;
  for (let u = 1; u < 64; ++u) u !== 32 && (l[u] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: s,
    offsetTable: l,
  };
}
function Do(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = Mr(n, -65504, 65504)),
    (El.floatView[0] = n);
  const e = El.uint32View[0],
    t = (e >> 23) & 511;
  return El.baseTable[t] + ((e & 8388607) >> El.shiftTable[t]);
}
function Lp(n) {
  const e = n >> 10;
  return (
    (El.uint32View[0] =
      El.mantissaTable[El.offsetTable[e] + (n & 1023)] + El.exponentTable[e]),
    El.floatView[0]
  );
}
const y4 = { toHalfFloat: Do, fromHalfFloat: Lp },
  Jr = new ie(),
  Zg = new tt();
class zn {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = mm),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = ko),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      rh(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        Zg.fromBufferAttribute(this, t),
          Zg.applyMatrix3(e),
          this.setXY(t, Zg.x, Zg.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        Jr.fromBufferAttribute(this, t),
          Jr.applyMatrix3(e),
          this.setXYZ(t, Jr.x, Jr.y, Jr.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Jr.fromBufferAttribute(this, t),
        Jr.applyMatrix4(e),
        this.setXYZ(t, Jr.x, Jr.y, Jr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Jr.fromBufferAttribute(this, t),
        Jr.applyNormalMatrix(e),
        this.setXYZ(t, Jr.x, Jr.y, Jr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Jr.fromBufferAttribute(this, t),
        Jr.transformDirection(e),
        this.setXYZ(t, Jr.x, Jr.y, Jr.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = po(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = on(r, this.array)),
      (this.array[e * this.itemSize + t] = r),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = po(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = po(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = po(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = po(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = on(t, this.array)), (r = on(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array)),
        (o = on(o, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== mm && (e.usage = this.usage),
      e
    );
  }
}
class x4 extends zn {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class _4 extends zn {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class S4 extends zn {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class w4 extends zn {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class WS extends zn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class M4 extends zn {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class jS extends zn {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class b4 extends zn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Lp(this.array[e * this.itemSize]);
    return this.normalized && (t = po(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize] = Do(t)),
      this
    );
  }
  getY(e) {
    let t = Lp(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = po(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 1] = Do(t)),
      this
    );
  }
  getZ(e) {
    let t = Lp(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = po(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 2] = Do(t)),
      this
    );
  }
  getW(e) {
    let t = Lp(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = po(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 3] = Do(t)),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = on(t, this.array)), (r = on(r, this.array))),
      (this.array[e + 0] = Do(t)),
      (this.array[e + 1] = Do(r)),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array))),
      (this.array[e + 0] = Do(t)),
      (this.array[e + 1] = Do(r)),
      (this.array[e + 2] = Do(i)),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array)),
        (o = on(o, this.array))),
      (this.array[e + 0] = Do(t)),
      (this.array[e + 1] = Do(r)),
      (this.array[e + 2] = Do(i)),
      (this.array[e + 3] = Do(o)),
      this
    );
  }
}
class Lt extends zn {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let E4 = 0;
const Ss = new Wt(),
  w_ = new xn(),
  Cd = new ie(),
  Jo = new Qi(),
  vp = new Qi(),
  vi = new ie();
class Kt extends Ol {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: E4++ }),
      (this.uuid = is()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (yA(e) ? jS : WS)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new Qt().getNormalMatrix(e);
      r.applyNormalMatrix(o), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Ss.makeRotationFromQuaternion(e), this.applyMatrix4(Ss), this;
  }
  rotateX(e) {
    return Ss.makeRotationX(e), this.applyMatrix4(Ss), this;
  }
  rotateY(e) {
    return Ss.makeRotationY(e), this.applyMatrix4(Ss), this;
  }
  rotateZ(e) {
    return Ss.makeRotationZ(e), this.applyMatrix4(Ss), this;
  }
  translate(e, t, r) {
    return Ss.makeTranslation(e, t, r), this.applyMatrix4(Ss), this;
  }
  scale(e, t, r) {
    return Ss.makeScale(e, t, r), this.applyMatrix4(Ss), this;
  }
  lookAt(e) {
    return w_.lookAt(e), w_.updateMatrix(), this.applyMatrix4(w_.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Cd).negate(),
      this.translate(Cd.x, Cd.y, Cd.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const o = e[r];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new Lt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Qi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new ie(-1 / 0, -1 / 0, -1 / 0),
          new ie(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, i = t.length; r < i; r++) {
          const o = t[r];
          Jo.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (vi.addVectors(this.boundingBox.min, Jo.min),
                this.boundingBox.expandByPoint(vi),
                vi.addVectors(this.boundingBox.max, Jo.max),
                this.boundingBox.expandByPoint(vi))
              : (this.boundingBox.expandByPoint(Jo.min),
                this.boundingBox.expandByPoint(Jo.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Di());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new ie(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((Jo.setFromBufferAttribute(e), t))
        for (let o = 0, s = t.length; o < s; o++) {
          const l = t[o];
          vp.setFromBufferAttribute(l),
            this.morphTargetsRelative
              ? (vi.addVectors(Jo.min, vp.min),
                Jo.expandByPoint(vi),
                vi.addVectors(Jo.max, vp.max),
                Jo.expandByPoint(vi))
              : (Jo.expandByPoint(vp.min), Jo.expandByPoint(vp.max));
        }
      Jo.getCenter(r);
      let i = 0;
      for (let o = 0, s = e.count; o < s; o++)
        vi.fromBufferAttribute(e, o),
          (i = Math.max(i, r.distanceToSquared(vi)));
      if (t)
        for (let o = 0, s = t.length; o < s; o++) {
          const l = t[o],
            u = this.morphTargetsRelative;
          for (let f = 0, h = l.count; f < h; f++)
            vi.fromBufferAttribute(l, f),
              u && (Cd.fromBufferAttribute(e, f), vi.add(Cd)),
              (i = Math.max(i, r.distanceToSquared(vi)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = t.position,
      i = t.normal,
      o = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new zn(new Float32Array(4 * r.count), 4));
    const s = this.getAttribute("tangent"),
      l = [],
      u = [];
    for (let U = 0; U < r.count; U++) (l[U] = new ie()), (u[U] = new ie());
    const f = new ie(),
      h = new ie(),
      m = new ie(),
      g = new tt(),
      y = new tt(),
      _ = new tt(),
      S = new ie(),
      x = new ie();
    function w(U, O, L) {
      f.fromBufferAttribute(r, U),
        h.fromBufferAttribute(r, O),
        m.fromBufferAttribute(r, L),
        g.fromBufferAttribute(o, U),
        y.fromBufferAttribute(o, O),
        _.fromBufferAttribute(o, L),
        h.sub(f),
        m.sub(f),
        y.sub(g),
        _.sub(g);
      const V = 1 / (y.x * _.y - _.x * y.y);
      isFinite(V) &&
        (S.copy(h)
          .multiplyScalar(_.y)
          .addScaledVector(m, -y.y)
          .multiplyScalar(V),
        x
          .copy(m)
          .multiplyScalar(y.x)
          .addScaledVector(h, -_.x)
          .multiplyScalar(V),
        l[U].add(S),
        l[O].add(S),
        l[L].add(S),
        u[U].add(x),
        u[O].add(x),
        u[L].add(x));
    }
    let T = this.groups;
    T.length === 0 && (T = [{ start: 0, count: e.count }]);
    for (let U = 0, O = T.length; U < O; ++U) {
      const L = T[U],
        V = L.start,
        H = L.count;
      for (let $ = V, q = V + H; $ < q; $ += 3)
        w(e.getX($ + 0), e.getX($ + 1), e.getX($ + 2));
    }
    const E = new ie(),
      A = new ie(),
      R = new ie(),
      D = new ie();
    function I(U) {
      R.fromBufferAttribute(i, U), D.copy(R);
      const O = l[U];
      E.copy(O),
        E.sub(R.multiplyScalar(R.dot(O))).normalize(),
        A.crossVectors(D, O);
      const V = A.dot(u[U]) < 0 ? -1 : 1;
      s.setXYZW(U, E.x, E.y, E.z, V);
    }
    for (let U = 0, O = T.length; U < O; ++U) {
      const L = T[U],
        V = L.start,
        H = L.count;
      for (let $ = V, q = V + H; $ < q; $ += 3)
        I(e.getX($ + 0)), I(e.getX($ + 1)), I(e.getX($ + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new zn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let g = 0, y = r.count; g < y; g++) r.setXYZ(g, 0, 0, 0);
      const i = new ie(),
        o = new ie(),
        s = new ie(),
        l = new ie(),
        u = new ie(),
        f = new ie(),
        h = new ie(),
        m = new ie();
      if (e)
        for (let g = 0, y = e.count; g < y; g += 3) {
          const _ = e.getX(g + 0),
            S = e.getX(g + 1),
            x = e.getX(g + 2);
          i.fromBufferAttribute(t, _),
            o.fromBufferAttribute(t, S),
            s.fromBufferAttribute(t, x),
            h.subVectors(s, o),
            m.subVectors(i, o),
            h.cross(m),
            l.fromBufferAttribute(r, _),
            u.fromBufferAttribute(r, S),
            f.fromBufferAttribute(r, x),
            l.add(h),
            u.add(h),
            f.add(h),
            r.setXYZ(_, l.x, l.y, l.z),
            r.setXYZ(S, u.x, u.y, u.z),
            r.setXYZ(x, f.x, f.y, f.z);
        }
      else
        for (let g = 0, y = t.count; g < y; g += 3)
          i.fromBufferAttribute(t, g + 0),
            o.fromBufferAttribute(t, g + 1),
            s.fromBufferAttribute(t, g + 2),
            h.subVectors(s, o),
            m.subVectors(i, o),
            h.cross(m),
            r.setXYZ(g + 0, h.x, h.y, h.z),
            r.setXYZ(g + 1, h.x, h.y, h.z),
            r.setXYZ(g + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      vi.fromBufferAttribute(e, t),
        vi.normalize(),
        e.setXYZ(t, vi.x, vi.y, vi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const f = l.array,
        h = l.itemSize,
        m = l.normalized,
        g = new f.constructor(u.length * h);
      let y = 0,
        _ = 0;
      for (let S = 0, x = u.length; S < x; S++) {
        l.isInterleavedBufferAttribute
          ? (y = u[S] * l.data.stride + l.offset)
          : (y = u[S] * h);
        for (let w = 0; w < h; w++) g[_++] = f[y++];
      }
      return new zn(g, h, m);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new Kt(),
      r = this.index.array,
      i = this.attributes;
    for (const l in i) {
      const u = i[l],
        f = e(u, r);
      t.setAttribute(l, f);
    }
    const o = this.morphAttributes;
    for (const l in o) {
      const u = [],
        f = o[l];
      for (let h = 0, m = f.length; h < m; h++) {
        const g = f[h],
          y = e(g, r);
        u.push(y);
      }
      t.morphAttributes[l] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let l = 0, u = s.length; l < u; l++) {
      const f = s[l];
      t.addGroup(f.start, f.count, f.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const u = this.parameters;
      for (const f in u) u[f] !== void 0 && (e[f] = u[f]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const u in r) {
      const f = r[u];
      e.data.attributes[u] = f.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const u in this.morphAttributes) {
      const f = this.morphAttributes[u],
        h = [];
      for (let m = 0, g = f.length; m < g; m++) {
        const y = f[m];
        h.push(y.toJSON(e.data));
      }
      h.length > 0 && ((i[u] = h), (o = !0));
    }
    o &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    const l = this.boundingSphere;
    return (
      l !== null &&
        (e.data.boundingSphere = {
          center: l.center.toArray(),
          radius: l.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const f in i) {
      const h = i[f];
      this.setAttribute(f, h.clone(t));
    }
    const o = e.morphAttributes;
    for (const f in o) {
      const h = [],
        m = o[f];
      for (let g = 0, y = m.length; g < y; g++) h.push(m[g].clone(t));
      this.morphAttributes[f] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const s = e.groups;
    for (let f = 0, h = s.length; f < h; f++) {
      const m = s[f];
      this.addGroup(m.start, m.count, m.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Yb = new Wt(),
  Cc = new hf(),
  Jg = new Di(),
  qb = new ie(),
  Ad = new ie(),
  Rd = new ie(),
  Pd = new ie(),
  M_ = new ie(),
  Qg = new ie(),
  ev = new tt(),
  tv = new tt(),
  nv = new tt(),
  Kb = new ie(),
  Zb = new ie(),
  Jb = new ie(),
  rv = new ie(),
  iv = new ie();
class dr extends xn {
  constructor(e = new Kt(), t = new Nl()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const l = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      i = r.attributes.position,
      o = r.morphAttributes.position,
      s = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const l = this.morphTargetInfluences;
    if (o && l) {
      Qg.set(0, 0, 0);
      for (let u = 0, f = o.length; u < f; u++) {
        const h = l[u],
          m = o[u];
        h !== 0 &&
          (M_.fromBufferAttribute(m, e),
          s ? Qg.addScaledVector(M_, h) : Qg.addScaledVector(M_.sub(t), h));
      }
      t.add(Qg);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.material,
      o = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Jg.copy(r.boundingSphere),
      Jg.applyMatrix4(o),
      Cc.copy(e.ray).recast(e.near),
      !(
        Jg.containsPoint(Cc.origin) === !1 &&
        (Cc.intersectSphere(Jg, qb) === null ||
          Cc.origin.distanceToSquared(qb) > (e.far - e.near) ** 2)
      ) &&
        (Yb.copy(o).invert(),
        Cc.copy(e.ray).applyMatrix4(Yb),
        !(r.boundingBox !== null && Cc.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, t, Cc)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const o = this.geometry,
      s = this.material,
      l = o.index,
      u = o.attributes.position,
      f = o.attributes.uv,
      h = o.attributes.uv1,
      m = o.attributes.normal,
      g = o.groups,
      y = o.drawRange;
    if (l !== null)
      if (Array.isArray(s))
        for (let _ = 0, S = g.length; _ < S; _++) {
          const x = g[_],
            w = s[x.materialIndex],
            T = Math.max(x.start, y.start),
            E = Math.min(
              l.count,
              Math.min(x.start + x.count, y.start + y.count)
            );
          for (let A = T, R = E; A < R; A += 3) {
            const D = l.getX(A),
              I = l.getX(A + 1),
              U = l.getX(A + 2);
            (i = ov(this, w, e, r, f, h, m, D, I, U)),
              i &&
                ((i.faceIndex = Math.floor(A / 3)),
                (i.face.materialIndex = x.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, y.start),
          S = Math.min(l.count, y.start + y.count);
        for (let x = _, w = S; x < w; x += 3) {
          const T = l.getX(x),
            E = l.getX(x + 1),
            A = l.getX(x + 2);
          (i = ov(this, s, e, r, f, h, m, T, E, A)),
            i && ((i.faceIndex = Math.floor(x / 3)), t.push(i));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(s))
        for (let _ = 0, S = g.length; _ < S; _++) {
          const x = g[_],
            w = s[x.materialIndex],
            T = Math.max(x.start, y.start),
            E = Math.min(
              u.count,
              Math.min(x.start + x.count, y.start + y.count)
            );
          for (let A = T, R = E; A < R; A += 3) {
            const D = A,
              I = A + 1,
              U = A + 2;
            (i = ov(this, w, e, r, f, h, m, D, I, U)),
              i &&
                ((i.faceIndex = Math.floor(A / 3)),
                (i.face.materialIndex = x.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, y.start),
          S = Math.min(u.count, y.start + y.count);
        for (let x = _, w = S; x < w; x += 3) {
          const T = x,
            E = x + 1,
            A = x + 2;
          (i = ov(this, s, e, r, f, h, m, T, E, A)),
            i && ((i.faceIndex = Math.floor(x / 3)), t.push(i));
        }
      }
  }
}
function T4(n, e, t, r, i, o, s, l) {
  let u;
  if (
    (e.side === Zi
      ? (u = r.intersectTriangle(s, o, i, !0, l))
      : (u = r.intersectTriangle(i, o, s, e.side === Ga, l)),
    u === null)
  )
    return null;
  iv.copy(l), iv.applyMatrix4(n.matrixWorld);
  const f = t.ray.origin.distanceTo(iv);
  return f < t.near || f > t.far
    ? null
    : { distance: f, point: iv.clone(), object: n };
}
function ov(n, e, t, r, i, o, s, l, u, f) {
  n.getVertexPosition(l, Ad),
    n.getVertexPosition(u, Rd),
    n.getVertexPosition(f, Pd);
  const h = T4(n, e, t, r, Ad, Rd, Pd, rv);
  if (h) {
    i &&
      (ev.fromBufferAttribute(i, l),
      tv.fromBufferAttribute(i, u),
      nv.fromBufferAttribute(i, f),
      (h.uv = es.getInterpolation(rv, Ad, Rd, Pd, ev, tv, nv, new tt()))),
      o &&
        (ev.fromBufferAttribute(o, l),
        tv.fromBufferAttribute(o, u),
        nv.fromBufferAttribute(o, f),
        (h.uv1 = es.getInterpolation(rv, Ad, Rd, Pd, ev, tv, nv, new tt()))),
      s &&
        (Kb.fromBufferAttribute(s, l),
        Zb.fromBufferAttribute(s, u),
        Jb.fromBufferAttribute(s, f),
        (h.normal = es.getInterpolation(rv, Ad, Rd, Pd, Kb, Zb, Jb, new ie())),
        h.normal.dot(r.direction) > 0 && h.normal.multiplyScalar(-1));
    const m = { a: l, b: u, c: f, normal: new ie(), materialIndex: 0 };
    es.getNormal(Ad, Rd, Pd, m.normal), (h.face = m);
  }
  return h;
}
class pf extends Kt {
  constructor(e = 1, t = 1, r = 1, i = 1, o = 1, s = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: o,
        depthSegments: s,
      });
    const l = this;
    (i = Math.floor(i)), (o = Math.floor(o)), (s = Math.floor(s));
    const u = [],
      f = [],
      h = [],
      m = [];
    let g = 0,
      y = 0;
    _("z", "y", "x", -1, -1, r, t, e, s, o, 0),
      _("z", "y", "x", 1, -1, r, t, -e, s, o, 1),
      _("x", "z", "y", 1, 1, e, r, t, i, s, 2),
      _("x", "z", "y", 1, -1, e, r, -t, i, s, 3),
      _("x", "y", "z", 1, -1, e, t, r, i, o, 4),
      _("x", "y", "z", -1, -1, e, t, -r, i, o, 5),
      this.setIndex(u),
      this.setAttribute("position", new Lt(f, 3)),
      this.setAttribute("normal", new Lt(h, 3)),
      this.setAttribute("uv", new Lt(m, 2));
    function _(S, x, w, T, E, A, R, D, I, U, O) {
      const L = A / I,
        V = R / U,
        H = A / 2,
        $ = R / 2,
        q = D / 2,
        K = I + 1,
        Y = U + 1;
      let ne = 0,
        j = 0;
      const re = new ie();
      for (let B = 0; B < Y; B++) {
        const G = B * V - $;
        for (let te = 0; te < K; te++) {
          const le = te * L - H;
          (re[S] = le * T),
            (re[x] = G * E),
            (re[w] = q),
            f.push(re.x, re.y, re.z),
            (re[S] = 0),
            (re[x] = 0),
            (re[w] = D > 0 ? 1 : -1),
            h.push(re.x, re.y, re.z),
            m.push(te / I),
            m.push(1 - B / U),
            (ne += 1);
        }
      }
      for (let B = 0; B < U; B++)
        for (let G = 0; G < I; G++) {
          const te = g + G + K * B,
            le = g + G + K * (B + 1),
            J = g + (G + 1) + K * (B + 1),
            oe = g + (G + 1) + K * B;
          u.push(te, le, oe), u.push(le, J, oe), (j += 6);
        }
      l.addGroup(y, j, O), (y += j), (g += ne);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new pf(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function fh(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = i.clone())
        : Array.isArray(i)
        ? (e[t][r] = i.slice())
        : (e[t][r] = i);
    }
  }
  return e;
}
function ho(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = fh(n[t]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function C4(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function MA(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : yn.workingColorSpace;
}
const $S = { clone: fh, merge: ho };
var A4 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  R4 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class la extends ki {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = A4),
      (this.fragmentShader = R4),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = fh(e.uniforms)),
      (this.uniformsGroups = C4(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const s = this.uniforms[i].value;
      s && s.isTexture
        ? (t.uniforms[i] = { type: "t", value: s.toJSON(e).uuid })
        : s && s.isColor
        ? (t.uniforms[i] = { type: "c", value: s.getHex() })
        : s && s.isVector2
        ? (t.uniforms[i] = { type: "v2", value: s.toArray() })
        : s && s.isVector3
        ? (t.uniforms[i] = { type: "v3", value: s.toArray() })
        : s && s.isVector4
        ? (t.uniforms[i] = { type: "v4", value: s.toArray() })
        : s && s.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: s.toArray() })
        : s && s.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: s.toArray() })
        : (t.uniforms[i] = { value: s });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class Nm extends xn {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Wt()),
      (this.projectionMatrix = new Wt()),
      (this.projectionMatrixInverse = new Wt()),
      (this.coordinateSystem = Ua);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Cu = new ie(),
  Qb = new tt(),
  eE = new tt();
class Dr extends Nm {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = ch * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Qc * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return ch * 2 * Math.atan(Math.tan(Qc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, r) {
    Cu.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Cu.x, Cu.y).multiplyScalar(-e / Cu.z),
      Cu.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      r.set(Cu.x, Cu.y).multiplyScalar(-e / Cu.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, Qb, eE), t.subVectors(eE, Qb);
  }
  setViewOffset(e, t, r, i, o, s) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Qc * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      i = this.aspect * r,
      o = -0.5 * i;
    const s = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = s.fullWidth,
        f = s.fullHeight;
      (o += (s.offsetX * i) / u),
        (t -= (s.offsetY * r) / f),
        (i *= s.width / u),
        (r *= s.height / f);
    }
    const l = this.filmOffset;
    l !== 0 && (o += (e * l) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        o,
        o + i,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Id = -90,
  Ld = 1;
class bA extends xn {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Dr(Id, Ld, e, t);
    (i.layers = this.layers), this.add(i);
    const o = new Dr(Id, Ld, e, t);
    (o.layers = this.layers), this.add(o);
    const s = new Dr(Id, Ld, e, t);
    (s.layers = this.layers), this.add(s);
    const l = new Dr(Id, Ld, e, t);
    (l.layers = this.layers), this.add(l);
    const u = new Dr(Id, Ld, e, t);
    (u.layers = this.layers), this.add(u);
    const f = new Dr(Id, Ld, e, t);
    (f.layers = this.layers), this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, i, o, s, l, u] = t;
    for (const f of t) this.remove(f);
    if (e === Ua)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, -1, 0),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, -1);
    else if (e === gm)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, -1, 0),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, 1),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const f of t) this.add(f), f.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [o, s, l, u, f, h] = this.children,
      m = e.getRenderTarget(),
      g = e.getActiveCubeFace(),
      y = e.getActiveMipmapLevel(),
      _ = e.xr.enabled;
    e.xr.enabled = !1;
    const S = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(t, o),
      e.setRenderTarget(r, 1, i),
      e.render(t, s),
      e.setRenderTarget(r, 2, i),
      e.render(t, l),
      e.setRenderTarget(r, 3, i),
      e.render(t, u),
      e.setRenderTarget(r, 4, i),
      e.render(t, f),
      (r.texture.generateMipmaps = S),
      e.setRenderTarget(r, 5, i),
      e.render(t, h),
      e.setRenderTarget(m, g, y),
      (e.xr.enabled = _),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class Um extends rr {
  constructor(e, t, r, i, o, s, l, u, f, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Il),
      super(e, t, r, i, o, s, l, u, f, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class EA extends aa {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    (this.texture = new Um(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : br);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new pf(5, 5, 5),
      o = new la({
        name: "CubemapFromEquirect",
        uniforms: fh(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: Zi,
        blending: Al,
      });
    o.uniforms.tEquirect.value = t;
    const s = new dr(i, o),
      l = t.minFilter;
    return (
      t.minFilter === Na && (t.minFilter = br),
      new bA(1, 10, this).update(e, s),
      (t.minFilter = l),
      s.geometry.dispose(),
      s.material.dispose(),
      this
    );
  }
  clear(e, t, r, i) {
    const o = e.getRenderTarget();
    for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, r, i);
    e.setRenderTarget(o);
  }
}
const b_ = new ie(),
  P4 = new ie(),
  I4 = new Qt();
class wl {
  constructor(e = new ie(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = b_.subVectors(r, t).cross(P4.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(b_),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(r, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || I4.getNormalMatrix(e),
      i = this.coplanarPoint(b_).applyMatrix4(e),
      o = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ac = new Di(),
  sv = new ie();
class Fm {
  constructor(
    e = new wl(),
    t = new wl(),
    r = new wl(),
    i = new wl(),
    o = new wl(),
    s = new wl()
  ) {
    this.planes = [e, t, r, i, o, s];
  }
  set(e, t, r, i, o, s) {
    const l = this.planes;
    return (
      l[0].copy(e),
      l[1].copy(t),
      l[2].copy(r),
      l[3].copy(i),
      l[4].copy(o),
      l[5].copy(s),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ua) {
    const r = this.planes,
      i = e.elements,
      o = i[0],
      s = i[1],
      l = i[2],
      u = i[3],
      f = i[4],
      h = i[5],
      m = i[6],
      g = i[7],
      y = i[8],
      _ = i[9],
      S = i[10],
      x = i[11],
      w = i[12],
      T = i[13],
      E = i[14],
      A = i[15];
    if (
      (r[0].setComponents(u - o, g - f, x - y, A - w).normalize(),
      r[1].setComponents(u + o, g + f, x + y, A + w).normalize(),
      r[2].setComponents(u + s, g + h, x + _, A + T).normalize(),
      r[3].setComponents(u - s, g - h, x - _, A - T).normalize(),
      r[4].setComponents(u - l, g - m, x - S, A - E).normalize(),
      t === Ua)
    )
      r[5].setComponents(u + l, g + m, x + S, A + E).normalize();
    else if (t === gm) r[5].setComponents(l, m, S, E).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Ac.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Ac.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Ac);
  }
  intersectsSprite(e) {
    return (
      Ac.center.set(0, 0, 0),
      (Ac.radius = 0.7071067811865476),
      Ac.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ac)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      i = -e.radius;
    for (let o = 0; o < 6; o++) if (t[o].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (
        ((sv.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (sv.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (sv.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(sv) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function TA() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function i(o, s) {
    t(o, s), (r = n.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (o) {
      t = o;
    },
    setContext: function (o) {
      n = o;
    },
  };
}
function L4(n) {
  const e = new WeakMap();
  function t(l, u) {
    const f = l.array,
      h = l.usage,
      m = f.byteLength,
      g = n.createBuffer();
    n.bindBuffer(u, g), n.bufferData(u, f, h), l.onUploadCallback();
    let y;
    if (f instanceof Float32Array) y = n.FLOAT;
    else if (f instanceof Uint16Array)
      l.isFloat16BufferAttribute ? (y = n.HALF_FLOAT) : (y = n.UNSIGNED_SHORT);
    else if (f instanceof Int16Array) y = n.SHORT;
    else if (f instanceof Uint32Array) y = n.UNSIGNED_INT;
    else if (f instanceof Int32Array) y = n.INT;
    else if (f instanceof Int8Array) y = n.BYTE;
    else if (f instanceof Uint8Array) y = n.UNSIGNED_BYTE;
    else if (f instanceof Uint8ClampedArray) y = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + f
      );
    return {
      buffer: g,
      type: y,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: l.version,
      size: m,
    };
  }
  function r(l, u, f) {
    const h = u.array,
      m = u._updateRange,
      g = u.updateRanges;
    if (
      (n.bindBuffer(f, l),
      m.count === -1 && g.length === 0 && n.bufferSubData(f, 0, h),
      g.length !== 0)
    ) {
      for (let y = 0, _ = g.length; y < _; y++) {
        const S = g[y];
        n.bufferSubData(f, S.start * h.BYTES_PER_ELEMENT, h, S.start, S.count);
      }
      u.clearUpdateRanges();
    }
    m.count !== -1 &&
      (n.bufferSubData(f, m.offset * h.BYTES_PER_ELEMENT, h, m.offset, m.count),
      (m.count = -1)),
      u.onUploadCallback();
  }
  function i(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = e.get(l);
    u && (n.deleteBuffer(u.buffer), e.delete(l));
  }
  function s(l, u) {
    if (
      (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute)
    ) {
      const h = e.get(l);
      (!h || h.version < l.version) &&
        e.set(l, {
          buffer: l.buffer,
          type: l.type,
          bytesPerElement: l.elementSize,
          version: l.version,
        });
      return;
    }
    const f = e.get(l);
    if (f === void 0) e.set(l, t(l, u));
    else if (f.version < l.version) {
      if (f.size !== l.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      r(f.buffer, l, u), (f.version = l.version);
    }
  }
  return { get: i, remove: o, update: s };
}
class Ul extends Kt {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: i,
      });
    const o = e / 2,
      s = t / 2,
      l = Math.floor(r),
      u = Math.floor(i),
      f = l + 1,
      h = u + 1,
      m = e / l,
      g = t / u,
      y = [],
      _ = [],
      S = [],
      x = [];
    for (let w = 0; w < h; w++) {
      const T = w * g - s;
      for (let E = 0; E < f; E++) {
        const A = E * m - o;
        _.push(A, -T, 0), S.push(0, 0, 1), x.push(E / l), x.push(1 - w / u);
      }
    }
    for (let w = 0; w < u; w++)
      for (let T = 0; T < l; T++) {
        const E = T + f * w,
          A = T + f * (w + 1),
          R = T + 1 + f * (w + 1),
          D = T + 1 + f * w;
        y.push(E, A, D), y.push(A, R, D);
      }
    this.setIndex(y),
      this.setAttribute("position", new Lt(_, 3)),
      this.setAttribute("normal", new Lt(S, 3)),
      this.setAttribute("uv", new Lt(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ul(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var D4 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  k4 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  O4 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  N4 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  U4 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  F4 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  z4 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  B4 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  V4 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  H4 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  G4 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  W4 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  j4 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  $4 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  X4 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Y4 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  q4 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  K4 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Z4 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  J4 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Q4 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  ez = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  tz = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  nz = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  rz = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  iz = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  oz = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  sz = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  az = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  lz = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  uz = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  cz = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  fz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  dz = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  hz = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  pz = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  mz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  gz = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  vz = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  yz = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  xz = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  _z = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  Sz = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  wz = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  Mz = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  bz = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Ez = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  Tz = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  Cz = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  Az = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  Rz = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Pz = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  Iz = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Lz = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Dz = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  kz = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  Oz = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Nz = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Uz = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Fz = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  zz = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Bz = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Vz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Hz = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Gz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Wz = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  jz = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  $z = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Xz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Yz = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  qz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Kz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  Zz = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Jz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Qz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  eB = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  tB = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  nB = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  rB = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  iB = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  oB = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  sB = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  aB = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  lB = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  uB = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  cB = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  fB = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  dB = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  hB = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  pB = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  mB = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  gB = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  vB = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  yB = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  xB = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  _B = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  SB = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  wB = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  MB = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  bB = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  EB = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  TB = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  CB = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  AB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  RB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  PB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  IB = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const LB = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  DB = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  kB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  OB = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  NB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  UB = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  FB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  zB = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  BB = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  VB = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  HB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  GB = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  WB = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  jB = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  $B = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  XB = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  YB = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  qB = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  KB = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  ZB = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  JB = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  QB = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  e5 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  t5 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  n5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  r5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  i5 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  o5 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  s5 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  a5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  l5 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  u5 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  c5 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  f5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  rn = {
    alphahash_fragment: D4,
    alphahash_pars_fragment: k4,
    alphamap_fragment: O4,
    alphamap_pars_fragment: N4,
    alphatest_fragment: U4,
    alphatest_pars_fragment: F4,
    aomap_fragment: z4,
    aomap_pars_fragment: B4,
    batching_pars_vertex: V4,
    batching_vertex: H4,
    begin_vertex: G4,
    beginnormal_vertex: W4,
    bsdfs: j4,
    iridescence_fragment: $4,
    bumpmap_pars_fragment: X4,
    clipping_planes_fragment: Y4,
    clipping_planes_pars_fragment: q4,
    clipping_planes_pars_vertex: K4,
    clipping_planes_vertex: Z4,
    color_fragment: J4,
    color_pars_fragment: Q4,
    color_pars_vertex: ez,
    color_vertex: tz,
    common: nz,
    cube_uv_reflection_fragment: rz,
    defaultnormal_vertex: iz,
    displacementmap_pars_vertex: oz,
    displacementmap_vertex: sz,
    emissivemap_fragment: az,
    emissivemap_pars_fragment: lz,
    colorspace_fragment: uz,
    colorspace_pars_fragment: cz,
    envmap_fragment: fz,
    envmap_common_pars_fragment: dz,
    envmap_pars_fragment: hz,
    envmap_pars_vertex: pz,
    envmap_physical_pars_fragment: Ez,
    envmap_vertex: mz,
    fog_vertex: gz,
    fog_pars_vertex: vz,
    fog_fragment: yz,
    fog_pars_fragment: xz,
    gradientmap_pars_fragment: _z,
    lightmap_pars_fragment: Sz,
    lights_lambert_fragment: wz,
    lights_lambert_pars_fragment: Mz,
    lights_pars_begin: bz,
    lights_toon_fragment: Tz,
    lights_toon_pars_fragment: Cz,
    lights_phong_fragment: Az,
    lights_phong_pars_fragment: Rz,
    lights_physical_fragment: Pz,
    lights_physical_pars_fragment: Iz,
    lights_fragment_begin: Lz,
    lights_fragment_maps: Dz,
    lights_fragment_end: kz,
    logdepthbuf_fragment: Oz,
    logdepthbuf_pars_fragment: Nz,
    logdepthbuf_pars_vertex: Uz,
    logdepthbuf_vertex: Fz,
    map_fragment: zz,
    map_pars_fragment: Bz,
    map_particle_fragment: Vz,
    map_particle_pars_fragment: Hz,
    metalnessmap_fragment: Gz,
    metalnessmap_pars_fragment: Wz,
    morphinstance_vertex: jz,
    morphcolor_vertex: $z,
    morphnormal_vertex: Xz,
    morphtarget_pars_vertex: Yz,
    morphtarget_vertex: qz,
    normal_fragment_begin: Kz,
    normal_fragment_maps: Zz,
    normal_pars_fragment: Jz,
    normal_pars_vertex: Qz,
    normal_vertex: eB,
    normalmap_pars_fragment: tB,
    clearcoat_normal_fragment_begin: nB,
    clearcoat_normal_fragment_maps: rB,
    clearcoat_pars_fragment: iB,
    iridescence_pars_fragment: oB,
    opaque_fragment: sB,
    packing: aB,
    premultiplied_alpha_fragment: lB,
    project_vertex: uB,
    dithering_fragment: cB,
    dithering_pars_fragment: fB,
    roughnessmap_fragment: dB,
    roughnessmap_pars_fragment: hB,
    shadowmap_pars_fragment: pB,
    shadowmap_pars_vertex: mB,
    shadowmap_vertex: gB,
    shadowmask_pars_fragment: vB,
    skinbase_vertex: yB,
    skinning_pars_vertex: xB,
    skinning_vertex: _B,
    skinnormal_vertex: SB,
    specularmap_fragment: wB,
    specularmap_pars_fragment: MB,
    tonemapping_fragment: bB,
    tonemapping_pars_fragment: EB,
    transmission_fragment: TB,
    transmission_pars_fragment: CB,
    uv_pars_fragment: AB,
    uv_pars_vertex: RB,
    uv_vertex: PB,
    worldpos_vertex: IB,
    background_vert: LB,
    background_frag: DB,
    backgroundCube_vert: kB,
    backgroundCube_frag: OB,
    cube_vert: NB,
    cube_frag: UB,
    depth_vert: FB,
    depth_frag: zB,
    distanceRGBA_vert: BB,
    distanceRGBA_frag: VB,
    equirect_vert: HB,
    equirect_frag: GB,
    linedashed_vert: WB,
    linedashed_frag: jB,
    meshbasic_vert: $B,
    meshbasic_frag: XB,
    meshlambert_vert: YB,
    meshlambert_frag: qB,
    meshmatcap_vert: KB,
    meshmatcap_frag: ZB,
    meshnormal_vert: JB,
    meshnormal_frag: QB,
    meshphong_vert: e5,
    meshphong_frag: t5,
    meshphysical_vert: n5,
    meshphysical_frag: r5,
    meshtoon_vert: i5,
    meshtoon_frag: o5,
    points_vert: s5,
    points_frag: a5,
    shadow_vert: l5,
    shadow_frag: u5,
    sprite_vert: c5,
    sprite_frag: f5,
  },
  xt = {
    common: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Qt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Qt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Qt() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Qt() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Qt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Qt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Qt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Qt() },
      normalScale: { value: new tt(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Qt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Qt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Qt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Qt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new St(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Qt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Qt() },
    },
    sprite: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      center: { value: new tt(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Qt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Qt() },
      alphaTest: { value: 0 },
    },
  },
  ra = {
    basic: {
      uniforms: ho([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.fog,
      ]),
      vertexShader: rn.meshbasic_vert,
      fragmentShader: rn.meshbasic_frag,
    },
    lambert: {
      uniforms: ho([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new St(0) } },
      ]),
      vertexShader: rn.meshlambert_vert,
      fragmentShader: rn.meshlambert_frag,
    },
    phong: {
      uniforms: ho([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new St(0) },
          specular: { value: new St(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: rn.meshphong_vert,
      fragmentShader: rn.meshphong_frag,
    },
    standard: {
      uniforms: ho([
        xt.common,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.roughnessmap,
        xt.metalnessmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new St(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: rn.meshphysical_vert,
      fragmentShader: rn.meshphysical_frag,
    },
    toon: {
      uniforms: ho([
        xt.common,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.gradientmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new St(0) } },
      ]),
      vertexShader: rn.meshtoon_vert,
      fragmentShader: rn.meshtoon_frag,
    },
    matcap: {
      uniforms: ho([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: rn.meshmatcap_vert,
      fragmentShader: rn.meshmatcap_frag,
    },
    points: {
      uniforms: ho([xt.points, xt.fog]),
      vertexShader: rn.points_vert,
      fragmentShader: rn.points_frag,
    },
    dashed: {
      uniforms: ho([
        xt.common,
        xt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: rn.linedashed_vert,
      fragmentShader: rn.linedashed_frag,
    },
    depth: {
      uniforms: ho([xt.common, xt.displacementmap]),
      vertexShader: rn.depth_vert,
      fragmentShader: rn.depth_frag,
    },
    normal: {
      uniforms: ho([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: rn.meshnormal_vert,
      fragmentShader: rn.meshnormal_frag,
    },
    sprite: {
      uniforms: ho([xt.sprite, xt.fog]),
      vertexShader: rn.sprite_vert,
      fragmentShader: rn.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Qt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: rn.background_vert,
      fragmentShader: rn.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Qt() },
      },
      vertexShader: rn.backgroundCube_vert,
      fragmentShader: rn.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: rn.cube_vert,
      fragmentShader: rn.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: rn.equirect_vert,
      fragmentShader: rn.equirect_frag,
    },
    distanceRGBA: {
      uniforms: ho([
        xt.common,
        xt.displacementmap,
        {
          referencePosition: { value: new ie() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: rn.distanceRGBA_vert,
      fragmentShader: rn.distanceRGBA_frag,
    },
    shadow: {
      uniforms: ho([
        xt.lights,
        xt.fog,
        { color: { value: new St(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: rn.shadow_vert,
      fragmentShader: rn.shadow_frag,
    },
  };
ra.physical = {
  uniforms: ho([
    ra.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Qt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Qt() },
      clearcoatNormalScale: { value: new tt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Qt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Qt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Qt() },
      sheen: { value: 0 },
      sheenColor: { value: new St(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Qt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Qt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Qt() },
      transmissionSamplerSize: { value: new tt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Qt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new St(0) },
      specularColor: { value: new St(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Qt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Qt() },
      anisotropyVector: { value: new tt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Qt() },
    },
  ]),
  vertexShader: rn.meshphysical_vert,
  fragmentShader: rn.meshphysical_frag,
};
const av = { r: 0, b: 0, g: 0 },
  Rc = new ss(),
  d5 = new Wt();
function h5(n, e, t, r, i, o, s) {
  const l = new St(0);
  let u = o === !0 ? 0 : 1,
    f,
    h,
    m = null,
    g = 0,
    y = null;
  function _(T) {
    let E = T.isScene === !0 ? T.background : null;
    return (
      E && E.isTexture && (E = (T.backgroundBlurriness > 0 ? t : e).get(E)), E
    );
  }
  function S(T) {
    let E = !1;
    const A = _(T);
    A === null ? w(l, u) : A && A.isColor && (w(A, 1), (E = !0));
    const R = n.xr.getEnvironmentBlendMode();
    R === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, s)
      : R === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, s),
      (n.autoClear || E) &&
        (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  function x(T, E) {
    const A = _(E);
    A && (A.isCubeTexture || A.mapping === vh)
      ? (h === void 0 &&
          ((h = new dr(
            new pf(1, 1, 1),
            new la({
              name: "BackgroundCubeMaterial",
              uniforms: fh(ra.backgroundCube.uniforms),
              vertexShader: ra.backgroundCube.vertexShader,
              fragmentShader: ra.backgroundCube.fragmentShader,
              side: Zi,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          h.geometry.deleteAttribute("normal"),
          h.geometry.deleteAttribute("uv"),
          (h.onBeforeRender = function (R, D, I) {
            this.matrixWorld.copyPosition(I.matrixWorld);
          }),
          Object.defineProperty(h.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(h)),
        Rc.copy(E.backgroundRotation),
        (Rc.x *= -1),
        (Rc.y *= -1),
        (Rc.z *= -1),
        A.isCubeTexture &&
          A.isRenderTargetTexture === !1 &&
          ((Rc.y *= -1), (Rc.z *= -1)),
        (h.material.uniforms.envMap.value = A),
        (h.material.uniforms.flipEnvMap.value =
          A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1),
        (h.material.uniforms.backgroundBlurriness.value =
          E.backgroundBlurriness),
        (h.material.uniforms.backgroundIntensity.value = E.backgroundIntensity),
        h.material.uniforms.backgroundRotation.value.setFromMatrix4(
          d5.makeRotationFromEuler(Rc)
        ),
        (h.material.toneMapped = yn.getTransfer(A.colorSpace) !== $n),
        (m !== A || g !== A.version || y !== n.toneMapping) &&
          ((h.material.needsUpdate = !0),
          (m = A),
          (g = A.version),
          (y = n.toneMapping)),
        h.layers.enableAll(),
        T.unshift(h, h.geometry, h.material, 0, 0, null))
      : A &&
        A.isTexture &&
        (f === void 0 &&
          ((f = new dr(
            new Ul(2, 2),
            new la({
              name: "BackgroundMaterial",
              uniforms: fh(ra.background.uniforms),
              vertexShader: ra.background.vertexShader,
              fragmentShader: ra.background.fragmentShader,
              side: Ga,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          f.geometry.deleteAttribute("normal"),
          Object.defineProperty(f.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(f)),
        (f.material.uniforms.t2D.value = A),
        (f.material.uniforms.backgroundIntensity.value = E.backgroundIntensity),
        (f.material.toneMapped = yn.getTransfer(A.colorSpace) !== $n),
        A.matrixAutoUpdate === !0 && A.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(A.matrix),
        (m !== A || g !== A.version || y !== n.toneMapping) &&
          ((f.material.needsUpdate = !0),
          (m = A),
          (g = A.version),
          (y = n.toneMapping)),
        f.layers.enableAll(),
        T.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function w(T, E) {
    T.getRGB(av, MA(n)), r.buffers.color.setClear(av.r, av.g, av.b, E, s);
  }
  return {
    getClearColor: function () {
      return l;
    },
    setClearColor: function (T, E = 1) {
      l.set(T), (u = E), w(l, u);
    },
    getClearAlpha: function () {
      return u;
    },
    setClearAlpha: function (T) {
      (u = T), w(l, u);
    },
    render: S,
    addToRenderList: x,
  };
}
function p5(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    r = {},
    i = g(null);
  let o = i,
    s = !1;
  function l(L, V, H, $, q) {
    let K = !1;
    const Y = m($, H, V);
    o !== Y && ((o = Y), f(o.object)),
      (K = y(L, $, H, q)),
      K && _(L, $, H, q),
      q !== null && e.update(q, n.ELEMENT_ARRAY_BUFFER),
      (K || s) &&
        ((s = !1),
        A(L, V, H, $),
        q !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(q).buffer));
  }
  function u() {
    return n.createVertexArray();
  }
  function f(L) {
    return n.bindVertexArray(L);
  }
  function h(L) {
    return n.deleteVertexArray(L);
  }
  function m(L, V, H) {
    const $ = H.wireframe === !0;
    let q = r[L.id];
    q === void 0 && ((q = {}), (r[L.id] = q));
    let K = q[V.id];
    K === void 0 && ((K = {}), (q[V.id] = K));
    let Y = K[$];
    return Y === void 0 && ((Y = g(u())), (K[$] = Y)), Y;
  }
  function g(L) {
    const V = [],
      H = [],
      $ = [];
    for (let q = 0; q < t; q++) (V[q] = 0), (H[q] = 0), ($[q] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: V,
      enabledAttributes: H,
      attributeDivisors: $,
      object: L,
      attributes: {},
      index: null,
    };
  }
  function y(L, V, H, $) {
    const q = o.attributes,
      K = V.attributes;
    let Y = 0;
    const ne = H.getAttributes();
    for (const j in ne)
      if (ne[j].location >= 0) {
        const B = q[j];
        let G = K[j];
        if (
          (G === void 0 &&
            (j === "instanceMatrix" &&
              L.instanceMatrix &&
              (G = L.instanceMatrix),
            j === "instanceColor" && L.instanceColor && (G = L.instanceColor)),
          B === void 0 || B.attribute !== G || (G && B.data !== G.data))
        )
          return !0;
        Y++;
      }
    return o.attributesNum !== Y || o.index !== $;
  }
  function _(L, V, H, $) {
    const q = {},
      K = V.attributes;
    let Y = 0;
    const ne = H.getAttributes();
    for (const j in ne)
      if (ne[j].location >= 0) {
        let B = K[j];
        B === void 0 &&
          (j === "instanceMatrix" && L.instanceMatrix && (B = L.instanceMatrix),
          j === "instanceColor" && L.instanceColor && (B = L.instanceColor));
        const G = {};
        (G.attribute = B), B && B.data && (G.data = B.data), (q[j] = G), Y++;
      }
    (o.attributes = q), (o.attributesNum = Y), (o.index = $);
  }
  function S() {
    const L = o.newAttributes;
    for (let V = 0, H = L.length; V < H; V++) L[V] = 0;
  }
  function x(L) {
    w(L, 0);
  }
  function w(L, V) {
    const H = o.newAttributes,
      $ = o.enabledAttributes,
      q = o.attributeDivisors;
    (H[L] = 1),
      $[L] === 0 && (n.enableVertexAttribArray(L), ($[L] = 1)),
      q[L] !== V && (n.vertexAttribDivisor(L, V), (q[L] = V));
  }
  function T() {
    const L = o.newAttributes,
      V = o.enabledAttributes;
    for (let H = 0, $ = V.length; H < $; H++)
      V[H] !== L[H] && (n.disableVertexAttribArray(H), (V[H] = 0));
  }
  function E(L, V, H, $, q, K, Y) {
    Y === !0
      ? n.vertexAttribIPointer(L, V, H, q, K)
      : n.vertexAttribPointer(L, V, H, $, q, K);
  }
  function A(L, V, H, $) {
    S();
    const q = $.attributes,
      K = H.getAttributes(),
      Y = V.defaultAttributeValues;
    for (const ne in K) {
      const j = K[ne];
      if (j.location >= 0) {
        let re = q[ne];
        if (
          (re === void 0 &&
            (ne === "instanceMatrix" &&
              L.instanceMatrix &&
              (re = L.instanceMatrix),
            ne === "instanceColor" &&
              L.instanceColor &&
              (re = L.instanceColor)),
          re !== void 0)
        ) {
          const B = re.normalized,
            G = re.itemSize,
            te = e.get(re);
          if (te === void 0) continue;
          const le = te.buffer,
            J = te.type,
            oe = te.bytesPerElement,
            he = J === n.INT || J === n.UNSIGNED_INT || re.gpuType === py;
          if (re.isInterleavedBufferAttribute) {
            const ae = re.data,
              ue = ae.stride,
              Ee = re.offset;
            if (ae.isInstancedInterleavedBuffer) {
              for (let Ne = 0; Ne < j.locationSize; Ne++)
                w(j.location + Ne, ae.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = ae.meshPerAttribute * ae.count);
            } else
              for (let Ne = 0; Ne < j.locationSize; Ne++) x(j.location + Ne);
            n.bindBuffer(n.ARRAY_BUFFER, le);
            for (let Ne = 0; Ne < j.locationSize; Ne++)
              E(
                j.location + Ne,
                G / j.locationSize,
                J,
                B,
                ue * oe,
                (Ee + (G / j.locationSize) * Ne) * oe,
                he
              );
          } else {
            if (re.isInstancedBufferAttribute) {
              for (let ae = 0; ae < j.locationSize; ae++)
                w(j.location + ae, re.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = re.meshPerAttribute * re.count);
            } else
              for (let ae = 0; ae < j.locationSize; ae++) x(j.location + ae);
            n.bindBuffer(n.ARRAY_BUFFER, le);
            for (let ae = 0; ae < j.locationSize; ae++)
              E(
                j.location + ae,
                G / j.locationSize,
                J,
                B,
                G * oe,
                (G / j.locationSize) * ae * oe,
                he
              );
          }
        } else if (Y !== void 0) {
          const B = Y[ne];
          if (B !== void 0)
            switch (B.length) {
              case 2:
                n.vertexAttrib2fv(j.location, B);
                break;
              case 3:
                n.vertexAttrib3fv(j.location, B);
                break;
              case 4:
                n.vertexAttrib4fv(j.location, B);
                break;
              default:
                n.vertexAttrib1fv(j.location, B);
            }
        }
      }
    }
    T();
  }
  function R() {
    U();
    for (const L in r) {
      const V = r[L];
      for (const H in V) {
        const $ = V[H];
        for (const q in $) h($[q].object), delete $[q];
        delete V[H];
      }
      delete r[L];
    }
  }
  function D(L) {
    if (r[L.id] === void 0) return;
    const V = r[L.id];
    for (const H in V) {
      const $ = V[H];
      for (const q in $) h($[q].object), delete $[q];
      delete V[H];
    }
    delete r[L.id];
  }
  function I(L) {
    for (const V in r) {
      const H = r[V];
      if (H[L.id] === void 0) continue;
      const $ = H[L.id];
      for (const q in $) h($[q].object), delete $[q];
      delete H[L.id];
    }
  }
  function U() {
    O(), (s = !0), o !== i && ((o = i), f(o.object));
  }
  function O() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: l,
    reset: U,
    resetDefaultState: O,
    dispose: R,
    releaseStatesOfGeometry: D,
    releaseStatesOfProgram: I,
    initAttributes: S,
    enableAttribute: x,
    disableUnusedAttributes: T,
  };
}
function m5(n, e, t) {
  let r;
  function i(f) {
    r = f;
  }
  function o(f, h) {
    n.drawArrays(r, f, h), t.update(h, r, 1);
  }
  function s(f, h, m) {
    m !== 0 && (n.drawArraysInstanced(r, f, h, m), t.update(h, r, m));
  }
  function l(f, h, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, f, 0, h, 0, m);
    let y = 0;
    for (let _ = 0; _ < m; _++) y += h[_];
    t.update(y, r, 1);
  }
  function u(f, h, m, g) {
    if (m === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null) for (let _ = 0; _ < f.length; _++) s(f[_], h[_], g[_]);
    else {
      y.multiDrawArraysInstancedWEBGL(r, f, 0, h, 0, g, 0, m);
      let _ = 0;
      for (let S = 0; S < m; S++) _ += h[S];
      for (let S = 0; S < g.length; S++) t.update(_, r, g[S]);
    }
  }
  (this.setMode = i),
    (this.render = o),
    (this.renderInstances = s),
    (this.renderMultiDraw = l),
    (this.renderMultiDrawInstances = u);
}
function g5(n, e, t, r) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const D = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(D) {
    return !(
      D !== Ki &&
      r.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function l(D) {
    const I =
      D === yh &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      D !== sa &&
      r.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      D !== ko &&
      !I
    );
  }
  function u(D) {
    if (D === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      D = "mediump";
    }
    return D === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let f = t.precision !== void 0 ? t.precision : "highp";
  const h = u(f);
  h !== f &&
    (console.warn(
      "THREE.WebGLRenderer:",
      f,
      "not supported, using",
      h,
      "instead."
    ),
    (f = h));
  const m = t.logarithmicDepthBuffer === !0,
    g = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    y = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    _ = n.getParameter(n.MAX_TEXTURE_SIZE),
    S = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    w = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    T = n.getParameter(n.MAX_VARYING_VECTORS),
    E = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    A = y > 0,
    R = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: o,
    getMaxPrecision: u,
    textureFormatReadable: s,
    textureTypeReadable: l,
    precision: f,
    logarithmicDepthBuffer: m,
    maxTextures: g,
    maxVertexTextures: y,
    maxTextureSize: _,
    maxCubemapSize: S,
    maxAttributes: x,
    maxVertexUniforms: w,
    maxVaryings: T,
    maxFragmentUniforms: E,
    vertexTextures: A,
    maxSamples: R,
  };
}
function v5(n) {
  const e = this;
  let t = null,
    r = 0,
    i = !1,
    o = !1;
  const s = new wl(),
    l = new Qt(),
    u = { value: null, needsUpdate: !1 };
  (this.uniform = u),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (m, g) {
      const y = m.length !== 0 || g || r !== 0 || i;
      return (i = g), (r = m.length), y;
    }),
    (this.beginShadows = function () {
      (o = !0), h(null);
    }),
    (this.endShadows = function () {
      o = !1;
    }),
    (this.setGlobalState = function (m, g) {
      t = h(m, g, 0);
    }),
    (this.setState = function (m, g, y) {
      const _ = m.clippingPlanes,
        S = m.clipIntersection,
        x = m.clipShadows,
        w = n.get(m);
      if (!i || _ === null || _.length === 0 || (o && !x)) o ? h(null) : f();
      else {
        const T = o ? 0 : r,
          E = T * 4;
        let A = w.clippingState || null;
        (u.value = A), (A = h(_, g, E, y));
        for (let R = 0; R !== E; ++R) A[R] = t[R];
        (w.clippingState = A),
          (this.numIntersection = S ? this.numPlanes : 0),
          (this.numPlanes += T);
      }
    });
  function f() {
    u.value !== t && ((u.value = t), (u.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function h(m, g, y, _) {
    const S = m !== null ? m.length : 0;
    let x = null;
    if (S !== 0) {
      if (((x = u.value), _ !== !0 || x === null)) {
        const w = y + S * 4,
          T = g.matrixWorldInverse;
        l.getNormalMatrix(T),
          (x === null || x.length < w) && (x = new Float32Array(w));
        for (let E = 0, A = y; E !== S; ++E, A += 4)
          s.copy(m[E]).applyMatrix4(T, l),
            s.normal.toArray(x, A),
            (x[A + 3] = s.constant);
      }
      (u.value = x), (u.needsUpdate = !0);
    }
    return (e.numPlanes = S), (e.numIntersection = 0), x;
  }
}
function y5(n) {
  let e = new WeakMap();
  function t(s, l) {
    return l === sm ? (s.mapping = Il) : l === am && (s.mapping = Bu), s;
  }
  function r(s) {
    if (s && s.isTexture) {
      const l = s.mapping;
      if (l === sm || l === am)
        if (e.has(s)) {
          const u = e.get(s).texture;
          return t(u, s.mapping);
        } else {
          const u = s.image;
          if (u && u.height > 0) {
            const f = new EA(u.height);
            return (
              f.fromEquirectangularTexture(n, s),
              e.set(s, f),
              s.addEventListener("dispose", i),
              t(f.texture, s.mapping)
            );
          } else return null;
        }
    }
    return s;
  }
  function i(s) {
    const l = s.target;
    l.removeEventListener("dispose", i);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: r, dispose: o };
}
class Nu extends Nm {
  constructor(e = -1, t = 1, r = 1, i = -1, o = 0.1, s = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = i),
      (this.near = o),
      (this.far = s),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, i, o, s) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let o = r - e,
      s = r + e,
      l = i + t,
      u = i - t;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += f * this.view.offsetX),
        (s = o + f * this.view.width),
        (l -= h * this.view.offsetY),
        (u = l - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      o,
      s,
      l,
      u,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const qd = 4,
  tE = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  jc = 20,
  E_ = new Nu(),
  nE = new St();
let T_ = null,
  C_ = 0,
  A_ = 0,
  R_ = !1;
const Wc = (1 + Math.sqrt(5)) / 2,
  Dd = 1 / Wc,
  rE = [
    new ie(-Wc, Dd, 0),
    new ie(Wc, Dd, 0),
    new ie(-Dd, 0, Wc),
    new ie(Dd, 0, Wc),
    new ie(0, Wc, -Dd),
    new ie(0, Wc, Dd),
    new ie(-1, 1, -1),
    new ie(1, 1, -1),
    new ie(-1, 1, 1),
    new ie(1, 1, 1),
  ];
class N1 {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    (T_ = this._renderer.getRenderTarget()),
      (C_ = this._renderer.getActiveCubeFace()),
      (A_ = this._renderer.getActiveMipmapLevel()),
      (R_ = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const o = this._allocateTargets();
    return (
      (o.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, o),
      t > 0 && this._blur(o, 0, 0, t),
      this._applyPMREM(o),
      this._cleanup(o),
      o
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = sE()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = oE()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(T_, C_, A_),
      (this._renderer.xr.enabled = R_),
      (e.scissorTest = !1),
      lv(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Il || e.mapping === Bu
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (T_ = this._renderer.getRenderTarget()),
      (C_ = this._renderer.getActiveCubeFace()),
      (A_ = this._renderer.getActiveMipmapLevel()),
      (R_ = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: br,
        minFilter: br,
        generateMipmaps: !1,
        type: yh,
        format: Ki,
        colorSpace: kl,
        depthBuffer: !1,
      },
      i = iE(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = iE(e, t, r));
      const { _lodMax: o } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = x5(o)),
        (this._blurMaterial = _5(o, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new dr(this._lodPlanes[0], e);
    this._renderer.compile(t, E_);
  }
  _sceneToCubeUV(e, t, r, i) {
    const l = new Dr(90, 1, t, r),
      u = [1, -1, 1, 1, 1, 1],
      f = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      m = h.autoClear,
      g = h.toneMapping;
    h.getClearColor(nE), (h.toneMapping = Ba), (h.autoClear = !1);
    const y = new Nl({
        name: "PMREM.Background",
        side: Zi,
        depthWrite: !1,
        depthTest: !1,
      }),
      _ = new dr(new pf(), y);
    let S = !1;
    const x = e.background;
    x
      ? x.isColor && (y.color.copy(x), (e.background = null), (S = !0))
      : (y.color.copy(nE), (S = !0));
    for (let w = 0; w < 6; w++) {
      const T = w % 3;
      T === 0
        ? (l.up.set(0, u[w], 0), l.lookAt(f[w], 0, 0))
        : T === 1
        ? (l.up.set(0, 0, u[w]), l.lookAt(0, f[w], 0))
        : (l.up.set(0, u[w], 0), l.lookAt(0, 0, f[w]));
      const E = this._cubeSize;
      lv(i, T * E, w > 2 ? E : 0, E, E),
        h.setRenderTarget(i),
        S && h.render(_, l),
        h.render(e, l);
    }
    _.geometry.dispose(),
      _.material.dispose(),
      (h.toneMapping = g),
      (h.autoClear = m),
      (e.background = x);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      i = e.mapping === Il || e.mapping === Bu;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = sE()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = oE());
    const o = i ? this._cubemapMaterial : this._equirectMaterial,
      s = new dr(this._lodPlanes[0], o),
      l = o.uniforms;
    l.envMap.value = e;
    const u = this._cubeSize;
    lv(t, 0, 0, 3 * u, 2 * u), r.setRenderTarget(t), r.render(s, E_);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const s = Math.sqrt(
          this._sigmas[o] * this._sigmas[o] -
            this._sigmas[o - 1] * this._sigmas[o - 1]
        ),
        l = rE[(i - o - 1) % rE.length];
      this._blur(e, o - 1, o, s, l);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, o) {
    const s = this._pingPongRenderTarget;
    this._halfBlur(e, s, t, r, i, "latitudinal", o),
      this._halfBlur(s, e, r, r, i, "longitudinal", o);
  }
  _halfBlur(e, t, r, i, o, s, l) {
    const u = this._renderer,
      f = this._blurMaterial;
    s !== "latitudinal" &&
      s !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      m = new dr(this._lodPlanes[i], f),
      g = f.uniforms,
      y = this._sizeLods[r] - 1,
      _ = isFinite(o) ? Math.PI / (2 * y) : (2 * Math.PI) / (2 * jc - 1),
      S = o / _,
      x = isFinite(o) ? 1 + Math.floor(h * S) : jc;
    x > jc &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${jc}`
      );
    const w = [];
    let T = 0;
    for (let I = 0; I < jc; ++I) {
      const U = I / S,
        O = Math.exp((-U * U) / 2);
      w.push(O), I === 0 ? (T += O) : I < x && (T += 2 * O);
    }
    for (let I = 0; I < w.length; I++) w[I] = w[I] / T;
    (g.envMap.value = e.texture),
      (g.samples.value = x),
      (g.weights.value = w),
      (g.latitudinal.value = s === "latitudinal"),
      l && (g.poleAxis.value = l);
    const { _lodMax: E } = this;
    (g.dTheta.value = _), (g.mipInt.value = E - r);
    const A = this._sizeLods[i],
      R = 3 * A * (i > E - qd ? i - E + qd : 0),
      D = 4 * (this._cubeSize - A);
    lv(t, R, D, 3 * A, 2 * A), u.setRenderTarget(t), u.render(m, E_);
  }
}
function x5(n) {
  const e = [],
    t = [],
    r = [];
  let i = n;
  const o = n - qd + 1 + tE.length;
  for (let s = 0; s < o; s++) {
    const l = Math.pow(2, i);
    t.push(l);
    let u = 1 / l;
    s > n - qd ? (u = tE[s - n + qd - 1]) : s === 0 && (u = 0), r.push(u);
    const f = 1 / (l - 2),
      h = -f,
      m = 1 + f,
      g = [h, h, m, h, m, m, h, h, m, m, h, m],
      y = 6,
      _ = 6,
      S = 3,
      x = 2,
      w = 1,
      T = new Float32Array(S * _ * y),
      E = new Float32Array(x * _ * y),
      A = new Float32Array(w * _ * y);
    for (let D = 0; D < y; D++) {
      const I = ((D % 3) * 2) / 3 - 1,
        U = D > 2 ? 0 : -1,
        O = [
          I,
          U,
          0,
          I + 2 / 3,
          U,
          0,
          I + 2 / 3,
          U + 1,
          0,
          I,
          U,
          0,
          I + 2 / 3,
          U + 1,
          0,
          I,
          U + 1,
          0,
        ];
      T.set(O, S * _ * D), E.set(g, x * _ * D);
      const L = [D, D, D, D, D, D];
      A.set(L, w * _ * D);
    }
    const R = new Kt();
    R.setAttribute("position", new zn(T, S)),
      R.setAttribute("uv", new zn(E, x)),
      R.setAttribute("faceIndex", new zn(A, w)),
      e.push(R),
      i > qd && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function iE(n, e, t) {
  const r = new aa(n, e, t);
  return (
    (r.texture.mapping = vh),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function lv(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function _5(n, e, t) {
  const r = new Float32Array(jc),
    i = new ie(0, 1, 0);
  return new la({
    name: "SphericalGaussianBlur",
    defines: {
      n: jc,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: XS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Al,
    depthTest: !1,
    depthWrite: !1,
  });
}
function oE() {
  return new la({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: XS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Al,
    depthTest: !1,
    depthWrite: !1,
  });
}
function sE() {
  return new la({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: XS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Al,
    depthTest: !1,
    depthWrite: !1,
  });
}
function XS() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function S5(n) {
  let e = new WeakMap(),
    t = null;
  function r(l) {
    if (l && l.isTexture) {
      const u = l.mapping,
        f = u === sm || u === am,
        h = u === Il || u === Bu;
      if (f || h) {
        let m = e.get(l);
        const g = m !== void 0 ? m.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== g)
          return (
            t === null && (t = new N1(n)),
            (m = f ? t.fromEquirectangular(l, m) : t.fromCubemap(l, m)),
            (m.texture.pmremVersion = l.pmremVersion),
            e.set(l, m),
            m.texture
          );
        if (m !== void 0) return m.texture;
        {
          const y = l.image;
          return (f && y && y.height > 0) || (h && y && i(y))
            ? (t === null && (t = new N1(n)),
              (m = f ? t.fromEquirectangular(l) : t.fromCubemap(l)),
              (m.texture.pmremVersion = l.pmremVersion),
              e.set(l, m),
              l.addEventListener("dispose", o),
              m.texture)
            : null;
        }
      }
    }
    return l;
  }
  function i(l) {
    let u = 0;
    const f = 6;
    for (let h = 0; h < f; h++) l[h] !== void 0 && u++;
    return u === f;
  }
  function o(l) {
    const u = l.target;
    u.removeEventListener("dispose", o);
    const f = e.get(u);
    f !== void 0 && (e.delete(u), f.dispose());
  }
  function s() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: s };
}
function w5(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (r) {
      const i = t(r);
      return (
        i === null &&
          rh("THREE.WebGLRenderer: " + r + " extension not supported."),
        i
      );
    },
  };
}
function M5(n, e, t, r) {
  const i = {},
    o = new WeakMap();
  function s(m) {
    const g = m.target;
    g.index !== null && e.remove(g.index);
    for (const _ in g.attributes) e.remove(g.attributes[_]);
    for (const _ in g.morphAttributes) {
      const S = g.morphAttributes[_];
      for (let x = 0, w = S.length; x < w; x++) e.remove(S[x]);
    }
    g.removeEventListener("dispose", s), delete i[g.id];
    const y = o.get(g);
    y && (e.remove(y), o.delete(g)),
      r.releaseStatesOfGeometry(g),
      g.isInstancedBufferGeometry === !0 && delete g._maxInstanceCount,
      t.memory.geometries--;
  }
  function l(m, g) {
    return (
      i[g.id] === !0 ||
        (g.addEventListener("dispose", s),
        (i[g.id] = !0),
        t.memory.geometries++),
      g
    );
  }
  function u(m) {
    const g = m.attributes;
    for (const _ in g) e.update(g[_], n.ARRAY_BUFFER);
    const y = m.morphAttributes;
    for (const _ in y) {
      const S = y[_];
      for (let x = 0, w = S.length; x < w; x++) e.update(S[x], n.ARRAY_BUFFER);
    }
  }
  function f(m) {
    const g = [],
      y = m.index,
      _ = m.attributes.position;
    let S = 0;
    if (y !== null) {
      const T = y.array;
      S = y.version;
      for (let E = 0, A = T.length; E < A; E += 3) {
        const R = T[E + 0],
          D = T[E + 1],
          I = T[E + 2];
        g.push(R, D, D, I, I, R);
      }
    } else if (_ !== void 0) {
      const T = _.array;
      S = _.version;
      for (let E = 0, A = T.length / 3 - 1; E < A; E += 3) {
        const R = E + 0,
          D = E + 1,
          I = E + 2;
        g.push(R, D, D, I, I, R);
      }
    } else return;
    const x = new (yA(g) ? jS : WS)(g, 1);
    x.version = S;
    const w = o.get(m);
    w && e.remove(w), o.set(m, x);
  }
  function h(m) {
    const g = o.get(m);
    if (g) {
      const y = m.index;
      y !== null && g.version < y.version && f(m);
    } else f(m);
    return o.get(m);
  }
  return { get: l, update: u, getWireframeAttribute: h };
}
function b5(n, e, t) {
  let r;
  function i(g) {
    r = g;
  }
  let o, s;
  function l(g) {
    (o = g.type), (s = g.bytesPerElement);
  }
  function u(g, y) {
    n.drawElements(r, y, o, g * s), t.update(y, r, 1);
  }
  function f(g, y, _) {
    _ !== 0 && (n.drawElementsInstanced(r, y, o, g * s, _), t.update(y, r, _));
  }
  function h(g, y, _) {
    if (_ === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, y, 0, o, g, 0, _);
    let x = 0;
    for (let w = 0; w < _; w++) x += y[w];
    t.update(x, r, 1);
  }
  function m(g, y, _, S) {
    if (_ === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null) for (let w = 0; w < g.length; w++) f(g[w] / s, y[w], S[w]);
    else {
      x.multiDrawElementsInstancedWEBGL(r, y, 0, o, g, 0, S, 0, _);
      let w = 0;
      for (let T = 0; T < _; T++) w += y[T];
      for (let T = 0; T < S.length; T++) t.update(w, r, S[T]);
    }
  }
  (this.setMode = i),
    (this.setIndex = l),
    (this.render = u),
    (this.renderInstances = f),
    (this.renderMultiDraw = h),
    (this.renderMultiDrawInstances = m);
}
function E5(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(o, s, l) {
    switch ((t.calls++, s)) {
      case n.TRIANGLES:
        t.triangles += l * (o / 3);
        break;
      case n.LINES:
        t.lines += l * (o / 2);
        break;
      case n.LINE_STRIP:
        t.lines += l * (o - 1);
        break;
      case n.LINE_LOOP:
        t.lines += l * o;
        break;
      case n.POINTS:
        t.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function T5(n, e, t) {
  const r = new WeakMap(),
    i = new En();
  function o(s, l, u) {
    const f = s.morphTargetInfluences,
      h =
        l.morphAttributes.position ||
        l.morphAttributes.normal ||
        l.morphAttributes.color,
      m = h !== void 0 ? h.length : 0;
    let g = r.get(l);
    if (g === void 0 || g.count !== m) {
      let L = function () {
        U.dispose(), r.delete(l), l.removeEventListener("dispose", L);
      };
      var y = L;
      g !== void 0 && g.texture.dispose();
      const _ = l.morphAttributes.position !== void 0,
        S = l.morphAttributes.normal !== void 0,
        x = l.morphAttributes.color !== void 0,
        w = l.morphAttributes.position || [],
        T = l.morphAttributes.normal || [],
        E = l.morphAttributes.color || [];
      let A = 0;
      _ === !0 && (A = 1), S === !0 && (A = 2), x === !0 && (A = 3);
      let R = l.attributes.position.count * A,
        D = 1;
      R > e.maxTextureSize &&
        ((D = Math.ceil(R / e.maxTextureSize)), (R = e.maxTextureSize));
      const I = new Float32Array(R * D * 4 * m),
        U = new wy(I, R, D, m);
      (U.type = ko), (U.needsUpdate = !0);
      const O = A * 4;
      for (let V = 0; V < m; V++) {
        const H = w[V],
          $ = T[V],
          q = E[V],
          K = R * D * 4 * V;
        for (let Y = 0; Y < H.count; Y++) {
          const ne = Y * O;
          _ === !0 &&
            (i.fromBufferAttribute(H, Y),
            (I[K + ne + 0] = i.x),
            (I[K + ne + 1] = i.y),
            (I[K + ne + 2] = i.z),
            (I[K + ne + 3] = 0)),
            S === !0 &&
              (i.fromBufferAttribute($, Y),
              (I[K + ne + 4] = i.x),
              (I[K + ne + 5] = i.y),
              (I[K + ne + 6] = i.z),
              (I[K + ne + 7] = 0)),
            x === !0 &&
              (i.fromBufferAttribute(q, Y),
              (I[K + ne + 8] = i.x),
              (I[K + ne + 9] = i.y),
              (I[K + ne + 10] = i.z),
              (I[K + ne + 11] = q.itemSize === 4 ? i.w : 1));
        }
      }
      (g = { count: m, texture: U, size: new tt(R, D) }),
        r.set(l, g),
        l.addEventListener("dispose", L);
    }
    if (s.isInstancedMesh === !0 && s.morphTexture !== null)
      u.getUniforms().setValue(n, "morphTexture", s.morphTexture, t);
    else {
      let _ = 0;
      for (let x = 0; x < f.length; x++) _ += f[x];
      const S = l.morphTargetsRelative ? 1 : 1 - _;
      u.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
        u.getUniforms().setValue(n, "morphTargetInfluences", f);
    }
    u.getUniforms().setValue(n, "morphTargetsTexture", g.texture, t),
      u.getUniforms().setValue(n, "morphTargetsTextureSize", g.size);
  }
  return { update: o };
}
function C5(n, e, t, r) {
  let i = new WeakMap();
  function o(u) {
    const f = r.render.frame,
      h = u.geometry,
      m = e.get(u, h);
    if (
      (i.get(m) !== f && (e.update(m), i.set(m, f)),
      u.isInstancedMesh &&
        (u.hasEventListener("dispose", l) === !1 &&
          u.addEventListener("dispose", l),
        i.get(u) !== f &&
          (t.update(u.instanceMatrix, n.ARRAY_BUFFER),
          u.instanceColor !== null && t.update(u.instanceColor, n.ARRAY_BUFFER),
          i.set(u, f))),
      u.isSkinnedMesh)
    ) {
      const g = u.skeleton;
      i.get(g) !== f && (g.update(), i.set(g, f));
    }
    return m;
  }
  function s() {
    i = new WeakMap();
  }
  function l(u) {
    const f = u.target;
    f.removeEventListener("dispose", l),
      t.remove(f.instanceMatrix),
      f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return { update: o, dispose: s };
}
class YS extends rr {
  constructor(e, t, r, i, o, s, l, u, f, h = Jc) {
    if (h !== Jc && h !== lf)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && h === Jc && (r = Ll),
      r === void 0 && h === lf && (r = af),
      super(null, i, o, s, l, u, h, r, f),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = l !== void 0 ? l : yi),
      (this.minFilter = u !== void 0 ? u : yi),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const CA = new rr(),
  aE = new YS(1, 1),
  AA = new wy(),
  RA = new GS(),
  PA = new Um(),
  lE = [],
  uE = [],
  cE = new Float32Array(16),
  fE = new Float32Array(9),
  dE = new Float32Array(4);
function xh(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let o = lE[i];
  if ((o === void 0 && ((o = new Float32Array(i)), (lE[i] = o)), e !== 0)) {
    r.toArray(o, 0);
    for (let s = 1, l = 0; s !== e; ++s) (l += t), n[s].toArray(o, l);
  }
  return o;
}
function li(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function ui(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function My(n, e) {
  let t = uE[e];
  t === void 0 && ((t = new Int32Array(e)), (uE[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function A5(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function R5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (li(t, e)) return;
    n.uniform2fv(this.addr, e), ui(t, e);
  }
}
function P5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (li(t, e)) return;
    n.uniform3fv(this.addr, e), ui(t, e);
  }
}
function I5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (li(t, e)) return;
    n.uniform4fv(this.addr, e), ui(t, e);
  }
}
function L5(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (li(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), ui(t, e);
  } else {
    if (li(t, r)) return;
    dE.set(r), n.uniformMatrix2fv(this.addr, !1, dE), ui(t, r);
  }
}
function D5(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (li(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), ui(t, e);
  } else {
    if (li(t, r)) return;
    fE.set(r), n.uniformMatrix3fv(this.addr, !1, fE), ui(t, r);
  }
}
function k5(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (li(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), ui(t, e);
  } else {
    if (li(t, r)) return;
    cE.set(r), n.uniformMatrix4fv(this.addr, !1, cE), ui(t, r);
  }
}
function O5(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function N5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (li(t, e)) return;
    n.uniform2iv(this.addr, e), ui(t, e);
  }
}
function U5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (li(t, e)) return;
    n.uniform3iv(this.addr, e), ui(t, e);
  }
}
function F5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (li(t, e)) return;
    n.uniform4iv(this.addr, e), ui(t, e);
  }
}
function z5(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function B5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (li(t, e)) return;
    n.uniform2uiv(this.addr, e), ui(t, e);
  }
}
function V5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (li(t, e)) return;
    n.uniform3uiv(this.addr, e), ui(t, e);
  }
}
function H5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (li(t, e)) return;
    n.uniform4uiv(this.addr, e), ui(t, e);
  }
}
function G5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i));
  let o;
  this.type === n.SAMPLER_2D_SHADOW
    ? ((aE.compareFunction = VS), (o = aE))
    : (o = CA),
    t.setTexture2D(e || o, i);
}
function W5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture3D(e || RA, i);
}
function j5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTextureCube(e || PA, i);
}
function $5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2DArray(e || AA, i);
}
function X5(n) {
  switch (n) {
    case 5126:
      return A5;
    case 35664:
      return R5;
    case 35665:
      return P5;
    case 35666:
      return I5;
    case 35674:
      return L5;
    case 35675:
      return D5;
    case 35676:
      return k5;
    case 5124:
    case 35670:
      return O5;
    case 35667:
    case 35671:
      return N5;
    case 35668:
    case 35672:
      return U5;
    case 35669:
    case 35673:
      return F5;
    case 5125:
      return z5;
    case 36294:
      return B5;
    case 36295:
      return V5;
    case 36296:
      return H5;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return G5;
    case 35679:
    case 36299:
    case 36307:
      return W5;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return j5;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return $5;
  }
}
function Y5(n, e) {
  n.uniform1fv(this.addr, e);
}
function q5(n, e) {
  const t = xh(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function K5(n, e) {
  const t = xh(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Z5(n, e) {
  const t = xh(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function J5(n, e) {
  const t = xh(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function Q5(n, e) {
  const t = xh(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function e6(n, e) {
  const t = xh(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function t6(n, e) {
  n.uniform1iv(this.addr, e);
}
function n6(n, e) {
  n.uniform2iv(this.addr, e);
}
function r6(n, e) {
  n.uniform3iv(this.addr, e);
}
function i6(n, e) {
  n.uniform4iv(this.addr, e);
}
function o6(n, e) {
  n.uniform1uiv(this.addr, e);
}
function s6(n, e) {
  n.uniform2uiv(this.addr, e);
}
function a6(n, e) {
  n.uniform3uiv(this.addr, e);
}
function l6(n, e) {
  n.uniform4uiv(this.addr, e);
}
function u6(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = My(t, i);
  li(r, o) || (n.uniform1iv(this.addr, o), ui(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture2D(e[s] || CA, o[s]);
}
function c6(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = My(t, i);
  li(r, o) || (n.uniform1iv(this.addr, o), ui(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture3D(e[s] || RA, o[s]);
}
function f6(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = My(t, i);
  li(r, o) || (n.uniform1iv(this.addr, o), ui(r, o));
  for (let s = 0; s !== i; ++s) t.setTextureCube(e[s] || PA, o[s]);
}
function d6(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = My(t, i);
  li(r, o) || (n.uniform1iv(this.addr, o), ui(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture2DArray(e[s] || AA, o[s]);
}
function h6(n) {
  switch (n) {
    case 5126:
      return Y5;
    case 35664:
      return q5;
    case 35665:
      return K5;
    case 35666:
      return Z5;
    case 35674:
      return J5;
    case 35675:
      return Q5;
    case 35676:
      return e6;
    case 5124:
    case 35670:
      return t6;
    case 35667:
    case 35671:
      return n6;
    case 35668:
    case 35672:
      return r6;
    case 35669:
    case 35673:
      return i6;
    case 5125:
      return o6;
    case 36294:
      return s6;
    case 36295:
      return a6;
    case 36296:
      return l6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return u6;
    case 35679:
    case 36299:
    case 36307:
      return c6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return f6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return d6;
  }
}
class p6 {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = X5(t.type));
  }
}
class m6 {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = h6(t.type));
  }
}
class g6 {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let o = 0, s = i.length; o !== s; ++o) {
      const l = i[o];
      l.setValue(e, t[l.id], r);
    }
  }
}
const P_ = /(\w+)(\])?(\[|\.)?/g;
function hE(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function v6(n, e, t) {
  const r = n.name,
    i = r.length;
  for (P_.lastIndex = 0; ; ) {
    const o = P_.exec(r),
      s = P_.lastIndex;
    let l = o[1];
    const u = o[2] === "]",
      f = o[3];
    if ((u && (l = l | 0), f === void 0 || (f === "[" && s + 2 === i))) {
      hE(t, f === void 0 ? new p6(l, n, e) : new m6(l, n, e));
      break;
    } else {
      let m = t.map[l];
      m === void 0 && ((m = new g6(l)), hE(t, m)), (t = m);
    }
  }
}
class Yv {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const o = e.getActiveUniform(t, i),
        s = e.getUniformLocation(t, o.name);
      v6(o, s, this);
    }
  }
  setValue(e, t, r, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let o = 0, s = t.length; o !== s; ++o) {
      const l = t[o],
        u = r[l.id];
      u.needsUpdate !== !1 && l.setValue(e, u.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const s = e[i];
      s.id in t && r.push(s);
    }
    return r;
  }
}
function pE(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
const y6 = 37297;
let x6 = 0;
function _6(n, e) {
  const t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    o = Math.min(e + 6, t.length);
  for (let s = i; s < o; s++) {
    const l = s + 1;
    r.push(`${l === e ? ">" : " "} ${l}: ${t[s]}`);
  }
  return r.join(`
`);
}
function S6(n) {
  const e = yn.getPrimaries(yn.workingColorSpace),
    t = yn.getPrimaries(n);
  let r;
  switch (
    (e === t
      ? (r = "")
      : e === pm && t === hm
      ? (r = "LinearDisplayP3ToLinearSRGB")
      : e === hm && t === pm && (r = "LinearSRGBToLinearDisplayP3"),
    n)
  ) {
    case kl:
    case Om:
      return [r, "LinearTransferOETF"];
    case Ms:
    case Sy:
      return [r, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [r, "LinearTransferOETF"]
      );
  }
}
function mE(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const s = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      _6(n.getShaderSource(e), s)
    );
  } else return i;
}
function w6(n, e) {
  const t = S6(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function M6(n, e) {
  let t;
  switch (e) {
    case Q2:
      t = "Linear";
      break;
    case eA:
      t = "Reinhard";
      break;
    case tA:
      t = "OptimizedCineon";
      break;
    case AS:
      t = "ACESFilmic";
      break;
    case rA:
      t = "AgX";
      break;
    case iA:
      t = "Neutral";
      break;
    case nA:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const uv = new ie();
function b6() {
  yn.getLuminanceCoefficients(uv);
  const n = uv.x.toFixed(4),
    e = uv.y.toFixed(4),
    t = uv.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function E6(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Dp).join(`
`);
}
function T6(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function C6(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const o = n.getActiveAttrib(e, i),
      s = o.name;
    let l = 1;
    o.type === n.FLOAT_MAT2 && (l = 2),
      o.type === n.FLOAT_MAT3 && (l = 3),
      o.type === n.FLOAT_MAT4 && (l = 4),
      (t[s] = {
        type: o.type,
        location: n.getAttribLocation(e, s),
        locationSize: l,
      });
  }
  return t;
}
function Dp(n) {
  return n !== "";
}
function gE(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function vE(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const A6 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function U1(n) {
  return n.replace(A6, P6);
}
const R6 = new Map();
function P6(n, e) {
  let t = rn[e];
  if (t === void 0) {
    const r = R6.get(e);
    if (r !== void 0)
      (t = rn[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return U1(t);
}
const I6 =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function yE(n) {
  return n.replace(I6, L6);
}
function L6(n, e, t, r) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function xE(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function D6(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === dy
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === zp
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === na && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function k6(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Il:
      case Bu:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case vh:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function O6(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Bu:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function N6(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case Dm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Z2:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case J2:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function U6(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function F6(n, e, t, r) {
  const i = n.getContext(),
    o = t.defines;
  let s = t.vertexShader,
    l = t.fragmentShader;
  const u = D6(t),
    f = k6(t),
    h = O6(t),
    m = N6(t),
    g = U6(t),
    y = E6(t),
    _ = T6(o),
    S = i.createProgram();
  let x,
    w,
    T = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((x = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(Dp).join(`
`)),
      x.length > 0 &&
        (x += `
`),
      (w = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(Dp).join(`
`)),
      w.length > 0 &&
        (w += `
`))
    : ((x = [
        xE(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Dp).join(`
`)),
      (w = [
        xE(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + f : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + m : "",
        g ? "#define CUBEUV_TEXEL_WIDTH " + g.texelWidth : "",
        g ? "#define CUBEUV_TEXEL_HEIGHT " + g.texelHeight : "",
        g ? "#define CUBEUV_MAX_MIP " + g.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Ba ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Ba ? rn.tonemapping_pars_fragment : "",
        t.toneMapping !== Ba ? M6("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        rn.colorspace_pars_fragment,
        w6("linearToOutputTexel", t.outputColorSpace),
        b6(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Dp).join(`
`))),
    (s = U1(s)),
    (s = gE(s, t)),
    (s = vE(s, t)),
    (l = U1(l)),
    (l = gE(l, t)),
    (l = vE(l, t)),
    (s = yE(s)),
    (l = yE(l)),
    t.isRawShaderMaterial !== !0 &&
      ((T = `#version 300 es
`),
      (x =
        [
          y,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        x),
      (w =
        [
          "#define varying in",
          t.glslVersion === O1
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === O1 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        w));
  const E = T + x + s,
    A = T + w + l,
    R = pE(i, i.VERTEX_SHADER, E),
    D = pE(i, i.FRAGMENT_SHADER, A);
  i.attachShader(S, R),
    i.attachShader(S, D),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(S, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(S, 0, "position"),
    i.linkProgram(S);
  function I(V) {
    if (n.debug.checkShaderErrors) {
      const H = i.getProgramInfoLog(S).trim(),
        $ = i.getShaderInfoLog(R).trim(),
        q = i.getShaderInfoLog(D).trim();
      let K = !0,
        Y = !0;
      if (i.getProgramParameter(S, i.LINK_STATUS) === !1)
        if (((K = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(i, S, R, D);
        else {
          const ne = mE(i, R, "vertex"),
            j = mE(i, D, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(S, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              V.name +
              `
Material Type: ` +
              V.type +
              `

Program Info Log: ` +
              H +
              `
` +
              ne +
              `
` +
              j
          );
        }
      else
        H !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", H)
          : ($ === "" || q === "") && (Y = !1);
      Y &&
        (V.diagnostics = {
          runnable: K,
          programLog: H,
          vertexShader: { log: $, prefix: x },
          fragmentShader: { log: q, prefix: w },
        });
    }
    i.deleteShader(R), i.deleteShader(D), (U = new Yv(i, S)), (O = C6(i, S));
  }
  let U;
  this.getUniforms = function () {
    return U === void 0 && I(this), U;
  };
  let O;
  this.getAttributes = function () {
    return O === void 0 && I(this), O;
  };
  let L = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return L === !1 && (L = i.getProgramParameter(S, y6)), L;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(S),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = x6++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = S),
    (this.vertexShader = R),
    (this.fragmentShader = D),
    this
  );
}
let z6 = 0;
class B6 {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(t),
      o = this._getShaderStage(r),
      s = this._getShaderCacheForMaterial(e);
    return (
      s.has(i) === !1 && (s.add(i), i.usedTimes++),
      s.has(o) === !1 && (s.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new V6(e)), t.set(e, r)), r;
  }
}
class V6 {
  constructor(e) {
    (this.id = z6++), (this.code = e), (this.usedTimes = 0);
  }
}
function H6(n, e, t, r, i, o, s) {
  const l = new ef(),
    u = new B6(),
    f = new Set(),
    h = [],
    m = i.logarithmicDepthBuffer,
    g = i.vertexTextures;
  let y = i.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function S(O) {
    return f.add(O), O === 0 ? "uv" : `uv${O}`;
  }
  function x(O, L, V, H, $) {
    const q = H.fog,
      K = $.geometry,
      Y = O.isMeshStandardMaterial ? H.environment : null,
      ne = (O.isMeshStandardMaterial ? t : e).get(O.envMap || Y),
      j = ne && ne.mapping === vh ? ne.image.height : null,
      re = _[O.type];
    O.precision !== null &&
      ((y = i.getMaxPrecision(O.precision)),
      y !== O.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          O.precision,
          "not supported, using",
          y,
          "instead."
        ));
    const B =
        K.morphAttributes.position ||
        K.morphAttributes.normal ||
        K.morphAttributes.color,
      G = B !== void 0 ? B.length : 0;
    let te = 0;
    K.morphAttributes.position !== void 0 && (te = 1),
      K.morphAttributes.normal !== void 0 && (te = 2),
      K.morphAttributes.color !== void 0 && (te = 3);
    let le, J, oe, he;
    if (re) {
      const ht = ra[re];
      (le = ht.vertexShader), (J = ht.fragmentShader);
    } else
      (le = O.vertexShader),
        (J = O.fragmentShader),
        u.update(O),
        (oe = u.getVertexShaderID(O)),
        (he = u.getFragmentShaderID(O));
    const ae = n.getRenderTarget(),
      ue = $.isInstancedMesh === !0,
      Ee = $.isBatchedMesh === !0,
      Ne = !!O.map,
      Ae = !!O.matcap,
      W = !!ne,
      _e = !!O.aoMap,
      Te = !!O.lightMap,
      ke = !!O.bumpMap,
      Pe = !!O.normalMap,
      rt = !!O.displacementMap,
      Le = !!O.emissiveMap,
      Xe = !!O.metalnessMap,
      Z = !!O.roughnessMap,
      F = O.anisotropy > 0,
      me = O.clearcoat > 0,
      xe = O.dispersion > 0,
      ye = O.iridescence > 0,
      Me = O.sheen > 0,
      at = O.transmission > 0,
      Fe = F && !!O.anisotropyMap,
      ze = me && !!O.clearcoatMap,
      We = me && !!O.clearcoatNormalMap,
      Ye = me && !!O.clearcoatRoughnessMap,
      nt = ye && !!O.iridescenceMap,
      yt = ye && !!O.iridescenceThicknessMap,
      $e = Me && !!O.sheenColorMap,
      qe = Me && !!O.sheenRoughnessMap,
      et = !!O.specularMap,
      ce = !!O.specularColorMap,
      Je = !!O.specularIntensityMap,
      de = at && !!O.transmissionMap,
      He = at && !!O.thicknessMap,
      Ce = !!O.gradientMap,
      Ue = !!O.alphaMap,
      it = O.alphaTest > 0,
      mt = !!O.alphaHash,
      gt = !!O.extensions;
    let Ot = Ba;
    O.toneMapped &&
      (ae === null || ae.isXRRenderTarget === !0) &&
      (Ot = n.toneMapping);
    const Nt = {
      shaderID: re,
      shaderType: O.type,
      shaderName: O.name,
      vertexShader: le,
      fragmentShader: J,
      defines: O.defines,
      customVertexShaderID: oe,
      customFragmentShaderID: he,
      isRawShaderMaterial: O.isRawShaderMaterial === !0,
      glslVersion: O.glslVersion,
      precision: y,
      batching: Ee,
      batchingColor: Ee && $._colorsTexture !== null,
      instancing: ue,
      instancingColor: ue && $.instanceColor !== null,
      instancingMorph: ue && $.morphTexture !== null,
      supportsVertexTextures: g,
      outputColorSpace:
        ae === null
          ? n.outputColorSpace
          : ae.isXRRenderTarget === !0
          ? ae.texture.colorSpace
          : kl,
      alphaToCoverage: !!O.alphaToCoverage,
      map: Ne,
      matcap: Ae,
      envMap: W,
      envMapMode: W && ne.mapping,
      envMapCubeUVHeight: j,
      aoMap: _e,
      lightMap: Te,
      bumpMap: ke,
      normalMap: Pe,
      displacementMap: g && rt,
      emissiveMap: Le,
      normalMapObjectSpace: Pe && O.normalMapType === cA,
      normalMapTangentSpace: Pe && O.normalMapType === Gu,
      metalnessMap: Xe,
      roughnessMap: Z,
      anisotropy: F,
      anisotropyMap: Fe,
      clearcoat: me,
      clearcoatMap: ze,
      clearcoatNormalMap: We,
      clearcoatRoughnessMap: Ye,
      dispersion: xe,
      iridescence: ye,
      iridescenceMap: nt,
      iridescenceThicknessMap: yt,
      sheen: Me,
      sheenColorMap: $e,
      sheenRoughnessMap: qe,
      specularMap: et,
      specularColorMap: ce,
      specularIntensityMap: Je,
      transmission: at,
      transmissionMap: de,
      thicknessMap: He,
      gradientMap: Ce,
      opaque:
        O.transparent === !1 && O.blending === Zc && O.alphaToCoverage === !1,
      alphaMap: Ue,
      alphaTest: it,
      alphaHash: mt,
      combine: O.combine,
      mapUv: Ne && S(O.map.channel),
      aoMapUv: _e && S(O.aoMap.channel),
      lightMapUv: Te && S(O.lightMap.channel),
      bumpMapUv: ke && S(O.bumpMap.channel),
      normalMapUv: Pe && S(O.normalMap.channel),
      displacementMapUv: rt && S(O.displacementMap.channel),
      emissiveMapUv: Le && S(O.emissiveMap.channel),
      metalnessMapUv: Xe && S(O.metalnessMap.channel),
      roughnessMapUv: Z && S(O.roughnessMap.channel),
      anisotropyMapUv: Fe && S(O.anisotropyMap.channel),
      clearcoatMapUv: ze && S(O.clearcoatMap.channel),
      clearcoatNormalMapUv: We && S(O.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ye && S(O.clearcoatRoughnessMap.channel),
      iridescenceMapUv: nt && S(O.iridescenceMap.channel),
      iridescenceThicknessMapUv: yt && S(O.iridescenceThicknessMap.channel),
      sheenColorMapUv: $e && S(O.sheenColorMap.channel),
      sheenRoughnessMapUv: qe && S(O.sheenRoughnessMap.channel),
      specularMapUv: et && S(O.specularMap.channel),
      specularColorMapUv: ce && S(O.specularColorMap.channel),
      specularIntensityMapUv: Je && S(O.specularIntensityMap.channel),
      transmissionMapUv: de && S(O.transmissionMap.channel),
      thicknessMapUv: He && S(O.thicknessMap.channel),
      alphaMapUv: Ue && S(O.alphaMap.channel),
      vertexTangents: !!K.attributes.tangent && (Pe || F),
      vertexColors: O.vertexColors,
      vertexAlphas:
        O.vertexColors === !0 &&
        !!K.attributes.color &&
        K.attributes.color.itemSize === 4,
      pointsUvs: $.isPoints === !0 && !!K.attributes.uv && (Ne || Ue),
      fog: !!q,
      useFog: O.fog === !0,
      fogExp2: !!q && q.isFogExp2,
      flatShading: O.flatShading === !0,
      sizeAttenuation: O.sizeAttenuation === !0,
      logarithmicDepthBuffer: m,
      skinning: $.isSkinnedMesh === !0,
      morphTargets: K.morphAttributes.position !== void 0,
      morphNormals: K.morphAttributes.normal !== void 0,
      morphColors: K.morphAttributes.color !== void 0,
      morphTargetsCount: G,
      morphTextureStride: te,
      numDirLights: L.directional.length,
      numPointLights: L.point.length,
      numSpotLights: L.spot.length,
      numSpotLightMaps: L.spotLightMap.length,
      numRectAreaLights: L.rectArea.length,
      numHemiLights: L.hemi.length,
      numDirLightShadows: L.directionalShadowMap.length,
      numPointLightShadows: L.pointShadowMap.length,
      numSpotLightShadows: L.spotShadowMap.length,
      numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
      numLightProbes: L.numLightProbes,
      numClippingPlanes: s.numPlanes,
      numClipIntersection: s.numIntersection,
      dithering: O.dithering,
      shadowMapEnabled: n.shadowMap.enabled && V.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: Ot,
      decodeVideoTexture:
        Ne &&
        O.map.isVideoTexture === !0 &&
        yn.getTransfer(O.map.colorSpace) === $n,
      premultipliedAlpha: O.premultipliedAlpha,
      doubleSided: O.side === Es,
      flipSided: O.side === Zi,
      useDepthPacking: O.depthPacking >= 0,
      depthPacking: O.depthPacking || 0,
      index0AttributeName: O.index0AttributeName,
      extensionClipCullDistance:
        gt &&
        O.extensions.clipCullDistance === !0 &&
        r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((gt && O.extensions.multiDraw === !0) || Ee) &&
        r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: O.customProgramCacheKey(),
    };
    return (
      (Nt.vertexUv1s = f.has(1)),
      (Nt.vertexUv2s = f.has(2)),
      (Nt.vertexUv3s = f.has(3)),
      f.clear(),
      Nt
    );
  }
  function w(O) {
    const L = [];
    if (
      (O.shaderID
        ? L.push(O.shaderID)
        : (L.push(O.customVertexShaderID), L.push(O.customFragmentShaderID)),
      O.defines !== void 0)
    )
      for (const V in O.defines) L.push(V), L.push(O.defines[V]);
    return (
      O.isRawShaderMaterial === !1 &&
        (T(L, O), E(L, O), L.push(n.outputColorSpace)),
      L.push(O.customProgramCacheKey),
      L.join()
    );
  }
  function T(O, L) {
    O.push(L.precision),
      O.push(L.outputColorSpace),
      O.push(L.envMapMode),
      O.push(L.envMapCubeUVHeight),
      O.push(L.mapUv),
      O.push(L.alphaMapUv),
      O.push(L.lightMapUv),
      O.push(L.aoMapUv),
      O.push(L.bumpMapUv),
      O.push(L.normalMapUv),
      O.push(L.displacementMapUv),
      O.push(L.emissiveMapUv),
      O.push(L.metalnessMapUv),
      O.push(L.roughnessMapUv),
      O.push(L.anisotropyMapUv),
      O.push(L.clearcoatMapUv),
      O.push(L.clearcoatNormalMapUv),
      O.push(L.clearcoatRoughnessMapUv),
      O.push(L.iridescenceMapUv),
      O.push(L.iridescenceThicknessMapUv),
      O.push(L.sheenColorMapUv),
      O.push(L.sheenRoughnessMapUv),
      O.push(L.specularMapUv),
      O.push(L.specularColorMapUv),
      O.push(L.specularIntensityMapUv),
      O.push(L.transmissionMapUv),
      O.push(L.thicknessMapUv),
      O.push(L.combine),
      O.push(L.fogExp2),
      O.push(L.sizeAttenuation),
      O.push(L.morphTargetsCount),
      O.push(L.morphAttributeCount),
      O.push(L.numDirLights),
      O.push(L.numPointLights),
      O.push(L.numSpotLights),
      O.push(L.numSpotLightMaps),
      O.push(L.numHemiLights),
      O.push(L.numRectAreaLights),
      O.push(L.numDirLightShadows),
      O.push(L.numPointLightShadows),
      O.push(L.numSpotLightShadows),
      O.push(L.numSpotLightShadowsWithMaps),
      O.push(L.numLightProbes),
      O.push(L.shadowMapType),
      O.push(L.toneMapping),
      O.push(L.numClippingPlanes),
      O.push(L.numClipIntersection),
      O.push(L.depthPacking);
  }
  function E(O, L) {
    l.disableAll(),
      L.supportsVertexTextures && l.enable(0),
      L.instancing && l.enable(1),
      L.instancingColor && l.enable(2),
      L.instancingMorph && l.enable(3),
      L.matcap && l.enable(4),
      L.envMap && l.enable(5),
      L.normalMapObjectSpace && l.enable(6),
      L.normalMapTangentSpace && l.enable(7),
      L.clearcoat && l.enable(8),
      L.iridescence && l.enable(9),
      L.alphaTest && l.enable(10),
      L.vertexColors && l.enable(11),
      L.vertexAlphas && l.enable(12),
      L.vertexUv1s && l.enable(13),
      L.vertexUv2s && l.enable(14),
      L.vertexUv3s && l.enable(15),
      L.vertexTangents && l.enable(16),
      L.anisotropy && l.enable(17),
      L.alphaHash && l.enable(18),
      L.batching && l.enable(19),
      L.dispersion && l.enable(20),
      L.batchingColor && l.enable(21),
      O.push(l.mask),
      l.disableAll(),
      L.fog && l.enable(0),
      L.useFog && l.enable(1),
      L.flatShading && l.enable(2),
      L.logarithmicDepthBuffer && l.enable(3),
      L.skinning && l.enable(4),
      L.morphTargets && l.enable(5),
      L.morphNormals && l.enable(6),
      L.morphColors && l.enable(7),
      L.premultipliedAlpha && l.enable(8),
      L.shadowMapEnabled && l.enable(9),
      L.doubleSided && l.enable(10),
      L.flipSided && l.enable(11),
      L.useDepthPacking && l.enable(12),
      L.dithering && l.enable(13),
      L.transmission && l.enable(14),
      L.sheen && l.enable(15),
      L.opaque && l.enable(16),
      L.pointsUvs && l.enable(17),
      L.decodeVideoTexture && l.enable(18),
      L.alphaToCoverage && l.enable(19),
      O.push(l.mask);
  }
  function A(O) {
    const L = _[O.type];
    let V;
    if (L) {
      const H = ra[L];
      V = $S.clone(H.uniforms);
    } else V = O.uniforms;
    return V;
  }
  function R(O, L) {
    let V;
    for (let H = 0, $ = h.length; H < $; H++) {
      const q = h[H];
      if (q.cacheKey === L) {
        (V = q), ++V.usedTimes;
        break;
      }
    }
    return V === void 0 && ((V = new F6(n, L, O, o)), h.push(V)), V;
  }
  function D(O) {
    if (--O.usedTimes === 0) {
      const L = h.indexOf(O);
      (h[L] = h[h.length - 1]), h.pop(), O.destroy();
    }
  }
  function I(O) {
    u.remove(O);
  }
  function U() {
    u.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: w,
    getUniforms: A,
    acquireProgram: R,
    releaseProgram: D,
    releaseShaderCache: I,
    programs: h,
    dispose: U,
  };
}
function G6() {
  let n = new WeakMap();
  function e(o) {
    let s = n.get(o);
    return s === void 0 && ((s = {}), n.set(o, s)), s;
  }
  function t(o) {
    n.delete(o);
  }
  function r(o, s, l) {
    n.get(o)[s] = l;
  }
  function i() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: r, dispose: i };
}
function W6(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function _E(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function SE() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    i = [];
  function o() {
    (e = 0), (t.length = 0), (r.length = 0), (i.length = 0);
  }
  function s(m, g, y, _, S, x) {
    let w = n[e];
    return (
      w === void 0
        ? ((w = {
            id: m.id,
            object: m,
            geometry: g,
            material: y,
            groupOrder: _,
            renderOrder: m.renderOrder,
            z: S,
            group: x,
          }),
          (n[e] = w))
        : ((w.id = m.id),
          (w.object = m),
          (w.geometry = g),
          (w.material = y),
          (w.groupOrder = _),
          (w.renderOrder = m.renderOrder),
          (w.z = S),
          (w.group = x)),
      e++,
      w
    );
  }
  function l(m, g, y, _, S, x) {
    const w = s(m, g, y, _, S, x);
    y.transmission > 0
      ? r.push(w)
      : y.transparent === !0
      ? i.push(w)
      : t.push(w);
  }
  function u(m, g, y, _, S, x) {
    const w = s(m, g, y, _, S, x);
    y.transmission > 0
      ? r.unshift(w)
      : y.transparent === !0
      ? i.unshift(w)
      : t.unshift(w);
  }
  function f(m, g) {
    t.length > 1 && t.sort(m || W6),
      r.length > 1 && r.sort(g || _E),
      i.length > 1 && i.sort(g || _E);
  }
  function h() {
    for (let m = e, g = n.length; m < g; m++) {
      const y = n[m];
      if (y.id === null) break;
      (y.id = null),
        (y.object = null),
        (y.geometry = null),
        (y.material = null),
        (y.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: o,
    push: l,
    unshift: u,
    finish: h,
    sort: f,
  };
}
function j6() {
  let n = new WeakMap();
  function e(r, i) {
    const o = n.get(r);
    let s;
    return (
      o === void 0
        ? ((s = new SE()), n.set(r, [s]))
        : i >= o.length
        ? ((s = new SE()), o.push(s))
        : (s = o[i]),
      s
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function $6() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new ie(), color: new St() };
          break;
        case "SpotLight":
          t = {
            position: new ie(),
            direction: new ie(),
            color: new St(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new ie(), color: new St(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = {
            direction: new ie(),
            skyColor: new St(),
            groundColor: new St(),
          };
          break;
        case "RectAreaLight":
          t = {
            color: new St(),
            position: new ie(),
            halfWidth: new ie(),
            halfHeight: new ie(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function X6() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let Y6 = 0;
function q6(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function K6(n) {
  const e = new $6(),
    t = X6(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let f = 0; f < 9; f++) r.probe.push(new ie());
  const i = new ie(),
    o = new Wt(),
    s = new Wt();
  function l(f) {
    let h = 0,
      m = 0,
      g = 0;
    for (let O = 0; O < 9; O++) r.probe[O].set(0, 0, 0);
    let y = 0,
      _ = 0,
      S = 0,
      x = 0,
      w = 0,
      T = 0,
      E = 0,
      A = 0,
      R = 0,
      D = 0,
      I = 0;
    f.sort(q6);
    for (let O = 0, L = f.length; O < L; O++) {
      const V = f[O],
        H = V.color,
        $ = V.intensity,
        q = V.distance,
        K = V.shadow && V.shadow.map ? V.shadow.map.texture : null;
      if (V.isAmbientLight) (h += H.r * $), (m += H.g * $), (g += H.b * $);
      else if (V.isLightProbe) {
        for (let Y = 0; Y < 9; Y++)
          r.probe[Y].addScaledVector(V.sh.coefficients[Y], $);
        I++;
      } else if (V.isDirectionalLight) {
        const Y = e.get(V);
        if ((Y.color.copy(V.color).multiplyScalar(V.intensity), V.castShadow)) {
          const ne = V.shadow,
            j = t.get(V);
          (j.shadowIntensity = ne.intensity),
            (j.shadowBias = ne.bias),
            (j.shadowNormalBias = ne.normalBias),
            (j.shadowRadius = ne.radius),
            (j.shadowMapSize = ne.mapSize),
            (r.directionalShadow[y] = j),
            (r.directionalShadowMap[y] = K),
            (r.directionalShadowMatrix[y] = V.shadow.matrix),
            T++;
        }
        (r.directional[y] = Y), y++;
      } else if (V.isSpotLight) {
        const Y = e.get(V);
        Y.position.setFromMatrixPosition(V.matrixWorld),
          Y.color.copy(H).multiplyScalar($),
          (Y.distance = q),
          (Y.coneCos = Math.cos(V.angle)),
          (Y.penumbraCos = Math.cos(V.angle * (1 - V.penumbra))),
          (Y.decay = V.decay),
          (r.spot[S] = Y);
        const ne = V.shadow;
        if (
          (V.map &&
            ((r.spotLightMap[R] = V.map),
            R++,
            ne.updateMatrices(V),
            V.castShadow && D++),
          (r.spotLightMatrix[S] = ne.matrix),
          V.castShadow)
        ) {
          const j = t.get(V);
          (j.shadowIntensity = ne.intensity),
            (j.shadowBias = ne.bias),
            (j.shadowNormalBias = ne.normalBias),
            (j.shadowRadius = ne.radius),
            (j.shadowMapSize = ne.mapSize),
            (r.spotShadow[S] = j),
            (r.spotShadowMap[S] = K),
            A++;
        }
        S++;
      } else if (V.isRectAreaLight) {
        const Y = e.get(V);
        Y.color.copy(H).multiplyScalar($),
          Y.halfWidth.set(V.width * 0.5, 0, 0),
          Y.halfHeight.set(0, V.height * 0.5, 0),
          (r.rectArea[x] = Y),
          x++;
      } else if (V.isPointLight) {
        const Y = e.get(V);
        if (
          (Y.color.copy(V.color).multiplyScalar(V.intensity),
          (Y.distance = V.distance),
          (Y.decay = V.decay),
          V.castShadow)
        ) {
          const ne = V.shadow,
            j = t.get(V);
          (j.shadowIntensity = ne.intensity),
            (j.shadowBias = ne.bias),
            (j.shadowNormalBias = ne.normalBias),
            (j.shadowRadius = ne.radius),
            (j.shadowMapSize = ne.mapSize),
            (j.shadowCameraNear = ne.camera.near),
            (j.shadowCameraFar = ne.camera.far),
            (r.pointShadow[_] = j),
            (r.pointShadowMap[_] = K),
            (r.pointShadowMatrix[_] = V.shadow.matrix),
            E++;
        }
        (r.point[_] = Y), _++;
      } else if (V.isHemisphereLight) {
        const Y = e.get(V);
        Y.skyColor.copy(V.color).multiplyScalar($),
          Y.groundColor.copy(V.groundColor).multiplyScalar($),
          (r.hemi[w] = Y),
          w++;
      }
    }
    x > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = xt.LTC_FLOAT_1), (r.rectAreaLTC2 = xt.LTC_FLOAT_2))
        : ((r.rectAreaLTC1 = xt.LTC_HALF_1), (r.rectAreaLTC2 = xt.LTC_HALF_2))),
      (r.ambient[0] = h),
      (r.ambient[1] = m),
      (r.ambient[2] = g);
    const U = r.hash;
    (U.directionalLength !== y ||
      U.pointLength !== _ ||
      U.spotLength !== S ||
      U.rectAreaLength !== x ||
      U.hemiLength !== w ||
      U.numDirectionalShadows !== T ||
      U.numPointShadows !== E ||
      U.numSpotShadows !== A ||
      U.numSpotMaps !== R ||
      U.numLightProbes !== I) &&
      ((r.directional.length = y),
      (r.spot.length = S),
      (r.rectArea.length = x),
      (r.point.length = _),
      (r.hemi.length = w),
      (r.directionalShadow.length = T),
      (r.directionalShadowMap.length = T),
      (r.pointShadow.length = E),
      (r.pointShadowMap.length = E),
      (r.spotShadow.length = A),
      (r.spotShadowMap.length = A),
      (r.directionalShadowMatrix.length = T),
      (r.pointShadowMatrix.length = E),
      (r.spotLightMatrix.length = A + R - D),
      (r.spotLightMap.length = R),
      (r.numSpotLightShadowsWithMaps = D),
      (r.numLightProbes = I),
      (U.directionalLength = y),
      (U.pointLength = _),
      (U.spotLength = S),
      (U.rectAreaLength = x),
      (U.hemiLength = w),
      (U.numDirectionalShadows = T),
      (U.numPointShadows = E),
      (U.numSpotShadows = A),
      (U.numSpotMaps = R),
      (U.numLightProbes = I),
      (r.version = Y6++));
  }
  function u(f, h) {
    let m = 0,
      g = 0,
      y = 0,
      _ = 0,
      S = 0;
    const x = h.matrixWorldInverse;
    for (let w = 0, T = f.length; w < T; w++) {
      const E = f[w];
      if (E.isDirectionalLight) {
        const A = r.directional[m];
        A.direction.setFromMatrixPosition(E.matrixWorld),
          i.setFromMatrixPosition(E.target.matrixWorld),
          A.direction.sub(i),
          A.direction.transformDirection(x),
          m++;
      } else if (E.isSpotLight) {
        const A = r.spot[y];
        A.position.setFromMatrixPosition(E.matrixWorld),
          A.position.applyMatrix4(x),
          A.direction.setFromMatrixPosition(E.matrixWorld),
          i.setFromMatrixPosition(E.target.matrixWorld),
          A.direction.sub(i),
          A.direction.transformDirection(x),
          y++;
      } else if (E.isRectAreaLight) {
        const A = r.rectArea[_];
        A.position.setFromMatrixPosition(E.matrixWorld),
          A.position.applyMatrix4(x),
          s.identity(),
          o.copy(E.matrixWorld),
          o.premultiply(x),
          s.extractRotation(o),
          A.halfWidth.set(E.width * 0.5, 0, 0),
          A.halfHeight.set(0, E.height * 0.5, 0),
          A.halfWidth.applyMatrix4(s),
          A.halfHeight.applyMatrix4(s),
          _++;
      } else if (E.isPointLight) {
        const A = r.point[g];
        A.position.setFromMatrixPosition(E.matrixWorld),
          A.position.applyMatrix4(x),
          g++;
      } else if (E.isHemisphereLight) {
        const A = r.hemi[S];
        A.direction.setFromMatrixPosition(E.matrixWorld),
          A.direction.transformDirection(x),
          S++;
      }
    }
  }
  return { setup: l, setupView: u, state: r };
}
function wE(n) {
  const e = new K6(n),
    t = [],
    r = [];
  function i(h) {
    (f.camera = h), (t.length = 0), (r.length = 0);
  }
  function o(h) {
    t.push(h);
  }
  function s(h) {
    r.push(h);
  }
  function l() {
    e.setup(t);
  }
  function u(h) {
    e.setupView(t, h);
  }
  const f = {
    lightsArray: t,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: f,
    setupLights: l,
    setupLightsView: u,
    pushLight: o,
    pushShadow: s,
  };
}
function Z6(n) {
  let e = new WeakMap();
  function t(i, o = 0) {
    const s = e.get(i);
    let l;
    return (
      s === void 0
        ? ((l = new wE(n)), e.set(i, [l]))
        : o >= s.length
        ? ((l = new wE(n)), s.push(l))
        : (l = s[o]),
      l
    );
  }
  function r() {
    e = new WeakMap();
  }
  return { get: t, dispose: r };
}
class by extends ki {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = uA),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Ey extends ki {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const J6 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  Q6 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function eV(n, e, t) {
  let r = new Fm();
  const i = new tt(),
    o = new tt(),
    s = new En(),
    l = new by({ depthPacking: BS }),
    u = new Ey(),
    f = {},
    h = t.maxTextureSize,
    m = { [Ga]: Zi, [Zi]: Ga, [Es]: Es },
    g = new la({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new tt() },
        radius: { value: 4 },
      },
      vertexShader: J6,
      fragmentShader: Q6,
    }),
    y = g.clone();
  y.defines.HORIZONTAL_PASS = 1;
  const _ = new Kt();
  _.setAttribute(
    "position",
    new zn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const S = new dr(_, g),
    x = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = dy);
  let w = this.type;
  this.render = function (D, I, U) {
    if (
      x.enabled === !1 ||
      (x.autoUpdate === !1 && x.needsUpdate === !1) ||
      D.length === 0
    )
      return;
    const O = n.getRenderTarget(),
      L = n.getActiveCubeFace(),
      V = n.getActiveMipmapLevel(),
      H = n.state;
    H.setBlending(Al),
      H.buffers.color.setClear(1, 1, 1, 1),
      H.buffers.depth.setTest(!0),
      H.setScissorTest(!1);
    const $ = w !== na && this.type === na,
      q = w === na && this.type !== na;
    for (let K = 0, Y = D.length; K < Y; K++) {
      const ne = D[K],
        j = ne.shadow;
      if (j === void 0) {
        console.warn("THREE.WebGLShadowMap:", ne, "has no shadow.");
        continue;
      }
      if (j.autoUpdate === !1 && j.needsUpdate === !1) continue;
      i.copy(j.mapSize);
      const re = j.getFrameExtents();
      if (
        (i.multiply(re),
        o.copy(j.mapSize),
        (i.x > h || i.y > h) &&
          (i.x > h &&
            ((o.x = Math.floor(h / re.x)),
            (i.x = o.x * re.x),
            (j.mapSize.x = o.x)),
          i.y > h &&
            ((o.y = Math.floor(h / re.y)),
            (i.y = o.y * re.y),
            (j.mapSize.y = o.y))),
        j.map === null || $ === !0 || q === !0)
      ) {
        const G = this.type !== na ? { minFilter: yi, magFilter: yi } : {};
        j.map !== null && j.map.dispose(),
          (j.map = new aa(i.x, i.y, G)),
          (j.map.texture.name = ne.name + ".shadowMap"),
          j.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(j.map), n.clear();
      const B = j.getViewportCount();
      for (let G = 0; G < B; G++) {
        const te = j.getViewport(G);
        s.set(o.x * te.x, o.y * te.y, o.x * te.z, o.y * te.w),
          H.viewport(s),
          j.updateMatrices(ne, G),
          (r = j.getFrustum()),
          A(I, U, j.camera, ne, this.type);
      }
      j.isPointLightShadow !== !0 && this.type === na && T(j, U),
        (j.needsUpdate = !1);
    }
    (w = this.type), (x.needsUpdate = !1), n.setRenderTarget(O, L, V);
  };
  function T(D, I) {
    const U = e.update(S);
    g.defines.VSM_SAMPLES !== D.blurSamples &&
      ((g.defines.VSM_SAMPLES = D.blurSamples),
      (y.defines.VSM_SAMPLES = D.blurSamples),
      (g.needsUpdate = !0),
      (y.needsUpdate = !0)),
      D.mapPass === null && (D.mapPass = new aa(i.x, i.y)),
      (g.uniforms.shadow_pass.value = D.map.texture),
      (g.uniforms.resolution.value = D.mapSize),
      (g.uniforms.radius.value = D.radius),
      n.setRenderTarget(D.mapPass),
      n.clear(),
      n.renderBufferDirect(I, null, U, g, S, null),
      (y.uniforms.shadow_pass.value = D.mapPass.texture),
      (y.uniforms.resolution.value = D.mapSize),
      (y.uniforms.radius.value = D.radius),
      n.setRenderTarget(D.map),
      n.clear(),
      n.renderBufferDirect(I, null, U, y, S, null);
  }
  function E(D, I, U, O) {
    let L = null;
    const V =
      U.isPointLight === !0 ? D.customDistanceMaterial : D.customDepthMaterial;
    if (V !== void 0) L = V;
    else if (
      ((L = U.isPointLight === !0 ? u : l),
      (n.localClippingEnabled &&
        I.clipShadows === !0 &&
        Array.isArray(I.clippingPlanes) &&
        I.clippingPlanes.length !== 0) ||
        (I.displacementMap && I.displacementScale !== 0) ||
        (I.alphaMap && I.alphaTest > 0) ||
        (I.map && I.alphaTest > 0))
    ) {
      const H = L.uuid,
        $ = I.uuid;
      let q = f[H];
      q === void 0 && ((q = {}), (f[H] = q));
      let K = q[$];
      K === void 0 &&
        ((K = L.clone()), (q[$] = K), I.addEventListener("dispose", R)),
        (L = K);
    }
    if (
      ((L.visible = I.visible),
      (L.wireframe = I.wireframe),
      O === na
        ? (L.side = I.shadowSide !== null ? I.shadowSide : I.side)
        : (L.side = I.shadowSide !== null ? I.shadowSide : m[I.side]),
      (L.alphaMap = I.alphaMap),
      (L.alphaTest = I.alphaTest),
      (L.map = I.map),
      (L.clipShadows = I.clipShadows),
      (L.clippingPlanes = I.clippingPlanes),
      (L.clipIntersection = I.clipIntersection),
      (L.displacementMap = I.displacementMap),
      (L.displacementScale = I.displacementScale),
      (L.displacementBias = I.displacementBias),
      (L.wireframeLinewidth = I.wireframeLinewidth),
      (L.linewidth = I.linewidth),
      U.isPointLight === !0 && L.isMeshDistanceMaterial === !0)
    ) {
      const H = n.properties.get(L);
      H.light = U;
    }
    return L;
  }
  function A(D, I, U, O, L) {
    if (D.visible === !1) return;
    if (
      D.layers.test(I.layers) &&
      (D.isMesh || D.isLine || D.isPoints) &&
      (D.castShadow || (D.receiveShadow && L === na)) &&
      (!D.frustumCulled || r.intersectsObject(D))
    ) {
      D.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, D.matrixWorld);
      const $ = e.update(D),
        q = D.material;
      if (Array.isArray(q)) {
        const K = $.groups;
        for (let Y = 0, ne = K.length; Y < ne; Y++) {
          const j = K[Y],
            re = q[j.materialIndex];
          if (re && re.visible) {
            const B = E(D, re, O, L);
            D.onBeforeShadow(n, D, I, U, $, B, j),
              n.renderBufferDirect(U, null, $, B, D, j),
              D.onAfterShadow(n, D, I, U, $, B, j);
          }
        }
      } else if (q.visible) {
        const K = E(D, q, O, L);
        D.onBeforeShadow(n, D, I, U, $, K, null),
          n.renderBufferDirect(U, null, $, K, D, null),
          D.onAfterShadow(n, D, I, U, $, K, null);
      }
    }
    const H = D.children;
    for (let $ = 0, q = H.length; $ < q; $++) A(H[$], I, U, O, L);
  }
  function R(D) {
    D.target.removeEventListener("dispose", R);
    for (const U in f) {
      const O = f[U],
        L = D.target.uuid;
      L in O && (O[L].dispose(), delete O[L]);
    }
  }
}
function tV(n) {
  function e() {
    let de = !1;
    const He = new En();
    let Ce = null;
    const Ue = new En(0, 0, 0, 0);
    return {
      setMask: function (it) {
        Ce !== it && !de && (n.colorMask(it, it, it, it), (Ce = it));
      },
      setLocked: function (it) {
        de = it;
      },
      setClear: function (it, mt, gt, Ot, Nt) {
        Nt === !0 && ((it *= Ot), (mt *= Ot), (gt *= Ot)),
          He.set(it, mt, gt, Ot),
          Ue.equals(He) === !1 && (n.clearColor(it, mt, gt, Ot), Ue.copy(He));
      },
      reset: function () {
        (de = !1), (Ce = null), Ue.set(-1, 0, 0, 0);
      },
    };
  }
  function t() {
    let de = !1,
      He = null,
      Ce = null,
      Ue = null;
    return {
      setTest: function (it) {
        it ? he(n.DEPTH_TEST) : ae(n.DEPTH_TEST);
      },
      setMask: function (it) {
        He !== it && !de && (n.depthMask(it), (He = it));
      },
      setFunc: function (it) {
        if (Ce !== it) {
          switch (it) {
            case W2:
              n.depthFunc(n.NEVER);
              break;
            case j2:
              n.depthFunc(n.ALWAYS);
              break;
            case $2:
              n.depthFunc(n.LESS);
              break;
            case om:
              n.depthFunc(n.LEQUAL);
              break;
            case X2:
              n.depthFunc(n.EQUAL);
              break;
            case Y2:
              n.depthFunc(n.GEQUAL);
              break;
            case q2:
              n.depthFunc(n.GREATER);
              break;
            case K2:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Ce = it;
        }
      },
      setLocked: function (it) {
        de = it;
      },
      setClear: function (it) {
        Ue !== it && (n.clearDepth(it), (Ue = it));
      },
      reset: function () {
        (de = !1), (He = null), (Ce = null), (Ue = null);
      },
    };
  }
  function r() {
    let de = !1,
      He = null,
      Ce = null,
      Ue = null,
      it = null,
      mt = null,
      gt = null,
      Ot = null,
      Nt = null;
    return {
      setTest: function (ht) {
        de || (ht ? he(n.STENCIL_TEST) : ae(n.STENCIL_TEST));
      },
      setMask: function (ht) {
        He !== ht && !de && (n.stencilMask(ht), (He = ht));
      },
      setFunc: function (ht, jt, an) {
        (Ce !== ht || Ue !== jt || it !== an) &&
          (n.stencilFunc(ht, jt, an), (Ce = ht), (Ue = jt), (it = an));
      },
      setOp: function (ht, jt, an) {
        (mt !== ht || gt !== jt || Ot !== an) &&
          (n.stencilOp(ht, jt, an), (mt = ht), (gt = jt), (Ot = an));
      },
      setLocked: function (ht) {
        de = ht;
      },
      setClear: function (ht) {
        Nt !== ht && (n.clearStencil(ht), (Nt = ht));
      },
      reset: function () {
        (de = !1),
          (He = null),
          (Ce = null),
          (Ue = null),
          (it = null),
          (mt = null),
          (gt = null),
          (Ot = null),
          (Nt = null);
      },
    };
  }
  const i = new e(),
    o = new t(),
    s = new r(),
    l = new WeakMap(),
    u = new WeakMap();
  let f = {},
    h = {},
    m = new WeakMap(),
    g = [],
    y = null,
    _ = !1,
    S = null,
    x = null,
    w = null,
    T = null,
    E = null,
    A = null,
    R = null,
    D = new St(0, 0, 0),
    I = 0,
    U = !1,
    O = null,
    L = null,
    V = null,
    H = null,
    $ = null;
  const q = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let K = !1,
    Y = 0;
  const ne = n.getParameter(n.VERSION);
  ne.indexOf("WebGL") !== -1
    ? ((Y = parseFloat(/^WebGL (\d)/.exec(ne)[1])), (K = Y >= 1))
    : ne.indexOf("OpenGL ES") !== -1 &&
      ((Y = parseFloat(/^OpenGL ES (\d)/.exec(ne)[1])), (K = Y >= 2));
  let j = null,
    re = {};
  const B = n.getParameter(n.SCISSOR_BOX),
    G = n.getParameter(n.VIEWPORT),
    te = new En().fromArray(B),
    le = new En().fromArray(G);
  function J(de, He, Ce, Ue) {
    const it = new Uint8Array(4),
      mt = n.createTexture();
    n.bindTexture(de, mt),
      n.texParameteri(de, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(de, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let gt = 0; gt < Ce; gt++)
      de === n.TEXTURE_3D || de === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(He, 0, n.RGBA, 1, 1, Ue, 0, n.RGBA, n.UNSIGNED_BYTE, it)
        : n.texImage2D(
            He + gt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            it
          );
    return mt;
  }
  const oe = {};
  (oe[n.TEXTURE_2D] = J(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (oe[n.TEXTURE_CUBE_MAP] = J(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (oe[n.TEXTURE_2D_ARRAY] = J(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (oe[n.TEXTURE_3D] = J(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    i.setClear(0, 0, 0, 1),
    o.setClear(1),
    s.setClear(0),
    he(n.DEPTH_TEST),
    o.setFunc(om),
    ke(!1),
    Pe(R1),
    he(n.CULL_FACE),
    _e(Al);
  function he(de) {
    f[de] !== !0 && (n.enable(de), (f[de] = !0));
  }
  function ae(de) {
    f[de] !== !1 && (n.disable(de), (f[de] = !1));
  }
  function ue(de, He) {
    return h[de] !== He
      ? (n.bindFramebuffer(de, He),
        (h[de] = He),
        de === n.DRAW_FRAMEBUFFER && (h[n.FRAMEBUFFER] = He),
        de === n.FRAMEBUFFER && (h[n.DRAW_FRAMEBUFFER] = He),
        !0)
      : !1;
  }
  function Ee(de, He) {
    let Ce = g,
      Ue = !1;
    if (de) {
      (Ce = m.get(He)), Ce === void 0 && ((Ce = []), m.set(He, Ce));
      const it = de.textures;
      if (Ce.length !== it.length || Ce[0] !== n.COLOR_ATTACHMENT0) {
        for (let mt = 0, gt = it.length; mt < gt; mt++)
          Ce[mt] = n.COLOR_ATTACHMENT0 + mt;
        (Ce.length = it.length), (Ue = !0);
      }
    } else Ce[0] !== n.BACK && ((Ce[0] = n.BACK), (Ue = !0));
    Ue && n.drawBuffers(Ce);
  }
  function Ne(de) {
    return y !== de ? (n.useProgram(de), (y = de), !0) : !1;
  }
  const Ae = {
    [Lu]: n.FUNC_ADD,
    [C2]: n.FUNC_SUBTRACT,
    [A2]: n.FUNC_REVERSE_SUBTRACT,
  };
  (Ae[R2] = n.MIN), (Ae[P2] = n.MAX);
  const W = {
    [I2]: n.ZERO,
    [L2]: n.ONE,
    [D2]: n.SRC_COLOR,
    [c0]: n.SRC_ALPHA,
    [z2]: n.SRC_ALPHA_SATURATE,
    [U2]: n.DST_COLOR,
    [O2]: n.DST_ALPHA,
    [k2]: n.ONE_MINUS_SRC_COLOR,
    [f0]: n.ONE_MINUS_SRC_ALPHA,
    [F2]: n.ONE_MINUS_DST_COLOR,
    [N2]: n.ONE_MINUS_DST_ALPHA,
    [B2]: n.CONSTANT_COLOR,
    [V2]: n.ONE_MINUS_CONSTANT_COLOR,
    [H2]: n.CONSTANT_ALPHA,
    [G2]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function _e(de, He, Ce, Ue, it, mt, gt, Ot, Nt, ht) {
    if (de === Al) {
      _ === !0 && (ae(n.BLEND), (_ = !1));
      return;
    }
    if ((_ === !1 && (he(n.BLEND), (_ = !0)), de !== T2)) {
      if (de !== S || ht !== U) {
        if (
          ((x !== Lu || E !== Lu) &&
            (n.blendEquation(n.FUNC_ADD), (x = Lu), (E = Lu)),
          ht)
        )
          switch (de) {
            case Zc:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case P1:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case I1:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case L1:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", de);
              break;
          }
        else
          switch (de) {
            case Zc:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case P1:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case I1:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case L1:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", de);
              break;
          }
        (w = null),
          (T = null),
          (A = null),
          (R = null),
          D.set(0, 0, 0),
          (I = 0),
          (S = de),
          (U = ht);
      }
      return;
    }
    (it = it || He),
      (mt = mt || Ce),
      (gt = gt || Ue),
      (He !== x || it !== E) &&
        (n.blendEquationSeparate(Ae[He], Ae[it]), (x = He), (E = it)),
      (Ce !== w || Ue !== T || mt !== A || gt !== R) &&
        (n.blendFuncSeparate(W[Ce], W[Ue], W[mt], W[gt]),
        (w = Ce),
        (T = Ue),
        (A = mt),
        (R = gt)),
      (Ot.equals(D) === !1 || Nt !== I) &&
        (n.blendColor(Ot.r, Ot.g, Ot.b, Nt), D.copy(Ot), (I = Nt)),
      (S = de),
      (U = !1);
  }
  function Te(de, He) {
    de.side === Es ? ae(n.CULL_FACE) : he(n.CULL_FACE);
    let Ce = de.side === Zi;
    He && (Ce = !Ce),
      ke(Ce),
      de.blending === Zc && de.transparent === !1
        ? _e(Al)
        : _e(
            de.blending,
            de.blendEquation,
            de.blendSrc,
            de.blendDst,
            de.blendEquationAlpha,
            de.blendSrcAlpha,
            de.blendDstAlpha,
            de.blendColor,
            de.blendAlpha,
            de.premultipliedAlpha
          ),
      o.setFunc(de.depthFunc),
      o.setTest(de.depthTest),
      o.setMask(de.depthWrite),
      i.setMask(de.colorWrite);
    const Ue = de.stencilWrite;
    s.setTest(Ue),
      Ue &&
        (s.setMask(de.stencilWriteMask),
        s.setFunc(de.stencilFunc, de.stencilRef, de.stencilFuncMask),
        s.setOp(de.stencilFail, de.stencilZFail, de.stencilZPass)),
      Le(de.polygonOffset, de.polygonOffsetFactor, de.polygonOffsetUnits),
      de.alphaToCoverage === !0
        ? he(n.SAMPLE_ALPHA_TO_COVERAGE)
        : ae(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ke(de) {
    O !== de && (de ? n.frontFace(n.CW) : n.frontFace(n.CCW), (O = de));
  }
  function Pe(de) {
    de !== M2
      ? (he(n.CULL_FACE),
        de !== L &&
          (de === R1
            ? n.cullFace(n.BACK)
            : de === b2
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : ae(n.CULL_FACE),
      (L = de);
  }
  function rt(de) {
    de !== V && (K && n.lineWidth(de), (V = de));
  }
  function Le(de, He, Ce) {
    de
      ? (he(n.POLYGON_OFFSET_FILL),
        (H !== He || $ !== Ce) && (n.polygonOffset(He, Ce), (H = He), ($ = Ce)))
      : ae(n.POLYGON_OFFSET_FILL);
  }
  function Xe(de) {
    de ? he(n.SCISSOR_TEST) : ae(n.SCISSOR_TEST);
  }
  function Z(de) {
    de === void 0 && (de = n.TEXTURE0 + q - 1),
      j !== de && (n.activeTexture(de), (j = de));
  }
  function F(de, He, Ce) {
    Ce === void 0 && (j === null ? (Ce = n.TEXTURE0 + q - 1) : (Ce = j));
    let Ue = re[Ce];
    Ue === void 0 && ((Ue = { type: void 0, texture: void 0 }), (re[Ce] = Ue)),
      (Ue.type !== de || Ue.texture !== He) &&
        (j !== Ce && (n.activeTexture(Ce), (j = Ce)),
        n.bindTexture(de, He || oe[de]),
        (Ue.type = de),
        (Ue.texture = He));
  }
  function me() {
    const de = re[j];
    de !== void 0 &&
      de.type !== void 0 &&
      (n.bindTexture(de.type, null), (de.type = void 0), (de.texture = void 0));
  }
  function xe() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function ye() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function Me() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function at() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function Fe() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function ze() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function We() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function Ye() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function nt() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function yt() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function $e(de) {
    te.equals(de) === !1 && (n.scissor(de.x, de.y, de.z, de.w), te.copy(de));
  }
  function qe(de) {
    le.equals(de) === !1 && (n.viewport(de.x, de.y, de.z, de.w), le.copy(de));
  }
  function et(de, He) {
    let Ce = u.get(He);
    Ce === void 0 && ((Ce = new WeakMap()), u.set(He, Ce));
    let Ue = Ce.get(de);
    Ue === void 0 &&
      ((Ue = n.getUniformBlockIndex(He, de.name)), Ce.set(de, Ue));
  }
  function ce(de, He) {
    const Ue = u.get(He).get(de);
    l.get(He) !== Ue &&
      (n.uniformBlockBinding(He, Ue, de.__bindingPointIndex), l.set(He, Ue));
  }
  function Je() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (f = {}),
      (j = null),
      (re = {}),
      (h = {}),
      (m = new WeakMap()),
      (g = []),
      (y = null),
      (_ = !1),
      (S = null),
      (x = null),
      (w = null),
      (T = null),
      (E = null),
      (A = null),
      (R = null),
      (D = new St(0, 0, 0)),
      (I = 0),
      (U = !1),
      (O = null),
      (L = null),
      (V = null),
      (H = null),
      ($ = null),
      te.set(0, 0, n.canvas.width, n.canvas.height),
      le.set(0, 0, n.canvas.width, n.canvas.height),
      i.reset(),
      o.reset(),
      s.reset();
  }
  return {
    buffers: { color: i, depth: o, stencil: s },
    enable: he,
    disable: ae,
    bindFramebuffer: ue,
    drawBuffers: Ee,
    useProgram: Ne,
    setBlending: _e,
    setMaterial: Te,
    setFlipSided: ke,
    setCullFace: Pe,
    setLineWidth: rt,
    setPolygonOffset: Le,
    setScissorTest: Xe,
    activeTexture: Z,
    bindTexture: F,
    unbindTexture: me,
    compressedTexImage2D: xe,
    compressedTexImage3D: ye,
    texImage2D: nt,
    texImage3D: yt,
    updateUBOMapping: et,
    uniformBlockBinding: ce,
    texStorage2D: We,
    texStorage3D: Ye,
    texSubImage2D: Me,
    texSubImage3D: at,
    compressedTexSubImage2D: Fe,
    compressedTexSubImage3D: ze,
    scissor: $e,
    viewport: qe,
    reset: Je,
  };
}
function nV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  );
}
function rV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  );
}
function iV(n) {
  return (
    (n.repeat.x = 1), (n.repeat.y = 1), (n.offset.x = 0), (n.offset.y = 0), n
  );
}
function F1(n, e, t, r) {
  const i = oV(r);
  switch (t) {
    case DS:
      return n * e;
    case OS:
      return n * e;
    case NS:
      return n * e * 2;
    case vy:
      return ((n * e) / i.components) * i.byteLength;
    case km:
      return ((n * e) / i.components) * i.byteLength;
    case US:
      return ((n * e * 2) / i.components) * i.byteLength;
    case yy:
      return ((n * e * 2) / i.components) * i.byteLength;
    case kS:
      return ((n * e * 3) / i.components) * i.byteLength;
    case Ki:
      return ((n * e * 4) / i.components) * i.byteLength;
    case xy:
      return ((n * e * 4) / i.components) * i.byteLength;
    case Vp:
    case Hp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Gp:
    case Wp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case h0:
    case m0:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case d0:
    case p0:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case g0:
    case v0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case y0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case x0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case _0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case S0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case w0:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case M0:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case b0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case E0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case T0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case C0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case A0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case R0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case P0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case I0:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case L0:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case jp:
    case D0:
    case k0:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case FS:
    case O0:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case N0:
    case U0:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function oV(n) {
  switch (n) {
    case sa:
    case PS:
      return { byteLength: 1, components: 1 };
    case uh:
    case IS:
    case yh:
      return { byteLength: 2, components: 1 };
    case my:
    case gy:
      return { byteLength: 2, components: 4 };
    case Ll:
    case py:
    case ko:
      return { byteLength: 4, components: 1 };
    case LS:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
const sV = { contain: nV, cover: rV, fill: iV, getByteLength: F1 };
function aV(n, e, t, r, i, o, s) {
  const l = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    u =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    f = new tt(),
    h = new WeakMap();
  let m;
  const g = new WeakMap();
  let y = !1;
  try {
    y =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function _(Z, F) {
    return y ? new OffscreenCanvas(Z, F) : vm("canvas");
  }
  function S(Z, F, me) {
    let xe = 1;
    const ye = Xe(Z);
    if (
      ((ye.width > me || ye.height > me) &&
        (xe = me / Math.max(ye.width, ye.height)),
      xe < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && Z instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && Z instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && Z instanceof VideoFrame)
      ) {
        const Me = Math.floor(xe * ye.width),
          at = Math.floor(xe * ye.height);
        m === void 0 && (m = _(Me, at));
        const Fe = F ? _(Me, at) : m;
        return (
          (Fe.width = Me),
          (Fe.height = at),
          Fe.getContext("2d").drawImage(Z, 0, 0, Me, at),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              ye.width +
              "x" +
              ye.height +
              ") to (" +
              Me +
              "x" +
              at +
              ")."
          ),
          Fe
        );
      } else
        return (
          "data" in Z &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                ye.width +
                "x" +
                ye.height +
                ")."
            ),
          Z
        );
    return Z;
  }
  function x(Z) {
    return Z.generateMipmaps && Z.minFilter !== yi && Z.minFilter !== br;
  }
  function w(Z) {
    n.generateMipmap(Z);
  }
  function T(Z, F, me, xe, ye = !1) {
    if (Z !== null) {
      if (n[Z] !== void 0) return n[Z];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          Z +
          "'"
      );
    }
    let Me = F;
    if (
      (F === n.RED &&
        (me === n.FLOAT && (Me = n.R32F),
        me === n.HALF_FLOAT && (Me = n.R16F),
        me === n.UNSIGNED_BYTE && (Me = n.R8)),
      F === n.RED_INTEGER &&
        (me === n.UNSIGNED_BYTE && (Me = n.R8UI),
        me === n.UNSIGNED_SHORT && (Me = n.R16UI),
        me === n.UNSIGNED_INT && (Me = n.R32UI),
        me === n.BYTE && (Me = n.R8I),
        me === n.SHORT && (Me = n.R16I),
        me === n.INT && (Me = n.R32I)),
      F === n.RG &&
        (me === n.FLOAT && (Me = n.RG32F),
        me === n.HALF_FLOAT && (Me = n.RG16F),
        me === n.UNSIGNED_BYTE && (Me = n.RG8)),
      F === n.RG_INTEGER &&
        (me === n.UNSIGNED_BYTE && (Me = n.RG8UI),
        me === n.UNSIGNED_SHORT && (Me = n.RG16UI),
        me === n.UNSIGNED_INT && (Me = n.RG32UI),
        me === n.BYTE && (Me = n.RG8I),
        me === n.SHORT && (Me = n.RG16I),
        me === n.INT && (Me = n.RG32I)),
      F === n.RGB && me === n.UNSIGNED_INT_5_9_9_9_REV && (Me = n.RGB9_E5),
      F === n.RGBA)
    ) {
      const at = ye ? dm : yn.getTransfer(xe);
      me === n.FLOAT && (Me = n.RGBA32F),
        me === n.HALF_FLOAT && (Me = n.RGBA16F),
        me === n.UNSIGNED_BYTE && (Me = at === $n ? n.SRGB8_ALPHA8 : n.RGBA8),
        me === n.UNSIGNED_SHORT_4_4_4_4 && (Me = n.RGBA4),
        me === n.UNSIGNED_SHORT_5_5_5_1 && (Me = n.RGB5_A1);
    }
    return (
      (Me === n.R16F ||
        Me === n.R32F ||
        Me === n.RG16F ||
        Me === n.RG32F ||
        Me === n.RGBA16F ||
        Me === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Me
    );
  }
  function E(Z, F) {
    let me;
    return (
      Z
        ? F === null || F === Ll || F === af
          ? (me = n.DEPTH24_STENCIL8)
          : F === ko
          ? (me = n.DEPTH32F_STENCIL8)
          : F === uh &&
            ((me = n.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : F === null || F === Ll || F === af
        ? (me = n.DEPTH_COMPONENT24)
        : F === ko
        ? (me = n.DEPTH_COMPONENT32F)
        : F === uh && (me = n.DEPTH_COMPONENT16),
      me
    );
  }
  function A(Z, F) {
    return x(Z) === !0 ||
      (Z.isFramebufferTexture && Z.minFilter !== yi && Z.minFilter !== br)
      ? Math.log2(Math.max(F.width, F.height)) + 1
      : Z.mipmaps !== void 0 && Z.mipmaps.length > 0
      ? Z.mipmaps.length
      : Z.isCompressedTexture && Array.isArray(Z.image)
      ? F.mipmaps.length
      : 1;
  }
  function R(Z) {
    const F = Z.target;
    F.removeEventListener("dispose", R), I(F), F.isVideoTexture && h.delete(F);
  }
  function D(Z) {
    const F = Z.target;
    F.removeEventListener("dispose", D), O(F);
  }
  function I(Z) {
    const F = r.get(Z);
    if (F.__webglInit === void 0) return;
    const me = Z.source,
      xe = g.get(me);
    if (xe) {
      const ye = xe[F.__cacheKey];
      ye.usedTimes--,
        ye.usedTimes === 0 && U(Z),
        Object.keys(xe).length === 0 && g.delete(me);
    }
    r.remove(Z);
  }
  function U(Z) {
    const F = r.get(Z);
    n.deleteTexture(F.__webglTexture);
    const me = Z.source,
      xe = g.get(me);
    delete xe[F.__cacheKey], s.memory.textures--;
  }
  function O(Z) {
    const F = r.get(Z);
    if ((Z.depthTexture && Z.depthTexture.dispose(), Z.isWebGLCubeRenderTarget))
      for (let xe = 0; xe < 6; xe++) {
        if (Array.isArray(F.__webglFramebuffer[xe]))
          for (let ye = 0; ye < F.__webglFramebuffer[xe].length; ye++)
            n.deleteFramebuffer(F.__webglFramebuffer[xe][ye]);
        else n.deleteFramebuffer(F.__webglFramebuffer[xe]);
        F.__webglDepthbuffer && n.deleteRenderbuffer(F.__webglDepthbuffer[xe]);
      }
    else {
      if (Array.isArray(F.__webglFramebuffer))
        for (let xe = 0; xe < F.__webglFramebuffer.length; xe++)
          n.deleteFramebuffer(F.__webglFramebuffer[xe]);
      else n.deleteFramebuffer(F.__webglFramebuffer);
      if (
        (F.__webglDepthbuffer && n.deleteRenderbuffer(F.__webglDepthbuffer),
        F.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(F.__webglMultisampledFramebuffer),
        F.__webglColorRenderbuffer)
      )
        for (let xe = 0; xe < F.__webglColorRenderbuffer.length; xe++)
          F.__webglColorRenderbuffer[xe] &&
            n.deleteRenderbuffer(F.__webglColorRenderbuffer[xe]);
      F.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(F.__webglDepthRenderbuffer);
    }
    const me = Z.textures;
    for (let xe = 0, ye = me.length; xe < ye; xe++) {
      const Me = r.get(me[xe]);
      Me.__webglTexture &&
        (n.deleteTexture(Me.__webglTexture), s.memory.textures--),
        r.remove(me[xe]);
    }
    r.remove(Z);
  }
  let L = 0;
  function V() {
    L = 0;
  }
  function H() {
    const Z = L;
    return (
      Z >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            Z +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (L += 1),
      Z
    );
  }
  function $(Z) {
    const F = [];
    return (
      F.push(Z.wrapS),
      F.push(Z.wrapT),
      F.push(Z.wrapR || 0),
      F.push(Z.magFilter),
      F.push(Z.minFilter),
      F.push(Z.anisotropy),
      F.push(Z.internalFormat),
      F.push(Z.format),
      F.push(Z.type),
      F.push(Z.generateMipmaps),
      F.push(Z.premultiplyAlpha),
      F.push(Z.flipY),
      F.push(Z.unpackAlignment),
      F.push(Z.colorSpace),
      F.join()
    );
  }
  function q(Z, F) {
    const me = r.get(Z);
    if (
      (Z.isVideoTexture && rt(Z),
      Z.isRenderTargetTexture === !1 &&
        Z.version > 0 &&
        me.__version !== Z.version)
    ) {
      const xe = Z.image;
      if (xe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (xe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        le(me, Z, F);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, me.__webglTexture, n.TEXTURE0 + F);
  }
  function K(Z, F) {
    const me = r.get(Z);
    if (Z.version > 0 && me.__version !== Z.version) {
      le(me, Z, F);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, me.__webglTexture, n.TEXTURE0 + F);
  }
  function Y(Z, F) {
    const me = r.get(Z);
    if (Z.version > 0 && me.__version !== Z.version) {
      le(me, Z, F);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, me.__webglTexture, n.TEXTURE0 + F);
  }
  function ne(Z, F) {
    const me = r.get(Z);
    if (Z.version > 0 && me.__version !== Z.version) {
      J(me, Z, F);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, me.__webglTexture, n.TEXTURE0 + F);
  }
  const j = { [lm]: n.REPEAT, [Cs]: n.CLAMP_TO_EDGE, [um]: n.MIRRORED_REPEAT },
    re = {
      [yi]: n.NEAREST,
      [RS]: n.NEAREST_MIPMAP_NEAREST,
      [Xd]: n.NEAREST_MIPMAP_LINEAR,
      [br]: n.LINEAR,
      [Bp]: n.LINEAR_MIPMAP_NEAREST,
      [Na]: n.LINEAR_MIPMAP_LINEAR,
    },
    B = {
      [fA]: n.NEVER,
      [vA]: n.ALWAYS,
      [dA]: n.LESS,
      [VS]: n.LEQUAL,
      [hA]: n.EQUAL,
      [gA]: n.GEQUAL,
      [pA]: n.GREATER,
      [mA]: n.NOTEQUAL,
    };
  function G(Z, F) {
    if (
      (F.type === ko &&
        e.has("OES_texture_float_linear") === !1 &&
        (F.magFilter === br ||
          F.magFilter === Bp ||
          F.magFilter === Xd ||
          F.magFilter === Na ||
          F.minFilter === br ||
          F.minFilter === Bp ||
          F.minFilter === Xd ||
          F.minFilter === Na) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      n.texParameteri(Z, n.TEXTURE_WRAP_S, j[F.wrapS]),
      n.texParameteri(Z, n.TEXTURE_WRAP_T, j[F.wrapT]),
      (Z === n.TEXTURE_3D || Z === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(Z, n.TEXTURE_WRAP_R, j[F.wrapR]),
      n.texParameteri(Z, n.TEXTURE_MAG_FILTER, re[F.magFilter]),
      n.texParameteri(Z, n.TEXTURE_MIN_FILTER, re[F.minFilter]),
      F.compareFunction &&
        (n.texParameteri(Z, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(Z, n.TEXTURE_COMPARE_FUNC, B[F.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        F.magFilter === yi ||
        (F.minFilter !== Xd && F.minFilter !== Na) ||
        (F.type === ko && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (F.anisotropy > 1 || r.get(F).__currentAnisotropy) {
        const me = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(
          Z,
          me.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(F.anisotropy, i.getMaxAnisotropy())
        ),
          (r.get(F).__currentAnisotropy = F.anisotropy);
      }
    }
  }
  function te(Z, F) {
    let me = !1;
    Z.__webglInit === void 0 &&
      ((Z.__webglInit = !0), F.addEventListener("dispose", R));
    const xe = F.source;
    let ye = g.get(xe);
    ye === void 0 && ((ye = {}), g.set(xe, ye));
    const Me = $(F);
    if (Me !== Z.__cacheKey) {
      ye[Me] === void 0 &&
        ((ye[Me] = { texture: n.createTexture(), usedTimes: 0 }),
        s.memory.textures++,
        (me = !0)),
        ye[Me].usedTimes++;
      const at = ye[Z.__cacheKey];
      at !== void 0 &&
        (ye[Z.__cacheKey].usedTimes--, at.usedTimes === 0 && U(F)),
        (Z.__cacheKey = Me),
        (Z.__webglTexture = ye[Me].texture);
    }
    return me;
  }
  function le(Z, F, me) {
    let xe = n.TEXTURE_2D;
    (F.isDataArrayTexture || F.isCompressedArrayTexture) &&
      (xe = n.TEXTURE_2D_ARRAY),
      F.isData3DTexture && (xe = n.TEXTURE_3D);
    const ye = te(Z, F),
      Me = F.source;
    t.bindTexture(xe, Z.__webglTexture, n.TEXTURE0 + me);
    const at = r.get(Me);
    if (Me.version !== at.__version || ye === !0) {
      t.activeTexture(n.TEXTURE0 + me);
      const Fe = yn.getPrimaries(yn.workingColorSpace),
        ze = F.colorSpace === bl ? null : yn.getPrimaries(F.colorSpace),
        We =
          F.colorSpace === bl || Fe === ze ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, F.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, F.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, F.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, We);
      let Ye = S(F.image, !1, i.maxTextureSize);
      Ye = Le(F, Ye);
      const nt = o.convert(F.format, F.colorSpace),
        yt = o.convert(F.type);
      let $e = T(F.internalFormat, nt, yt, F.colorSpace, F.isVideoTexture);
      G(xe, F);
      let qe;
      const et = F.mipmaps,
        ce = F.isVideoTexture !== !0,
        Je = at.__version === void 0 || ye === !0,
        de = Me.dataReady,
        He = A(F, Ye);
      if (F.isDepthTexture)
        ($e = E(F.format === lf, F.type)),
          Je &&
            (ce
              ? t.texStorage2D(n.TEXTURE_2D, 1, $e, Ye.width, Ye.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  $e,
                  Ye.width,
                  Ye.height,
                  0,
                  nt,
                  yt,
                  null
                ));
      else if (F.isDataTexture)
        if (et.length > 0) {
          ce &&
            Je &&
            t.texStorage2D(n.TEXTURE_2D, He, $e, et[0].width, et[0].height);
          for (let Ce = 0, Ue = et.length; Ce < Ue; Ce++)
            (qe = et[Ce]),
              ce
                ? de &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Ce,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    nt,
                    yt,
                    qe.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Ce,
                    $e,
                    qe.width,
                    qe.height,
                    0,
                    nt,
                    yt,
                    qe.data
                  );
          F.generateMipmaps = !1;
        } else
          ce
            ? (Je && t.texStorage2D(n.TEXTURE_2D, He, $e, Ye.width, Ye.height),
              de &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Ye.width,
                  Ye.height,
                  nt,
                  yt,
                  Ye.data
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                $e,
                Ye.width,
                Ye.height,
                0,
                nt,
                yt,
                Ye.data
              );
      else if (F.isCompressedTexture)
        if (F.isCompressedArrayTexture) {
          ce &&
            Je &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              He,
              $e,
              et[0].width,
              et[0].height,
              Ye.depth
            );
          for (let Ce = 0, Ue = et.length; Ce < Ue; Ce++)
            if (((qe = et[Ce]), F.format !== Ki))
              if (nt !== null)
                if (ce) {
                  if (de)
                    if (F.layerUpdates.size > 0) {
                      const it = F1(qe.width, qe.height, F.format, F.type);
                      for (const mt of F.layerUpdates) {
                        const gt = qe.data.subarray(
                          (mt * it) / qe.data.BYTES_PER_ELEMENT,
                          ((mt + 1) * it) / qe.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Ce,
                          0,
                          0,
                          mt,
                          qe.width,
                          qe.height,
                          1,
                          nt,
                          gt,
                          0,
                          0
                        );
                      }
                      F.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Ce,
                        0,
                        0,
                        0,
                        qe.width,
                        qe.height,
                        Ye.depth,
                        nt,
                        qe.data,
                        0,
                        0
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ce,
                    $e,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    0,
                    qe.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              ce
                ? de &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ce,
                    0,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    nt,
                    yt,
                    qe.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ce,
                    $e,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    0,
                    nt,
                    yt,
                    qe.data
                  );
        } else {
          ce &&
            Je &&
            t.texStorage2D(n.TEXTURE_2D, He, $e, et[0].width, et[0].height);
          for (let Ce = 0, Ue = et.length; Ce < Ue; Ce++)
            (qe = et[Ce]),
              F.format !== Ki
                ? nt !== null
                  ? ce
                    ? de &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Ce,
                        0,
                        0,
                        qe.width,
                        qe.height,
                        nt,
                        qe.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Ce,
                        $e,
                        qe.width,
                        qe.height,
                        0,
                        qe.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ce
                ? de &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Ce,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    nt,
                    yt,
                    qe.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Ce,
                    $e,
                    qe.width,
                    qe.height,
                    0,
                    nt,
                    yt,
                    qe.data
                  );
        }
      else if (F.isDataArrayTexture)
        if (ce) {
          if (
            (Je &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                He,
                $e,
                Ye.width,
                Ye.height,
                Ye.depth
              ),
            de)
          )
            if (F.layerUpdates.size > 0) {
              const Ce = F1(Ye.width, Ye.height, F.format, F.type);
              for (const Ue of F.layerUpdates) {
                const it = Ye.data.subarray(
                  (Ue * Ce) / Ye.data.BYTES_PER_ELEMENT,
                  ((Ue + 1) * Ce) / Ye.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Ue,
                  Ye.width,
                  Ye.height,
                  1,
                  nt,
                  yt,
                  it
                );
              }
              F.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ye.width,
                Ye.height,
                Ye.depth,
                nt,
                yt,
                Ye.data
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            $e,
            Ye.width,
            Ye.height,
            Ye.depth,
            0,
            nt,
            yt,
            Ye.data
          );
      else if (F.isData3DTexture)
        ce
          ? (Je &&
              t.texStorage3D(
                n.TEXTURE_3D,
                He,
                $e,
                Ye.width,
                Ye.height,
                Ye.depth
              ),
            de &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ye.width,
                Ye.height,
                Ye.depth,
                nt,
                yt,
                Ye.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              $e,
              Ye.width,
              Ye.height,
              Ye.depth,
              0,
              nt,
              yt,
              Ye.data
            );
      else if (F.isFramebufferTexture) {
        if (Je)
          if (ce) t.texStorage2D(n.TEXTURE_2D, He, $e, Ye.width, Ye.height);
          else {
            let Ce = Ye.width,
              Ue = Ye.height;
            for (let it = 0; it < He; it++)
              t.texImage2D(n.TEXTURE_2D, it, $e, Ce, Ue, 0, nt, yt, null),
                (Ce >>= 1),
                (Ue >>= 1);
          }
      } else if (et.length > 0) {
        if (ce && Je) {
          const Ce = Xe(et[0]);
          t.texStorage2D(n.TEXTURE_2D, He, $e, Ce.width, Ce.height);
        }
        for (let Ce = 0, Ue = et.length; Ce < Ue; Ce++)
          (qe = et[Ce]),
            ce
              ? de && t.texSubImage2D(n.TEXTURE_2D, Ce, 0, 0, nt, yt, qe)
              : t.texImage2D(n.TEXTURE_2D, Ce, $e, nt, yt, qe);
        F.generateMipmaps = !1;
      } else if (ce) {
        if (Je) {
          const Ce = Xe(Ye);
          t.texStorage2D(n.TEXTURE_2D, He, $e, Ce.width, Ce.height);
        }
        de && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, nt, yt, Ye);
      } else t.texImage2D(n.TEXTURE_2D, 0, $e, nt, yt, Ye);
      x(F) && w(xe), (at.__version = Me.version), F.onUpdate && F.onUpdate(F);
    }
    Z.__version = F.version;
  }
  function J(Z, F, me) {
    if (F.image.length !== 6) return;
    const xe = te(Z, F),
      ye = F.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, Z.__webglTexture, n.TEXTURE0 + me);
    const Me = r.get(ye);
    if (ye.version !== Me.__version || xe === !0) {
      t.activeTexture(n.TEXTURE0 + me);
      const at = yn.getPrimaries(yn.workingColorSpace),
        Fe = F.colorSpace === bl ? null : yn.getPrimaries(F.colorSpace),
        ze =
          F.colorSpace === bl || at === Fe ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, F.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, F.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, F.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ze);
      const We = F.isCompressedTexture || F.image[0].isCompressedTexture,
        Ye = F.image[0] && F.image[0].isDataTexture,
        nt = [];
      for (let Ue = 0; Ue < 6; Ue++)
        !We && !Ye
          ? (nt[Ue] = S(F.image[Ue], !0, i.maxCubemapSize))
          : (nt[Ue] = Ye ? F.image[Ue].image : F.image[Ue]),
          (nt[Ue] = Le(F, nt[Ue]));
      const yt = nt[0],
        $e = o.convert(F.format, F.colorSpace),
        qe = o.convert(F.type),
        et = T(F.internalFormat, $e, qe, F.colorSpace),
        ce = F.isVideoTexture !== !0,
        Je = Me.__version === void 0 || xe === !0,
        de = ye.dataReady;
      let He = A(F, yt);
      G(n.TEXTURE_CUBE_MAP, F);
      let Ce;
      if (We) {
        ce &&
          Je &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, He, et, yt.width, yt.height);
        for (let Ue = 0; Ue < 6; Ue++) {
          Ce = nt[Ue].mipmaps;
          for (let it = 0; it < Ce.length; it++) {
            const mt = Ce[it];
            F.format !== Ki
              ? $e !== null
                ? ce
                  ? de &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                      it,
                      0,
                      0,
                      mt.width,
                      mt.height,
                      $e,
                      mt.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                      it,
                      et,
                      mt.width,
                      mt.height,
                      0,
                      mt.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : ce
              ? de &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  it,
                  0,
                  0,
                  mt.width,
                  mt.height,
                  $e,
                  qe,
                  mt.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  it,
                  et,
                  mt.width,
                  mt.height,
                  0,
                  $e,
                  qe,
                  mt.data
                );
          }
        }
      } else {
        if (((Ce = F.mipmaps), ce && Je)) {
          Ce.length > 0 && He++;
          const Ue = Xe(nt[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, He, et, Ue.width, Ue.height);
        }
        for (let Ue = 0; Ue < 6; Ue++)
          if (Ye) {
            ce
              ? de &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  0,
                  0,
                  nt[Ue].width,
                  nt[Ue].height,
                  $e,
                  qe,
                  nt[Ue].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  et,
                  nt[Ue].width,
                  nt[Ue].height,
                  0,
                  $e,
                  qe,
                  nt[Ue].data
                );
            for (let it = 0; it < Ce.length; it++) {
              const gt = Ce[it].image[Ue].image;
              ce
                ? de &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    0,
                    0,
                    gt.width,
                    gt.height,
                    $e,
                    qe,
                    gt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    et,
                    gt.width,
                    gt.height,
                    0,
                    $e,
                    qe,
                    gt.data
                  );
            }
          } else {
            ce
              ? de &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  0,
                  0,
                  $e,
                  qe,
                  nt[Ue]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  et,
                  $e,
                  qe,
                  nt[Ue]
                );
            for (let it = 0; it < Ce.length; it++) {
              const mt = Ce[it];
              ce
                ? de &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    0,
                    0,
                    $e,
                    qe,
                    mt.image[Ue]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    et,
                    $e,
                    qe,
                    mt.image[Ue]
                  );
            }
          }
      }
      x(F) && w(n.TEXTURE_CUBE_MAP),
        (Me.__version = ye.version),
        F.onUpdate && F.onUpdate(F);
    }
    Z.__version = F.version;
  }
  function oe(Z, F, me, xe, ye, Me) {
    const at = o.convert(me.format, me.colorSpace),
      Fe = o.convert(me.type),
      ze = T(me.internalFormat, at, Fe, me.colorSpace);
    if (!r.get(F).__hasExternalTextures) {
      const Ye = Math.max(1, F.width >> Me),
        nt = Math.max(1, F.height >> Me);
      ye === n.TEXTURE_3D || ye === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(ye, Me, ze, Ye, nt, F.depth, 0, at, Fe, null)
        : t.texImage2D(ye, Me, ze, Ye, nt, 0, at, Fe, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, Z),
      Pe(F)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            xe,
            ye,
            r.get(me).__webglTexture,
            0,
            ke(F)
          )
        : (ye === n.TEXTURE_2D ||
            (ye >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              ye <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            xe,
            ye,
            r.get(me).__webglTexture,
            Me
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function he(Z, F, me) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, Z), F.depthBuffer)) {
      const xe = F.depthTexture,
        ye = xe && xe.isDepthTexture ? xe.type : null,
        Me = E(F.stencilBuffer, ye),
        at = F.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Fe = ke(F);
      Pe(F)
        ? l.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Fe,
            Me,
            F.width,
            F.height
          )
        : me
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Fe,
            Me,
            F.width,
            F.height
          )
        : n.renderbufferStorage(n.RENDERBUFFER, Me, F.width, F.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, at, n.RENDERBUFFER, Z);
    } else {
      const xe = F.textures;
      for (let ye = 0; ye < xe.length; ye++) {
        const Me = xe[ye],
          at = o.convert(Me.format, Me.colorSpace),
          Fe = o.convert(Me.type),
          ze = T(Me.internalFormat, at, Fe, Me.colorSpace),
          We = ke(F);
        me && Pe(F) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              We,
              ze,
              F.width,
              F.height
            )
          : Pe(F)
          ? l.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              We,
              ze,
              F.width,
              F.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, ze, F.width, F.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function ae(Z, F) {
    if (F && F.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, Z),
      !(F.depthTexture && F.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(F.depthTexture).__webglTexture ||
      F.depthTexture.image.width !== F.width ||
      F.depthTexture.image.height !== F.height) &&
      ((F.depthTexture.image.width = F.width),
      (F.depthTexture.image.height = F.height),
      (F.depthTexture.needsUpdate = !0)),
      q(F.depthTexture, 0);
    const xe = r.get(F.depthTexture).__webglTexture,
      ye = ke(F);
    if (F.depthTexture.format === Jc)
      Pe(F)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0,
            ye
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0
          );
    else if (F.depthTexture.format === lf)
      Pe(F)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0,
            ye
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function ue(Z) {
    const F = r.get(Z),
      me = Z.isWebGLCubeRenderTarget === !0;
    if (Z.depthTexture && !F.__autoAllocateDepthBuffer) {
      if (me)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      ae(F.__webglFramebuffer, Z);
    } else if (me) {
      F.__webglDepthbuffer = [];
      for (let xe = 0; xe < 6; xe++)
        t.bindFramebuffer(n.FRAMEBUFFER, F.__webglFramebuffer[xe]),
          (F.__webglDepthbuffer[xe] = n.createRenderbuffer()),
          he(F.__webglDepthbuffer[xe], Z, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, F.__webglFramebuffer),
        (F.__webglDepthbuffer = n.createRenderbuffer()),
        he(F.__webglDepthbuffer, Z, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ee(Z, F, me) {
    const xe = r.get(Z);
    F !== void 0 &&
      oe(
        xe.__webglFramebuffer,
        Z,
        Z.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      me !== void 0 && ue(Z);
  }
  function Ne(Z) {
    const F = Z.texture,
      me = r.get(Z),
      xe = r.get(F);
    Z.addEventListener("dispose", D);
    const ye = Z.textures,
      Me = Z.isWebGLCubeRenderTarget === !0,
      at = ye.length > 1;
    if (
      (at ||
        (xe.__webglTexture === void 0 &&
          (xe.__webglTexture = n.createTexture()),
        (xe.__version = F.version),
        s.memory.textures++),
      Me)
    ) {
      me.__webglFramebuffer = [];
      for (let Fe = 0; Fe < 6; Fe++)
        if (F.mipmaps && F.mipmaps.length > 0) {
          me.__webglFramebuffer[Fe] = [];
          for (let ze = 0; ze < F.mipmaps.length; ze++)
            me.__webglFramebuffer[Fe][ze] = n.createFramebuffer();
        } else me.__webglFramebuffer[Fe] = n.createFramebuffer();
    } else {
      if (F.mipmaps && F.mipmaps.length > 0) {
        me.__webglFramebuffer = [];
        for (let Fe = 0; Fe < F.mipmaps.length; Fe++)
          me.__webglFramebuffer[Fe] = n.createFramebuffer();
      } else me.__webglFramebuffer = n.createFramebuffer();
      if (at)
        for (let Fe = 0, ze = ye.length; Fe < ze; Fe++) {
          const We = r.get(ye[Fe]);
          We.__webglTexture === void 0 &&
            ((We.__webglTexture = n.createTexture()), s.memory.textures++);
        }
      if (Z.samples > 0 && Pe(Z) === !1) {
        (me.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (me.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, me.__webglMultisampledFramebuffer);
        for (let Fe = 0; Fe < ye.length; Fe++) {
          const ze = ye[Fe];
          (me.__webglColorRenderbuffer[Fe] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, me.__webglColorRenderbuffer[Fe]);
          const We = o.convert(ze.format, ze.colorSpace),
            Ye = o.convert(ze.type),
            nt = T(
              ze.internalFormat,
              We,
              Ye,
              ze.colorSpace,
              Z.isXRRenderTarget === !0
            ),
            yt = ke(Z);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            yt,
            nt,
            Z.width,
            Z.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Fe,
              n.RENDERBUFFER,
              me.__webglColorRenderbuffer[Fe]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          Z.depthBuffer &&
            ((me.__webglDepthRenderbuffer = n.createRenderbuffer()),
            he(me.__webglDepthRenderbuffer, Z, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (Me) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, xe.__webglTexture),
        G(n.TEXTURE_CUBE_MAP, F);
      for (let Fe = 0; Fe < 6; Fe++)
        if (F.mipmaps && F.mipmaps.length > 0)
          for (let ze = 0; ze < F.mipmaps.length; ze++)
            oe(
              me.__webglFramebuffer[Fe][ze],
              Z,
              F,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe,
              ze
            );
        else
          oe(
            me.__webglFramebuffer[Fe],
            Z,
            F,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe,
            0
          );
      x(F) && w(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (at) {
      for (let Fe = 0, ze = ye.length; Fe < ze; Fe++) {
        const We = ye[Fe],
          Ye = r.get(We);
        t.bindTexture(n.TEXTURE_2D, Ye.__webglTexture),
          G(n.TEXTURE_2D, We),
          oe(
            me.__webglFramebuffer,
            Z,
            We,
            n.COLOR_ATTACHMENT0 + Fe,
            n.TEXTURE_2D,
            0
          ),
          x(We) && w(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Fe = n.TEXTURE_2D;
      if (
        ((Z.isWebGL3DRenderTarget || Z.isWebGLArrayRenderTarget) &&
          (Fe = Z.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Fe, xe.__webglTexture),
        G(Fe, F),
        F.mipmaps && F.mipmaps.length > 0)
      )
        for (let ze = 0; ze < F.mipmaps.length; ze++)
          oe(me.__webglFramebuffer[ze], Z, F, n.COLOR_ATTACHMENT0, Fe, ze);
      else oe(me.__webglFramebuffer, Z, F, n.COLOR_ATTACHMENT0, Fe, 0);
      x(F) && w(Fe), t.unbindTexture();
    }
    Z.depthBuffer && ue(Z);
  }
  function Ae(Z) {
    const F = Z.textures;
    for (let me = 0, xe = F.length; me < xe; me++) {
      const ye = F[me];
      if (x(ye)) {
        const Me = Z.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          at = r.get(ye).__webglTexture;
        t.bindTexture(Me, at), w(Me), t.unbindTexture();
      }
    }
  }
  const W = [],
    _e = [];
  function Te(Z) {
    if (Z.samples > 0) {
      if (Pe(Z) === !1) {
        const F = Z.textures,
          me = Z.width,
          xe = Z.height;
        let ye = n.COLOR_BUFFER_BIT;
        const Me = Z.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          at = r.get(Z),
          Fe = F.length > 1;
        if (Fe)
          for (let ze = 0; ze < F.length; ze++)
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          at.__webglMultisampledFramebuffer
        ),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, at.__webglFramebuffer);
        for (let ze = 0; ze < F.length; ze++) {
          if (
            (Z.resolveDepthBuffer &&
              (Z.depthBuffer && (ye |= n.DEPTH_BUFFER_BIT),
              Z.stencilBuffer &&
                Z.resolveStencilBuffer &&
                (ye |= n.STENCIL_BUFFER_BIT)),
            Fe)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              at.__webglColorRenderbuffer[ze]
            );
            const We = r.get(F[ze]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              We,
              0
            );
          }
          n.blitFramebuffer(0, 0, me, xe, 0, 0, me, xe, ye, n.NEAREST),
            u === !0 &&
              ((W.length = 0),
              (_e.length = 0),
              W.push(n.COLOR_ATTACHMENT0 + ze),
              Z.depthBuffer &&
                Z.resolveDepthBuffer === !1 &&
                (W.push(Me),
                _e.push(Me),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, _e)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, W));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Fe)
        )
          for (let ze = 0; ze < F.length; ze++) {
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.RENDERBUFFER,
                at.__webglColorRenderbuffer[ze]
              );
            const We = r.get(F[ze]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.TEXTURE_2D,
                We,
                0
              );
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          at.__webglMultisampledFramebuffer
        );
      } else if (Z.depthBuffer && Z.resolveDepthBuffer === !1 && u) {
        const F = Z.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [F]);
      }
    }
  }
  function ke(Z) {
    return Math.min(i.maxSamples, Z.samples);
  }
  function Pe(Z) {
    const F = r.get(Z);
    return (
      Z.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      F.__useRenderToTexture !== !1
    );
  }
  function rt(Z) {
    const F = s.render.frame;
    h.get(Z) !== F && (h.set(Z, F), Z.update());
  }
  function Le(Z, F) {
    const me = Z.colorSpace,
      xe = Z.format,
      ye = Z.type;
    return (
      Z.isCompressedTexture === !0 ||
        Z.isVideoTexture === !0 ||
        (me !== kl &&
          me !== bl &&
          (yn.getTransfer(me) === $n
            ? (xe !== Ki || ye !== sa) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                me
              ))),
      F
    );
  }
  function Xe(Z) {
    return (
      typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement
        ? ((f.width = Z.naturalWidth || Z.width),
          (f.height = Z.naturalHeight || Z.height))
        : typeof VideoFrame < "u" && Z instanceof VideoFrame
        ? ((f.width = Z.displayWidth), (f.height = Z.displayHeight))
        : ((f.width = Z.width), (f.height = Z.height)),
      f
    );
  }
  (this.allocateTextureUnit = H),
    (this.resetTextureUnits = V),
    (this.setTexture2D = q),
    (this.setTexture2DArray = K),
    (this.setTexture3D = Y),
    (this.setTextureCube = ne),
    (this.rebindTextures = Ee),
    (this.setupRenderTarget = Ne),
    (this.updateRenderTargetMipmap = Ae),
    (this.updateMultisampleRenderTarget = Te),
    (this.setupDepthRenderbuffer = ue),
    (this.setupFrameBufferTexture = oe),
    (this.useMultisampledRTT = Pe);
}
function IA(n, e) {
  function t(r, i = bl) {
    let o;
    const s = yn.getTransfer(i);
    if (r === sa) return n.UNSIGNED_BYTE;
    if (r === my) return n.UNSIGNED_SHORT_4_4_4_4;
    if (r === gy) return n.UNSIGNED_SHORT_5_5_5_1;
    if (r === LS) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (r === PS) return n.BYTE;
    if (r === IS) return n.SHORT;
    if (r === uh) return n.UNSIGNED_SHORT;
    if (r === py) return n.INT;
    if (r === Ll) return n.UNSIGNED_INT;
    if (r === ko) return n.FLOAT;
    if (r === yh) return n.HALF_FLOAT;
    if (r === DS) return n.ALPHA;
    if (r === kS) return n.RGB;
    if (r === Ki) return n.RGBA;
    if (r === OS) return n.LUMINANCE;
    if (r === NS) return n.LUMINANCE_ALPHA;
    if (r === Jc) return n.DEPTH_COMPONENT;
    if (r === lf) return n.DEPTH_STENCIL;
    if (r === vy) return n.RED;
    if (r === km) return n.RED_INTEGER;
    if (r === US) return n.RG;
    if (r === yy) return n.RG_INTEGER;
    if (r === xy) return n.RGBA_INTEGER;
    if (r === Vp || r === Hp || r === Gp || r === Wp)
      if (s === $n)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (r === Vp) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === Hp) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === Gp) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === Wp) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (r === Vp) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === Hp) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === Gp) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === Wp) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === d0 || r === h0 || r === p0 || r === m0)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (r === d0) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === h0) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === p0) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === m0) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === g0 || r === v0 || r === y0)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (r === g0 || r === v0)
          return s === $n ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === y0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === x0 ||
      r === _0 ||
      r === S0 ||
      r === w0 ||
      r === M0 ||
      r === b0 ||
      r === E0 ||
      r === T0 ||
      r === C0 ||
      r === A0 ||
      r === R0 ||
      r === P0 ||
      r === I0 ||
      r === L0
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (r === x0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === _0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === S0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === w0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === M0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === b0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === E0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === T0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === C0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === A0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === R0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === P0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === I0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === L0)
          return s === $n
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === jp || r === D0 || r === k0)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (r === jp)
          return s === $n
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === D0) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === k0) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (r === FS || r === O0 || r === N0 || r === U0)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (r === jp) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === O0) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === N0) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === U0) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === af ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null;
  }
  return { convert: t };
}
class LA extends Dr {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Kd extends xn {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const lV = { type: "move" };
class I_ {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Kd()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Kd()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new ie()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new ie())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Kd()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new ie()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new ie())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let i = null,
      o = null,
      s = null;
    const l = this._targetRay,
      u = this._grip,
      f = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        s = !0;
        for (const S of e.hand.values()) {
          const x = t.getJointPose(S, r),
            w = this._getHandJoint(f, S);
          x !== null &&
            (w.matrix.fromArray(x.transform.matrix),
            w.matrix.decompose(w.position, w.rotation, w.scale),
            (w.matrixWorldNeedsUpdate = !0),
            (w.jointRadius = x.radius)),
            (w.visible = x !== null);
        }
        const h = f.joints["index-finger-tip"],
          m = f.joints["thumb-tip"],
          g = h.position.distanceTo(m.position),
          y = 0.02,
          _ = 0.005;
        f.inputState.pinching && g > y + _
          ? ((f.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !f.inputState.pinching &&
            g <= y - _ &&
            ((f.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        u !== null &&
          e.gripSpace &&
          ((o = t.getPose(e.gripSpace, r)),
          o !== null &&
            (u.matrix.fromArray(o.transform.matrix),
            u.matrix.decompose(u.position, u.rotation, u.scale),
            (u.matrixWorldNeedsUpdate = !0),
            o.linearVelocity
              ? ((u.hasLinearVelocity = !0),
                u.linearVelocity.copy(o.linearVelocity))
              : (u.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((u.hasAngularVelocity = !0),
                u.angularVelocity.copy(o.angularVelocity))
              : (u.hasAngularVelocity = !1)));
      l !== null &&
        ((i = t.getPose(e.targetRaySpace, r)),
        i === null && o !== null && (i = o),
        i !== null &&
          (l.matrix.fromArray(i.transform.matrix),
          l.matrix.decompose(l.position, l.rotation, l.scale),
          (l.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((l.hasLinearVelocity = !0),
              l.linearVelocity.copy(i.linearVelocity))
            : (l.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((l.hasAngularVelocity = !0),
              l.angularVelocity.copy(i.angularVelocity))
            : (l.hasAngularVelocity = !1),
          this.dispatchEvent(lV)));
    }
    return (
      l !== null && (l.visible = i !== null),
      u !== null && (u.visible = o !== null),
      f !== null && (f.visible = s !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new Kd();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
const uV = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  cV = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class fV {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, r) {
    if (this.texture === null) {
      const i = new rr(),
        o = e.properties.get(i);
      (o.__webglTexture = t.texture),
        (t.depthNear != r.depthNear || t.depthFar != r.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        r = new la({
          vertexShader: uV,
          fragmentShader: cV,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new dr(new Ul(20, 20), r);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class dV extends Ol {
  constructor(e, t) {
    super();
    const r = this;
    let i = null,
      o = 1,
      s = null,
      l = "local-floor",
      u = 1,
      f = null,
      h = null,
      m = null,
      g = null,
      y = null,
      _ = null;
    const S = new fV(),
      x = t.getContextAttributes();
    let w = null,
      T = null;
    const E = [],
      A = [],
      R = new tt();
    let D = null;
    const I = new Dr();
    I.layers.enable(1), (I.viewport = new En());
    const U = new Dr();
    U.layers.enable(2), (U.viewport = new En());
    const O = [I, U],
      L = new LA();
    L.layers.enable(1), L.layers.enable(2);
    let V = null,
      H = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (J) {
        let oe = E[J];
        return (
          oe === void 0 && ((oe = new I_()), (E[J] = oe)),
          oe.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (J) {
        let oe = E[J];
        return (
          oe === void 0 && ((oe = new I_()), (E[J] = oe)), oe.getGripSpace()
        );
      }),
      (this.getHand = function (J) {
        let oe = E[J];
        return (
          oe === void 0 && ((oe = new I_()), (E[J] = oe)), oe.getHandSpace()
        );
      });
    function $(J) {
      const oe = A.indexOf(J.inputSource);
      if (oe === -1) return;
      const he = E[oe];
      he !== void 0 &&
        (he.update(J.inputSource, J.frame, f || s),
        he.dispatchEvent({ type: J.type, data: J.inputSource }));
    }
    function q() {
      i.removeEventListener("select", $),
        i.removeEventListener("selectstart", $),
        i.removeEventListener("selectend", $),
        i.removeEventListener("squeeze", $),
        i.removeEventListener("squeezestart", $),
        i.removeEventListener("squeezeend", $),
        i.removeEventListener("end", q),
        i.removeEventListener("inputsourceschange", K);
      for (let J = 0; J < E.length; J++) {
        const oe = A[J];
        oe !== null && ((A[J] = null), E[J].disconnect(oe));
      }
      (V = null),
        (H = null),
        S.reset(),
        e.setRenderTarget(w),
        (y = null),
        (g = null),
        (m = null),
        (i = null),
        (T = null),
        le.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(D),
        e.setSize(R.width, R.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (J) {
      (o = J),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (J) {
        (l = J),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return f || s;
      }),
      (this.setReferenceSpace = function (J) {
        f = J;
      }),
      (this.getBaseLayer = function () {
        return g !== null ? g : y;
      }),
      (this.getBinding = function () {
        return m;
      }),
      (this.getFrame = function () {
        return _;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (J) {
        if (((i = J), i !== null)) {
          if (
            ((w = e.getRenderTarget()),
            i.addEventListener("select", $),
            i.addEventListener("selectstart", $),
            i.addEventListener("selectend", $),
            i.addEventListener("squeeze", $),
            i.addEventListener("squeezestart", $),
            i.addEventListener("squeezeend", $),
            i.addEventListener("end", q),
            i.addEventListener("inputsourceschange", K),
            x.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (D = e.getPixelRatio()),
            e.getSize(R),
            i.renderState.layers === void 0)
          ) {
            const oe = {
              antialias: x.antialias,
              alpha: !0,
              depth: x.depth,
              stencil: x.stencil,
              framebufferScaleFactor: o,
            };
            (y = new XRWebGLLayer(i, t, oe)),
              i.updateRenderState({ baseLayer: y }),
              e.setPixelRatio(1),
              e.setSize(y.framebufferWidth, y.framebufferHeight, !1),
              (T = new aa(y.framebufferWidth, y.framebufferHeight, {
                format: Ki,
                type: sa,
                colorSpace: e.outputColorSpace,
                stencilBuffer: x.stencil,
              }));
          } else {
            let oe = null,
              he = null,
              ae = null;
            x.depth &&
              ((ae = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (oe = x.stencil ? lf : Jc),
              (he = x.stencil ? af : Ll));
            const ue = {
              colorFormat: t.RGBA8,
              depthFormat: ae,
              scaleFactor: o,
            };
            (m = new XRWebGLBinding(i, t)),
              (g = m.createProjectionLayer(ue)),
              i.updateRenderState({ layers: [g] }),
              e.setPixelRatio(1),
              e.setSize(g.textureWidth, g.textureHeight, !1),
              (T = new aa(g.textureWidth, g.textureHeight, {
                format: Ki,
                type: sa,
                depthTexture: new YS(
                  g.textureWidth,
                  g.textureHeight,
                  he,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  oe
                ),
                stencilBuffer: x.stencil,
                colorSpace: e.outputColorSpace,
                samples: x.antialias ? 4 : 0,
                resolveDepthBuffer: g.ignoreDepthValues === !1,
              }));
          }
          (T.isXRRenderTarget = !0),
            this.setFoveation(u),
            (f = null),
            (s = await i.requestReferenceSpace(l)),
            le.setContext(i),
            le.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return S.getDepthTexture();
      });
    function K(J) {
      for (let oe = 0; oe < J.removed.length; oe++) {
        const he = J.removed[oe],
          ae = A.indexOf(he);
        ae >= 0 && ((A[ae] = null), E[ae].disconnect(he));
      }
      for (let oe = 0; oe < J.added.length; oe++) {
        const he = J.added[oe];
        let ae = A.indexOf(he);
        if (ae === -1) {
          for (let Ee = 0; Ee < E.length; Ee++)
            if (Ee >= A.length) {
              A.push(he), (ae = Ee);
              break;
            } else if (A[Ee] === null) {
              (A[Ee] = he), (ae = Ee);
              break;
            }
          if (ae === -1) break;
        }
        const ue = E[ae];
        ue && ue.connect(he);
      }
    }
    const Y = new ie(),
      ne = new ie();
    function j(J, oe, he) {
      Y.setFromMatrixPosition(oe.matrixWorld),
        ne.setFromMatrixPosition(he.matrixWorld);
      const ae = Y.distanceTo(ne),
        ue = oe.projectionMatrix.elements,
        Ee = he.projectionMatrix.elements,
        Ne = ue[14] / (ue[10] - 1),
        Ae = ue[14] / (ue[10] + 1),
        W = (ue[9] + 1) / ue[5],
        _e = (ue[9] - 1) / ue[5],
        Te = (ue[8] - 1) / ue[0],
        ke = (Ee[8] + 1) / Ee[0],
        Pe = Ne * Te,
        rt = Ne * ke,
        Le = ae / (-Te + ke),
        Xe = Le * -Te;
      oe.matrixWorld.decompose(J.position, J.quaternion, J.scale),
        J.translateX(Xe),
        J.translateZ(Le),
        J.matrixWorld.compose(J.position, J.quaternion, J.scale),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
      const Z = Ne + Le,
        F = Ae + Le,
        me = Pe - Xe,
        xe = rt + (ae - Xe),
        ye = ((W * Ae) / F) * Z,
        Me = ((_e * Ae) / F) * Z;
      J.projectionMatrix.makePerspective(me, xe, ye, Me, Z, F),
        J.projectionMatrixInverse.copy(J.projectionMatrix).invert();
    }
    function re(J, oe) {
      oe === null
        ? J.matrixWorld.copy(J.matrix)
        : J.matrixWorld.multiplyMatrices(oe.matrixWorld, J.matrix),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
    }
    this.updateCamera = function (J) {
      if (i === null) return;
      S.texture !== null && ((J.near = S.depthNear), (J.far = S.depthFar)),
        (L.near = U.near = I.near = J.near),
        (L.far = U.far = I.far = J.far),
        (V !== L.near || H !== L.far) &&
          (i.updateRenderState({ depthNear: L.near, depthFar: L.far }),
          (V = L.near),
          (H = L.far),
          (I.near = V),
          (I.far = H),
          (U.near = V),
          (U.far = H),
          I.updateProjectionMatrix(),
          U.updateProjectionMatrix(),
          J.updateProjectionMatrix());
      const oe = J.parent,
        he = L.cameras;
      re(L, oe);
      for (let ae = 0; ae < he.length; ae++) re(he[ae], oe);
      he.length === 2
        ? j(L, I, U)
        : L.projectionMatrix.copy(I.projectionMatrix),
        B(J, L, oe);
    };
    function B(J, oe, he) {
      he === null
        ? J.matrix.copy(oe.matrixWorld)
        : (J.matrix.copy(he.matrixWorld),
          J.matrix.invert(),
          J.matrix.multiply(oe.matrixWorld)),
        J.matrix.decompose(J.position, J.quaternion, J.scale),
        J.updateMatrixWorld(!0),
        J.projectionMatrix.copy(oe.projectionMatrix),
        J.projectionMatrixInverse.copy(oe.projectionMatrixInverse),
        J.isPerspectiveCamera &&
          ((J.fov = ch * 2 * Math.atan(1 / J.projectionMatrix.elements[5])),
          (J.zoom = 1));
    }
    (this.getCamera = function () {
      return L;
    }),
      (this.getFoveation = function () {
        if (!(g === null && y === null)) return u;
      }),
      (this.setFoveation = function (J) {
        (u = J),
          g !== null && (g.fixedFoveation = J),
          y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = J);
      }),
      (this.hasDepthSensing = function () {
        return S.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return S.getMesh(L);
      });
    let G = null;
    function te(J, oe) {
      if (((h = oe.getViewerPose(f || s)), (_ = oe), h !== null)) {
        const he = h.views;
        y !== null &&
          (e.setRenderTargetFramebuffer(T, y.framebuffer),
          e.setRenderTarget(T));
        let ae = !1;
        he.length !== L.cameras.length && ((L.cameras.length = 0), (ae = !0));
        for (let Ee = 0; Ee < he.length; Ee++) {
          const Ne = he[Ee];
          let Ae = null;
          if (y !== null) Ae = y.getViewport(Ne);
          else {
            const _e = m.getViewSubImage(g, Ne);
            (Ae = _e.viewport),
              Ee === 0 &&
                (e.setRenderTargetTextures(
                  T,
                  _e.colorTexture,
                  g.ignoreDepthValues ? void 0 : _e.depthStencilTexture
                ),
                e.setRenderTarget(T));
          }
          let W = O[Ee];
          W === void 0 &&
            ((W = new Dr()),
            W.layers.enable(Ee),
            (W.viewport = new En()),
            (O[Ee] = W)),
            W.matrix.fromArray(Ne.transform.matrix),
            W.matrix.decompose(W.position, W.quaternion, W.scale),
            W.projectionMatrix.fromArray(Ne.projectionMatrix),
            W.projectionMatrixInverse.copy(W.projectionMatrix).invert(),
            W.viewport.set(Ae.x, Ae.y, Ae.width, Ae.height),
            Ee === 0 &&
              (L.matrix.copy(W.matrix),
              L.matrix.decompose(L.position, L.quaternion, L.scale)),
            ae === !0 && L.cameras.push(W);
        }
        const ue = i.enabledFeatures;
        if (ue && ue.includes("depth-sensing")) {
          const Ee = m.getDepthInformation(he[0]);
          Ee && Ee.isValid && Ee.texture && S.init(e, Ee, i.renderState);
        }
      }
      for (let he = 0; he < E.length; he++) {
        const ae = A[he],
          ue = E[he];
        ae !== null && ue !== void 0 && ue.update(ae, oe, f || s);
      }
      G && G(J, oe),
        oe.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: oe }),
        (_ = null);
    }
    const le = new TA();
    le.setAnimationLoop(te),
      (this.setAnimationLoop = function (J) {
        G = J;
      }),
      (this.dispose = function () {});
  }
}
const Pc = new ss(),
  hV = new Wt();
function pV(n, e) {
  function t(x, w) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), w.value.copy(x.matrix);
  }
  function r(x, w) {
    w.color.getRGB(x.fogColor.value, MA(n)),
      w.isFog
        ? ((x.fogNear.value = w.near), (x.fogFar.value = w.far))
        : w.isFogExp2 && (x.fogDensity.value = w.density);
  }
  function i(x, w, T, E, A) {
    w.isMeshBasicMaterial || w.isMeshLambertMaterial
      ? o(x, w)
      : w.isMeshToonMaterial
      ? (o(x, w), m(x, w))
      : w.isMeshPhongMaterial
      ? (o(x, w), h(x, w))
      : w.isMeshStandardMaterial
      ? (o(x, w), g(x, w), w.isMeshPhysicalMaterial && y(x, w, A))
      : w.isMeshMatcapMaterial
      ? (o(x, w), _(x, w))
      : w.isMeshDepthMaterial
      ? o(x, w)
      : w.isMeshDistanceMaterial
      ? (o(x, w), S(x, w))
      : w.isMeshNormalMaterial
      ? o(x, w)
      : w.isLineBasicMaterial
      ? (s(x, w), w.isLineDashedMaterial && l(x, w))
      : w.isPointsMaterial
      ? u(x, w, T, E)
      : w.isSpriteMaterial
      ? f(x, w)
      : w.isShadowMaterial
      ? (x.color.value.copy(w.color), (x.opacity.value = w.opacity))
      : w.isShaderMaterial && (w.uniformsNeedUpdate = !1);
  }
  function o(x, w) {
    (x.opacity.value = w.opacity),
      w.color && x.diffuse.value.copy(w.color),
      w.emissive &&
        x.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity),
      w.map && ((x.map.value = w.map), t(w.map, x.mapTransform)),
      w.alphaMap &&
        ((x.alphaMap.value = w.alphaMap), t(w.alphaMap, x.alphaMapTransform)),
      w.bumpMap &&
        ((x.bumpMap.value = w.bumpMap),
        t(w.bumpMap, x.bumpMapTransform),
        (x.bumpScale.value = w.bumpScale),
        w.side === Zi && (x.bumpScale.value *= -1)),
      w.normalMap &&
        ((x.normalMap.value = w.normalMap),
        t(w.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(w.normalScale),
        w.side === Zi && x.normalScale.value.negate()),
      w.displacementMap &&
        ((x.displacementMap.value = w.displacementMap),
        t(w.displacementMap, x.displacementMapTransform),
        (x.displacementScale.value = w.displacementScale),
        (x.displacementBias.value = w.displacementBias)),
      w.emissiveMap &&
        ((x.emissiveMap.value = w.emissiveMap),
        t(w.emissiveMap, x.emissiveMapTransform)),
      w.specularMap &&
        ((x.specularMap.value = w.specularMap),
        t(w.specularMap, x.specularMapTransform)),
      w.alphaTest > 0 && (x.alphaTest.value = w.alphaTest);
    const T = e.get(w),
      E = T.envMap,
      A = T.envMapRotation;
    E &&
      ((x.envMap.value = E),
      Pc.copy(A),
      (Pc.x *= -1),
      (Pc.y *= -1),
      (Pc.z *= -1),
      E.isCubeTexture &&
        E.isRenderTargetTexture === !1 &&
        ((Pc.y *= -1), (Pc.z *= -1)),
      x.envMapRotation.value.setFromMatrix4(hV.makeRotationFromEuler(Pc)),
      (x.flipEnvMap.value =
        E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1),
      (x.reflectivity.value = w.reflectivity),
      (x.ior.value = w.ior),
      (x.refractionRatio.value = w.refractionRatio)),
      w.lightMap &&
        ((x.lightMap.value = w.lightMap),
        (x.lightMapIntensity.value = w.lightMapIntensity),
        t(w.lightMap, x.lightMapTransform)),
      w.aoMap &&
        ((x.aoMap.value = w.aoMap),
        (x.aoMapIntensity.value = w.aoMapIntensity),
        t(w.aoMap, x.aoMapTransform));
  }
  function s(x, w) {
    x.diffuse.value.copy(w.color),
      (x.opacity.value = w.opacity),
      w.map && ((x.map.value = w.map), t(w.map, x.mapTransform));
  }
  function l(x, w) {
    (x.dashSize.value = w.dashSize),
      (x.totalSize.value = w.dashSize + w.gapSize),
      (x.scale.value = w.scale);
  }
  function u(x, w, T, E) {
    x.diffuse.value.copy(w.color),
      (x.opacity.value = w.opacity),
      (x.size.value = w.size * T),
      (x.scale.value = E * 0.5),
      w.map && ((x.map.value = w.map), t(w.map, x.uvTransform)),
      w.alphaMap &&
        ((x.alphaMap.value = w.alphaMap), t(w.alphaMap, x.alphaMapTransform)),
      w.alphaTest > 0 && (x.alphaTest.value = w.alphaTest);
  }
  function f(x, w) {
    x.diffuse.value.copy(w.color),
      (x.opacity.value = w.opacity),
      (x.rotation.value = w.rotation),
      w.map && ((x.map.value = w.map), t(w.map, x.mapTransform)),
      w.alphaMap &&
        ((x.alphaMap.value = w.alphaMap), t(w.alphaMap, x.alphaMapTransform)),
      w.alphaTest > 0 && (x.alphaTest.value = w.alphaTest);
  }
  function h(x, w) {
    x.specular.value.copy(w.specular),
      (x.shininess.value = Math.max(w.shininess, 1e-4));
  }
  function m(x, w) {
    w.gradientMap && (x.gradientMap.value = w.gradientMap);
  }
  function g(x, w) {
    (x.metalness.value = w.metalness),
      w.metalnessMap &&
        ((x.metalnessMap.value = w.metalnessMap),
        t(w.metalnessMap, x.metalnessMapTransform)),
      (x.roughness.value = w.roughness),
      w.roughnessMap &&
        ((x.roughnessMap.value = w.roughnessMap),
        t(w.roughnessMap, x.roughnessMapTransform)),
      w.envMap && (x.envMapIntensity.value = w.envMapIntensity);
  }
  function y(x, w, T) {
    (x.ior.value = w.ior),
      w.sheen > 0 &&
        (x.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen),
        (x.sheenRoughness.value = w.sheenRoughness),
        w.sheenColorMap &&
          ((x.sheenColorMap.value = w.sheenColorMap),
          t(w.sheenColorMap, x.sheenColorMapTransform)),
        w.sheenRoughnessMap &&
          ((x.sheenRoughnessMap.value = w.sheenRoughnessMap),
          t(w.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
      w.clearcoat > 0 &&
        ((x.clearcoat.value = w.clearcoat),
        (x.clearcoatRoughness.value = w.clearcoatRoughness),
        w.clearcoatMap &&
          ((x.clearcoatMap.value = w.clearcoatMap),
          t(w.clearcoatMap, x.clearcoatMapTransform)),
        w.clearcoatRoughnessMap &&
          ((x.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap),
          t(w.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        w.clearcoatNormalMap &&
          ((x.clearcoatNormalMap.value = w.clearcoatNormalMap),
          t(w.clearcoatNormalMap, x.clearcoatNormalMapTransform),
          x.clearcoatNormalScale.value.copy(w.clearcoatNormalScale),
          w.side === Zi && x.clearcoatNormalScale.value.negate())),
      w.dispersion > 0 && (x.dispersion.value = w.dispersion),
      w.iridescence > 0 &&
        ((x.iridescence.value = w.iridescence),
        (x.iridescenceIOR.value = w.iridescenceIOR),
        (x.iridescenceThicknessMinimum.value = w.iridescenceThicknessRange[0]),
        (x.iridescenceThicknessMaximum.value = w.iridescenceThicknessRange[1]),
        w.iridescenceMap &&
          ((x.iridescenceMap.value = w.iridescenceMap),
          t(w.iridescenceMap, x.iridescenceMapTransform)),
        w.iridescenceThicknessMap &&
          ((x.iridescenceThicknessMap.value = w.iridescenceThicknessMap),
          t(w.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
      w.transmission > 0 &&
        ((x.transmission.value = w.transmission),
        (x.transmissionSamplerMap.value = T.texture),
        x.transmissionSamplerSize.value.set(T.width, T.height),
        w.transmissionMap &&
          ((x.transmissionMap.value = w.transmissionMap),
          t(w.transmissionMap, x.transmissionMapTransform)),
        (x.thickness.value = w.thickness),
        w.thicknessMap &&
          ((x.thicknessMap.value = w.thicknessMap),
          t(w.thicknessMap, x.thicknessMapTransform)),
        (x.attenuationDistance.value = w.attenuationDistance),
        x.attenuationColor.value.copy(w.attenuationColor)),
      w.anisotropy > 0 &&
        (x.anisotropyVector.value.set(
          w.anisotropy * Math.cos(w.anisotropyRotation),
          w.anisotropy * Math.sin(w.anisotropyRotation)
        ),
        w.anisotropyMap &&
          ((x.anisotropyMap.value = w.anisotropyMap),
          t(w.anisotropyMap, x.anisotropyMapTransform))),
      (x.specularIntensity.value = w.specularIntensity),
      x.specularColor.value.copy(w.specularColor),
      w.specularColorMap &&
        ((x.specularColorMap.value = w.specularColorMap),
        t(w.specularColorMap, x.specularColorMapTransform)),
      w.specularIntensityMap &&
        ((x.specularIntensityMap.value = w.specularIntensityMap),
        t(w.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function _(x, w) {
    w.matcap && (x.matcap.value = w.matcap);
  }
  function S(x, w) {
    const T = e.get(w).light;
    x.referencePosition.value.setFromMatrixPosition(T.matrixWorld),
      (x.nearDistance.value = T.shadow.camera.near),
      (x.farDistance.value = T.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function mV(n, e, t, r) {
  let i = {},
    o = {},
    s = [];
  const l = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(T, E) {
    const A = E.program;
    r.uniformBlockBinding(T, A);
  }
  function f(T, E) {
    let A = i[T.id];
    A === void 0 &&
      (_(T), (A = h(T)), (i[T.id] = A), T.addEventListener("dispose", x));
    const R = E.program;
    r.updateUBOMapping(T, R);
    const D = e.render.frame;
    o[T.id] !== D && (g(T), (o[T.id] = D));
  }
  function h(T) {
    const E = m();
    T.__bindingPointIndex = E;
    const A = n.createBuffer(),
      R = T.__size,
      D = T.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, A),
      n.bufferData(n.UNIFORM_BUFFER, R, D),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, E, A),
      A
    );
  }
  function m() {
    for (let T = 0; T < l; T++) if (s.indexOf(T) === -1) return s.push(T), T;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function g(T) {
    const E = i[T.id],
      A = T.uniforms,
      R = T.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, E);
    for (let D = 0, I = A.length; D < I; D++) {
      const U = Array.isArray(A[D]) ? A[D] : [A[D]];
      for (let O = 0, L = U.length; O < L; O++) {
        const V = U[O];
        if (y(V, D, O, R) === !0) {
          const H = V.__offset,
            $ = Array.isArray(V.value) ? V.value : [V.value];
          let q = 0;
          for (let K = 0; K < $.length; K++) {
            const Y = $[K],
              ne = S(Y);
            typeof Y == "number" || typeof Y == "boolean"
              ? ((V.__data[0] = Y),
                n.bufferSubData(n.UNIFORM_BUFFER, H + q, V.__data))
              : Y.isMatrix3
              ? ((V.__data[0] = Y.elements[0]),
                (V.__data[1] = Y.elements[1]),
                (V.__data[2] = Y.elements[2]),
                (V.__data[3] = 0),
                (V.__data[4] = Y.elements[3]),
                (V.__data[5] = Y.elements[4]),
                (V.__data[6] = Y.elements[5]),
                (V.__data[7] = 0),
                (V.__data[8] = Y.elements[6]),
                (V.__data[9] = Y.elements[7]),
                (V.__data[10] = Y.elements[8]),
                (V.__data[11] = 0))
              : (Y.toArray(V.__data, q),
                (q += ne.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, H, V.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function y(T, E, A, R) {
    const D = T.value,
      I = E + "_" + A;
    if (R[I] === void 0)
      return (
        typeof D == "number" || typeof D == "boolean"
          ? (R[I] = D)
          : (R[I] = D.clone()),
        !0
      );
    {
      const U = R[I];
      if (typeof D == "number" || typeof D == "boolean") {
        if (U !== D) return (R[I] = D), !0;
      } else if (U.equals(D) === !1) return U.copy(D), !0;
    }
    return !1;
  }
  function _(T) {
    const E = T.uniforms;
    let A = 0;
    const R = 16;
    for (let I = 0, U = E.length; I < U; I++) {
      const O = Array.isArray(E[I]) ? E[I] : [E[I]];
      for (let L = 0, V = O.length; L < V; L++) {
        const H = O[L],
          $ = Array.isArray(H.value) ? H.value : [H.value];
        for (let q = 0, K = $.length; q < K; q++) {
          const Y = $[q],
            ne = S(Y),
            j = A % R,
            re = j % ne.boundary,
            B = j + re;
          (A += re),
            B !== 0 && R - B < ne.storage && (A += R - B),
            (H.__data = new Float32Array(
              ne.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (H.__offset = A),
            (A += ne.storage);
        }
      }
    }
    const D = A % R;
    return D > 0 && (A += R - D), (T.__size = A), (T.__cache = {}), this;
  }
  function S(T) {
    const E = { boundary: 0, storage: 0 };
    return (
      typeof T == "number" || typeof T == "boolean"
        ? ((E.boundary = 4), (E.storage = 4))
        : T.isVector2
        ? ((E.boundary = 8), (E.storage = 8))
        : T.isVector3 || T.isColor
        ? ((E.boundary = 16), (E.storage = 12))
        : T.isVector4
        ? ((E.boundary = 16), (E.storage = 16))
        : T.isMatrix3
        ? ((E.boundary = 48), (E.storage = 48))
        : T.isMatrix4
        ? ((E.boundary = 64), (E.storage = 64))
        : T.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            T
          ),
      E
    );
  }
  function x(T) {
    const E = T.target;
    E.removeEventListener("dispose", x);
    const A = s.indexOf(E.__bindingPointIndex);
    s.splice(A, 1), n.deleteBuffer(i[E.id]), delete i[E.id], delete o[E.id];
  }
  function w() {
    for (const T in i) n.deleteBuffer(i[T]);
    (s = []), (i = {}), (o = {});
  }
  return { bind: u, update: f, dispose: w };
}
class DA {
  constructor(e = {}) {
    const {
      canvas: t = xA(),
      context: r = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: s = !1,
      antialias: l = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: f = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: m = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let g;
    if (r !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        r instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      g = r.getContextAttributes().alpha;
    } else g = s;
    const y = new Uint32Array(4),
      _ = new Int32Array(4);
    let S = null,
      x = null;
    const w = [],
      T = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Ms),
      (this.toneMapping = Ba),
      (this.toneMappingExposure = 1);
    const E = this;
    let A = !1,
      R = 0,
      D = 0,
      I = null,
      U = -1,
      O = null;
    const L = new En(),
      V = new En();
    let H = null;
    const $ = new St(0);
    let q = 0,
      K = t.width,
      Y = t.height,
      ne = 1,
      j = null,
      re = null;
    const B = new En(0, 0, K, Y),
      G = new En(0, 0, K, Y);
    let te = !1;
    const le = new Fm();
    let J = !1,
      oe = !1;
    const he = new Wt(),
      ae = new ie(),
      ue = new En(),
      Ee = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let Ne = !1;
    function Ae() {
      return I === null ? ne : 1;
    }
    let W = r;
    function _e(Q, be) {
      return t.getContext(Q, be);
    }
    try {
      const Q = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: l,
        premultipliedAlpha: u,
        preserveDrawingBuffer: f,
        powerPreference: h,
        failIfMajorPerformanceCaveat: m,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${fy}`),
        t.addEventListener("webglcontextlost", Ce, !1),
        t.addEventListener("webglcontextrestored", Ue, !1),
        t.addEventListener("webglcontextcreationerror", it, !1),
        W === null)
      ) {
        const be = "webgl2";
        if (((W = _e(be, Q)), W === null))
          throw _e(be)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (Q) {
      throw (console.error("THREE.WebGLRenderer: " + Q.message), Q);
    }
    let Te,
      ke,
      Pe,
      rt,
      Le,
      Xe,
      Z,
      F,
      me,
      xe,
      ye,
      Me,
      at,
      Fe,
      ze,
      We,
      Ye,
      nt,
      yt,
      $e,
      qe,
      et,
      ce,
      Je;
    function de() {
      (Te = new w5(W)),
        Te.init(),
        (et = new IA(W, Te)),
        (ke = new g5(W, Te, e, et)),
        (Pe = new tV(W)),
        (rt = new E5(W)),
        (Le = new G6()),
        (Xe = new aV(W, Te, Pe, Le, ke, et, rt)),
        (Z = new y5(E)),
        (F = new S5(E)),
        (me = new L4(W)),
        (ce = new p5(W, me)),
        (xe = new M5(W, me, rt, ce)),
        (ye = new C5(W, xe, me, rt)),
        (yt = new T5(W, ke, Xe)),
        (We = new v5(Le)),
        (Me = new H6(E, Z, F, Te, ke, ce, We)),
        (at = new pV(E, Le)),
        (Fe = new j6()),
        (ze = new Z6(Te)),
        (nt = new h5(E, Z, F, Pe, ye, g, u)),
        (Ye = new eV(E, ye, ke)),
        (Je = new mV(W, rt, ke, Pe)),
        ($e = new m5(W, Te, rt)),
        (qe = new b5(W, Te, rt)),
        (rt.programs = Me.programs),
        (E.capabilities = ke),
        (E.extensions = Te),
        (E.properties = Le),
        (E.renderLists = Fe),
        (E.shadowMap = Ye),
        (E.state = Pe),
        (E.info = rt);
    }
    de();
    const He = new dV(E, W);
    (this.xr = He),
      (this.getContext = function () {
        return W;
      }),
      (this.getContextAttributes = function () {
        return W.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const Q = Te.get("WEBGL_lose_context");
        Q && Q.loseContext();
      }),
      (this.forceContextRestore = function () {
        const Q = Te.get("WEBGL_lose_context");
        Q && Q.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return ne;
      }),
      (this.setPixelRatio = function (Q) {
        Q !== void 0 && ((ne = Q), this.setSize(K, Y, !1));
      }),
      (this.getSize = function (Q) {
        return Q.set(K, Y);
      }),
      (this.setSize = function (Q, be, Be = !0) {
        if (He.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (K = Q),
          (Y = be),
          (t.width = Math.floor(Q * ne)),
          (t.height = Math.floor(be * ne)),
          Be === !0 &&
            ((t.style.width = Q + "px"), (t.style.height = be + "px")),
          this.setViewport(0, 0, Q, be);
      }),
      (this.getDrawingBufferSize = function (Q) {
        return Q.set(K * ne, Y * ne).floor();
      }),
      (this.setDrawingBufferSize = function (Q, be, Be) {
        (K = Q),
          (Y = be),
          (ne = Be),
          (t.width = Math.floor(Q * Be)),
          (t.height = Math.floor(be * Be)),
          this.setViewport(0, 0, Q, be);
      }),
      (this.getCurrentViewport = function (Q) {
        return Q.copy(L);
      }),
      (this.getViewport = function (Q) {
        return Q.copy(B);
      }),
      (this.setViewport = function (Q, be, Be, Ge) {
        Q.isVector4 ? B.set(Q.x, Q.y, Q.z, Q.w) : B.set(Q, be, Be, Ge),
          Pe.viewport(L.copy(B).multiplyScalar(ne).round());
      }),
      (this.getScissor = function (Q) {
        return Q.copy(G);
      }),
      (this.setScissor = function (Q, be, Be, Ge) {
        Q.isVector4 ? G.set(Q.x, Q.y, Q.z, Q.w) : G.set(Q, be, Be, Ge),
          Pe.scissor(V.copy(G).multiplyScalar(ne).round());
      }),
      (this.getScissorTest = function () {
        return te;
      }),
      (this.setScissorTest = function (Q) {
        Pe.setScissorTest((te = Q));
      }),
      (this.setOpaqueSort = function (Q) {
        j = Q;
      }),
      (this.setTransparentSort = function (Q) {
        re = Q;
      }),
      (this.getClearColor = function (Q) {
        return Q.copy(nt.getClearColor());
      }),
      (this.setClearColor = function () {
        nt.setClearColor.apply(nt, arguments);
      }),
      (this.getClearAlpha = function () {
        return nt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        nt.setClearAlpha.apply(nt, arguments);
      }),
      (this.clear = function (Q = !0, be = !0, Be = !0) {
        let Ge = 0;
        if (Q) {
          let Ie = !1;
          if (I !== null) {
            const ut = I.texture.format;
            Ie = ut === xy || ut === yy || ut === km;
          }
          if (Ie) {
            const ut = I.texture.type,
              vt =
                ut === sa ||
                ut === Ll ||
                ut === uh ||
                ut === af ||
                ut === my ||
                ut === gy,
              Et = nt.getClearColor(),
              Ke = nt.getClearAlpha(),
              Dt = Et.r,
              Ut = Et.g,
              At = Et.b;
            vt
              ? ((y[0] = Dt),
                (y[1] = Ut),
                (y[2] = At),
                (y[3] = Ke),
                W.clearBufferuiv(W.COLOR, 0, y))
              : ((_[0] = Dt),
                (_[1] = Ut),
                (_[2] = At),
                (_[3] = Ke),
                W.clearBufferiv(W.COLOR, 0, _));
          } else Ge |= W.COLOR_BUFFER_BIT;
        }
        be && (Ge |= W.DEPTH_BUFFER_BIT),
          Be &&
            ((Ge |= W.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          W.clear(Ge);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Ce, !1),
          t.removeEventListener("webglcontextrestored", Ue, !1),
          t.removeEventListener("webglcontextcreationerror", it, !1),
          Fe.dispose(),
          ze.dispose(),
          Le.dispose(),
          Z.dispose(),
          F.dispose(),
          ye.dispose(),
          ce.dispose(),
          Je.dispose(),
          Me.dispose(),
          He.dispose(),
          He.removeEventListener("sessionstart", an),
          He.removeEventListener("sessionend", _n),
          mn.stop();
      });
    function Ce(Q) {
      Q.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (A = !0);
    }
    function Ue() {
      console.log("THREE.WebGLRenderer: Context Restored."), (A = !1);
      const Q = rt.autoReset,
        be = Ye.enabled,
        Be = Ye.autoUpdate,
        Ge = Ye.needsUpdate,
        Ie = Ye.type;
      de(),
        (rt.autoReset = Q),
        (Ye.enabled = be),
        (Ye.autoUpdate = Be),
        (Ye.needsUpdate = Ge),
        (Ye.type = Ie);
    }
    function it(Q) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        Q.statusMessage
      );
    }
    function mt(Q) {
      const be = Q.target;
      be.removeEventListener("dispose", mt), gt(be);
    }
    function gt(Q) {
      Ot(Q), Le.remove(Q);
    }
    function Ot(Q) {
      const be = Le.get(Q).programs;
      be !== void 0 &&
        (be.forEach(function (Be) {
          Me.releaseProgram(Be);
        }),
        Q.isShaderMaterial && Me.releaseShaderCache(Q));
    }
    this.renderBufferDirect = function (Q, be, Be, Ge, Ie, ut) {
      be === null && (be = Ee);
      const vt = Ie.isMesh && Ie.matrixWorld.determinant() < 0,
        Et = Fl(Q, be, Be, Ge, Ie);
      Pe.setMaterial(Ge, vt);
      let Ke = Be.index,
        Dt = 1;
      if (Ge.wireframe === !0) {
        if (((Ke = xe.getWireframeAttribute(Be)), Ke === void 0)) return;
        Dt = 2;
      }
      const Ut = Be.drawRange,
        At = Be.attributes.position;
      let tn = Ut.start * Dt,
        Tn = (Ut.start + Ut.count) * Dt;
      ut !== null &&
        ((tn = Math.max(tn, ut.start * Dt)),
        (Tn = Math.min(Tn, (ut.start + ut.count) * Dt))),
        Ke !== null
          ? ((tn = Math.max(tn, 0)), (Tn = Math.min(Tn, Ke.count)))
          : At != null &&
            ((tn = Math.max(tn, 0)), (Tn = Math.min(Tn, At.count)));
      const dn = Tn - tn;
      if (dn < 0 || dn === 1 / 0) return;
      ce.setup(Ie, Ge, Et, Be, Ke);
      let Sn,
        wt = $e;
      if (
        (Ke !== null && ((Sn = me.get(Ke)), (wt = qe), wt.setIndex(Sn)),
        Ie.isMesh)
      )
        Ge.wireframe === !0
          ? (Pe.setLineWidth(Ge.wireframeLinewidth * Ae()), wt.setMode(W.LINES))
          : wt.setMode(W.TRIANGLES);
      else if (Ie.isLine) {
        let dt = Ge.linewidth;
        dt === void 0 && (dt = 1),
          Pe.setLineWidth(dt * Ae()),
          Ie.isLineSegments
            ? wt.setMode(W.LINES)
            : Ie.isLineLoop
            ? wt.setMode(W.LINE_LOOP)
            : wt.setMode(W.LINE_STRIP);
      } else
        Ie.isPoints
          ? wt.setMode(W.POINTS)
          : Ie.isSprite && wt.setMode(W.TRIANGLES);
      if (Ie.isBatchedMesh)
        if (Ie._multiDrawInstances !== null)
          wt.renderMultiDrawInstances(
            Ie._multiDrawStarts,
            Ie._multiDrawCounts,
            Ie._multiDrawCount,
            Ie._multiDrawInstances
          );
        else if (Te.get("WEBGL_multi_draw"))
          wt.renderMultiDraw(
            Ie._multiDrawStarts,
            Ie._multiDrawCounts,
            Ie._multiDrawCount
          );
        else {
          const dt = Ie._multiDrawStarts,
            Zt = Ie._multiDrawCounts,
            Bt = Ie._multiDrawCount,
            wn = Ke ? me.get(Ke).bytesPerElement : 1,
            ni = Le.get(Ge).currentProgram.getUniforms();
          for (let Cn = 0; Cn < Bt; Cn++)
            ni.setValue(W, "_gl_DrawID", Cn), wt.render(dt[Cn] / wn, Zt[Cn]);
        }
      else if (Ie.isInstancedMesh) wt.renderInstances(tn, dn, Ie.count);
      else if (Be.isInstancedBufferGeometry) {
        const dt =
            Be._maxInstanceCount !== void 0 ? Be._maxInstanceCount : 1 / 0,
          Zt = Math.min(Be.instanceCount, dt);
        wt.renderInstances(tn, dn, Zt);
      } else wt.render(tn, dn);
    };
    function Nt(Q, be, Be) {
      Q.transparent === !0 && Q.side === Es && Q.forceSinglePass === !1
        ? ((Q.side = Zi),
          (Q.needsUpdate = !0),
          Ur(Q, be, Be),
          (Q.side = Ga),
          (Q.needsUpdate = !0),
          Ur(Q, be, Be),
          (Q.side = Es))
        : Ur(Q, be, Be);
    }
    (this.compile = function (Q, be, Be = null) {
      Be === null && (Be = Q),
        (x = ze.get(Be)),
        x.init(be),
        T.push(x),
        Be.traverseVisible(function (Ie) {
          Ie.isLight &&
            Ie.layers.test(be.layers) &&
            (x.pushLight(Ie), Ie.castShadow && x.pushShadow(Ie));
        }),
        Q !== Be &&
          Q.traverseVisible(function (Ie) {
            Ie.isLight &&
              Ie.layers.test(be.layers) &&
              (x.pushLight(Ie), Ie.castShadow && x.pushShadow(Ie));
          }),
        x.setupLights();
      const Ge = new Set();
      return (
        Q.traverse(function (Ie) {
          const ut = Ie.material;
          if (ut)
            if (Array.isArray(ut))
              for (let vt = 0; vt < ut.length; vt++) {
                const Et = ut[vt];
                Nt(Et, Be, Ie), Ge.add(Et);
              }
            else Nt(ut, Be, Ie), Ge.add(ut);
        }),
        T.pop(),
        (x = null),
        Ge
      );
    }),
      (this.compileAsync = function (Q, be, Be = null) {
        const Ge = this.compile(Q, be, Be);
        return new Promise((Ie) => {
          function ut() {
            if (
              (Ge.forEach(function (vt) {
                Le.get(vt).currentProgram.isReady() && Ge.delete(vt);
              }),
              Ge.size === 0)
            ) {
              Ie(Q);
              return;
            }
            setTimeout(ut, 10);
          }
          Te.get("KHR_parallel_shader_compile") !== null
            ? ut()
            : setTimeout(ut, 10);
        });
      });
    let ht = null;
    function jt(Q) {
      ht && ht(Q);
    }
    function an() {
      mn.stop();
    }
    function _n() {
      mn.start();
    }
    const mn = new TA();
    mn.setAnimationLoop(jt),
      typeof self < "u" && mn.setContext(self),
      (this.setAnimationLoop = function (Q) {
        (ht = Q), He.setAnimationLoop(Q), Q === null ? mn.stop() : mn.start();
      }),
      He.addEventListener("sessionstart", an),
      He.addEventListener("sessionend", _n),
      (this.render = function (Q, be) {
        if (be !== void 0 && be.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (A === !0) return;
        if (
          (Q.matrixWorldAutoUpdate === !0 && Q.updateMatrixWorld(),
          be.parent === null &&
            be.matrixWorldAutoUpdate === !0 &&
            be.updateMatrixWorld(),
          He.enabled === !0 &&
            He.isPresenting === !0 &&
            (He.cameraAutoUpdate === !0 && He.updateCamera(be),
            (be = He.getCamera())),
          Q.isScene === !0 && Q.onBeforeRender(E, Q, be, I),
          (x = ze.get(Q, T.length)),
          x.init(be),
          T.push(x),
          he.multiplyMatrices(be.projectionMatrix, be.matrixWorldInverse),
          le.setFromProjectionMatrix(he),
          (oe = this.localClippingEnabled),
          (J = We.init(this.clippingPlanes, oe)),
          (S = Fe.get(Q, w.length)),
          S.init(),
          w.push(S),
          He.enabled === !0 && He.isPresenting === !0)
        ) {
          const ut = E.xr.getDepthSensingMesh();
          ut !== null && ir(ut, be, -1 / 0, E.sortObjects);
        }
        ir(Q, be, 0, E.sortObjects),
          S.finish(),
          E.sortObjects === !0 && S.sort(j, re),
          (Ne =
            He.enabled === !1 ||
            He.isPresenting === !1 ||
            He.hasDepthSensing() === !1),
          Ne && nt.addToRenderList(S, Q),
          this.info.render.frame++,
          J === !0 && We.beginShadows();
        const Be = x.state.shadowsArray;
        Ye.render(Be, Q, be),
          J === !0 && We.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Ge = S.opaque,
          Ie = S.transmissive;
        if ((x.setupLights(), be.isArrayCamera)) {
          const ut = be.cameras;
          if (Ie.length > 0)
            for (let vt = 0, Et = ut.length; vt < Et; vt++) {
              const Ke = ut[vt];
              mr(Ge, Ie, Q, Ke);
            }
          Ne && nt.render(Q);
          for (let vt = 0, Et = ut.length; vt < Et; vt++) {
            const Ke = ut[vt];
            Oi(S, Q, Ke, Ke.viewport);
          }
        } else
          Ie.length > 0 && mr(Ge, Ie, Q, be), Ne && nt.render(Q), Oi(S, Q, be);
        I !== null &&
          (Xe.updateMultisampleRenderTarget(I), Xe.updateRenderTargetMipmap(I)),
          Q.isScene === !0 && Q.onAfterRender(E, Q, be),
          ce.resetDefaultState(),
          (U = -1),
          (O = null),
          T.pop(),
          T.length > 0
            ? ((x = T[T.length - 1]),
              J === !0 && We.setGlobalState(E.clippingPlanes, x.state.camera))
            : (x = null),
          w.pop(),
          w.length > 0 ? (S = w[w.length - 1]) : (S = null);
      });
    function ir(Q, be, Be, Ge) {
      if (Q.visible === !1) return;
      if (Q.layers.test(be.layers)) {
        if (Q.isGroup) Be = Q.renderOrder;
        else if (Q.isLOD) Q.autoUpdate === !0 && Q.update(be);
        else if (Q.isLight) x.pushLight(Q), Q.castShadow && x.pushShadow(Q);
        else if (Q.isSprite) {
          if (!Q.frustumCulled || le.intersectsSprite(Q)) {
            Ge && ue.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(he);
            const vt = ye.update(Q),
              Et = Q.material;
            Et.visible && S.push(Q, vt, Et, Be, ue.z, null);
          }
        } else if (
          (Q.isMesh || Q.isLine || Q.isPoints) &&
          (!Q.frustumCulled || le.intersectsObject(Q))
        ) {
          const vt = ye.update(Q),
            Et = Q.material;
          if (
            (Ge &&
              (Q.boundingSphere !== void 0
                ? (Q.boundingSphere === null && Q.computeBoundingSphere(),
                  ue.copy(Q.boundingSphere.center))
                : (vt.boundingSphere === null && vt.computeBoundingSphere(),
                  ue.copy(vt.boundingSphere.center)),
              ue.applyMatrix4(Q.matrixWorld).applyMatrix4(he)),
            Array.isArray(Et))
          ) {
            const Ke = vt.groups;
            for (let Dt = 0, Ut = Ke.length; Dt < Ut; Dt++) {
              const At = Ke[Dt],
                tn = Et[At.materialIndex];
              tn && tn.visible && S.push(Q, vt, tn, Be, ue.z, At);
            }
          } else Et.visible && S.push(Q, vt, Et, Be, ue.z, null);
        }
      }
      const ut = Q.children;
      for (let vt = 0, Et = ut.length; vt < Et; vt++) ir(ut[vt], be, Be, Ge);
    }
    function Oi(Q, be, Be, Ge) {
      const Ie = Q.opaque,
        ut = Q.transmissive,
        vt = Q.transparent;
      x.setupLightsView(Be),
        J === !0 && We.setGlobalState(E.clippingPlanes, Be),
        Ge && Pe.viewport(L.copy(Ge)),
        Ie.length > 0 && Nr(Ie, be, Be),
        ut.length > 0 && Nr(ut, be, Be),
        vt.length > 0 && Nr(vt, be, Be),
        Pe.buffers.depth.setTest(!0),
        Pe.buffers.depth.setMask(!0),
        Pe.buffers.color.setMask(!0),
        Pe.setPolygonOffset(!1);
    }
    function mr(Q, be, Be, Ge) {
      if ((Be.isScene === !0 ? Be.overrideMaterial : null) !== null) return;
      x.state.transmissionRenderTarget[Ge.id] === void 0 &&
        (x.state.transmissionRenderTarget[Ge.id] = new aa(1, 1, {
          generateMipmaps: !0,
          type:
            Te.has("EXT_color_buffer_half_float") ||
            Te.has("EXT_color_buffer_float")
              ? yh
              : sa,
          minFilter: Na,
          samples: 4,
          stencilBuffer: o,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: yn.workingColorSpace,
        }));
      const ut = x.state.transmissionRenderTarget[Ge.id],
        vt = Ge.viewport || L;
      ut.setSize(vt.z, vt.w);
      const Et = E.getRenderTarget();
      E.setRenderTarget(ut),
        E.getClearColor($),
        (q = E.getClearAlpha()),
        q < 1 && E.setClearColor(16777215, 0.5),
        E.clear(),
        Ne && nt.render(Be);
      const Ke = E.toneMapping;
      E.toneMapping = Ba;
      const Dt = Ge.viewport;
      if (
        (Ge.viewport !== void 0 && (Ge.viewport = void 0),
        x.setupLightsView(Ge),
        J === !0 && We.setGlobalState(E.clippingPlanes, Ge),
        Nr(Q, Be, Ge),
        Xe.updateMultisampleRenderTarget(ut),
        Xe.updateRenderTargetMipmap(ut),
        Te.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let Ut = !1;
        for (let At = 0, tn = be.length; At < tn; At++) {
          const Tn = be[At],
            dn = Tn.object,
            Sn = Tn.geometry,
            wt = Tn.material,
            dt = Tn.group;
          if (wt.side === Es && dn.layers.test(Ge.layers)) {
            const Zt = wt.side;
            (wt.side = Zi),
              (wt.needsUpdate = !0),
              Er(dn, Be, Ge, Sn, wt, dt),
              (wt.side = Zt),
              (wt.needsUpdate = !0),
              (Ut = !0);
          }
        }
        Ut === !0 &&
          (Xe.updateMultisampleRenderTarget(ut),
          Xe.updateRenderTargetMipmap(ut));
      }
      E.setRenderTarget(Et),
        E.setClearColor($, q),
        Dt !== void 0 && (Ge.viewport = Dt),
        (E.toneMapping = Ke);
    }
    function Nr(Q, be, Be) {
      const Ge = be.isScene === !0 ? be.overrideMaterial : null;
      for (let Ie = 0, ut = Q.length; Ie < ut; Ie++) {
        const vt = Q[Ie],
          Et = vt.object,
          Ke = vt.geometry,
          Dt = Ge === null ? vt.material : Ge,
          Ut = vt.group;
        Et.layers.test(Be.layers) && Er(Et, be, Be, Ke, Dt, Ut);
      }
    }
    function Er(Q, be, Be, Ge, Ie, ut) {
      Q.onBeforeRender(E, be, Be, Ge, Ie, ut),
        Q.modelViewMatrix.multiplyMatrices(
          Be.matrixWorldInverse,
          Q.matrixWorld
        ),
        Q.normalMatrix.getNormalMatrix(Q.modelViewMatrix),
        Ie.transparent === !0 && Ie.side === Es && Ie.forceSinglePass === !1
          ? ((Ie.side = Zi),
            (Ie.needsUpdate = !0),
            E.renderBufferDirect(Be, be, Ge, Ie, Q, ut),
            (Ie.side = Ga),
            (Ie.needsUpdate = !0),
            E.renderBufferDirect(Be, be, Ge, Ie, Q, ut),
            (Ie.side = Es))
          : E.renderBufferDirect(Be, be, Ge, Ie, Q, ut),
        Q.onAfterRender(E, be, Be, Ge, Ie, ut);
    }
    function Ur(Q, be, Be) {
      be.isScene !== !0 && (be = Ee);
      const Ge = Le.get(Q),
        Ie = x.state.lights,
        ut = x.state.shadowsArray,
        vt = Ie.state.version,
        Et = Me.getParameters(Q, Ie.state, ut, be, Be),
        Ke = Me.getProgramCacheKey(Et);
      let Dt = Ge.programs;
      (Ge.environment = Q.isMeshStandardMaterial ? be.environment : null),
        (Ge.fog = be.fog),
        (Ge.envMap = (Q.isMeshStandardMaterial ? F : Z).get(
          Q.envMap || Ge.environment
        )),
        (Ge.envMapRotation =
          Ge.environment !== null && Q.envMap === null
            ? be.environmentRotation
            : Q.envMapRotation),
        Dt === void 0 &&
          (Q.addEventListener("dispose", mt),
          (Dt = new Map()),
          (Ge.programs = Dt));
      let Ut = Dt.get(Ke);
      if (Ut !== void 0) {
        if (Ge.currentProgram === Ut && Ge.lightsStateVersion === vt)
          return go(Q, Et), Ut;
      } else
        (Et.uniforms = Me.getUniforms(Q)),
          Q.onBeforeCompile(Et, E),
          (Ut = Me.acquireProgram(Et, Ke)),
          Dt.set(Ke, Ut),
          (Ge.uniforms = Et.uniforms);
      const At = Ge.uniforms;
      return (
        ((!Q.isShaderMaterial && !Q.isRawShaderMaterial) ||
          Q.clipping === !0) &&
          (At.clippingPlanes = We.uniform),
        go(Q, Et),
        (Ge.needsLights = zl(Q)),
        (Ge.lightsStateVersion = vt),
        Ge.needsLights &&
          ((At.ambientLightColor.value = Ie.state.ambient),
          (At.lightProbe.value = Ie.state.probe),
          (At.directionalLights.value = Ie.state.directional),
          (At.directionalLightShadows.value = Ie.state.directionalShadow),
          (At.spotLights.value = Ie.state.spot),
          (At.spotLightShadows.value = Ie.state.spotShadow),
          (At.rectAreaLights.value = Ie.state.rectArea),
          (At.ltc_1.value = Ie.state.rectAreaLTC1),
          (At.ltc_2.value = Ie.state.rectAreaLTC2),
          (At.pointLights.value = Ie.state.point),
          (At.pointLightShadows.value = Ie.state.pointShadow),
          (At.hemisphereLights.value = Ie.state.hemi),
          (At.directionalShadowMap.value = Ie.state.directionalShadowMap),
          (At.directionalShadowMatrix.value = Ie.state.directionalShadowMatrix),
          (At.spotShadowMap.value = Ie.state.spotShadowMap),
          (At.spotLightMatrix.value = Ie.state.spotLightMatrix),
          (At.spotLightMap.value = Ie.state.spotLightMap),
          (At.pointShadowMap.value = Ie.state.pointShadowMap),
          (At.pointShadowMatrix.value = Ie.state.pointShadowMatrix)),
        (Ge.currentProgram = Ut),
        (Ge.uniformsList = null),
        Ut
      );
    }
    function gr(Q) {
      if (Q.uniformsList === null) {
        const be = Q.currentProgram.getUniforms();
        Q.uniformsList = Yv.seqWithValue(be.seq, Q.uniforms);
      }
      return Q.uniformsList;
    }
    function go(Q, be) {
      const Be = Le.get(Q);
      (Be.outputColorSpace = be.outputColorSpace),
        (Be.batching = be.batching),
        (Be.batchingColor = be.batchingColor),
        (Be.instancing = be.instancing),
        (Be.instancingColor = be.instancingColor),
        (Be.instancingMorph = be.instancingMorph),
        (Be.skinning = be.skinning),
        (Be.morphTargets = be.morphTargets),
        (Be.morphNormals = be.morphNormals),
        (Be.morphColors = be.morphColors),
        (Be.morphTargetsCount = be.morphTargetsCount),
        (Be.numClippingPlanes = be.numClippingPlanes),
        (Be.numIntersection = be.numClipIntersection),
        (Be.vertexAlphas = be.vertexAlphas),
        (Be.vertexTangents = be.vertexTangents),
        (Be.toneMapping = be.toneMapping);
    }
    function Fl(Q, be, Be, Ge, Ie) {
      be.isScene !== !0 && (be = Ee), Xe.resetTextureUnits();
      const ut = be.fog,
        vt = Ge.isMeshStandardMaterial ? be.environment : null,
        Et =
          I === null
            ? E.outputColorSpace
            : I.isXRRenderTarget === !0
            ? I.texture.colorSpace
            : kl,
        Ke = (Ge.isMeshStandardMaterial ? F : Z).get(Ge.envMap || vt),
        Dt =
          Ge.vertexColors === !0 &&
          !!Be.attributes.color &&
          Be.attributes.color.itemSize === 4,
        Ut = !!Be.attributes.tangent && (!!Ge.normalMap || Ge.anisotropy > 0),
        At = !!Be.morphAttributes.position,
        tn = !!Be.morphAttributes.normal,
        Tn = !!Be.morphAttributes.color;
      let dn = Ba;
      Ge.toneMapped &&
        (I === null || I.isXRRenderTarget === !0) &&
        (dn = E.toneMapping);
      const Sn =
          Be.morphAttributes.position ||
          Be.morphAttributes.normal ||
          Be.morphAttributes.color,
        wt = Sn !== void 0 ? Sn.length : 0,
        dt = Le.get(Ge),
        Zt = x.state.lights;
      if (J === !0 && (oe === !0 || Q !== O)) {
        const or = Q === O && Ge.id === U;
        We.setState(Ge, Q, or);
      }
      let Bt = !1;
      Ge.version === dt.__version
        ? ((dt.needsLights && dt.lightsStateVersion !== Zt.state.version) ||
            dt.outputColorSpace !== Et ||
            (Ie.isBatchedMesh && dt.batching === !1) ||
            (!Ie.isBatchedMesh && dt.batching === !0) ||
            (Ie.isBatchedMesh &&
              dt.batchingColor === !0 &&
              Ie.colorTexture === null) ||
            (Ie.isBatchedMesh &&
              dt.batchingColor === !1 &&
              Ie.colorTexture !== null) ||
            (Ie.isInstancedMesh && dt.instancing === !1) ||
            (!Ie.isInstancedMesh && dt.instancing === !0) ||
            (Ie.isSkinnedMesh && dt.skinning === !1) ||
            (!Ie.isSkinnedMesh && dt.skinning === !0) ||
            (Ie.isInstancedMesh &&
              dt.instancingColor === !0 &&
              Ie.instanceColor === null) ||
            (Ie.isInstancedMesh &&
              dt.instancingColor === !1 &&
              Ie.instanceColor !== null) ||
            (Ie.isInstancedMesh &&
              dt.instancingMorph === !0 &&
              Ie.morphTexture === null) ||
            (Ie.isInstancedMesh &&
              dt.instancingMorph === !1 &&
              Ie.morphTexture !== null) ||
            dt.envMap !== Ke ||
            (Ge.fog === !0 && dt.fog !== ut) ||
            (dt.numClippingPlanes !== void 0 &&
              (dt.numClippingPlanes !== We.numPlanes ||
                dt.numIntersection !== We.numIntersection)) ||
            dt.vertexAlphas !== Dt ||
            dt.vertexTangents !== Ut ||
            dt.morphTargets !== At ||
            dt.morphNormals !== tn ||
            dt.morphColors !== Tn ||
            dt.toneMapping !== dn ||
            dt.morphTargetsCount !== wt) &&
          (Bt = !0)
        : ((Bt = !0), (dt.__version = Ge.version));
      let wn = dt.currentProgram;
      Bt === !0 && (wn = Ur(Ge, be, Ie));
      let ni = !1,
        Cn = !1,
        Bn = !1;
      const ln = wn.getUniforms(),
        Fr = dt.uniforms;
      if (
        (Pe.useProgram(wn.program) && ((ni = !0), (Cn = !0), (Bn = !0)),
        Ge.id !== U && ((U = Ge.id), (Cn = !0)),
        ni || O !== Q)
      ) {
        ln.setValue(W, "projectionMatrix", Q.projectionMatrix),
          ln.setValue(W, "viewMatrix", Q.matrixWorldInverse);
        const or = ln.map.cameraPosition;
        or !== void 0 &&
          or.setValue(W, ae.setFromMatrixPosition(Q.matrixWorld)),
          ke.logarithmicDepthBuffer &&
            ln.setValue(
              W,
              "logDepthBufFC",
              2 / (Math.log(Q.far + 1) / Math.LN2)
            ),
          (Ge.isMeshPhongMaterial ||
            Ge.isMeshToonMaterial ||
            Ge.isMeshLambertMaterial ||
            Ge.isMeshBasicMaterial ||
            Ge.isMeshStandardMaterial ||
            Ge.isShaderMaterial) &&
            ln.setValue(W, "isOrthographic", Q.isOrthographicCamera === !0),
          O !== Q && ((O = Q), (Cn = !0), (Bn = !0));
      }
      if (Ie.isSkinnedMesh) {
        ln.setOptional(W, Ie, "bindMatrix"),
          ln.setOptional(W, Ie, "bindMatrixInverse");
        const or = Ie.skeleton;
        or &&
          (or.boneTexture === null && or.computeBoneTexture(),
          ln.setValue(W, "boneTexture", or.boneTexture, Xe));
      }
      Ie.isBatchedMesh &&
        (ln.setOptional(W, Ie, "batchingTexture"),
        ln.setValue(W, "batchingTexture", Ie._matricesTexture, Xe),
        ln.setOptional(W, Ie, "batchingIdTexture"),
        ln.setValue(W, "batchingIdTexture", Ie._indirectTexture, Xe),
        ln.setOptional(W, Ie, "batchingColorTexture"),
        Ie._colorsTexture !== null &&
          ln.setValue(W, "batchingColorTexture", Ie._colorsTexture, Xe));
      const as = Be.morphAttributes;
      if (
        ((as.position !== void 0 ||
          as.normal !== void 0 ||
          as.color !== void 0) &&
          yt.update(Ie, Be, wn),
        (Cn || dt.receiveShadow !== Ie.receiveShadow) &&
          ((dt.receiveShadow = Ie.receiveShadow),
          ln.setValue(W, "receiveShadow", Ie.receiveShadow)),
        Ge.isMeshGouraudMaterial &&
          Ge.envMap !== null &&
          ((Fr.envMap.value = Ke),
          (Fr.flipEnvMap.value =
            Ke.isCubeTexture && Ke.isRenderTargetTexture === !1 ? -1 : 1)),
        Ge.isMeshStandardMaterial &&
          Ge.envMap === null &&
          be.environment !== null &&
          (Fr.envMapIntensity.value = be.environmentIntensity),
        Cn &&
          (ln.setValue(W, "toneMappingExposure", E.toneMappingExposure),
          dt.needsLights && eo(Fr, Bn),
          ut && Ge.fog === !0 && at.refreshFogUniforms(Fr, ut),
          at.refreshMaterialUniforms(
            Fr,
            Ge,
            ne,
            Y,
            x.state.transmissionRenderTarget[Q.id]
          ),
          Yv.upload(W, gr(dt), Fr, Xe)),
        Ge.isShaderMaterial &&
          Ge.uniformsNeedUpdate === !0 &&
          (Yv.upload(W, gr(dt), Fr, Xe), (Ge.uniformsNeedUpdate = !1)),
        Ge.isSpriteMaterial && ln.setValue(W, "center", Ie.center),
        ln.setValue(W, "modelViewMatrix", Ie.modelViewMatrix),
        ln.setValue(W, "normalMatrix", Ie.normalMatrix),
        ln.setValue(W, "modelMatrix", Ie.matrixWorld),
        Ge.isShaderMaterial || Ge.isRawShaderMaterial)
      ) {
        const or = Ge.uniformsGroups;
        for (let Tr = 0, ci = or.length; Tr < ci; Tr++) {
          const Uo = or[Tr];
          Je.update(Uo, wn), Je.bind(Uo, wn);
        }
      }
      return wn;
    }
    function eo(Q, be) {
      (Q.ambientLightColor.needsUpdate = be),
        (Q.lightProbe.needsUpdate = be),
        (Q.directionalLights.needsUpdate = be),
        (Q.directionalLightShadows.needsUpdate = be),
        (Q.pointLights.needsUpdate = be),
        (Q.pointLightShadows.needsUpdate = be),
        (Q.spotLights.needsUpdate = be),
        (Q.spotLightShadows.needsUpdate = be),
        (Q.rectAreaLights.needsUpdate = be),
        (Q.hemisphereLights.needsUpdate = be);
    }
    function zl(Q) {
      return (
        Q.isMeshLambertMaterial ||
        Q.isMeshToonMaterial ||
        Q.isMeshPhongMaterial ||
        Q.isMeshStandardMaterial ||
        Q.isShadowMaterial ||
        (Q.isShaderMaterial && Q.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return R;
    }),
      (this.getActiveMipmapLevel = function () {
        return D;
      }),
      (this.getRenderTarget = function () {
        return I;
      }),
      (this.setRenderTargetTextures = function (Q, be, Be) {
        (Le.get(Q.texture).__webglTexture = be),
          (Le.get(Q.depthTexture).__webglTexture = Be);
        const Ge = Le.get(Q);
        (Ge.__hasExternalTextures = !0),
          (Ge.__autoAllocateDepthBuffer = Be === void 0),
          Ge.__autoAllocateDepthBuffer ||
            (Te.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (Ge.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (Q, be) {
        const Be = Le.get(Q);
        (Be.__webglFramebuffer = be),
          (Be.__useDefaultFramebuffer = be === void 0);
      }),
      (this.setRenderTarget = function (Q, be = 0, Be = 0) {
        (I = Q), (R = be), (D = Be);
        let Ge = !0,
          Ie = null,
          ut = !1,
          vt = !1;
        if (Q) {
          const Ke = Le.get(Q);
          Ke.__useDefaultFramebuffer !== void 0
            ? (Pe.bindFramebuffer(W.FRAMEBUFFER, null), (Ge = !1))
            : Ke.__webglFramebuffer === void 0
            ? Xe.setupRenderTarget(Q)
            : Ke.__hasExternalTextures &&
              Xe.rebindTextures(
                Q,
                Le.get(Q.texture).__webglTexture,
                Le.get(Q.depthTexture).__webglTexture
              );
          const Dt = Q.texture;
          (Dt.isData3DTexture ||
            Dt.isDataArrayTexture ||
            Dt.isCompressedArrayTexture) &&
            (vt = !0);
          const Ut = Le.get(Q).__webglFramebuffer;
          Q.isWebGLCubeRenderTarget
            ? (Array.isArray(Ut[be]) ? (Ie = Ut[be][Be]) : (Ie = Ut[be]),
              (ut = !0))
            : Q.samples > 0 && Xe.useMultisampledRTT(Q) === !1
            ? (Ie = Le.get(Q).__webglMultisampledFramebuffer)
            : Array.isArray(Ut)
            ? (Ie = Ut[Be])
            : (Ie = Ut),
            L.copy(Q.viewport),
            V.copy(Q.scissor),
            (H = Q.scissorTest);
        } else
          L.copy(B).multiplyScalar(ne).floor(),
            V.copy(G).multiplyScalar(ne).floor(),
            (H = te);
        if (
          (Pe.bindFramebuffer(W.FRAMEBUFFER, Ie) && Ge && Pe.drawBuffers(Q, Ie),
          Pe.viewport(L),
          Pe.scissor(V),
          Pe.setScissorTest(H),
          ut)
        ) {
          const Ke = Le.get(Q.texture);
          W.framebufferTexture2D(
            W.FRAMEBUFFER,
            W.COLOR_ATTACHMENT0,
            W.TEXTURE_CUBE_MAP_POSITIVE_X + be,
            Ke.__webglTexture,
            Be
          );
        } else if (vt) {
          const Ke = Le.get(Q.texture),
            Dt = be || 0;
          W.framebufferTextureLayer(
            W.FRAMEBUFFER,
            W.COLOR_ATTACHMENT0,
            Ke.__webglTexture,
            Be || 0,
            Dt
          );
        }
        U = -1;
      }),
      (this.readRenderTargetPixels = function (Q, be, Be, Ge, Ie, ut, vt) {
        if (!(Q && Q.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Et = Le.get(Q).__webglFramebuffer;
        if ((Q.isWebGLCubeRenderTarget && vt !== void 0 && (Et = Et[vt]), Et)) {
          Pe.bindFramebuffer(W.FRAMEBUFFER, Et);
          try {
            const Ke = Q.texture,
              Dt = Ke.format,
              Ut = Ke.type;
            if (!ke.textureFormatReadable(Dt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!ke.textureTypeReadable(Ut)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            be >= 0 &&
              be <= Q.width - Ge &&
              Be >= 0 &&
              Be <= Q.height - Ie &&
              W.readPixels(be, Be, Ge, Ie, et.convert(Dt), et.convert(Ut), ut);
          } finally {
            const Ke = I !== null ? Le.get(I).__webglFramebuffer : null;
            Pe.bindFramebuffer(W.FRAMEBUFFER, Ke);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        Q,
        be,
        Be,
        Ge,
        Ie,
        ut,
        vt
      ) {
        if (!(Q && Q.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let Et = Le.get(Q).__webglFramebuffer;
        if ((Q.isWebGLCubeRenderTarget && vt !== void 0 && (Et = Et[vt]), Et)) {
          Pe.bindFramebuffer(W.FRAMEBUFFER, Et);
          try {
            const Ke = Q.texture,
              Dt = Ke.format,
              Ut = Ke.type;
            if (!ke.textureFormatReadable(Dt))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!ke.textureTypeReadable(Ut))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            if (
              be >= 0 &&
              be <= Q.width - Ge &&
              Be >= 0 &&
              Be <= Q.height - Ie
            ) {
              const At = W.createBuffer();
              W.bindBuffer(W.PIXEL_PACK_BUFFER, At),
                W.bufferData(W.PIXEL_PACK_BUFFER, ut.byteLength, W.STREAM_READ),
                W.readPixels(be, Be, Ge, Ie, et.convert(Dt), et.convert(Ut), 0),
                W.flush();
              const tn = W.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE, 0);
              await r4(W, tn, 4);
              try {
                W.bindBuffer(W.PIXEL_PACK_BUFFER, At),
                  W.getBufferSubData(W.PIXEL_PACK_BUFFER, 0, ut);
              } finally {
                W.deleteBuffer(At), W.deleteSync(tn);
              }
              return ut;
            }
          } finally {
            const Ke = I !== null ? Le.get(I).__webglFramebuffer : null;
            Pe.bindFramebuffer(W.FRAMEBUFFER, Ke);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (Q, be = null, Be = 0) {
        Q.isTexture !== !0 &&
          (rh(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          (be = arguments[0] || null),
          (Q = arguments[1]));
        const Ge = Math.pow(2, -Be),
          Ie = Math.floor(Q.image.width * Ge),
          ut = Math.floor(Q.image.height * Ge),
          vt = be !== null ? be.x : 0,
          Et = be !== null ? be.y : 0;
        Xe.setTexture2D(Q, 0),
          W.copyTexSubImage2D(W.TEXTURE_2D, Be, 0, 0, vt, Et, Ie, ut),
          Pe.unbindTexture();
      }),
      (this.copyTextureToTexture = function (
        Q,
        be,
        Be = null,
        Ge = null,
        Ie = 0
      ) {
        Q.isTexture !== !0 &&
          (rh(
            "WebGLRenderer: copyTextureToTexture function signature has changed."
          ),
          (Ge = arguments[0] || null),
          (Q = arguments[1]),
          (be = arguments[2]),
          (Ie = arguments[3] || 0),
          (Be = null));
        let ut, vt, Et, Ke, Dt, Ut;
        Be !== null
          ? ((ut = Be.max.x - Be.min.x),
            (vt = Be.max.y - Be.min.y),
            (Et = Be.min.x),
            (Ke = Be.min.y))
          : ((ut = Q.image.width), (vt = Q.image.height), (Et = 0), (Ke = 0)),
          Ge !== null ? ((Dt = Ge.x), (Ut = Ge.y)) : ((Dt = 0), (Ut = 0));
        const At = et.convert(be.format),
          tn = et.convert(be.type);
        Xe.setTexture2D(be, 0),
          W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, be.flipY),
          W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, be.premultiplyAlpha),
          W.pixelStorei(W.UNPACK_ALIGNMENT, be.unpackAlignment);
        const Tn = W.getParameter(W.UNPACK_ROW_LENGTH),
          dn = W.getParameter(W.UNPACK_IMAGE_HEIGHT),
          Sn = W.getParameter(W.UNPACK_SKIP_PIXELS),
          wt = W.getParameter(W.UNPACK_SKIP_ROWS),
          dt = W.getParameter(W.UNPACK_SKIP_IMAGES),
          Zt = Q.isCompressedTexture ? Q.mipmaps[Ie] : Q.image;
        W.pixelStorei(W.UNPACK_ROW_LENGTH, Zt.width),
          W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, Zt.height),
          W.pixelStorei(W.UNPACK_SKIP_PIXELS, Et),
          W.pixelStorei(W.UNPACK_SKIP_ROWS, Ke),
          Q.isDataTexture
            ? W.texSubImage2D(W.TEXTURE_2D, Ie, Dt, Ut, ut, vt, At, tn, Zt.data)
            : Q.isCompressedTexture
            ? W.compressedTexSubImage2D(
                W.TEXTURE_2D,
                Ie,
                Dt,
                Ut,
                Zt.width,
                Zt.height,
                At,
                Zt.data
              )
            : W.texSubImage2D(W.TEXTURE_2D, Ie, Dt, Ut, ut, vt, At, tn, Zt),
          W.pixelStorei(W.UNPACK_ROW_LENGTH, Tn),
          W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, dn),
          W.pixelStorei(W.UNPACK_SKIP_PIXELS, Sn),
          W.pixelStorei(W.UNPACK_SKIP_ROWS, wt),
          W.pixelStorei(W.UNPACK_SKIP_IMAGES, dt),
          Ie === 0 && be.generateMipmaps && W.generateMipmap(W.TEXTURE_2D),
          Pe.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (
        Q,
        be,
        Be = null,
        Ge = null,
        Ie = 0
      ) {
        Q.isTexture !== !0 &&
          (rh(
            "WebGLRenderer: copyTextureToTexture3D function signature has changed."
          ),
          (Be = arguments[0] || null),
          (Ge = arguments[1] || null),
          (Q = arguments[2]),
          (be = arguments[3]),
          (Ie = arguments[4] || 0));
        let ut, vt, Et, Ke, Dt, Ut, At, tn, Tn;
        const dn = Q.isCompressedTexture ? Q.mipmaps[Ie] : Q.image;
        Be !== null
          ? ((ut = Be.max.x - Be.min.x),
            (vt = Be.max.y - Be.min.y),
            (Et = Be.max.z - Be.min.z),
            (Ke = Be.min.x),
            (Dt = Be.min.y),
            (Ut = Be.min.z))
          : ((ut = dn.width),
            (vt = dn.height),
            (Et = dn.depth),
            (Ke = 0),
            (Dt = 0),
            (Ut = 0)),
          Ge !== null
            ? ((At = Ge.x), (tn = Ge.y), (Tn = Ge.z))
            : ((At = 0), (tn = 0), (Tn = 0));
        const Sn = et.convert(be.format),
          wt = et.convert(be.type);
        let dt;
        if (be.isData3DTexture) Xe.setTexture3D(be, 0), (dt = W.TEXTURE_3D);
        else if (be.isDataArrayTexture || be.isCompressedArrayTexture)
          Xe.setTexture2DArray(be, 0), (dt = W.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, be.flipY),
          W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, be.premultiplyAlpha),
          W.pixelStorei(W.UNPACK_ALIGNMENT, be.unpackAlignment);
        const Zt = W.getParameter(W.UNPACK_ROW_LENGTH),
          Bt = W.getParameter(W.UNPACK_IMAGE_HEIGHT),
          wn = W.getParameter(W.UNPACK_SKIP_PIXELS),
          ni = W.getParameter(W.UNPACK_SKIP_ROWS),
          Cn = W.getParameter(W.UNPACK_SKIP_IMAGES);
        W.pixelStorei(W.UNPACK_ROW_LENGTH, dn.width),
          W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, dn.height),
          W.pixelStorei(W.UNPACK_SKIP_PIXELS, Ke),
          W.pixelStorei(W.UNPACK_SKIP_ROWS, Dt),
          W.pixelStorei(W.UNPACK_SKIP_IMAGES, Ut),
          Q.isDataTexture || Q.isData3DTexture
            ? W.texSubImage3D(dt, Ie, At, tn, Tn, ut, vt, Et, Sn, wt, dn.data)
            : be.isCompressedArrayTexture
            ? W.compressedTexSubImage3D(
                dt,
                Ie,
                At,
                tn,
                Tn,
                ut,
                vt,
                Et,
                Sn,
                dn.data
              )
            : W.texSubImage3D(dt, Ie, At, tn, Tn, ut, vt, Et, Sn, wt, dn),
          W.pixelStorei(W.UNPACK_ROW_LENGTH, Zt),
          W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, Bt),
          W.pixelStorei(W.UNPACK_SKIP_PIXELS, wn),
          W.pixelStorei(W.UNPACK_SKIP_ROWS, ni),
          W.pixelStorei(W.UNPACK_SKIP_IMAGES, Cn),
          Ie === 0 && be.generateMipmaps && W.generateMipmap(dt),
          Pe.unbindTexture();
      }),
      (this.initRenderTarget = function (Q) {
        Le.get(Q).__webglFramebuffer === void 0 && Xe.setupRenderTarget(Q);
      }),
      (this.initTexture = function (Q) {
        Q.isCubeTexture
          ? Xe.setTextureCube(Q, 0)
          : Q.isData3DTexture
          ? Xe.setTexture3D(Q, 0)
          : Q.isDataArrayTexture || Q.isCompressedArrayTexture
          ? Xe.setTexture2DArray(Q, 0)
          : Xe.setTexture2D(Q, 0),
          Pe.unbindTexture();
      }),
      (this.resetState = function () {
        (R = 0), (D = 0), (I = null), Pe.reset(), ce.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Ua;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = e === Sy ? "display-p3" : "srgb"),
      (t.unpackColorSpace =
        yn.workingColorSpace === Om ? "display-p3" : "srgb");
  }
}
class Ty {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new St(e)),
      (this.density = t);
  }
  clone() {
    return new Ty(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Cy {
  constructor(e, t = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new St(e)),
      (this.near = t),
      (this.far = r);
  }
  clone() {
    return new Cy(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
let z0 = class extends xn {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new ss()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new ss()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
};
class Ay {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = mm),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = is());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      rh(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.stride), (r *= t.stride);
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = is()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = is()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const fo = new ie();
class uf {
  constructor(e, t, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      fo.fromBufferAttribute(this, t),
        fo.applyMatrix4(e),
        this.setXYZ(t, fo.x, fo.y, fo.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      fo.fromBufferAttribute(this, t),
        fo.applyNormalMatrix(e),
        this.setXYZ(t, fo.x, fo.y, fo.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      fo.fromBufferAttribute(this, t),
        fo.transformDirection(e),
        this.setXYZ(t, fo.x, fo.y, fo.z);
    return this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (r = po(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = on(r, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = r),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = po(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = po(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = po(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = po(t, this.array)), t;
  }
  setXY(e, t, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = on(t, this.array)), (r = on(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array)),
        (o = on(o, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return new zn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new uf(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class qS extends ki {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let kd;
const yp = new ie(),
  Od = new ie(),
  Nd = new ie(),
  Ud = new tt(),
  xp = new tt(),
  kA = new Wt(),
  cv = new ie(),
  _p = new ie(),
  fv = new ie(),
  ME = new tt(),
  L_ = new tt(),
  bE = new tt();
class OA extends xn {
  constructor(e = new qS()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), kd === void 0)
    ) {
      kd = new Kt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new Ay(t, 5);
      kd.setIndex([0, 1, 2, 0, 2, 3]),
        kd.setAttribute("position", new uf(r, 3, 0, !1)),
        kd.setAttribute("uv", new uf(r, 2, 3, !1));
    }
    (this.geometry = kd), (this.material = e), (this.center = new tt(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Od.setFromMatrixScale(this.matrixWorld),
      kA.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Nd.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Od.multiplyScalar(-Nd.z);
    const r = this.material.rotation;
    let i, o;
    r !== 0 && ((o = Math.cos(r)), (i = Math.sin(r)));
    const s = this.center;
    dv(cv.set(-0.5, -0.5, 0), Nd, s, Od, i, o),
      dv(_p.set(0.5, -0.5, 0), Nd, s, Od, i, o),
      dv(fv.set(0.5, 0.5, 0), Nd, s, Od, i, o),
      ME.set(0, 0),
      L_.set(1, 0),
      bE.set(1, 1);
    let l = e.ray.intersectTriangle(cv, _p, fv, !1, yp);
    if (
      l === null &&
      (dv(_p.set(-0.5, 0.5, 0), Nd, s, Od, i, o),
      L_.set(0, 1),
      (l = e.ray.intersectTriangle(cv, fv, _p, !1, yp)),
      l === null)
    )
      return;
    const u = e.ray.origin.distanceTo(yp);
    u < e.near ||
      u > e.far ||
      t.push({
        distance: u,
        point: yp.clone(),
        uv: es.getInterpolation(yp, cv, _p, fv, ME, L_, bE, new tt()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function dv(n, e, t, r, i, o) {
  Ud.subVectors(n, t).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((xp.x = o * Ud.x - i * Ud.y), (xp.y = i * Ud.x + o * Ud.y))
      : xp.copy(Ud),
    n.copy(e),
    (n.x += xp.x),
    (n.y += xp.y),
    n.applyMatrix4(kA);
}
const hv = new ie(),
  EE = new ie();
class NA extends xn {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(t < i[o].distance); o++);
    return (
      i.splice(o, 0, { distance: t, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), e < o)) break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      hv.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(hv);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      hv.setFromMatrixPosition(e.matrixWorld),
        EE.setFromMatrixPosition(this.matrixWorld);
      const r = hv.distanceTo(EE) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), r >= s))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < o; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const r = this.levels;
    for (let i = 0, o = r.length; i < o; i++) {
      const s = r[i];
      t.object.levels.push({
        object: s.object.uuid,
        distance: s.distance,
        hysteresis: s.hysteresis,
      });
    }
    return t;
  }
}
const TE = new ie(),
  CE = new En(),
  AE = new En(),
  gV = new ie(),
  RE = new Wt(),
  pv = new ie(),
  D_ = new Di(),
  PE = new Wt(),
  k_ = new hf();
class UA extends dr {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = D1),
      (this.bindMatrix = new Wt()),
      (this.bindMatrixInverse = new Wt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Qi()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, pv), this.boundingBox.expandByPoint(pv);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Di()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, pv), this.boundingSphere.expandByPoint(pv);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      D_.copy(this.boundingSphere),
      D_.applyMatrix4(i),
      e.ray.intersectsSphere(D_) !== !1 &&
        (PE.copy(i).invert(),
        k_.copy(e.ray).applyMatrix4(PE),
        !(
          this.boundingBox !== null && k_.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, k_)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new En(),
      t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0),
        t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === D1
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === oA
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton,
      i = this.geometry;
    CE.fromBufferAttribute(i.attributes.skinIndex, e),
      AE.fromBufferAttribute(i.attributes.skinWeight, e),
      TE.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const s = AE.getComponent(o);
      if (s !== 0) {
        const l = CE.getComponent(o);
        RE.multiplyMatrices(r.bones[l].matrixWorld, r.boneInverses[l]),
          t.addScaledVector(gV.copy(TE).applyMatrix4(RE), s);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class KS extends xn {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Va extends rr {
  constructor(e = null, t = 1, r = 1, i, o, s, l, u, f = yi, h = yi, m, g) {
    super(null, s, l, u, f, h, i, o, m, g),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const IE = new Wt(),
  vV = new Wt();
class Ry {
  constructor(e = [], t = []) {
    (this.uuid = is()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new Wt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Wt();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let o = 0, s = e.length; o < s; o++) {
      const l = e[o] ? e[o].matrixWorld : vV;
      IE.multiplyMatrices(l, t[o]), IE.toArray(r, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Ry(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new Va(t, e, e, Ki, ko);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const o = e.bones[r];
      let s = t[o];
      s === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", o),
        (s = new KS())),
        this.bones.push(s),
        this.boneInverses.push(new Wt().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      r = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const s = t[i];
      e.bones.push(s.uuid);
      const l = r[i];
      e.boneInverses.push(l.toArray());
    }
    return e;
  }
}
class cf extends zn {
  constructor(e, t, r, i = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Fd = new Wt(),
  LE = new Wt(),
  mv = [],
  DE = new Qi(),
  yV = new Wt(),
  Sp = new dr(),
  wp = new Di();
class FA extends dr {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new cf(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, yV);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Qi()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Fd),
        DE.copy(e.boundingBox).applyMatrix4(Fd),
        this.boundingBox.union(DE);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Di()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Fd),
        wp.copy(e.boundingSphere).applyMatrix4(Fd),
        this.boundingSphere.union(wp);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      o = r.length + 1,
      s = e * o + 1;
    for (let l = 0; l < r.length; l++) r[l] = i[s + l];
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((Sp.geometry = this.geometry),
      (Sp.material = this.material),
      Sp.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        wp.copy(this.boundingSphere),
        wp.applyMatrix4(r),
        e.ray.intersectsSphere(wp) !== !1))
    )
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, Fd),
          LE.multiplyMatrices(r, Fd),
          (Sp.matrixWorld = LE),
          Sp.raycast(e, mv);
        for (let s = 0, l = mv.length; s < l; s++) {
          const u = mv[s];
          (u.instanceId = o), (u.object = this), t.push(u);
        }
        mv.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new cf(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = r.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Va(
        new Float32Array(i * this.count),
        i,
        this.count,
        vy,
        ko
      ));
    const o = this.morphTexture.source.data.data;
    let s = 0;
    for (let f = 0; f < r.length; f++) s += r[f];
    const l = this.geometry.morphTargetsRelative ? 1 : 1 - s,
      u = i * e;
    (o[u] = l), o.set(r, u + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
function xV(n, e) {
  return n.z - e.z;
}
function _V(n, e) {
  return e.z - n.z;
}
class SV {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, r) {
    const i = this.pool,
      o = this.list;
    this.index >= i.length &&
      i.push({ start: -1, count: -1, z: -1, index: -1 });
    const s = i[this.index];
    o.push(s),
      this.index++,
      (s.start = e.start),
      (s.count = e.count),
      (s.z = t),
      (s.index = r);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Au = new Wt(),
  O_ = new Wt(),
  wV = new Wt(),
  MV = new St(1, 1, 1),
  kE = new Wt(),
  N_ = new Fm(),
  gv = new Qi(),
  Ic = new Di(),
  Mp = new ie(),
  OE = new ie(),
  bV = new ie(),
  U_ = new SV(),
  $i = new dr(),
  vv = [];
function EV(n, e, t = 0) {
  const r = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const i = n.count;
    for (let o = 0; o < i; o++)
      for (let s = 0; s < r; s++)
        e.setComponent(o + t, s, n.getComponent(o, s));
  } else e.array.set(n.array, t * r);
  e.needsUpdate = !0;
}
class zA extends dr {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  constructor(e, t, r = t * 2, i) {
    super(new Kt(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawInfo = []),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._bounds = []),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = r),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      r = new Va(t, e, e, Ki, ko);
    this._matricesTexture = r;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      r = new Va(t, e, e, km, Ll);
    this._indirectTexture = r;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxIndexCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      r = new Va(t, e, e, Ki, ko);
    (r.colorSpace = yn.workingColorSpace), (this._colorsTexture = r);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      r = this._maxVertexCount,
      i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const s = e.getAttribute(o),
          { array: l, itemSize: u, normalized: f } = s,
          h = new l.constructor(r * u),
          m = new zn(h, u, f);
        t.setAttribute(o, m);
      }
      if (e.getIndex() !== null) {
        const o = r > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new zn(o, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in t.attributes) {
      if (!e.hasAttribute(r))
        throw new Error(
          `BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        o = t.getAttribute(r);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Qi());
    const e = this._geometryCount,
      t = this.boundingBox,
      r = this._drawInfo;
    t.makeEmpty();
    for (let i = 0; i < e; i++) {
      if (r[i].active === !1) continue;
      const o = r[i].geometryIndex;
      this.getMatrixAt(i, Au),
        this.getBoundingBoxAt(o, gv).applyMatrix4(Au),
        t.union(gv);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Di());
    const e = this.boundingSphere,
      t = this._drawInfo;
    e.makeEmpty();
    for (let r = 0, i = t.length; r < i; r++) {
      if (t[r].active === !1) continue;
      const o = t[r].geometryIndex;
      this.getMatrixAt(r, Au),
        this.getBoundingSphereAt(o, Ic).applyMatrix4(Au),
        e.union(Ic);
    }
  }
  addInstance(e) {
    if (this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    this._drawInfo.push({ visible: !0, active: !0, geometryIndex: e });
    const t = this._drawInfo.length - 1,
      r = this._matricesTexture,
      i = r.image.data;
    wV.toArray(i, t * 16), (r.needsUpdate = !0);
    const o = this._colorsTexture;
    return o && (MV.toArray(o.image.data, t * 4), (o.needsUpdate = !0)), t;
  }
  addGeometry(e, t = -1, r = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._drawInfo.length >= this._maxInstanceCount)
    )
      throw new Error("BatchedMesh: Maximum item count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let o = null;
    const s = this._reservedRanges,
      l = this._drawRanges,
      u = this._bounds;
    this._geometryCount !== 0 && (o = s[s.length - 1]),
      t === -1
        ? (i.vertexCount = e.getAttribute("position").count)
        : (i.vertexCount = t),
      o === null
        ? (i.vertexStart = 0)
        : (i.vertexStart = o.vertexStart + o.vertexCount);
    const f = e.getIndex(),
      h = f !== null;
    if (
      (h &&
        (r === -1 ? (i.indexCount = f.count) : (i.indexCount = r),
        o === null
          ? (i.indexStart = 0)
          : (i.indexStart = o.indexStart + o.indexCount)),
      (i.indexStart !== -1 &&
        i.indexStart + i.indexCount > this._maxIndexCount) ||
        i.vertexStart + i.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const m = this._geometryCount;
    return (
      this._geometryCount++,
      s.push(i),
      l.push({ start: h ? i.indexStart : i.vertexStart, count: -1 }),
      u.push({
        boxInitialized: !1,
        box: new Qi(),
        sphereInitialized: !1,
        sphere: new Di(),
      }),
      this.setGeometryAt(m, e),
      m
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const r = this.geometry,
      i = r.getIndex() !== null,
      o = r.getIndex(),
      s = t.getIndex(),
      l = this._reservedRanges[e];
    if (
      (i && s.count > l.indexCount) ||
      t.attributes.position.count > l.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const u = l.vertexStart,
      f = l.vertexCount;
    for (const y in r.attributes) {
      const _ = t.getAttribute(y),
        S = r.getAttribute(y);
      EV(_, S, u);
      const x = _.itemSize;
      for (let w = _.count, T = f; w < T; w++) {
        const E = u + w;
        for (let A = 0; A < x; A++) S.setComponent(E, A, 0);
      }
      (S.needsUpdate = !0), S.addUpdateRange(u * x, f * x);
    }
    if (i) {
      const y = l.indexStart;
      for (let _ = 0; _ < s.count; _++) o.setX(y + _, u + s.getX(_));
      for (let _ = s.count, S = l.indexCount; _ < S; _++) o.setX(y + _, u);
      (o.needsUpdate = !0), o.addUpdateRange(y, l.indexCount);
    }
    const h = this._bounds[e];
    t.boundingBox !== null
      ? (h.box.copy(t.boundingBox), (h.boxInitialized = !0))
      : (h.boxInitialized = !1),
      t.boundingSphere !== null
        ? (h.sphere.copy(t.boundingSphere), (h.sphereInitialized = !0))
        : (h.sphereInitialized = !1);
    const m = this._drawRanges[e],
      g = t.getAttribute("position");
    return (m.count = i ? s.count : g.count), (this._visibilityChanged = !0), e;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this._bounds[e],
      i = r.box,
      o = this.geometry;
    if (r.boxInitialized === !1) {
      i.makeEmpty();
      const s = o.index,
        l = o.attributes.position,
        u = this._drawRanges[e];
      for (let f = u.start, h = u.start + u.count; f < h; f++) {
        let m = f;
        s && (m = s.getX(m)), i.expandByPoint(Mp.fromBufferAttribute(l, m));
      }
      r.boxInitialized = !0;
    }
    return t.copy(i), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this._bounds[e],
      i = r.sphere,
      o = this.geometry;
    if (r.sphereInitialized === !1) {
      i.makeEmpty(), this.getBoundingBoxAt(e, gv), gv.getCenter(i.center);
      const s = o.index,
        l = o.attributes.position,
        u = this._drawRanges[e];
      let f = 0;
      for (let h = u.start, m = u.start + u.count; h < m; h++) {
        let g = h;
        s && (g = s.getX(g)),
          Mp.fromBufferAttribute(l, g),
          (f = Math.max(f, i.center.distanceToSquared(Mp)));
      }
      (i.radius = Math.sqrt(f)), (r.sphereInitialized = !0);
    }
    return t.copy(i), t;
  }
  setMatrixAt(e, t) {
    const r = this._drawInfo,
      i = this._matricesTexture,
      o = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1
      ? this
      : (t.toArray(o, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    const r = this._drawInfo,
      i = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1 ? null : t.fromArray(i, e * 16);
  }
  setColorAt(e, t) {
    this._colorsTexture === null && this._initColorsTexture();
    const r = this._colorsTexture,
      i = this._colorsTexture.image.data,
      o = this._drawInfo;
    return e >= o.length || o[e].active === !1
      ? this
      : (t.toArray(i, e * 4), (r.needsUpdate = !0), this);
  }
  getColorAt(e, t) {
    const r = this._colorsTexture.image.data,
      i = this._drawInfo;
    return e >= i.length || i[e].active === !1 ? null : t.fromArray(r, e * 4);
  }
  setVisibleAt(e, t) {
    const r = this._drawInfo;
    return e >= r.length || r[e].active === !1 || r[e].visible === t
      ? this
      : ((r[e].visible = t), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const t = this._drawInfo;
    return e >= t.length || t[e].active === !1 ? !1 : t[e].visible;
  }
  raycast(e, t) {
    const r = this._drawInfo,
      i = this._drawRanges,
      o = this.matrixWorld,
      s = this.geometry;
    ($i.material = this.material),
      ($i.geometry.index = s.index),
      ($i.geometry.attributes = s.attributes),
      $i.geometry.boundingBox === null && ($i.geometry.boundingBox = new Qi()),
      $i.geometry.boundingSphere === null &&
        ($i.geometry.boundingSphere = new Di());
    for (let l = 0, u = r.length; l < u; l++) {
      if (!r[l].visible || !r[l].active) continue;
      const f = r[l].geometryIndex,
        h = i[f];
      $i.geometry.setDrawRange(h.start, h.count),
        this.getMatrixAt(l, $i.matrixWorld).premultiply(o),
        this.getBoundingBoxAt(f, $i.geometry.boundingBox),
        this.getBoundingSphereAt(f, $i.geometry.boundingSphere),
        $i.raycast(e, vv);
      for (let m = 0, g = vv.length; m < g; m++) {
        const y = vv[m];
        (y.object = this), (y.batchId = l), t.push(y);
      }
      vv.length = 0;
    }
    ($i.material = null),
      ($i.geometry.index = null),
      ($i.geometry.attributes = {}),
      $i.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
      (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
      (this._drawInfo = e._drawInfo.map((t) => ({ ...t }))),
      (this._bounds = e._bounds.map((t) => ({
        boxInitialized: t.boxInitialized,
        box: t.box.clone(),
        sphereInitialized: t.sphereInitialized,
        sphere: t.sphere.clone(),
      }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, t, r, i, o) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const s = i.getIndex(),
      l = s === null ? 1 : s.array.BYTES_PER_ELEMENT,
      u = this._drawInfo,
      f = this._multiDrawStarts,
      h = this._multiDrawCounts,
      m = this._drawRanges,
      g = this.perObjectFrustumCulled,
      y = this._indirectTexture,
      _ = y.image.data;
    g &&
      (kE
        .multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse)
        .multiply(this.matrixWorld),
      N_.setFromProjectionMatrix(kE, e.coordinateSystem));
    let S = 0;
    if (this.sortObjects) {
      O_.copy(this.matrixWorld).invert(),
        Mp.setFromMatrixPosition(r.matrixWorld).applyMatrix4(O_),
        OE.set(0, 0, -1)
          .transformDirection(r.matrixWorld)
          .transformDirection(O_);
      for (let T = 0, E = u.length; T < E; T++)
        if (u[T].visible && u[T].active) {
          const A = u[T].geometryIndex;
          this.getMatrixAt(T, Au),
            this.getBoundingSphereAt(A, Ic).applyMatrix4(Au);
          let R = !1;
          if ((g && (R = !N_.intersectsSphere(Ic)), !R)) {
            const D = bV.subVectors(Ic.center, Mp).dot(OE);
            U_.push(m[A], D, T);
          }
        }
      const x = U_.list,
        w = this.customSort;
      w === null ? x.sort(o.transparent ? _V : xV) : w.call(this, x, r);
      for (let T = 0, E = x.length; T < E; T++) {
        const A = x[T];
        (f[S] = A.start * l), (h[S] = A.count), (_[S] = A.index), S++;
      }
      U_.reset();
    } else
      for (let x = 0, w = u.length; x < w; x++)
        if (u[x].visible && u[x].active) {
          const T = u[x].geometryIndex;
          let E = !1;
          if (
            (g &&
              (this.getMatrixAt(x, Au),
              this.getBoundingSphereAt(T, Ic).applyMatrix4(Au),
              (E = !N_.intersectsSphere(Ic))),
            !E)
          ) {
            const A = m[T];
            (f[S] = A.start * l), (h[S] = A.count), (_[S] = x), S++;
          }
        }
    (y.needsUpdate = !0),
      (this._multiDrawCount = S),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, r, i, o, s) {
    this.onBeforeRender(e, null, i, o, s);
  }
}
class mo extends ki {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const B0 = new ie(),
  V0 = new ie(),
  NE = new Wt(),
  bp = new hf(),
  yv = new Di(),
  F_ = new ie(),
  UE = new ie();
let Vu = class extends xn {
  constructor(e = new Kt(), t = new mo()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let i = 1, o = t.count; i < o; i++)
        B0.fromBufferAttribute(t, i - 1),
          V0.fromBufferAttribute(t, i),
          (r[i] = r[i - 1]),
          (r[i] += B0.distanceTo(V0));
      e.setAttribute("lineDistance", new Lt(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Line.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      yv.copy(r.boundingSphere),
      yv.applyMatrix4(i),
      (yv.radius += o),
      e.ray.intersectsSphere(yv) === !1)
    )
      return;
    NE.copy(i).invert(), bp.copy(e.ray).applyMatrix4(NE);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = l * l,
      f = this.isLineSegments ? 2 : 1,
      h = r.index,
      g = r.attributes.position;
    if (h !== null) {
      const y = Math.max(0, s.start),
        _ = Math.min(h.count, s.start + s.count);
      for (let S = y, x = _ - 1; S < x; S += f) {
        const w = h.getX(S),
          T = h.getX(S + 1),
          E = xv(this, e, bp, u, w, T);
        E && t.push(E);
      }
      if (this.isLineLoop) {
        const S = h.getX(_ - 1),
          x = h.getX(y),
          w = xv(this, e, bp, u, S, x);
        w && t.push(w);
      }
    } else {
      const y = Math.max(0, s.start),
        _ = Math.min(g.count, s.start + s.count);
      for (let S = y, x = _ - 1; S < x; S += f) {
        const w = xv(this, e, bp, u, S, S + 1);
        w && t.push(w);
      }
      if (this.isLineLoop) {
        const S = xv(this, e, bp, u, _ - 1, y);
        S && t.push(S);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const l = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
};
function xv(n, e, t, r, i, o) {
  const s = n.geometry.attributes.position;
  if (
    (B0.fromBufferAttribute(s, i),
    V0.fromBufferAttribute(s, o),
    t.distanceSqToSegment(B0, V0, F_, UE) > r)
  )
    return;
  F_.applyMatrix4(n.matrixWorld);
  const u = e.ray.origin.distanceTo(F_);
  if (!(u < e.near || u > e.far))
    return {
      distance: u,
      point: UE.clone().applyMatrix4(n.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: n,
    };
}
const FE = new ie(),
  zE = new ie();
class ja extends Vu {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        FE.fromBufferAttribute(t, i),
          zE.fromBufferAttribute(t, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + FE.distanceTo(zE));
      e.setAttribute("lineDistance", new Lt(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class BA extends Vu {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class ZS extends ki {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const BE = new Wt(),
  z1 = new hf(),
  _v = new Di(),
  Sv = new ie();
class VA extends xn {
  constructor(e = new Kt(), t = new ZS()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Points.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      _v.copy(r.boundingSphere),
      _v.applyMatrix4(i),
      (_v.radius += o),
      e.ray.intersectsSphere(_v) === !1)
    )
      return;
    BE.copy(i).invert(), z1.copy(e.ray).applyMatrix4(BE);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = l * l,
      f = r.index,
      m = r.attributes.position;
    if (f !== null) {
      const g = Math.max(0, s.start),
        y = Math.min(f.count, s.start + s.count);
      for (let _ = g, S = y; _ < S; _++) {
        const x = f.getX(_);
        Sv.fromBufferAttribute(m, x), VE(Sv, x, u, i, e, t, this);
      }
    } else {
      const g = Math.max(0, s.start),
        y = Math.min(m.count, s.start + s.count);
      for (let _ = g, S = y; _ < S; _++)
        Sv.fromBufferAttribute(m, _), VE(Sv, _, u, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const l = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
}
function VE(n, e, t, r, i, o, s) {
  const l = z1.distanceSqToPoint(n);
  if (l < t) {
    const u = new ie();
    z1.closestPointToPoint(n, u), u.applyMatrix4(r);
    const f = i.ray.origin.distanceTo(u);
    if (f < i.near || f > i.far) return;
    o.push({
      distance: f,
      distanceToRay: Math.sqrt(l),
      point: u,
      index: e,
      face: null,
      object: s,
    });
  }
}
class TV extends rr {
  constructor(e, t, r, i, o, s, l, u, f) {
    super(e, t, r, i, o, s, l, u, f),
      (this.isVideoTexture = !0),
      (this.minFilter = s !== void 0 ? s : br),
      (this.magFilter = o !== void 0 ? o : br),
      (this.generateMipmaps = !1);
    const h = this;
    function m() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(m);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(m);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class CV extends rr {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = yi),
      (this.minFilter = yi),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class Py extends rr {
  constructor(e, t, r, i, o, s, l, u, f, h, m, g) {
    super(null, s, l, u, f, h, i, o, m, g),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class AV extends Py {
  constructor(e, t, r, i, o, s) {
    super(e, t, r, o, s),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = Cs),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class RV extends Py {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, Il),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class PV extends rr {
  constructor(e, t, r, i, o, s, l, u, f) {
    super(e, t, r, i, o, s, l, u, f),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class ua {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      i = this.getPoint(0),
      o = 0;
    t.push(0);
    for (let s = 1; s <= e; s++)
      (r = this.getPoint(s / e)), (o += r.distanceTo(i)), t.push(o), (i = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const o = r.length;
    let s;
    t ? (s = t) : (s = e * r[o - 1]);
    let l = 0,
      u = o - 1,
      f;
    for (; l <= u; )
      if (((i = Math.floor(l + (u - l) / 2)), (f = r[i] - s), f < 0)) l = i + 1;
      else if (f > 0) u = i - 1;
      else {
        u = i;
        break;
      }
    if (((i = u), r[i] === s)) return i / (o - 1);
    const h = r[i],
      g = r[i + 1] - h,
      y = (s - h) / g;
    return (i + y) / (o - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const s = this.getPoint(i),
      l = this.getPoint(o),
      u = t || (s.isVector2 ? new tt() : new ie());
    return u.copy(l).sub(s).normalize(), u;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new ie(),
      i = [],
      o = [],
      s = [],
      l = new ie(),
      u = new Wt();
    for (let y = 0; y <= e; y++) {
      const _ = y / e;
      i[y] = this.getTangentAt(_, new ie());
    }
    (o[0] = new ie()), (s[0] = new ie());
    let f = Number.MAX_VALUE;
    const h = Math.abs(i[0].x),
      m = Math.abs(i[0].y),
      g = Math.abs(i[0].z);
    h <= f && ((f = h), r.set(1, 0, 0)),
      m <= f && ((f = m), r.set(0, 1, 0)),
      g <= f && r.set(0, 0, 1),
      l.crossVectors(i[0], r).normalize(),
      o[0].crossVectors(i[0], l),
      s[0].crossVectors(i[0], o[0]);
    for (let y = 1; y <= e; y++) {
      if (
        ((o[y] = o[y - 1].clone()),
        (s[y] = s[y - 1].clone()),
        l.crossVectors(i[y - 1], i[y]),
        l.length() > Number.EPSILON)
      ) {
        l.normalize();
        const _ = Math.acos(Mr(i[y - 1].dot(i[y]), -1, 1));
        o[y].applyMatrix4(u.makeRotationAxis(l, _));
      }
      s[y].crossVectors(i[y], o[y]);
    }
    if (t === !0) {
      let y = Math.acos(Mr(o[0].dot(o[e]), -1, 1));
      (y /= e), i[0].dot(l.crossVectors(o[0], o[e])) > 0 && (y = -y);
      for (let _ = 1; _ <= e; _++)
        o[_].applyMatrix4(u.makeRotationAxis(i[_], y * _)),
          s[_].crossVectors(i[_], o[_]);
    }
    return { tangents: i, normals: o, binormals: s };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Iy extends ua {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    i = 1,
    o = 0,
    s = Math.PI * 2,
    l = !1,
    u = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = o),
      (this.aEndAngle = s),
      (this.aClockwise = l),
      (this.aRotation = u);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const s = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (s ? (o = 0) : (o = i)),
      this.aClockwise === !0 && !s && (o === i ? (o = -i) : (o = o - i));
    const l = this.aStartAngle + e * o;
    let u = this.aX + this.xRadius * Math.cos(l),
      f = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        m = Math.sin(this.aRotation),
        g = u - this.aX,
        y = f - this.aY;
      (u = g * h - y * m + this.aX), (f = g * m + y * h + this.aY);
    }
    return r.set(u, f);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class HA extends Iy {
  constructor(e, t, r, i, o, s) {
    super(e, t, r, r, i, o, s),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function JS() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function i(o, s, l, u) {
    (n = o),
      (e = l),
      (t = -3 * o + 3 * s - 2 * l - u),
      (r = 2 * o - 2 * s + l + u);
  }
  return {
    initCatmullRom: function (o, s, l, u, f) {
      i(s, l, f * (l - o), f * (u - s));
    },
    initNonuniformCatmullRom: function (o, s, l, u, f, h, m) {
      let g = (s - o) / f - (l - o) / (f + h) + (l - s) / h,
        y = (l - s) / h - (u - s) / (h + m) + (u - l) / m;
      (g *= h), (y *= h), i(s, l, g, y);
    },
    calc: function (o) {
      const s = o * o,
        l = s * o;
      return n + e * o + t * s + r * l;
    },
  };
}
const wv = new ie(),
  z_ = new JS(),
  B_ = new JS(),
  V_ = new JS();
class GA extends ua {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, t = new ie()) {
    const r = t,
      i = this.points,
      o = i.length,
      s = (o - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(s),
      u = s - l;
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o)
      : u === 0 && l === o - 1 && ((l = o - 2), (u = 1));
    let f, h;
    this.closed || l > 0
      ? (f = i[(l - 1) % o])
      : (wv.subVectors(i[0], i[1]).add(i[0]), (f = wv));
    const m = i[l % o],
      g = i[(l + 1) % o];
    if (
      (this.closed || l + 2 < o
        ? (h = i[(l + 2) % o])
        : (wv.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), (h = wv)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const y = this.curveType === "chordal" ? 0.5 : 0.25;
      let _ = Math.pow(f.distanceToSquared(m), y),
        S = Math.pow(m.distanceToSquared(g), y),
        x = Math.pow(g.distanceToSquared(h), y);
      S < 1e-4 && (S = 1),
        _ < 1e-4 && (_ = S),
        x < 1e-4 && (x = S),
        z_.initNonuniformCatmullRom(f.x, m.x, g.x, h.x, _, S, x),
        B_.initNonuniformCatmullRom(f.y, m.y, g.y, h.y, _, S, x),
        V_.initNonuniformCatmullRom(f.z, m.z, g.z, h.z, _, S, x);
    } else
      this.curveType === "catmullrom" &&
        (z_.initCatmullRom(f.x, m.x, g.x, h.x, this.tension),
        B_.initCatmullRom(f.y, m.y, g.y, h.y, this.tension),
        V_.initCatmullRom(f.z, m.z, g.z, h.z, this.tension));
    return r.set(z_.calc(u), B_.calc(u), V_.calc(u)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new ie().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function HE(n, e, t, r, i) {
  const o = (r - e) * 0.5,
    s = (i - t) * 0.5,
    l = n * n,
    u = n * l;
  return (
    (2 * t - 2 * r + o + s) * u + (-3 * t + 3 * r - 2 * o - s) * l + o * n + t
  );
}
function IV(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function LV(n, e) {
  return 2 * (1 - n) * n * e;
}
function DV(n, e) {
  return n * n * e;
}
function Xp(n, e, t, r) {
  return IV(n, e) + LV(n, t) + DV(n, r);
}
function kV(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function OV(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function NV(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function UV(n, e) {
  return n * n * n * e;
}
function Yp(n, e, t, r, i) {
  return kV(n, e) + OV(n, t) + NV(n, r) + UV(n, i);
}
class QS extends ua {
  constructor(e = new tt(), t = new tt(), r = new tt(), i = new tt()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      l = this.v3;
    return r.set(Yp(e, i.x, o.x, s.x, l.x), Yp(e, i.y, o.y, s.y, l.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class WA extends ua {
  constructor(e = new ie(), t = new ie(), r = new ie(), i = new ie()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new ie()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      l = this.v3;
    return (
      r.set(
        Yp(e, i.x, o.x, s.x, l.x),
        Yp(e, i.y, o.y, s.y, l.y),
        Yp(e, i.z, o.z, s.z, l.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class ew extends ua {
  constructor(e = new tt(), t = new tt()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new tt()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new tt()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class jA extends ua {
  constructor(e = new ie(), t = new ie()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new ie()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ie()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class tw extends ua {
  constructor(e = new tt(), t = new tt(), r = new tt()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return r.set(Xp(e, i.x, o.x, s.x), Xp(e, i.y, o.y, s.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class nw extends ua {
  constructor(e = new ie(), t = new ie(), r = new ie()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new ie()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return (
      r.set(Xp(e, i.x, o.x, s.x), Xp(e, i.y, o.y, s.y), Xp(e, i.z, o.z, s.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class rw extends ua {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.points,
      o = (i.length - 1) * e,
      s = Math.floor(o),
      l = o - s,
      u = i[s === 0 ? s : s - 1],
      f = i[s],
      h = i[s > i.length - 2 ? i.length - 1 : s + 1],
      m = i[s > i.length - 3 ? i.length - 1 : s + 2];
    return r.set(HE(l, u.x, f.x, h.x, m.x), HE(l, u.y, f.y, h.y, m.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new tt().fromArray(i));
    }
    return this;
  }
}
var H0 = Object.freeze({
  __proto__: null,
  ArcCurve: HA,
  CatmullRomCurve3: GA,
  CubicBezierCurve: QS,
  CubicBezierCurve3: WA,
  EllipseCurve: Iy,
  LineCurve: ew,
  LineCurve3: jA,
  QuadraticBezierCurve: tw,
  QuadraticBezierCurve3: nw,
  SplineCurve: rw,
});
class $A extends ua {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new H0[r](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= r) {
        const s = i[o] - r,
          l = this.curves[o],
          u = l.getLength(),
          f = u === 0 ? 0 : 1 - s / u;
        return l.getPointAt(f, t);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const s = o[i],
        l = s.isEllipseCurve
          ? e * 2
          : s.isLineCurve || s.isLineCurve3
          ? 1
          : s.isSplineCurve
          ? e * s.points.length
          : e,
        u = s.getPoints(l);
      for (let f = 0; f < u.length; f++) {
        const h = u[f];
        (r && r.equals(h)) || (t.push(h), (r = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new H0[i.type]().fromJSON(i));
    }
    return this;
  }
}
class ym extends $A {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new tt()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new ew(this.currentPoint.clone(), new tt(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const o = new tw(this.currentPoint.clone(), new tt(e, t), new tt(r, i));
    return this.curves.push(o), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, s) {
    const l = new QS(
      this.currentPoint.clone(),
      new tt(e, t),
      new tt(r, i),
      new tt(o, s)
    );
    return this.curves.push(l), this.currentPoint.set(o, s), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new rw(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, o, s) {
    const l = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absarc(e + l, t + u, r, i, o, s), this;
  }
  absarc(e, t, r, i, o, s) {
    return this.absellipse(e, t, r, r, i, o, s), this;
  }
  ellipse(e, t, r, i, o, s, l, u) {
    const f = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + f, t + h, r, i, o, s, l, u), this;
  }
  absellipse(e, t, r, i, o, s, l, u) {
    const f = new Iy(e, t, r, i, o, s, l, u);
    if (this.curves.length > 0) {
      const m = f.getPoint(0);
      m.equals(this.currentPoint) || this.lineTo(m.x, m.y);
    }
    this.curves.push(f);
    const h = f.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class zm extends Kt {
  constructor(
    e = [new tt(0, -0.5), new tt(0.5, 0), new tt(0, 0.5)],
    t = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }),
      (t = Math.floor(t)),
      (i = Mr(i, 0, Math.PI * 2));
    const o = [],
      s = [],
      l = [],
      u = [],
      f = [],
      h = 1 / t,
      m = new ie(),
      g = new tt(),
      y = new ie(),
      _ = new ie(),
      S = new ie();
    let x = 0,
      w = 0;
    for (let T = 0; T <= e.length - 1; T++)
      switch (T) {
        case 0:
          (x = e[T + 1].x - e[T].x),
            (w = e[T + 1].y - e[T].y),
            (y.x = w * 1),
            (y.y = -x),
            (y.z = w * 0),
            S.copy(y),
            y.normalize(),
            u.push(y.x, y.y, y.z);
          break;
        case e.length - 1:
          u.push(S.x, S.y, S.z);
          break;
        default:
          (x = e[T + 1].x - e[T].x),
            (w = e[T + 1].y - e[T].y),
            (y.x = w * 1),
            (y.y = -x),
            (y.z = w * 0),
            _.copy(y),
            (y.x += S.x),
            (y.y += S.y),
            (y.z += S.z),
            y.normalize(),
            u.push(y.x, y.y, y.z),
            S.copy(_);
      }
    for (let T = 0; T <= t; T++) {
      const E = r + T * h * i,
        A = Math.sin(E),
        R = Math.cos(E);
      for (let D = 0; D <= e.length - 1; D++) {
        (m.x = e[D].x * A),
          (m.y = e[D].y),
          (m.z = e[D].x * R),
          s.push(m.x, m.y, m.z),
          (g.x = T / t),
          (g.y = D / (e.length - 1)),
          l.push(g.x, g.y);
        const I = u[3 * D + 0] * A,
          U = u[3 * D + 1],
          O = u[3 * D + 0] * R;
        f.push(I, U, O);
      }
    }
    for (let T = 0; T < t; T++)
      for (let E = 0; E < e.length - 1; E++) {
        const A = E + T * e.length,
          R = A,
          D = A + e.length,
          I = A + e.length + 1,
          U = A + 1;
        o.push(R, D, U), o.push(I, U, D);
      }
    this.setIndex(o),
      this.setAttribute("position", new Lt(s, 3)),
      this.setAttribute("uv", new Lt(l, 2)),
      this.setAttribute("normal", new Lt(f, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new zm(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Ly extends zm {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const o = new ym();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      o.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(o.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new Ly(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Dy extends Kt {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: r,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const o = [],
      s = [],
      l = [],
      u = [],
      f = new ie(),
      h = new tt();
    s.push(0, 0, 0), l.push(0, 0, 1), u.push(0.5, 0.5);
    for (let m = 0, g = 3; m <= t; m++, g += 3) {
      const y = r + (m / t) * i;
      (f.x = e * Math.cos(y)),
        (f.y = e * Math.sin(y)),
        s.push(f.x, f.y, f.z),
        l.push(0, 0, 1),
        (h.x = (s[g] / e + 1) / 2),
        (h.y = (s[g + 1] / e + 1) / 2),
        u.push(h.x, h.y);
    }
    for (let m = 1; m <= t; m++) o.push(m, m + 1, 0);
    this.setIndex(o),
      this.setAttribute("position", new Lt(s, 3)),
      this.setAttribute("normal", new Lt(l, 3)),
      this.setAttribute("uv", new Lt(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Dy(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class _h extends Kt {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    i = 32,
    o = 1,
    s = !1,
    l = 0,
    u = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: i,
        heightSegments: o,
        openEnded: s,
        thetaStart: l,
        thetaLength: u,
      });
    const f = this;
    (i = Math.floor(i)), (o = Math.floor(o));
    const h = [],
      m = [],
      g = [],
      y = [];
    let _ = 0;
    const S = [],
      x = r / 2;
    let w = 0;
    T(),
      s === !1 && (e > 0 && E(!0), t > 0 && E(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Lt(m, 3)),
      this.setAttribute("normal", new Lt(g, 3)),
      this.setAttribute("uv", new Lt(y, 2));
    function T() {
      const A = new ie(),
        R = new ie();
      let D = 0;
      const I = (t - e) / r;
      for (let U = 0; U <= o; U++) {
        const O = [],
          L = U / o,
          V = L * (t - e) + e;
        for (let H = 0; H <= i; H++) {
          const $ = H / i,
            q = $ * u + l,
            K = Math.sin(q),
            Y = Math.cos(q);
          (R.x = V * K),
            (R.y = -L * r + x),
            (R.z = V * Y),
            m.push(R.x, R.y, R.z),
            A.set(K, I, Y).normalize(),
            g.push(A.x, A.y, A.z),
            y.push($, 1 - L),
            O.push(_++);
        }
        S.push(O);
      }
      for (let U = 0; U < i; U++)
        for (let O = 0; O < o; O++) {
          const L = S[O][U],
            V = S[O + 1][U],
            H = S[O + 1][U + 1],
            $ = S[O][U + 1];
          h.push(L, V, $), h.push(V, H, $), (D += 6);
        }
      f.addGroup(w, D, 0), (w += D);
    }
    function E(A) {
      const R = _,
        D = new tt(),
        I = new ie();
      let U = 0;
      const O = A === !0 ? e : t,
        L = A === !0 ? 1 : -1;
      for (let H = 1; H <= i; H++)
        m.push(0, x * L, 0), g.push(0, L, 0), y.push(0.5, 0.5), _++;
      const V = _;
      for (let H = 0; H <= i; H++) {
        const q = (H / i) * u + l,
          K = Math.cos(q),
          Y = Math.sin(q);
        (I.x = O * Y),
          (I.y = x * L),
          (I.z = O * K),
          m.push(I.x, I.y, I.z),
          g.push(0, L, 0),
          (D.x = K * 0.5 + 0.5),
          (D.y = Y * 0.5 * L + 0.5),
          y.push(D.x, D.y),
          _++;
      }
      for (let H = 0; H < i; H++) {
        const $ = R + H,
          q = V + H;
        A === !0 ? h.push(q, q + 1, $) : h.push(q + 1, q, $), (U += 3);
      }
      f.addGroup(w, U, A === !0 ? 1 : 2), (w += U);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new _h(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ky extends _h {
  constructor(e = 1, t = 1, r = 32, i = 1, o = !1, s = 0, l = Math.PI * 2) {
    super(0, e, t, r, i, o, s, l),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: i,
        openEnded: o,
        thetaStart: s,
        thetaLength: l,
      });
  }
  static fromJSON(e) {
    return new ky(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Wu extends Kt {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: i });
    const o = [],
      s = [];
    l(i),
      f(r),
      h(),
      this.setAttribute("position", new Lt(o, 3)),
      this.setAttribute("normal", new Lt(o.slice(), 3)),
      this.setAttribute("uv", new Lt(s, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(T) {
      const E = new ie(),
        A = new ie(),
        R = new ie();
      for (let D = 0; D < t.length; D += 3)
        y(t[D + 0], E), y(t[D + 1], A), y(t[D + 2], R), u(E, A, R, T);
    }
    function u(T, E, A, R) {
      const D = R + 1,
        I = [];
      for (let U = 0; U <= D; U++) {
        I[U] = [];
        const O = T.clone().lerp(A, U / D),
          L = E.clone().lerp(A, U / D),
          V = D - U;
        for (let H = 0; H <= V; H++)
          H === 0 && U === D
            ? (I[U][H] = O)
            : (I[U][H] = O.clone().lerp(L, H / V));
      }
      for (let U = 0; U < D; U++)
        for (let O = 0; O < 2 * (D - U) - 1; O++) {
          const L = Math.floor(O / 2);
          O % 2 === 0
            ? (g(I[U][L + 1]), g(I[U + 1][L]), g(I[U][L]))
            : (g(I[U][L + 1]), g(I[U + 1][L + 1]), g(I[U + 1][L]));
        }
    }
    function f(T) {
      const E = new ie();
      for (let A = 0; A < o.length; A += 3)
        (E.x = o[A + 0]),
          (E.y = o[A + 1]),
          (E.z = o[A + 2]),
          E.normalize().multiplyScalar(T),
          (o[A + 0] = E.x),
          (o[A + 1] = E.y),
          (o[A + 2] = E.z);
    }
    function h() {
      const T = new ie();
      for (let E = 0; E < o.length; E += 3) {
        (T.x = o[E + 0]), (T.y = o[E + 1]), (T.z = o[E + 2]);
        const A = x(T) / 2 / Math.PI + 0.5,
          R = w(T) / Math.PI + 0.5;
        s.push(A, 1 - R);
      }
      _(), m();
    }
    function m() {
      for (let T = 0; T < s.length; T += 6) {
        const E = s[T + 0],
          A = s[T + 2],
          R = s[T + 4],
          D = Math.max(E, A, R),
          I = Math.min(E, A, R);
        D > 0.9 &&
          I < 0.1 &&
          (E < 0.2 && (s[T + 0] += 1),
          A < 0.2 && (s[T + 2] += 1),
          R < 0.2 && (s[T + 4] += 1));
      }
    }
    function g(T) {
      o.push(T.x, T.y, T.z);
    }
    function y(T, E) {
      const A = T * 3;
      (E.x = e[A + 0]), (E.y = e[A + 1]), (E.z = e[A + 2]);
    }
    function _() {
      const T = new ie(),
        E = new ie(),
        A = new ie(),
        R = new ie(),
        D = new tt(),
        I = new tt(),
        U = new tt();
      for (let O = 0, L = 0; O < o.length; O += 9, L += 6) {
        T.set(o[O + 0], o[O + 1], o[O + 2]),
          E.set(o[O + 3], o[O + 4], o[O + 5]),
          A.set(o[O + 6], o[O + 7], o[O + 8]),
          D.set(s[L + 0], s[L + 1]),
          I.set(s[L + 2], s[L + 3]),
          U.set(s[L + 4], s[L + 5]),
          R.copy(T).add(E).add(A).divideScalar(3);
        const V = x(R);
        S(D, L + 0, T, V), S(I, L + 2, E, V), S(U, L + 4, A, V);
      }
    }
    function S(T, E, A, R) {
      R < 0 && T.x === 1 && (s[E] = T.x - 1),
        A.x === 0 && A.z === 0 && (s[E] = R / 2 / Math.PI + 0.5);
    }
    function x(T) {
      return Math.atan2(T.z, -T.x);
    }
    function w(T) {
      return Math.atan2(-T.y, Math.sqrt(T.x * T.x + T.z * T.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Wu(e.vertices, e.indices, e.radius, e.details);
  }
}
class Oy extends Wu {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      o = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      s = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(o, s, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Oy(e.radius, e.detail);
  }
}
const Mv = new ie(),
  bv = new ie(),
  H_ = new ie(),
  Ev = new es();
class XA extends Kt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        o = Math.cos(Qc * t),
        s = e.getIndex(),
        l = e.getAttribute("position"),
        u = s ? s.count : l.count,
        f = [0, 0, 0],
        h = ["a", "b", "c"],
        m = new Array(3),
        g = {},
        y = [];
      for (let _ = 0; _ < u; _ += 3) {
        s
          ? ((f[0] = s.getX(_)), (f[1] = s.getX(_ + 1)), (f[2] = s.getX(_ + 2)))
          : ((f[0] = _), (f[1] = _ + 1), (f[2] = _ + 2));
        const { a: S, b: x, c: w } = Ev;
        if (
          (S.fromBufferAttribute(l, f[0]),
          x.fromBufferAttribute(l, f[1]),
          w.fromBufferAttribute(l, f[2]),
          Ev.getNormal(H_),
          (m[0] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${Math.round(
            S.z * i
          )}`),
          (m[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(
            x.z * i
          )}`),
          (m[2] = `${Math.round(w.x * i)},${Math.round(w.y * i)},${Math.round(
            w.z * i
          )}`),
          !(m[0] === m[1] || m[1] === m[2] || m[2] === m[0]))
        )
          for (let T = 0; T < 3; T++) {
            const E = (T + 1) % 3,
              A = m[T],
              R = m[E],
              D = Ev[h[T]],
              I = Ev[h[E]],
              U = `${A}_${R}`,
              O = `${R}_${A}`;
            O in g && g[O]
              ? (H_.dot(g[O].normal) <= o &&
                  (y.push(D.x, D.y, D.z), y.push(I.x, I.y, I.z)),
                (g[O] = null))
              : U in g ||
                (g[U] = { index0: f[T], index1: f[E], normal: H_.clone() });
          }
      }
      for (const _ in g)
        if (g[_]) {
          const { index0: S, index1: x } = g[_];
          Mv.fromBufferAttribute(l, S),
            bv.fromBufferAttribute(l, x),
            y.push(Mv.x, Mv.y, Mv.z),
            y.push(bv.x, bv.y, bv.z);
        }
      this.setAttribute("position", new Lt(y, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class tf extends ym {
  constructor(e) {
    super(e), (this.uuid = is()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new ym().fromJSON(i));
    }
    return this;
  }
}
const FV = {
  triangulate: function (n, e, t = 2) {
    const r = e && e.length,
      i = r ? e[0] * t : n.length;
    let o = YA(n, 0, i, t, !0);
    const s = [];
    if (!o || o.next === o.prev) return s;
    let l, u, f, h, m, g, y;
    if ((r && (o = GV(n, e, o, t)), n.length > 80 * t)) {
      (l = f = n[0]), (u = h = n[1]);
      for (let _ = t; _ < i; _ += t)
        (m = n[_]),
          (g = n[_ + 1]),
          m < l && (l = m),
          g < u && (u = g),
          m > f && (f = m),
          g > h && (h = g);
      (y = Math.max(f - l, h - u)), (y = y !== 0 ? 32767 / y : 0);
    }
    return xm(o, s, t, l, u, y, 0), s;
  },
};
function YA(n, e, t, r, i) {
  let o, s;
  if (i === eH(n, e, t, r) > 0)
    for (o = e; o < t; o += r) s = GE(o, n[o], n[o + 1], s);
  else for (o = t - r; o >= e; o -= r) s = GE(o, n[o], n[o + 1], s);
  return s && Ny(s, s.next) && (Sm(s), (s = s.next)), s;
}
function ff(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1), !t.steiner && (Ny(t, t.next) || fr(t.prev, t, t.next) === 0))
    ) {
      if ((Sm(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function xm(n, e, t, r, i, o, s) {
  if (!n) return;
  !s && o && YV(n, r, i, o);
  let l = n,
    u,
    f;
  for (; n.prev !== n.next; ) {
    if (((u = n.prev), (f = n.next), o ? BV(n, r, i, o) : zV(n))) {
      e.push((u.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((f.i / t) | 0),
        Sm(n),
        (n = f.next),
        (l = f.next);
      continue;
    }
    if (((n = f), n === l)) {
      s
        ? s === 1
          ? ((n = VV(ff(n), e, t)), xm(n, e, t, r, i, o, 2))
          : s === 2 && HV(n, e, t, r, i, o)
        : xm(ff(n), e, t, r, i, o, 1);
      break;
    }
  }
}
function zV(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (fr(e, t, r) >= 0) return !1;
  const i = e.x,
    o = t.x,
    s = r.x,
    l = e.y,
    u = t.y,
    f = r.y,
    h = i < o ? (i < s ? i : s) : o < s ? o : s,
    m = l < u ? (l < f ? l : f) : u < f ? u : f,
    g = i > o ? (i > s ? i : s) : o > s ? o : s,
    y = l > u ? (l > f ? l : f) : u > f ? u : f;
  let _ = r.next;
  for (; _ !== e; ) {
    if (
      _.x >= h &&
      _.x <= g &&
      _.y >= m &&
      _.y <= y &&
      Zd(i, l, o, u, s, f, _.x, _.y) &&
      fr(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.next;
  }
  return !0;
}
function BV(n, e, t, r) {
  const i = n.prev,
    o = n,
    s = n.next;
  if (fr(i, o, s) >= 0) return !1;
  const l = i.x,
    u = o.x,
    f = s.x,
    h = i.y,
    m = o.y,
    g = s.y,
    y = l < u ? (l < f ? l : f) : u < f ? u : f,
    _ = h < m ? (h < g ? h : g) : m < g ? m : g,
    S = l > u ? (l > f ? l : f) : u > f ? u : f,
    x = h > m ? (h > g ? h : g) : m > g ? m : g,
    w = B1(y, _, e, t, r),
    T = B1(S, x, e, t, r);
  let E = n.prevZ,
    A = n.nextZ;
  for (; E && E.z >= w && A && A.z <= T; ) {
    if (
      (E.x >= y &&
        E.x <= S &&
        E.y >= _ &&
        E.y <= x &&
        E !== i &&
        E !== s &&
        Zd(l, h, u, m, f, g, E.x, E.y) &&
        fr(E.prev, E, E.next) >= 0) ||
      ((E = E.prevZ),
      A.x >= y &&
        A.x <= S &&
        A.y >= _ &&
        A.y <= x &&
        A !== i &&
        A !== s &&
        Zd(l, h, u, m, f, g, A.x, A.y) &&
        fr(A.prev, A, A.next) >= 0)
    )
      return !1;
    A = A.nextZ;
  }
  for (; E && E.z >= w; ) {
    if (
      E.x >= y &&
      E.x <= S &&
      E.y >= _ &&
      E.y <= x &&
      E !== i &&
      E !== s &&
      Zd(l, h, u, m, f, g, E.x, E.y) &&
      fr(E.prev, E, E.next) >= 0
    )
      return !1;
    E = E.prevZ;
  }
  for (; A && A.z <= T; ) {
    if (
      A.x >= y &&
      A.x <= S &&
      A.y >= _ &&
      A.y <= x &&
      A !== i &&
      A !== s &&
      Zd(l, h, u, m, f, g, A.x, A.y) &&
      fr(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.nextZ;
  }
  return !0;
}
function VV(n, e, t) {
  let r = n;
  do {
    const i = r.prev,
      o = r.next.next;
    !Ny(i, o) &&
      qA(i, r, r.next, o) &&
      _m(i, o) &&
      _m(o, i) &&
      (e.push((i.i / t) | 0),
      e.push((r.i / t) | 0),
      e.push((o.i / t) | 0),
      Sm(r),
      Sm(r.next),
      (r = n = o)),
      (r = r.next);
  } while (r !== n);
  return ff(r);
}
function HV(n, e, t, r, i, o) {
  let s = n;
  do {
    let l = s.next.next;
    for (; l !== s.prev; ) {
      if (s.i !== l.i && ZV(s, l)) {
        let u = KA(s, l);
        (s = ff(s, s.next)),
          (u = ff(u, u.next)),
          xm(s, e, t, r, i, o, 0),
          xm(u, e, t, r, i, o, 0);
        return;
      }
      l = l.next;
    }
    s = s.next;
  } while (s !== n);
}
function GV(n, e, t, r) {
  const i = [];
  let o, s, l, u, f;
  for (o = 0, s = e.length; o < s; o++)
    (l = e[o] * r),
      (u = o < s - 1 ? e[o + 1] * r : n.length),
      (f = YA(n, l, u, r, !1)),
      f === f.next && (f.steiner = !0),
      i.push(KV(f));
  for (i.sort(WV), o = 0; o < i.length; o++) t = jV(i[o], t);
  return t;
}
function WV(n, e) {
  return n.x - e.x;
}
function jV(n, e) {
  const t = $V(n, e);
  if (!t) return e;
  const r = KA(t, n);
  return ff(r, r.next), ff(t, t.next);
}
function $V(n, e) {
  let t = e,
    r = -1 / 0,
    i;
  const o = n.x,
    s = n.y;
  do {
    if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
      const g = t.x + ((s - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        g <= o &&
        g > r &&
        ((r = g), (i = t.x < t.next.x ? t : t.next), g === o)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const l = i,
    u = i.x,
    f = i.y;
  let h = 1 / 0,
    m;
  t = i;
  do
    o >= t.x &&
      t.x >= u &&
      o !== t.x &&
      Zd(s < f ? o : r, s, u, f, s < f ? r : o, s, t.x, t.y) &&
      ((m = Math.abs(s - t.y) / (o - t.x)),
      _m(t, n) &&
        (m < h || (m === h && (t.x > i.x || (t.x === i.x && XV(i, t))))) &&
        ((i = t), (h = m))),
      (t = t.next);
  while (t !== l);
  return i;
}
function XV(n, e) {
  return fr(n.prev, n, e.prev) < 0 && fr(e.next, n, n.next) < 0;
}
function YV(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = B1(i.x, i.y, e, t, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== n);
  (i.prevZ.nextZ = null), (i.prevZ = null), qV(i);
}
function qV(n) {
  let e,
    t,
    r,
    i,
    o,
    s,
    l,
    u,
    f = 1;
  do {
    for (t = n, n = null, o = null, s = 0; t; ) {
      for (s++, r = t, l = 0, e = 0; e < f && (l++, (r = r.nextZ), !!r); e++);
      for (u = f; l > 0 || (u > 0 && r); )
        l !== 0 && (u === 0 || !r || t.z <= r.z)
          ? ((i = t), (t = t.nextZ), l--)
          : ((i = r), (r = r.nextZ), u--),
          o ? (o.nextZ = i) : (n = i),
          (i.prevZ = o),
          (o = i);
      t = r;
    }
    (o.nextZ = null), (f *= 2);
  } while (s > 1);
  return n;
}
function B1(n, e, t, r, i) {
  return (
    (n = ((n - t) * i) | 0),
    (e = ((e - r) * i) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function KV(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function Zd(n, e, t, r, i, o, s, l) {
  return (
    (i - s) * (e - l) >= (n - s) * (o - l) &&
    (n - s) * (r - l) >= (t - s) * (e - l) &&
    (t - s) * (o - l) >= (i - s) * (r - l)
  );
}
function ZV(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !JV(n, e) &&
    ((_m(n, e) &&
      _m(e, n) &&
      QV(n, e) &&
      (fr(n.prev, n, e.prev) || fr(n, e.prev, e))) ||
      (Ny(n, e) && fr(n.prev, n, n.next) > 0 && fr(e.prev, e, e.next) > 0))
  );
}
function fr(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function Ny(n, e) {
  return n.x === e.x && n.y === e.y;
}
function qA(n, e, t, r) {
  const i = Cv(fr(n, e, t)),
    o = Cv(fr(n, e, r)),
    s = Cv(fr(t, r, n)),
    l = Cv(fr(t, r, e));
  return !!(
    (i !== o && s !== l) ||
    (i === 0 && Tv(n, t, e)) ||
    (o === 0 && Tv(n, r, e)) ||
    (s === 0 && Tv(t, n, r)) ||
    (l === 0 && Tv(t, e, r))
  );
}
function Tv(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function Cv(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function JV(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      qA(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function _m(n, e) {
  return fr(n.prev, n, n.next) < 0
    ? fr(n, e, n.next) >= 0 && fr(n, n.prev, e) >= 0
    : fr(n, e, n.prev) < 0 || fr(n, n.next, e) < 0;
}
function QV(n, e) {
  let t = n,
    r = !1;
  const i = (n.x + e.x) / 2,
    o = (n.y + e.y) / 2;
  do
    t.y > o != t.next.y > o &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (o - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function KA(n, e) {
  const t = new V1(n.i, n.x, n.y),
    r = new V1(e.i, e.x, e.y),
    i = n.next,
    o = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = i),
    (i.prev = t),
    (r.next = t),
    (t.prev = r),
    (o.next = r),
    (r.prev = o),
    r
  );
}
function GE(n, e, t, r) {
  const i = new V1(n, e, t);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Sm(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function V1(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function eH(n, e, t, r) {
  let i = 0;
  for (let o = e, s = t - r; o < t; o += r)
    (i += (n[s] - n[o]) * (n[o + 1] + n[s + 1])), (s = o);
  return i;
}
class Ha {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, o = 0; o < t; i = o++)
      r += e[i].x * e[o].y - e[o].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Ha.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      i = [],
      o = [];
    WE(e), jE(r, e);
    let s = e.length;
    t.forEach(WE);
    for (let u = 0; u < t.length; u++)
      i.push(s), (s += t[u].length), jE(r, t[u]);
    const l = FV.triangulate(r, i);
    for (let u = 0; u < l.length; u += 3) o.push(l.slice(u, u + 3));
    return o;
  }
}
function WE(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function jE(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class Uy extends Kt {
  constructor(
    e = new tf([
      new tt(0.5, 0.5),
      new tt(-0.5, 0.5),
      new tt(-0.5, -0.5),
      new tt(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      o = [];
    for (let l = 0, u = e.length; l < u; l++) {
      const f = e[l];
      s(f);
    }
    this.setAttribute("position", new Lt(i, 3)),
      this.setAttribute("uv", new Lt(o, 2)),
      this.computeVertexNormals();
    function s(l) {
      const u = [],
        f = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        m = t.depth !== void 0 ? t.depth : 1;
      let g = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        y = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        _ = t.bevelSize !== void 0 ? t.bevelSize : y - 0.1,
        S = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const w = t.extrudePath,
        T = t.UVGenerator !== void 0 ? t.UVGenerator : tH;
      let E,
        A = !1,
        R,
        D,
        I,
        U;
      w &&
        ((E = w.getSpacedPoints(h)),
        (A = !0),
        (g = !1),
        (R = w.computeFrenetFrames(h, !1)),
        (D = new ie()),
        (I = new ie()),
        (U = new ie())),
        g || ((x = 0), (y = 0), (_ = 0), (S = 0));
      const O = l.extractPoints(f);
      let L = O.shape;
      const V = O.holes;
      if (!Ha.isClockWise(L)) {
        L = L.reverse();
        for (let W = 0, _e = V.length; W < _e; W++) {
          const Te = V[W];
          Ha.isClockWise(Te) && (V[W] = Te.reverse());
        }
      }
      const $ = Ha.triangulateShape(L, V),
        q = L;
      for (let W = 0, _e = V.length; W < _e; W++) {
        const Te = V[W];
        L = L.concat(Te);
      }
      function K(W, _e, Te) {
        return (
          _e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          W.clone().addScaledVector(_e, Te)
        );
      }
      const Y = L.length,
        ne = $.length;
      function j(W, _e, Te) {
        let ke, Pe, rt;
        const Le = W.x - _e.x,
          Xe = W.y - _e.y,
          Z = Te.x - W.x,
          F = Te.y - W.y,
          me = Le * Le + Xe * Xe,
          xe = Le * F - Xe * Z;
        if (Math.abs(xe) > Number.EPSILON) {
          const ye = Math.sqrt(me),
            Me = Math.sqrt(Z * Z + F * F),
            at = _e.x - Xe / ye,
            Fe = _e.y + Le / ye,
            ze = Te.x - F / Me,
            We = Te.y + Z / Me,
            Ye = ((ze - at) * F - (We - Fe) * Z) / (Le * F - Xe * Z);
          (ke = at + Le * Ye - W.x), (Pe = Fe + Xe * Ye - W.y);
          const nt = ke * ke + Pe * Pe;
          if (nt <= 2) return new tt(ke, Pe);
          rt = Math.sqrt(nt / 2);
        } else {
          let ye = !1;
          Le > Number.EPSILON
            ? Z > Number.EPSILON && (ye = !0)
            : Le < -Number.EPSILON
            ? Z < -Number.EPSILON && (ye = !0)
            : Math.sign(Xe) === Math.sign(F) && (ye = !0),
            ye
              ? ((ke = -Xe), (Pe = Le), (rt = Math.sqrt(me)))
              : ((ke = Le), (Pe = Xe), (rt = Math.sqrt(me / 2)));
        }
        return new tt(ke / rt, Pe / rt);
      }
      const re = [];
      for (
        let W = 0, _e = q.length, Te = _e - 1, ke = W + 1;
        W < _e;
        W++, Te++, ke++
      )
        Te === _e && (Te = 0),
          ke === _e && (ke = 0),
          (re[W] = j(q[W], q[Te], q[ke]));
      const B = [];
      let G,
        te = re.concat();
      for (let W = 0, _e = V.length; W < _e; W++) {
        const Te = V[W];
        G = [];
        for (
          let ke = 0, Pe = Te.length, rt = Pe - 1, Le = ke + 1;
          ke < Pe;
          ke++, rt++, Le++
        )
          rt === Pe && (rt = 0),
            Le === Pe && (Le = 0),
            (G[ke] = j(Te[ke], Te[rt], Te[Le]));
        B.push(G), (te = te.concat(G));
      }
      for (let W = 0; W < x; W++) {
        const _e = W / x,
          Te = y * Math.cos((_e * Math.PI) / 2),
          ke = _ * Math.sin((_e * Math.PI) / 2) + S;
        for (let Pe = 0, rt = q.length; Pe < rt; Pe++) {
          const Le = K(q[Pe], re[Pe], ke);
          ae(Le.x, Le.y, -Te);
        }
        for (let Pe = 0, rt = V.length; Pe < rt; Pe++) {
          const Le = V[Pe];
          G = B[Pe];
          for (let Xe = 0, Z = Le.length; Xe < Z; Xe++) {
            const F = K(Le[Xe], G[Xe], ke);
            ae(F.x, F.y, -Te);
          }
        }
      }
      const le = _ + S;
      for (let W = 0; W < Y; W++) {
        const _e = g ? K(L[W], te[W], le) : L[W];
        A
          ? (I.copy(R.normals[0]).multiplyScalar(_e.x),
            D.copy(R.binormals[0]).multiplyScalar(_e.y),
            U.copy(E[0]).add(I).add(D),
            ae(U.x, U.y, U.z))
          : ae(_e.x, _e.y, 0);
      }
      for (let W = 1; W <= h; W++)
        for (let _e = 0; _e < Y; _e++) {
          const Te = g ? K(L[_e], te[_e], le) : L[_e];
          A
            ? (I.copy(R.normals[W]).multiplyScalar(Te.x),
              D.copy(R.binormals[W]).multiplyScalar(Te.y),
              U.copy(E[W]).add(I).add(D),
              ae(U.x, U.y, U.z))
            : ae(Te.x, Te.y, (m / h) * W);
        }
      for (let W = x - 1; W >= 0; W--) {
        const _e = W / x,
          Te = y * Math.cos((_e * Math.PI) / 2),
          ke = _ * Math.sin((_e * Math.PI) / 2) + S;
        for (let Pe = 0, rt = q.length; Pe < rt; Pe++) {
          const Le = K(q[Pe], re[Pe], ke);
          ae(Le.x, Le.y, m + Te);
        }
        for (let Pe = 0, rt = V.length; Pe < rt; Pe++) {
          const Le = V[Pe];
          G = B[Pe];
          for (let Xe = 0, Z = Le.length; Xe < Z; Xe++) {
            const F = K(Le[Xe], G[Xe], ke);
            A
              ? ae(F.x, F.y + E[h - 1].y, E[h - 1].x + Te)
              : ae(F.x, F.y, m + Te);
          }
        }
      }
      J(), oe();
      function J() {
        const W = i.length / 3;
        if (g) {
          let _e = 0,
            Te = Y * _e;
          for (let ke = 0; ke < ne; ke++) {
            const Pe = $[ke];
            ue(Pe[2] + Te, Pe[1] + Te, Pe[0] + Te);
          }
          (_e = h + x * 2), (Te = Y * _e);
          for (let ke = 0; ke < ne; ke++) {
            const Pe = $[ke];
            ue(Pe[0] + Te, Pe[1] + Te, Pe[2] + Te);
          }
        } else {
          for (let _e = 0; _e < ne; _e++) {
            const Te = $[_e];
            ue(Te[2], Te[1], Te[0]);
          }
          for (let _e = 0; _e < ne; _e++) {
            const Te = $[_e];
            ue(Te[0] + Y * h, Te[1] + Y * h, Te[2] + Y * h);
          }
        }
        r.addGroup(W, i.length / 3 - W, 0);
      }
      function oe() {
        const W = i.length / 3;
        let _e = 0;
        he(q, _e), (_e += q.length);
        for (let Te = 0, ke = V.length; Te < ke; Te++) {
          const Pe = V[Te];
          he(Pe, _e), (_e += Pe.length);
        }
        r.addGroup(W, i.length / 3 - W, 1);
      }
      function he(W, _e) {
        let Te = W.length;
        for (; --Te >= 0; ) {
          const ke = Te;
          let Pe = Te - 1;
          Pe < 0 && (Pe = W.length - 1);
          for (let rt = 0, Le = h + x * 2; rt < Le; rt++) {
            const Xe = Y * rt,
              Z = Y * (rt + 1),
              F = _e + ke + Xe,
              me = _e + Pe + Xe,
              xe = _e + Pe + Z,
              ye = _e + ke + Z;
            Ee(F, me, xe, ye);
          }
        }
      }
      function ae(W, _e, Te) {
        u.push(W), u.push(_e), u.push(Te);
      }
      function ue(W, _e, Te) {
        Ne(W), Ne(_e), Ne(Te);
        const ke = i.length / 3,
          Pe = T.generateTopUV(r, i, ke - 3, ke - 2, ke - 1);
        Ae(Pe[0]), Ae(Pe[1]), Ae(Pe[2]);
      }
      function Ee(W, _e, Te, ke) {
        Ne(W), Ne(_e), Ne(ke), Ne(_e), Ne(Te), Ne(ke);
        const Pe = i.length / 3,
          rt = T.generateSideWallUV(r, i, Pe - 6, Pe - 3, Pe - 2, Pe - 1);
        Ae(rt[0]), Ae(rt[1]), Ae(rt[3]), Ae(rt[1]), Ae(rt[2]), Ae(rt[3]);
      }
      function Ne(W) {
        i.push(u[W * 3 + 0]), i.push(u[W * 3 + 1]), i.push(u[W * 3 + 2]);
      }
      function Ae(W) {
        o.push(W.x), o.push(W.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return nH(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let o = 0, s = e.shapes.length; o < s; o++) {
      const l = t[e.shapes[o]];
      r.push(l);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new H0[i.type]().fromJSON(i)),
      new Uy(r, e.options)
    );
  }
}
const tH = {
  generateTopUV: function (n, e, t, r, i) {
    const o = e[t * 3],
      s = e[t * 3 + 1],
      l = e[r * 3],
      u = e[r * 3 + 1],
      f = e[i * 3],
      h = e[i * 3 + 1];
    return [new tt(o, s), new tt(l, u), new tt(f, h)];
  },
  generateSideWallUV: function (n, e, t, r, i, o) {
    const s = e[t * 3],
      l = e[t * 3 + 1],
      u = e[t * 3 + 2],
      f = e[r * 3],
      h = e[r * 3 + 1],
      m = e[r * 3 + 2],
      g = e[i * 3],
      y = e[i * 3 + 1],
      _ = e[i * 3 + 2],
      S = e[o * 3],
      x = e[o * 3 + 1],
      w = e[o * 3 + 2];
    return Math.abs(l - h) < Math.abs(s - f)
      ? [new tt(s, 1 - u), new tt(f, 1 - m), new tt(g, 1 - _), new tt(S, 1 - w)]
      : [
          new tt(l, 1 - u),
          new tt(h, 1 - m),
          new tt(y, 1 - _),
          new tt(x, 1 - w),
        ];
  },
};
function nH(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      t.shapes.push(o.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Fy extends Wu {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      o = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, o, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Fy(e.radius, e.detail);
  }
}
class Bm extends Wu {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Bm(e.radius, e.detail);
  }
}
class zy extends Kt {
  constructor(e = 0.5, t = 1, r = 32, i = 1, o = 0, s = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: o,
        thetaLength: s,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const l = [],
      u = [],
      f = [],
      h = [];
    let m = e;
    const g = (t - e) / i,
      y = new ie(),
      _ = new tt();
    for (let S = 0; S <= i; S++) {
      for (let x = 0; x <= r; x++) {
        const w = o + (x / r) * s;
        (y.x = m * Math.cos(w)),
          (y.y = m * Math.sin(w)),
          u.push(y.x, y.y, y.z),
          f.push(0, 0, 1),
          (_.x = (y.x / t + 1) / 2),
          (_.y = (y.y / t + 1) / 2),
          h.push(_.x, _.y);
      }
      m += g;
    }
    for (let S = 0; S < i; S++) {
      const x = S * (r + 1);
      for (let w = 0; w < r; w++) {
        const T = w + x,
          E = T,
          A = T + r + 1,
          R = T + r + 2,
          D = T + 1;
        l.push(E, A, D), l.push(A, R, D);
      }
    }
    this.setIndex(l),
      this.setAttribute("position", new Lt(u, 3)),
      this.setAttribute("normal", new Lt(f, 3)),
      this.setAttribute("uv", new Lt(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new zy(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class By extends Kt {
  constructor(
    e = new tf([new tt(0, 0.5), new tt(-0.5, -0.5), new tt(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const r = [],
      i = [],
      o = [],
      s = [];
    let l = 0,
      u = 0;
    if (Array.isArray(e) === !1) f(e);
    else
      for (let h = 0; h < e.length; h++)
        f(e[h]), this.addGroup(l, u, h), (l += u), (u = 0);
    this.setIndex(r),
      this.setAttribute("position", new Lt(i, 3)),
      this.setAttribute("normal", new Lt(o, 3)),
      this.setAttribute("uv", new Lt(s, 2));
    function f(h) {
      const m = i.length / 3,
        g = h.extractPoints(t);
      let y = g.shape;
      const _ = g.holes;
      Ha.isClockWise(y) === !1 && (y = y.reverse());
      for (let x = 0, w = _.length; x < w; x++) {
        const T = _[x];
        Ha.isClockWise(T) === !0 && (_[x] = T.reverse());
      }
      const S = Ha.triangulateShape(y, _);
      for (let x = 0, w = _.length; x < w; x++) {
        const T = _[x];
        y = y.concat(T);
      }
      for (let x = 0, w = y.length; x < w; x++) {
        const T = y[x];
        i.push(T.x, T.y, 0), o.push(0, 0, 1), s.push(T.x, T.y);
      }
      for (let x = 0, w = S.length; x < w; x++) {
        const T = S[x],
          E = T[0] + m,
          A = T[1] + m,
          R = T[2] + m;
        r.push(E, A, R), (u += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return rH(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const s = t[e.shapes[i]];
      r.push(s);
    }
    return new By(r, e.curveSegments);
  }
}
function rH(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class Vm extends Kt {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    i = 0,
    o = Math.PI * 2,
    s = 0,
    l = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: i,
        phiLength: o,
        thetaStart: s,
        thetaLength: l,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const u = Math.min(s + l, Math.PI);
    let f = 0;
    const h = [],
      m = new ie(),
      g = new ie(),
      y = [],
      _ = [],
      S = [],
      x = [];
    for (let w = 0; w <= r; w++) {
      const T = [],
        E = w / r;
      let A = 0;
      w === 0 && s === 0
        ? (A = 0.5 / t)
        : w === r && u === Math.PI && (A = -0.5 / t);
      for (let R = 0; R <= t; R++) {
        const D = R / t;
        (m.x = -e * Math.cos(i + D * o) * Math.sin(s + E * l)),
          (m.y = e * Math.cos(s + E * l)),
          (m.z = e * Math.sin(i + D * o) * Math.sin(s + E * l)),
          _.push(m.x, m.y, m.z),
          g.copy(m).normalize(),
          S.push(g.x, g.y, g.z),
          x.push(D + A, 1 - E),
          T.push(f++);
      }
      h.push(T);
    }
    for (let w = 0; w < r; w++)
      for (let T = 0; T < t; T++) {
        const E = h[w][T + 1],
          A = h[w][T],
          R = h[w + 1][T],
          D = h[w + 1][T + 1];
        (w !== 0 || s > 0) && y.push(E, A, D),
          (w !== r - 1 || u < Math.PI) && y.push(A, R, D);
      }
    this.setIndex(y),
      this.setAttribute("position", new Lt(_, 3)),
      this.setAttribute("normal", new Lt(S, 3)),
      this.setAttribute("uv", new Lt(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Vm(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Vy extends Wu {
  constructor(e = 1, t = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Vy(e.radius, e.detail);
  }
}
class Hy extends Kt {
  constructor(e = 1, t = 0.4, r = 12, i = 48, o = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: i,
        arc: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const s = [],
      l = [],
      u = [],
      f = [],
      h = new ie(),
      m = new ie(),
      g = new ie();
    for (let y = 0; y <= r; y++)
      for (let _ = 0; _ <= i; _++) {
        const S = (_ / i) * o,
          x = (y / r) * Math.PI * 2;
        (m.x = (e + t * Math.cos(x)) * Math.cos(S)),
          (m.y = (e + t * Math.cos(x)) * Math.sin(S)),
          (m.z = t * Math.sin(x)),
          l.push(m.x, m.y, m.z),
          (h.x = e * Math.cos(S)),
          (h.y = e * Math.sin(S)),
          g.subVectors(m, h).normalize(),
          u.push(g.x, g.y, g.z),
          f.push(_ / i),
          f.push(y / r);
      }
    for (let y = 1; y <= r; y++)
      for (let _ = 1; _ <= i; _++) {
        const S = (i + 1) * y + _ - 1,
          x = (i + 1) * (y - 1) + _ - 1,
          w = (i + 1) * (y - 1) + _,
          T = (i + 1) * y + _;
        s.push(S, x, T), s.push(x, w, T);
      }
    this.setIndex(s),
      this.setAttribute("position", new Lt(l, 3)),
      this.setAttribute("normal", new Lt(u, 3)),
      this.setAttribute("uv", new Lt(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Hy(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Gy extends Kt {
  constructor(e = 1, t = 0.4, r = 64, i = 8, o = 2, s = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: r,
        radialSegments: i,
        p: o,
        q: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const l = [],
      u = [],
      f = [],
      h = [],
      m = new ie(),
      g = new ie(),
      y = new ie(),
      _ = new ie(),
      S = new ie(),
      x = new ie(),
      w = new ie();
    for (let E = 0; E <= r; ++E) {
      const A = (E / r) * o * Math.PI * 2;
      T(A, o, s, e, y),
        T(A + 0.01, o, s, e, _),
        x.subVectors(_, y),
        w.addVectors(_, y),
        S.crossVectors(x, w),
        w.crossVectors(S, x),
        S.normalize(),
        w.normalize();
      for (let R = 0; R <= i; ++R) {
        const D = (R / i) * Math.PI * 2,
          I = -t * Math.cos(D),
          U = t * Math.sin(D);
        (m.x = y.x + (I * w.x + U * S.x)),
          (m.y = y.y + (I * w.y + U * S.y)),
          (m.z = y.z + (I * w.z + U * S.z)),
          u.push(m.x, m.y, m.z),
          g.subVectors(m, y).normalize(),
          f.push(g.x, g.y, g.z),
          h.push(E / r),
          h.push(R / i);
      }
    }
    for (let E = 1; E <= r; E++)
      for (let A = 1; A <= i; A++) {
        const R = (i + 1) * (E - 1) + (A - 1),
          D = (i + 1) * E + (A - 1),
          I = (i + 1) * E + A,
          U = (i + 1) * (E - 1) + A;
        l.push(R, D, U), l.push(D, I, U);
      }
    this.setIndex(l),
      this.setAttribute("position", new Lt(u, 3)),
      this.setAttribute("normal", new Lt(f, 3)),
      this.setAttribute("uv", new Lt(h, 2));
    function T(E, A, R, D, I) {
      const U = Math.cos(E),
        O = Math.sin(E),
        L = (R / A) * E,
        V = Math.cos(L);
      (I.x = D * (2 + V) * 0.5 * U),
        (I.y = D * (2 + V) * O * 0.5),
        (I.z = D * Math.sin(L) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Gy(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class Wy extends Kt {
  constructor(
    e = new nw(new ie(-1, -1, 0), new ie(-1, 1, 0), new ie(1, 1, 0)),
    t = 64,
    r = 1,
    i = 8,
    o = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: i,
        closed: o,
      });
    const s = e.computeFrenetFrames(t, o);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals);
    const l = new ie(),
      u = new ie(),
      f = new tt();
    let h = new ie();
    const m = [],
      g = [],
      y = [],
      _ = [];
    S(),
      this.setIndex(_),
      this.setAttribute("position", new Lt(m, 3)),
      this.setAttribute("normal", new Lt(g, 3)),
      this.setAttribute("uv", new Lt(y, 2));
    function S() {
      for (let E = 0; E < t; E++) x(E);
      x(o === !1 ? t : 0), T(), w();
    }
    function x(E) {
      h = e.getPointAt(E / t, h);
      const A = s.normals[E],
        R = s.binormals[E];
      for (let D = 0; D <= i; D++) {
        const I = (D / i) * Math.PI * 2,
          U = Math.sin(I),
          O = -Math.cos(I);
        (u.x = O * A.x + U * R.x),
          (u.y = O * A.y + U * R.y),
          (u.z = O * A.z + U * R.z),
          u.normalize(),
          g.push(u.x, u.y, u.z),
          (l.x = h.x + r * u.x),
          (l.y = h.y + r * u.y),
          (l.z = h.z + r * u.z),
          m.push(l.x, l.y, l.z);
      }
    }
    function w() {
      for (let E = 1; E <= t; E++)
        for (let A = 1; A <= i; A++) {
          const R = (i + 1) * (E - 1) + (A - 1),
            D = (i + 1) * E + (A - 1),
            I = (i + 1) * E + A,
            U = (i + 1) * (E - 1) + A;
          _.push(R, D, U), _.push(D, I, U);
        }
    }
    function T() {
      for (let E = 0; E <= t; E++)
        for (let A = 0; A <= i; A++)
          (f.x = E / t), (f.y = A / i), y.push(f.x, f.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new Wy(
      new H0[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class ZA extends Kt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        r = new Set(),
        i = new ie(),
        o = new ie();
      if (e.index !== null) {
        const s = e.attributes.position,
          l = e.index;
        let u = e.groups;
        u.length === 0 &&
          (u = [{ start: 0, count: l.count, materialIndex: 0 }]);
        for (let f = 0, h = u.length; f < h; ++f) {
          const m = u[f],
            g = m.start,
            y = m.count;
          for (let _ = g, S = g + y; _ < S; _ += 3)
            for (let x = 0; x < 3; x++) {
              const w = l.getX(_ + x),
                T = l.getX(_ + ((x + 1) % 3));
              i.fromBufferAttribute(s, w),
                o.fromBufferAttribute(s, T),
                $E(i, o, r) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const s = e.attributes.position;
        for (let l = 0, u = s.count / 3; l < u; l++)
          for (let f = 0; f < 3; f++) {
            const h = 3 * l + f,
              m = 3 * l + ((f + 1) % 3);
            i.fromBufferAttribute(s, h),
              o.fromBufferAttribute(s, m),
              $E(i, o, r) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new Lt(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function $E(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var XE = Object.freeze({
  __proto__: null,
  BoxGeometry: pf,
  CapsuleGeometry: Ly,
  CircleGeometry: Dy,
  ConeGeometry: ky,
  CylinderGeometry: _h,
  DodecahedronGeometry: Oy,
  EdgesGeometry: XA,
  ExtrudeGeometry: Uy,
  IcosahedronGeometry: Fy,
  LatheGeometry: zm,
  OctahedronGeometry: Bm,
  PlaneGeometry: Ul,
  PolyhedronGeometry: Wu,
  RingGeometry: zy,
  ShapeGeometry: By,
  SphereGeometry: Vm,
  TetrahedronGeometry: Vy,
  TorusGeometry: Hy,
  TorusKnotGeometry: Gy,
  TubeGeometry: Wy,
  WireframeGeometry: ZA,
});
class JA extends ki {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new St(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class QA extends la {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class iw extends ki {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new St(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Gu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ss()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class eR extends iw {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new tt(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Mr((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new St(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new St(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new St(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class tR extends ki {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new St(16777215)),
      (this.specular = new St(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Gu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ss()),
      (this.combine = Dm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class nR extends ki {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Gu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class rR extends ki {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Gu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class iR extends ki {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Gu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ss()),
      (this.combine = Dm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class oR extends ki {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new St(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Gu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class sR extends mo {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function Kc(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function aR(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function lR(n) {
  function e(i, o) {
    return n[i] - n[o];
  }
  const t = n.length,
    r = new Array(t);
  for (let i = 0; i !== t; ++i) r[i] = i;
  return r.sort(e), r;
}
function H1(n, e, t) {
  const r = n.length,
    i = new n.constructor(r);
  for (let o = 0, s = 0; s !== r; ++o) {
    const l = t[o] * e;
    for (let u = 0; u !== e; ++u) i[s++] = n[l + u];
  }
  return i;
}
function ow(n, e, t, r) {
  let i = 1,
    o = n[0];
  for (; o !== void 0 && o[r] === void 0; ) o = n[i++];
  if (o === void 0) return;
  let s = o[r];
  if (s !== void 0)
    if (Array.isArray(s))
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), t.push.apply(t, s)),
          (o = n[i++]);
      while (o !== void 0);
    else if (s.toArray !== void 0)
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), s.toArray(t, t.length)),
          (o = n[i++]);
      while (o !== void 0);
    else
      do (s = o[r]), s !== void 0 && (e.push(o.time), t.push(s)), (o = n[i++]);
      while (o !== void 0);
}
function iH(n, e, t, r, i = 30) {
  const o = n.clone();
  o.name = e;
  const s = [];
  for (let u = 0; u < o.tracks.length; ++u) {
    const f = o.tracks[u],
      h = f.getValueSize(),
      m = [],
      g = [];
    for (let y = 0; y < f.times.length; ++y) {
      const _ = f.times[y] * i;
      if (!(_ < t || _ >= r)) {
        m.push(f.times[y]);
        for (let S = 0; S < h; ++S) g.push(f.values[y * h + S]);
      }
    }
    m.length !== 0 &&
      ((f.times = Kc(m, f.times.constructor)),
      (f.values = Kc(g, f.values.constructor)),
      s.push(f));
  }
  o.tracks = s;
  let l = 1 / 0;
  for (let u = 0; u < o.tracks.length; ++u)
    l > o.tracks[u].times[0] && (l = o.tracks[u].times[0]);
  for (let u = 0; u < o.tracks.length; ++u) o.tracks[u].shift(-1 * l);
  return o.resetDuration(), o;
}
function oH(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length,
    o = e / r;
  for (let s = 0; s < i; ++s) {
    const l = t.tracks[s],
      u = l.ValueTypeName;
    if (u === "bool" || u === "string") continue;
    const f = n.tracks.find(function (w) {
      return w.name === l.name && w.ValueTypeName === u;
    });
    if (f === void 0) continue;
    let h = 0;
    const m = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = m / 3);
    let g = 0;
    const y = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (g = y / 3);
    const _ = l.times.length - 1;
    let S;
    if (o <= l.times[0]) {
      const w = h,
        T = m - h;
      S = l.values.slice(w, T);
    } else if (o >= l.times[_]) {
      const w = _ * m + h,
        T = w + m - h;
      S = l.values.slice(w, T);
    } else {
      const w = l.createInterpolant(),
        T = h,
        E = m - h;
      w.evaluate(o), (S = w.resultBuffer.slice(T, E));
    }
    u === "quaternion" &&
      new Ji().fromArray(S).normalize().conjugate().toArray(S);
    const x = f.times.length;
    for (let w = 0; w < x; ++w) {
      const T = w * y + g;
      if (u === "quaternion")
        Ji.multiplyQuaternionsFlat(f.values, T, S, 0, f.values, T);
      else {
        const E = y - g * 2;
        for (let A = 0; A < E; ++A) f.values[T + A] -= S[A];
      }
    }
  }
  return (n.blendMode = zS), n;
}
const sH = {
  convertArray: Kc,
  isTypedArray: aR,
  getKeyframeOrder: lR,
  sortedArray: H1,
  flattenJSON: ow,
  subclip: iH,
  makeClipAdditive: oH,
};
class Hm {
  constructor(e, t, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(r)),
      (this.sampleValues = t),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex,
      i = t[r],
      o = t[r - 1];
    e: {
      t: {
        let s;
        n: {
          r: if (!(e < i)) {
            for (let l = r + 2; ; ) {
              if (i === void 0) {
                if (e < o) break r;
                return (
                  (r = t.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === l) break;
              if (((o = i), (i = t[++r]), e < i)) break t;
            }
            s = t.length;
            break n;
          }
          if (!(e >= o)) {
            const l = t[1];
            e < l && ((r = 2), (o = l));
            for (let u = r - 2; ; ) {
              if (o === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === u) break;
              if (((i = o), (o = t[--r - 1]), e >= o)) break t;
            }
            (s = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < s; ) {
          const l = (r + s) >>> 1;
          e < t[l] ? (s = l) : (r = l + 1);
        }
        if (((i = t[r]), (o = t[r - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = t.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, o, i);
    }
    return this.interpolate_(r, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      o = e * i;
    for (let s = 0; s !== i; ++s) t[s] = r[o + s];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class uR extends Hm {
  constructor(e, t, r, i) {
    super(e, t, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Xc, endingEnd: Xc });
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let o = e - 2,
      s = e + 1,
      l = i[o],
      u = i[s];
    if (l === void 0)
      switch (this.getSettings_().endingStart) {
        case Yc:
          (o = e), (l = 2 * t - r);
          break;
        case fm:
          (o = i.length - 2), (l = t + i[o] - i[o + 1]);
          break;
        default:
          (o = e), (l = r);
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case Yc:
          (s = e), (u = 2 * r - t);
          break;
        case fm:
          (s = 1), (u = r + i[1] - i[0]);
          break;
        default:
          (s = e - 1), (u = t);
      }
    const f = (r - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = f / (t - l)),
      (this._weightNext = f / (u - r)),
      (this._offsetPrev = o * h),
      (this._offsetNext = s * h);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      l = this.valueSize,
      u = e * l,
      f = u - l,
      h = this._offsetPrev,
      m = this._offsetNext,
      g = this._weightPrev,
      y = this._weightNext,
      _ = (r - t) / (i - t),
      S = _ * _,
      x = S * _,
      w = -g * x + 2 * g * S - g * _,
      T = (1 + g) * x + (-1.5 - 2 * g) * S + (-0.5 + g) * _ + 1,
      E = (-1 - y) * x + (1.5 + y) * S + 0.5 * _,
      A = y * x - y * S;
    for (let R = 0; R !== l; ++R)
      o[R] = w * s[h + R] + T * s[f + R] + E * s[u + R] + A * s[m + R];
    return o;
  }
}
class sw extends Hm {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      l = this.valueSize,
      u = e * l,
      f = u - l,
      h = (r - t) / (i - t),
      m = 1 - h;
    for (let g = 0; g !== l; ++g) o[g] = s[f + g] * m + s[u + g] * h;
    return o;
  }
}
class cR extends Hm {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ca {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Kc(t, this.TimeBufferType)),
      (this.values = Kc(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON) r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: Kc(e.times, Array),
        values: Kc(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new cR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new sw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new uR(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case cm:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case F0:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Xv:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return cm;
      case this.InterpolantFactoryMethodLinear:
        return F0;
      case this.InterpolantFactoryMethodSmooth:
        return Xv;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times,
      i = r.length;
    let o = 0,
      s = i - 1;
    for (; o !== i && r[o] < e; ) ++o;
    for (; s !== -1 && r[s] > t; ) --s;
    if ((++s, o !== 0 || s !== i)) {
      o >= s && ((s = Math.max(s, 1)), (o = s - 1));
      const l = this.getValueSize();
      (this.times = r.slice(o, s)),
        (this.values = this.values.slice(o * l, s * l));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      o = r.length;
    o === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let s = null;
    for (let l = 0; l !== o; l++) {
      const u = r[l];
      if (typeof u == "number" && isNaN(u)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          l,
          u
        ),
          (e = !1);
        break;
      }
      if (s !== null && s > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, l, u, s),
          (e = !1);
        break;
      }
      s = u;
    }
    if (i !== void 0 && aR(i))
      for (let l = 0, u = i.length; l !== u; ++l) {
        const f = i[l];
        if (isNaN(f)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            l,
            f
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === Xv,
      o = e.length - 1;
    let s = 1;
    for (let l = 1; l < o; ++l) {
      let u = !1;
      const f = e[l],
        h = e[l + 1];
      if (f !== h && (l !== 1 || f !== e[0]))
        if (i) u = !0;
        else {
          const m = l * r,
            g = m - r,
            y = m + r;
          for (let _ = 0; _ !== r; ++_) {
            const S = t[m + _];
            if (S !== t[g + _] || S !== t[y + _]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (l !== s) {
          e[s] = e[l];
          const m = l * r,
            g = s * r;
          for (let y = 0; y !== r; ++y) t[g + y] = t[m + y];
        }
        ++s;
      }
    }
    if (o > 0) {
      e[s] = e[o];
      for (let l = o * r, u = s * r, f = 0; f !== r; ++f) t[u + f] = t[l + f];
      ++s;
    }
    return (
      s !== e.length
        ? ((this.times = e.slice(0, s)), (this.values = t.slice(0, s * r)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
ca.prototype.TimeBufferType = Float32Array;
ca.prototype.ValueBufferType = Float32Array;
ca.prototype.DefaultInterpolation = F0;
class mf extends ca {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
mf.prototype.ValueTypeName = "bool";
mf.prototype.ValueBufferType = Array;
mf.prototype.DefaultInterpolation = cm;
mf.prototype.InterpolantFactoryMethodLinear = void 0;
mf.prototype.InterpolantFactoryMethodSmooth = void 0;
class aw extends ca {}
aw.prototype.ValueTypeName = "color";
class wm extends ca {}
wm.prototype.ValueTypeName = "number";
class fR extends Hm {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      l = this.valueSize,
      u = (r - t) / (i - t);
    let f = e * l;
    for (let h = f + l; f !== h; f += 4) Ji.slerpFlat(o, 0, s, f - l, s, f, u);
    return o;
  }
}
class Gm extends ca {
  InterpolantFactoryMethodLinear(e) {
    return new fR(this.times, this.values, this.getValueSize(), e);
  }
}
Gm.prototype.ValueTypeName = "quaternion";
Gm.prototype.InterpolantFactoryMethodSmooth = void 0;
class gf extends ca {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
gf.prototype.ValueTypeName = "string";
gf.prototype.ValueBufferType = Array;
gf.prototype.DefaultInterpolation = cm;
gf.prototype.InterpolantFactoryMethodLinear = void 0;
gf.prototype.InterpolantFactoryMethodSmooth = void 0;
class Mm extends ca {}
Mm.prototype.ValueTypeName = "vector";
class bm {
  constructor(e = "", t = -1, r = [], i = _y) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = is()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let s = 0, l = r.length; s !== l; ++s) t.push(lH(r[s]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const t = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let o = 0, s = r.length; o !== s; ++o) t.push(ca.toJSON(r[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const o = t.length,
      s = [];
    for (let l = 0; l < o; l++) {
      let u = [],
        f = [];
      u.push((l + o - 1) % o, l, (l + 1) % o), f.push(0, 1, 0);
      const h = lR(u);
      (u = H1(u, 1, h)),
        (f = H1(f, 1, h)),
        !i && u[0] === 0 && (u.push(o), f.push(f[0])),
        s.push(
          new wm(".morphTargetInfluences[" + t[l].name + "]", u, f).scale(1 / r)
        );
    }
    return new this(e, -1, s);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let l = 0, u = e.length; l < u; l++) {
      const f = e[l],
        h = f.name.match(o);
      if (h && h.length > 1) {
        const m = h[1];
        let g = i[m];
        g || (i[m] = g = []), g.push(f);
      }
    }
    const s = [];
    for (const l in i)
      s.push(this.CreateFromMorphTargetSequence(l, i[l], t, r));
    return s;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (m, g, y, _, S) {
        if (y.length !== 0) {
          const x = [],
            w = [];
          ow(y, x, w, _), x.length !== 0 && S.push(new m(g, x, w));
        }
      },
      i = [],
      o = e.name || "default",
      s = e.fps || 30,
      l = e.blendMode;
    let u = e.length || -1;
    const f = e.hierarchy || [];
    for (let m = 0; m < f.length; m++) {
      const g = f[m].keys;
      if (!(!g || g.length === 0))
        if (g[0].morphTargets) {
          const y = {};
          let _;
          for (_ = 0; _ < g.length; _++)
            if (g[_].morphTargets)
              for (let S = 0; S < g[_].morphTargets.length; S++)
                y[g[_].morphTargets[S]] = -1;
          for (const S in y) {
            const x = [],
              w = [];
            for (let T = 0; T !== g[_].morphTargets.length; ++T) {
              const E = g[_];
              x.push(E.time), w.push(E.morphTarget === S ? 1 : 0);
            }
            i.push(new wm(".morphTargetInfluence[" + S + "]", x, w));
          }
          u = y.length * s;
        } else {
          const y = ".bones[" + t[m].name + "]";
          r(Mm, y + ".position", g, "pos", i),
            r(Gm, y + ".quaternion", g, "rot", i),
            r(Mm, y + ".scale", g, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(o, u, i, l);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const o = this.tracks[r];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function aH(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return wm;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Mm;
    case "color":
      return aw;
    case "quaternion":
      return Gm;
    case "bool":
    case "boolean":
      return mf;
    case "string":
      return gf;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function lH(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = aH(n.type);
  if (n.times === void 0) {
    const t = [],
      r = [];
    ow(n.keys, t, r, "value"), (n.times = t), (n.values = r);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Cl = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class lw {
  constructor(e, t, r) {
    const i = this;
    let o = !1,
      s = 0,
      l = 0,
      u;
    const f = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (h) {
        l++, o === !1 && i.onStart !== void 0 && i.onStart(h, s, l), (o = !0);
      }),
      (this.itemEnd = function (h) {
        s++,
          i.onProgress !== void 0 && i.onProgress(h, s, l),
          s === l && ((o = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (h) {
        i.onError !== void 0 && i.onError(h);
      }),
      (this.resolveURL = function (h) {
        return u ? u(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (u = h), this;
      }),
      (this.addHandler = function (h, m) {
        return f.push(h, m), this;
      }),
      (this.removeHandler = function (h) {
        const m = f.indexOf(h);
        return m !== -1 && f.splice(m, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let m = 0, g = f.length; m < g; m += 2) {
          const y = f[m],
            _ = f[m + 1];
          if ((y.global && (y.lastIndex = 0), y.test(h))) return _;
        }
        return null;
      });
  }
}
const dR = new lw();
class No {
  constructor(e) {
    (this.manager = e !== void 0 ? e : dR),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, o) {
      r.load(e, i, t, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
No.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const _l = {};
class uH extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Dl extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = Cl.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (_l[e] !== void 0) {
      _l[e].push({ onLoad: t, onProgress: r, onError: i });
      return;
    }
    (_l[e] = []), _l[e].push({ onLoad: t, onProgress: r, onError: i });
    const s = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      l = this.mimeType,
      u = this.responseType;
    fetch(s)
      .then((f) => {
        if (f.status === 200 || f.status === 0) {
          if (
            (f.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              f.body === void 0 ||
              f.body.getReader === void 0)
          )
            return f;
          const h = _l[e],
            m = f.body.getReader(),
            g = f.headers.get("X-File-Size") || f.headers.get("Content-Length"),
            y = g ? parseInt(g) : 0,
            _ = y !== 0;
          let S = 0;
          const x = new ReadableStream({
            start(w) {
              T();
              function T() {
                m.read().then(
                  ({ done: E, value: A }) => {
                    if (E) w.close();
                    else {
                      S += A.byteLength;
                      const R = new ProgressEvent("progress", {
                        lengthComputable: _,
                        loaded: S,
                        total: y,
                      });
                      for (let D = 0, I = h.length; D < I; D++) {
                        const U = h[D];
                        U.onProgress && U.onProgress(R);
                      }
                      w.enqueue(A), T();
                    }
                  },
                  (E) => {
                    w.error(E);
                  }
                );
              }
            },
          });
          return new Response(x);
        } else
          throw new uH(
            `fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,
            f
          );
      })
      .then((f) => {
        switch (u) {
          case "arraybuffer":
            return f.arrayBuffer();
          case "blob":
            return f.blob();
          case "document":
            return f.text().then((h) => new DOMParser().parseFromString(h, l));
          case "json":
            return f.json();
          default:
            if (l === void 0) return f.text();
            {
              const m = /charset="?([^;"\s]*)"?/i.exec(l),
                g = m && m[1] ? m[1].toLowerCase() : void 0,
                y = new TextDecoder(g);
              return f.arrayBuffer().then((_) => y.decode(_));
            }
        }
      })
      .then((f) => {
        Cl.add(e, f);
        const h = _l[e];
        delete _l[e];
        for (let m = 0, g = h.length; m < g; m++) {
          const y = h[m];
          y.onLoad && y.onLoad(f);
        }
      })
      .catch((f) => {
        const h = _l[e];
        if (h === void 0) throw (this.manager.itemError(e), f);
        delete _l[e];
        for (let m = 0, g = h.length; m < g; m++) {
          const y = h[m];
          y.onError && y.onError(f);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class cH extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Dl(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = bm.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class fH extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = [],
      l = new Py(),
      u = new Dl(this.manager);
    u.setPath(this.path),
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(o.withCredentials);
    let f = 0;
    function h(m) {
      u.load(
        e[m],
        function (g) {
          const y = o.parse(g, !0);
          (s[m] = {
            width: y.width,
            height: y.height,
            format: y.format,
            mipmaps: y.mipmaps,
          }),
            (f += 1),
            f === 6 &&
              (y.mipmapCount === 1 && (l.minFilter = br),
              (l.image = s),
              (l.format = y.format),
              (l.needsUpdate = !0),
              t && t(l));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let m = 0, g = e.length; m < g; ++m) h(m);
    else
      u.load(
        e,
        function (m) {
          const g = o.parse(m, !0);
          if (g.isCubemap) {
            const y = g.mipmaps.length / g.mipmapCount;
            for (let _ = 0; _ < y; _++) {
              s[_] = { mipmaps: [] };
              for (let S = 0; S < g.mipmapCount; S++)
                s[_].mipmaps.push(g.mipmaps[_ * g.mipmapCount + S]),
                  (s[_].format = g.format),
                  (s[_].width = g.width),
                  (s[_].height = g.height);
            }
            l.image = s;
          } else
            (l.image.width = g.width),
              (l.image.height = g.height),
              (l.mipmaps = g.mipmaps);
          g.mipmapCount === 1 && (l.minFilter = br),
            (l.format = g.format),
            (l.needsUpdate = !0),
            t && t(l);
        },
        r,
        i
      );
    return l;
  }
}
class Em extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Cl.get(e);
    if (s !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    const l = vm("img");
    function u() {
      h(), Cl.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function f(m) {
      h(), i && i(m), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", u, !1),
        l.removeEventListener("error", f, !1);
    }
    return (
      l.addEventListener("load", u, !1),
      l.addEventListener("error", f, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (l.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (l.src = e),
      l
    );
  }
}
class dH extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new Um();
    o.colorSpace = Ms;
    const s = new Em(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let l = 0;
    function u(f) {
      s.load(
        e[f],
        function (h) {
          (o.images[f] = h), l++, l === 6 && ((o.needsUpdate = !0), t && t(o));
        },
        void 0,
        i
      );
    }
    for (let f = 0; f < e.length; ++f) u(f);
    return o;
  }
}
class hH extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Va(),
      l = new Dl(this.manager);
    return (
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setPath(this.path),
      l.setWithCredentials(o.withCredentials),
      l.load(
        e,
        function (u) {
          let f;
          try {
            f = o.parse(u);
          } catch (h) {
            if (i !== void 0) i(h);
            else {
              console.error(h);
              return;
            }
          }
          f.image !== void 0
            ? (s.image = f.image)
            : f.data !== void 0 &&
              ((s.image.width = f.width),
              (s.image.height = f.height),
              (s.image.data = f.data)),
            (s.wrapS = f.wrapS !== void 0 ? f.wrapS : Cs),
            (s.wrapT = f.wrapT !== void 0 ? f.wrapT : Cs),
            (s.magFilter = f.magFilter !== void 0 ? f.magFilter : br),
            (s.minFilter = f.minFilter !== void 0 ? f.minFilter : br),
            (s.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1),
            f.colorSpace !== void 0 && (s.colorSpace = f.colorSpace),
            f.flipY !== void 0 && (s.flipY = f.flipY),
            f.format !== void 0 && (s.format = f.format),
            f.type !== void 0 && (s.type = f.type),
            f.mipmaps !== void 0 &&
              ((s.mipmaps = f.mipmaps), (s.minFilter = Na)),
            f.mipmapCount === 1 && (s.minFilter = br),
            f.generateMipmaps !== void 0 &&
              (s.generateMipmaps = f.generateMipmaps),
            (s.needsUpdate = !0),
            t && t(s, f);
        },
        r,
        i
      ),
      s
    );
  }
}
class pH extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new rr(),
      s = new Em(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (l) {
          (o.image = l), (o.needsUpdate = !0), t !== void 0 && t(o);
        },
        r,
        i
      ),
      o
    );
  }
}
class ju extends xn {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new St(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class hR extends ju {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(xn.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new St(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const G_ = new Wt(),
  YE = new ie(),
  qE = new ie();
class uw {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new tt(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Wt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Fm()),
      (this._frameExtents = new tt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new En(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    YE.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(YE),
      qE.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(qE),
      t.updateMatrixWorld(),
      G_.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(G_),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(G_);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class mH extends uw {
  constructor() {
    super(new Dr(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      r = ch * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      o = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || o !== t.far) &&
      ((t.fov = r), (t.aspect = i), (t.far = o), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class pR extends ju {
  constructor(e, t, r = 0, i = Math.PI / 3, o = 0, s = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(xn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new xn()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = o),
      (this.decay = s),
      (this.map = null),
      (this.shadow = new mH());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const KE = new Wt(),
  Ep = new ie(),
  W_ = new ie();
class gH extends uw {
  constructor() {
    super(new Dr(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new tt(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new En(2, 1, 1, 1),
        new En(0, 1, 1, 1),
        new En(3, 1, 1, 1),
        new En(1, 1, 1, 1),
        new En(3, 0, 1, 1),
        new En(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new ie(1, 0, 0),
        new ie(-1, 0, 0),
        new ie(0, 0, 1),
        new ie(0, 0, -1),
        new ie(0, 1, 0),
        new ie(0, -1, 0),
      ]),
      (this._cubeUps = [
        new ie(0, 1, 0),
        new ie(0, 1, 0),
        new ie(0, 1, 0),
        new ie(0, 1, 0),
        new ie(0, 0, 1),
        new ie(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      i = this.matrix,
      o = e.distance || r.far;
    o !== r.far && ((r.far = o), r.updateProjectionMatrix()),
      Ep.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(Ep),
      W_.copy(r.position),
      W_.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(W_),
      r.updateMatrixWorld(),
      i.makeTranslation(-Ep.x, -Ep.y, -Ep.z),
      KE.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(KE);
  }
}
class mR extends ju {
  constructor(e, t, r = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new gH());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class vH extends uw {
  constructor() {
    super(new Nu(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class gR extends ju {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(xn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new xn()),
      (this.shadow = new vH());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class vR extends ju {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class yR extends ju {
  constructor(e, t, r = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class xR {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new ie());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      t.copy(s[0]).multiplyScalar(0.282095),
      t.addScaledVector(s[1], 0.488603 * i),
      t.addScaledVector(s[2], 0.488603 * o),
      t.addScaledVector(s[3], 0.488603 * r),
      t.addScaledVector(s[4], 1.092548 * (r * i)),
      t.addScaledVector(s[5], 1.092548 * (i * o)),
      t.addScaledVector(s[6], 0.315392 * (3 * o * o - 1)),
      t.addScaledVector(s[7], 1.092548 * (r * o)),
      t.addScaledVector(s[8], 0.546274 * (r * r - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      t.copy(s[0]).multiplyScalar(0.886227),
      t.addScaledVector(s[1], 2 * 0.511664 * i),
      t.addScaledVector(s[2], 2 * 0.511664 * o),
      t.addScaledVector(s[3], 2 * 0.511664 * r),
      t.addScaledVector(s[4], 2 * 0.429043 * r * i),
      t.addScaledVector(s[5], 2 * 0.429043 * i * o),
      t.addScaledVector(s[6], 0.743125 * o * o - 0.247708),
      t.addScaledVector(s[7], 2 * 0.429043 * r * o),
      t.addScaledVector(s[8], 0.429043 * (r * r - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * o),
      (t[3] = 0.488603 * r),
      (t[4] = 1.092548 * r * i),
      (t[5] = 1.092548 * i * o),
      (t[6] = 0.315392 * (3 * o * o - 1)),
      (t[7] = 1.092548 * r * o),
      (t[8] = 0.546274 * (r * r - i * i));
  }
}
class _R extends ju {
  constructor(e = new xR(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class jy extends No {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, r, i) {
    const o = this,
      s = new Dl(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function r(o) {
      return (
        t[o] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", o),
        t[o]
      );
    }
    const i = jy.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new St().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const o in e.uniforms) {
        const s = e.uniforms[o];
        switch (((i.uniforms[o] = {}), s.type)) {
          case "t":
            i.uniforms[o].value = r(s.value);
            break;
          case "c":
            i.uniforms[o].value = new St().setHex(s.value);
            break;
          case "v2":
            i.uniforms[o].value = new tt().fromArray(s.value);
            break;
          case "v3":
            i.uniforms[o].value = new ie().fromArray(s.value);
            break;
          case "v4":
            i.uniforms[o].value = new En().fromArray(s.value);
            break;
          case "m3":
            i.uniforms[o].value = new Qt().fromArray(s.value);
            break;
          case "m4":
            i.uniforms[o].value = new Wt().fromArray(s.value);
            break;
          default:
            i.uniforms[o].value = s.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const o in e.extensions) i.extensions[o] = e.extensions[o];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]),
        (i.normalScale = new tt().fromArray(o));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new tt().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: JA,
      SpriteMaterial: qS,
      RawShaderMaterial: QA,
      ShaderMaterial: la,
      PointsMaterial: ZS,
      MeshPhysicalMaterial: eR,
      MeshStandardMaterial: iw,
      MeshPhongMaterial: tR,
      MeshToonMaterial: nR,
      MeshNormalMaterial: rR,
      MeshLambertMaterial: iR,
      MeshDepthMaterial: by,
      MeshDistanceMaterial: Ey,
      MeshBasicMaterial: Nl,
      MeshMatcapMaterial: oR,
      LineDashedMaterial: sR,
      LineBasicMaterial: mo,
      Material: ki,
    };
    return new t[e]();
  }
}
class G1 {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class cw extends Kt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class SR extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Dl(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = {},
      r = {};
    function i(y, _) {
      if (t[_] !== void 0) return t[_];
      const x = y.interleavedBuffers[_],
        w = o(y, x.buffer),
        T = Yd(x.type, w),
        E = new Ay(T, x.stride);
      return (E.uuid = x.uuid), (t[_] = E), E;
    }
    function o(y, _) {
      if (r[_] !== void 0) return r[_];
      const x = y.arrayBuffers[_],
        w = new Uint32Array(x).buffer;
      return (r[_] = w), w;
    }
    const s = e.isInstancedBufferGeometry ? new cw() : new Kt(),
      l = e.data.index;
    if (l !== void 0) {
      const y = Yd(l.type, l.array);
      s.setIndex(new zn(y, 1));
    }
    const u = e.data.attributes;
    for (const y in u) {
      const _ = u[y];
      let S;
      if (_.isInterleavedBufferAttribute) {
        const x = i(e.data, _.data);
        S = new uf(x, _.itemSize, _.offset, _.normalized);
      } else {
        const x = Yd(_.type, _.array),
          w = _.isInstancedBufferAttribute ? cf : zn;
        S = new w(x, _.itemSize, _.normalized);
      }
      _.name !== void 0 && (S.name = _.name),
        _.usage !== void 0 && S.setUsage(_.usage),
        s.setAttribute(y, S);
    }
    const f = e.data.morphAttributes;
    if (f)
      for (const y in f) {
        const _ = f[y],
          S = [];
        for (let x = 0, w = _.length; x < w; x++) {
          const T = _[x];
          let E;
          if (T.isInterleavedBufferAttribute) {
            const A = i(e.data, T.data);
            E = new uf(A, T.itemSize, T.offset, T.normalized);
          } else {
            const A = Yd(T.type, T.array);
            E = new zn(A, T.itemSize, T.normalized);
          }
          T.name !== void 0 && (E.name = T.name), S.push(E);
        }
        s.morphAttributes[y] = S;
      }
    e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const m = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (m !== void 0)
      for (let y = 0, _ = m.length; y !== _; ++y) {
        const S = m[y];
        s.addGroup(S.start, S.count, S.materialIndex);
      }
    const g = e.data.boundingSphere;
    if (g !== void 0) {
      const y = new ie();
      g.center !== void 0 && y.fromArray(g.center),
        (s.boundingSphere = new Di(y, g.radius));
    }
    return (
      e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s
    );
  }
}
class yH extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = this.path === "" ? G1.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || s;
    const l = new Dl(this.manager);
    l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (u) {
          let f = null;
          try {
            f = JSON.parse(u);
          } catch (m) {
            i !== void 0 && i(m),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                m.message
              );
            return;
          }
          const h = f.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          o.parse(f, t);
        },
        r,
        i
      );
  }
  async loadAsync(e, t) {
    const r = this,
      i = this.path === "" ? G1.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new Dl(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials);
    const s = await o.loadAsync(e, t),
      l = JSON.parse(s),
      u = l.metadata;
    if (
      u === void 0 ||
      u.type === void 0 ||
      u.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(l);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      o = this.parseGeometries(e.geometries, i),
      s = this.parseImages(e.images, function () {
        t !== void 0 && t(f);
      }),
      l = this.parseTextures(e.textures, s),
      u = this.parseMaterials(e.materials, l),
      f = this.parseObject(e.object, o, u, l, r),
      h = this.parseSkeletons(e.skeletons, f);
    if ((this.bindSkeletons(f, h), this.bindLightTargets(f), t !== void 0)) {
      let m = !1;
      for (const g in s)
        if (s[g].data instanceof HTMLImageElement) {
          m = !0;
          break;
        }
      m === !1 && t(f);
    }
    return f;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      o = await this.parseImagesAsync(e.images),
      s = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, s),
      u = this.parseObject(e.object, i, l, s, t),
      f = this.parseSkeletons(e.skeletons, u);
    return this.bindSkeletons(u, f), this.bindLightTargets(u), u;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const o = new tf().fromJSON(e[r]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {},
      i = {};
    if (
      (t.traverse(function (o) {
        o.isBone && (i[o.uuid] = o);
      }),
      e !== void 0)
    )
      for (let o = 0, s = e.length; o < s; o++) {
        const l = new Ry().fromJSON(e[o], i);
        r[l.uuid] = l;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new SR();
      for (let o = 0, s = e.length; o < s; o++) {
        let l;
        const u = e[o];
        switch (u.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            l = i.parse(u);
            break;
          default:
            u.type in XE
              ? (l = XE[u.type].fromJSON(u, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${u.type}"`
                );
        }
        (l.uuid = u.uuid),
          u.name !== void 0 && (l.name = u.name),
          u.userData !== void 0 && (l.userData = u.userData),
          (r[u.uuid] = l);
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const o = new jy();
      o.setTextures(t);
      for (let s = 0, l = e.length; s < l; s++) {
        const u = e[s];
        r[u.uuid] === void 0 && (r[u.uuid] = o.parse(u)),
          (i[u.uuid] = r[u.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          o = bm.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this,
      i = {};
    let o;
    function s(u) {
      return (
        r.manager.itemStart(u),
        o.load(
          u,
          function () {
            r.manager.itemEnd(u);
          },
          void 0,
          function () {
            r.manager.itemError(u), r.manager.itemEnd(u);
          }
        )
      );
    }
    function l(u) {
      if (typeof u == "string") {
        const f = u,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : r.resourcePath + f;
        return s(h);
      } else
        return u.data
          ? { data: Yd(u.type, u.data), width: u.width, height: u.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const u = new lw(t);
      (o = new Em(u)), o.setCrossOrigin(this.crossOrigin);
      for (let f = 0, h = e.length; f < h; f++) {
        const m = e[f],
          g = m.url;
        if (Array.isArray(g)) {
          const y = [];
          for (let _ = 0, S = g.length; _ < S; _++) {
            const x = g[_],
              w = l(x);
            w !== null &&
              (w instanceof HTMLImageElement
                ? y.push(w)
                : y.push(new Va(w.data, w.width, w.height)));
          }
          i[m.uuid] = new qc(y);
        } else {
          const y = l(m.url);
          i[m.uuid] = new qc(y);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      r = {};
    let i;
    async function o(s) {
      if (typeof s == "string") {
        const l = s,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
        return await i.loadAsync(u);
      } else
        return s.data
          ? { data: Yd(s.type, s.data), width: s.width, height: s.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Em(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let s = 0, l = e.length; s < l; s++) {
        const u = e[s],
          f = u.url;
        if (Array.isArray(f)) {
          const h = [];
          for (let m = 0, g = f.length; m < g; m++) {
            const y = f[m],
              _ = await o(y);
            _ !== null &&
              (_ instanceof HTMLImageElement
                ? h.push(_)
                : h.push(new Va(_.data, _.width, _.height)));
          }
          r[u.uuid] = new qc(h);
        } else {
          const h = await o(u.url);
          r[u.uuid] = new qc(h);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(o, s) {
      return typeof o == "number"
        ? o
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            o
          ),
          s[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, s = e.length; o < s; o++) {
        const l = e[o];
        l.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
          t[l.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", l.image);
        const u = t[l.image],
          f = u.data;
        let h;
        Array.isArray(f)
          ? ((h = new Um()), f.length === 6 && (h.needsUpdate = !0))
          : (f && f.data ? (h = new Va()) : (h = new rr()),
            f && (h.needsUpdate = !0)),
          (h.source = u),
          (h.uuid = l.uuid),
          l.name !== void 0 && (h.name = l.name),
          l.mapping !== void 0 && (h.mapping = r(l.mapping, xH)),
          l.channel !== void 0 && (h.channel = l.channel),
          l.offset !== void 0 && h.offset.fromArray(l.offset),
          l.repeat !== void 0 && h.repeat.fromArray(l.repeat),
          l.center !== void 0 && h.center.fromArray(l.center),
          l.rotation !== void 0 && (h.rotation = l.rotation),
          l.wrap !== void 0 &&
            ((h.wrapS = r(l.wrap[0], ZE)), (h.wrapT = r(l.wrap[1], ZE))),
          l.format !== void 0 && (h.format = l.format),
          l.internalFormat !== void 0 && (h.internalFormat = l.internalFormat),
          l.type !== void 0 && (h.type = l.type),
          l.colorSpace !== void 0 && (h.colorSpace = l.colorSpace),
          l.minFilter !== void 0 && (h.minFilter = r(l.minFilter, JE)),
          l.magFilter !== void 0 && (h.magFilter = r(l.magFilter, JE)),
          l.anisotropy !== void 0 && (h.anisotropy = l.anisotropy),
          l.flipY !== void 0 && (h.flipY = l.flipY),
          l.generateMipmaps !== void 0 &&
            (h.generateMipmaps = l.generateMipmaps),
          l.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = l.premultiplyAlpha),
          l.unpackAlignment !== void 0 &&
            (h.unpackAlignment = l.unpackAlignment),
          l.compareFunction !== void 0 &&
            (h.compareFunction = l.compareFunction),
          l.userData !== void 0 && (h.userData = l.userData),
          (i[l.uuid] = h);
      }
    return i;
  }
  parseObject(e, t, r, i, o) {
    let s;
    function l(g) {
      return (
        t[g] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", g),
        t[g]
      );
    }
    function u(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const y = [];
          for (let _ = 0, S = g.length; _ < S; _++) {
            const x = g[_];
            r[x] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", x),
              y.push(r[x]);
          }
          return y;
        }
        return (
          r[g] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", g),
          r[g]
        );
      }
    }
    function f(g) {
      return (
        i[g] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", g),
        i[g]
      );
    }
    let h, m;
    switch (e.type) {
      case "Scene":
        (s = new z0()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (s.background = new St(e.background))
              : (s.background = f(e.background))),
          e.environment !== void 0 && (s.environment = f(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (s.fog = new Cy(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (s.fog = new Ty(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (s.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (s.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (s.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            s.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (s.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            s.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (s = new Dr(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (s.focus = e.focus),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (s = new Nu(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        s = new vR(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (s = new gR(e.color, e.intensity)), (s.target = e.target || "");
        break;
      case "PointLight":
        s = new mR(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        s = new yR(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (s = new pR(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (s.target = e.target || "");
        break;
      case "HemisphereLight":
        s = new hR(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        s = new _R().fromJSON(e);
        break;
      case "SkinnedMesh":
        (h = l(e.geometry)),
          (m = u(e.material)),
          (s = new UA(h, m)),
          e.bindMode !== void 0 && (s.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (s.skeleton = e.skeleton);
        break;
      case "Mesh":
        (h = l(e.geometry)), (m = u(e.material)), (s = new dr(h, m));
        break;
      case "InstancedMesh":
        (h = l(e.geometry)), (m = u(e.material));
        const g = e.count,
          y = e.instanceMatrix,
          _ = e.instanceColor;
        (s = new FA(h, m, g)),
          (s.instanceMatrix = new cf(new Float32Array(y.array), 16)),
          _ !== void 0 &&
            (s.instanceColor = new cf(new Float32Array(_.array), _.itemSize));
        break;
      case "BatchedMesh":
        (h = l(e.geometry)),
          (m = u(e.material)),
          (s = new zA(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            m
          )),
          (s.geometry = h),
          (s.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (s.sortObjects = e.sortObjects),
          (s._drawRanges = e.drawRanges),
          (s._reservedRanges = e.reservedRanges),
          (s._visibility = e.visibility),
          (s._active = e.active),
          (s._bounds = e.bounds.map((S) => {
            const x = new Qi();
            x.min.fromArray(S.boxMin), x.max.fromArray(S.boxMax);
            const w = new Di();
            return (
              (w.radius = S.sphereRadius),
              w.center.fromArray(S.sphereCenter),
              {
                boxInitialized: S.boxInitialized,
                box: x,
                sphereInitialized: S.sphereInitialized,
                sphere: w,
              }
            );
          })),
          (s._maxInstanceCount = e.maxInstanceCount),
          (s._maxVertexCount = e.maxVertexCount),
          (s._maxIndexCount = e.maxIndexCount),
          (s._geometryInitialized = e.geometryInitialized),
          (s._geometryCount = e.geometryCount),
          (s._matricesTexture = f(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (s._colorsTexture = f(e.colorsTexture.uuid));
        break;
      case "LOD":
        s = new NA();
        break;
      case "Line":
        s = new Vu(l(e.geometry), u(e.material));
        break;
      case "LineLoop":
        s = new BA(l(e.geometry), u(e.material));
        break;
      case "LineSegments":
        s = new ja(l(e.geometry), u(e.material));
        break;
      case "PointCloud":
      case "Points":
        s = new VA(l(e.geometry), u(e.material));
        break;
      case "Sprite":
        s = new OA(u(e.material));
        break;
      case "Group":
        s = new Kd();
        break;
      case "Bone":
        s = new KS();
        break;
      default:
        s = new xn();
    }
    if (
      ((s.uuid = e.uuid),
      e.name !== void 0 && (s.name = e.name),
      e.matrix !== void 0
        ? (s.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (s.matrixAutoUpdate = e.matrixAutoUpdate),
          s.matrixAutoUpdate &&
            s.matrix.decompose(s.position, s.quaternion, s.scale))
        : (e.position !== void 0 && s.position.fromArray(e.position),
          e.rotation !== void 0 && s.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && s.scale.fromArray(e.scale)),
      e.up !== void 0 && s.up.fromArray(e.up),
      e.castShadow !== void 0 && (s.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (s.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (s.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          s.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (s.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (s.visible = e.visible),
      e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder),
      e.userData !== void 0 && (s.userData = e.userData),
      e.layers !== void 0 && (s.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const g = e.children;
      for (let y = 0; y < g.length; y++)
        s.add(this.parseObject(g[y], t, r, i, o));
    }
    if (e.animations !== void 0) {
      const g = e.animations;
      for (let y = 0; y < g.length; y++) {
        const _ = g[y];
        s.animations.push(o[_]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate);
      const g = e.levels;
      for (let y = 0; y < g.length; y++) {
        const _ = g[y],
          S = s.getObjectByProperty("uuid", _.object);
        S !== void 0 && s.addLevel(S, _.distance, _.hysteresis);
      }
    }
    return s;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = t[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const r = t.target,
          i = e.getObjectByProperty("uuid", r);
        i !== void 0 ? (t.target = i) : (t.target = new xn());
      }
    });
  }
}
const xH = {
    UVMapping: hy,
    CubeReflectionMapping: Il,
    CubeRefractionMapping: Bu,
    EquirectangularReflectionMapping: sm,
    EquirectangularRefractionMapping: am,
    CubeUVReflectionMapping: vh,
  },
  ZE = {
    RepeatWrapping: lm,
    ClampToEdgeWrapping: Cs,
    MirroredRepeatWrapping: um,
  },
  JE = {
    NearestFilter: yi,
    NearestMipmapNearestFilter: RS,
    NearestMipmapLinearFilter: Xd,
    LinearFilter: br,
    LinearMipmapNearestFilter: Bp,
    LinearMipmapLinearFilter: Na,
  };
class _H extends No {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Cl.get(e);
    if (s !== void 0) {
      if ((o.manager.itemStart(e), s.then)) {
        s.then((f) => {
          t && t(f), o.manager.itemEnd(e);
        }).catch((f) => {
          i && i(f);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    }
    const l = {};
    (l.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (l.headers = this.requestHeader);
    const u = fetch(e, l)
      .then(function (f) {
        return f.blob();
      })
      .then(function (f) {
        return createImageBitmap(
          f,
          Object.assign(o.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (f) {
        return Cl.add(e, f), t && t(f), o.manager.itemEnd(e), f;
      })
      .catch(function (f) {
        i && i(f), Cl.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
      });
    Cl.add(e, u), o.manager.itemStart(e);
  }
}
let Av;
class fw {
  static getContext() {
    return (
      Av === void 0 &&
        (Av = new (window.AudioContext || window.webkitAudioContext)()),
      Av
    );
  }
  static setContext(e) {
    Av = e;
  }
}
class SH extends No {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Dl(this.manager);
    s.setResponseType("arraybuffer"),
      s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (u) {
          try {
            const f = u.slice(0);
            fw.getContext()
              .decodeAudioData(f, function (m) {
                t(m);
              })
              .catch(l);
          } catch (f) {
            l(f);
          }
        },
        r,
        i
      );
    function l(u) {
      i ? i(u) : console.error(u), o.manager.itemError(e);
    }
  }
}
const QE = new Wt(),
  eT = new Wt(),
  Lc = new Wt();
class wH {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Dr()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Dr()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Lc.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        o = (i * t.near) / t.focus,
        s = (t.near * Math.tan(Qc * t.fov * 0.5)) / t.zoom;
      let l, u;
      (eT.elements[12] = -i),
        (QE.elements[12] = i),
        (l = -s * t.aspect + o),
        (u = s * t.aspect + o),
        (Lc.elements[0] = (2 * t.near) / (u - l)),
        (Lc.elements[8] = (u + l) / (u - l)),
        this.cameraL.projectionMatrix.copy(Lc),
        (l = -s * t.aspect - o),
        (u = s * t.aspect - o),
        (Lc.elements[0] = (2 * t.near) / (u - l)),
        (Lc.elements[8] = (u + l) / (u - l)),
        this.cameraR.projectionMatrix.copy(Lc);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(eT),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(QE);
  }
}
class dw {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = tT()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = tT();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function tT() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Dc = new ie(),
  nT = new Ji(),
  MH = new ie(),
  kc = new ie();
class bH extends xn {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = fw.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new dw());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Dc, nT, MH),
      kc.set(0, 0, -1).applyQuaternion(nT),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Dc.x, i),
        t.positionY.linearRampToValueAtTime(Dc.y, i),
        t.positionZ.linearRampToValueAtTime(Dc.z, i),
        t.forwardX.linearRampToValueAtTime(kc.x, i),
        t.forwardY.linearRampToValueAtTime(kc.y, i),
        t.forwardZ.linearRampToValueAtTime(kc.z, i),
        t.upX.linearRampToValueAtTime(r.x, i),
        t.upY.linearRampToValueAtTime(r.y, i),
        t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(Dc.x, Dc.y, Dc.z),
        t.setOrientation(kc.x, kc.y, kc.z, r.x, r.y, r.z);
  }
}
class wR extends xn {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const Oc = new ie(),
  rT = new Ji(),
  EH = new ie(),
  Nc = new ie();
class TH extends wR {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Oc, rT, EH), Nc.set(0, 0, 1).applyQuaternion(rT);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Oc.x, r),
        t.positionY.linearRampToValueAtTime(Oc.y, r),
        t.positionZ.linearRampToValueAtTime(Oc.z, r),
        t.orientationX.linearRampToValueAtTime(Nc.x, r),
        t.orientationY.linearRampToValueAtTime(Nc.y, r),
        t.orientationZ.linearRampToValueAtTime(Nc.z, r);
    } else t.setPosition(Oc.x, Oc.y, Oc.z), t.setOrientation(Nc.x, Nc.y, Nc.z);
  }
}
class CH {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++) e += t[r];
    return e / t.length;
  }
}
class MR {
  constructor(e, t, r) {
    (this.binding = e), (this.valueSize = r);
    let i, o, s;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (o = this._slerpAdditive),
          (s = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (o = this._select),
          (s = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (o = this._lerpAdditive),
          (s = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = o),
      (this._setIdentity = s),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const r = this.buffer,
      i = this.valueSize,
      o = e * i + i;
    let s = this.cumulativeWeight;
    if (s === 0) {
      for (let l = 0; l !== i; ++l) r[o + l] = r[l];
      s = t;
    } else {
      s += t;
      const l = t / s;
      this._mixBufferRegion(r, o, 0, l, i);
    }
    this.cumulativeWeight = s;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      r = this.buffer,
      i = e * t + t,
      o = this.cumulativeWeight,
      s = this.cumulativeWeightAdditive,
      l = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), o < 1)
    ) {
      const u = t * this._origIndex;
      this._mixBufferRegion(r, i, u, 1 - o, t);
    }
    s > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let u = t, f = t + t; u !== f; ++u)
      if (r[u] !== r[u + t]) {
        l.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(t, i);
    for (let o = r, s = i; o !== s; ++o) t[o] = t[i + (o % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let r = e; r < t; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, o) {
    if (i >= 0.5) for (let s = 0; s !== o; ++s) e[t + s] = e[r + s];
  }
  _slerp(e, t, r, i) {
    Ji.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, o) {
    const s = this._workIndex * o;
    Ji.multiplyQuaternionsFlat(e, s, e, t, e, r),
      Ji.slerpFlat(e, t, e, t, e, s, i);
  }
  _lerp(e, t, r, i, o) {
    const s = 1 - i;
    for (let l = 0; l !== o; ++l) {
      const u = t + l;
      e[u] = e[u] * s + e[r + l] * i;
    }
  }
  _lerpAdditive(e, t, r, i, o) {
    for (let s = 0; s !== o; ++s) {
      const l = t + s;
      e[l] = e[l] + e[r + s] * i;
    }
  }
}
const hw = "\\[\\]\\.:\\/",
  AH = new RegExp("[" + hw + "]", "g"),
  pw = "[^" + hw + "]",
  RH = "[^" + hw.replace("\\.", "") + "]",
  PH = /((?:WC+[\/:])*)/.source.replace("WC", pw),
  IH = /(WCOD+)?/.source.replace("WCOD", RH),
  LH = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", pw),
  DH = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", pw),
  kH = new RegExp("^" + PH + IH + LH + DH + "$"),
  OH = ["material", "materials", "bones", "map"];
class NH {
  constructor(e, t, r) {
    const i = r || vn.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class vn {
  constructor(e, t, r) {
    (this.path = t),
      (this.parsedPath = r || vn.parseTrackName(t)),
      (this.node = vn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup
      ? new vn.Composite(e, t, r)
      : new vn(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(AH, "");
  }
  static parseTrackName(e) {
    const t = kH.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = r.nodeName.substring(i + 1);
      OH.indexOf(o) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = o));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (o) {
          for (let s = 0; s < o.length; s++) {
            const l = o[s];
            if (l.name === t || l.uuid === t) return l;
            const u = r(l.children);
            if (u) return u;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      r = t.objectName,
      i = t.propertyName;
    let o = t.propertyIndex;
    if (
      (e || ((e = vn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let f = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === f) {
              f = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[f];
      }
    }
    const s = e[i];
    if (s === void 0) {
      const f = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          f +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let l = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (l = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (l = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 &&
          (o = e.morphTargetDictionary[o]);
      }
      (u = this.BindingType.ArrayElement),
        (this.resolvedProperty = s),
        (this.propertyIndex = o);
    } else
      s.fromArray !== void 0 && s.toArray !== void 0
        ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
        : Array.isArray(s)
        ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = s))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[u]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[u][l]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
vn.Composite = NH;
vn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
vn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
vn.prototype.GetterByBindingType = [
  vn.prototype._getValue_direct,
  vn.prototype._getValue_array,
  vn.prototype._getValue_arrayElement,
  vn.prototype._getValue_toArray,
];
vn.prototype.SetterByBindingTypeAndVersioning = [
  [
    vn.prototype._setValue_direct,
    vn.prototype._setValue_direct_setNeedsUpdate,
    vn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    vn.prototype._setValue_array,
    vn.prototype._setValue_array_setNeedsUpdate,
    vn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    vn.prototype._setValue_arrayElement,
    vn.prototype._setValue_arrayElement_setNeedsUpdate,
    vn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    vn.prototype._setValue_fromArray,
    vn.prototype._setValue_fromArray_setNeedsUpdate,
    vn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class UH {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = is()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      o = this._bindings,
      s = o.length;
    let l,
      u = e.length,
      f = this.nCachedObjects_;
    for (let h = 0, m = arguments.length; h !== m; ++h) {
      const g = arguments[h],
        y = g.uuid;
      let _ = t[y];
      if (_ === void 0) {
        (_ = u++), (t[y] = _), e.push(g);
        for (let S = 0, x = s; S !== x; ++S) o[S].push(new vn(g, r[S], i[S]));
      } else if (_ < f) {
        l = e[_];
        const S = --f,
          x = e[S];
        (t[x.uuid] = _), (e[_] = x), (t[y] = S), (e[S] = g);
        for (let w = 0, T = s; w !== T; ++w) {
          const E = o[w],
            A = E[S];
          let R = E[_];
          (E[_] = A), R === void 0 && (R = new vn(g, r[w], i[w])), (E[S] = R);
        }
      } else
        e[_] !== l &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_;
    for (let s = 0, l = arguments.length; s !== l; ++s) {
      const u = arguments[s],
        f = u.uuid,
        h = t[f];
      if (h !== void 0 && h >= o) {
        const m = o++,
          g = e[m];
        (t[g.uuid] = h), (e[h] = g), (t[f] = m), (e[m] = u);
        for (let y = 0, _ = i; y !== _; ++y) {
          const S = r[y],
            x = S[m],
            w = S[h];
          (S[h] = x), (S[m] = w);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_,
      s = e.length;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const f = arguments[l],
        h = f.uuid,
        m = t[h];
      if (m !== void 0)
        if ((delete t[h], m < o)) {
          const g = --o,
            y = e[g],
            _ = --s,
            S = e[_];
          (t[y.uuid] = m), (e[m] = y), (t[S.uuid] = g), (e[g] = S), e.pop();
          for (let x = 0, w = i; x !== w; ++x) {
            const T = r[x],
              E = T[g],
              A = T[_];
            (T[m] = E), (T[g] = A), T.pop();
          }
        } else {
          const g = --s,
            y = e[g];
          g > 0 && (t[y.uuid] = m), (e[m] = y), e.pop();
          for (let _ = 0, S = i; _ !== S; ++_) {
            const x = r[_];
            (x[m] = x[g]), x.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const s = this._paths,
      l = this._parsedPaths,
      u = this._objects,
      f = u.length,
      h = this.nCachedObjects_,
      m = new Array(f);
    (i = o.length), (r[e] = i), s.push(e), l.push(t), o.push(m);
    for (let g = h, y = u.length; g !== y; ++g) {
      const _ = u[g];
      m[g] = new vn(_, e, t);
    }
    return m;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      r = t[e];
    if (r !== void 0) {
      const i = this._paths,
        o = this._parsedPaths,
        s = this._bindings,
        l = s.length - 1,
        u = s[l],
        f = e[l];
      (t[f] = r),
        (s[r] = u),
        s.pop(),
        (o[r] = o[l]),
        o.pop(),
        (i[r] = i[l]),
        i.pop();
    }
  }
}
class bR {
  constructor(e, t, r = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = r),
      (this.blendMode = i);
    const o = t.tracks,
      s = o.length,
      l = new Array(s),
      u = { endingStart: Xc, endingEnd: Xc };
    for (let f = 0; f !== s; ++f) {
      const h = o[f].createInterpolant(null);
      (l[f] = h), (h.settings = u);
    }
    (this._interpolantSettings = u),
      (this._interpolants = l),
      (this._propertyBindings = new Array(s)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = aA),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if ((e.fadeOut(t), this.fadeIn(t), r)) {
      const i = this._clip.duration,
        o = e._clip.duration,
        s = o / i,
        l = i / o;
      e.warp(1, s, t), this.warp(l, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer,
      o = i.time,
      s = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null &&
      ((l = i._lendControlInterpolant()), (this._timeScaleInterpolant = l));
    const u = l.parameterPositions,
      f = l.sampleValues;
    return (u[0] = o), (u[1] = o + r), (f[0] = e / s), (f[1] = t / s), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const u = (e - o) * r;
      u < 0 || r === 0 ? (t = 0) : ((this._startTime = null), (t = r * u));
    }
    t *= this._updateTimeScale(e);
    const s = this._updateTime(t),
      l = this._updateWeight(e);
    if (l > 0) {
      const u = this._interpolants,
        f = this._propertyBindings;
      switch (this.blendMode) {
        case zS:
          for (let h = 0, m = u.length; h !== m; ++h)
            u[h].evaluate(s), f[h].accumulateAdditive(l);
          break;
        case _y:
        default:
          for (let h = 0, m = u.length; h !== m; ++h)
            u[h].evaluate(s), f[h].accumulate(i, l);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      o = this._loopCount;
    const s = r === lA;
    if (e === 0) return o === -1 ? i : s && (o & 1) === 1 ? t - i : i;
    if (r === sA) {
      o === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (o === -1 &&
          (e >= 0
            ? ((o = 0), this._setEndings(!0, this.repetitions === 0, s))
            : this._setEndings(this.repetitions === 0, !0, s)),
        i >= t || i < 0)
      ) {
        const l = Math.floor(i / t);
        (i -= t * l), (o += Math.abs(l));
        const u = this.repetitions - o;
        if (u <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (u === 1) {
            const f = e < 0;
            this._setEndings(f, !f, s);
          } else this._setEndings(!1, !1, s);
          (this._loopCount = o),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: l,
            });
        }
      } else this.time = i;
      if (s && (o & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = Yc), (i.endingEnd = Yc))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? Yc : Xc)
          : (i.endingStart = fm),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? Yc : Xc) : (i.endingEnd = fm));
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer,
      o = i.time;
    let s = this._weightInterpolant;
    s === null &&
      ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
    const l = s.parameterPositions,
      u = s.sampleValues;
    return (l[0] = o), (u[0] = t), (l[1] = o + e), (u[1] = r), this;
  }
}
const FH = new Float32Array(1);
class zH extends Ol {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      o = i.length,
      s = e._propertyBindings,
      l = e._interpolants,
      u = r.uuid,
      f = this._bindingsByRootAndName;
    let h = f[u];
    h === void 0 && ((h = {}), (f[u] = h));
    for (let m = 0; m !== o; ++m) {
      const g = i[m],
        y = g.name;
      let _ = h[y];
      if (_ !== void 0) ++_.referenceCount, (s[m] = _);
      else {
        if (((_ = s[m]), _ !== void 0)) {
          _._cacheIndex === null &&
            (++_.referenceCount, this._addInactiveBinding(_, u, y));
          continue;
        }
        const S = t && t._propertyBindings[m].binding.parsedPath;
        (_ = new MR(vn.create(r, y, S), g.ValueTypeName, g.getValueSize())),
          ++_.referenceCount,
          this._addInactiveBinding(_, u, y),
          (s[m] = _);
      }
      l[m].resultBuffer = _.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          o = this._actionsByClip[i];
        this._bindAction(e, o && o.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        --o.useCount === 0 &&
          (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions,
      o = this._actionsByClip;
    let s = o[t];
    if (s === void 0)
      (s = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (o[t] = s);
    else {
      const l = s.knownActions;
      (e._byClipCacheIndex = l.length), l.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      r = t[t.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (t[i] = r), t.pop(), (e._cacheIndex = null);
    const o = e._clip.uuid,
      s = this._actionsByClip,
      l = s[o],
      u = l.knownActions,
      f = u[u.length - 1],
      h = e._byClipCacheIndex;
    (f._byClipCacheIndex = h),
      (u[h] = f),
      u.pop(),
      (e._byClipCacheIndex = null);
    const m = l.actionByRoot,
      g = (e._localRoot || this._root).uuid;
    delete m[g],
      u.length === 0 && delete s[o],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const o = t[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName,
      o = this._bindings;
    let s = i[t];
    s === void 0 && ((s = {}), (i[t] = s)),
      (s[r] = e),
      (e._cacheIndex = o.length),
      o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      o = r.path,
      s = this._bindingsByRootAndName,
      l = s[i],
      u = t[t.length - 1],
      f = e._cacheIndex;
    (u._cacheIndex = f),
      (t[f] = u),
      t.pop(),
      delete l[o],
      Object.keys(l).length === 0 && delete s[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let r = e[t];
    return (
      r === void 0 &&
        ((r = new sw(new Float32Array(2), new Float32Array(2), 1, FH)),
        (r.__cacheIndex = t),
        (e[t] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      o = t[i];
    (e.__cacheIndex = i), (t[i] = e), (o.__cacheIndex = r), (t[r] = o);
  }
  clipAction(e, t, r) {
    const i = t || this._root,
      o = i.uuid;
    let s = typeof e == "string" ? bm.findByName(i, e) : e;
    const l = s !== null ? s.uuid : e,
      u = this._actionsByClip[l];
    let f = null;
    if (
      (r === void 0 && (s !== null ? (r = s.blendMode) : (r = _y)),
      u !== void 0)
    ) {
      const m = u.actionByRoot[o];
      if (m !== void 0 && m.blendMode === r) return m;
      (f = u.knownActions[0]), s === null && (s = f._clip);
    }
    if (s === null) return null;
    const h = new bR(this, s, t, r);
    return this._bindAction(h, f), this._addInactiveAction(h, l, o), h;
  }
  existingAction(e, t) {
    const r = t || this._root,
      i = r.uuid,
      o = typeof e == "string" ? bm.findByName(r, e) : e,
      s = o ? o.uuid : e,
      l = this._actionsByClip[s];
    return (l !== void 0 && l.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      o = Math.sign(e),
      s = (this._accuIndex ^= 1);
    for (let f = 0; f !== r; ++f) t[f]._update(i, e, o, s);
    const l = this._bindings,
      u = this._nActiveBindings;
    for (let f = 0; f !== u; ++f) l[f].apply(s);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      o = i[r];
    if (o !== void 0) {
      const s = o.knownActions;
      for (let l = 0, u = s.length; l !== u; ++l) {
        const f = s[l];
        this._deactivateAction(f);
        const h = f._cacheIndex,
          m = t[t.length - 1];
        (f._cacheIndex = null),
          (f._byClipCacheIndex = null),
          (m._cacheIndex = h),
          (t[h] = m),
          t.pop(),
          this._removeInactiveBindingsForAction(f);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      r = this._actionsByClip;
    for (const s in r) {
      const l = r[s].actionByRoot,
        u = l[t];
      u !== void 0 &&
        (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const i = this._bindingsByRootAndName,
      o = i[t];
    if (o !== void 0)
      for (const s in o) {
        const l = o[s];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class mw {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new mw(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let BH = 0;
class VH extends Ol {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: BH++ }),
      (this.name = ""),
      (this.usage = mm),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = Array.isArray(t[r]) ? t[r] : [t[r]];
      for (let s = 0; s < o.length; s++) this.uniforms.push(o[s].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class HH extends Ay {
  constructor(e, t, r = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class GH {
  constructor(e, t, r, i, o) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const iT = new Wt();
class ER {
  constructor(e, t, r = 0, i = 1 / 0) {
    (this.ray = new hf(e, t)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new ef()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      iT.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(iT),
      this
    );
  }
  intersectObject(e, t = !0, r = []) {
    return W1(e, this, r, t), r.sort(oT), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, o = e.length; i < o; i++) W1(e[i], this, r, t);
    return r.sort(oT), r;
  }
}
function oT(n, e) {
  return n.distance - e.distance;
}
function W1(n, e, t, r) {
  let i = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (i = !1),
    i === !0 && r === !0)
  ) {
    const o = n.children;
    for (let s = 0, l = o.length; s < l; s++) W1(o[s], e, t, !0);
  }
}
class j1 {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(Mr(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class WH {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class gw {
  constructor(e, t, r, i) {
    (gw.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 4; r++) this.elements[r] = e[r + t];
    return this;
  }
  set(e, t, r, i) {
    const o = this.elements;
    return (o[0] = e), (o[2] = t), (o[1] = r), (o[3] = i), this;
  }
}
const sT = new tt();
class jH {
  constructor(e = new tt(1 / 0, 1 / 0), t = new tt(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = sT.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, sT).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const aT = new ie(),
  Rv = new ie();
class $H {
  constructor(e = new ie(), t = new ie()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    aT.subVectors(e, this.start), Rv.subVectors(this.end, this.start);
    const r = Rv.dot(Rv);
    let o = Rv.dot(aT) / r;
    return t && (o = Mr(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const lT = new ie();
class XH extends xn {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const r = new Kt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let s = 0, l = 1, u = 32; s < u; s++, l++) {
      const f = (s / u) * Math.PI * 2,
        h = (l / u) * Math.PI * 2;
      i.push(Math.cos(f), Math.sin(f), 1, Math.cos(h), Math.sin(h), 1);
    }
    r.setAttribute("position", new Lt(i, 3));
    const o = new mo({ fog: !1, toneMapped: !1 });
    (this.cone = new ja(r, o)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      lT.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(lT),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const Ru = new ie(),
  Pv = new Wt(),
  j_ = new Wt();
class YH extends ja {
  constructor(e) {
    const t = TR(e),
      r = new Kt(),
      i = [],
      o = [],
      s = new St(0, 0, 1),
      l = new St(0, 1, 0);
    for (let f = 0; f < t.length; f++) {
      const h = t[f];
      h.parent &&
        h.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        o.push(s.r, s.g, s.b),
        o.push(l.r, l.g, l.b));
    }
    r.setAttribute("position", new Lt(i, 3)),
      r.setAttribute("color", new Lt(o, 3));
    const u = new mo({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, u),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    j_.copy(this.root.matrixWorld).invert();
    for (let o = 0, s = 0; o < t.length; o++) {
      const l = t[o];
      l.parent &&
        l.parent.isBone &&
        (Pv.multiplyMatrices(j_, l.matrixWorld),
        Ru.setFromMatrixPosition(Pv),
        i.setXYZ(s, Ru.x, Ru.y, Ru.z),
        Pv.multiplyMatrices(j_, l.parent.matrixWorld),
        Ru.setFromMatrixPosition(Pv),
        i.setXYZ(s + 1, Ru.x, Ru.y, Ru.z),
        (s += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function TR(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, TR(n.children[t]));
  return e;
}
class qH extends dr {
  constructor(e, t, r) {
    const i = new Vm(t, 4, 2),
      o = new Nl({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const KH = new ie(),
  uT = new St(),
  cT = new St();
class ZH extends xn {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new Bm(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new Nl({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"),
      s = new Float32Array(o.count * 3);
    i.setAttribute("color", new zn(s, 3)),
      this.add(new dr(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      uT.copy(this.light.color), cT.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const o = r < i / 2 ? uT : cT;
        t.setXYZ(r, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(KH.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class JH extends ja {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    (r = new St(r)), (i = new St(i));
    const o = t / 2,
      s = e / t,
      l = e / 2,
      u = [],
      f = [];
    for (let g = 0, y = 0, _ = -l; g <= t; g++, _ += s) {
      u.push(-l, 0, _, l, 0, _), u.push(_, 0, -l, _, 0, l);
      const S = g === o ? r : i;
      S.toArray(f, y),
        (y += 3),
        S.toArray(f, y),
        (y += 3),
        S.toArray(f, y),
        (y += 3),
        S.toArray(f, y),
        (y += 3);
    }
    const h = new Kt();
    h.setAttribute("position", new Lt(u, 3)),
      h.setAttribute("color", new Lt(f, 3));
    const m = new mo({ vertexColors: !0, toneMapped: !1 });
    super(h, m), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class QH extends ja {
  constructor(e = 10, t = 16, r = 8, i = 64, o = 4473924, s = 8947848) {
    (o = new St(o)), (s = new St(s));
    const l = [],
      u = [];
    if (t > 1)
      for (let m = 0; m < t; m++) {
        const g = (m / t) * (Math.PI * 2),
          y = Math.sin(g) * e,
          _ = Math.cos(g) * e;
        l.push(0, 0, 0), l.push(y, 0, _);
        const S = m & 1 ? o : s;
        u.push(S.r, S.g, S.b), u.push(S.r, S.g, S.b);
      }
    for (let m = 0; m < r; m++) {
      const g = m & 1 ? o : s,
        y = e - (e / r) * m;
      for (let _ = 0; _ < i; _++) {
        let S = (_ / i) * (Math.PI * 2),
          x = Math.sin(S) * y,
          w = Math.cos(S) * y;
        l.push(x, 0, w),
          u.push(g.r, g.g, g.b),
          (S = ((_ + 1) / i) * (Math.PI * 2)),
          (x = Math.sin(S) * y),
          (w = Math.cos(S) * y),
          l.push(x, 0, w),
          u.push(g.r, g.g, g.b);
      }
    }
    const f = new Kt();
    f.setAttribute("position", new Lt(l, 3)),
      f.setAttribute("color", new Lt(u, 3));
    const h = new mo({ vertexColors: !0, toneMapped: !1 });
    super(f, h), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const fT = new ie(),
  Iv = new ie(),
  dT = new ie();
class e8 extends xn {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new Kt();
    i.setAttribute(
      "position",
      new Lt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const o = new mo({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Vu(i, o)),
      this.add(this.lightPlane),
      (i = new Kt()),
      i.setAttribute("position", new Lt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Vu(i, o)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      fT.setFromMatrixPosition(this.light.matrixWorld),
      Iv.setFromMatrixPosition(this.light.target.matrixWorld),
      dT.subVectors(Iv, fT),
      this.lightPlane.lookAt(Iv),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Iv),
      (this.targetLine.scale.z = dT.length());
  }
}
const Lv = new ie(),
  _r = new Nm();
class t8 extends ja {
  constructor(e) {
    const t = new Kt(),
      r = new mo({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      o = [],
      s = {};
    l("n1", "n2"),
      l("n2", "n4"),
      l("n4", "n3"),
      l("n3", "n1"),
      l("f1", "f2"),
      l("f2", "f4"),
      l("f4", "f3"),
      l("f3", "f1"),
      l("n1", "f1"),
      l("n2", "f2"),
      l("n3", "f3"),
      l("n4", "f4"),
      l("p", "n1"),
      l("p", "n2"),
      l("p", "n3"),
      l("p", "n4"),
      l("u1", "u2"),
      l("u2", "u3"),
      l("u3", "u1"),
      l("c", "t"),
      l("p", "c"),
      l("cn1", "cn2"),
      l("cn3", "cn4"),
      l("cf1", "cf2"),
      l("cf3", "cf4");
    function l(_, S) {
      u(_), u(S);
    }
    function u(_) {
      i.push(0, 0, 0),
        o.push(0, 0, 0),
        s[_] === void 0 && (s[_] = []),
        s[_].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Lt(i, 3)),
      t.setAttribute("color", new Lt(o, 3)),
      super(t, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = s),
      this.update();
    const f = new St(16755200),
      h = new St(16711680),
      m = new St(43775),
      g = new St(16777215),
      y = new St(3355443);
    this.setColors(f, h, m, g, y);
  }
  setColors(e, t, r, i, o) {
    const l = this.geometry.getAttribute("color");
    l.setXYZ(0, e.r, e.g, e.b),
      l.setXYZ(1, e.r, e.g, e.b),
      l.setXYZ(2, e.r, e.g, e.b),
      l.setXYZ(3, e.r, e.g, e.b),
      l.setXYZ(4, e.r, e.g, e.b),
      l.setXYZ(5, e.r, e.g, e.b),
      l.setXYZ(6, e.r, e.g, e.b),
      l.setXYZ(7, e.r, e.g, e.b),
      l.setXYZ(8, e.r, e.g, e.b),
      l.setXYZ(9, e.r, e.g, e.b),
      l.setXYZ(10, e.r, e.g, e.b),
      l.setXYZ(11, e.r, e.g, e.b),
      l.setXYZ(12, e.r, e.g, e.b),
      l.setXYZ(13, e.r, e.g, e.b),
      l.setXYZ(14, e.r, e.g, e.b),
      l.setXYZ(15, e.r, e.g, e.b),
      l.setXYZ(16, e.r, e.g, e.b),
      l.setXYZ(17, e.r, e.g, e.b),
      l.setXYZ(18, e.r, e.g, e.b),
      l.setXYZ(19, e.r, e.g, e.b),
      l.setXYZ(20, e.r, e.g, e.b),
      l.setXYZ(21, e.r, e.g, e.b),
      l.setXYZ(22, e.r, e.g, e.b),
      l.setXYZ(23, e.r, e.g, e.b),
      l.setXYZ(24, t.r, t.g, t.b),
      l.setXYZ(25, t.r, t.g, t.b),
      l.setXYZ(26, t.r, t.g, t.b),
      l.setXYZ(27, t.r, t.g, t.b),
      l.setXYZ(28, t.r, t.g, t.b),
      l.setXYZ(29, t.r, t.g, t.b),
      l.setXYZ(30, t.r, t.g, t.b),
      l.setXYZ(31, t.r, t.g, t.b),
      l.setXYZ(32, r.r, r.g, r.b),
      l.setXYZ(33, r.r, r.g, r.b),
      l.setXYZ(34, r.r, r.g, r.b),
      l.setXYZ(35, r.r, r.g, r.b),
      l.setXYZ(36, r.r, r.g, r.b),
      l.setXYZ(37, r.r, r.g, r.b),
      l.setXYZ(38, i.r, i.g, i.b),
      l.setXYZ(39, i.r, i.g, i.b),
      l.setXYZ(40, o.r, o.g, o.b),
      l.setXYZ(41, o.r, o.g, o.b),
      l.setXYZ(42, o.r, o.g, o.b),
      l.setXYZ(43, o.r, o.g, o.b),
      l.setXYZ(44, o.r, o.g, o.b),
      l.setXYZ(45, o.r, o.g, o.b),
      l.setXYZ(46, o.r, o.g, o.b),
      l.setXYZ(47, o.r, o.g, o.b),
      l.setXYZ(48, o.r, o.g, o.b),
      l.setXYZ(49, o.r, o.g, o.b),
      (l.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      r = 1,
      i = 1;
    _r.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Lr("c", t, e, _r, 0, 0, -1),
      Lr("t", t, e, _r, 0, 0, 1),
      Lr("n1", t, e, _r, -1, -1, -1),
      Lr("n2", t, e, _r, r, -1, -1),
      Lr("n3", t, e, _r, -1, i, -1),
      Lr("n4", t, e, _r, r, i, -1),
      Lr("f1", t, e, _r, -1, -1, 1),
      Lr("f2", t, e, _r, r, -1, 1),
      Lr("f3", t, e, _r, -1, i, 1),
      Lr("f4", t, e, _r, r, i, 1),
      Lr("u1", t, e, _r, r * 0.7, i * 1.1, -1),
      Lr("u2", t, e, _r, -1 * 0.7, i * 1.1, -1),
      Lr("u3", t, e, _r, 0, i * 2, -1),
      Lr("cf1", t, e, _r, -1, 0, 1),
      Lr("cf2", t, e, _r, r, 0, 1),
      Lr("cf3", t, e, _r, 0, -1, 1),
      Lr("cf4", t, e, _r, 0, i, 1),
      Lr("cn1", t, e, _r, -1, 0, -1),
      Lr("cn2", t, e, _r, r, 0, -1),
      Lr("cn3", t, e, _r, 0, -1, -1),
      Lr("cn4", t, e, _r, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Lr(n, e, t, r, i, o, s) {
  Lv.set(i, o, s).unproject(r);
  const l = e[n];
  if (l !== void 0) {
    const u = t.getAttribute("position");
    for (let f = 0, h = l.length; f < h; f++) u.setXYZ(l[f], Lv.x, Lv.y, Lv.z);
  }
}
const Dv = new Qi();
class n8 extends ja {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      o = new Kt();
    o.setIndex(new zn(r, 1)),
      o.setAttribute("position", new zn(i, 3)),
      super(o, new mo({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Dv.setFromObject(this.object),
      Dv.isEmpty())
    )
      return;
    const t = Dv.min,
      r = Dv.max,
      i = this.geometry.attributes.position,
      o = i.array;
    (o[0] = r.x),
      (o[1] = r.y),
      (o[2] = r.z),
      (o[3] = t.x),
      (o[4] = r.y),
      (o[5] = r.z),
      (o[6] = t.x),
      (o[7] = t.y),
      (o[8] = r.z),
      (o[9] = r.x),
      (o[10] = t.y),
      (o[11] = r.z),
      (o[12] = r.x),
      (o[13] = r.y),
      (o[14] = t.z),
      (o[15] = t.x),
      (o[16] = r.y),
      (o[17] = t.z),
      (o[18] = t.x),
      (o[19] = t.y),
      (o[20] = t.z),
      (o[21] = r.x),
      (o[22] = t.y),
      (o[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class r8 extends ja {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      o = new Kt();
    o.setIndex(new zn(r, 1)),
      o.setAttribute("position", new Lt(i, 3)),
      super(o, new mo({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class i8 extends Vu {
  constructor(e, t = 1, r = 16776960) {
    const i = r,
      o = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      s = new Kt();
    s.setAttribute("position", new Lt(o, 3)),
      s.computeBoundingSphere(),
      super(s, new mo({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      u = new Kt();
    u.setAttribute("position", new Lt(l, 3)),
      u.computeBoundingSphere(),
      this.add(
        new dr(
          u,
          new Nl({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const hT = new ie();
let kv, $_;
class o8 extends xn {
  constructor(
    e = new ie(0, 0, 1),
    t = new ie(0, 0, 0),
    r = 1,
    i = 16776960,
    o = r * 0.2,
    s = o * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      kv === void 0 &&
        ((kv = new Kt()),
        kv.setAttribute("position", new Lt([0, 0, 0, 0, 1, 0], 3)),
        ($_ = new _h(0, 0.5, 1, 5, 1)),
        $_.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Vu(kv, new mo({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new dr($_, new Nl({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, o, s);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      hT.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(hT, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, t, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class s8 extends ja {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new Kt();
    i.setAttribute("position", new Lt(t, 3)),
      i.setAttribute("color", new Lt(r, 3));
    const o = new mo({ vertexColors: !0, toneMapped: !1 });
    super(i, o), (this.type = "AxesHelper");
  }
  setColors(e, t, r) {
    const i = new St(),
      o = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(o, 0),
      i.toArray(o, 3),
      i.set(t),
      i.toArray(o, 6),
      i.toArray(o, 9),
      i.set(r),
      i.toArray(o, 12),
      i.toArray(o, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class a8 {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new St()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new ym()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, s) {
    return this.currentPath.bezierCurveTo(e, t, r, i, o, s), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(w) {
      const T = [];
      for (let E = 0, A = w.length; E < A; E++) {
        const R = w[E],
          D = new tf();
        (D.curves = R.curves), T.push(D);
      }
      return T;
    }
    function r(w, T) {
      const E = T.length;
      let A = !1;
      for (let R = E - 1, D = 0; D < E; R = D++) {
        let I = T[R],
          U = T[D],
          O = U.x - I.x,
          L = U.y - I.y;
        if (Math.abs(L) > Number.EPSILON) {
          if (
            (L < 0 && ((I = T[D]), (O = -O), (U = T[R]), (L = -L)),
            w.y < I.y || w.y > U.y)
          )
            continue;
          if (w.y === I.y) {
            if (w.x === I.x) return !0;
          } else {
            const V = L * (w.x - I.x) - O * (w.y - I.y);
            if (V === 0) return !0;
            if (V < 0) continue;
            A = !A;
          }
        } else {
          if (w.y !== I.y) continue;
          if ((U.x <= w.x && w.x <= I.x) || (I.x <= w.x && w.x <= U.x))
            return !0;
        }
      }
      return A;
    }
    const i = Ha.isClockWise,
      o = this.subPaths;
    if (o.length === 0) return [];
    let s, l, u;
    const f = [];
    if (o.length === 1)
      return (l = o[0]), (u = new tf()), (u.curves = l.curves), f.push(u), f;
    let h = !i(o[0].getPoints());
    h = e ? !h : h;
    const m = [],
      g = [];
    let y = [],
      _ = 0,
      S;
    (g[_] = void 0), (y[_] = []);
    for (let w = 0, T = o.length; w < T; w++)
      (l = o[w]),
        (S = l.getPoints()),
        (s = i(S)),
        (s = e ? !s : s),
        s
          ? (!h && g[_] && _++,
            (g[_] = { s: new tf(), p: S }),
            (g[_].s.curves = l.curves),
            h && _++,
            (y[_] = []))
          : y[_].push({ h: l, p: S[0] });
    if (!g[0]) return t(o);
    if (g.length > 1) {
      let w = !1,
        T = 0;
      for (let E = 0, A = g.length; E < A; E++) m[E] = [];
      for (let E = 0, A = g.length; E < A; E++) {
        const R = y[E];
        for (let D = 0; D < R.length; D++) {
          const I = R[D];
          let U = !0;
          for (let O = 0; O < g.length; O++)
            r(I.p, g[O].p) &&
              (E !== O && T++, U ? ((U = !1), m[O].push(I)) : (w = !0));
          U && m[E].push(I);
        }
      }
      T > 0 && w === !1 && (y = m);
    }
    let x;
    for (let w = 0, T = g.length; w < T; w++) {
      (u = g[w].s), f.push(u), (x = y[w]);
      for (let E = 0, A = x.length; E < A; E++) u.holes.push(x[E].h);
    }
    return f;
  }
}
class l8 extends aa {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
    ),
      super(e, t, { ...i, count: r }),
      (this.isWebGLMultipleRenderTargets = !0);
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: fy } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = fy));
const u8 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: AS,
      AddEquation: Lu,
      AddOperation: J2,
      AdditiveAnimationBlendMode: zS,
      AdditiveBlending: P1,
      AgXToneMapping: rA,
      AlphaFormat: DS,
      AlwaysCompare: vA,
      AlwaysDepth: j2,
      AlwaysStencilFunc: k1,
      AmbientLight: vR,
      AnimationAction: bR,
      AnimationClip: bm,
      AnimationLoader: cH,
      AnimationMixer: zH,
      AnimationObjectGroup: UH,
      AnimationUtils: sH,
      ArcCurve: HA,
      ArrayCamera: LA,
      ArrowHelper: o8,
      AttachedBindMode: D1,
      Audio: wR,
      AudioAnalyser: CH,
      AudioContext: fw,
      AudioListener: bH,
      AudioLoader: SH,
      AxesHelper: s8,
      BackSide: Zi,
      BasicDepthPacking: uA,
      BasicShadowMap: E2,
      BatchedMesh: zA,
      Bone: KS,
      BooleanKeyframeTrack: mf,
      Box2: jH,
      Box3: Qi,
      Box3Helper: r8,
      BoxGeometry: pf,
      BoxHelper: n8,
      BufferAttribute: zn,
      BufferGeometry: Kt,
      BufferGeometryLoader: SR,
      ByteType: PS,
      Cache: Cl,
      Camera: Nm,
      CameraHelper: t8,
      CanvasTexture: PV,
      CapsuleGeometry: Ly,
      CatmullRomCurve3: GA,
      CineonToneMapping: tA,
      CircleGeometry: Dy,
      ClampToEdgeWrapping: Cs,
      Clock: dw,
      Color: St,
      ColorKeyframeTrack: aw,
      ColorManagement: yn,
      CompressedArrayTexture: AV,
      CompressedCubeTexture: RV,
      CompressedTexture: Py,
      CompressedTextureLoader: fH,
      ConeGeometry: ky,
      ConstantAlphaFactor: H2,
      ConstantColorFactor: B2,
      CubeCamera: bA,
      CubeReflectionMapping: Il,
      CubeRefractionMapping: Bu,
      CubeTexture: Um,
      CubeTextureLoader: dH,
      CubeUVReflectionMapping: vh,
      CubicBezierCurve: QS,
      CubicBezierCurve3: WA,
      CubicInterpolant: uR,
      CullFaceBack: R1,
      CullFaceFront: b2,
      CullFaceFrontBack: oF,
      CullFaceNone: M2,
      Curve: ua,
      CurvePath: $A,
      CustomBlending: T2,
      CustomToneMapping: nA,
      CylinderGeometry: _h,
      Cylindrical: WH,
      Data3DTexture: GS,
      DataArrayTexture: wy,
      DataTexture: Va,
      DataTextureLoader: hH,
      DataUtils: y4,
      DecrementStencilOp: xF,
      DecrementWrapStencilOp: SF,
      DefaultLoadingManager: dR,
      DepthFormat: Jc,
      DepthStencilFormat: lf,
      DepthTexture: YS,
      DetachedBindMode: oA,
      DirectionalLight: gR,
      DirectionalLightHelper: e8,
      DiscreteInterpolant: cR,
      DisplayP3ColorSpace: Sy,
      DodecahedronGeometry: Oy,
      DoubleSide: Es,
      DstAlphaFactor: O2,
      DstColorFactor: U2,
      DynamicCopyUsage: NF,
      DynamicDrawUsage: PF,
      DynamicReadUsage: DF,
      EdgesGeometry: XA,
      EllipseCurve: Iy,
      EqualCompare: hA,
      EqualDepth: X2,
      EqualStencilFunc: EF,
      EquirectangularReflectionMapping: sm,
      EquirectangularRefractionMapping: am,
      Euler: ss,
      EventDispatcher: Ol,
      ExtrudeGeometry: Uy,
      FileLoader: Dl,
      Float16BufferAttribute: b4,
      Float32BufferAttribute: Lt,
      FloatType: ko,
      Fog: Cy,
      FogExp2: Ty,
      FramebufferTexture: CV,
      FrontSide: Ga,
      Frustum: Fm,
      GLBufferAttribute: GH,
      GLSL1: FF,
      GLSL3: O1,
      GreaterCompare: pA,
      GreaterDepth: q2,
      GreaterEqualCompare: gA,
      GreaterEqualDepth: Y2,
      GreaterEqualStencilFunc: RF,
      GreaterStencilFunc: CF,
      GridHelper: JH,
      Group: Kd,
      HalfFloatType: yh,
      HemisphereLight: hR,
      HemisphereLightHelper: ZH,
      IcosahedronGeometry: Fy,
      ImageBitmapLoader: _H,
      ImageLoader: Em,
      ImageUtils: _A,
      IncrementStencilOp: yF,
      IncrementWrapStencilOp: _F,
      InstancedBufferAttribute: cf,
      InstancedBufferGeometry: cw,
      InstancedInterleavedBuffer: HH,
      InstancedMesh: FA,
      Int16BufferAttribute: w4,
      Int32BufferAttribute: M4,
      Int8BufferAttribute: x4,
      IntType: py,
      InterleavedBuffer: Ay,
      InterleavedBufferAttribute: uf,
      Interpolant: Hm,
      InterpolateDiscrete: cm,
      InterpolateLinear: F0,
      InterpolateSmooth: Xv,
      InvertStencilOp: wF,
      KeepStencilOp: Gc,
      KeyframeTrack: ca,
      LOD: NA,
      LatheGeometry: zm,
      Layers: ef,
      LessCompare: dA,
      LessDepth: $2,
      LessEqualCompare: VS,
      LessEqualDepth: om,
      LessEqualStencilFunc: TF,
      LessStencilFunc: bF,
      Light: ju,
      LightProbe: _R,
      Line: Vu,
      Line3: $H,
      LineBasicMaterial: mo,
      LineCurve: ew,
      LineCurve3: jA,
      LineDashedMaterial: sR,
      LineLoop: BA,
      LineSegments: ja,
      LinearDisplayP3ColorSpace: Om,
      LinearFilter: br,
      LinearInterpolant: sw,
      LinearMipMapLinearFilter: uF,
      LinearMipMapNearestFilter: lF,
      LinearMipmapLinearFilter: Na,
      LinearMipmapNearestFilter: Bp,
      LinearSRGBColorSpace: kl,
      LinearToneMapping: Q2,
      LinearTransfer: dm,
      Loader: No,
      LoaderUtils: G1,
      LoadingManager: lw,
      LoopOnce: sA,
      LoopPingPong: lA,
      LoopRepeat: aA,
      LuminanceAlphaFormat: NS,
      LuminanceFormat: OS,
      MOUSE: Vc,
      Material: ki,
      MaterialLoader: jy,
      MathUtils: t4,
      Matrix2: gw,
      Matrix3: Qt,
      Matrix4: Wt,
      MaxEquation: P2,
      Mesh: dr,
      MeshBasicMaterial: Nl,
      MeshDepthMaterial: by,
      MeshDistanceMaterial: Ey,
      MeshLambertMaterial: iR,
      MeshMatcapMaterial: oR,
      MeshNormalMaterial: rR,
      MeshPhongMaterial: tR,
      MeshPhysicalMaterial: eR,
      MeshStandardMaterial: iw,
      MeshToonMaterial: nR,
      MinEquation: R2,
      MirroredRepeatWrapping: um,
      MixOperation: Z2,
      MultiplyBlending: L1,
      MultiplyOperation: Dm,
      NearestFilter: yi,
      NearestMipMapLinearFilter: aF,
      NearestMipMapNearestFilter: sF,
      NearestMipmapLinearFilter: Xd,
      NearestMipmapNearestFilter: RS,
      NeutralToneMapping: iA,
      NeverCompare: fA,
      NeverDepth: W2,
      NeverStencilFunc: MF,
      NoBlending: Al,
      NoColorSpace: bl,
      NoToneMapping: Ba,
      NormalAnimationBlendMode: _y,
      NormalBlending: Zc,
      NotEqualCompare: mA,
      NotEqualDepth: K2,
      NotEqualStencilFunc: AF,
      NumberKeyframeTrack: wm,
      Object3D: xn,
      ObjectLoader: yH,
      ObjectSpaceNormalMap: cA,
      OctahedronGeometry: Bm,
      OneFactor: L2,
      OneMinusConstantAlphaFactor: G2,
      OneMinusConstantColorFactor: V2,
      OneMinusDstAlphaFactor: N2,
      OneMinusDstColorFactor: F2,
      OneMinusSrcAlphaFactor: f0,
      OneMinusSrcColorFactor: k2,
      OrthographicCamera: Nu,
      P3Primaries: pm,
      PCFShadowMap: dy,
      PCFSoftShadowMap: zp,
      PMREMGenerator: N1,
      Path: ym,
      PerspectiveCamera: Dr,
      Plane: wl,
      PlaneGeometry: Ul,
      PlaneHelper: i8,
      PointLight: mR,
      PointLightHelper: qH,
      Points: VA,
      PointsMaterial: ZS,
      PolarGridHelper: QH,
      PolyhedronGeometry: Wu,
      PositionalAudio: TH,
      PropertyBinding: vn,
      PropertyMixer: MR,
      QuadraticBezierCurve: tw,
      QuadraticBezierCurve3: nw,
      Quaternion: Ji,
      QuaternionKeyframeTrack: Gm,
      QuaternionLinearInterpolant: fR,
      RED_GREEN_RGTC2_Format: N0,
      RED_RGTC1_Format: FS,
      REVISION: fy,
      RGBADepthPacking: BS,
      RGBAFormat: Ki,
      RGBAIntegerFormat: xy,
      RGBA_ASTC_10x10_Format: P0,
      RGBA_ASTC_10x5_Format: C0,
      RGBA_ASTC_10x6_Format: A0,
      RGBA_ASTC_10x8_Format: R0,
      RGBA_ASTC_12x10_Format: I0,
      RGBA_ASTC_12x12_Format: L0,
      RGBA_ASTC_4x4_Format: x0,
      RGBA_ASTC_5x4_Format: _0,
      RGBA_ASTC_5x5_Format: S0,
      RGBA_ASTC_6x5_Format: w0,
      RGBA_ASTC_6x6_Format: M0,
      RGBA_ASTC_8x5_Format: b0,
      RGBA_ASTC_8x6_Format: E0,
      RGBA_ASTC_8x8_Format: T0,
      RGBA_BPTC_Format: jp,
      RGBA_ETC2_EAC_Format: y0,
      RGBA_PVRTC_2BPPV1_Format: m0,
      RGBA_PVRTC_4BPPV1_Format: p0,
      RGBA_S3TC_DXT1_Format: Hp,
      RGBA_S3TC_DXT3_Format: Gp,
      RGBA_S3TC_DXT5_Format: Wp,
      RGBDepthPacking: pF,
      RGBFormat: kS,
      RGBIntegerFormat: cF,
      RGB_BPTC_SIGNED_Format: D0,
      RGB_BPTC_UNSIGNED_Format: k0,
      RGB_ETC1_Format: g0,
      RGB_ETC2_Format: v0,
      RGB_PVRTC_2BPPV1_Format: h0,
      RGB_PVRTC_4BPPV1_Format: d0,
      RGB_S3TC_DXT1_Format: Vp,
      RGDepthPacking: mF,
      RGFormat: US,
      RGIntegerFormat: yy,
      RawShaderMaterial: QA,
      Ray: hf,
      Raycaster: ER,
      Rec709Primaries: hm,
      RectAreaLight: yR,
      RedFormat: vy,
      RedIntegerFormat: km,
      ReinhardToneMapping: eA,
      RenderTarget: SA,
      RepeatWrapping: lm,
      ReplaceStencilOp: vF,
      ReverseSubtractEquation: A2,
      RingGeometry: zy,
      SIGNED_RED_GREEN_RGTC2_Format: U0,
      SIGNED_RED_RGTC1_Format: O0,
      SRGBColorSpace: Ms,
      SRGBTransfer: $n,
      Scene: z0,
      ShaderChunk: rn,
      ShaderLib: ra,
      ShaderMaterial: la,
      ShadowMaterial: JA,
      Shape: tf,
      ShapeGeometry: By,
      ShapePath: a8,
      ShapeUtils: Ha,
      ShortType: IS,
      Skeleton: Ry,
      SkeletonHelper: YH,
      SkinnedMesh: UA,
      Source: qc,
      Sphere: Di,
      SphereGeometry: Vm,
      Spherical: j1,
      SphericalHarmonics3: xR,
      SplineCurve: rw,
      SpotLight: pR,
      SpotLightHelper: XH,
      Sprite: OA,
      SpriteMaterial: qS,
      SrcAlphaFactor: c0,
      SrcAlphaSaturateFactor: z2,
      SrcColorFactor: D2,
      StaticCopyUsage: OF,
      StaticDrawUsage: mm,
      StaticReadUsage: LF,
      StereoCamera: wH,
      StreamCopyUsage: UF,
      StreamDrawUsage: IF,
      StreamReadUsage: kF,
      StringKeyframeTrack: gf,
      SubtractEquation: C2,
      SubtractiveBlending: I1,
      TOUCH: Hc,
      TangentSpaceNormalMap: Gu,
      TetrahedronGeometry: Vy,
      Texture: rr,
      TextureLoader: pH,
      TextureUtils: sV,
      TorusGeometry: Hy,
      TorusKnotGeometry: Gy,
      Triangle: es,
      TriangleFanDrawMode: hF,
      TriangleStripDrawMode: dF,
      TrianglesDrawMode: fF,
      TubeGeometry: Wy,
      UVMapping: hy,
      Uint16BufferAttribute: WS,
      Uint32BufferAttribute: jS,
      Uint8BufferAttribute: _4,
      Uint8ClampedBufferAttribute: S4,
      Uniform: mw,
      UniformsGroup: VH,
      UniformsLib: xt,
      UniformsUtils: $S,
      UnsignedByteType: sa,
      UnsignedInt248Type: af,
      UnsignedInt5999Type: LS,
      UnsignedIntType: Ll,
      UnsignedShort4444Type: my,
      UnsignedShort5551Type: gy,
      UnsignedShortType: uh,
      VSMShadowMap: na,
      Vector2: tt,
      Vector3: ie,
      Vector4: En,
      VectorKeyframeTrack: Mm,
      VideoTexture: TV,
      WebGL3DRenderTarget: l4,
      WebGLArrayRenderTarget: a4,
      WebGLCoordinateSystem: Ua,
      WebGLCubeRenderTarget: EA,
      WebGLMultipleRenderTargets: l8,
      WebGLRenderTarget: aa,
      WebGLRenderer: DA,
      WebGLUtils: IA,
      WebGPUCoordinateSystem: gm,
      WireframeGeometry: ZA,
      WrapAroundEnding: fm,
      ZeroCurvatureEnding: Xc,
      ZeroFactor: I2,
      ZeroSlopeEnding: Yc,
      ZeroStencilOp: gF,
      createCanvasElement: xA,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var X_ = { exports: {} },
  Pu = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var pT;
function c8() {
  return (
    pT ||
      ((pT = 1),
      (Pu.ConcurrentRoot = 1),
      (Pu.ContinuousEventPriority = 4),
      (Pu.DefaultEventPriority = 16),
      (Pu.DiscreteEventPriority = 1),
      (Pu.IdleEventPriority = 536870912),
      (Pu.LegacyRoot = 0)),
    Pu
  );
}
var mT;
function f8() {
  return mT || ((mT = 1), (X_.exports = c8())), X_.exports;
}
var Jd = f8();
function d8(n) {
  let e;
  const t = new Set(),
    r = (f, h) => {
      const m = typeof f == "function" ? f(e) : f;
      if (m !== e) {
        const g = e;
        (e = h ? m : Object.assign({}, e, m)), t.forEach((y) => y(e, g));
      }
    },
    i = () => e,
    o = (f, h = i, m = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let g = h(e);
      function y() {
        const _ = h(e);
        if (!m(g, _)) {
          const S = g;
          f((g = _), S);
        }
      }
      return t.add(y), () => t.delete(y);
    },
    u = {
      setState: r,
      getState: i,
      subscribe: (f, h, m) =>
        h || m ? o(f, h, m) : (t.add(f), () => t.delete(f)),
      destroy: () => t.clear(),
    };
  return (e = n(r, i, u)), u;
}
const h8 =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  gT = h8 ? ee.useEffect : ee.useLayoutEffect;
function p8(n) {
  const e = typeof n == "function" ? d8(n) : n,
    t = (r = e.getState, i = Object.is) => {
      const [, o] = ee.useReducer((x) => x + 1, 0),
        s = e.getState(),
        l = ee.useRef(s),
        u = ee.useRef(r),
        f = ee.useRef(i),
        h = ee.useRef(!1),
        m = ee.useRef();
      m.current === void 0 && (m.current = r(s));
      let g,
        y = !1;
      (l.current !== s || u.current !== r || f.current !== i || h.current) &&
        ((g = r(s)), (y = !i(m.current, g))),
        gT(() => {
          y && (m.current = g),
            (l.current = s),
            (u.current = r),
            (f.current = i),
            (h.current = !1);
        });
      const _ = ee.useRef(s);
      gT(() => {
        const x = () => {
            try {
              const T = e.getState(),
                E = u.current(T);
              f.current(m.current, E) ||
                ((l.current = T), (m.current = E), o());
            } catch {
              (h.current = !0), o();
            }
          },
          w = e.subscribe(x);
        return e.getState() !== _.current && x(), w;
      }, []);
      const S = y ? g : m.current;
      return ee.useDebugValue(S), S;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [t, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    t
  );
}
var Y_ = { exports: {} },
  q_ = { exports: {} },
  K_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var vT;
function m8() {
  return (
    vT ||
      ((vT = 1),
      (function (n) {
        function e(j, re) {
          var B = j.length;
          j.push(re);
          e: for (; 0 < B; ) {
            var G = (B - 1) >>> 1,
              te = j[G];
            if (0 < i(te, re)) (j[G] = re), (j[B] = te), (B = G);
            else break e;
          }
        }
        function t(j) {
          return j.length === 0 ? null : j[0];
        }
        function r(j) {
          if (j.length === 0) return null;
          var re = j[0],
            B = j.pop();
          if (B !== re) {
            j[0] = B;
            e: for (var G = 0, te = j.length, le = te >>> 1; G < le; ) {
              var J = 2 * (G + 1) - 1,
                oe = j[J],
                he = J + 1,
                ae = j[he];
              if (0 > i(oe, B))
                he < te && 0 > i(ae, oe)
                  ? ((j[G] = ae), (j[he] = B), (G = he))
                  : ((j[G] = oe), (j[J] = B), (G = J));
              else if (he < te && 0 > i(ae, B))
                (j[G] = ae), (j[he] = B), (G = he);
              else break e;
            }
          }
          return re;
        }
        function i(j, re) {
          var B = j.sortIndex - re.sortIndex;
          return B !== 0 ? B : j.id - re.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var s = Date,
            l = s.now();
          n.unstable_now = function () {
            return s.now() - l;
          };
        }
        var u = [],
          f = [],
          h = 1,
          m = null,
          g = 3,
          y = !1,
          _ = !1,
          S = !1,
          x = typeof setTimeout == "function" ? setTimeout : null,
          w = typeof clearTimeout == "function" ? clearTimeout : null,
          T = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function E(j) {
          for (var re = t(f); re !== null; ) {
            if (re.callback === null) r(f);
            else if (re.startTime <= j)
              r(f), (re.sortIndex = re.expirationTime), e(u, re);
            else break;
            re = t(f);
          }
        }
        function A(j) {
          if (((S = !1), E(j), !_))
            if (t(u) !== null) (_ = !0), Y(R);
            else {
              var re = t(f);
              re !== null && ne(A, re.startTime - j);
            }
        }
        function R(j, re) {
          (_ = !1), S && ((S = !1), w(U), (U = -1)), (y = !0);
          var B = g;
          try {
            for (
              E(re), m = t(u);
              m !== null && (!(m.expirationTime > re) || (j && !V()));

            ) {
              var G = m.callback;
              if (typeof G == "function") {
                (m.callback = null), (g = m.priorityLevel);
                var te = G(m.expirationTime <= re);
                (re = n.unstable_now()),
                  typeof te == "function"
                    ? (m.callback = te)
                    : m === t(u) && r(u),
                  E(re);
              } else r(u);
              m = t(u);
            }
            if (m !== null) var le = !0;
            else {
              var J = t(f);
              J !== null && ne(A, J.startTime - re), (le = !1);
            }
            return le;
          } finally {
            (m = null), (g = B), (y = !1);
          }
        }
        var D = !1,
          I = null,
          U = -1,
          O = 5,
          L = -1;
        function V() {
          return !(n.unstable_now() - L < O);
        }
        function H() {
          if (I !== null) {
            var j = n.unstable_now();
            L = j;
            var re = !0;
            try {
              re = I(!0, j);
            } finally {
              re ? $() : ((D = !1), (I = null));
            }
          } else D = !1;
        }
        var $;
        if (typeof T == "function")
          $ = function () {
            T(H);
          };
        else if (typeof MessageChannel < "u") {
          var q = new MessageChannel(),
            K = q.port2;
          (q.port1.onmessage = H),
            ($ = function () {
              K.postMessage(null);
            });
        } else
          $ = function () {
            x(H, 0);
          };
        function Y(j) {
          (I = j), D || ((D = !0), $());
        }
        function ne(j, re) {
          U = x(function () {
            j(n.unstable_now());
          }, re);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (j) {
            j.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            _ || y || ((_ = !0), Y(R));
          }),
          (n.unstable_forceFrameRate = function (j) {
            0 > j || 125 < j
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (O = 0 < j ? Math.floor(1e3 / j) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(u);
          }),
          (n.unstable_next = function (j) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var re = 3;
                break;
              default:
                re = g;
            }
            var B = g;
            g = re;
            try {
              return j();
            } finally {
              g = B;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (j, re) {
            switch (j) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                j = 3;
            }
            var B = g;
            g = j;
            try {
              return re();
            } finally {
              g = B;
            }
          }),
          (n.unstable_scheduleCallback = function (j, re, B) {
            var G = n.unstable_now();
            switch (
              (typeof B == "object" && B !== null
                ? ((B = B.delay),
                  (B = typeof B == "number" && 0 < B ? G + B : G))
                : (B = G),
              j)
            ) {
              case 1:
                var te = -1;
                break;
              case 2:
                te = 250;
                break;
              case 5:
                te = 1073741823;
                break;
              case 4:
                te = 1e4;
                break;
              default:
                te = 5e3;
            }
            return (
              (te = B + te),
              (j = {
                id: h++,
                callback: re,
                priorityLevel: j,
                startTime: B,
                expirationTime: te,
                sortIndex: -1,
              }),
              B > G
                ? ((j.sortIndex = B),
                  e(f, j),
                  t(u) === null &&
                    j === t(f) &&
                    (S ? (w(U), (U = -1)) : (S = !0), ne(A, B - G)))
                : ((j.sortIndex = te), e(u, j), _ || y || ((_ = !0), Y(R))),
              j
            );
          }),
          (n.unstable_shouldYield = V),
          (n.unstable_wrapCallback = function (j) {
            var re = g;
            return function () {
              var B = g;
              g = re;
              try {
                return j.apply(this, arguments);
              } finally {
                g = B;
              }
            };
          });
      })(K_)),
    K_
  );
}
var yT;
function CR() {
  return yT || ((yT = 1), (q_.exports = m8())), q_.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Z_, xT;
function g8() {
  return (
    xT ||
      ((xT = 1),
      (Z_ = function (e) {
        var t = {},
          r = hh(),
          i = CR(),
          o = Object.assign;
        function s(d) {
          for (
            var p =
                "https://reactjs.org/docs/error-decoder.html?invariant=" + d,
              M = 1;
            M < arguments.length;
            M++
          )
            p += "&args[]=" + encodeURIComponent(arguments[M]);
          return (
            "Minified React error #" +
            d +
            "; visit " +
            p +
            " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
          );
        }
        var l = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          u = Symbol.for("react.element"),
          f = Symbol.for("react.portal"),
          h = Symbol.for("react.fragment"),
          m = Symbol.for("react.strict_mode"),
          g = Symbol.for("react.profiler"),
          y = Symbol.for("react.provider"),
          _ = Symbol.for("react.context"),
          S = Symbol.for("react.forward_ref"),
          x = Symbol.for("react.suspense"),
          w = Symbol.for("react.suspense_list"),
          T = Symbol.for("react.memo"),
          E = Symbol.for("react.lazy"),
          A = Symbol.for("react.offscreen"),
          R = Symbol.iterator;
        function D(d) {
          return d === null || typeof d != "object"
            ? null
            : ((d = (R && d[R]) || d["@@iterator"]),
              typeof d == "function" ? d : null);
        }
        function I(d) {
          if (d == null) return null;
          if (typeof d == "function") return d.displayName || d.name || null;
          if (typeof d == "string") return d;
          switch (d) {
            case h:
              return "Fragment";
            case f:
              return "Portal";
            case g:
              return "Profiler";
            case m:
              return "StrictMode";
            case x:
              return "Suspense";
            case w:
              return "SuspenseList";
          }
          if (typeof d == "object")
            switch (d.$$typeof) {
              case _:
                return (d.displayName || "Context") + ".Consumer";
              case y:
                return (d._context.displayName || "Context") + ".Provider";
              case S:
                var p = d.render;
                return (
                  (d = d.displayName),
                  d ||
                    ((d = p.displayName || p.name || ""),
                    (d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")),
                  d
                );
              case T:
                return (
                  (p = d.displayName || null),
                  p !== null ? p : I(d.type) || "Memo"
                );
              case E:
                (p = d._payload), (d = d._init);
                try {
                  return I(d(p));
                } catch {}
            }
          return null;
        }
        function U(d) {
          var p = d.type;
          switch (d.tag) {
            case 24:
              return "Cache";
            case 9:
              return (p.displayName || "Context") + ".Consumer";
            case 10:
              return (p._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return (
                (d = p.render),
                (d = d.displayName || d.name || ""),
                p.displayName ||
                  (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")
              );
            case 7:
              return "Fragment";
            case 5:
              return p;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return I(p);
            case 8:
              return p === m ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if (typeof p == "function")
                return p.displayName || p.name || null;
              if (typeof p == "string") return p;
          }
          return null;
        }
        function O(d) {
          var p = d,
            M = d;
          if (d.alternate) for (; p.return; ) p = p.return;
          else {
            d = p;
            do
              (p = d), (p.flags & 4098) !== 0 && (M = p.return), (d = p.return);
            while (d);
          }
          return p.tag === 3 ? M : null;
        }
        function L(d) {
          if (O(d) !== d) throw Error(s(188));
        }
        function V(d) {
          var p = d.alternate;
          if (!p) {
            if (((p = O(d)), p === null)) throw Error(s(188));
            return p !== d ? null : d;
          }
          for (var M = d, C = p; ; ) {
            var k = M.return;
            if (k === null) break;
            var z = k.alternate;
            if (z === null) {
              if (((C = k.return), C !== null)) {
                M = C;
                continue;
              }
              break;
            }
            if (k.child === z.child) {
              for (z = k.child; z; ) {
                if (z === M) return L(k), d;
                if (z === C) return L(k), p;
                z = z.sibling;
              }
              throw Error(s(188));
            }
            if (M.return !== C.return) (M = k), (C = z);
            else {
              for (var se = !1, we = k.child; we; ) {
                if (we === M) {
                  (se = !0), (M = k), (C = z);
                  break;
                }
                if (we === C) {
                  (se = !0), (C = k), (M = z);
                  break;
                }
                we = we.sibling;
              }
              if (!se) {
                for (we = z.child; we; ) {
                  if (we === M) {
                    (se = !0), (M = z), (C = k);
                    break;
                  }
                  if (we === C) {
                    (se = !0), (C = z), (M = k);
                    break;
                  }
                  we = we.sibling;
                }
                if (!se) throw Error(s(189));
              }
            }
            if (M.alternate !== C) throw Error(s(190));
          }
          if (M.tag !== 3) throw Error(s(188));
          return M.stateNode.current === M ? d : p;
        }
        function H(d) {
          return (d = V(d)), d !== null ? $(d) : null;
        }
        function $(d) {
          if (d.tag === 5 || d.tag === 6) return d;
          for (d = d.child; d !== null; ) {
            var p = $(d);
            if (p !== null) return p;
            d = d.sibling;
          }
          return null;
        }
        function q(d) {
          if (d.tag === 5 || d.tag === 6) return d;
          for (d = d.child; d !== null; ) {
            if (d.tag !== 4) {
              var p = q(d);
              if (p !== null) return p;
            }
            d = d.sibling;
          }
          return null;
        }
        var K = Array.isArray,
          Y = e.getPublicInstance,
          ne = e.getRootHostContext,
          j = e.getChildHostContext,
          re = e.prepareForCommit,
          B = e.resetAfterCommit,
          G = e.createInstance,
          te = e.appendInitialChild,
          le = e.finalizeInitialChildren,
          J = e.prepareUpdate,
          oe = e.shouldSetTextContent,
          he = e.createTextInstance,
          ae = e.scheduleTimeout,
          ue = e.cancelTimeout,
          Ee = e.noTimeout,
          Ne = e.isPrimaryRenderer,
          Ae = e.supportsMutation,
          W = e.supportsPersistence,
          _e = e.supportsHydration,
          Te = e.getInstanceFromNode,
          ke = e.preparePortalMount,
          Pe = e.getCurrentEventPriority,
          rt = e.detachDeletedInstance,
          Le = e.supportsMicrotasks,
          Xe = e.scheduleMicrotask,
          Z = e.supportsTestSelectors,
          F = e.findFiberRoot,
          me = e.getBoundingRect,
          xe = e.getTextContent,
          ye = e.isHiddenSubtree,
          Me = e.matchAccessibilityRole,
          at = e.setFocusIfFocusable,
          Fe = e.setupIntersectionObserver,
          ze = e.appendChild,
          We = e.appendChildToContainer,
          Ye = e.commitTextUpdate,
          nt = e.commitMount,
          yt = e.commitUpdate,
          $e = e.insertBefore,
          qe = e.insertInContainerBefore,
          et = e.removeChild,
          ce = e.removeChildFromContainer,
          Je = e.resetTextContent,
          de = e.hideInstance,
          He = e.hideTextInstance,
          Ce = e.unhideInstance,
          Ue = e.unhideTextInstance,
          it = e.clearContainer,
          mt = e.cloneInstance,
          gt = e.createContainerChildSet,
          Ot = e.appendChildToContainerChildSet,
          Nt = e.finalizeContainerChildren,
          ht = e.replaceContainerChildren,
          jt = e.cloneHiddenInstance,
          an = e.cloneHiddenTextInstance,
          _n = e.canHydrateInstance,
          mn = e.canHydrateTextInstance,
          ir = e.canHydrateSuspenseInstance,
          Oi = e.isSuspenseInstancePending,
          mr = e.isSuspenseInstanceFallback,
          Nr = e.registerSuspenseInstanceRetry,
          Er = e.getNextHydratableSibling,
          Ur = e.getFirstHydratableChild,
          gr = e.getFirstHydratableChildWithinContainer,
          go = e.getFirstHydratableChildWithinSuspenseInstance,
          Fl = e.hydrateInstance,
          eo = e.hydrateTextInstance,
          zl = e.hydrateSuspenseInstance,
          Q = e.getNextHydratableInstanceAfterSuspenseInstance,
          be = e.commitHydratedContainer,
          Be = e.commitHydratedSuspenseInstance,
          Ge = e.clearSuspenseBoundary,
          Ie = e.clearSuspenseBoundaryFromContainer,
          ut = e.shouldDeleteUnhydratedTailInstances,
          vt = e.didNotMatchHydratedContainerTextInstance,
          Et = e.didNotMatchHydratedTextInstance,
          Ke;
        function Dt(d) {
          if (Ke === void 0)
            try {
              throw Error();
            } catch (M) {
              var p = M.stack.trim().match(/\n( *(at )?)/);
              Ke = (p && p[1]) || "";
            }
          return (
            `
` +
            Ke +
            d
          );
        }
        var Ut = !1;
        function At(d, p) {
          if (!d || Ut) return "";
          Ut = !0;
          var M = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (p)
              if (
                ((p = function () {
                  throw Error();
                }),
                Object.defineProperty(p.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(p, []);
                } catch (ct) {
                  var C = ct;
                }
                Reflect.construct(d, [], p);
              } else {
                try {
                  p.call();
                } catch (ct) {
                  C = ct;
                }
                d.call(p.prototype);
              }
            else {
              try {
                throw Error();
              } catch (ct) {
                C = ct;
              }
              d();
            }
          } catch (ct) {
            if (ct && C && typeof ct.stack == "string") {
              for (
                var k = ct.stack.split(`
`),
                  z = C.stack.split(`
`),
                  se = k.length - 1,
                  we = z.length - 1;
                1 <= se && 0 <= we && k[se] !== z[we];

              )
                we--;
              for (; 1 <= se && 0 <= we; se--, we--)
                if (k[se] !== z[we]) {
                  if (se !== 1 || we !== 1)
                    do
                      if ((se--, we--, 0 > we || k[se] !== z[we])) {
                        var Qe =
                          `
` + k[se].replace(" at new ", " at ");
                        return (
                          d.displayName &&
                            Qe.includes("<anonymous>") &&
                            (Qe = Qe.replace("<anonymous>", d.displayName)),
                          Qe
                        );
                      }
                    while (1 <= se && 0 <= we);
                  break;
                }
            }
          } finally {
            (Ut = !1), (Error.prepareStackTrace = M);
          }
          return (d = d ? d.displayName || d.name : "") ? Dt(d) : "";
        }
        var tn = Object.prototype.hasOwnProperty,
          Tn = [],
          dn = -1;
        function Sn(d) {
          return { current: d };
        }
        function wt(d) {
          0 > dn || ((d.current = Tn[dn]), (Tn[dn] = null), dn--);
        }
        function dt(d, p) {
          dn++, (Tn[dn] = d.current), (d.current = p);
        }
        var Zt = {},
          Bt = Sn(Zt),
          wn = Sn(!1),
          ni = Zt;
        function Cn(d, p) {
          var M = d.type.contextTypes;
          if (!M) return Zt;
          var C = d.stateNode;
          if (C && C.__reactInternalMemoizedUnmaskedChildContext === p)
            return C.__reactInternalMemoizedMaskedChildContext;
          var k = {},
            z;
          for (z in M) k[z] = p[z];
          return (
            C &&
              ((d = d.stateNode),
              (d.__reactInternalMemoizedUnmaskedChildContext = p),
              (d.__reactInternalMemoizedMaskedChildContext = k)),
            k
          );
        }
        function Bn(d) {
          return (d = d.childContextTypes), d != null;
        }
        function ln() {
          wt(wn), wt(Bt);
        }
        function Fr(d, p, M) {
          if (Bt.current !== Zt) throw Error(s(168));
          dt(Bt, p), dt(wn, M);
        }
        function as(d, p, M) {
          var C = d.stateNode;
          if (
            ((p = p.childContextTypes), typeof C.getChildContext != "function")
          )
            return M;
          C = C.getChildContext();
          for (var k in C)
            if (!(k in p)) throw Error(s(108, U(d) || "Unknown", k));
          return o({}, M, C);
        }
        function or(d) {
          return (
            (d =
              ((d = d.stateNode) &&
                d.__reactInternalMemoizedMergedChildContext) ||
              Zt),
            (ni = Bt.current),
            dt(Bt, d),
            dt(wn, wn.current),
            !0
          );
        }
        function Tr(d, p, M) {
          var C = d.stateNode;
          if (!C) throw Error(s(169));
          M
            ? ((d = as(d, p, ni)),
              (C.__reactInternalMemoizedMergedChildContext = d),
              wt(wn),
              wt(Bt),
              dt(Bt, d))
            : wt(wn),
            dt(wn, M);
        }
        var ci = Math.clz32 ? Math.clz32 : vf,
          Uo = Math.log,
          Fo = Math.LN2;
        function vf(d) {
          return (d >>>= 0), d === 0 ? 32 : (31 - ((Uo(d) / Fo) | 0)) | 0;
        }
        var zo = 64,
          sn = 4194304;
        function ls(d) {
          switch (d & -d) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return d & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return d & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return d;
          }
        }
        function fa(d, p) {
          var M = d.pendingLanes;
          if (M === 0) return 0;
          var C = 0,
            k = d.suspendedLanes,
            z = d.pingedLanes,
            se = M & 268435455;
          if (se !== 0) {
            var we = se & ~k;
            we !== 0 ? (C = ls(we)) : ((z &= se), z !== 0 && (C = ls(z)));
          } else
            (se = M & ~k), se !== 0 ? (C = ls(se)) : z !== 0 && (C = ls(z));
          if (C === 0) return 0;
          if (
            p !== 0 &&
            p !== C &&
            (p & k) === 0 &&
            ((k = C & -C),
            (z = p & -p),
            k >= z || (k === 16 && (z & 4194240) !== 0))
          )
            return p;
          if (((C & 4) !== 0 && (C |= M & 16), (p = d.entangledLanes), p !== 0))
            for (d = d.entanglements, p &= C; 0 < p; )
              (M = 31 - ci(p)), (k = 1 << M), (C |= d[M]), (p &= ~k);
          return C;
        }
        function Bl(d, p) {
          switch (d) {
            case 1:
            case 2:
            case 4:
              return p + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return p + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function Vl(d, p) {
          for (
            var M = d.suspendedLanes,
              C = d.pingedLanes,
              k = d.expirationTimes,
              z = d.pendingLanes;
            0 < z;

          ) {
            var se = 31 - ci(z),
              we = 1 << se,
              Qe = k[se];
            Qe === -1
              ? ((we & M) === 0 || (we & C) !== 0) && (k[se] = Bl(we, p))
              : Qe <= p && (d.expiredLanes |= we),
              (z &= ~we);
          }
        }
        function us(d) {
          return (
            (d = d.pendingLanes & -1073741825),
            d !== 0 ? d : d & 1073741824 ? 1073741824 : 0
          );
        }
        function $a(d) {
          for (var p = [], M = 0; 31 > M; M++) p.push(d);
          return p;
        }
        function vo(d, p, M) {
          (d.pendingLanes |= p),
            p !== 536870912 && ((d.suspendedLanes = 0), (d.pingedLanes = 0)),
            (d = d.eventTimes),
            (p = 31 - ci(p)),
            (d[p] = M);
        }
        function Bo(d, p) {
          var M = d.pendingLanes & ~p;
          (d.pendingLanes = p),
            (d.suspendedLanes = 0),
            (d.pingedLanes = 0),
            (d.expiredLanes &= p),
            (d.mutableReadLanes &= p),
            (d.entangledLanes &= p),
            (p = d.entanglements);
          var C = d.eventTimes;
          for (d = d.expirationTimes; 0 < M; ) {
            var k = 31 - ci(M),
              z = 1 << k;
            (p[k] = 0), (C[k] = -1), (d[k] = -1), (M &= ~z);
          }
        }
        function ri(d, p) {
          var M = (d.entangledLanes |= p);
          for (d = d.entanglements; M; ) {
            var C = 31 - ci(M),
              k = 1 << C;
            (k & p) | (d[C] & p) && (d[C] |= p), (M &= ~k);
          }
        }
        var $t = 0;
        function yo(d) {
          return (
            (d &= -d),
            1 < d ? (4 < d ? ((d & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
          );
        }
        var to = i.unstable_scheduleCallback,
          cs = i.unstable_cancelCallback,
          xo = i.unstable_shouldYield,
          yf = i.unstable_requestPaint,
          Gn = i.unstable_now,
          Vo = i.unstable_ImmediatePriority,
          xf = i.unstable_UserBlockingPriority,
          fi = i.unstable_NormalPriority,
          da = i.unstable_IdlePriority,
          ha = null,
          no = null;
        function Ps(d) {
          if (no && typeof no.onCommitFiberRoot == "function")
            try {
              no.onCommitFiberRoot(
                ha,
                d,
                void 0,
                (d.current.flags & 128) === 128
              );
            } catch {}
        }
        function pa(d, p) {
          return (
            (d === p && (d !== 0 || 1 / d === 1 / p)) || (d !== d && p !== p)
          );
        }
        var zr = typeof Object.is == "function" ? Object.is : pa,
          Br = null,
          fs = !1,
          _o = !1;
        function Xa(d) {
          Br === null ? (Br = [d]) : Br.push(d);
        }
        function ma(d) {
          (fs = !0), Xa(d);
        }
        function di() {
          if (!_o && Br !== null) {
            _o = !0;
            var d = 0,
              p = $t;
            try {
              var M = Br;
              for ($t = 1; d < M.length; d++) {
                var C = M[d];
                do C = C(!0);
                while (C !== null);
              }
              (Br = null), (fs = !1);
            } catch (k) {
              throw (Br !== null && (Br = Br.slice(d + 1)), to(Vo, di), k);
            } finally {
              ($t = p), (_o = !1);
            }
          }
          return null;
        }
        var ga = l.ReactCurrentBatchConfig;
        function Ni(d, p) {
          if (zr(d, p)) return !0;
          if (
            typeof d != "object" ||
            d === null ||
            typeof p != "object" ||
            p === null
          )
            return !1;
          var M = Object.keys(d),
            C = Object.keys(p);
          if (M.length !== C.length) return !1;
          for (C = 0; C < M.length; C++) {
            var k = M[C];
            if (!tn.call(p, k) || !zr(d[k], p[k])) return !1;
          }
          return !0;
        }
        function Is(d) {
          switch (d.tag) {
            case 5:
              return Dt(d.type);
            case 16:
              return Dt("Lazy");
            case 13:
              return Dt("Suspense");
            case 19:
              return Dt("SuspenseList");
            case 0:
            case 2:
            case 15:
              return (d = At(d.type, !1)), d;
            case 11:
              return (d = At(d.type.render, !1)), d;
            case 1:
              return (d = At(d.type, !0)), d;
            default:
              return "";
          }
        }
        function Vr(d, p) {
          if (d && d.defaultProps) {
            (p = o({}, p)), (d = d.defaultProps);
            for (var M in d) p[M] === void 0 && (p[M] = d[M]);
            return p;
          }
          return p;
        }
        var Cr = Sn(null),
          Ls = null,
          Ui = null,
          Ds = null;
        function Hr() {
          Ds = Ui = Ls = null;
        }
        function ks(d, p, M) {
          Ne
            ? (dt(Cr, p._currentValue), (p._currentValue = M))
            : (dt(Cr, p._currentValue2), (p._currentValue2 = M));
        }
        function vr(d) {
          var p = Cr.current;
          wt(Cr), Ne ? (d._currentValue = p) : (d._currentValue2 = p);
        }
        function Ar(d, p, M) {
          for (; d !== null; ) {
            var C = d.alternate;
            if (
              ((d.childLanes & p) !== p
                ? ((d.childLanes |= p), C !== null && (C.childLanes |= p))
                : C !== null && (C.childLanes & p) !== p && (C.childLanes |= p),
              d === M)
            )
              break;
            d = d.return;
          }
        }
        function sr(d, p) {
          (Ls = d),
            (Ds = Ui = null),
            (d = d.dependencies),
            d !== null &&
              d.firstContext !== null &&
              ((d.lanes & p) !== 0 && ($r = !0), (d.firstContext = null));
        }
        function Yn(d) {
          var p = Ne ? d._currentValue : d._currentValue2;
          if (Ds !== d)
            if (
              ((d = { context: d, memoizedValue: p, next: null }), Ui === null)
            ) {
              if (Ls === null) throw Error(s(308));
              (Ui = d), (Ls.dependencies = { lanes: 0, firstContext: d });
            } else Ui = Ui.next = d;
          return p;
        }
        var _i = null,
          So = !1;
        function Hl(d) {
          d.updateQueue = {
            baseState: d.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function wh(d, p) {
          (d = d.updateQueue),
            p.updateQueue === d &&
              (p.updateQueue = {
                baseState: d.baseState,
                firstBaseUpdate: d.firstBaseUpdate,
                lastBaseUpdate: d.lastBaseUpdate,
                shared: d.shared,
                effects: d.effects,
              });
        }
        function Os(d, p) {
          return {
            eventTime: d,
            lane: p,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function va(d, p) {
          var M = d.updateQueue;
          M !== null &&
            ((M = M.shared),
            Zn !== null && (d.mode & 1) !== 0 && (nn & 2) === 0
              ? ((d = M.interleaved),
                d === null
                  ? ((p.next = p), _i === null ? (_i = [M]) : _i.push(M))
                  : ((p.next = d.next), (d.next = p)),
                (M.interleaved = p))
              : ((d = M.pending),
                d === null ? (p.next = p) : ((p.next = d.next), (d.next = p)),
                (M.pending = p)));
        }
        function _f(d, p, M) {
          if (
            ((p = p.updateQueue),
            p !== null && ((p = p.shared), (M & 4194240) !== 0))
          ) {
            var C = p.lanes;
            (C &= d.pendingLanes), (M |= C), (p.lanes = M), ri(d, M);
          }
        }
        function Sf(d, p) {
          var M = d.updateQueue,
            C = d.alternate;
          if (C !== null && ((C = C.updateQueue), M === C)) {
            var k = null,
              z = null;
            if (((M = M.firstBaseUpdate), M !== null)) {
              do {
                var se = {
                  eventTime: M.eventTime,
                  lane: M.lane,
                  tag: M.tag,
                  payload: M.payload,
                  callback: M.callback,
                  next: null,
                };
                z === null ? (k = z = se) : (z = z.next = se), (M = M.next);
              } while (M !== null);
              z === null ? (k = z = p) : (z = z.next = p);
            } else k = z = p;
            (M = {
              baseState: C.baseState,
              firstBaseUpdate: k,
              lastBaseUpdate: z,
              shared: C.shared,
              effects: C.effects,
            }),
              (d.updateQueue = M);
            return;
          }
          (d = M.lastBaseUpdate),
            d === null ? (M.firstBaseUpdate = p) : (d.next = p),
            (M.lastBaseUpdate = p);
        }
        function wf(d, p, M, C) {
          var k = d.updateQueue;
          So = !1;
          var z = k.firstBaseUpdate,
            se = k.lastBaseUpdate,
            we = k.shared.pending;
          if (we !== null) {
            k.shared.pending = null;
            var Qe = we,
              ct = Qe.next;
            (Qe.next = null),
              se === null ? (z = ct) : (se.next = ct),
              (se = Qe);
            var Tt = d.alternate;
            Tt !== null &&
              ((Tt = Tt.updateQueue),
              (we = Tt.lastBaseUpdate),
              we !== se &&
                (we === null ? (Tt.firstBaseUpdate = ct) : (we.next = ct),
                (Tt.lastBaseUpdate = Qe)));
          }
          if (z !== null) {
            var qt = k.baseState;
            (se = 0), (Tt = ct = Qe = null), (we = z);
            do {
              var zt = we.lane,
                kn = we.eventTime;
              if ((C & zt) === zt) {
                Tt !== null &&
                  (Tt = Tt.next =
                    {
                      eventTime: kn,
                      lane: 0,
                      tag: we.tag,
                      payload: we.payload,
                      callback: we.callback,
                      next: null,
                    });
                e: {
                  var Mt = d,
                    Mn = we;
                  switch (((zt = p), (kn = M), Mn.tag)) {
                    case 1:
                      if (((Mt = Mn.payload), typeof Mt == "function")) {
                        qt = Mt.call(kn, qt, zt);
                        break e;
                      }
                      qt = Mt;
                      break e;
                    case 3:
                      Mt.flags = (Mt.flags & -65537) | 128;
                    case 0:
                      if (
                        ((Mt = Mn.payload),
                        (zt =
                          typeof Mt == "function" ? Mt.call(kn, qt, zt) : Mt),
                        zt == null)
                      )
                        break e;
                      qt = o({}, qt, zt);
                      break e;
                    case 2:
                      So = !0;
                  }
                }
                we.callback !== null &&
                  we.lane !== 0 &&
                  ((d.flags |= 64),
                  (zt = k.effects),
                  zt === null ? (k.effects = [we]) : zt.push(we));
              } else
                (kn = {
                  eventTime: kn,
                  lane: zt,
                  tag: we.tag,
                  payload: we.payload,
                  callback: we.callback,
                  next: null,
                }),
                  Tt === null
                    ? ((ct = Tt = kn), (Qe = qt))
                    : (Tt = Tt.next = kn),
                  (se |= zt);
              if (((we = we.next), we === null)) {
                if (((we = k.shared.pending), we === null)) break;
                (zt = we),
                  (we = zt.next),
                  (zt.next = null),
                  (k.lastBaseUpdate = zt),
                  (k.shared.pending = null);
              }
            } while (!0);
            if (
              (Tt === null && (Qe = qt),
              (k.baseState = Qe),
              (k.firstBaseUpdate = ct),
              (k.lastBaseUpdate = Tt),
              (p = k.shared.interleaved),
              p !== null)
            ) {
              k = p;
              do (se |= k.lane), (k = k.next);
              while (k !== p);
            } else z === null && (k.shared.lanes = 0);
            (ul |= se), (d.lanes = se), (d.memoizedState = qt);
          }
        }
        function jm(d, p, M) {
          if (((d = p.effects), (p.effects = null), d !== null))
            for (p = 0; p < d.length; p++) {
              var C = d[p],
                k = C.callback;
              if (k !== null) {
                if (((C.callback = null), (C = M), typeof k != "function"))
                  throw Error(s(191, k));
                k.call(C);
              }
            }
        }
        var $m = new r.Component().refs;
        function Mh(d, p, M, C) {
          (p = d.memoizedState),
            (M = M(C, p)),
            (M = M == null ? p : o({}, p, M)),
            (d.memoizedState = M),
            d.lanes === 0 && (d.updateQueue.baseState = M);
        }
        var Mf = {
          isMounted: function (d) {
            return (d = d._reactInternals) ? O(d) === d : !1;
          },
          enqueueSetState: function (d, p, M) {
            d = d._reactInternals;
            var C = qr(),
              k = vs(d),
              z = Os(C, k);
            (z.payload = p),
              M != null && (z.callback = M),
              va(d, z),
              (p = Vi(d, k, C)),
              p !== null && _f(p, d, k);
          },
          enqueueReplaceState: function (d, p, M) {
            d = d._reactInternals;
            var C = qr(),
              k = vs(d),
              z = Os(C, k);
            (z.tag = 1),
              (z.payload = p),
              M != null && (z.callback = M),
              va(d, z),
              (p = Vi(d, k, C)),
              p !== null && _f(p, d, k);
          },
          enqueueForceUpdate: function (d, p) {
            d = d._reactInternals;
            var M = qr(),
              C = vs(d),
              k = Os(M, C);
            (k.tag = 2),
              p != null && (k.callback = p),
              va(d, k),
              (p = Vi(d, C, M)),
              p !== null && _f(p, d, C);
          },
        };
        function bh(d, p, M, C, k, z, se) {
          return (
            (d = d.stateNode),
            typeof d.shouldComponentUpdate == "function"
              ? d.shouldComponentUpdate(C, z, se)
              : p.prototype && p.prototype.isPureReactComponent
              ? !Ni(M, C) || !Ni(k, z)
              : !0
          );
        }
        function Xm(d, p, M) {
          var C = !1,
            k = Zt,
            z = p.contextType;
          return (
            typeof z == "object" && z !== null
              ? (z = Yn(z))
              : ((k = Bn(p) ? ni : Bt.current),
                (C = p.contextTypes),
                (z = (C = C != null) ? Cn(d, k) : Zt)),
            (p = new p(M, z)),
            (d.memoizedState =
              p.state !== null && p.state !== void 0 ? p.state : null),
            (p.updater = Mf),
            (d.stateNode = p),
            (p._reactInternals = d),
            C &&
              ((d = d.stateNode),
              (d.__reactInternalMemoizedUnmaskedChildContext = k),
              (d.__reactInternalMemoizedMaskedChildContext = z)),
            p
          );
        }
        function Ym(d, p, M, C) {
          (d = p.state),
            typeof p.componentWillReceiveProps == "function" &&
              p.componentWillReceiveProps(M, C),
            typeof p.UNSAFE_componentWillReceiveProps == "function" &&
              p.UNSAFE_componentWillReceiveProps(M, C),
            p.state !== d && Mf.enqueueReplaceState(p, p.state, null);
        }
        function Eh(d, p, M, C) {
          var k = d.stateNode;
          (k.props = M), (k.state = d.memoizedState), (k.refs = $m), Hl(d);
          var z = p.contextType;
          typeof z == "object" && z !== null
            ? (k.context = Yn(z))
            : ((z = Bn(p) ? ni : Bt.current), (k.context = Cn(d, z))),
            (k.state = d.memoizedState),
            (z = p.getDerivedStateFromProps),
            typeof z == "function" &&
              (Mh(d, p, z, M), (k.state = d.memoizedState)),
            typeof p.getDerivedStateFromProps == "function" ||
              typeof k.getSnapshotBeforeUpdate == "function" ||
              (typeof k.UNSAFE_componentWillMount != "function" &&
                typeof k.componentWillMount != "function") ||
              ((p = k.state),
              typeof k.componentWillMount == "function" &&
                k.componentWillMount(),
              typeof k.UNSAFE_componentWillMount == "function" &&
                k.UNSAFE_componentWillMount(),
              p !== k.state && Mf.enqueueReplaceState(k, k.state, null),
              wf(d, M, k, C),
              (k.state = d.memoizedState)),
            typeof k.componentDidMount == "function" && (d.flags |= 4194308);
        }
        var Gl = [],
          ya = 0,
          bf = null,
          Ef = 0,
          wo = [],
          ro = 0,
          Ya = null,
          Ns = 1,
          Us = "";
        function qa(d, p) {
          (Gl[ya++] = Ef), (Gl[ya++] = bf), (bf = d), (Ef = p);
        }
        function qm(d, p, M) {
          (wo[ro++] = Ns), (wo[ro++] = Us), (wo[ro++] = Ya), (Ya = d);
          var C = Ns;
          d = Us;
          var k = 32 - ci(C) - 1;
          (C &= ~(1 << k)), (M += 1);
          var z = 32 - ci(p) + k;
          if (30 < z) {
            var se = k - (k % 5);
            (z = (C & ((1 << se) - 1)).toString(32)),
              (C >>= se),
              (k -= se),
              (Ns = (1 << (32 - ci(p) + k)) | (M << k) | C),
              (Us = z + d);
          } else (Ns = (1 << z) | (M << k) | C), (Us = d);
        }
        function Th(d) {
          d.return !== null && (qa(d, 1), qm(d, 1, 0));
        }
        function Ch(d) {
          for (; d === bf; )
            (bf = Gl[--ya]), (Gl[ya] = null), (Ef = Gl[--ya]), (Gl[ya] = null);
          for (; d === Ya; )
            (Ya = wo[--ro]),
              (wo[ro] = null),
              (Us = wo[--ro]),
              (wo[ro] = null),
              (Ns = wo[--ro]),
              (wo[ro] = null);
        }
        var Si = null,
          ii = null,
          Wn = !1,
          Wl = !1,
          Mo = null;
        function Ah(d, p) {
          var M = lo(5, null, null, 0);
          (M.elementType = "DELETED"),
            (M.stateNode = p),
            (M.return = d),
            (p = d.deletions),
            p === null ? ((d.deletions = [M]), (d.flags |= 16)) : p.push(M);
        }
        function Rh(d, p) {
          switch (d.tag) {
            case 5:
              return (
                (p = _n(p, d.type, d.pendingProps)),
                p !== null
                  ? ((d.stateNode = p), (Si = d), (ii = Ur(p)), !0)
                  : !1
              );
            case 6:
              return (
                (p = mn(p, d.pendingProps)),
                p !== null ? ((d.stateNode = p), (Si = d), (ii = null), !0) : !1
              );
            case 13:
              if (((p = ir(p)), p !== null)) {
                var M = Ya !== null ? { id: Ns, overflow: Us } : null;
                return (
                  (d.memoizedState = {
                    dehydrated: p,
                    treeContext: M,
                    retryLane: 1073741824,
                  }),
                  (M = lo(18, null, null, 0)),
                  (M.stateNode = p),
                  (M.return = d),
                  (d.child = M),
                  (Si = d),
                  (ii = null),
                  !0
                );
              }
              return !1;
            default:
              return !1;
          }
        }
        function Tf(d) {
          return (d.mode & 1) !== 0 && (d.flags & 128) === 0;
        }
        function xa(d) {
          if (Wn) {
            var p = ii;
            if (p) {
              var M = p;
              if (!Rh(d, p)) {
                if (Tf(d)) throw Error(s(418));
                p = Er(M);
                var C = Si;
                p && Rh(d, p)
                  ? Ah(C, M)
                  : ((d.flags = (d.flags & -4097) | 2), (Wn = !1), (Si = d));
              }
            } else {
              if (Tf(d)) throw Error(s(418));
              (d.flags = (d.flags & -4097) | 2), (Wn = !1), (Si = d);
            }
          }
        }
        function Km(d) {
          for (
            d = d.return;
            d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13;

          )
            d = d.return;
          Si = d;
        }
        function Xu(d) {
          if (!_e || d !== Si) return !1;
          if (!Wn) return Km(d), (Wn = !0), !1;
          if (
            d.tag !== 3 &&
            (d.tag !== 5 || (ut(d.type) && !oe(d.type, d.memoizedProps)))
          ) {
            var p = ii;
            if (p) {
              if (Tf(d)) {
                for (d = ii; d; ) d = Er(d);
                throw Error(s(418));
              }
              for (; p; ) Ah(d, p), (p = Er(p));
            }
          }
          if ((Km(d), d.tag === 13)) {
            if (!_e) throw Error(s(316));
            if (
              ((d = d.memoizedState),
              (d = d !== null ? d.dehydrated : null),
              !d)
            )
              throw Error(s(317));
            ii = Q(d);
          } else ii = Si ? Er(d.stateNode) : null;
          return !0;
        }
        function jl() {
          _e && ((ii = Si = null), (Wl = Wn = !1));
        }
        function Cf(d) {
          Mo === null ? (Mo = [d]) : Mo.push(d);
        }
        function $l(d, p, M) {
          if (
            ((d = M.ref),
            d !== null && typeof d != "function" && typeof d != "object")
          ) {
            if (M._owner) {
              if (((M = M._owner), M)) {
                if (M.tag !== 1) throw Error(s(309));
                var C = M.stateNode;
              }
              if (!C) throw Error(s(147, d));
              var k = C,
                z = "" + d;
              return p !== null &&
                p.ref !== null &&
                typeof p.ref == "function" &&
                p.ref._stringRef === z
                ? p.ref
                : ((p = function (se) {
                    var we = k.refs;
                    we === $m && (we = k.refs = {}),
                      se === null ? delete we[z] : (we[z] = se);
                  }),
                  (p._stringRef = z),
                  p);
            }
            if (typeof d != "string") throw Error(s(284));
            if (!M._owner) throw Error(s(290, d));
          }
          return d;
        }
        function _a(d, p) {
          throw (
            ((d = Object.prototype.toString.call(p)),
            Error(
              s(
                31,
                d === "[object Object]"
                  ? "object with keys {" + Object.keys(p).join(", ") + "}"
                  : d
              )
            ))
          );
        }
        function Xl(d) {
          var p = d._init;
          return p(d._payload);
        }
        function Zm(d) {
          function p(Ve, Re) {
            if (d) {
              var Ze = Ve.deletions;
              Ze === null
                ? ((Ve.deletions = [Re]), (Ve.flags |= 16))
                : Ze.push(Re);
            }
          }
          function M(Ve, Re) {
            if (!d) return null;
            for (; Re !== null; ) p(Ve, Re), (Re = Re.sibling);
            return null;
          }
          function C(Ve, Re) {
            for (Ve = new Map(); Re !== null; )
              Re.key !== null ? Ve.set(Re.key, Re) : Ve.set(Re.index, Re),
                (Re = Re.sibling);
            return Ve;
          }
          function k(Ve, Re) {
            return (Ve = qs(Ve, Re)), (Ve.index = 0), (Ve.sibling = null), Ve;
          }
          function z(Ve, Re, Ze) {
            return (
              (Ve.index = Ze),
              d
                ? ((Ze = Ve.alternate),
                  Ze !== null
                    ? ((Ze = Ze.index), Ze < Re ? ((Ve.flags |= 2), Re) : Ze)
                    : ((Ve.flags |= 2), Re))
                : ((Ve.flags |= 1048576), Re)
            );
          }
          function se(Ve) {
            return d && Ve.alternate === null && (Ve.flags |= 2), Ve;
          }
          function we(Ve, Re, Ze, _t) {
            return Re === null || Re.tag !== 6
              ? ((Re = od(Ze, Ve.mode, _t)), (Re.return = Ve), Re)
              : ((Re = k(Re, Ze)), (Re.return = Ve), Re);
          }
          function Qe(Ve, Re, Ze, _t) {
            var Pt = Ze.type;
            return Pt === h
              ? Tt(Ve, Re, Ze.props.children, _t, Ze.key)
              : Re !== null &&
                (Re.elementType === Pt ||
                  (typeof Pt == "object" &&
                    Pt !== null &&
                    Pt.$$typeof === E &&
                    Xl(Pt) === Re.type))
              ? ((_t = k(Re, Ze.props)),
                (_t.ref = $l(Ve, Re, Ze)),
                (_t.return = Ve),
                _t)
              : ((_t = gc(Ze.type, Ze.key, Ze.props, null, Ve.mode, _t)),
                (_t.ref = $l(Ve, Re, Ze)),
                (_t.return = Ve),
                _t);
          }
          function ct(Ve, Re, Ze, _t) {
            return Re === null ||
              Re.tag !== 4 ||
              Re.stateNode.containerInfo !== Ze.containerInfo ||
              Re.stateNode.implementation !== Ze.implementation
              ? ((Re = sd(Ze, Ve.mode, _t)), (Re.return = Ve), Re)
              : ((Re = k(Re, Ze.children || [])), (Re.return = Ve), Re);
          }
          function Tt(Ve, Re, Ze, _t, Pt) {
            return Re === null || Re.tag !== 7
              ? ((Re = La(Ze, Ve.mode, _t, Pt)), (Re.return = Ve), Re)
              : ((Re = k(Re, Ze)), (Re.return = Ve), Re);
          }
          function qt(Ve, Re, Ze) {
            if ((typeof Re == "string" && Re !== "") || typeof Re == "number")
              return (Re = od("" + Re, Ve.mode, Ze)), (Re.return = Ve), Re;
            if (typeof Re == "object" && Re !== null) {
              switch (Re.$$typeof) {
                case u:
                  return (
                    (Ze = gc(Re.type, Re.key, Re.props, null, Ve.mode, Ze)),
                    (Ze.ref = $l(Ve, null, Re)),
                    (Ze.return = Ve),
                    Ze
                  );
                case f:
                  return (Re = sd(Re, Ve.mode, Ze)), (Re.return = Ve), Re;
                case E:
                  var _t = Re._init;
                  return qt(Ve, _t(Re._payload), Ze);
              }
              if (K(Re) || D(Re))
                return (Re = La(Re, Ve.mode, Ze, null)), (Re.return = Ve), Re;
              _a(Ve, Re);
            }
            return null;
          }
          function zt(Ve, Re, Ze, _t) {
            var Pt = Re !== null ? Re.key : null;
            if ((typeof Ze == "string" && Ze !== "") || typeof Ze == "number")
              return Pt !== null ? null : we(Ve, Re, "" + Ze, _t);
            if (typeof Ze == "object" && Ze !== null) {
              switch (Ze.$$typeof) {
                case u:
                  return Ze.key === Pt ? Qe(Ve, Re, Ze, _t) : null;
                case f:
                  return Ze.key === Pt ? ct(Ve, Re, Ze, _t) : null;
                case E:
                  return (Pt = Ze._init), zt(Ve, Re, Pt(Ze._payload), _t);
              }
              if (K(Ze) || D(Ze))
                return Pt !== null ? null : Tt(Ve, Re, Ze, _t, null);
              _a(Ve, Ze);
            }
            return null;
          }
          function kn(Ve, Re, Ze, _t, Pt) {
            if ((typeof _t == "string" && _t !== "") || typeof _t == "number")
              return (Ve = Ve.get(Ze) || null), we(Re, Ve, "" + _t, Pt);
            if (typeof _t == "object" && _t !== null) {
              switch (_t.$$typeof) {
                case u:
                  return (
                    (Ve = Ve.get(_t.key === null ? Ze : _t.key) || null),
                    Qe(Re, Ve, _t, Pt)
                  );
                case f:
                  return (
                    (Ve = Ve.get(_t.key === null ? Ze : _t.key) || null),
                    ct(Re, Ve, _t, Pt)
                  );
                case E:
                  var Jt = _t._init;
                  return kn(Ve, Re, Ze, Jt(_t._payload), Pt);
              }
              if (K(_t) || D(_t))
                return (Ve = Ve.get(Ze) || null), Tt(Re, Ve, _t, Pt, null);
              _a(Re, _t);
            }
            return null;
          }
          function Mt(Ve, Re, Ze, _t) {
            for (
              var Pt = null, Jt = null, Xt = Re, pn = (Re = 0), Pr = null;
              Xt !== null && pn < Ze.length;
              pn++
            ) {
              Xt.index > pn ? ((Pr = Xt), (Xt = null)) : (Pr = Xt.sibling);
              var hn = zt(Ve, Xt, Ze[pn], _t);
              if (hn === null) {
                Xt === null && (Xt = Pr);
                break;
              }
              d && Xt && hn.alternate === null && p(Ve, Xt),
                (Re = z(hn, Re, pn)),
                Jt === null ? (Pt = hn) : (Jt.sibling = hn),
                (Jt = hn),
                (Xt = Pr);
            }
            if (pn === Ze.length) return M(Ve, Xt), Wn && qa(Ve, pn), Pt;
            if (Xt === null) {
              for (; pn < Ze.length; pn++)
                (Xt = qt(Ve, Ze[pn], _t)),
                  Xt !== null &&
                    ((Re = z(Xt, Re, pn)),
                    Jt === null ? (Pt = Xt) : (Jt.sibling = Xt),
                    (Jt = Xt));
              return Wn && qa(Ve, pn), Pt;
            }
            for (Xt = C(Ve, Xt); pn < Ze.length; pn++)
              (Pr = kn(Xt, Ve, pn, Ze[pn], _t)),
                Pr !== null &&
                  (d &&
                    Pr.alternate !== null &&
                    Xt.delete(Pr.key === null ? pn : Pr.key),
                  (Re = z(Pr, Re, pn)),
                  Jt === null ? (Pt = Pr) : (Jt.sibling = Pr),
                  (Jt = Pr));
            return (
              d &&
                Xt.forEach(function (ys) {
                  return p(Ve, ys);
                }),
              Wn && qa(Ve, pn),
              Pt
            );
          }
          function Mn(Ve, Re, Ze, _t) {
            var Pt = D(Ze);
            if (typeof Pt != "function") throw Error(s(150));
            if (((Ze = Pt.call(Ze)), Ze == null)) throw Error(s(151));
            for (
              var Jt = (Pt = null),
                Xt = Re,
                pn = (Re = 0),
                Pr = null,
                hn = Ze.next();
              Xt !== null && !hn.done;
              pn++, hn = Ze.next()
            ) {
              Xt.index > pn ? ((Pr = Xt), (Xt = null)) : (Pr = Xt.sibling);
              var ys = zt(Ve, Xt, hn.value, _t);
              if (ys === null) {
                Xt === null && (Xt = Pr);
                break;
              }
              d && Xt && ys.alternate === null && p(Ve, Xt),
                (Re = z(ys, Re, pn)),
                Jt === null ? (Pt = ys) : (Jt.sibling = ys),
                (Jt = ys),
                (Xt = Pr);
            }
            if (hn.done) return M(Ve, Xt), Wn && qa(Ve, pn), Pt;
            if (Xt === null) {
              for (; !hn.done; pn++, hn = Ze.next())
                (hn = qt(Ve, hn.value, _t)),
                  hn !== null &&
                    ((Re = z(hn, Re, pn)),
                    Jt === null ? (Pt = hn) : (Jt.sibling = hn),
                    (Jt = hn));
              return Wn && qa(Ve, pn), Pt;
            }
            for (Xt = C(Ve, Xt); !hn.done; pn++, hn = Ze.next())
              (hn = kn(Xt, Ve, pn, hn.value, _t)),
                hn !== null &&
                  (d &&
                    hn.alternate !== null &&
                    Xt.delete(hn.key === null ? pn : hn.key),
                  (Re = z(hn, Re, pn)),
                  Jt === null ? (Pt = hn) : (Jt.sibling = hn),
                  (Jt = hn));
            return (
              d &&
                Xt.forEach(function (gg) {
                  return p(Ve, gg);
                }),
              Wn && qa(Ve, pn),
              Pt
            );
          }
          function uo(Ve, Re, Ze, _t) {
            if (
              (typeof Ze == "object" &&
                Ze !== null &&
                Ze.type === h &&
                Ze.key === null &&
                (Ze = Ze.props.children),
              typeof Ze == "object" && Ze !== null)
            ) {
              switch (Ze.$$typeof) {
                case u:
                  e: {
                    for (var Pt = Ze.key, Jt = Re; Jt !== null; ) {
                      if (Jt.key === Pt) {
                        if (((Pt = Ze.type), Pt === h)) {
                          if (Jt.tag === 7) {
                            M(Ve, Jt.sibling),
                              (Re = k(Jt, Ze.props.children)),
                              (Re.return = Ve),
                              (Ve = Re);
                            break e;
                          }
                        } else if (
                          Jt.elementType === Pt ||
                          (typeof Pt == "object" &&
                            Pt !== null &&
                            Pt.$$typeof === E &&
                            Xl(Pt) === Jt.type)
                        ) {
                          M(Ve, Jt.sibling),
                            (Re = k(Jt, Ze.props)),
                            (Re.ref = $l(Ve, Jt, Ze)),
                            (Re.return = Ve),
                            (Ve = Re);
                          break e;
                        }
                        M(Ve, Jt);
                        break;
                      } else p(Ve, Jt);
                      Jt = Jt.sibling;
                    }
                    Ze.type === h
                      ? ((Re = La(Ze.props.children, Ve.mode, _t, Ze.key)),
                        (Re.return = Ve),
                        (Ve = Re))
                      : ((_t = gc(
                          Ze.type,
                          Ze.key,
                          Ze.props,
                          null,
                          Ve.mode,
                          _t
                        )),
                        (_t.ref = $l(Ve, Re, Ze)),
                        (_t.return = Ve),
                        (Ve = _t));
                  }
                  return se(Ve);
                case f:
                  e: {
                    for (Jt = Ze.key; Re !== null; ) {
                      if (Re.key === Jt)
                        if (
                          Re.tag === 4 &&
                          Re.stateNode.containerInfo === Ze.containerInfo &&
                          Re.stateNode.implementation === Ze.implementation
                        ) {
                          M(Ve, Re.sibling),
                            (Re = k(Re, Ze.children || [])),
                            (Re.return = Ve),
                            (Ve = Re);
                          break e;
                        } else {
                          M(Ve, Re);
                          break;
                        }
                      else p(Ve, Re);
                      Re = Re.sibling;
                    }
                    (Re = sd(Ze, Ve.mode, _t)), (Re.return = Ve), (Ve = Re);
                  }
                  return se(Ve);
                case E:
                  return (Jt = Ze._init), uo(Ve, Re, Jt(Ze._payload), _t);
              }
              if (K(Ze)) return Mt(Ve, Re, Ze, _t);
              if (D(Ze)) return Mn(Ve, Re, Ze, _t);
              _a(Ve, Ze);
            }
            return (typeof Ze == "string" && Ze !== "") || typeof Ze == "number"
              ? ((Ze = "" + Ze),
                Re !== null && Re.tag === 6
                  ? (M(Ve, Re.sibling),
                    (Re = k(Re, Ze)),
                    (Re.return = Ve),
                    (Ve = Re))
                  : (M(Ve, Re),
                    (Re = od(Ze, Ve.mode, _t)),
                    (Re.return = Ve),
                    (Ve = Re)),
                se(Ve))
              : M(Ve, Re);
          }
          return uo;
        }
        var Fs = Zm(!0),
          Jm = Zm(!1),
          Yl = {},
          Fi = Sn(Yl),
          Ka = Sn(Yl),
          Za = Sn(Yl);
        function Ho(d) {
          if (d === Yl) throw Error(s(174));
          return d;
        }
        function Af(d, p) {
          dt(Za, p), dt(Ka, d), dt(Fi, Yl), (d = ne(p)), wt(Fi), dt(Fi, d);
        }
        function ql() {
          wt(Fi), wt(Ka), wt(Za);
        }
        function Qm(d) {
          var p = Ho(Za.current),
            M = Ho(Fi.current);
          (p = j(M, d.type, p)), M !== p && (dt(Ka, d), dt(Fi, p));
        }
        function Ph(d) {
          Ka.current === d && (wt(Fi), wt(Ka));
        }
        var qn = Sn(0);
        function Rf(d) {
          for (var p = d; p !== null; ) {
            if (p.tag === 13) {
              var M = p.memoizedState;
              if (
                M !== null &&
                ((M = M.dehydrated), M === null || Oi(M) || mr(M))
              )
                return p;
            } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
              if ((p.flags & 128) !== 0) return p;
            } else if (p.child !== null) {
              (p.child.return = p), (p = p.child);
              continue;
            }
            if (p === d) break;
            for (; p.sibling === null; ) {
              if (p.return === null || p.return === d) return null;
              p = p.return;
            }
            (p.sibling.return = p.return), (p = p.sibling);
          }
          return null;
        }
        var io = [];
        function Ja() {
          for (var d = 0; d < io.length; d++) {
            var p = io[d];
            Ne
              ? (p._workInProgressVersionPrimary = null)
              : (p._workInProgressVersionSecondary = null);
          }
          io.length = 0;
        }
        var Yu = l.ReactCurrentDispatcher,
          oo = l.ReactCurrentBatchConfig,
          Qa = 0,
          Kn = null,
          Gr = null,
          Wr = null,
          Pf = !1,
          ds = !1,
          el = 0,
          qu = 0;
        function jr() {
          throw Error(s(321));
        }
        function If(d, p) {
          if (p === null) return !1;
          for (var M = 0; M < p.length && M < d.length; M++)
            if (!zr(d[M], p[M])) return !1;
          return !0;
        }
        function Kl(d, p, M, C, k, z) {
          if (
            ((Qa = z),
            (Kn = p),
            (p.memoizedState = null),
            (p.updateQueue = null),
            (p.lanes = 0),
            (Yu.current = d === null || d.memoizedState === null ? Nh : Uh),
            (d = M(C, k)),
            ds)
          ) {
            z = 0;
            do {
              if (((ds = !1), (el = 0), 25 <= z)) throw Error(s(301));
              (z += 1),
                (Wr = Gr = null),
                (p.updateQueue = null),
                (Yu.current = Fh),
                (d = M(C, k));
            } while (ds);
          }
          if (
            ((Yu.current = eu),
            (p = Gr !== null && Gr.next !== null),
            (Qa = 0),
            (Wr = Gr = Kn = null),
            (Pf = !1),
            p)
          )
            throw Error(s(300));
          return d;
        }
        function Sa() {
          var d = el !== 0;
          return (el = 0), d;
        }
        function Go() {
          var d = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return (
            Wr === null ? (Kn.memoizedState = Wr = d) : (Wr = Wr.next = d), Wr
          );
        }
        function Wo() {
          if (Gr === null) {
            var d = Kn.alternate;
            d = d !== null ? d.memoizedState : null;
          } else d = Gr.next;
          var p = Wr === null ? Kn.memoizedState : Wr.next;
          if (p !== null) (Wr = p), (Gr = d);
          else {
            if (d === null) throw Error(s(310));
            (Gr = d),
              (d = {
                memoizedState: Gr.memoizedState,
                baseState: Gr.baseState,
                baseQueue: Gr.baseQueue,
                queue: Gr.queue,
                next: null,
              }),
              Wr === null ? (Kn.memoizedState = Wr = d) : (Wr = Wr.next = d);
          }
          return Wr;
        }
        function hs(d, p) {
          return typeof p == "function" ? p(d) : p;
        }
        function Ku(d) {
          var p = Wo(),
            M = p.queue;
          if (M === null) throw Error(s(311));
          M.lastRenderedReducer = d;
          var C = Gr,
            k = C.baseQueue,
            z = M.pending;
          if (z !== null) {
            if (k !== null) {
              var se = k.next;
              (k.next = z.next), (z.next = se);
            }
            (C.baseQueue = k = z), (M.pending = null);
          }
          if (k !== null) {
            (z = k.next), (C = C.baseState);
            var we = (se = null),
              Qe = null,
              ct = z;
            do {
              var Tt = ct.lane;
              if ((Qa & Tt) === Tt)
                Qe !== null &&
                  (Qe = Qe.next =
                    {
                      lane: 0,
                      action: ct.action,
                      hasEagerState: ct.hasEagerState,
                      eagerState: ct.eagerState,
                      next: null,
                    }),
                  (C = ct.hasEagerState ? ct.eagerState : d(C, ct.action));
              else {
                var qt = {
                  lane: Tt,
                  action: ct.action,
                  hasEagerState: ct.hasEagerState,
                  eagerState: ct.eagerState,
                  next: null,
                };
                Qe === null ? ((we = Qe = qt), (se = C)) : (Qe = Qe.next = qt),
                  (Kn.lanes |= Tt),
                  (ul |= Tt);
              }
              ct = ct.next;
            } while (ct !== null && ct !== z);
            Qe === null ? (se = C) : (Qe.next = we),
              zr(C, p.memoizedState) || ($r = !0),
              (p.memoizedState = C),
              (p.baseState = se),
              (p.baseQueue = Qe),
              (M.lastRenderedState = C);
          }
          if (((d = M.interleaved), d !== null)) {
            k = d;
            do (z = k.lane), (Kn.lanes |= z), (ul |= z), (k = k.next);
            while (k !== d);
          } else k === null && (M.lanes = 0);
          return [p.memoizedState, M.dispatch];
        }
        function Zu(d) {
          var p = Wo(),
            M = p.queue;
          if (M === null) throw Error(s(311));
          M.lastRenderedReducer = d;
          var C = M.dispatch,
            k = M.pending,
            z = p.memoizedState;
          if (k !== null) {
            M.pending = null;
            var se = (k = k.next);
            do (z = d(z, se.action)), (se = se.next);
            while (se !== k);
            zr(z, p.memoizedState) || ($r = !0),
              (p.memoizedState = z),
              p.baseQueue === null && (p.baseState = z),
              (M.lastRenderedState = z);
          }
          return [z, C];
        }
        function Ih() {}
        function Lh(d, p) {
          var M = Kn,
            C = Wo(),
            k = p(),
            z = !zr(C.memoizedState, k);
          if (
            (z && ((C.memoizedState = k), ($r = !0)),
            (C = C.queue),
            Zl(zs.bind(null, M, C, d), [d]),
            C.getSnapshot !== p ||
              z ||
              (Wr !== null && Wr.memoizedState.tag & 1))
          ) {
            if (
              ((M.flags |= 2048),
              Qu(9, kh.bind(null, M, C, k, p), void 0, null),
              Zn === null)
            )
              throw Error(s(349));
            (Qa & 30) !== 0 || Dh(M, p, k);
          }
          return k;
        }
        function Dh(d, p, M) {
          (d.flags |= 16384),
            (d = { getSnapshot: p, value: M }),
            (p = Kn.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (Kn.updateQueue = p),
                (p.stores = [d]))
              : ((M = p.stores), M === null ? (p.stores = [d]) : M.push(d));
        }
        function kh(d, p, M, C) {
          (p.value = M), (p.getSnapshot = C), Lf(p) && Vi(d, 1, -1);
        }
        function zs(d, p, M) {
          return M(function () {
            Lf(p) && Vi(d, 1, -1);
          });
        }
        function Lf(d) {
          var p = d.getSnapshot;
          d = d.value;
          try {
            var M = p();
            return !zr(d, M);
          } catch {
            return !0;
          }
        }
        function Ju(d) {
          var p = Go();
          return (
            typeof d == "function" && (d = d()),
            (p.memoizedState = p.baseState = d),
            (d = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: hs,
              lastRenderedState: d,
            }),
            (p.queue = d),
            (d = d.dispatch = Yy.bind(null, Kn, d)),
            [p.memoizedState, d]
          );
        }
        function Qu(d, p, M, C) {
          return (
            (d = { tag: d, create: p, destroy: M, deps: C, next: null }),
            (p = Kn.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (Kn.updateQueue = p),
                (p.lastEffect = d.next = d))
              : ((M = p.lastEffect),
                M === null
                  ? (p.lastEffect = d.next = d)
                  : ((C = M.next),
                    (M.next = d),
                    (d.next = C),
                    (p.lastEffect = d))),
            d
          );
        }
        function eg() {
          return Wo().memoizedState;
        }
        function wa(d, p, M, C) {
          var k = Go();
          (Kn.flags |= d),
            (k.memoizedState = Qu(1 | p, M, void 0, C === void 0 ? null : C));
        }
        function Df(d, p, M, C) {
          var k = Wo();
          C = C === void 0 ? null : C;
          var z = void 0;
          if (Gr !== null) {
            var se = Gr.memoizedState;
            if (((z = se.destroy), C !== null && If(C, se.deps))) {
              k.memoizedState = Qu(p, M, z, C);
              return;
            }
          }
          (Kn.flags |= d), (k.memoizedState = Qu(1 | p, M, z, C));
        }
        function kf(d, p) {
          return wa(8390656, 8, d, p);
        }
        function Zl(d, p) {
          return Df(2048, 8, d, p);
        }
        function On(d, p) {
          return Df(4, 2, d, p);
        }
        function Of(d, p) {
          return Df(4, 4, d, p);
        }
        function ec(d, p) {
          if (typeof p == "function")
            return (
              (d = d()),
              p(d),
              function () {
                p(null);
              }
            );
          if (p != null)
            return (
              (d = d()),
              (p.current = d),
              function () {
                p.current = null;
              }
            );
        }
        function Jl(d, p, M) {
          return (
            (M = M != null ? M.concat([d]) : null),
            Df(4, 4, ec.bind(null, p, d), M)
          );
        }
        function Nf() {}
        function Uf(d, p) {
          var M = Wo();
          p = p === void 0 ? null : p;
          var C = M.memoizedState;
          return C !== null && p !== null && If(p, C[1])
            ? C[0]
            : ((M.memoizedState = [d, p]), d);
        }
        function Ql(d, p) {
          var M = Wo();
          p = p === void 0 ? null : p;
          var C = M.memoizedState;
          return C !== null && p !== null && If(p, C[1])
            ? C[0]
            : ((d = d()), (M.memoizedState = [d, p]), d);
        }
        function Ff(d, p) {
          var M = $t;
          ($t = M !== 0 && 4 > M ? M : 4), d(!0);
          var C = oo.transition;
          oo.transition = {};
          try {
            d(!1), p();
          } finally {
            ($t = M), (oo.transition = C);
          }
        }
        function tl() {
          return Wo().memoizedState;
        }
        function tg(d, p, M) {
          var C = vs(d);
          (M = {
            lane: C,
            action: M,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          }),
            ng(d)
              ? Oh(p, M)
              : (tc(d, p, M),
                (M = qr()),
                (d = Vi(d, C, M)),
                d !== null && nc(d, p, C));
        }
        function Yy(d, p, M) {
          var C = vs(d),
            k = {
              lane: C,
              action: M,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
          if (ng(d)) Oh(p, k);
          else {
            tc(d, p, k);
            var z = d.alternate;
            if (
              d.lanes === 0 &&
              (z === null || z.lanes === 0) &&
              ((z = p.lastRenderedReducer), z !== null)
            )
              try {
                var se = p.lastRenderedState,
                  we = z(se, M);
                if (((k.hasEagerState = !0), (k.eagerState = we), zr(we, se)))
                  return;
              } catch {
              } finally {
              }
            (M = qr()), (d = Vi(d, C, M)), d !== null && nc(d, p, C);
          }
        }
        function ng(d) {
          var p = d.alternate;
          return d === Kn || (p !== null && p === Kn);
        }
        function Oh(d, p) {
          ds = Pf = !0;
          var M = d.pending;
          M === null ? (p.next = p) : ((p.next = M.next), (M.next = p)),
            (d.pending = p);
        }
        function tc(d, p, M) {
          Zn !== null && (d.mode & 1) !== 0 && (nn & 2) === 0
            ? ((d = p.interleaved),
              d === null
                ? ((M.next = M), _i === null ? (_i = [p]) : _i.push(p))
                : ((M.next = d.next), (d.next = M)),
              (p.interleaved = M))
            : ((d = p.pending),
              d === null ? (M.next = M) : ((M.next = d.next), (d.next = M)),
              (p.pending = M));
        }
        function nc(d, p, M) {
          if ((M & 4194240) !== 0) {
            var C = p.lanes;
            (C &= d.pendingLanes), (M |= C), (p.lanes = M), ri(d, M);
          }
        }
        var eu = {
            readContext: Yn,
            useCallback: jr,
            useContext: jr,
            useEffect: jr,
            useImperativeHandle: jr,
            useInsertionEffect: jr,
            useLayoutEffect: jr,
            useMemo: jr,
            useReducer: jr,
            useRef: jr,
            useState: jr,
            useDebugValue: jr,
            useDeferredValue: jr,
            useTransition: jr,
            useMutableSource: jr,
            useSyncExternalStore: jr,
            useId: jr,
            unstable_isNewReconciler: !1,
          },
          Nh = {
            readContext: Yn,
            useCallback: function (d, p) {
              return (Go().memoizedState = [d, p === void 0 ? null : p]), d;
            },
            useContext: Yn,
            useEffect: kf,
            useImperativeHandle: function (d, p, M) {
              return (
                (M = M != null ? M.concat([d]) : null),
                wa(4194308, 4, ec.bind(null, p, d), M)
              );
            },
            useLayoutEffect: function (d, p) {
              return wa(4194308, 4, d, p);
            },
            useInsertionEffect: function (d, p) {
              return wa(4, 2, d, p);
            },
            useMemo: function (d, p) {
              var M = Go();
              return (
                (p = p === void 0 ? null : p),
                (d = d()),
                (M.memoizedState = [d, p]),
                d
              );
            },
            useReducer: function (d, p, M) {
              var C = Go();
              return (
                (p = M !== void 0 ? M(p) : p),
                (C.memoizedState = C.baseState = p),
                (d = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: d,
                  lastRenderedState: p,
                }),
                (C.queue = d),
                (d = d.dispatch = tg.bind(null, Kn, d)),
                [C.memoizedState, d]
              );
            },
            useRef: function (d) {
              var p = Go();
              return (d = { current: d }), (p.memoizedState = d);
            },
            useState: Ju,
            useDebugValue: Nf,
            useDeferredValue: function (d) {
              var p = Ju(d),
                M = p[0],
                C = p[1];
              return (
                kf(
                  function () {
                    var k = oo.transition;
                    oo.transition = {};
                    try {
                      C(d);
                    } finally {
                      oo.transition = k;
                    }
                  },
                  [d]
                ),
                M
              );
            },
            useTransition: function () {
              var d = Ju(!1),
                p = d[0];
              return (
                (d = Ff.bind(null, d[1])), (Go().memoizedState = d), [p, d]
              );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (d, p, M) {
              var C = Kn,
                k = Go();
              if (Wn) {
                if (M === void 0) throw Error(s(407));
                M = M();
              } else {
                if (((M = p()), Zn === null)) throw Error(s(349));
                (Qa & 30) !== 0 || Dh(C, p, M);
              }
              k.memoizedState = M;
              var z = { value: M, getSnapshot: p };
              return (
                (k.queue = z),
                kf(zs.bind(null, C, z, d), [d]),
                (C.flags |= 2048),
                Qu(9, kh.bind(null, C, z, M, p), void 0, null),
                M
              );
            },
            useId: function () {
              var d = Go(),
                p = Zn.identifierPrefix;
              if (Wn) {
                var M = Us,
                  C = Ns;
                (M = (C & ~(1 << (32 - ci(C) - 1))).toString(32) + M),
                  (p = ":" + p + "R" + M),
                  (M = el++),
                  0 < M && (p += "H" + M.toString(32)),
                  (p += ":");
              } else (M = qu++), (p = ":" + p + "r" + M.toString(32) + ":");
              return (d.memoizedState = p);
            },
            unstable_isNewReconciler: !1,
          },
          Uh = {
            readContext: Yn,
            useCallback: Uf,
            useContext: Yn,
            useEffect: Zl,
            useImperativeHandle: Jl,
            useInsertionEffect: On,
            useLayoutEffect: Of,
            useMemo: Ql,
            useReducer: Ku,
            useRef: eg,
            useState: function () {
              return Ku(hs);
            },
            useDebugValue: Nf,
            useDeferredValue: function (d) {
              var p = Ku(hs),
                M = p[0],
                C = p[1];
              return (
                Zl(
                  function () {
                    var k = oo.transition;
                    oo.transition = {};
                    try {
                      C(d);
                    } finally {
                      oo.transition = k;
                    }
                  },
                  [d]
                ),
                M
              );
            },
            useTransition: function () {
              var d = Ku(hs)[0],
                p = Wo().memoizedState;
              return [d, p];
            },
            useMutableSource: Ih,
            useSyncExternalStore: Lh,
            useId: tl,
            unstable_isNewReconciler: !1,
          },
          Fh = {
            readContext: Yn,
            useCallback: Uf,
            useContext: Yn,
            useEffect: Zl,
            useImperativeHandle: Jl,
            useInsertionEffect: On,
            useLayoutEffect: Of,
            useMemo: Ql,
            useReducer: Zu,
            useRef: eg,
            useState: function () {
              return Zu(hs);
            },
            useDebugValue: Nf,
            useDeferredValue: function (d) {
              var p = Zu(hs),
                M = p[0],
                C = p[1];
              return (
                Zl(
                  function () {
                    var k = oo.transition;
                    oo.transition = {};
                    try {
                      C(d);
                    } finally {
                      oo.transition = k;
                    }
                  },
                  [d]
                ),
                M
              );
            },
            useTransition: function () {
              var d = Zu(hs)[0],
                p = Wo().memoizedState;
              return [d, p];
            },
            useMutableSource: Ih,
            useSyncExternalStore: Lh,
            useId: tl,
            unstable_isNewReconciler: !1,
          };
        function zh(d, p) {
          try {
            var M = "",
              C = p;
            do (M += Is(C)), (C = C.return);
            while (C);
            var k = M;
          } catch (z) {
            k =
              `
Error generating stack: ` +
              z.message +
              `
` +
              z.stack;
          }
          return { value: d, source: p, stack: k };
        }
        function zf(d, p) {
          try {
            console.error(p.value);
          } catch (M) {
            setTimeout(function () {
              throw M;
            });
          }
        }
        var qy = typeof WeakMap == "function" ? WeakMap : Map;
        function rg(d, p, M) {
          (M = Os(-1, M)), (M.tag = 3), (M.payload = { element: null });
          var C = p.value;
          return (
            (M.callback = function () {
              Ca || ((Ca = !0), (Co = C)), zf(d, p);
            }),
            M
          );
        }
        function Bf(d, p, M) {
          (M = Os(-1, M)), (M.tag = 3);
          var C = d.type.getDerivedStateFromError;
          if (typeof C == "function") {
            var k = p.value;
            (M.payload = function () {
              return C(k);
            }),
              (M.callback = function () {
                zf(d, p);
              });
          }
          var z = d.stateNode;
          return (
            z !== null &&
              typeof z.componentDidCatch == "function" &&
              (M.callback = function () {
                zf(d, p),
                  typeof C != "function" &&
                    (Ao === null ? (Ao = new Set([this])) : Ao.add(this));
                var se = p.stack;
                this.componentDidCatch(p.value, {
                  componentStack: se !== null ? se : "",
                });
              }),
            M
          );
        }
        function Bs(d, p, M) {
          var C = d.pingCache;
          if (C === null) {
            C = d.pingCache = new qy();
            var k = new Set();
            C.set(p, k);
          } else (k = C.get(p)), k === void 0 && ((k = new Set()), C.set(p, k));
          k.has(M) || (k.add(M), (d = ag.bind(null, d, p, M)), p.then(d, d));
        }
        function Bh(d) {
          do {
            var p;
            if (
              ((p = d.tag === 13) &&
                ((p = d.memoizedState),
                (p = p !== null ? p.dehydrated !== null : !0)),
              p)
            )
              return d;
            d = d.return;
          } while (d !== null);
          return null;
        }
        function nl(d, p, M, C, k) {
          return (d.mode & 1) === 0
            ? (d === p
                ? (d.flags |= 65536)
                : ((d.flags |= 128),
                  (M.flags |= 131072),
                  (M.flags &= -52805),
                  M.tag === 1 &&
                    (M.alternate === null
                      ? (M.tag = 17)
                      : ((p = Os(-1, 1)), (p.tag = 2), va(M, p))),
                  (M.lanes |= 1)),
              d)
            : ((d.flags |= 65536), (d.lanes = k), d);
        }
        function Rr(d) {
          d.flags |= 4;
        }
        function tu(d, p) {
          if (d !== null && d.child === p.child) return !0;
          if ((p.flags & 16) !== 0) return !1;
          for (d = p.child; d !== null; ) {
            if ((d.flags & 12854) !== 0 || (d.subtreeFlags & 12854) !== 0)
              return !1;
            d = d.sibling;
          }
          return !0;
        }
        var so, rl, Vf, Hf;
        if (Ae)
          (so = function (d, p) {
            for (var M = p.child; M !== null; ) {
              if (M.tag === 5 || M.tag === 6) te(d, M.stateNode);
              else if (M.tag !== 4 && M.child !== null) {
                (M.child.return = M), (M = M.child);
                continue;
              }
              if (M === p) break;
              for (; M.sibling === null; ) {
                if (M.return === null || M.return === p) return;
                M = M.return;
              }
              (M.sibling.return = M.return), (M = M.sibling);
            }
          }),
            (rl = function () {}),
            (Vf = function (d, p, M, C, k) {
              if (((d = d.memoizedProps), d !== C)) {
                var z = p.stateNode,
                  se = Ho(Fi.current);
                (M = J(z, M, d, C, k, se)), (p.updateQueue = M) && Rr(p);
              }
            }),
            (Hf = function (d, p, M, C) {
              M !== C && Rr(p);
            });
        else if (W) {
          so = function (d, p, M, C) {
            for (var k = p.child; k !== null; ) {
              if (k.tag === 5) {
                var z = k.stateNode;
                M && C && (z = jt(z, k.type, k.memoizedProps, k)), te(d, z);
              } else if (k.tag === 6)
                (z = k.stateNode),
                  M && C && (z = an(z, k.memoizedProps, k)),
                  te(d, z);
              else if (k.tag !== 4) {
                if (k.tag === 22 && k.memoizedState !== null)
                  (z = k.child), z !== null && (z.return = k), so(d, k, !0, !0);
                else if (k.child !== null) {
                  (k.child.return = k), (k = k.child);
                  continue;
                }
              }
              if (k === p) break;
              for (; k.sibling === null; ) {
                if (k.return === null || k.return === p) return;
                k = k.return;
              }
              (k.sibling.return = k.return), (k = k.sibling);
            }
          };
          var Ma = function (d, p, M, C) {
            for (var k = p.child; k !== null; ) {
              if (k.tag === 5) {
                var z = k.stateNode;
                M && C && (z = jt(z, k.type, k.memoizedProps, k)), Ot(d, z);
              } else if (k.tag === 6)
                (z = k.stateNode),
                  M && C && (z = an(z, k.memoizedProps, k)),
                  Ot(d, z);
              else if (k.tag !== 4) {
                if (k.tag === 22 && k.memoizedState !== null)
                  (z = k.child), z !== null && (z.return = k), Ma(d, k, !0, !0);
                else if (k.child !== null) {
                  (k.child.return = k), (k = k.child);
                  continue;
                }
              }
              if (k === p) break;
              for (; k.sibling === null; ) {
                if (k.return === null || k.return === p) return;
                k = k.return;
              }
              (k.sibling.return = k.return), (k = k.sibling);
            }
          };
          (rl = function (d, p) {
            var M = p.stateNode;
            if (!tu(d, p)) {
              d = M.containerInfo;
              var C = gt(d);
              Ma(C, p, !1, !1), (M.pendingChildren = C), Rr(p), Nt(d, C);
            }
          }),
            (Vf = function (d, p, M, C, k) {
              var z = d.stateNode,
                se = d.memoizedProps;
              if ((d = tu(d, p)) && se === C) p.stateNode = z;
              else {
                var we = p.stateNode,
                  Qe = Ho(Fi.current),
                  ct = null;
                se !== C && (ct = J(we, M, se, C, k, Qe)),
                  d && ct === null
                    ? (p.stateNode = z)
                    : ((z = mt(z, ct, M, se, C, p, d, we)),
                      le(z, M, C, k, Qe) && Rr(p),
                      (p.stateNode = z),
                      d ? Rr(p) : so(z, p, !1, !1));
              }
            }),
            (Hf = function (d, p, M, C) {
              M !== C
                ? ((d = Ho(Za.current)),
                  (M = Ho(Fi.current)),
                  (p.stateNode = he(C, d, M, p)),
                  Rr(p))
                : (p.stateNode = d.stateNode);
            });
        } else
          (rl = function () {}), (Vf = function () {}), (Hf = function () {});
        function Vs(d, p) {
          if (!Wn)
            switch (d.tailMode) {
              case "hidden":
                p = d.tail;
                for (var M = null; p !== null; )
                  p.alternate !== null && (M = p), (p = p.sibling);
                M === null ? (d.tail = null) : (M.sibling = null);
                break;
              case "collapsed":
                M = d.tail;
                for (var C = null; M !== null; )
                  M.alternate !== null && (C = M), (M = M.sibling);
                C === null
                  ? p || d.tail === null
                    ? (d.tail = null)
                    : (d.tail.sibling = null)
                  : (C.sibling = null);
            }
        }
        function ar(d) {
          var p = d.alternate !== null && d.alternate.child === d.child,
            M = 0,
            C = 0;
          if (p)
            for (var k = d.child; k !== null; )
              (M |= k.lanes | k.childLanes),
                (C |= k.subtreeFlags & 14680064),
                (C |= k.flags & 14680064),
                (k.return = d),
                (k = k.sibling);
          else
            for (k = d.child; k !== null; )
              (M |= k.lanes | k.childLanes),
                (C |= k.subtreeFlags),
                (C |= k.flags),
                (k.return = d),
                (k = k.sibling);
          return (d.subtreeFlags |= C), (d.childLanes = M), p;
        }
        function Gf(d, p, M) {
          var C = p.pendingProps;
          switch ((Ch(p), p.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return ar(p), null;
            case 1:
              return Bn(p.type) && ln(), ar(p), null;
            case 3:
              return (
                (C = p.stateNode),
                ql(),
                wt(wn),
                wt(Bt),
                Ja(),
                C.pendingContext &&
                  ((C.context = C.pendingContext), (C.pendingContext = null)),
                (d === null || d.child === null) &&
                  (Xu(p)
                    ? Rr(p)
                    : d === null ||
                      (d.memoizedState.isDehydrated && (p.flags & 256) === 0) ||
                      ((p.flags |= 1024),
                      Mo !== null && (ur(Mo), (Mo = null)))),
                rl(d, p),
                ar(p),
                null
              );
            case 5:
              Ph(p), (M = Ho(Za.current));
              var k = p.type;
              if (d !== null && p.stateNode != null)
                Vf(d, p, k, C, M),
                  d.ref !== p.ref && ((p.flags |= 512), (p.flags |= 2097152));
              else {
                if (!C) {
                  if (p.stateNode === null) throw Error(s(166));
                  return ar(p), null;
                }
                if (((d = Ho(Fi.current)), Xu(p))) {
                  if (!_e) throw Error(s(175));
                  (d = Fl(p.stateNode, p.type, p.memoizedProps, M, d, p, !Wl)),
                    (p.updateQueue = d),
                    d !== null && Rr(p);
                } else {
                  var z = G(k, C, M, d, p);
                  so(z, p, !1, !1),
                    (p.stateNode = z),
                    le(z, k, C, M, d) && Rr(p);
                }
                p.ref !== null && ((p.flags |= 512), (p.flags |= 2097152));
              }
              return ar(p), null;
            case 6:
              if (d && p.stateNode != null) Hf(d, p, d.memoizedProps, C);
              else {
                if (typeof C != "string" && p.stateNode === null)
                  throw Error(s(166));
                if (((d = Ho(Za.current)), (M = Ho(Fi.current)), Xu(p))) {
                  if (!_e) throw Error(s(176));
                  if (
                    ((d = p.stateNode),
                    (C = p.memoizedProps),
                    (M = eo(d, C, p, !Wl)) && ((k = Si), k !== null))
                  )
                    switch (((z = (k.mode & 1) !== 0), k.tag)) {
                      case 3:
                        vt(k.stateNode.containerInfo, d, C, z);
                        break;
                      case 5:
                        Et(k.type, k.memoizedProps, k.stateNode, d, C, z);
                    }
                  M && Rr(p);
                } else p.stateNode = he(C, d, M, p);
              }
              return ar(p), null;
            case 13:
              if (
                (wt(qn),
                (C = p.memoizedState),
                Wn &&
                  ii !== null &&
                  (p.mode & 1) !== 0 &&
                  (p.flags & 128) === 0)
              ) {
                for (d = ii; d; ) d = Er(d);
                return jl(), (p.flags |= 98560), p;
              }
              if (C !== null && C.dehydrated !== null) {
                if (((C = Xu(p)), d === null)) {
                  if (!C) throw Error(s(318));
                  if (!_e) throw Error(s(344));
                  if (
                    ((d = p.memoizedState),
                    (d = d !== null ? d.dehydrated : null),
                    !d)
                  )
                    throw Error(s(317));
                  zl(d, p);
                } else
                  jl(),
                    (p.flags & 128) === 0 && (p.memoizedState = null),
                    (p.flags |= 4);
                return ar(p), null;
              }
              return (
                Mo !== null && (ur(Mo), (Mo = null)),
                (p.flags & 128) !== 0
                  ? ((p.lanes = M), p)
                  : ((C = C !== null),
                    (M = !1),
                    d === null ? Xu(p) : (M = d.memoizedState !== null),
                    C &&
                      !M &&
                      ((p.child.flags |= 8192),
                      (p.mode & 1) !== 0 &&
                        (d === null || (qn.current & 1) !== 0
                          ? yr === 0 && (yr = 3)
                          : fc())),
                    p.updateQueue !== null && (p.flags |= 4),
                    ar(p),
                    null)
              );
            case 4:
              return (
                ql(),
                rl(d, p),
                d === null && ke(p.stateNode.containerInfo),
                ar(p),
                null
              );
            case 10:
              return vr(p.type._context), ar(p), null;
            case 17:
              return Bn(p.type) && ln(), ar(p), null;
            case 19:
              if ((wt(qn), (k = p.memoizedState), k === null))
                return ar(p), null;
              if (((C = (p.flags & 128) !== 0), (z = k.rendering), z === null))
                if (C) Vs(k, !1);
                else {
                  if (yr !== 0 || (d !== null && (d.flags & 128) !== 0))
                    for (d = p.child; d !== null; ) {
                      if (((z = Rf(d)), z !== null)) {
                        for (
                          p.flags |= 128,
                            Vs(k, !1),
                            d = z.updateQueue,
                            d !== null && ((p.updateQueue = d), (p.flags |= 4)),
                            p.subtreeFlags = 0,
                            d = M,
                            C = p.child;
                          C !== null;

                        )
                          (M = C),
                            (k = d),
                            (M.flags &= 14680066),
                            (z = M.alternate),
                            z === null
                              ? ((M.childLanes = 0),
                                (M.lanes = k),
                                (M.child = null),
                                (M.subtreeFlags = 0),
                                (M.memoizedProps = null),
                                (M.memoizedState = null),
                                (M.updateQueue = null),
                                (M.dependencies = null),
                                (M.stateNode = null))
                              : ((M.childLanes = z.childLanes),
                                (M.lanes = z.lanes),
                                (M.child = z.child),
                                (M.subtreeFlags = 0),
                                (M.deletions = null),
                                (M.memoizedProps = z.memoizedProps),
                                (M.memoizedState = z.memoizedState),
                                (M.updateQueue = z.updateQueue),
                                (M.type = z.type),
                                (k = z.dependencies),
                                (M.dependencies =
                                  k === null
                                    ? null
                                    : {
                                        lanes: k.lanes,
                                        firstContext: k.firstContext,
                                      })),
                            (C = C.sibling);
                        return dt(qn, (qn.current & 1) | 2), p.child;
                      }
                      d = d.sibling;
                    }
                  k.tail !== null &&
                    Gn() > Ta &&
                    ((p.flags |= 128),
                    (C = !0),
                    Vs(k, !1),
                    (p.lanes = 4194304));
                }
              else {
                if (!C)
                  if (((d = Rf(z)), d !== null)) {
                    if (
                      ((p.flags |= 128),
                      (C = !0),
                      (d = d.updateQueue),
                      d !== null && ((p.updateQueue = d), (p.flags |= 4)),
                      Vs(k, !0),
                      k.tail === null &&
                        k.tailMode === "hidden" &&
                        !z.alternate &&
                        !Wn)
                    )
                      return ar(p), null;
                  } else
                    2 * Gn() - k.renderingStartTime > Ta &&
                      M !== 1073741824 &&
                      ((p.flags |= 128),
                      (C = !0),
                      Vs(k, !1),
                      (p.lanes = 4194304));
                k.isBackwards
                  ? ((z.sibling = p.child), (p.child = z))
                  : ((d = k.last),
                    d !== null ? (d.sibling = z) : (p.child = z),
                    (k.last = z));
              }
              return k.tail !== null
                ? ((p = k.tail),
                  (k.rendering = p),
                  (k.tail = p.sibling),
                  (k.renderingStartTime = Gn()),
                  (p.sibling = null),
                  (d = qn.current),
                  dt(qn, C ? (d & 1) | 2 : d & 1),
                  p)
                : (ar(p), null);
            case 22:
            case 23:
              return (
                qh(),
                (C = p.memoizedState !== null),
                d !== null &&
                  (d.memoizedState !== null) !== C &&
                  (p.flags |= 8192),
                C && (p.mode & 1) !== 0
                  ? (Ti & 1073741824) !== 0 &&
                    (ar(p), Ae && p.subtreeFlags & 6 && (p.flags |= 8192))
                  : ar(p),
                null
              );
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(s(156, p.tag));
        }
        var Vh = l.ReactCurrentOwner,
          $r = !1;
        function Qn(d, p, M, C) {
          p.child = d === null ? Jm(p, null, M, C) : Fs(p, d.child, M, C);
        }
        function Nn(d, p, M, C, k) {
          M = M.render;
          var z = p.ref;
          return (
            sr(p, k),
            (C = Kl(d, p, M, C, z, k)),
            (M = Sa()),
            d !== null && !$r
              ? ((p.updateQueue = d.updateQueue),
                (p.flags &= -2053),
                (d.lanes &= ~k),
                zi(d, p, k))
              : (Wn && M && Th(p), (p.flags |= 1), Qn(d, p, C, k), p.child)
          );
        }
        function Dn(d, p, M, C, k) {
          if (d === null) {
            var z = M.type;
            return typeof z == "function" &&
              !mc(z) &&
              z.defaultProps === void 0 &&
              M.compare === null &&
              M.defaultProps === void 0
              ? ((p.tag = 15), (p.type = z), Hs(d, p, z, C, k))
              : ((d = gc(M.type, null, C, p, p.mode, k)),
                (d.ref = p.ref),
                (d.return = p),
                (p.child = d));
          }
          if (((z = d.child), (d.lanes & k) === 0)) {
            var se = z.memoizedProps;
            if (
              ((M = M.compare),
              (M = M !== null ? M : Ni),
              M(se, C) && d.ref === p.ref)
            )
              return zi(d, p, k);
          }
          return (
            (p.flags |= 1),
            (d = qs(z, C)),
            (d.ref = p.ref),
            (d.return = p),
            (p.child = d)
          );
        }
        function Hs(d, p, M, C, k) {
          if (d !== null && Ni(d.memoizedProps, C) && d.ref === p.ref)
            if ((($r = !1), (d.lanes & k) !== 0))
              (d.flags & 131072) !== 0 && ($r = !0);
            else return (p.lanes = d.lanes), zi(d, p, k);
          return Gs(d, p, M, C, k);
        }
        function oi(d, p, M) {
          var C = p.pendingProps,
            k = C.children,
            z = d !== null ? d.memoizedState : null;
          if (C.mode === "hidden")
            if ((p.mode & 1) === 0)
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                dt(Ys, Ti),
                (Ti |= M);
            else if ((M & 1073741824) !== 0)
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                (C = z !== null ? z.baseLanes : M),
                dt(Ys, Ti),
                (Ti |= C);
            else
              return (
                (d = z !== null ? z.baseLanes | M : M),
                (p.lanes = p.childLanes = 1073741824),
                (p.memoizedState = { baseLanes: d, cachePool: null }),
                (p.updateQueue = null),
                dt(Ys, Ti),
                (Ti |= d),
                null
              );
          else
            z !== null
              ? ((C = z.baseLanes | M), (p.memoizedState = null))
              : (C = M),
              dt(Ys, Ti),
              (Ti |= C);
          return Qn(d, p, k, M), p.child;
        }
        function wi(d, p) {
          var M = p.ref;
          ((d === null && M !== null) || (d !== null && d.ref !== M)) &&
            ((p.flags |= 512), (p.flags |= 2097152));
        }
        function Gs(d, p, M, C, k) {
          var z = Bn(M) ? ni : Bt.current;
          return (
            (z = Cn(p, z)),
            sr(p, k),
            (M = Kl(d, p, M, C, z, k)),
            (C = Sa()),
            d !== null && !$r
              ? ((p.updateQueue = d.updateQueue),
                (p.flags &= -2053),
                (d.lanes &= ~k),
                zi(d, p, k))
              : (Wn && C && Th(p), (p.flags |= 1), Qn(d, p, M, k), p.child)
          );
        }
        function il(d, p, M, C, k) {
          if (Bn(M)) {
            var z = !0;
            or(p);
          } else z = !1;
          if ((sr(p, k), p.stateNode === null))
            d !== null &&
              ((d.alternate = null), (p.alternate = null), (p.flags |= 2)),
              Xm(p, M, C),
              Eh(p, M, C, k),
              (C = !0);
          else if (d === null) {
            var se = p.stateNode,
              we = p.memoizedProps;
            se.props = we;
            var Qe = se.context,
              ct = M.contextType;
            typeof ct == "object" && ct !== null
              ? (ct = Yn(ct))
              : ((ct = Bn(M) ? ni : Bt.current), (ct = Cn(p, ct)));
            var Tt = M.getDerivedStateFromProps,
              qt =
                typeof Tt == "function" ||
                typeof se.getSnapshotBeforeUpdate == "function";
            qt ||
              (typeof se.UNSAFE_componentWillReceiveProps != "function" &&
                typeof se.componentWillReceiveProps != "function") ||
              ((we !== C || Qe !== ct) && Ym(p, se, C, ct)),
              (So = !1);
            var zt = p.memoizedState;
            (se.state = zt),
              wf(p, C, se, k),
              (Qe = p.memoizedState),
              we !== C || zt !== Qe || wn.current || So
                ? (typeof Tt == "function" &&
                    (Mh(p, M, Tt, C), (Qe = p.memoizedState)),
                  (we = So || bh(p, M, we, C, zt, Qe, ct))
                    ? (qt ||
                        (typeof se.UNSAFE_componentWillMount != "function" &&
                          typeof se.componentWillMount != "function") ||
                        (typeof se.componentWillMount == "function" &&
                          se.componentWillMount(),
                        typeof se.UNSAFE_componentWillMount == "function" &&
                          se.UNSAFE_componentWillMount()),
                      typeof se.componentDidMount == "function" &&
                        (p.flags |= 4194308))
                    : (typeof se.componentDidMount == "function" &&
                        (p.flags |= 4194308),
                      (p.memoizedProps = C),
                      (p.memoizedState = Qe)),
                  (se.props = C),
                  (se.state = Qe),
                  (se.context = ct),
                  (C = we))
                : (typeof se.componentDidMount == "function" &&
                    (p.flags |= 4194308),
                  (C = !1));
          } else {
            (se = p.stateNode),
              wh(d, p),
              (we = p.memoizedProps),
              (ct = p.type === p.elementType ? we : Vr(p.type, we)),
              (se.props = ct),
              (qt = p.pendingProps),
              (zt = se.context),
              (Qe = M.contextType),
              typeof Qe == "object" && Qe !== null
                ? (Qe = Yn(Qe))
                : ((Qe = Bn(M) ? ni : Bt.current), (Qe = Cn(p, Qe)));
            var kn = M.getDerivedStateFromProps;
            (Tt =
              typeof kn == "function" ||
              typeof se.getSnapshotBeforeUpdate == "function") ||
              (typeof se.UNSAFE_componentWillReceiveProps != "function" &&
                typeof se.componentWillReceiveProps != "function") ||
              ((we !== qt || zt !== Qe) && Ym(p, se, C, Qe)),
              (So = !1),
              (zt = p.memoizedState),
              (se.state = zt),
              wf(p, C, se, k);
            var Mt = p.memoizedState;
            we !== qt || zt !== Mt || wn.current || So
              ? (typeof kn == "function" &&
                  (Mh(p, M, kn, C), (Mt = p.memoizedState)),
                (ct = So || bh(p, M, ct, C, zt, Mt, Qe) || !1)
                  ? (Tt ||
                      (typeof se.UNSAFE_componentWillUpdate != "function" &&
                        typeof se.componentWillUpdate != "function") ||
                      (typeof se.componentWillUpdate == "function" &&
                        se.componentWillUpdate(C, Mt, Qe),
                      typeof se.UNSAFE_componentWillUpdate == "function" &&
                        se.UNSAFE_componentWillUpdate(C, Mt, Qe)),
                    typeof se.componentDidUpdate == "function" &&
                      (p.flags |= 4),
                    typeof se.getSnapshotBeforeUpdate == "function" &&
                      (p.flags |= 1024))
                  : (typeof se.componentDidUpdate != "function" ||
                      (we === d.memoizedProps && zt === d.memoizedState) ||
                      (p.flags |= 4),
                    typeof se.getSnapshotBeforeUpdate != "function" ||
                      (we === d.memoizedProps && zt === d.memoizedState) ||
                      (p.flags |= 1024),
                    (p.memoizedProps = C),
                    (p.memoizedState = Mt)),
                (se.props = C),
                (se.state = Mt),
                (se.context = Qe),
                (C = ct))
              : (typeof se.componentDidUpdate != "function" ||
                  (we === d.memoizedProps && zt === d.memoizedState) ||
                  (p.flags |= 4),
                typeof se.getSnapshotBeforeUpdate != "function" ||
                  (we === d.memoizedProps && zt === d.memoizedState) ||
                  (p.flags |= 1024),
                (C = !1));
          }
          return hi(d, p, M, C, z, k);
        }
        function hi(d, p, M, C, k, z) {
          wi(d, p);
          var se = (p.flags & 128) !== 0;
          if (!C && !se) return k && Tr(p, M, !1), zi(d, p, z);
          (C = p.stateNode), (Vh.current = p);
          var we =
            se && typeof M.getDerivedStateFromError != "function"
              ? null
              : C.render();
          return (
            (p.flags |= 1),
            d !== null && se
              ? ((p.child = Fs(p, d.child, null, z)),
                (p.child = Fs(p, null, we, z)))
              : Qn(d, p, we, z),
            (p.memoizedState = C.state),
            k && Tr(p, M, !0),
            p.child
          );
        }
        function rc(d) {
          var p = d.stateNode;
          p.pendingContext
            ? Fr(d, p.pendingContext, p.pendingContext !== p.context)
            : p.context && Fr(d, p.context, !1),
            Af(d, p.containerInfo);
        }
        function Hh(d, p, M, C, k) {
          return jl(), Cf(k), (p.flags |= 256), Qn(d, p, M, C), p.child;
        }
        var ic = { dehydrated: null, treeContext: null, retryLane: 0 };
        function ol(d) {
          return { baseLanes: d, cachePool: null };
        }
        function Gh(d, p, M) {
          var C = p.pendingProps,
            k = qn.current,
            z = !1,
            se = (p.flags & 128) !== 0,
            we;
          if (
            ((we = se) ||
              (we =
                d !== null && d.memoizedState === null ? !1 : (k & 2) !== 0),
            we
              ? ((z = !0), (p.flags &= -129))
              : (d === null || d.memoizedState !== null) && (k |= 1),
            dt(qn, k & 1),
            d === null)
          )
            return (
              xa(p),
              (d = p.memoizedState),
              d !== null && ((d = d.dehydrated), d !== null)
                ? ((p.mode & 1) === 0
                    ? (p.lanes = 1)
                    : mr(d)
                    ? (p.lanes = 8)
                    : (p.lanes = 1073741824),
                  null)
                : ((k = C.children),
                  (d = C.fallback),
                  z
                    ? ((C = p.mode),
                      (z = p.child),
                      (k = { mode: "hidden", children: k }),
                      (C & 1) === 0 && z !== null
                        ? ((z.childLanes = 0), (z.pendingProps = k))
                        : (z = hu(k, C, 0, null)),
                      (d = La(d, C, M, null)),
                      (z.return = p),
                      (d.return = p),
                      (z.sibling = d),
                      (p.child = z),
                      (p.child.memoizedState = ol(M)),
                      (p.memoizedState = ic),
                      d)
                    : jo(p, k))
            );
          if (((k = d.memoizedState), k !== null)) {
            if (((we = k.dehydrated), we !== null)) {
              if (se)
                return p.flags & 256
                  ? ((p.flags &= -257), sc(d, p, M, Error(s(422))))
                  : p.memoizedState !== null
                  ? ((p.child = d.child), (p.flags |= 128), null)
                  : ((z = C.fallback),
                    (k = p.mode),
                    (C = hu(
                      { mode: "visible", children: C.children },
                      k,
                      0,
                      null
                    )),
                    (z = La(z, k, M, null)),
                    (z.flags |= 2),
                    (C.return = p),
                    (z.return = p),
                    (C.sibling = z),
                    (p.child = C),
                    (p.mode & 1) !== 0 && Fs(p, d.child, null, M),
                    (p.child.memoizedState = ol(M)),
                    (p.memoizedState = ic),
                    z);
              if ((p.mode & 1) === 0) p = sc(d, p, M, null);
              else if (mr(we)) p = sc(d, p, M, Error(s(419)));
              else if (((C = (M & d.childLanes) !== 0), $r || C)) {
                if (((C = Zn), C !== null)) {
                  switch (M & -M) {
                    case 4:
                      z = 2;
                      break;
                    case 16:
                      z = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      z = 32;
                      break;
                    case 536870912:
                      z = 268435456;
                      break;
                    default:
                      z = 0;
                  }
                  (C = (z & (C.suspendedLanes | M)) !== 0 ? 0 : z),
                    C !== 0 &&
                      C !== k.retryLane &&
                      ((k.retryLane = C), Vi(d, C, -1));
                }
                fc(), (p = sc(d, p, M, Error(s(421))));
              } else
                Oi(we)
                  ? ((p.flags |= 128),
                    (p.child = d.child),
                    (p = lg.bind(null, d)),
                    Nr(we, p),
                    (p = null))
                  : ((M = k.treeContext),
                    _e &&
                      ((ii = go(we)),
                      (Si = p),
                      (Wn = !0),
                      (Mo = null),
                      (Wl = !1),
                      M !== null &&
                        ((wo[ro++] = Ns),
                        (wo[ro++] = Us),
                        (wo[ro++] = Ya),
                        (Ns = M.id),
                        (Us = M.overflow),
                        (Ya = p))),
                    (p = jo(p, p.pendingProps.children)),
                    (p.flags |= 4096));
              return p;
            }
            return z
              ? ((C = Wf(d, p, C.children, C.fallback, M)),
                (z = p.child),
                (k = d.child.memoizedState),
                (z.memoizedState =
                  k === null
                    ? ol(M)
                    : { baseLanes: k.baseLanes | M, cachePool: null }),
                (z.childLanes = d.childLanes & ~M),
                (p.memoizedState = ic),
                C)
              : ((M = oc(d, p, C.children, M)), (p.memoizedState = null), M);
          }
          return z
            ? ((C = Wf(d, p, C.children, C.fallback, M)),
              (z = p.child),
              (k = d.child.memoizedState),
              (z.memoizedState =
                k === null
                  ? ol(M)
                  : { baseLanes: k.baseLanes | M, cachePool: null }),
              (z.childLanes = d.childLanes & ~M),
              (p.memoizedState = ic),
              C)
            : ((M = oc(d, p, C.children, M)), (p.memoizedState = null), M);
        }
        function jo(d, p) {
          return (
            (p = hu({ mode: "visible", children: p }, d.mode, 0, null)),
            (p.return = d),
            (d.child = p)
          );
        }
        function oc(d, p, M, C) {
          var k = d.child;
          return (
            (d = k.sibling),
            (M = qs(k, { mode: "visible", children: M })),
            (p.mode & 1) === 0 && (M.lanes = C),
            (M.return = p),
            (M.sibling = null),
            d !== null &&
              ((C = p.deletions),
              C === null ? ((p.deletions = [d]), (p.flags |= 16)) : C.push(d)),
            (p.child = M)
          );
        }
        function Wf(d, p, M, C, k) {
          var z = p.mode;
          d = d.child;
          var se = d.sibling,
            we = { mode: "hidden", children: M };
          return (
            (z & 1) === 0 && p.child !== d
              ? ((M = p.child),
                (M.childLanes = 0),
                (M.pendingProps = we),
                (p.deletions = null))
              : ((M = qs(d, we)), (M.subtreeFlags = d.subtreeFlags & 14680064)),
            se !== null
              ? (C = qs(se, C))
              : ((C = La(C, z, k, null)), (C.flags |= 2)),
            (C.return = p),
            (M.return = p),
            (M.sibling = C),
            (p.child = M),
            C
          );
        }
        function sc(d, p, M, C) {
          return (
            C !== null && Cf(C),
            Fs(p, d.child, null, M),
            (d = jo(p, p.pendingProps.children)),
            (d.flags |= 2),
            (p.memoizedState = null),
            d
          );
        }
        function ig(d, p, M) {
          d.lanes |= p;
          var C = d.alternate;
          C !== null && (C.lanes |= p), Ar(d.return, p, M);
        }
        function ps(d, p, M, C, k) {
          var z = d.memoizedState;
          z === null
            ? (d.memoizedState = {
                isBackwards: p,
                rendering: null,
                renderingStartTime: 0,
                last: C,
                tail: M,
                tailMode: k,
              })
            : ((z.isBackwards = p),
              (z.rendering = null),
              (z.renderingStartTime = 0),
              (z.last = C),
              (z.tail = M),
              (z.tailMode = k));
        }
        function sl(d, p, M) {
          var C = p.pendingProps,
            k = C.revealOrder,
            z = C.tail;
          if ((Qn(d, p, C.children, M), (C = qn.current), (C & 2) !== 0))
            (C = (C & 1) | 2), (p.flags |= 128);
          else {
            if (d !== null && (d.flags & 128) !== 0)
              e: for (d = p.child; d !== null; ) {
                if (d.tag === 13) d.memoizedState !== null && ig(d, M, p);
                else if (d.tag === 19) ig(d, M, p);
                else if (d.child !== null) {
                  (d.child.return = d), (d = d.child);
                  continue;
                }
                if (d === p) break e;
                for (; d.sibling === null; ) {
                  if (d.return === null || d.return === p) break e;
                  d = d.return;
                }
                (d.sibling.return = d.return), (d = d.sibling);
              }
            C &= 1;
          }
          if ((dt(qn, C), (p.mode & 1) === 0)) p.memoizedState = null;
          else
            switch (k) {
              case "forwards":
                for (M = p.child, k = null; M !== null; )
                  (d = M.alternate),
                    d !== null && Rf(d) === null && (k = M),
                    (M = M.sibling);
                (M = k),
                  M === null
                    ? ((k = p.child), (p.child = null))
                    : ((k = M.sibling), (M.sibling = null)),
                  ps(p, !1, k, M, z);
                break;
              case "backwards":
                for (M = null, k = p.child, p.child = null; k !== null; ) {
                  if (((d = k.alternate), d !== null && Rf(d) === null)) {
                    p.child = k;
                    break;
                  }
                  (d = k.sibling), (k.sibling = M), (M = k), (k = d);
                }
                ps(p, !0, M, null, z);
                break;
              case "together":
                ps(p, !1, null, null, void 0);
                break;
              default:
                p.memoizedState = null;
            }
          return p.child;
        }
        function zi(d, p, M) {
          if (
            (d !== null && (p.dependencies = d.dependencies),
            (ul |= p.lanes),
            (M & p.childLanes) === 0)
          )
            return null;
          if (d !== null && p.child !== d.child) throw Error(s(153));
          if (p.child !== null) {
            for (
              d = p.child, M = qs(d, d.pendingProps), p.child = M, M.return = p;
              d.sibling !== null;

            )
              (d = d.sibling),
                (M = M.sibling = qs(d, d.pendingProps)),
                (M.return = p);
            M.sibling = null;
          }
          return p.child;
        }
        function jf(d, p, M) {
          switch (p.tag) {
            case 3:
              rc(p), jl();
              break;
            case 5:
              Qm(p);
              break;
            case 1:
              Bn(p.type) && or(p);
              break;
            case 4:
              Af(p, p.stateNode.containerInfo);
              break;
            case 10:
              ks(p, p.type._context, p.memoizedProps.value);
              break;
            case 13:
              var C = p.memoizedState;
              if (C !== null)
                return C.dehydrated !== null
                  ? (dt(qn, qn.current & 1), (p.flags |= 128), null)
                  : (M & p.child.childLanes) !== 0
                  ? Gh(d, p, M)
                  : (dt(qn, qn.current & 1),
                    (d = zi(d, p, M)),
                    d !== null ? d.sibling : null);
              dt(qn, qn.current & 1);
              break;
            case 19:
              if (((C = (M & p.childLanes) !== 0), (d.flags & 128) !== 0)) {
                if (C) return sl(d, p, M);
                p.flags |= 128;
              }
              var k = p.memoizedState;
              if (
                (k !== null &&
                  ((k.rendering = null),
                  (k.tail = null),
                  (k.lastEffect = null)),
                dt(qn, qn.current),
                C)
              )
                break;
              return null;
            case 22:
            case 23:
              return (p.lanes = 0), oi(d, p, M);
          }
          return zi(d, p, M);
        }
        function $f(d, p) {
          switch ((Ch(p), p.tag)) {
            case 1:
              return (
                Bn(p.type) && ln(),
                (d = p.flags),
                d & 65536 ? ((p.flags = (d & -65537) | 128), p) : null
              );
            case 3:
              return (
                ql(),
                wt(wn),
                wt(Bt),
                Ja(),
                (d = p.flags),
                (d & 65536) !== 0 && (d & 128) === 0
                  ? ((p.flags = (d & -65537) | 128), p)
                  : null
              );
            case 5:
              return Ph(p), null;
            case 13:
              if (
                (wt(qn),
                (d = p.memoizedState),
                d !== null && d.dehydrated !== null)
              ) {
                if (p.alternate === null) throw Error(s(340));
                jl();
              }
              return (
                (d = p.flags),
                d & 65536 ? ((p.flags = (d & -65537) | 128), p) : null
              );
            case 19:
              return wt(qn), null;
            case 4:
              return ql(), null;
            case 10:
              return vr(p.type._context), null;
            case 22:
            case 23:
              return qh(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Mi = !1,
          Xr = !1,
          al = typeof WeakSet == "function" ? WeakSet : Set,
          pt = null;
        function bo(d, p) {
          var M = d.ref;
          if (M !== null)
            if (typeof M == "function")
              try {
                M(null);
              } catch (C) {
                Ai(d, p, C);
              }
            else M.current = null;
        }
        function Ws(d, p, M) {
          try {
            M();
          } catch (C) {
            Ai(d, p, C);
          }
        }
        var Wh = !1;
        function jh(d, p) {
          for (re(d.containerInfo), pt = p; pt !== null; )
            if (
              ((d = pt),
              (p = d.child),
              (d.subtreeFlags & 1028) !== 0 && p !== null)
            )
              (p.return = d), (pt = p);
            else
              for (; pt !== null; ) {
                d = pt;
                try {
                  var M = d.alternate;
                  if ((d.flags & 1024) !== 0)
                    switch (d.tag) {
                      case 0:
                      case 11:
                      case 15:
                        break;
                      case 1:
                        if (M !== null) {
                          var C = M.memoizedProps,
                            k = M.memoizedState,
                            z = d.stateNode,
                            se = z.getSnapshotBeforeUpdate(
                              d.elementType === d.type ? C : Vr(d.type, C),
                              k
                            );
                          z.__reactInternalSnapshotBeforeUpdate = se;
                        }
                        break;
                      case 3:
                        Ae && it(d.stateNode.containerInfo);
                        break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                        break;
                      default:
                        throw Error(s(163));
                    }
                } catch (we) {
                  Ai(d, d.return, we);
                }
                if (((p = d.sibling), p !== null)) {
                  (p.return = d.return), (pt = p);
                  break;
                }
                pt = d.return;
              }
          return (M = Wh), (Wh = !1), M;
        }
        function js(d, p, M) {
          var C = p.updateQueue;
          if (((C = C !== null ? C.lastEffect : null), C !== null)) {
            var k = (C = C.next);
            do {
              if ((k.tag & d) === d) {
                var z = k.destroy;
                (k.destroy = void 0), z !== void 0 && Ws(p, M, z);
              }
              k = k.next;
            } while (k !== C);
          }
        }
        function si(d, p) {
          if (
            ((p = p.updateQueue),
            (p = p !== null ? p.lastEffect : null),
            p !== null)
          ) {
            var M = (p = p.next);
            do {
              if ((M.tag & d) === d) {
                var C = M.create;
                M.destroy = C();
              }
              M = M.next;
            } while (M !== p);
          }
        }
        function bi(d) {
          var p = d.ref;
          if (p !== null) {
            var M = d.stateNode;
            switch (d.tag) {
              case 5:
                d = Y(M);
                break;
              default:
                d = M;
            }
            typeof p == "function" ? p(d) : (p.current = d);
          }
        }
        function Vn(d, p, M) {
          if (no && typeof no.onCommitFiberUnmount == "function")
            try {
              no.onCommitFiberUnmount(ha, p);
            } catch {}
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                ((d = p.updateQueue),
                d !== null && ((d = d.lastEffect), d !== null))
              ) {
                var C = (d = d.next);
                do {
                  var k = C,
                    z = k.destroy;
                  (k = k.tag),
                    z !== void 0 &&
                      ((k & 2) !== 0 || (k & 4) !== 0) &&
                      Ws(p, M, z),
                    (C = C.next);
                } while (C !== d);
              }
              break;
            case 1:
              if (
                (bo(p, M),
                (d = p.stateNode),
                typeof d.componentWillUnmount == "function")
              )
                try {
                  (d.props = p.memoizedProps),
                    (d.state = p.memoizedState),
                    d.componentWillUnmount();
                } catch (se) {
                  Ai(p, M, se);
                }
              break;
            case 5:
              bo(p, M);
              break;
            case 4:
              Ae
                ? Yh(d, p, M)
                : W &&
                  W &&
                  ((p = p.stateNode.containerInfo), (M = gt(p)), ht(p, M));
          }
        }
        function Eo(d, p, M) {
          for (var C = p; ; )
            if ((Vn(d, C, M), C.child === null || (Ae && C.tag === 4))) {
              if (C === p) break;
              for (; C.sibling === null; ) {
                if (C.return === null || C.return === p) return;
                C = C.return;
              }
              (C.sibling.return = C.return), (C = C.sibling);
            } else (C.child.return = C), (C = C.child);
        }
        function $h(d) {
          var p = d.alternate;
          p !== null && ((d.alternate = null), $h(p)),
            (d.child = null),
            (d.deletions = null),
            (d.sibling = null),
            d.tag === 5 && ((p = d.stateNode), p !== null && rt(p)),
            (d.stateNode = null),
            (d.return = null),
            (d.dependencies = null),
            (d.memoizedProps = null),
            (d.memoizedState = null),
            (d.pendingProps = null),
            (d.stateNode = null),
            (d.updateQueue = null);
        }
        function Xh(d) {
          return d.tag === 5 || d.tag === 3 || d.tag === 4;
        }
        function Xf(d) {
          e: for (;;) {
            for (; d.sibling === null; ) {
              if (d.return === null || Xh(d.return)) return null;
              d = d.return;
            }
            for (
              d.sibling.return = d.return, d = d.sibling;
              d.tag !== 5 && d.tag !== 6 && d.tag !== 18;

            ) {
              if (d.flags & 2 || d.child === null || d.tag === 4) continue e;
              (d.child.return = d), (d = d.child);
            }
            if (!(d.flags & 2)) return d.stateNode;
          }
        }
        function Yf(d) {
          if (Ae) {
            e: {
              for (var p = d.return; p !== null; ) {
                if (Xh(p)) break e;
                p = p.return;
              }
              throw Error(s(160));
            }
            var M = p;
            switch (M.tag) {
              case 5:
                (p = M.stateNode),
                  M.flags & 32 && (Je(p), (M.flags &= -33)),
                  (M = Xf(d)),
                  nu(d, M, p);
                break;
              case 3:
              case 4:
                (p = M.stateNode.containerInfo), (M = Xf(d)), qf(d, M, p);
                break;
              default:
                throw Error(s(161));
            }
          }
        }
        function qf(d, p, M) {
          var C = d.tag;
          if (C === 5 || C === 6) (d = d.stateNode), p ? qe(M, d, p) : We(M, d);
          else if (C !== 4 && ((d = d.child), d !== null))
            for (qf(d, p, M), d = d.sibling; d !== null; )
              qf(d, p, M), (d = d.sibling);
        }
        function nu(d, p, M) {
          var C = d.tag;
          if (C === 5 || C === 6) (d = d.stateNode), p ? $e(M, d, p) : ze(M, d);
          else if (C !== 4 && ((d = d.child), d !== null))
            for (nu(d, p, M), d = d.sibling; d !== null; )
              nu(d, p, M), (d = d.sibling);
        }
        function Yh(d, p, M) {
          for (var C = p, k = !1, z, se; ; ) {
            if (!k) {
              k = C.return;
              e: for (;;) {
                if (k === null) throw Error(s(160));
                switch (((z = k.stateNode), k.tag)) {
                  case 5:
                    se = !1;
                    break e;
                  case 3:
                    (z = z.containerInfo), (se = !0);
                    break e;
                  case 4:
                    (z = z.containerInfo), (se = !0);
                    break e;
                }
                k = k.return;
              }
              k = !0;
            }
            if (C.tag === 5 || C.tag === 6)
              Eo(d, C, M), se ? ce(z, C.stateNode) : et(z, C.stateNode);
            else if (C.tag === 18) se ? Ie(z, C.stateNode) : Ge(z, C.stateNode);
            else if (C.tag === 4) {
              if (C.child !== null) {
                (z = C.stateNode.containerInfo),
                  (se = !0),
                  (C.child.return = C),
                  (C = C.child);
                continue;
              }
            } else if ((Vn(d, C, M), C.child !== null)) {
              (C.child.return = C), (C = C.child);
              continue;
            }
            if (C === p) break;
            for (; C.sibling === null; ) {
              if (C.return === null || C.return === p) return;
              (C = C.return), C.tag === 4 && (k = !1);
            }
            (C.sibling.return = C.return), (C = C.sibling);
          }
        }
        function ba(d, p) {
          if (Ae) {
            switch (p.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                js(3, p, p.return), si(3, p), js(5, p, p.return);
                return;
              case 1:
                return;
              case 5:
                var M = p.stateNode;
                if (M != null) {
                  var C = p.memoizedProps;
                  d = d !== null ? d.memoizedProps : C;
                  var k = p.type,
                    z = p.updateQueue;
                  (p.updateQueue = null), z !== null && yt(M, z, k, d, C, p);
                }
                return;
              case 6:
                if (p.stateNode === null) throw Error(s(162));
                (M = p.memoizedProps),
                  Ye(p.stateNode, d !== null ? d.memoizedProps : M, M);
                return;
              case 3:
                _e &&
                  d !== null &&
                  d.memoizedState.isDehydrated &&
                  be(p.stateNode.containerInfo);
                return;
              case 12:
                return;
              case 13:
                ru(p);
                return;
              case 19:
                ru(p);
                return;
              case 17:
                return;
            }
            throw Error(s(163));
          }
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              js(3, p, p.return), si(3, p), js(5, p, p.return);
              return;
            case 12:
              return;
            case 13:
              ru(p);
              return;
            case 19:
              ru(p);
              return;
            case 3:
              _e &&
                d !== null &&
                d.memoizedState.isDehydrated &&
                be(p.stateNode.containerInfo);
              break;
            case 22:
            case 23:
              return;
          }
          e: if (W) {
            switch (p.tag) {
              case 1:
              case 5:
              case 6:
                break e;
              case 3:
              case 4:
                (p = p.stateNode), ht(p.containerInfo, p.pendingChildren);
                break e;
            }
            throw Error(s(163));
          }
        }
        function ru(d) {
          var p = d.updateQueue;
          if (p !== null) {
            d.updateQueue = null;
            var M = d.stateNode;
            M === null && (M = d.stateNode = new al()),
              p.forEach(function (C) {
                var k = hc.bind(null, d, C);
                M.has(C) || (M.add(C), C.then(k, k));
              });
          }
        }
        function Ky(d, p) {
          for (pt = p; pt !== null; ) {
            p = pt;
            var M = p.deletions;
            if (M !== null)
              for (var C = 0; C < M.length; C++) {
                var k = M[C];
                try {
                  var z = d;
                  Ae ? Yh(z, k, p) : Eo(z, k, p);
                  var se = k.alternate;
                  se !== null && (se.return = null), (k.return = null);
                } catch (Pt) {
                  Ai(k, p, Pt);
                }
              }
            if (((M = p.child), (p.subtreeFlags & 12854) !== 0 && M !== null))
              (M.return = p), (pt = M);
            else
              for (; pt !== null; ) {
                p = pt;
                try {
                  var we = p.flags;
                  if ((we & 32 && Ae && Je(p.stateNode), we & 512)) {
                    var Qe = p.alternate;
                    if (Qe !== null) {
                      var ct = Qe.ref;
                      ct !== null &&
                        (typeof ct == "function"
                          ? ct(null)
                          : (ct.current = null));
                    }
                  }
                  if (we & 8192)
                    switch (p.tag) {
                      case 13:
                        if (p.memoizedState !== null) {
                          var Tt = p.alternate;
                          (Tt === null || Tt.memoizedState === null) &&
                            (Jf = Gn());
                        }
                        break;
                      case 22:
                        var qt = p.memoizedState !== null,
                          zt = p.alternate,
                          kn = zt !== null && zt.memoizedState !== null;
                        if (((M = p), Ae)) {
                          e: if (((C = M), (k = qt), (z = null), Ae))
                            for (var Mt = C; ; ) {
                              if (Mt.tag === 5) {
                                if (z === null) {
                                  z = Mt;
                                  var Mn = Mt.stateNode;
                                  k
                                    ? de(Mn)
                                    : Ce(Mt.stateNode, Mt.memoizedProps);
                                }
                              } else if (Mt.tag === 6) {
                                if (z === null) {
                                  var uo = Mt.stateNode;
                                  k ? He(uo) : Ue(uo, Mt.memoizedProps);
                                }
                              } else if (
                                ((Mt.tag !== 22 && Mt.tag !== 23) ||
                                  Mt.memoizedState === null ||
                                  Mt === C) &&
                                Mt.child !== null
                              ) {
                                (Mt.child.return = Mt), (Mt = Mt.child);
                                continue;
                              }
                              if (Mt === C) break;
                              for (; Mt.sibling === null; ) {
                                if (Mt.return === null || Mt.return === C)
                                  break e;
                                z === Mt && (z = null), (Mt = Mt.return);
                              }
                              z === Mt && (z = null),
                                (Mt.sibling.return = Mt.return),
                                (Mt = Mt.sibling);
                            }
                        }
                        if (qt && !kn && (M.mode & 1) !== 0) {
                          pt = M;
                          for (var Ve = M.child; Ve !== null; ) {
                            for (M = pt = Ve; pt !== null; ) {
                              C = pt;
                              var Re = C.child;
                              switch (C.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                  js(4, C, C.return);
                                  break;
                                case 1:
                                  bo(C, C.return);
                                  var Ze = C.stateNode;
                                  if (
                                    typeof Ze.componentWillUnmount == "function"
                                  ) {
                                    var _t = C.return;
                                    try {
                                      (Ze.props = C.memoizedProps),
                                        (Ze.state = C.memoizedState),
                                        Ze.componentWillUnmount();
                                    } catch (Pt) {
                                      Ai(C, _t, Pt);
                                    }
                                  }
                                  break;
                                case 5:
                                  bo(C, C.return);
                                  break;
                                case 22:
                                  if (C.memoizedState !== null) {
                                    ll(M);
                                    continue;
                                  }
                              }
                              Re !== null
                                ? ((Re.return = C), (pt = Re))
                                : ll(M);
                            }
                            Ve = Ve.sibling;
                          }
                        }
                    }
                  switch (we & 4102) {
                    case 2:
                      Yf(p), (p.flags &= -3);
                      break;
                    case 6:
                      Yf(p), (p.flags &= -3), ba(p.alternate, p);
                      break;
                    case 4096:
                      p.flags &= -4097;
                      break;
                    case 4100:
                      (p.flags &= -4097), ba(p.alternate, p);
                      break;
                    case 4:
                      ba(p.alternate, p);
                  }
                } catch (Pt) {
                  Ai(p, p.return, Pt);
                }
                if (((M = p.sibling), M !== null)) {
                  (M.return = p.return), (pt = M);
                  break;
                }
                pt = p.return;
              }
          }
        }
        function $o(d, p, M) {
          (pt = d), ac(d);
        }
        function ac(d, p, M) {
          for (var C = (d.mode & 1) !== 0; pt !== null; ) {
            var k = pt,
              z = k.child;
            if (k.tag === 22 && C) {
              var se = k.memoizedState !== null || Mi;
              if (!se) {
                var we = k.alternate,
                  Qe = (we !== null && we.memoizedState !== null) || Xr;
                we = Mi;
                var ct = Xr;
                if (((Mi = se), (Xr = Qe) && !ct))
                  for (pt = k; pt !== null; )
                    (se = pt),
                      (Qe = se.child),
                      se.tag === 22 && se.memoizedState !== null
                        ? Kf(k)
                        : Qe !== null
                        ? ((Qe.return = se), (pt = Qe))
                        : Kf(k);
                for (; z !== null; ) (pt = z), ac(z), (z = z.sibling);
                (pt = k), (Mi = we), (Xr = ct);
              }
              lc(d);
            } else
              (k.subtreeFlags & 8772) !== 0 && z !== null
                ? ((z.return = k), (pt = z))
                : lc(d);
          }
        }
        function lc(d) {
          for (; pt !== null; ) {
            var p = pt;
            if ((p.flags & 8772) !== 0) {
              var M = p.alternate;
              try {
                if ((p.flags & 8772) !== 0)
                  switch (p.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Xr || si(5, p);
                      break;
                    case 1:
                      var C = p.stateNode;
                      if (p.flags & 4 && !Xr)
                        if (M === null) C.componentDidMount();
                        else {
                          var k =
                            p.elementType === p.type
                              ? M.memoizedProps
                              : Vr(p.type, M.memoizedProps);
                          C.componentDidUpdate(
                            k,
                            M.memoizedState,
                            C.__reactInternalSnapshotBeforeUpdate
                          );
                        }
                      var z = p.updateQueue;
                      z !== null && jm(p, z, C);
                      break;
                    case 3:
                      var se = p.updateQueue;
                      if (se !== null) {
                        if (((M = null), p.child !== null))
                          switch (p.child.tag) {
                            case 5:
                              M = Y(p.child.stateNode);
                              break;
                            case 1:
                              M = p.child.stateNode;
                          }
                        jm(p, se, M);
                      }
                      break;
                    case 5:
                      var we = p.stateNode;
                      M === null &&
                        p.flags & 4 &&
                        nt(we, p.type, p.memoizedProps, p);
                      break;
                    case 6:
                      break;
                    case 4:
                      break;
                    case 12:
                      break;
                    case 13:
                      if (_e && p.memoizedState === null) {
                        var Qe = p.alternate;
                        if (Qe !== null) {
                          var ct = Qe.memoizedState;
                          if (ct !== null) {
                            var Tt = ct.dehydrated;
                            Tt !== null && Be(Tt);
                          }
                        }
                      }
                      break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                      break;
                    default:
                      throw Error(s(163));
                  }
                Xr || (p.flags & 512 && bi(p));
              } catch (qt) {
                Ai(p, p.return, qt);
              }
            }
            if (p === d) {
              pt = null;
              break;
            }
            if (((M = p.sibling), M !== null)) {
              (M.return = p.return), (pt = M);
              break;
            }
            pt = p.return;
          }
        }
        function ll(d) {
          for (; pt !== null; ) {
            var p = pt;
            if (p === d) {
              pt = null;
              break;
            }
            var M = p.sibling;
            if (M !== null) {
              (M.return = p.return), (pt = M);
              break;
            }
            pt = p.return;
          }
        }
        function Kf(d) {
          for (; pt !== null; ) {
            var p = pt;
            try {
              switch (p.tag) {
                case 0:
                case 11:
                case 15:
                  var M = p.return;
                  try {
                    si(4, p);
                  } catch (Qe) {
                    Ai(p, M, Qe);
                  }
                  break;
                case 1:
                  var C = p.stateNode;
                  if (typeof C.componentDidMount == "function") {
                    var k = p.return;
                    try {
                      C.componentDidMount();
                    } catch (Qe) {
                      Ai(p, k, Qe);
                    }
                  }
                  var z = p.return;
                  try {
                    bi(p);
                  } catch (Qe) {
                    Ai(p, z, Qe);
                  }
                  break;
                case 5:
                  var se = p.return;
                  try {
                    bi(p);
                  } catch (Qe) {
                    Ai(p, se, Qe);
                  }
              }
            } catch (Qe) {
              Ai(p, p.return, Qe);
            }
            if (p === d) {
              pt = null;
              break;
            }
            var we = p.sibling;
            if (we !== null) {
              (we.return = p.return), (pt = we);
              break;
            }
            pt = p.return;
          }
        }
        var iu = 0,
          ou = 1,
          su = 2,
          $s = 3,
          Ei = 4;
        if (typeof Symbol == "function" && Symbol.for) {
          var Xo = Symbol.for;
          (iu = Xo("selector.component")),
            (ou = Xo("selector.has_pseudo_class")),
            (su = Xo("selector.role")),
            ($s = Xo("selector.test_id")),
            (Ei = Xo("selector.text"));
        }
        function uc(d) {
          var p = Te(d);
          if (p != null) {
            if (typeof p.memoizedProps["data-testname"] != "string")
              throw Error(s(364));
            return p;
          }
          if (((d = F(d)), d === null)) throw Error(s(362));
          return d.stateNode.current;
        }
        function Zf(d, p) {
          switch (p.$$typeof) {
            case iu:
              if (d.type === p.value) return !0;
              break;
            case ou:
              e: {
                (p = p.value), (d = [d, 0]);
                for (var M = 0; M < d.length; ) {
                  var C = d[M++],
                    k = d[M++],
                    z = p[k];
                  if (C.tag !== 5 || !ye(C)) {
                    for (; z != null && Zf(C, z); ) k++, (z = p[k]);
                    if (k === p.length) {
                      p = !0;
                      break e;
                    } else
                      for (C = C.child; C !== null; )
                        d.push(C, k), (C = C.sibling);
                  }
                }
                p = !1;
              }
              return p;
            case su:
              if (d.tag === 5 && Me(d.stateNode, p.value)) return !0;
              break;
            case Ei:
              if (
                (d.tag === 5 || d.tag === 6) &&
                ((d = xe(d)), d !== null && 0 <= d.indexOf(p.value))
              )
                return !0;
              break;
            case $s:
              if (
                d.tag === 5 &&
                ((d = d.memoizedProps["data-testname"]),
                typeof d == "string" &&
                  d.toLowerCase() === p.value.toLowerCase())
              )
                return !0;
              break;
            default:
              throw Error(s(365));
          }
          return !1;
        }
        function Yo(d) {
          switch (d.$$typeof) {
            case iu:
              return "<" + (I(d.value) || "Unknown") + ">";
            case ou:
              return ":has(" + (Yo(d) || "") + ")";
            case su:
              return '[role="' + d.value + '"]';
            case Ei:
              return '"' + d.value + '"';
            case $s:
              return '[data-testname="' + d.value + '"]';
            default:
              throw Error(s(365));
          }
        }
        function Xs(d, p) {
          var M = [];
          d = [d, 0];
          for (var C = 0; C < d.length; ) {
            var k = d[C++],
              z = d[C++],
              se = p[z];
            if (k.tag !== 5 || !ye(k)) {
              for (; se != null && Zf(k, se); ) z++, (se = p[z]);
              if (z === p.length) M.push(k);
              else
                for (k = k.child; k !== null; ) d.push(k, z), (k = k.sibling);
            }
          }
          return M;
        }
        function cc(d, p) {
          if (!Z) throw Error(s(363));
          (d = uc(d)), (d = Xs(d, p)), (p = []), (d = Array.from(d));
          for (var M = 0; M < d.length; ) {
            var C = d[M++];
            if (C.tag === 5) ye(C) || p.push(C.stateNode);
            else for (C = C.child; C !== null; ) d.push(C), (C = C.sibling);
          }
          return p;
        }
        var og = Math.ceil,
          To = l.ReactCurrentDispatcher,
          ms = l.ReactCurrentOwner,
          jn = l.ReactCurrentBatchConfig,
          nn = 0,
          Zn = null,
          lr = null,
          Yr = 0,
          Ti = 0,
          Ys = Sn(0),
          yr = 0,
          au = null,
          ul = 0,
          lu = 0,
          cl = 0,
          Ea = null,
          Ci = null,
          Jf = 0,
          Ta = 1 / 0;
        function fl() {
          Ta = Gn() + 500;
        }
        var Ca = !1,
          Co = null,
          Ao = null,
          Aa = !1,
          Bi = null,
          uu = 0,
          gs = 0,
          Qf = null,
          cu = -1,
          Un = 0;
        function qr() {
          return (nn & 6) !== 0 ? Gn() : cu !== -1 ? cu : (cu = Gn());
        }
        function vs(d) {
          return (d.mode & 1) === 0
            ? 1
            : (nn & 2) !== 0 && Yr !== 0
            ? Yr & -Yr
            : ga.transition !== null
            ? (Un === 0 &&
                ((d = zo),
                (zo <<= 1),
                (zo & 4194240) === 0 && (zo = 64),
                (Un = d)),
              Un)
            : ((d = $t), d !== 0 ? d : Pe());
        }
        function Vi(d, p, M) {
          if (50 < gs) throw ((gs = 0), (Qf = null), Error(s(185)));
          var C = dl(d, p);
          return C === null
            ? null
            : (vo(C, p, M),
              ((nn & 2) === 0 || C !== Zn) &&
                (C === Zn &&
                  ((nn & 2) === 0 && (lu |= p), yr === 4 && qo(C, Yr)),
                pi(C, M),
                p === 1 &&
                  nn === 0 &&
                  (d.mode & 1) === 0 &&
                  (fl(), fs && di())),
              C);
        }
        function dl(d, p) {
          d.lanes |= p;
          var M = d.alternate;
          for (M !== null && (M.lanes |= p), M = d, d = d.return; d !== null; )
            (d.childLanes |= p),
              (M = d.alternate),
              M !== null && (M.childLanes |= p),
              (M = d),
              (d = d.return);
          return M.tag === 3 ? M.stateNode : null;
        }
        function pi(d, p) {
          var M = d.callbackNode;
          Vl(d, p);
          var C = fa(d, d === Zn ? Yr : 0);
          if (C === 0)
            M !== null && cs(M),
              (d.callbackNode = null),
              (d.callbackPriority = 0);
          else if (((p = C & -C), d.callbackPriority !== p)) {
            if ((M != null && cs(M), p === 1))
              d.tag === 0 ? ma(fu.bind(null, d)) : Xa(fu.bind(null, d)),
                Le
                  ? Xe(function () {
                      nn === 0 && di();
                    })
                  : to(Vo, di),
                (M = null);
            else {
              switch (yo(C)) {
                case 1:
                  M = Vo;
                  break;
                case 4:
                  M = xf;
                  break;
                case 16:
                  M = fi;
                  break;
                case 536870912:
                  M = da;
                  break;
                default:
                  M = fi;
              }
              M = pc(M, Ra.bind(null, d));
            }
            (d.callbackPriority = p), (d.callbackNode = M);
          }
        }
        function Ra(d, p) {
          if (((cu = -1), (Un = 0), (nn & 6) !== 0)) throw Error(s(327));
          var M = d.callbackNode;
          if (Ia() && d.callbackNode !== M) return null;
          var C = fa(d, d === Zn ? Yr : 0);
          if (C === 0) return null;
          if ((C & 30) !== 0 || (C & d.expiredLanes) !== 0 || p) p = ao(d, C);
          else {
            p = C;
            var k = nn;
            nn |= 2;
            var z = td();
            (Zn !== d || Yr !== p) && (fl(), er(d, p));
            do
              try {
                dc();
                break;
              } catch (we) {
                ed(d, we);
              }
            while (!0);
            Hr(),
              (To.current = z),
              (nn = k),
              lr !== null ? (p = 0) : ((Zn = null), (Yr = 0), (p = yr));
          }
          if (p !== 0) {
            if (
              (p === 2 && ((k = us(d)), k !== 0 && ((C = k), (p = Hn(d, k)))),
              p === 1)
            )
              throw ((M = au), er(d, 0), qo(d, C), pi(d, Gn()), M);
            if (p === 6) qo(d, C);
            else {
              if (
                ((k = d.current.alternate),
                (C & 30) === 0 &&
                  !Kr(k) &&
                  ((p = ao(d, C)),
                  p === 2 &&
                    ((z = us(d)), z !== 0 && ((C = z), (p = Hn(d, z)))),
                  p === 1))
              )
                throw ((M = au), er(d, 0), qo(d, C), pi(d, Gn()), M);
              switch (((d.finishedWork = k), (d.finishedLanes = C), p)) {
                case 0:
                case 1:
                  throw Error(s(345));
                case 2:
                  Pa(d, Ci);
                  break;
                case 3:
                  if (
                    (qo(d, C),
                    (C & 130023424) === C && ((p = Jf + 500 - Gn()), 10 < p))
                  ) {
                    if (fa(d, 0) !== 0) break;
                    if (((k = d.suspendedLanes), (k & C) !== C)) {
                      qr(), (d.pingedLanes |= d.suspendedLanes & k);
                      break;
                    }
                    d.timeoutHandle = ae(Pa.bind(null, d, Ci), p);
                    break;
                  }
                  Pa(d, Ci);
                  break;
                case 4:
                  if ((qo(d, C), (C & 4194240) === C)) break;
                  for (p = d.eventTimes, k = -1; 0 < C; ) {
                    var se = 31 - ci(C);
                    (z = 1 << se), (se = p[se]), se > k && (k = se), (C &= ~z);
                  }
                  if (
                    ((C = k),
                    (C = Gn() - C),
                    (C =
                      (120 > C
                        ? 120
                        : 480 > C
                        ? 480
                        : 1080 > C
                        ? 1080
                        : 1920 > C
                        ? 1920
                        : 3e3 > C
                        ? 3e3
                        : 4320 > C
                        ? 4320
                        : 1960 * og(C / 1960)) - C),
                    10 < C)
                  ) {
                    d.timeoutHandle = ae(Pa.bind(null, d, Ci), C);
                    break;
                  }
                  Pa(d, Ci);
                  break;
                case 5:
                  Pa(d, Ci);
                  break;
                default:
                  throw Error(s(329));
              }
            }
          }
          return pi(d, Gn()), d.callbackNode === M ? Ra.bind(null, d) : null;
        }
        function Hn(d, p) {
          var M = Ea;
          return (
            d.current.memoizedState.isDehydrated && (er(d, p).flags |= 256),
            (d = ao(d, p)),
            d !== 2 && ((p = Ci), (Ci = M), p !== null && ur(p)),
            d
          );
        }
        function ur(d) {
          Ci === null ? (Ci = d) : Ci.push.apply(Ci, d);
        }
        function Kr(d) {
          for (var p = d; ; ) {
            if (p.flags & 16384) {
              var M = p.updateQueue;
              if (M !== null && ((M = M.stores), M !== null))
                for (var C = 0; C < M.length; C++) {
                  var k = M[C],
                    z = k.getSnapshot;
                  k = k.value;
                  try {
                    if (!zr(z(), k)) return !1;
                  } catch {
                    return !1;
                  }
                }
            }
            if (((M = p.child), p.subtreeFlags & 16384 && M !== null))
              (M.return = p), (p = M);
            else {
              if (p === d) break;
              for (; p.sibling === null; ) {
                if (p.return === null || p.return === d) return !0;
                p = p.return;
              }
              (p.sibling.return = p.return), (p = p.sibling);
            }
          }
          return !0;
        }
        function qo(d, p) {
          for (
            p &= ~cl,
              p &= ~lu,
              d.suspendedLanes |= p,
              d.pingedLanes &= ~p,
              d = d.expirationTimes;
            0 < p;

          ) {
            var M = 31 - ci(p),
              C = 1 << M;
            (d[M] = -1), (p &= ~C);
          }
        }
        function fu(d) {
          if ((nn & 6) !== 0) throw Error(s(327));
          Ia();
          var p = fa(d, 0);
          if ((p & 1) === 0) return pi(d, Gn()), null;
          var M = ao(d, p);
          if (d.tag !== 0 && M === 2) {
            var C = us(d);
            C !== 0 && ((p = C), (M = Hn(d, C)));
          }
          if (M === 1) throw ((M = au), er(d, 0), qo(d, p), pi(d, Gn()), M);
          if (M === 6) throw Error(s(345));
          return (
            (d.finishedWork = d.current.alternate),
            (d.finishedLanes = p),
            Pa(d, Ci),
            pi(d, Gn()),
            null
          );
        }
        function du(d) {
          Bi !== null && Bi.tag === 0 && (nn & 6) === 0 && Ia();
          var p = nn;
          nn |= 1;
          var M = jn.transition,
            C = $t;
          try {
            if (((jn.transition = null), ($t = 1), d)) return d();
          } finally {
            ($t = C), (jn.transition = M), (nn = p), (nn & 6) === 0 && di();
          }
        }
        function qh() {
          (Ti = Ys.current), wt(Ys);
        }
        function er(d, p) {
          (d.finishedWork = null), (d.finishedLanes = 0);
          var M = d.timeoutHandle;
          if ((M !== Ee && ((d.timeoutHandle = Ee), ue(M)), lr !== null))
            for (M = lr.return; M !== null; ) {
              var C = M;
              switch ((Ch(C), C.tag)) {
                case 1:
                  (C = C.type.childContextTypes), C != null && ln();
                  break;
                case 3:
                  ql(), wt(wn), wt(Bt), Ja();
                  break;
                case 5:
                  Ph(C);
                  break;
                case 4:
                  ql();
                  break;
                case 13:
                  wt(qn);
                  break;
                case 19:
                  wt(qn);
                  break;
                case 10:
                  vr(C.type._context);
                  break;
                case 22:
                case 23:
                  qh();
              }
              M = M.return;
            }
          if (
            ((Zn = d),
            (lr = d = qs(d.current, null)),
            (Yr = Ti = p),
            (yr = 0),
            (au = null),
            (cl = lu = ul = 0),
            (Ci = Ea = null),
            _i !== null)
          ) {
            for (p = 0; p < _i.length; p++)
              if (((M = _i[p]), (C = M.interleaved), C !== null)) {
                M.interleaved = null;
                var k = C.next,
                  z = M.pending;
                if (z !== null) {
                  var se = z.next;
                  (z.next = k), (C.next = se);
                }
                M.pending = C;
              }
            _i = null;
          }
          return d;
        }
        function ed(d, p) {
          do {
            var M = lr;
            try {
              if ((Hr(), (Yu.current = eu), Pf)) {
                for (var C = Kn.memoizedState; C !== null; ) {
                  var k = C.queue;
                  k !== null && (k.pending = null), (C = C.next);
                }
                Pf = !1;
              }
              if (
                ((Qa = 0),
                (Wr = Gr = Kn = null),
                (ds = !1),
                (el = 0),
                (ms.current = null),
                M === null || M.return === null)
              ) {
                (yr = 1), (au = p), (lr = null);
                break;
              }
              e: {
                var z = d,
                  se = M.return,
                  we = M,
                  Qe = p;
                if (
                  ((p = Yr),
                  (we.flags |= 32768),
                  Qe !== null &&
                    typeof Qe == "object" &&
                    typeof Qe.then == "function")
                ) {
                  var ct = Qe,
                    Tt = we,
                    qt = Tt.tag;
                  if (
                    (Tt.mode & 1) === 0 &&
                    (qt === 0 || qt === 11 || qt === 15)
                  ) {
                    var zt = Tt.alternate;
                    zt
                      ? ((Tt.updateQueue = zt.updateQueue),
                        (Tt.memoizedState = zt.memoizedState),
                        (Tt.lanes = zt.lanes))
                      : ((Tt.updateQueue = null), (Tt.memoizedState = null));
                  }
                  var kn = Bh(se);
                  if (kn !== null) {
                    (kn.flags &= -257),
                      nl(kn, se, we, z, p),
                      kn.mode & 1 && Bs(z, ct, p),
                      (p = kn),
                      (Qe = ct);
                    var Mt = p.updateQueue;
                    if (Mt === null) {
                      var Mn = new Set();
                      Mn.add(Qe), (p.updateQueue = Mn);
                    } else Mt.add(Qe);
                    break e;
                  } else {
                    if ((p & 1) === 0) {
                      Bs(z, ct, p), fc();
                      break e;
                    }
                    Qe = Error(s(426));
                  }
                } else if (Wn && we.mode & 1) {
                  var uo = Bh(se);
                  if (uo !== null) {
                    (uo.flags & 65536) === 0 && (uo.flags |= 256),
                      nl(uo, se, we, z, p),
                      Cf(Qe);
                    break e;
                  }
                }
                (z = Qe),
                  yr !== 4 && (yr = 2),
                  Ea === null ? (Ea = [z]) : Ea.push(z),
                  (Qe = zh(Qe, we)),
                  (we = se);
                do {
                  switch (we.tag) {
                    case 3:
                      (we.flags |= 65536), (p &= -p), (we.lanes |= p);
                      var Ve = rg(we, Qe, p);
                      Sf(we, Ve);
                      break e;
                    case 1:
                      z = Qe;
                      var Re = we.type,
                        Ze = we.stateNode;
                      if (
                        (we.flags & 128) === 0 &&
                        (typeof Re.getDerivedStateFromError == "function" ||
                          (Ze !== null &&
                            typeof Ze.componentDidCatch == "function" &&
                            (Ao === null || !Ao.has(Ze))))
                      ) {
                        (we.flags |= 65536), (p &= -p), (we.lanes |= p);
                        var _t = Bf(we, z, p);
                        Sf(we, _t);
                        break e;
                      }
                  }
                  we = we.return;
                } while (we !== null);
              }
              rd(M);
            } catch (Pt) {
              (p = Pt), lr === M && M !== null && (lr = M = M.return);
              continue;
            }
            break;
          } while (!0);
        }
        function td() {
          var d = To.current;
          return (To.current = eu), d === null ? eu : d;
        }
        function fc() {
          (yr === 0 || yr === 3 || yr === 2) && (yr = 4),
            Zn === null ||
              ((ul & 268435455) === 0 && (lu & 268435455) === 0) ||
              qo(Zn, Yr);
        }
        function ao(d, p) {
          var M = nn;
          nn |= 2;
          var C = td();
          (Zn === d && Yr === p) || er(d, p);
          do
            try {
              Ro();
              break;
            } catch (k) {
              ed(d, k);
            }
          while (!0);
          if ((Hr(), (nn = M), (To.current = C), lr !== null))
            throw Error(s(261));
          return (Zn = null), (Yr = 0), yr;
        }
        function Ro() {
          for (; lr !== null; ) nd(lr);
        }
        function dc() {
          for (; lr !== null && !xo(); ) nd(lr);
        }
        function nd(d) {
          var p = Jh(d.alternate, d, Ti);
          (d.memoizedProps = d.pendingProps),
            p === null ? rd(d) : (lr = p),
            (ms.current = null);
        }
        function rd(d) {
          var p = d;
          do {
            var M = p.alternate;
            if (((d = p.return), (p.flags & 32768) === 0)) {
              if (((M = Gf(M, p, Ti)), M !== null)) {
                lr = M;
                return;
              }
            } else {
              if (((M = $f(M, p)), M !== null)) {
                (M.flags &= 32767), (lr = M);
                return;
              }
              if (d !== null)
                (d.flags |= 32768), (d.subtreeFlags = 0), (d.deletions = null);
              else {
                (yr = 6), (lr = null);
                return;
              }
            }
            if (((p = p.sibling), p !== null)) {
              lr = p;
              return;
            }
            lr = p = d;
          } while (p !== null);
          yr === 0 && (yr = 5);
        }
        function Pa(d, p) {
          var M = $t,
            C = jn.transition;
          try {
            (jn.transition = null), ($t = 1), sg(d, p, M);
          } finally {
            (jn.transition = C), ($t = M);
          }
          return null;
        }
        function sg(d, p, M) {
          do Ia();
          while (Bi !== null);
          if ((nn & 6) !== 0) throw Error(s(327));
          var C = d.finishedWork,
            k = d.finishedLanes;
          if (C === null) return null;
          if (((d.finishedWork = null), (d.finishedLanes = 0), C === d.current))
            throw Error(s(177));
          (d.callbackNode = null), (d.callbackPriority = 0);
          var z = C.lanes | C.childLanes;
          if (
            (Bo(d, z),
            d === Zn && ((lr = Zn = null), (Yr = 0)),
            ((C.subtreeFlags & 2064) === 0 && (C.flags & 2064) === 0) ||
              Aa ||
              ((Aa = !0),
              pc(fi, function () {
                return Ia(), null;
              })),
            (z = (C.flags & 15990) !== 0),
            (C.subtreeFlags & 15990) !== 0 || z)
          ) {
            (z = jn.transition), (jn.transition = null);
            var se = $t;
            $t = 1;
            var we = nn;
            (nn |= 4),
              (ms.current = null),
              jh(d, C),
              Ky(d, C),
              B(d.containerInfo),
              (d.current = C),
              $o(C),
              yf(),
              (nn = we),
              ($t = se),
              (jn.transition = z);
          } else d.current = C;
          if (
            (Aa && ((Aa = !1), (Bi = d), (uu = k)),
            (z = d.pendingLanes),
            z === 0 && (Ao = null),
            Ps(C.stateNode),
            pi(d, Gn()),
            p !== null)
          )
            for (M = d.onRecoverableError, C = 0; C < p.length; C++) M(p[C]);
          if (Ca) throw ((Ca = !1), (d = Co), (Co = null), d);
          return (
            (uu & 1) !== 0 && d.tag !== 0 && Ia(),
            (z = d.pendingLanes),
            (z & 1) !== 0 ? (d === Qf ? gs++ : ((gs = 0), (Qf = d))) : (gs = 0),
            di(),
            null
          );
        }
        function Ia() {
          if (Bi !== null) {
            var d = yo(uu),
              p = jn.transition,
              M = $t;
            try {
              if (((jn.transition = null), ($t = 16 > d ? 16 : d), Bi === null))
                var C = !1;
              else {
                if (((d = Bi), (Bi = null), (uu = 0), (nn & 6) !== 0))
                  throw Error(s(331));
                var k = nn;
                for (nn |= 4, pt = d.current; pt !== null; ) {
                  var z = pt,
                    se = z.child;
                  if ((pt.flags & 16) !== 0) {
                    var we = z.deletions;
                    if (we !== null) {
                      for (var Qe = 0; Qe < we.length; Qe++) {
                        var ct = we[Qe];
                        for (pt = ct; pt !== null; ) {
                          var Tt = pt;
                          switch (Tt.tag) {
                            case 0:
                            case 11:
                            case 15:
                              js(8, Tt, z);
                          }
                          var qt = Tt.child;
                          if (qt !== null) (qt.return = Tt), (pt = qt);
                          else
                            for (; pt !== null; ) {
                              Tt = pt;
                              var zt = Tt.sibling,
                                kn = Tt.return;
                              if (($h(Tt), Tt === ct)) {
                                pt = null;
                                break;
                              }
                              if (zt !== null) {
                                (zt.return = kn), (pt = zt);
                                break;
                              }
                              pt = kn;
                            }
                        }
                      }
                      var Mt = z.alternate;
                      if (Mt !== null) {
                        var Mn = Mt.child;
                        if (Mn !== null) {
                          Mt.child = null;
                          do {
                            var uo = Mn.sibling;
                            (Mn.sibling = null), (Mn = uo);
                          } while (Mn !== null);
                        }
                      }
                      pt = z;
                    }
                  }
                  if ((z.subtreeFlags & 2064) !== 0 && se !== null)
                    (se.return = z), (pt = se);
                  else
                    e: for (; pt !== null; ) {
                      if (((z = pt), (z.flags & 2048) !== 0))
                        switch (z.tag) {
                          case 0:
                          case 11:
                          case 15:
                            js(9, z, z.return);
                        }
                      var Ve = z.sibling;
                      if (Ve !== null) {
                        (Ve.return = z.return), (pt = Ve);
                        break e;
                      }
                      pt = z.return;
                    }
                }
                var Re = d.current;
                for (pt = Re; pt !== null; ) {
                  se = pt;
                  var Ze = se.child;
                  if ((se.subtreeFlags & 2064) !== 0 && Ze !== null)
                    (Ze.return = se), (pt = Ze);
                  else
                    e: for (se = Re; pt !== null; ) {
                      if (((we = pt), (we.flags & 2048) !== 0))
                        try {
                          switch (we.tag) {
                            case 0:
                            case 11:
                            case 15:
                              si(9, we);
                          }
                        } catch (Pt) {
                          Ai(we, we.return, Pt);
                        }
                      if (we === se) {
                        pt = null;
                        break e;
                      }
                      var _t = we.sibling;
                      if (_t !== null) {
                        (_t.return = we.return), (pt = _t);
                        break e;
                      }
                      pt = we.return;
                    }
                }
                if (
                  ((nn = k),
                  di(),
                  no && typeof no.onPostCommitFiberRoot == "function")
                )
                  try {
                    no.onPostCommitFiberRoot(ha, d);
                  } catch {}
                C = !0;
              }
              return C;
            } finally {
              ($t = M), (jn.transition = p);
            }
          }
          return !1;
        }
        function Kh(d, p, M) {
          (p = zh(M, p)),
            (p = rg(d, p, 1)),
            va(d, p),
            (p = qr()),
            (d = dl(d, 1)),
            d !== null && (vo(d, 1, p), pi(d, p));
        }
        function Ai(d, p, M) {
          if (d.tag === 3) Kh(d, d, M);
          else
            for (; p !== null; ) {
              if (p.tag === 3) {
                Kh(p, d, M);
                break;
              } else if (p.tag === 1) {
                var C = p.stateNode;
                if (
                  typeof p.type.getDerivedStateFromError == "function" ||
                  (typeof C.componentDidCatch == "function" &&
                    (Ao === null || !Ao.has(C)))
                ) {
                  (d = zh(M, d)),
                    (d = Bf(p, d, 1)),
                    va(p, d),
                    (d = qr()),
                    (p = dl(p, 1)),
                    p !== null && (vo(p, 1, d), pi(p, d));
                  break;
                }
              }
              p = p.return;
            }
        }
        function ag(d, p, M) {
          var C = d.pingCache;
          C !== null && C.delete(p),
            (p = qr()),
            (d.pingedLanes |= d.suspendedLanes & M),
            Zn === d &&
              (Yr & M) === M &&
              (yr === 4 ||
              (yr === 3 && (Yr & 130023424) === Yr && 500 > Gn() - Jf)
                ? er(d, 0)
                : (cl |= M)),
            pi(d, p);
        }
        function Zh(d, p) {
          p === 0 &&
            ((d.mode & 1) === 0
              ? (p = 1)
              : ((p = sn),
                (sn <<= 1),
                (sn & 130023424) === 0 && (sn = 4194304)));
          var M = qr();
          (d = dl(d, p)), d !== null && (vo(d, p, M), pi(d, M));
        }
        function lg(d) {
          var p = d.memoizedState,
            M = 0;
          p !== null && (M = p.retryLane), Zh(d, M);
        }
        function hc(d, p) {
          var M = 0;
          switch (d.tag) {
            case 13:
              var C = d.stateNode,
                k = d.memoizedState;
              k !== null && (M = k.retryLane);
              break;
            case 19:
              C = d.stateNode;
              break;
            default:
              throw Error(s(314));
          }
          C !== null && C.delete(p), Zh(d, M);
        }
        var Jh;
        Jh = function (d, p, M) {
          if (d !== null)
            if (d.memoizedProps !== p.pendingProps || wn.current) $r = !0;
            else {
              if ((d.lanes & M) === 0 && (p.flags & 128) === 0)
                return ($r = !1), jf(d, p, M);
              $r = (d.flags & 131072) !== 0;
            }
          else ($r = !1), Wn && (p.flags & 1048576) !== 0 && qm(p, Ef, p.index);
          switch (((p.lanes = 0), p.tag)) {
            case 2:
              var C = p.type;
              d !== null &&
                ((d.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (d = p.pendingProps);
              var k = Cn(p, Bt.current);
              sr(p, M), (k = Kl(null, p, C, d, k, M));
              var z = Sa();
              return (
                (p.flags |= 1),
                typeof k == "object" &&
                k !== null &&
                typeof k.render == "function" &&
                k.$$typeof === void 0
                  ? ((p.tag = 1),
                    (p.memoizedState = null),
                    (p.updateQueue = null),
                    Bn(C) ? ((z = !0), or(p)) : (z = !1),
                    (p.memoizedState =
                      k.state !== null && k.state !== void 0 ? k.state : null),
                    Hl(p),
                    (k.updater = Mf),
                    (p.stateNode = k),
                    (k._reactInternals = p),
                    Eh(p, C, d, M),
                    (p = hi(null, p, C, !0, z, M)))
                  : ((p.tag = 0),
                    Wn && z && Th(p),
                    Qn(null, p, k, M),
                    (p = p.child)),
                p
              );
            case 16:
              C = p.elementType;
              e: {
                switch (
                  (d !== null &&
                    ((d.alternate = null),
                    (p.alternate = null),
                    (p.flags |= 2)),
                  (d = p.pendingProps),
                  (k = C._init),
                  (C = k(C._payload)),
                  (p.type = C),
                  (k = p.tag = ug(C)),
                  (d = Vr(C, d)),
                  k)
                ) {
                  case 0:
                    p = Gs(null, p, C, d, M);
                    break e;
                  case 1:
                    p = il(null, p, C, d, M);
                    break e;
                  case 11:
                    p = Nn(null, p, C, d, M);
                    break e;
                  case 14:
                    p = Dn(null, p, C, Vr(C.type, d), M);
                    break e;
                }
                throw Error(s(306, C, ""));
              }
              return p;
            case 0:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Vr(C, k)),
                Gs(d, p, C, k, M)
              );
            case 1:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Vr(C, k)),
                il(d, p, C, k, M)
              );
            case 3:
              e: {
                if ((rc(p), d === null)) throw Error(s(387));
                (C = p.pendingProps),
                  (z = p.memoizedState),
                  (k = z.element),
                  wh(d, p),
                  wf(p, C, null, M);
                var se = p.memoizedState;
                if (((C = se.element), _e && z.isDehydrated))
                  if (
                    ((z = {
                      element: C,
                      isDehydrated: !1,
                      cache: se.cache,
                      transitions: se.transitions,
                    }),
                    (p.updateQueue.baseState = z),
                    (p.memoizedState = z),
                    p.flags & 256)
                  ) {
                    (k = Error(s(423))), (p = Hh(d, p, C, M, k));
                    break e;
                  } else if (C !== k) {
                    (k = Error(s(424))), (p = Hh(d, p, C, M, k));
                    break e;
                  } else
                    for (
                      _e &&
                        ((ii = gr(p.stateNode.containerInfo)),
                        (Si = p),
                        (Wn = !0),
                        (Mo = null),
                        (Wl = !1)),
                        M = Jm(p, null, C, M),
                        p.child = M;
                      M;

                    )
                      (M.flags = (M.flags & -3) | 4096), (M = M.sibling);
                else {
                  if ((jl(), C === k)) {
                    p = zi(d, p, M);
                    break e;
                  }
                  Qn(d, p, C, M);
                }
                p = p.child;
              }
              return p;
            case 5:
              return (
                Qm(p),
                d === null && xa(p),
                (C = p.type),
                (k = p.pendingProps),
                (z = d !== null ? d.memoizedProps : null),
                (se = k.children),
                oe(C, k)
                  ? (se = null)
                  : z !== null && oe(C, z) && (p.flags |= 32),
                wi(d, p),
                Qn(d, p, se, M),
                p.child
              );
            case 6:
              return d === null && xa(p), null;
            case 13:
              return Gh(d, p, M);
            case 4:
              return (
                Af(p, p.stateNode.containerInfo),
                (C = p.pendingProps),
                d === null ? (p.child = Fs(p, null, C, M)) : Qn(d, p, C, M),
                p.child
              );
            case 11:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Vr(C, k)),
                Nn(d, p, C, k, M)
              );
            case 7:
              return Qn(d, p, p.pendingProps, M), p.child;
            case 8:
              return Qn(d, p, p.pendingProps.children, M), p.child;
            case 12:
              return Qn(d, p, p.pendingProps.children, M), p.child;
            case 10:
              e: {
                if (
                  ((C = p.type._context),
                  (k = p.pendingProps),
                  (z = p.memoizedProps),
                  (se = k.value),
                  ks(p, C, se),
                  z !== null)
                )
                  if (zr(z.value, se)) {
                    if (z.children === k.children && !wn.current) {
                      p = zi(d, p, M);
                      break e;
                    }
                  } else
                    for (
                      z = p.child, z !== null && (z.return = p);
                      z !== null;

                    ) {
                      var we = z.dependencies;
                      if (we !== null) {
                        se = z.child;
                        for (var Qe = we.firstContext; Qe !== null; ) {
                          if (Qe.context === C) {
                            if (z.tag === 1) {
                              (Qe = Os(-1, M & -M)), (Qe.tag = 2);
                              var ct = z.updateQueue;
                              if (ct !== null) {
                                ct = ct.shared;
                                var Tt = ct.pending;
                                Tt === null
                                  ? (Qe.next = Qe)
                                  : ((Qe.next = Tt.next), (Tt.next = Qe)),
                                  (ct.pending = Qe);
                              }
                            }
                            (z.lanes |= M),
                              (Qe = z.alternate),
                              Qe !== null && (Qe.lanes |= M),
                              Ar(z.return, M, p),
                              (we.lanes |= M);
                            break;
                          }
                          Qe = Qe.next;
                        }
                      } else if (z.tag === 10)
                        se = z.type === p.type ? null : z.child;
                      else if (z.tag === 18) {
                        if (((se = z.return), se === null)) throw Error(s(341));
                        (se.lanes |= M),
                          (we = se.alternate),
                          we !== null && (we.lanes |= M),
                          Ar(se, M, p),
                          (se = z.sibling);
                      } else se = z.child;
                      if (se !== null) se.return = z;
                      else
                        for (se = z; se !== null; ) {
                          if (se === p) {
                            se = null;
                            break;
                          }
                          if (((z = se.sibling), z !== null)) {
                            (z.return = se.return), (se = z);
                            break;
                          }
                          se = se.return;
                        }
                      z = se;
                    }
                Qn(d, p, k.children, M), (p = p.child);
              }
              return p;
            case 9:
              return (
                (k = p.type),
                (C = p.pendingProps.children),
                sr(p, M),
                (k = Yn(k)),
                (C = C(k)),
                (p.flags |= 1),
                Qn(d, p, C, M),
                p.child
              );
            case 14:
              return (
                (C = p.type),
                (k = Vr(C, p.pendingProps)),
                (k = Vr(C.type, k)),
                Dn(d, p, C, k, M)
              );
            case 15:
              return Hs(d, p, p.type, p.pendingProps, M);
            case 17:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Vr(C, k)),
                d !== null &&
                  ((d.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (p.tag = 1),
                Bn(C) ? ((d = !0), or(p)) : (d = !1),
                sr(p, M),
                Xm(p, C, k),
                Eh(p, C, k, M),
                hi(null, p, C, !0, d, M)
              );
            case 19:
              return sl(d, p, M);
            case 22:
              return oi(d, p, M);
          }
          throw Error(s(156, p.tag));
        };
        function pc(d, p) {
          return to(d, p);
        }
        function id(d, p, M, C) {
          (this.tag = d),
            (this.key = M),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = p),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = C),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function lo(d, p, M, C) {
          return new id(d, p, M, C);
        }
        function mc(d) {
          return (d = d.prototype), !(!d || !d.isReactComponent);
        }
        function ug(d) {
          if (typeof d == "function") return mc(d) ? 1 : 0;
          if (d != null) {
            if (((d = d.$$typeof), d === S)) return 11;
            if (d === T) return 14;
          }
          return 2;
        }
        function qs(d, p) {
          var M = d.alternate;
          return (
            M === null
              ? ((M = lo(d.tag, p, d.key, d.mode)),
                (M.elementType = d.elementType),
                (M.type = d.type),
                (M.stateNode = d.stateNode),
                (M.alternate = d),
                (d.alternate = M))
              : ((M.pendingProps = p),
                (M.type = d.type),
                (M.flags = 0),
                (M.subtreeFlags = 0),
                (M.deletions = null)),
            (M.flags = d.flags & 14680064),
            (M.childLanes = d.childLanes),
            (M.lanes = d.lanes),
            (M.child = d.child),
            (M.memoizedProps = d.memoizedProps),
            (M.memoizedState = d.memoizedState),
            (M.updateQueue = d.updateQueue),
            (p = d.dependencies),
            (M.dependencies =
              p === null
                ? null
                : { lanes: p.lanes, firstContext: p.firstContext }),
            (M.sibling = d.sibling),
            (M.index = d.index),
            (M.ref = d.ref),
            M
          );
        }
        function gc(d, p, M, C, k, z) {
          var se = 2;
          if (((C = d), typeof d == "function")) mc(d) && (se = 1);
          else if (typeof d == "string") se = 5;
          else
            e: switch (d) {
              case h:
                return La(M.children, k, z, p);
              case m:
                (se = 8), (k |= 8);
                break;
              case g:
                return (
                  (d = lo(12, M, p, k | 2)),
                  (d.elementType = g),
                  (d.lanes = z),
                  d
                );
              case x:
                return (
                  (d = lo(13, M, p, k)), (d.elementType = x), (d.lanes = z), d
                );
              case w:
                return (
                  (d = lo(19, M, p, k)), (d.elementType = w), (d.lanes = z), d
                );
              case A:
                return hu(M, k, z, p);
              default:
                if (typeof d == "object" && d !== null)
                  switch (d.$$typeof) {
                    case y:
                      se = 10;
                      break e;
                    case _:
                      se = 9;
                      break e;
                    case S:
                      se = 11;
                      break e;
                    case T:
                      se = 14;
                      break e;
                    case E:
                      (se = 16), (C = null);
                      break e;
                  }
                throw Error(s(130, d == null ? d : typeof d, ""));
            }
          return (
            (p = lo(se, M, p, k)),
            (p.elementType = d),
            (p.type = C),
            (p.lanes = z),
            p
          );
        }
        function La(d, p, M, C) {
          return (d = lo(7, d, C, p)), (d.lanes = M), d;
        }
        function hu(d, p, M, C) {
          return (
            (d = lo(22, d, C, p)),
            (d.elementType = A),
            (d.lanes = M),
            (d.stateNode = {}),
            d
          );
        }
        function od(d, p, M) {
          return (d = lo(6, d, null, p)), (d.lanes = M), d;
        }
        function sd(d, p, M) {
          return (
            (p = lo(4, d.children !== null ? d.children : [], d.key, p)),
            (p.lanes = M),
            (p.stateNode = {
              containerInfo: d.containerInfo,
              pendingChildren: null,
              implementation: d.implementation,
            }),
            p
          );
        }
        function cg(d, p, M, C, k) {
          (this.tag = p),
            (this.containerInfo = d),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = Ee),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = $a(0)),
            (this.expirationTimes = $a(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = $a(0)),
            (this.identifierPrefix = C),
            (this.onRecoverableError = k),
            _e && (this.mutableSourceEagerHydrationData = null);
        }
        function fg(d, p, M, C, k, z, se, we, Qe) {
          return (
            (d = new cg(d, p, M, we, Qe)),
            p === 1 ? ((p = 1), z === !0 && (p |= 8)) : (p = 0),
            (z = lo(3, null, null, p)),
            (d.current = z),
            (z.stateNode = d),
            (z.memoizedState = {
              element: C,
              isDehydrated: M,
              cache: null,
              transitions: null,
            }),
            Hl(z),
            d
          );
        }
        function Qh(d) {
          if (!d) return Zt;
          d = d._reactInternals;
          e: {
            if (O(d) !== d || d.tag !== 1) throw Error(s(170));
            var p = d;
            do {
              switch (p.tag) {
                case 3:
                  p = p.stateNode.context;
                  break e;
                case 1:
                  if (Bn(p.type)) {
                    p = p.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              p = p.return;
            } while (p !== null);
            throw Error(s(171));
          }
          if (d.tag === 1) {
            var M = d.type;
            if (Bn(M)) return as(d, M, p);
          }
          return p;
        }
        function dg(d) {
          var p = d._reactInternals;
          if (p === void 0)
            throw typeof d.render == "function"
              ? Error(s(188))
              : ((d = Object.keys(d).join(",")), Error(s(268, d)));
          return (d = H(p)), d === null ? null : d.stateNode;
        }
        function hg(d, p) {
          if (((d = d.memoizedState), d !== null && d.dehydrated !== null)) {
            var M = d.retryLane;
            d.retryLane = M !== 0 && M < p ? M : p;
          }
        }
        function ad(d, p) {
          hg(d, p), (d = d.alternate) && hg(d, p);
        }
        function pg(d) {
          return (d = H(d)), d === null ? null : d.stateNode;
        }
        function mg() {
          return null;
        }
        return (
          (t.attemptContinuousHydration = function (d) {
            if (d.tag === 13) {
              var p = qr();
              Vi(d, 134217728, p), ad(d, 134217728);
            }
          }),
          (t.attemptHydrationAtCurrentPriority = function (d) {
            if (d.tag === 13) {
              var p = qr(),
                M = vs(d);
              Vi(d, M, p), ad(d, M);
            }
          }),
          (t.attemptSynchronousHydration = function (d) {
            switch (d.tag) {
              case 3:
                var p = d.stateNode;
                if (p.current.memoizedState.isDehydrated) {
                  var M = ls(p.pendingLanes);
                  M !== 0 &&
                    (ri(p, M | 1), pi(p, Gn()), (nn & 6) === 0 && (fl(), di()));
                }
                break;
              case 13:
                var C = qr();
                du(function () {
                  return Vi(d, 1, C);
                }),
                  ad(d, 1);
            }
          }),
          (t.batchedUpdates = function (d, p) {
            var M = nn;
            nn |= 1;
            try {
              return d(p);
            } finally {
              (nn = M), nn === 0 && (fl(), fs && di());
            }
          }),
          (t.createComponentSelector = function (d) {
            return { $$typeof: iu, value: d };
          }),
          (t.createContainer = function (d, p, M, C, k, z, se) {
            return fg(d, p, !1, null, M, C, k, z, se);
          }),
          (t.createHasPseudoClassSelector = function (d) {
            return { $$typeof: ou, value: d };
          }),
          (t.createHydrationContainer = function (
            d,
            p,
            M,
            C,
            k,
            z,
            se,
            we,
            Qe
          ) {
            return (
              (d = fg(M, C, !0, d, k, z, se, we, Qe)),
              (d.context = Qh(null)),
              (M = d.current),
              (C = qr()),
              (k = vs(M)),
              (z = Os(C, k)),
              (z.callback = p ?? null),
              va(M, z),
              (d.current.lanes = k),
              vo(d, k, C),
              pi(d, C),
              d
            );
          }),
          (t.createPortal = function (d, p, M) {
            var C =
              3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : null;
            return {
              $$typeof: f,
              key: C == null ? null : "" + C,
              children: d,
              containerInfo: p,
              implementation: M,
            };
          }),
          (t.createRoleSelector = function (d) {
            return { $$typeof: su, value: d };
          }),
          (t.createTestNameSelector = function (d) {
            return { $$typeof: $s, value: d };
          }),
          (t.createTextSelector = function (d) {
            return { $$typeof: Ei, value: d };
          }),
          (t.deferredUpdates = function (d) {
            var p = $t,
              M = jn.transition;
            try {
              return (jn.transition = null), ($t = 16), d();
            } finally {
              ($t = p), (jn.transition = M);
            }
          }),
          (t.discreteUpdates = function (d, p, M, C, k) {
            var z = $t,
              se = jn.transition;
            try {
              return (jn.transition = null), ($t = 1), d(p, M, C, k);
            } finally {
              ($t = z), (jn.transition = se), nn === 0 && fl();
            }
          }),
          (t.findAllNodes = cc),
          (t.findBoundingRects = function (d, p) {
            if (!Z) throw Error(s(363));
            (p = cc(d, p)), (d = []);
            for (var M = 0; M < p.length; M++) d.push(me(p[M]));
            for (p = d.length - 1; 0 < p; p--) {
              M = d[p];
              for (
                var C = M.x,
                  k = C + M.width,
                  z = M.y,
                  se = z + M.height,
                  we = p - 1;
                0 <= we;
                we--
              )
                if (p !== we) {
                  var Qe = d[we],
                    ct = Qe.x,
                    Tt = ct + Qe.width,
                    qt = Qe.y,
                    zt = qt + Qe.height;
                  if (C >= ct && z >= qt && k <= Tt && se <= zt) {
                    d.splice(p, 1);
                    break;
                  } else if (
                    C !== ct ||
                    M.width !== Qe.width ||
                    zt < z ||
                    qt > se
                  ) {
                    if (
                      !(z !== qt || M.height !== Qe.height || Tt < C || ct > k)
                    ) {
                      ct > C && ((Qe.width += ct - C), (Qe.x = C)),
                        Tt < k && (Qe.width = k - ct),
                        d.splice(p, 1);
                      break;
                    }
                  } else {
                    qt > z && ((Qe.height += qt - z), (Qe.y = z)),
                      zt < se && (Qe.height = se - qt),
                      d.splice(p, 1);
                    break;
                  }
                }
            }
            return d;
          }),
          (t.findHostInstance = dg),
          (t.findHostInstanceWithNoPortals = function (d) {
            return (
              (d = V(d)),
              (d = d !== null ? q(d) : null),
              d === null ? null : d.stateNode
            );
          }),
          (t.findHostInstanceWithWarning = function (d) {
            return dg(d);
          }),
          (t.flushControlled = function (d) {
            var p = nn;
            nn |= 1;
            var M = jn.transition,
              C = $t;
            try {
              (jn.transition = null), ($t = 1), d();
            } finally {
              ($t = C), (jn.transition = M), (nn = p), nn === 0 && (fl(), di());
            }
          }),
          (t.flushPassiveEffects = Ia),
          (t.flushSync = du),
          (t.focusWithin = function (d, p) {
            if (!Z) throw Error(s(363));
            for (
              d = uc(d), p = Xs(d, p), p = Array.from(p), d = 0;
              d < p.length;

            ) {
              var M = p[d++];
              if (!ye(M)) {
                if (M.tag === 5 && at(M.stateNode)) return !0;
                for (M = M.child; M !== null; ) p.push(M), (M = M.sibling);
              }
            }
            return !1;
          }),
          (t.getCurrentUpdatePriority = function () {
            return $t;
          }),
          (t.getFindAllNodesFailureDescription = function (d, p) {
            if (!Z) throw Error(s(363));
            var M = 0,
              C = [];
            d = [uc(d), 0];
            for (var k = 0; k < d.length; ) {
              var z = d[k++],
                se = d[k++],
                we = p[se];
              if (
                (z.tag !== 5 || !ye(z)) &&
                (Zf(z, we) && (C.push(Yo(we)), se++, se > M && (M = se)),
                se < p.length)
              )
                for (z = z.child; z !== null; ) d.push(z, se), (z = z.sibling);
            }
            if (M < p.length) {
              for (d = []; M < p.length; M++) d.push(Yo(p[M]));
              return (
                `findAllNodes was able to match part of the selector:
  ` +
                (C.join(" > ") +
                  `

No matching component was found for:
  `) +
                d.join(" > ")
              );
            }
            return null;
          }),
          (t.getPublicRootInstance = function (d) {
            if (((d = d.current), !d.child)) return null;
            switch (d.child.tag) {
              case 5:
                return Y(d.child.stateNode);
              default:
                return d.child.stateNode;
            }
          }),
          (t.injectIntoDevTools = function (d) {
            if (
              ((d = {
                bundleType: d.bundleType,
                version: d.version,
                rendererPackageName: d.rendererPackageName,
                rendererConfig: d.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: l.ReactCurrentDispatcher,
                findHostInstanceByFiber: pg,
                findFiberByHostInstance: d.findFiberByHostInstance || mg,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329",
              }),
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            )
              d = !1;
            else {
              var p = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (p.isDisabled || !p.supportsFiber) d = !0;
              else {
                try {
                  (ha = p.inject(d)), (no = p);
                } catch {}
                d = !!p.checkDCE;
              }
            }
            return d;
          }),
          (t.isAlreadyRendering = function () {
            return !1;
          }),
          (t.observeVisibleRects = function (d, p, M, C) {
            if (!Z) throw Error(s(363));
            d = cc(d, p);
            var k = Fe(d, M, C).disconnect;
            return {
              disconnect: function () {
                k();
              },
            };
          }),
          (t.registerMutableSourceForHydration = function (d, p) {
            var M = p._getVersion;
            (M = M(p._source)),
              d.mutableSourceEagerHydrationData == null
                ? (d.mutableSourceEagerHydrationData = [p, M])
                : d.mutableSourceEagerHydrationData.push(p, M);
          }),
          (t.runWithPriority = function (d, p) {
            var M = $t;
            try {
              return ($t = d), p();
            } finally {
              $t = M;
            }
          }),
          (t.shouldError = function () {
            return null;
          }),
          (t.shouldSuspend = function () {
            return !1;
          }),
          (t.updateContainer = function (d, p, M, C) {
            var k = p.current,
              z = qr(),
              se = vs(k);
            return (
              (M = Qh(M)),
              p.context === null ? (p.context = M) : (p.pendingContext = M),
              (p = Os(z, se)),
              (p.payload = { element: d }),
              (C = C === void 0 ? null : C),
              C !== null && (p.callback = C),
              va(k, p),
              (d = Vi(k, se, z)),
              d !== null && _f(d, k, se),
              se
            );
          }),
          t
        );
      })),
    Z_
  );
}
var _T;
function v8() {
  return _T || ((_T = 1), (Y_.exports = g8())), Y_.exports;
}
var y8 = v8();
const x8 = Tm(y8);
var ST = CR();
const _8 = (n) => typeof n == "object" && typeof n.then == "function",
  Ov = [];
function S8(n, e, t = (r, i) => r === i) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const r = n.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!t(n[i], e[i])) return !1;
  return !0;
}
function w8(n, e = null, t = !1, r = {}) {
  e === null && (e = [n]);
  for (const o of Ov)
    if (S8(e, o.keys, o.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(o, "error")) throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (o.timeout && clearTimeout(o.timeout),
            (o.timeout = setTimeout(o.remove, r.lifespan))),
          o.response
        );
      if (!t) throw o.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const o = Ov.indexOf(i);
      o !== -1 && Ov.splice(o, 1);
    },
    promise: (_8(n) ? n : n(...e))
      .then((o) => {
        (i.response = o),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((o) => (i.error = o)),
  };
  if ((Ov.push(i), !t)) throw i.promise;
}
const M8 = (n, e, t) => w8(n, e, !1, t),
  vw = {},
  b8 = (n) => void Object.assign(vw, n);
function E8(n, e) {
  function t(h, { args: m = [], attach: g, ...y }, _) {
    let S = `${h[0].toUpperCase()}${h.slice(1)}`,
      x;
    if (h === "primitive") {
      if (y.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const w = y.object;
      x = Wd(w, { type: h, root: _, attach: g, primitive: !0 });
    } else {
      const w = vw[S];
      if (!w)
        throw new Error(
          `R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(m))
        throw new Error("R3F: The args prop must be an array!");
      x = Wd(new w(...m), {
        type: h,
        root: _,
        attach: g,
        memoizedProps: { args: m },
      });
    }
    return (
      x.__r3f.attach === void 0 &&
        (x instanceof Kt
          ? (x.__r3f.attach = "geometry")
          : x instanceof ki && (x.__r3f.attach = "material")),
      S !== "inject" && e1(x, y),
      x
    );
  }
  function r(h, m) {
    let g = !1;
    if (m) {
      var y, _;
      (y = m.__r3f) != null && y.attach
        ? Q_(h, m, m.__r3f.attach)
        : m.isObject3D && h.isObject3D && (h.add(m), (g = !0)),
        g || (_ = h.__r3f) == null || _.objects.push(m),
        m.__r3f || Wd(m, {}),
        (m.__r3f.parent = h),
        X1(m),
        jd(m);
    }
  }
  function i(h, m, g) {
    let y = !1;
    if (m) {
      var _, S;
      if ((_ = m.__r3f) != null && _.attach) Q_(h, m, m.__r3f.attach);
      else if (m.isObject3D && h.isObject3D) {
        (m.parent = h),
          m.dispatchEvent({ type: "added" }),
          h.dispatchEvent({ type: "childadded", child: m });
        const x = h.children.filter((T) => T !== m),
          w = x.indexOf(g);
        (h.children = [...x.slice(0, w), m, ...x.slice(w)]), (y = !0);
      }
      y || (S = h.__r3f) == null || S.objects.push(m),
        m.__r3f || Wd(m, {}),
        (m.__r3f.parent = h),
        X1(m),
        jd(m);
    }
  }
  function o(h, m, g = !1) {
    h && [...h].forEach((y) => s(m, y, g));
  }
  function s(h, m, g) {
    if (m) {
      var y, _, S;
      if (
        (m.__r3f && (m.__r3f.parent = null),
        (y = h.__r3f) != null &&
          y.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((A) => A !== m)),
        (_ = m.__r3f) != null && _.attach)
      )
        TT(h, m, m.__r3f.attach);
      else if (m.isObject3D && h.isObject3D) {
        var x;
        h.remove(m), (x = m.__r3f) != null && x.root && L8(qv(m), m);
      }
      const T = (S = m.__r3f) == null ? void 0 : S.primitive,
        E = !T && (g === void 0 ? m.dispose !== null : g);
      if (!T) {
        var w;
        o((w = m.__r3f) == null ? void 0 : w.objects, m, E),
          o(m.children, m, E);
      }
      if ((delete m.__r3f, E && m.dispose && m.type !== "Scene")) {
        const A = () => {
          try {
            m.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? ST.unstable_scheduleCallback(ST.unstable_IdlePriority, A)
          : A();
      }
      jd(h);
    }
  }
  function l(h, m, g, y) {
    var _;
    const S = (_ = h.__r3f) == null ? void 0 : _.parent;
    if (!S) return;
    const x = t(m, g, h.__r3f.root);
    if (h.children) {
      for (const w of h.children) w.__r3f && r(x, w);
      h.children = h.children.filter((w) => !w.__r3f);
    }
    h.__r3f.objects.forEach((w) => r(x, w)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || s(S, h),
      x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
      r(S, x),
      x.raycast &&
        x.__r3f.eventCount &&
        qv(x).getState().internal.interaction.push(x),
      [y, y.alternate].forEach((w) => {
        w !== null &&
          ((w.stateNode = x),
          w.ref &&
            (typeof w.ref == "function" ? w.ref(x) : (w.ref.current = x)));
      });
  }
  const u = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: x8({
      createInstance: t,
      removeChild: s,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, m) => {
        if (!m) return;
        const g = h.getState().scene;
        g.__r3f && ((g.__r3f.root = h), r(g, m));
      },
      removeChildFromContainer: (h, m) => {
        m && s(h.getState().scene, m);
      },
      insertInContainerBefore: (h, m, g) => {
        if (!m || !g) return;
        const y = h.getState().scene;
        y.__r3f && i(y, m, g);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var m;
        return !!((m = h == null ? void 0 : h.__r3f) != null ? m : {}).handlers;
      },
      prepareUpdate(h, m, g, y) {
        var _;
        if (
          ((_ = h == null ? void 0 : h.__r3f) != null ? _ : {}).primitive &&
          y.object &&
          y.object !== h
        )
          return [!0];
        {
          const { args: x = [], children: w, ...T } = y,
            { args: E = [], children: A, ...R } = g;
          if (!Array.isArray(x))
            throw new Error("R3F: the args prop must be an array!");
          if (x.some((I, U) => I !== E[U])) return [!0];
          const D = kR(h, T, R, !0);
          return D.changes.length ? [!1, D] : null;
        }
      },
      commitUpdate(h, [m, g], y, _, S, x) {
        m ? l(h, y, S, x) : e1(h, g);
      },
      commitMount(h, m, g, y) {
        var _;
        const S = (_ = h.__r3f) != null ? _ : {};
        h.raycast &&
          S.handlers &&
          S.eventCount &&
          qv(h).getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => Wd(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var m;
        const { attach: g, parent: y } = (m = h.__r3f) != null ? m : {};
        g && y && TT(y, h, g), h.isObject3D && (h.visible = !1), jd(h);
      },
      unhideInstance(h, m) {
        var g;
        const { attach: y, parent: _ } = (g = h.__r3f) != null ? g : {};
        y && _ && Q_(_, h, y),
          ((h.isObject3D && m.visible == null) || m.visible) &&
            (h.visible = !0),
          jd(h);
      },
      createTextInstance: u,
      hideTextInstance: u,
      unhideTextInstance: u,
      getCurrentEventPriority: () => (e ? e() : Jd.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Jn.fun(performance.now)
          ? performance.now
          : Jn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Jn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Jn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: e1,
  };
}
var wT, MT;
const J_ = (n) => "colorSpace" in n || "outputColorSpace" in n,
  AR = () => {
    var n;
    return (n = vw.ColorManagement) != null ? n : null;
  },
  RR = (n) => n && n.isOrthographicCamera,
  T8 = (n) => n && n.hasOwnProperty("current"),
  Wm =
    typeof window < "u" &&
    (((wT = window.document) != null && wT.createElement) ||
      ((MT = window.navigator) == null ? void 0 : MT.product) === "ReactNative")
      ? ee.useLayoutEffect
      : ee.useEffect;
function PR(n) {
  const e = ee.useRef(n);
  return Wm(() => void (e.current = n), [n]), e;
}
function C8({ set: n }) {
  return Wm(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class IR extends ee.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
IR.getDerivedStateFromError = () => ({ error: !0 });
const LR = "__default",
  bT = new Map(),
  A8 = (n) => n && !!n.memoized && !!n.changes;
function DR(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const Tp = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function qv(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Jn = {
  obj: (n) => n === Object(n) && !Jn.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (Jn.str(n) || Jn.num(n) || Jn.boo(n)) return n === e;
    const o = Jn.obj(n);
    if (o && r === "reference") return n === e;
    const s = Jn.arr(n);
    if (s && t === "reference") return n === e;
    if ((s || o) && n === e) return !0;
    let l;
    for (l in n) if (!(l in e)) return !1;
    if (o && t === "shallow" && r === "shallow") {
      for (l in i ? e : n)
        if (!Jn.equ(n[l], e[l], { strict: i, objects: "reference" })) return !1;
    } else for (l in i ? e : n) if (n[l] !== e[l]) return !1;
    if (Jn.und(l)) {
      if (
        (s && n.length === 0 && e.length === 0) ||
        (o && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function R8(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function Wd(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function $1(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (t = r.reduce((o, s) => o[s], n)), { target: t, key: i };
  } else return { target: t, key: e };
}
const ET = /-\d+$/;
function Q_(n, e, t) {
  if (Jn.str(t)) {
    if (ET.test(t)) {
      const o = t.replace(ET, ""),
        { target: s, key: l } = $1(n, o);
      Array.isArray(s[l]) || (s[l] = []);
    }
    const { target: r, key: i } = $1(n, t);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function TT(n, e, t) {
  var r, i;
  if (Jn.str(t)) {
    const { target: o, key: s } = $1(n, t),
      l = e.__r3f.previousAttach;
    l === void 0 ? delete o[s] : (o[s] = l);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function kR(
  n,
  { children: e, key: t, ref: r, ...i },
  { children: o, key: s, ref: l, ...u } = {},
  f = !1
) {
  const h = n.__r3f,
    m = Object.entries(i),
    g = [];
  if (f) {
    const _ = Object.keys(u);
    for (let S = 0; S < _.length; S++)
      i.hasOwnProperty(_[S]) || m.unshift([_[S], LR + "remove"]);
  }
  m.forEach(([_, S]) => {
    var x;
    if (
      ((x = n.__r3f) != null && x.primitive && _ === "object") ||
      Jn.equ(S, u[_])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(_))
      return g.push([_, S, !0, []]);
    let w = [];
    _.includes("-") && (w = _.split("-")), g.push([_, S, !1, w]);
    for (const T in i) {
      const E = i[T];
      T.startsWith(`${_}-`) && g.push([T, E, !1, T.split("-")]);
    }
  });
  const y = { ...i };
  return (
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.args &&
      (y.args = h.memoizedProps.args),
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.attach &&
      (y.attach = h.memoizedProps.attach),
    { memoized: y, changes: g }
  );
}
function e1(n, e) {
  var t;
  const r = n.__r3f,
    i = r == null ? void 0 : r.root,
    o = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: s, changes: l } = A8(e) ? e : kR(n, e),
    u = r == null ? void 0 : r.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = s);
  for (let h = 0; h < l.length; h++) {
    let [m, g, y, _] = l[h];
    if (J_(n)) {
      const T = "srgb",
        E = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (g = g === 3001 ? T : E))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (g = g === 3001 ? T : E));
    }
    let S = n,
      x = S[m];
    if (_.length && ((x = _.reduce((w, T) => w[T], n)), !(x && x.set))) {
      const [w, ...T] = _.reverse();
      (S = T.reverse().reduce((E, A) => E[A], n)), (m = w);
    }
    if (g === LR + "remove")
      if (S.constructor) {
        let w = bT.get(S.constructor);
        w || ((w = new S.constructor()), bT.set(S.constructor, w)), (g = w[m]);
      } else g = 0;
    if (y && r)
      g ? (r.handlers[m] = g) : delete r.handlers[m],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (x && x.set && (x.copy || x instanceof ef)) {
      if (Array.isArray(g)) x.fromArray ? x.fromArray(g) : x.set(...g);
      else if (x.copy && g && g.constructor && x.constructor === g.constructor)
        x.copy(g);
      else if (g !== void 0) {
        const w = x instanceof St;
        !w && x.setScalar
          ? x.setScalar(g)
          : x instanceof ef && g instanceof ef
          ? (x.mask = g.mask)
          : x.set(g),
          !AR() && o && !o.linear && w && x.convertSRGBToLinear();
      }
    } else if (
      ((S[m] = g),
      S[m] instanceof rr && S[m].format === Ki && S[m].type === sa && o)
    ) {
      const w = S[m];
      J_(w) && J_(o.gl)
        ? (w.colorSpace = o.gl.outputColorSpace)
        : (w.encoding = o.gl.outputEncoding);
    }
    jd(n);
  }
  if (r && r.parent && n.raycast && u !== r.eventCount) {
    const h = qv(n).getState().internal,
      m = h.interaction.indexOf(n);
    m > -1 && h.interaction.splice(m, 1), r.eventCount && h.interaction.push(n);
  }
  return (
    !(l.length === 1 && l[0][0] === "onUpdate") &&
      l.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      X1(n),
    n
  );
}
function jd(n) {
  var e, t;
  const r =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function X1(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function P8(n, e) {
  n.manual ||
    (RR(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function Nv(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function I8() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Jd.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Jd.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Jd.ContinuousEventPriority;
    default:
      return Jd.DefaultEventPriority;
  }
}
function OR(n, e, t, r) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function L8(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((r) => r !== e)),
    (t.initialHits = t.initialHits.filter((r) => r !== e)),
    t.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((r, i) => {
      OR(t.capturedMap, e, r, i);
    });
}
function D8(n) {
  function e(u) {
    const { internal: f } = n.getState(),
      h = u.offsetX - f.initialClick[0],
      m = u.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(h * h + m * m));
  }
  function t(u) {
    return u.filter((f) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
        var m;
        return (m = f.__r3f) == null ? void 0 : m.handlers["onPointer" + h];
      })
    );
  }
  function r(u, f) {
    const h = n.getState(),
      m = new Set(),
      g = [],
      y = f ? f(h.internal.interaction) : h.internal.interaction;
    for (let w = 0; w < y.length; w++) {
      const T = Tp(y[w]);
      T && (T.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(u, h);
    function _(w) {
      const T = Tp(w);
      if (!T || !T.events.enabled || T.raycaster.camera === null) return [];
      if (T.raycaster.camera === void 0) {
        var E;
        T.events.compute == null ||
          T.events.compute(
            u,
            T,
            (E = T.previousRoot) == null ? void 0 : E.getState()
          ),
          T.raycaster.camera === void 0 && (T.raycaster.camera = null);
      }
      return T.raycaster.camera ? T.raycaster.intersectObject(w, !0) : [];
    }
    let S = y
      .flatMap(_)
      .sort((w, T) => {
        const E = Tp(w.object),
          A = Tp(T.object);
        return !E || !A
          ? w.distance - T.distance
          : A.events.priority - E.events.priority || w.distance - T.distance;
      })
      .filter((w) => {
        const T = Nv(w);
        return m.has(T) ? !1 : (m.add(T), !0);
      });
    h.events.filter && (S = h.events.filter(S, h));
    for (const w of S) {
      let T = w.object;
      for (; T; ) {
        var x;
        (x = T.__r3f) != null &&
          x.eventCount &&
          g.push({ ...w, eventObject: T }),
          (T = T.parent);
      }
    }
    if ("pointerId" in u && h.internal.capturedMap.has(u.pointerId))
      for (let w of h.internal.capturedMap.get(u.pointerId).values())
        m.has(Nv(w.intersection)) || g.push(w.intersection);
    return g;
  }
  function i(u, f, h, m) {
    const g = n.getState();
    if (u.length) {
      const y = { stopped: !1 };
      for (const _ of u) {
        const S = Tp(_.object) || g,
          { raycaster: x, pointer: w, camera: T, internal: E } = S,
          A = new ie(w.x, w.y, 0).unproject(T),
          R = (L) => {
            var V, H;
            return (V =
              (H = E.capturedMap.get(L)) == null
                ? void 0
                : H.has(_.eventObject)) != null
              ? V
              : !1;
          },
          D = (L) => {
            const V = { intersection: _, target: f.target };
            E.capturedMap.has(L)
              ? E.capturedMap.get(L).set(_.eventObject, V)
              : E.capturedMap.set(L, new Map([[_.eventObject, V]])),
              f.target.setPointerCapture(L);
          },
          I = (L) => {
            const V = E.capturedMap.get(L);
            V && OR(E.capturedMap, _.eventObject, V, L);
          };
        let U = {};
        for (let L in f) {
          let V = f[L];
          typeof V != "function" && (U[L] = V);
        }
        let O = {
          ..._,
          ...U,
          pointer: w,
          intersections: u,
          stopped: y.stopped,
          delta: h,
          unprojectedPoint: A,
          ray: x.ray,
          camera: T,
          stopPropagation() {
            const L = "pointerId" in f && E.capturedMap.get(f.pointerId);
            if (
              (!L || L.has(_.eventObject)) &&
              ((O.stopped = y.stopped = !0),
              E.hovered.size &&
                Array.from(E.hovered.values()).find(
                  (V) => V.eventObject === _.eventObject
                ))
            ) {
              const V = u.slice(0, u.indexOf(_));
              o([...V, _]);
            }
          },
          target: {
            hasPointerCapture: R,
            setPointerCapture: D,
            releasePointerCapture: I,
          },
          currentTarget: {
            hasPointerCapture: R,
            setPointerCapture: D,
            releasePointerCapture: I,
          },
          nativeEvent: f,
        };
        if ((m(O), y.stopped === !0)) break;
      }
    }
    return u;
  }
  function o(u) {
    const { internal: f } = n.getState();
    for (const h of f.hovered.values())
      if (
        !u.length ||
        !u.find(
          (m) =>
            m.object === h.object &&
            m.index === h.index &&
            m.instanceId === h.instanceId
        )
      ) {
        const g = h.eventObject.__r3f,
          y = g == null ? void 0 : g.handlers;
        if ((f.hovered.delete(Nv(h)), g != null && g.eventCount)) {
          const _ = { ...h, intersections: u };
          y.onPointerOut == null || y.onPointerOut(_),
            y.onPointerLeave == null || y.onPointerLeave(_);
        }
      }
  }
  function s(u, f) {
    for (let h = 0; h < f.length; h++) {
      const m = f[h].__r3f;
      m == null ||
        m.handlers.onPointerMissed == null ||
        m.handlers.onPointerMissed(u);
    }
  }
  function l(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (f) => {
          const { internal: h } = n.getState();
          "pointerId" in f &&
            h.capturedMap.has(f.pointerId) &&
            requestAnimationFrame(() => {
              h.capturedMap.has(f.pointerId) &&
                (h.capturedMap.delete(f.pointerId), o([]));
            });
        };
    }
    return function (h) {
      const { onPointerMissed: m, internal: g } = n.getState();
      g.lastEvent.current = h;
      const y = u === "onPointerMove",
        _ = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick",
        x = r(h, y ? t : void 0),
        w = _ ? e(h) : 0;
      u === "onPointerDown" &&
        ((g.initialClick = [h.offsetX, h.offsetY]),
        (g.initialHits = x.map((E) => E.eventObject))),
        _ && !x.length && w <= 2 && (s(h, g.interaction), m && m(h)),
        y && o(x);
      function T(E) {
        const A = E.eventObject,
          R = A.__r3f,
          D = R == null ? void 0 : R.handlers;
        if (R != null && R.eventCount)
          if (y) {
            if (
              D.onPointerOver ||
              D.onPointerEnter ||
              D.onPointerOut ||
              D.onPointerLeave
            ) {
              const I = Nv(E),
                U = g.hovered.get(I);
              U
                ? U.stopped && E.stopPropagation()
                : (g.hovered.set(I, E),
                  D.onPointerOver == null || D.onPointerOver(E),
                  D.onPointerEnter == null || D.onPointerEnter(E));
            }
            D.onPointerMove == null || D.onPointerMove(E);
          } else {
            const I = D[u];
            I
              ? (!_ || g.initialHits.includes(A)) &&
                (s(
                  h,
                  g.interaction.filter((U) => !g.initialHits.includes(U))
                ),
                I(E))
              : _ &&
                g.initialHits.includes(A) &&
                s(
                  h,
                  g.interaction.filter((U) => !g.initialHits.includes(U))
                );
          }
      }
      i(x, h, w, T);
    };
  }
  return { handlePointer: l };
}
const NR = (n) => !!(n != null && n.render),
  UR = ee.createContext(null),
  k8 = (n, e) => {
    const t = p8((l, u) => {
        const f = new ie(),
          h = new ie(),
          m = new ie();
        function g(w = u().camera, T = h, E = u().size) {
          const { width: A, height: R, top: D, left: I } = E,
            U = A / R;
          T instanceof ie ? m.copy(T) : m.set(...T);
          const O = w.getWorldPosition(f).distanceTo(m);
          if (RR(w))
            return {
              width: A / w.zoom,
              height: R / w.zoom,
              top: D,
              left: I,
              factor: 1,
              distance: O,
              aspect: U,
            };
          {
            const L = (w.fov * Math.PI) / 180,
              V = 2 * Math.tan(L / 2) * O,
              H = V * (A / R);
            return {
              width: H,
              height: V,
              top: D,
              left: I,
              factor: A / H,
              distance: O,
              aspect: U,
            };
          }
        }
        let y;
        const _ = (w) =>
            l((T) => ({ performance: { ...T.performance, current: w } })),
          S = new tt();
        return {
          set: l,
          get: u,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (w = 1) => n(u(), w),
          advance: (w, T) => e(w, T, u()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new dw(),
          pointer: S,
          mouse: S,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const w = u();
              y && clearTimeout(y),
                w.performance.current !== w.performance.min &&
                  _(w.performance.min),
                (y = setTimeout(
                  () => _(u().performance.max),
                  w.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: g,
          },
          setEvents: (w) => l((T) => ({ ...T, events: { ...T.events, ...w } })),
          setSize: (w, T, E, A, R) => {
            const D = u().camera,
              I = {
                width: w,
                height: T,
                top: A || 0,
                left: R || 0,
                updateStyle: E,
              };
            l((U) => ({ size: I, viewport: { ...U.viewport, ...g(D, h, I) } }));
          },
          setDpr: (w) =>
            l((T) => {
              const E = DR(w);
              return {
                viewport: {
                  ...T.viewport,
                  dpr: E,
                  initialDpr: T.viewport.initialDpr || E,
                },
              };
            }),
          setFrameloop: (w = "always") => {
            const T = u().clock;
            T.stop(),
              (T.elapsedTime = 0),
              w !== "never" && (T.start(), (T.elapsedTime = 0)),
              l(() => ({ frameloop: w }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: ee.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (w, T, E) => {
              const A = u().internal;
              return (
                (A.priority = A.priority + (T > 0 ? 1 : 0)),
                A.subscribers.push({ ref: w, priority: T, store: E }),
                (A.subscribers = A.subscribers.sort(
                  (R, D) => R.priority - D.priority
                )),
                () => {
                  const R = u().internal;
                  R != null &&
                    R.subscribers &&
                    ((R.priority = R.priority - (T > 0 ? 1 : 0)),
                    (R.subscribers = R.subscribers.filter((D) => D.ref !== w)));
                }
              );
            },
          },
        };
      }),
      r = t.getState();
    let i = r.size,
      o = r.viewport.dpr,
      s = r.camera;
    return (
      t.subscribe(() => {
        const { camera: l, size: u, viewport: f, gl: h, set: m } = t.getState();
        if (u.width !== i.width || u.height !== i.height || f.dpr !== o) {
          var g;
          (i = u), (o = f.dpr), P8(l, u), h.setPixelRatio(f.dpr);
          const y =
            (g = u.updateStyle) != null
              ? g
              : typeof HTMLCanvasElement < "u" &&
                h.domElement instanceof HTMLCanvasElement;
          h.setSize(u.width, u.height, y);
        }
        l !== s &&
          ((s = l),
          m((y) => ({
            viewport: { ...y.viewport, ...y.viewport.getCurrentViewport(l) },
          })));
      }),
      t.subscribe((l) => n(l)),
      t
    );
  };
let Uv,
  O8 = new Set(),
  N8 = new Set(),
  U8 = new Set();
function t1(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Cp(n, e) {
  switch (n) {
    case "before":
      return t1(O8, e);
    case "after":
      return t1(N8, e);
    case "tail":
      return t1(U8, e);
  }
}
let n1, r1;
function i1(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((r = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      n1 = e.internal.subscribers,
      Uv = 0;
    Uv < n1.length;
    Uv++
  )
    (r1 = n1[Uv]), r1.ref.current(r1.store.getState(), r, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function F8(n) {
  let e = !1,
    t = !1,
    r,
    i,
    o;
  function s(f) {
    (i = requestAnimationFrame(s)),
      (e = !0),
      (r = 0),
      Cp("before", f),
      (t = !0);
    for (const m of n.values()) {
      var h;
      (o = m.store.getState()),
        o.internal.active &&
          (o.frameloop === "always" || o.internal.frames > 0) &&
          !((h = o.gl.xr) != null && h.isPresenting) &&
          (r += i1(f, o));
    }
    if (((t = !1), Cp("after", f), r === 0))
      return Cp("tail", f), (e = !1), cancelAnimationFrame(i);
  }
  function l(f, h = 1) {
    var m;
    if (!f) return n.forEach((g) => l(g.store.getState(), h));
    ((m = f.gl.xr) != null && m.isPresenting) ||
      !f.internal.active ||
      f.frameloop === "never" ||
      (h > 1
        ? (f.internal.frames = Math.min(60, f.internal.frames + h))
        : t
        ? (f.internal.frames = 2)
        : (f.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function u(f, h = !0, m, g) {
    if ((h && Cp("before", f), m)) i1(f, m, g);
    else for (const y of n.values()) i1(f, y.store.getState());
    h && Cp("after", f);
  }
  return { loop: s, invalidate: l, advance: u };
}
function FR() {
  const n = ee.useContext(UR);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function Sl(n = (t) => t, e) {
  return FR()(n, e);
}
function $y(n, e = 0) {
  const t = FR(),
    r = t.getState().internal.subscribe,
    i = PR(n);
  return Wm(() => r(i, e, t), [e, r, t]), null;
}
const dh = new Map(),
  { invalidate: CT, advance: AT } = F8(dh),
  { reconciler: G0, applyProps: zd } = E8(dh, I8),
  Bd = { objects: "shallow", strict: !1 },
  z8 = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return NR(t)
      ? t
      : new DA({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function B8(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: o, left: s, updateStyle: l = t } = e;
    return { width: r, height: i, top: o, left: s, updateStyle: l };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: o,
      left: s,
    } = n.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: o, left: s, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function V8(n) {
  const e = dh.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    o = r || k8(CT, AT),
    s =
      t ||
      G0.createContainer(o, Jd.ConcurrentRoot, null, !1, null, "", i, null);
  e || dh.set(n, { fiber: s, store: o });
  let l,
    u = !1,
    f;
  return {
    configure(h = {}) {
      let {
          gl: m,
          size: g,
          scene: y,
          events: _,
          onCreated: S,
          shadows: x = !1,
          linear: w = !1,
          flat: T = !1,
          legacy: E = !1,
          orthographic: A = !1,
          frameloop: R = "always",
          dpr: D = [1, 2],
          performance: I,
          raycaster: U,
          camera: O,
          onPointerMissed: L,
        } = h,
        V = o.getState(),
        H = V.gl;
      V.gl || V.set({ gl: (H = z8(m, n)) });
      let $ = V.raycaster;
      $ || V.set({ raycaster: ($ = new ER()) });
      const { params: q, ...K } = U || {};
      if (
        (Jn.equ(K, $, Bd) || zd($, { ...K }),
        Jn.equ(q, $.params, Bd) || zd($, { params: { ...$.params, ...q } }),
        !V.camera || (V.camera === f && !Jn.equ(f, O, Bd)))
      ) {
        f = O;
        const B = O instanceof Nm,
          G = B
            ? O
            : A
            ? new Nu(0, 0, 0, 0, 0.1, 1e3)
            : new Dr(75, 0, 0.1, 1e3);
        B ||
          ((G.position.z = 5),
          O &&
            (zd(G, O),
            ("aspect" in O ||
              "left" in O ||
              "right" in O ||
              "bottom" in O ||
              "top" in O) &&
              ((G.manual = !0), G.updateProjectionMatrix())),
          !V.camera && !(O != null && O.rotation) && G.lookAt(0, 0, 0)),
          V.set({ camera: G }),
          ($.camera = G);
      }
      if (!V.scene) {
        let B;
        y instanceof z0 ? (B = y) : ((B = new z0()), y && zd(B, y)),
          V.set({ scene: Wd(B) });
      }
      if (!V.xr) {
        var Y;
        const B = (le, J) => {
            const oe = o.getState();
            oe.frameloop !== "never" && AT(le, !0, oe, J);
          },
          G = () => {
            const le = o.getState();
            (le.gl.xr.enabled = le.gl.xr.isPresenting),
              le.gl.xr.setAnimationLoop(le.gl.xr.isPresenting ? B : null),
              le.gl.xr.isPresenting || CT(le);
          },
          te = {
            connect() {
              const le = o.getState().gl;
              le.xr.addEventListener("sessionstart", G),
                le.xr.addEventListener("sessionend", G);
            },
            disconnect() {
              const le = o.getState().gl;
              le.xr.removeEventListener("sessionstart", G),
                le.xr.removeEventListener("sessionend", G);
            },
          };
        typeof ((Y = H.xr) == null ? void 0 : Y.addEventListener) ==
          "function" && te.connect(),
          V.set({ xr: te });
      }
      if (H.shadowMap) {
        const B = H.shadowMap.enabled,
          G = H.shadowMap.type;
        if (((H.shadowMap.enabled = !!x), Jn.boo(x))) H.shadowMap.type = zp;
        else if (Jn.str(x)) {
          var ne;
          const te = { basic: E2, percentage: dy, soft: zp, variance: na };
          H.shadowMap.type = (ne = te[x]) != null ? ne : zp;
        } else Jn.obj(x) && Object.assign(H.shadowMap, x);
        (B !== H.shadowMap.enabled || G !== H.shadowMap.type) &&
          (H.shadowMap.needsUpdate = !0);
      }
      const j = AR();
      j &&
        ("enabled" in j
          ? (j.enabled = !E)
          : "legacyMode" in j && (j.legacyMode = E)),
        u ||
          zd(H, { outputEncoding: w ? 3e3 : 3001, toneMapping: T ? Ba : AS }),
        V.legacy !== E && V.set(() => ({ legacy: E })),
        V.linear !== w && V.set(() => ({ linear: w })),
        V.flat !== T && V.set(() => ({ flat: T })),
        m && !Jn.fun(m) && !NR(m) && !Jn.equ(m, H, Bd) && zd(H, m),
        _ && !V.events.handlers && V.set({ events: _(o) });
      const re = B8(n, g);
      return (
        Jn.equ(re, V.size, Bd) ||
          V.setSize(re.width, re.height, re.updateStyle, re.top, re.left),
        D && V.viewport.dpr !== DR(D) && V.setDpr(D),
        V.frameloop !== R && V.setFrameloop(R),
        V.onPointerMissed || V.set({ onPointerMissed: L }),
        I &&
          !Jn.equ(I, V.performance, Bd) &&
          V.set((B) => ({ performance: { ...B.performance, ...I } })),
        (l = S),
        (u = !0),
        this
      );
    },
    render(h) {
      return (
        u || this.configure(),
        G0.updateContainer(
          ve.jsx(H8, { store: o, children: h, onCreated: l, rootElement: n }),
          s,
          null,
          () => {}
        ),
        o
      );
    },
    unmount() {
      zR(n);
    },
  };
}
function H8({ store: n, children: e, onCreated: t, rootElement: r }) {
  return (
    Wm(() => {
      const i = n.getState();
      i.set((o) => ({ internal: { ...o.internal, active: !0 } })),
        t && t(i),
        n.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    ve.jsx(UR.Provider, { value: n, children: e })
  );
}
function zR(n, e) {
  const t = dh.get(n),
    r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      G0.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var o, s, l, u;
              i.events.disconnect == null || i.events.disconnect(),
                (o = i.gl) == null ||
                  (s = o.renderLists) == null ||
                  s.dispose == null ||
                  s.dispose(),
                (l = i.gl) == null ||
                  l.forceContextLoss == null ||
                  l.forceContextLoss(),
                (u = i.gl) != null && u.xr && i.xr.disconnect(),
                R8(i),
                dh.delete(n);
            } catch {}
          }, 500);
      });
  }
}
G0.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: ee.version,
});
function RT(n, e) {
  let t;
  return (...r) => {
    window.clearTimeout(t), (t = window.setTimeout(() => n(...r), e));
  };
}
function G8(
  { debounce: n, scroll: e, polyfill: t, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, s] = ee.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = ee.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
      orientationHandler: null,
    }),
    u = n ? (typeof n == "number" ? n : n.scroll) : null,
    f = n ? (typeof n == "number" ? n : n.resize) : null,
    h = ee.useRef(!1);
  ee.useEffect(() => ((h.current = !0), () => void (h.current = !1)));
  const [m, g, y] = ee.useMemo(() => {
    const w = () => {
      if (!l.current.element) return;
      const {
          left: T,
          top: E,
          width: A,
          height: R,
          bottom: D,
          right: I,
          x: U,
          y: O,
        } = l.current.element.getBoundingClientRect(),
        L = {
          left: T,
          top: E,
          width: A,
          height: R,
          bottom: D,
          right: I,
          x: U,
          y: O,
        };
      l.current.element instanceof HTMLElement &&
        r &&
        ((L.height = l.current.element.offsetHeight),
        (L.width = l.current.element.offsetWidth)),
        Object.freeze(L),
        h.current &&
          !X8(l.current.lastBounds, L) &&
          s((l.current.lastBounds = L));
    };
    return [w, f ? RT(w, f) : w, u ? RT(w, u) : w];
  }, [s, r, u, f]);
  function _() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((w) =>
        w.removeEventListener("scroll", y, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null)),
      l.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              l.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              l.current.orientationHandler
            ));
  }
  function S() {
    l.current.element &&
      ((l.current.resizeObserver = new i(y)),
      l.current.resizeObserver.observe(l.current.element),
      e &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((w) =>
          w.addEventListener("scroll", y, { capture: !0, passive: !0 })
        ),
      (l.current.orientationHandler = () => {
        y();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            l.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            l.current.orientationHandler
          ));
  }
  const x = (w) => {
    !w ||
      w === l.current.element ||
      (_(), (l.current.element = w), (l.current.scrollContainers = BR(w)), S());
  };
  return (
    j8(y, !!e),
    W8(g),
    ee.useEffect(() => {
      _(), S();
    }, [e, y, g]),
    ee.useEffect(() => _, []),
    [x, o, m]
  );
}
function W8(n) {
  ee.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function j8(n, e) {
  ee.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function BR(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(n);
  return (
    [t, r, i].some((o) => o === "auto" || o === "scroll") && e.push(n),
    [...e, ...BR(n.parentElement)]
  );
}
const $8 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  X8 = (n, e) => $8.every((t) => n[t] === e[t]);
var Y8 = Object.defineProperty,
  q8 = Object.defineProperties,
  K8 = Object.getOwnPropertyDescriptors,
  PT = Object.getOwnPropertySymbols,
  Z8 = Object.prototype.hasOwnProperty,
  J8 = Object.prototype.propertyIsEnumerable,
  IT = (n, e, t) =>
    e in n
      ? Y8(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  LT = (n, e) => {
    for (var t in e || (e = {})) Z8.call(e, t) && IT(n, t, e[t]);
    if (PT) for (var t of PT(e)) J8.call(e, t) && IT(n, t, e[t]);
    return n;
  },
  Q8 = (n, e) => q8(n, K8(e)),
  DT,
  kT;
typeof window < "u" &&
(((DT = window.document) != null && DT.createElement) ||
  ((kT = window.navigator) == null ? void 0 : kT.product) === "ReactNative")
  ? ee.useLayoutEffect
  : ee.useEffect;
function VR(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = n.child;
  for (; r; ) {
    const i = VR(r, e, t);
    if (i) return i;
    r = r.sibling;
  }
}
function HR(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const OT = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = OT;
    return;
  }
  return OT.apply(this, arguments);
};
const yw = HR(ee.createContext(null));
class GR extends ee.Component {
  render() {
    return ee.createElement(
      yw.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function eG() {
  const n = ee.useContext(yw);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = ee.useId();
  return ee.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r) continue;
      const i = VR(r, !1, (o) => {
        let s = o.memoizedState;
        for (; s; ) {
          if (s.memoizedState === e) return !0;
          s = s.next;
        }
      });
      if (i) return i;
    }
  }, [n, e]);
}
function tG() {
  const n = eG(),
    [e] = ee.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      i && i !== yw && !e.has(i) && e.set(i, ee.useContext(HR(i)));
    }
    t = t.return;
  }
  return e;
}
function nG() {
  const n = tG();
  return ee.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (r) =>
          ee.createElement(
            e,
            null,
            ee.createElement(t.Provider, Q8(LT({}, r), { value: n.get(t) }))
          ),
        (e) => ee.createElement(GR, LT({}, e))
      ),
    [n]
  );
}
const o1 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function rG(n) {
  const { handlePointer: e } = D8(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(
        (t.offsetX / r.size.width) * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(o1).reduce((t, r) => ({ ...t, [r]: e(r) }), {}),
    update: () => {
      var t;
      const { events: r, internal: i } = n.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const { set: i, events: o } = n.getState();
      o.disconnect == null || o.disconnect(),
        i((s) => ({ events: { ...s.events, connected: t } })),
        Object.entries((r = o.handlers) != null ? r : []).forEach(([s, l]) => {
          const [u, f] = o1[s];
          t.addEventListener(u, l, { passive: f });
        });
    },
    disconnect: () => {
      const { set: t, events: r } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([o, s]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [l] = o1[o];
            r.connected.removeEventListener(l, s);
          }
        }),
          t((o) => ({ events: { ...o.events, connected: void 0 } }));
      }
    },
  };
}
const iG = ee.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: r,
      style: i,
      gl: o,
      events: s = rG,
      eventSource: l,
      eventPrefix: u,
      shadows: f,
      linear: h,
      flat: m,
      legacy: g,
      orthographic: y,
      frameloop: _,
      dpr: S,
      performance: x,
      raycaster: w,
      camera: T,
      scene: E,
      onPointerMissed: A,
      onCreated: R,
      ...D
    },
    I
  ) {
    ee.useMemo(() => b8(u8), []);
    const U = nG(),
      [O, L] = G8({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      V = ee.useRef(null),
      H = ee.useRef(null);
    ee.useImperativeHandle(I, () => V.current);
    const $ = PR(A),
      [q, K] = ee.useState(!1),
      [Y, ne] = ee.useState(!1);
    if (q) throw q;
    if (Y) throw Y;
    const j = ee.useRef(null);
    Wm(() => {
      const B = V.current;
      L.width > 0 &&
        L.height > 0 &&
        B &&
        (j.current || (j.current = V8(B)),
        j.current.configure({
          gl: o,
          events: s,
          shadows: f,
          linear: h,
          flat: m,
          legacy: g,
          orthographic: y,
          frameloop: _,
          dpr: S,
          performance: x,
          raycaster: w,
          camera: T,
          scene: E,
          size: L,
          onPointerMissed: (...G) =>
            $.current == null ? void 0 : $.current(...G),
          onCreated: (G) => {
            G.events.connect == null ||
              G.events.connect(l ? (T8(l) ? l.current : l) : H.current),
              u &&
                G.setEvents({
                  compute: (te, le) => {
                    const J = te[u + "X"],
                      oe = te[u + "Y"];
                    le.pointer.set(
                      (J / le.size.width) * 2 - 1,
                      -(oe / le.size.height) * 2 + 1
                    ),
                      le.raycaster.setFromCamera(le.pointer, le.camera);
                  },
                }),
              R == null || R(G);
          },
        }),
        j.current.render(
          ve.jsx(U, {
            children: ve.jsx(IR, {
              set: ne,
              children: ve.jsx(ee.Suspense, {
                fallback: ve.jsx(C8, { set: K }),
                children: e,
              }),
            }),
          })
        ));
    }),
      ee.useEffect(() => {
        const B = V.current;
        if (B) return () => zR(B);
      }, []);
    const re = l ? "none" : "auto";
    return ve.jsx("div", {
      ref: H,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: re,
        ...i,
      },
      ...D,
      children: ve.jsx("div", {
        ref: O,
        style: { width: "100%", height: "100%" },
        children: ve.jsx("canvas", {
          ref: V,
          style: { display: "block" },
          children: t,
        }),
      }),
    });
  }),
  WR = ee.forwardRef(function (e, t) {
    return ve.jsx(GR, { children: ve.jsx(iG, { ...e, ref: t }) });
  });
var oG = Object.defineProperty,
  sG = (n, e, t) =>
    e in n
      ? oG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  aG = (n, e, t) => (sG(n, e + "", t), t);
class lG {
  constructor() {
    aG(this, "_listeners");
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
}
var uG = Object.defineProperty,
  cG = (n, e, t) =>
    e in n
      ? uG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  Gt = (n, e, t) => (cG(n, typeof e != "symbol" ? e + "" : e, t), t);
const Fv = new hf(),
  NT = new wl(),
  fG = Math.cos(70 * (Math.PI / 180)),
  UT = (n, e) => ((n % e) + e) % e;
let dG = class extends lG {
  constructor(e, t) {
    super(),
      Gt(this, "object"),
      Gt(this, "domElement"),
      Gt(this, "enabled", !0),
      Gt(this, "target", new ie()),
      Gt(this, "minDistance", 0),
      Gt(this, "maxDistance", 1 / 0),
      Gt(this, "minZoom", 0),
      Gt(this, "maxZoom", 1 / 0),
      Gt(this, "minPolarAngle", 0),
      Gt(this, "maxPolarAngle", Math.PI),
      Gt(this, "minAzimuthAngle", -1 / 0),
      Gt(this, "maxAzimuthAngle", 1 / 0),
      Gt(this, "enableDamping", !1),
      Gt(this, "dampingFactor", 0.05),
      Gt(this, "enableZoom", !0),
      Gt(this, "zoomSpeed", 1),
      Gt(this, "enableRotate", !0),
      Gt(this, "rotateSpeed", 1),
      Gt(this, "enablePan", !0),
      Gt(this, "panSpeed", 1),
      Gt(this, "screenSpacePanning", !0),
      Gt(this, "keyPanSpeed", 7),
      Gt(this, "zoomToCursor", !1),
      Gt(this, "autoRotate", !1),
      Gt(this, "autoRotateSpeed", 2),
      Gt(this, "reverseOrbit", !1),
      Gt(this, "reverseHorizontalOrbit", !1),
      Gt(this, "reverseVerticalOrbit", !1),
      Gt(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      Gt(this, "mouseButtons", {
        LEFT: Vc.ROTATE,
        MIDDLE: Vc.DOLLY,
        RIGHT: Vc.PAN,
      }),
      Gt(this, "touches", { ONE: Hc.ROTATE, TWO: Hc.DOLLY_PAN }),
      Gt(this, "target0"),
      Gt(this, "position0"),
      Gt(this, "zoom0"),
      Gt(this, "_domElementKeyEvents", null),
      Gt(this, "getPolarAngle"),
      Gt(this, "getAzimuthalAngle"),
      Gt(this, "setPolarAngle"),
      Gt(this, "setAzimuthalAngle"),
      Gt(this, "getDistance"),
      Gt(this, "getZoomScale"),
      Gt(this, "listenToKeyEvents"),
      Gt(this, "stopListenToKeyEvents"),
      Gt(this, "saveState"),
      Gt(this, "reset"),
      Gt(this, "update"),
      Gt(this, "connect"),
      Gt(this, "dispose"),
      Gt(this, "dollyIn"),
      Gt(this, "dollyOut"),
      Gt(this, "getScale"),
      Gt(this, "setScale"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => h.phi),
      (this.getAzimuthalAngle = () => h.theta),
      (this.setPolarAngle = (ce) => {
        let Je = UT(ce, 2 * Math.PI),
          de = h.phi;
        de < 0 && (de += 2 * Math.PI), Je < 0 && (Je += 2 * Math.PI);
        let He = Math.abs(Je - de);
        2 * Math.PI - He < He &&
          (Je < de ? (Je += 2 * Math.PI) : (de += 2 * Math.PI)),
          (m.phi = Je - de),
          r.update();
      }),
      (this.setAzimuthalAngle = (ce) => {
        let Je = UT(ce, 2 * Math.PI),
          de = h.theta;
        de < 0 && (de += 2 * Math.PI), Je < 0 && (Je += 2 * Math.PI);
        let He = Math.abs(Je - de);
        2 * Math.PI - He < He &&
          (Je < de ? (Je += 2 * Math.PI) : (de += 2 * Math.PI)),
          (m.theta = Je - de),
          r.update();
      }),
      (this.getDistance = () => r.object.position.distanceTo(r.target)),
      (this.listenToKeyEvents = (ce) => {
        ce.addEventListener("keydown", ze), (this._domElementKeyEvents = ce);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", ze),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = () => {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(i),
          r.update(),
          (u = l.NONE);
      }),
      (this.update = (() => {
        const ce = new ie(),
          Je = new ie(0, 1, 0),
          de = new Ji().setFromUnitVectors(e.up, Je),
          He = de.clone().invert(),
          Ce = new ie(),
          Ue = new Ji(),
          it = 2 * Math.PI;
        return function () {
          const gt = r.object.position;
          de.setFromUnitVectors(e.up, Je),
            He.copy(de).invert(),
            ce.copy(gt).sub(r.target),
            ce.applyQuaternion(de),
            h.setFromVector3(ce),
            r.autoRotate && u === l.NONE && q(H()),
            r.enableDamping
              ? ((h.theta += m.theta * r.dampingFactor),
                (h.phi += m.phi * r.dampingFactor))
              : ((h.theta += m.theta), (h.phi += m.phi));
          let Ot = r.minAzimuthAngle,
            Nt = r.maxAzimuthAngle;
          isFinite(Ot) &&
            isFinite(Nt) &&
            (Ot < -Math.PI ? (Ot += it) : Ot > Math.PI && (Ot -= it),
            Nt < -Math.PI ? (Nt += it) : Nt > Math.PI && (Nt -= it),
            Ot <= Nt
              ? (h.theta = Math.max(Ot, Math.min(Nt, h.theta)))
              : (h.theta =
                  h.theta > (Ot + Nt) / 2
                    ? Math.max(Ot, h.theta)
                    : Math.min(Nt, h.theta))),
            (h.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, h.phi)
            )),
            h.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(y, r.dampingFactor)
              : r.target.add(y),
            (r.zoomToCursor && O) || r.object.isOrthographicCamera
              ? (h.radius = le(h.radius))
              : (h.radius = le(h.radius * g)),
            ce.setFromSpherical(h),
            ce.applyQuaternion(He),
            gt.copy(r.target).add(ce),
            r.object.matrixAutoUpdate || r.object.updateMatrix(),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((m.theta *= 1 - r.dampingFactor),
                (m.phi *= 1 - r.dampingFactor),
                y.multiplyScalar(1 - r.dampingFactor))
              : (m.set(0, 0, 0), y.set(0, 0, 0));
          let ht = !1;
          if (r.zoomToCursor && O) {
            let jt = null;
            if (r.object instanceof Dr && r.object.isPerspectiveCamera) {
              const an = ce.length();
              jt = le(an * g);
              const _n = an - jt;
              r.object.position.addScaledVector(I, _n),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const an = new ie(U.x, U.y, 0);
              an.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / g)
                )),
                r.object.updateProjectionMatrix(),
                (ht = !0);
              const _n = new ie(U.x, U.y, 0);
              _n.unproject(r.object),
                r.object.position.sub(_n).add(an),
                r.object.updateMatrixWorld(),
                (jt = ce.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            jt !== null &&
              (r.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar(jt)
                    .add(r.object.position)
                : (Fv.origin.copy(r.object.position),
                  Fv.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(Fv.direction)) < fG
                    ? e.lookAt(r.target)
                    : (NT.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      Fv.intersectPlane(NT, r.target))));
          } else
            r.object instanceof Nu &&
              r.object.isOrthographicCamera &&
              ((ht = g !== 1),
              ht &&
                ((r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / g)
                )),
                r.object.updateProjectionMatrix()));
          return (
            (g = 1),
            (O = !1),
            ht ||
            Ce.distanceToSquared(r.object.position) > f ||
            8 * (1 - Ue.dot(r.object.quaternion)) > f
              ? (r.dispatchEvent(i),
                Ce.copy(r.object.position),
                Ue.copy(r.object.quaternion),
                (ht = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (ce) => {
        (r.domElement = ce),
          (r.domElement.style.touchAction = "none"),
          r.domElement.addEventListener("contextmenu", nt),
          r.domElement.addEventListener("pointerdown", me),
          r.domElement.addEventListener("pointercancel", ye),
          r.domElement.addEventListener("wheel", Fe);
      }),
      (this.dispose = () => {
        var ce, Je, de, He, Ce, Ue;
        r.domElement && (r.domElement.style.touchAction = "auto"),
          (ce = r.domElement) == null ||
            ce.removeEventListener("contextmenu", nt),
          (Je = r.domElement) == null ||
            Je.removeEventListener("pointerdown", me),
          (de = r.domElement) == null ||
            de.removeEventListener("pointercancel", ye),
          (He = r.domElement) == null || He.removeEventListener("wheel", Fe),
          (Ce = r.domElement) == null ||
            Ce.ownerDocument.removeEventListener("pointermove", xe),
          (Ue = r.domElement) == null ||
            Ue.ownerDocument.removeEventListener("pointerup", ye),
          r._domElementKeyEvents !== null &&
            r._domElementKeyEvents.removeEventListener("keydown", ze);
      });
    const r = this,
      i = { type: "change" },
      o = { type: "start" },
      s = { type: "end" },
      l = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let u = l.NONE;
    const f = 1e-6,
      h = new j1(),
      m = new j1();
    let g = 1;
    const y = new ie(),
      _ = new tt(),
      S = new tt(),
      x = new tt(),
      w = new tt(),
      T = new tt(),
      E = new tt(),
      A = new tt(),
      R = new tt(),
      D = new tt(),
      I = new ie(),
      U = new tt();
    let O = !1;
    const L = [],
      V = {};
    function H() {
      return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function $() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function q(ce) {
      r.reverseOrbit || r.reverseHorizontalOrbit
        ? (m.theta += ce)
        : (m.theta -= ce);
    }
    function K(ce) {
      r.reverseOrbit || r.reverseVerticalOrbit ? (m.phi += ce) : (m.phi -= ce);
    }
    const Y = (() => {
        const ce = new ie();
        return function (de, He) {
          ce.setFromMatrixColumn(He, 0), ce.multiplyScalar(-de), y.add(ce);
        };
      })(),
      ne = (() => {
        const ce = new ie();
        return function (de, He) {
          r.screenSpacePanning === !0
            ? ce.setFromMatrixColumn(He, 1)
            : (ce.setFromMatrixColumn(He, 0), ce.crossVectors(r.object.up, ce)),
            ce.multiplyScalar(de),
            y.add(ce);
        };
      })(),
      j = (() => {
        const ce = new ie();
        return function (de, He) {
          const Ce = r.domElement;
          if (Ce && r.object instanceof Dr && r.object.isPerspectiveCamera) {
            const Ue = r.object.position;
            ce.copy(Ue).sub(r.target);
            let it = ce.length();
            (it *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              Y((2 * de * it) / Ce.clientHeight, r.object.matrix),
              ne((2 * He * it) / Ce.clientHeight, r.object.matrix);
          } else
            Ce && r.object instanceof Nu && r.object.isOrthographicCamera
              ? (Y(
                  (de * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    Ce.clientWidth,
                  r.object.matrix
                ),
                ne(
                  (He * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    Ce.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function re(ce) {
      (r.object instanceof Dr && r.object.isPerspectiveCamera) ||
      (r.object instanceof Nu && r.object.isOrthographicCamera)
        ? (g = ce)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function B(ce) {
      re(g / ce);
    }
    function G(ce) {
      re(g * ce);
    }
    function te(ce) {
      if (!r.zoomToCursor || !r.domElement) return;
      O = !0;
      const Je = r.domElement.getBoundingClientRect(),
        de = ce.clientX - Je.left,
        He = ce.clientY - Je.top,
        Ce = Je.width,
        Ue = Je.height;
      (U.x = (de / Ce) * 2 - 1),
        (U.y = -(He / Ue) * 2 + 1),
        I.set(U.x, U.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function le(ce) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, ce));
    }
    function J(ce) {
      _.set(ce.clientX, ce.clientY);
    }
    function oe(ce) {
      te(ce), A.set(ce.clientX, ce.clientY);
    }
    function he(ce) {
      w.set(ce.clientX, ce.clientY);
    }
    function ae(ce) {
      S.set(ce.clientX, ce.clientY),
        x.subVectors(S, _).multiplyScalar(r.rotateSpeed);
      const Je = r.domElement;
      Je &&
        (q((2 * Math.PI * x.x) / Je.clientHeight),
        K((2 * Math.PI * x.y) / Je.clientHeight)),
        _.copy(S),
        r.update();
    }
    function ue(ce) {
      R.set(ce.clientX, ce.clientY),
        D.subVectors(R, A),
        D.y > 0 ? B($()) : D.y < 0 && G($()),
        A.copy(R),
        r.update();
    }
    function Ee(ce) {
      T.set(ce.clientX, ce.clientY),
        E.subVectors(T, w).multiplyScalar(r.panSpeed),
        j(E.x, E.y),
        w.copy(T),
        r.update();
    }
    function Ne(ce) {
      te(ce), ce.deltaY < 0 ? G($()) : ce.deltaY > 0 && B($()), r.update();
    }
    function Ae(ce) {
      let Je = !1;
      switch (ce.code) {
        case r.keys.UP:
          j(0, r.keyPanSpeed), (Je = !0);
          break;
        case r.keys.BOTTOM:
          j(0, -r.keyPanSpeed), (Je = !0);
          break;
        case r.keys.LEFT:
          j(r.keyPanSpeed, 0), (Je = !0);
          break;
        case r.keys.RIGHT:
          j(-r.keyPanSpeed, 0), (Je = !0);
          break;
      }
      Je && (ce.preventDefault(), r.update());
    }
    function W() {
      if (L.length == 1) _.set(L[0].pageX, L[0].pageY);
      else {
        const ce = 0.5 * (L[0].pageX + L[1].pageX),
          Je = 0.5 * (L[0].pageY + L[1].pageY);
        _.set(ce, Je);
      }
    }
    function _e() {
      if (L.length == 1) w.set(L[0].pageX, L[0].pageY);
      else {
        const ce = 0.5 * (L[0].pageX + L[1].pageX),
          Je = 0.5 * (L[0].pageY + L[1].pageY);
        w.set(ce, Je);
      }
    }
    function Te() {
      const ce = L[0].pageX - L[1].pageX,
        Je = L[0].pageY - L[1].pageY,
        de = Math.sqrt(ce * ce + Je * Je);
      A.set(0, de);
    }
    function ke() {
      r.enableZoom && Te(), r.enablePan && _e();
    }
    function Pe() {
      r.enableZoom && Te(), r.enableRotate && W();
    }
    function rt(ce) {
      if (L.length == 1) S.set(ce.pageX, ce.pageY);
      else {
        const de = et(ce),
          He = 0.5 * (ce.pageX + de.x),
          Ce = 0.5 * (ce.pageY + de.y);
        S.set(He, Ce);
      }
      x.subVectors(S, _).multiplyScalar(r.rotateSpeed);
      const Je = r.domElement;
      Je &&
        (q((2 * Math.PI * x.x) / Je.clientHeight),
        K((2 * Math.PI * x.y) / Je.clientHeight)),
        _.copy(S);
    }
    function Le(ce) {
      if (L.length == 1) T.set(ce.pageX, ce.pageY);
      else {
        const Je = et(ce),
          de = 0.5 * (ce.pageX + Je.x),
          He = 0.5 * (ce.pageY + Je.y);
        T.set(de, He);
      }
      E.subVectors(T, w).multiplyScalar(r.panSpeed), j(E.x, E.y), w.copy(T);
    }
    function Xe(ce) {
      const Je = et(ce),
        de = ce.pageX - Je.x,
        He = ce.pageY - Je.y,
        Ce = Math.sqrt(de * de + He * He);
      R.set(0, Ce),
        D.set(0, Math.pow(R.y / A.y, r.zoomSpeed)),
        B(D.y),
        A.copy(R);
    }
    function Z(ce) {
      r.enableZoom && Xe(ce), r.enablePan && Le(ce);
    }
    function F(ce) {
      r.enableZoom && Xe(ce), r.enableRotate && rt(ce);
    }
    function me(ce) {
      var Je, de;
      r.enabled !== !1 &&
        (L.length === 0 &&
          ((Je = r.domElement) == null ||
            Je.ownerDocument.addEventListener("pointermove", xe),
          (de = r.domElement) == null ||
            de.ownerDocument.addEventListener("pointerup", ye)),
        yt(ce),
        ce.pointerType === "touch" ? We(ce) : Me(ce));
    }
    function xe(ce) {
      r.enabled !== !1 && (ce.pointerType === "touch" ? Ye(ce) : at(ce));
    }
    function ye(ce) {
      var Je, de, He;
      $e(ce),
        L.length === 0 &&
          ((Je = r.domElement) == null ||
            Je.releasePointerCapture(ce.pointerId),
          (de = r.domElement) == null ||
            de.ownerDocument.removeEventListener("pointermove", xe),
          (He = r.domElement) == null ||
            He.ownerDocument.removeEventListener("pointerup", ye)),
        r.dispatchEvent(s),
        (u = l.NONE);
    }
    function Me(ce) {
      let Je;
      switch (ce.button) {
        case 0:
          Je = r.mouseButtons.LEFT;
          break;
        case 1:
          Je = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Je = r.mouseButtons.RIGHT;
          break;
        default:
          Je = -1;
      }
      switch (Je) {
        case Vc.DOLLY:
          if (r.enableZoom === !1) return;
          oe(ce), (u = l.DOLLY);
          break;
        case Vc.ROTATE:
          if (ce.ctrlKey || ce.metaKey || ce.shiftKey) {
            if (r.enablePan === !1) return;
            he(ce), (u = l.PAN);
          } else {
            if (r.enableRotate === !1) return;
            J(ce), (u = l.ROTATE);
          }
          break;
        case Vc.PAN:
          if (ce.ctrlKey || ce.metaKey || ce.shiftKey) {
            if (r.enableRotate === !1) return;
            J(ce), (u = l.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            he(ce), (u = l.PAN);
          }
          break;
        default:
          u = l.NONE;
      }
      u !== l.NONE && r.dispatchEvent(o);
    }
    function at(ce) {
      if (r.enabled !== !1)
        switch (u) {
          case l.ROTATE:
            if (r.enableRotate === !1) return;
            ae(ce);
            break;
          case l.DOLLY:
            if (r.enableZoom === !1) return;
            ue(ce);
            break;
          case l.PAN:
            if (r.enablePan === !1) return;
            Ee(ce);
            break;
        }
    }
    function Fe(ce) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        (u !== l.NONE && u !== l.ROTATE) ||
        (ce.preventDefault(), r.dispatchEvent(o), Ne(ce), r.dispatchEvent(s));
    }
    function ze(ce) {
      r.enabled === !1 || r.enablePan === !1 || Ae(ce);
    }
    function We(ce) {
      switch ((qe(ce), L.length)) {
        case 1:
          switch (r.touches.ONE) {
            case Hc.ROTATE:
              if (r.enableRotate === !1) return;
              W(), (u = l.TOUCH_ROTATE);
              break;
            case Hc.PAN:
              if (r.enablePan === !1) return;
              _e(), (u = l.TOUCH_PAN);
              break;
            default:
              u = l.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case Hc.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              ke(), (u = l.TOUCH_DOLLY_PAN);
              break;
            case Hc.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              Pe(), (u = l.TOUCH_DOLLY_ROTATE);
              break;
            default:
              u = l.NONE;
          }
          break;
        default:
          u = l.NONE;
      }
      u !== l.NONE && r.dispatchEvent(o);
    }
    function Ye(ce) {
      switch ((qe(ce), u)) {
        case l.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          rt(ce), r.update();
          break;
        case l.TOUCH_PAN:
          if (r.enablePan === !1) return;
          Le(ce), r.update();
          break;
        case l.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          Z(ce), r.update();
          break;
        case l.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          F(ce), r.update();
          break;
        default:
          u = l.NONE;
      }
    }
    function nt(ce) {
      r.enabled !== !1 && ce.preventDefault();
    }
    function yt(ce) {
      L.push(ce);
    }
    function $e(ce) {
      delete V[ce.pointerId];
      for (let Je = 0; Je < L.length; Je++)
        if (L[Je].pointerId == ce.pointerId) {
          L.splice(Je, 1);
          return;
        }
    }
    function qe(ce) {
      let Je = V[ce.pointerId];
      Je === void 0 && ((Je = new tt()), (V[ce.pointerId] = Je)),
        Je.set(ce.pageX, ce.pageY);
    }
    function et(ce) {
      const Je = ce.pointerId === L[0].pointerId ? L[1] : L[0];
      return V[Je.pointerId];
    }
    (this.dollyIn = (ce = $()) => {
      G(ce), r.update();
    }),
      (this.dollyOut = (ce = $()) => {
        B(ce), r.update();
      }),
      (this.getScale = () => g),
      (this.setScale = (ce) => {
        re(ce), r.update();
      }),
      (this.getZoomScale = () => $()),
      t !== void 0 && this.connect(t),
      this.update();
  }
};
function hG() {
  var n = Object.create(null);
  function e(i, o) {
    var s = i.id,
      l = i.name,
      u = i.dependencies;
    u === void 0 && (u = []);
    var f = i.init;
    f === void 0 && (f = function () {});
    var h = i.getTransferables;
    if ((h === void 0 && (h = null), !n[s]))
      try {
        (u = u.map(function (g) {
          return (
            g &&
              g.isWorkerModule &&
              (e(g, function (y) {
                if (y instanceof Error) throw y;
              }),
              (g = n[g.id].value)),
            g
          );
        })),
          (f = r("<" + l + ">.init", f)),
          h && (h = r("<" + l + ">.getTransferables", h));
        var m = null;
        typeof f == "function"
          ? (m = f.apply(void 0, u))
          : console.error("worker module init function failed to rehydrate"),
          (n[s] = { id: s, value: m, getTransferables: h }),
          o(m);
      } catch (g) {
        (g && g.noLog) || console.error(g), o(g);
      }
  }
  function t(i, o) {
    var s,
      l = i.id,
      u = i.args;
    (!n[l] || typeof n[l].value != "function") &&
      o(
        new Error(
          "Worker module " +
            l +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var f = (s = n[l]).value.apply(s, u);
      f && typeof f.then == "function"
        ? f.then(h, function (m) {
            return o(m instanceof Error ? m : new Error("" + m));
          })
        : h(f);
    } catch (m) {
      o(m);
    }
    function h(m) {
      try {
        var g = n[l].getTransferables && n[l].getTransferables(m);
        (!g || !Array.isArray(g) || !g.length) && (g = void 0), o(m, g);
      } catch (y) {
        console.error(y), o(y);
      }
    }
  }
  function r(i, o) {
    var s = void 0;
    self.troikaDefine = function (u) {
      return (s = u);
    };
    var l = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            i.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            o +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(l);
    } catch (u) {
      console.error(u);
    }
    return URL.revokeObjectURL(l), delete self.troikaDefine, s;
  }
  self.addEventListener("message", function (i) {
    var o = i.data,
      s = o.messageId,
      l = o.action,
      u = o.data;
    try {
      l === "registerModule" &&
        e(u, function (f) {
          f instanceof Error
            ? postMessage({ messageId: s, success: !1, error: f.message })
            : postMessage({
                messageId: s,
                success: !0,
                result: { isCallable: typeof f == "function" },
              });
        }),
        l === "callModule" &&
          t(u, function (f, h) {
            f instanceof Error
              ? postMessage({ messageId: s, success: !1, error: f.message })
              : postMessage(
                  { messageId: s, success: !0, result: f },
                  h || void 0
                );
          });
    } catch (f) {
      postMessage({ messageId: s, success: !1, error: f.stack });
    }
  });
}
function pG(n) {
  var e = function () {
    for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
    return e._getInitResult().then(function (i) {
      if (typeof i == "function") return i.apply(void 0, t);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var t = n.dependencies,
        r = n.init;
      t = Array.isArray(t)
        ? t.map(function (o) {
            return o && o._getInitResult ? o._getInitResult() : o;
          })
        : [];
      var i = Promise.all(t).then(function (o) {
        return r.apply(null, o);
      });
      return (
        (e._getInitResult = function () {
          return i;
        }),
        i
      );
    }),
    e
  );
}
var jR = function () {
    var n = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        e.terminate(), (n = !0);
      } catch (t) {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
            t.message +
            "]"
        );
      }
    return (
      (jR = function () {
        return n;
      }),
      n
    );
  },
  mG = 0,
  gG = 0,
  s1 = !1,
  qp = Object.create(null),
  Kp = Object.create(null),
  Y1 = Object.create(null);
function Sh(n) {
  if ((!n || typeof n.init != "function") && !s1)
    throw new Error("requires `options.init` function");
  var e = n.dependencies,
    t = n.init,
    r = n.getTransferables,
    i = n.workerId;
  if (!jR()) return pG(n);
  i == null && (i = "#default");
  var o = "workerModule" + ++mG,
    s = n.name || o,
    l = null;
  e =
    e &&
    e.map(function (f) {
      return (
        typeof f == "function" &&
          !f.workerModuleData &&
          ((s1 = !0),
          (f = Sh({
            workerId: i,
            name: "<" + s + "> function dependency: " + f.name,
            init:
              `function(){return (
` +
              Kv(f) +
              `
)}`,
          })),
          (s1 = !1)),
        f && f.workerModuleData && (f = f.workerModuleData),
        f
      );
    });
  function u() {
    for (var f = [], h = arguments.length; h--; ) f[h] = arguments[h];
    if (!l) {
      l = FT(i, "registerModule", u.workerModuleData);
      var m = function () {
        (l = null), Kp[i].delete(m);
      };
      (Kp[i] || (Kp[i] = new Set())).add(m);
    }
    return l.then(function (g) {
      var y = g.isCallable;
      if (y) return FT(i, "callModule", { id: o, args: f });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (u.workerModuleData = {
      isWorkerModule: !0,
      id: o,
      name: s,
      dependencies: e,
      init: Kv(t),
      getTransferables: r && Kv(r),
    }),
    u
  );
}
function vG(n) {
  Kp[n] &&
    Kp[n].forEach(function (e) {
      e();
    }),
    qp[n] && (qp[n].terminate(), delete qp[n]);
}
function Kv(n) {
  var e = n.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
  );
}
function yG(n) {
  var e = qp[n];
  if (!e) {
    var t = Kv(hG);
    (e = qp[n] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                n.replace(/\*/g, "") +
                ` **/

;(` +
                t +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (e.onmessage = function (r) {
        var i = r.data,
          o = i.messageId,
          s = Y1[o];
        if (!s)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete Y1[o], s(i);
      });
  }
  return e;
}
function FT(n, e, t) {
  return new Promise(function (r, i) {
    var o = ++gG;
    (Y1[o] = function (s) {
      s.success
        ? r(s.result)
        : i(new Error("Error in worker " + e + " call: " + s.error));
    }),
      yG(n).postMessage({ messageId: o, action: e, data: t });
  });
}
function $R() {
  var n = (function (e) {
    function t(re, B, G, te, le, J, oe, he) {
      var ae = 1 - oe;
      (he.x = ae * ae * re + 2 * ae * oe * G + oe * oe * le),
        (he.y = ae * ae * B + 2 * ae * oe * te + oe * oe * J);
    }
    function r(re, B, G, te, le, J, oe, he, ae, ue) {
      var Ee = 1 - ae;
      (ue.x =
        Ee * Ee * Ee * re +
        3 * Ee * Ee * ae * G +
        3 * Ee * ae * ae * le +
        ae * ae * ae * oe),
        (ue.y =
          Ee * Ee * Ee * B +
          3 * Ee * Ee * ae * te +
          3 * Ee * ae * ae * J +
          ae * ae * ae * he);
    }
    function i(re, B) {
      for (
        var G = /([MLQCZ])([^MLQCZ]*)/g, te, le, J, oe, he;
        (te = G.exec(re));

      ) {
        var ae = te[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (ue) {
            return parseFloat(ue);
          });
        switch (te[1]) {
          case "M":
            (oe = le = ae[0]), (he = J = ae[1]);
            break;
          case "L":
            (ae[0] !== oe || ae[1] !== he) &&
              B("L", oe, he, (oe = ae[0]), (he = ae[1]));
            break;
          case "Q": {
            B("Q", oe, he, (oe = ae[2]), (he = ae[3]), ae[0], ae[1]);
            break;
          }
          case "C": {
            B(
              "C",
              oe,
              he,
              (oe = ae[4]),
              (he = ae[5]),
              ae[0],
              ae[1],
              ae[2],
              ae[3]
            );
            break;
          }
          case "Z":
            (oe !== le || he !== J) && B("L", oe, he, le, J);
            break;
        }
      }
    }
    function o(re, B, G) {
      G === void 0 && (G = 16);
      var te = { x: 0, y: 0 };
      i(re, function (le, J, oe, he, ae, ue, Ee, Ne, Ae) {
        switch (le) {
          case "L":
            B(J, oe, he, ae);
            break;
          case "Q": {
            for (var W = J, _e = oe, Te = 1; Te < G; Te++)
              t(J, oe, ue, Ee, he, ae, Te / (G - 1), te),
                B(W, _e, te.x, te.y),
                (W = te.x),
                (_e = te.y);
            break;
          }
          case "C": {
            for (var ke = J, Pe = oe, rt = 1; rt < G; rt++)
              r(J, oe, ue, Ee, Ne, Ae, he, ae, rt / (G - 1), te),
                B(ke, Pe, te.x, te.y),
                (ke = te.x),
                (Pe = te.y);
            break;
          }
        }
      });
    }
    var s =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      l =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      u = new WeakMap(),
      f = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function h(re, B) {
      var G = re.getContext ? re.getContext("webgl", f) : re,
        te = u.get(G);
      if (!te) {
        let ke = function (F) {
            var me = J[F];
            if (!me && ((me = J[F] = G.getExtension(F)), !me))
              throw new Error(F + " not supported");
            return me;
          },
          Pe = function (F, me) {
            var xe = G.createShader(me);
            return G.shaderSource(xe, F), G.compileShader(xe), xe;
          },
          rt = function (F, me, xe, ye) {
            if (!oe[F]) {
              var Me = {},
                at = {},
                Fe = G.createProgram();
              G.attachShader(Fe, Pe(me, G.VERTEX_SHADER)),
                G.attachShader(Fe, Pe(xe, G.FRAGMENT_SHADER)),
                G.linkProgram(Fe),
                (oe[F] = {
                  program: Fe,
                  transaction: function (We) {
                    G.useProgram(Fe),
                      We({
                        setUniform: function (nt, yt) {
                          for (
                            var $e = [], qe = arguments.length - 2;
                            qe-- > 0;

                          )
                            $e[qe] = arguments[qe + 2];
                          var et =
                            at[yt] || (at[yt] = G.getUniformLocation(Fe, yt));
                          G["uniform" + nt].apply(G, [et].concat($e));
                        },
                        setAttribute: function (nt, yt, $e, qe, et) {
                          var ce = Me[nt];
                          ce ||
                            (ce = Me[nt] =
                              {
                                buf: G.createBuffer(),
                                loc: G.getAttribLocation(Fe, nt),
                                data: null,
                              }),
                            G.bindBuffer(G.ARRAY_BUFFER, ce.buf),
                            G.vertexAttribPointer(
                              ce.loc,
                              yt,
                              G.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            G.enableVertexAttribArray(ce.loc),
                            le
                              ? G.vertexAttribDivisor(ce.loc, qe)
                              : ke(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(ce.loc, qe),
                            et !== ce.data &&
                              (G.bufferData(G.ARRAY_BUFFER, et, $e),
                              (ce.data = et));
                        },
                      });
                  },
                });
            }
            oe[F].transaction(ye);
          },
          Le = function (F, me) {
            ae++;
            try {
              G.activeTexture(G.TEXTURE0 + ae);
              var xe = he[F];
              xe ||
                ((xe = he[F] = G.createTexture()),
                G.bindTexture(G.TEXTURE_2D, xe),
                G.texParameteri(G.TEXTURE_2D, G.TEXTURE_MIN_FILTER, G.NEAREST),
                G.texParameteri(G.TEXTURE_2D, G.TEXTURE_MAG_FILTER, G.NEAREST)),
                G.bindTexture(G.TEXTURE_2D, xe),
                me(xe, ae);
            } finally {
              ae--;
            }
          },
          Xe = function (F, me, xe) {
            var ye = G.createFramebuffer();
            ue.push(ye),
              G.bindFramebuffer(G.FRAMEBUFFER, ye),
              G.activeTexture(G.TEXTURE0 + me),
              G.bindTexture(G.TEXTURE_2D, F),
              G.framebufferTexture2D(
                G.FRAMEBUFFER,
                G.COLOR_ATTACHMENT0,
                G.TEXTURE_2D,
                F,
                0
              );
            try {
              xe(ye);
            } finally {
              G.deleteFramebuffer(ye),
                G.bindFramebuffer(G.FRAMEBUFFER, ue[--ue.length - 1] || null);
            }
          },
          Z = function () {
            (J = {}), (oe = {}), (he = {}), (ae = -1), (ue.length = 0);
          };
        var Ee = ke,
          Ne = Pe,
          Ae = rt,
          W = Le,
          _e = Xe,
          Te = Z,
          le =
            typeof WebGL2RenderingContext < "u" &&
            G instanceof WebGL2RenderingContext,
          J = {},
          oe = {},
          he = {},
          ae = -1,
          ue = [];
        G.canvas.addEventListener(
          "webglcontextlost",
          function (F) {
            Z(), F.preventDefault();
          },
          !1
        ),
          u.set(
            G,
            (te = {
              gl: G,
              isWebGL2: le,
              getExtension: ke,
              withProgram: rt,
              withTexture: Le,
              withTextureFramebuffer: Xe,
              handleContextLoss: Z,
            })
          );
      }
      B(te);
    }
    function m(re, B, G, te, le, J, oe, he) {
      oe === void 0 && (oe = 15),
        he === void 0 && (he = null),
        h(re, function (ae) {
          var ue = ae.gl,
            Ee = ae.withProgram,
            Ne = ae.withTexture;
          Ne("copy", function (Ae, W) {
            ue.texImage2D(
              ue.TEXTURE_2D,
              0,
              ue.RGBA,
              le,
              J,
              0,
              ue.RGBA,
              ue.UNSIGNED_BYTE,
              B
            ),
              Ee("copy", s, l, function (_e) {
                var Te = _e.setUniform,
                  ke = _e.setAttribute;
                ke(
                  "aUV",
                  2,
                  ue.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  Te("1i", "image", W),
                  ue.bindFramebuffer(ue.FRAMEBUFFER, he || null),
                  ue.disable(ue.BLEND),
                  ue.colorMask(oe & 8, oe & 4, oe & 2, oe & 1),
                  ue.viewport(G, te, le, J),
                  ue.scissor(G, te, le, J),
                  ue.drawArrays(ue.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function g(re, B, G) {
      var te = re.width,
        le = re.height;
      h(re, function (J) {
        var oe = J.gl,
          he = new Uint8Array(te * le * 4);
        oe.readPixels(0, 0, te, le, oe.RGBA, oe.UNSIGNED_BYTE, he),
          (re.width = B),
          (re.height = G),
          m(oe, he, 0, 0, te, le);
      });
    }
    var y = Object.freeze({
      __proto__: null,
      withWebGLContext: h,
      renderImageData: m,
      resizeWebGLCanvasWithoutClearing: g,
    });
    function _(re, B, G, te, le, J) {
      J === void 0 && (J = 1);
      var oe = new Uint8Array(re * B),
        he = te[2] - te[0],
        ae = te[3] - te[1],
        ue = [];
      o(G, function (ke, Pe, rt, Le) {
        ue.push({
          x1: ke,
          y1: Pe,
          x2: rt,
          y2: Le,
          minX: Math.min(ke, rt),
          minY: Math.min(Pe, Le),
          maxX: Math.max(ke, rt),
          maxY: Math.max(Pe, Le),
        });
      }),
        ue.sort(function (ke, Pe) {
          return ke.maxX - Pe.maxX;
        });
      for (var Ee = 0; Ee < re; Ee++)
        for (var Ne = 0; Ne < B; Ne++) {
          var Ae = _e(
              te[0] + (he * (Ee + 0.5)) / re,
              te[1] + (ae * (Ne + 0.5)) / B
            ),
            W = Math.pow(1 - Math.abs(Ae) / le, J) / 2;
          Ae < 0 && (W = 1 - W),
            (W = Math.max(0, Math.min(255, Math.round(W * 255)))),
            (oe[Ne * re + Ee] = W);
        }
      return oe;
      function _e(ke, Pe) {
        for (var rt = 1 / 0, Le = 1 / 0, Xe = ue.length; Xe--; ) {
          var Z = ue[Xe];
          if (Z.maxX + Le <= ke) break;
          if (ke + Le > Z.minX && Pe - Le < Z.maxY && Pe + Le > Z.minY) {
            var F = w(ke, Pe, Z.x1, Z.y1, Z.x2, Z.y2);
            F < rt && ((rt = F), (Le = Math.sqrt(rt)));
          }
        }
        return Te(ke, Pe) && (Le = -Le), Le;
      }
      function Te(ke, Pe) {
        for (var rt = 0, Le = ue.length; Le--; ) {
          var Xe = ue[Le];
          if (Xe.maxX <= ke) break;
          var Z =
            Xe.y1 > Pe != Xe.y2 > Pe &&
            ke < ((Xe.x2 - Xe.x1) * (Pe - Xe.y1)) / (Xe.y2 - Xe.y1) + Xe.x1;
          Z && (rt += Xe.y1 < Xe.y2 ? 1 : -1);
        }
        return rt !== 0;
      }
    }
    function S(re, B, G, te, le, J, oe, he, ae, ue) {
      J === void 0 && (J = 1),
        he === void 0 && (he = 0),
        ae === void 0 && (ae = 0),
        ue === void 0 && (ue = 0),
        x(re, B, G, te, le, J, oe, null, he, ae, ue);
    }
    function x(re, B, G, te, le, J, oe, he, ae, ue, Ee) {
      J === void 0 && (J = 1),
        ae === void 0 && (ae = 0),
        ue === void 0 && (ue = 0),
        Ee === void 0 && (Ee = 0);
      for (
        var Ne = _(re, B, G, te, le, J),
          Ae = new Uint8Array(Ne.length * 4),
          W = 0;
        W < Ne.length;
        W++
      )
        Ae[W * 4 + Ee] = Ne[W];
      m(oe, Ae, ae, ue, re, B, 1 << (3 - Ee), he);
    }
    function w(re, B, G, te, le, J) {
      var oe = le - G,
        he = J - te,
        ae = oe * oe + he * he,
        ue = ae
          ? Math.max(0, Math.min(1, ((re - G) * oe + (B - te) * he) / ae))
          : 0,
        Ee = re - (G + ue * oe),
        Ne = B - (te + ue * he);
      return Ee * Ee + Ne * Ne;
    }
    var T = Object.freeze({
        __proto__: null,
        generate: _,
        generateIntoCanvas: S,
        generateIntoFramebuffer: x,
      }),
      E =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      A =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      R =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      D = new Float32Array([0, 0, 2, 0, 0, 2]),
      I = null,
      U = !1,
      O = {},
      L = new WeakMap();
    function V(re) {
      if (!U && !K(re)) throw new Error("WebGL generation not supported");
    }
    function H(re, B, G, te, le, J, oe) {
      if (
        (J === void 0 && (J = 1),
        oe === void 0 && (oe = null),
        !oe && ((oe = I), !oe))
      ) {
        var he =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!he) throw new Error("OffscreenCanvas or DOM canvas not supported");
        oe = I = he.getContext("webgl", { depth: !1 });
      }
      V(oe);
      var ae = new Uint8Array(re * B * 4);
      h(oe, function (Ae) {
        var W = Ae.gl,
          _e = Ae.withTexture,
          Te = Ae.withTextureFramebuffer;
        _e("readable", function (ke, Pe) {
          W.texImage2D(
            W.TEXTURE_2D,
            0,
            W.RGBA,
            re,
            B,
            0,
            W.RGBA,
            W.UNSIGNED_BYTE,
            null
          ),
            Te(ke, Pe, function (rt) {
              q(re, B, G, te, le, J, W, rt, 0, 0, 0),
                W.readPixels(0, 0, re, B, W.RGBA, W.UNSIGNED_BYTE, ae);
            });
        });
      });
      for (
        var ue = new Uint8Array(re * B), Ee = 0, Ne = 0;
        Ee < ae.length;
        Ee += 4
      )
        ue[Ne++] = ae[Ee];
      return ue;
    }
    function $(re, B, G, te, le, J, oe, he, ae, ue) {
      J === void 0 && (J = 1),
        he === void 0 && (he = 0),
        ae === void 0 && (ae = 0),
        ue === void 0 && (ue = 0),
        q(re, B, G, te, le, J, oe, null, he, ae, ue);
    }
    function q(re, B, G, te, le, J, oe, he, ae, ue, Ee) {
      J === void 0 && (J = 1),
        ae === void 0 && (ae = 0),
        ue === void 0 && (ue = 0),
        Ee === void 0 && (Ee = 0),
        V(oe);
      var Ne = [];
      o(G, function (Ae, W, _e, Te) {
        Ne.push(Ae, W, _e, Te);
      }),
        (Ne = new Float32Array(Ne)),
        h(oe, function (Ae) {
          var W = Ae.gl,
            _e = Ae.isWebGL2,
            Te = Ae.getExtension,
            ke = Ae.withProgram,
            Pe = Ae.withTexture,
            rt = Ae.withTextureFramebuffer,
            Le = Ae.handleContextLoss;
          if (
            (Pe("rawDistances", function (Xe, Z) {
              (re !== Xe._lastWidth || B !== Xe._lastHeight) &&
                W.texImage2D(
                  W.TEXTURE_2D,
                  0,
                  W.RGBA,
                  (Xe._lastWidth = re),
                  (Xe._lastHeight = B),
                  0,
                  W.RGBA,
                  W.UNSIGNED_BYTE,
                  null
                ),
                ke("main", E, A, function (F) {
                  var me = F.setAttribute,
                    xe = F.setUniform,
                    ye = !_e && Te("ANGLE_instanced_arrays"),
                    Me = !_e && Te("EXT_blend_minmax");
                  me("aUV", 2, W.STATIC_DRAW, 0, D),
                    me("aLineSegment", 4, W.DYNAMIC_DRAW, 1, Ne),
                    xe.apply(void 0, ["4f", "uGlyphBounds"].concat(te)),
                    xe("1f", "uMaxDistance", le),
                    xe("1f", "uExponent", J),
                    rt(Xe, Z, function (at) {
                      W.enable(W.BLEND),
                        W.colorMask(!0, !0, !0, !0),
                        W.viewport(0, 0, re, B),
                        W.scissor(0, 0, re, B),
                        W.blendFunc(W.ONE, W.ONE),
                        W.blendEquationSeparate(
                          W.FUNC_ADD,
                          _e ? W.MAX : Me.MAX_EXT
                        ),
                        W.clear(W.COLOR_BUFFER_BIT),
                        _e
                          ? W.drawArraysInstanced(
                              W.TRIANGLES,
                              0,
                              3,
                              Ne.length / 4
                            )
                          : ye.drawArraysInstancedANGLE(
                              W.TRIANGLES,
                              0,
                              3,
                              Ne.length / 4
                            );
                    });
                }),
                ke("post", s, R, function (F) {
                  F.setAttribute("aUV", 2, W.STATIC_DRAW, 0, D),
                    F.setUniform("1i", "tex", Z),
                    W.bindFramebuffer(W.FRAMEBUFFER, he),
                    W.disable(W.BLEND),
                    W.colorMask(Ee === 0, Ee === 1, Ee === 2, Ee === 3),
                    W.viewport(ae, ue, re, B),
                    W.scissor(ae, ue, re, B),
                    W.drawArrays(W.TRIANGLES, 0, 3);
                });
            }),
            W.isContextLost())
          )
            throw (Le(), new Error("webgl context lost"));
        });
    }
    function K(re) {
      var B = !re || re === I ? O : re.canvas || re,
        G = L.get(B);
      if (G === void 0) {
        U = !0;
        var te = null;
        try {
          var le = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            J = H(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, re);
          (G =
            J &&
            le.length === J.length &&
            J.every(function (oe, he) {
              return oe === le[he];
            })),
            G || ((te = "bad trial run results"), console.info(le, J));
        } catch (oe) {
          (G = !1), (te = oe.message);
        }
        te && console.warn("WebGL SDF generation not supported:", te),
          (U = !1),
          L.set(B, G);
      }
      return G;
    }
    var Y = Object.freeze({
      __proto__: null,
      generate: H,
      generateIntoCanvas: $,
      generateIntoFramebuffer: q,
      isSupported: K,
    });
    function ne(re, B, G, te, le, J) {
      le === void 0 && (le = Math.max(te[2] - te[0], te[3] - te[1]) / 2),
        J === void 0 && (J = 1);
      try {
        return H.apply(Y, arguments);
      } catch (oe) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", oe),
          _.apply(T, arguments)
        );
      }
    }
    function j(re, B, G, te, le, J, oe, he, ae, ue) {
      le === void 0 && (le = Math.max(te[2] - te[0], te[3] - te[1]) / 2),
        J === void 0 && (J = 1),
        he === void 0 && (he = 0),
        ae === void 0 && (ae = 0),
        ue === void 0 && (ue = 0);
      try {
        return $.apply(Y, arguments);
      } catch (Ee) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", Ee),
          S.apply(T, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = i),
      (e.generate = ne),
      (e.generateIntoCanvas = j),
      (e.javascript = T),
      (e.pathToLineSegments = o),
      (e.webgl = Y),
      (e.webglUtils = y),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
function xG() {
  var n = (function (e) {
    var t = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      r = {},
      i = {};
    (r.L = 1),
      (i[1] = "L"),
      Object.keys(t).forEach(function (Le, Xe) {
        (r[Le] = 1 << (Xe + 1)), (i[r[Le]] = Le);
      }),
      Object.freeze(r);
    var o = r.LRI | r.RLI | r.FSI,
      s = r.L | r.R | r.AL,
      l = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI,
      u = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF,
      f = r.S | r.WS | r.B | o | r.PDI | u,
      h = null;
    function m() {
      if (!h) {
        h = new Map();
        var Le = function (Z) {
          if (t.hasOwnProperty(Z)) {
            var F = 0;
            t[Z].split(",").forEach(function (me) {
              var xe = me.split("+"),
                ye = xe[0],
                Me = xe[1];
              (ye = parseInt(ye, 36)),
                (Me = Me ? parseInt(Me, 36) : 0),
                h.set((F += ye), r[Z]);
              for (var at = 0; at < Me; at++) h.set(++F, r[Z]);
            });
          }
        };
        for (var Xe in t) Le(Xe);
      }
    }
    function g(Le) {
      return m(), h.get(Le.codePointAt(0)) || r.L;
    }
    function y(Le) {
      return i[g(Le)];
    }
    var _ = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function S(Le, Xe) {
      var Z = 36,
        F = 0,
        me = new Map(),
        xe = Xe && new Map(),
        ye;
      return (
        Le.split(",").forEach(function Me(at) {
          if (at.indexOf("+") !== -1) for (var Fe = +at; Fe--; ) Me(ye);
          else {
            ye = at;
            var ze = at.split(">"),
              We = ze[0],
              Ye = ze[1];
            (We = String.fromCodePoint((F += parseInt(We, Z)))),
              (Ye = String.fromCodePoint((F += parseInt(Ye, Z)))),
              me.set(We, Ye),
              Xe && xe.set(Ye, We);
          }
        }),
        { map: me, reverseMap: xe }
      );
    }
    var x, w, T;
    function E() {
      if (!x) {
        var Le = S(_.pairs, !0),
          Xe = Le.map,
          Z = Le.reverseMap;
        (x = Xe), (w = Z), (T = S(_.canonical, !1).map);
      }
    }
    function A(Le) {
      return E(), x.get(Le) || null;
    }
    function R(Le) {
      return E(), w.get(Le) || null;
    }
    function D(Le) {
      return E(), T.get(Le) || null;
    }
    var I = r.L,
      U = r.R,
      O = r.EN,
      L = r.ES,
      V = r.ET,
      H = r.AN,
      $ = r.CS,
      q = r.B,
      K = r.S,
      Y = r.ON,
      ne = r.BN,
      j = r.NSM,
      re = r.AL,
      B = r.LRO,
      G = r.RLO,
      te = r.LRE,
      le = r.RLE,
      J = r.PDF,
      oe = r.LRI,
      he = r.RLI,
      ae = r.FSI,
      ue = r.PDI;
    function Ee(Le, Xe) {
      for (
        var Z = 125, F = new Uint32Array(Le.length), me = 0;
        me < Le.length;
        me++
      )
        F[me] = g(Le[me]);
      var xe = new Map();
      function ye(vr, Ar) {
        var sr = F[vr];
        (F[vr] = Ar),
          xe.set(sr, xe.get(sr) - 1),
          sr & l && xe.set(l, xe.get(l) - 1),
          xe.set(Ar, (xe.get(Ar) || 0) + 1),
          Ar & l && xe.set(l, (xe.get(l) || 0) + 1);
      }
      for (
        var Me = new Uint8Array(Le.length),
          at = new Map(),
          Fe = [],
          ze = null,
          We = 0;
        We < Le.length;
        We++
      )
        ze ||
          Fe.push(
            (ze = {
              start: We,
              end: Le.length - 1,
              level: Xe === "rtl" ? 1 : Xe === "ltr" ? 0 : Hr(We, !1),
            })
          ),
          F[We] & q && ((ze.end = We), (ze = null));
      for (
        var Ye = le | te | G | B | o | ue | J | q,
          nt = function (vr) {
            return vr + (vr & 1 ? 1 : 2);
          },
          yt = function (vr) {
            return vr + (vr & 1 ? 2 : 1);
          },
          $e = 0;
        $e < Fe.length;
        $e++
      ) {
        ze = Fe[$e];
        var qe = [{ _level: ze.level, _override: 0, _isolate: 0 }],
          et = void 0,
          ce = 0,
          Je = 0,
          de = 0;
        xe.clear();
        for (var He = ze.start; He <= ze.end; He++) {
          var Ce = F[He];
          if (
            ((et = qe[qe.length - 1]),
            xe.set(Ce, (xe.get(Ce) || 0) + 1),
            Ce & l && xe.set(l, (xe.get(l) || 0) + 1),
            Ce & Ye)
          )
            if (Ce & (le | te)) {
              Me[He] = et._level;
              var Ue = (Ce === le ? yt : nt)(et._level);
              Ue <= Z && !ce && !Je
                ? qe.push({ _level: Ue, _override: 0, _isolate: 0 })
                : ce || Je++;
            } else if (Ce & (G | B)) {
              Me[He] = et._level;
              var it = (Ce === G ? yt : nt)(et._level);
              it <= Z && !ce && !Je
                ? qe.push({
                    _level: it,
                    _override: Ce & G ? U : I,
                    _isolate: 0,
                  })
                : ce || Je++;
            } else if (Ce & o) {
              Ce & ae && (Ce = Hr(He + 1, !0) === 1 ? he : oe),
                (Me[He] = et._level),
                et._override && ye(He, et._override);
              var mt = (Ce === he ? yt : nt)(et._level);
              mt <= Z && ce === 0 && Je === 0
                ? (de++,
                  qe.push({
                    _level: mt,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: He,
                  }))
                : ce++;
            } else if (Ce & ue) {
              if (ce > 0) ce--;
              else if (de > 0) {
                for (Je = 0; !qe[qe.length - 1]._isolate; ) qe.pop();
                var gt = qe[qe.length - 1]._isolInitIndex;
                gt != null && (at.set(gt, He), at.set(He, gt)), qe.pop(), de--;
              }
              (et = qe[qe.length - 1]),
                (Me[He] = et._level),
                et._override && ye(He, et._override);
            } else
              Ce & J
                ? (ce === 0 &&
                    (Je > 0
                      ? Je--
                      : !et._isolate &&
                        qe.length > 1 &&
                        (qe.pop(), (et = qe[qe.length - 1]))),
                  (Me[He] = et._level))
                : Ce & q && (Me[He] = ze.level);
          else
            (Me[He] = et._level),
              et._override && Ce !== ne && ye(He, et._override);
        }
        for (var Ot = [], Nt = null, ht = ze.start; ht <= ze.end; ht++) {
          var jt = F[ht];
          if (!(jt & u)) {
            var an = Me[ht],
              _n = jt & o,
              mn = jt === ue;
            Nt && an === Nt._level
              ? ((Nt._end = ht), (Nt._endsWithIsolInit = _n))
              : Ot.push(
                  (Nt = {
                    _start: ht,
                    _end: ht,
                    _level: an,
                    _startsWithPDI: mn,
                    _endsWithIsolInit: _n,
                  })
                );
          }
        }
        for (var ir = [], Oi = 0; Oi < Ot.length; Oi++) {
          var mr = Ot[Oi];
          if (!mr._startsWithPDI || (mr._startsWithPDI && !at.has(mr._start))) {
            for (
              var Nr = [(Nt = mr)], Er = void 0;
              Nt && Nt._endsWithIsolInit && (Er = at.get(Nt._end)) != null;

            )
              for (var Ur = Oi + 1; Ur < Ot.length; Ur++)
                if (Ot[Ur]._start === Er) {
                  Nr.push((Nt = Ot[Ur]));
                  break;
                }
            for (var gr = [], go = 0; go < Nr.length; go++)
              for (var Fl = Nr[go], eo = Fl._start; eo <= Fl._end; eo++)
                gr.push(eo);
            for (
              var zl = Me[gr[0]], Q = ze.level, be = gr[0] - 1;
              be >= 0;
              be--
            )
              if (!(F[be] & u)) {
                Q = Me[be];
                break;
              }
            var Be = gr[gr.length - 1],
              Ge = Me[Be],
              Ie = ze.level;
            if (!(F[Be] & o)) {
              for (var ut = Be + 1; ut <= ze.end; ut++)
                if (!(F[ut] & u)) {
                  Ie = Me[ut];
                  break;
                }
            }
            ir.push({
              _seqIndices: gr,
              _sosType: Math.max(Q, zl) % 2 ? U : I,
              _eosType: Math.max(Ie, Ge) % 2 ? U : I,
            });
          }
        }
        for (var vt = 0; vt < ir.length; vt++) {
          var Et = ir[vt],
            Ke = Et._seqIndices,
            Dt = Et._sosType,
            Ut = Et._eosType,
            At = Me[Ke[0]] & 1 ? U : I;
          if (xe.get(j))
            for (var tn = 0; tn < Ke.length; tn++) {
              var Tn = Ke[tn];
              if (F[Tn] & j) {
                for (var dn = Dt, Sn = tn - 1; Sn >= 0; Sn--)
                  if (!(F[Ke[Sn]] & u)) {
                    dn = F[Ke[Sn]];
                    break;
                  }
                ye(Tn, dn & (o | ue) ? Y : dn);
              }
            }
          if (xe.get(O))
            for (var wt = 0; wt < Ke.length; wt++) {
              var dt = Ke[wt];
              if (F[dt] & O)
                for (var Zt = wt - 1; Zt >= -1; Zt--) {
                  var Bt = Zt === -1 ? Dt : F[Ke[Zt]];
                  if (Bt & s) {
                    Bt === re && ye(dt, H);
                    break;
                  }
                }
            }
          if (xe.get(re))
            for (var wn = 0; wn < Ke.length; wn++) {
              var ni = Ke[wn];
              F[ni] & re && ye(ni, U);
            }
          if (xe.get(L) || xe.get($))
            for (var Cn = 1; Cn < Ke.length - 1; Cn++) {
              var Bn = Ke[Cn];
              if (F[Bn] & (L | $)) {
                for (
                  var ln = 0, Fr = 0, as = Cn - 1;
                  as >= 0 && ((ln = F[Ke[as]]), !!(ln & u));
                  as--
                );
                for (
                  var or = Cn + 1;
                  or < Ke.length && ((Fr = F[Ke[or]]), !!(Fr & u));
                  or++
                );
                ln === Fr &&
                  (F[Bn] === L ? ln === O : ln & (O | H)) &&
                  ye(Bn, ln);
              }
            }
          if (xe.get(O))
            for (var Tr = 0; Tr < Ke.length; Tr++) {
              var ci = Ke[Tr];
              if (F[ci] & O) {
                for (var Uo = Tr - 1; Uo >= 0 && F[Ke[Uo]] & (V | u); Uo--)
                  ye(Ke[Uo], O);
                for (Tr++; Tr < Ke.length && F[Ke[Tr]] & (V | u | O); Tr++)
                  F[Ke[Tr]] !== O && ye(Ke[Tr], O);
              }
            }
          if (xe.get(V) || xe.get(L) || xe.get($))
            for (var Fo = 0; Fo < Ke.length; Fo++) {
              var vf = Ke[Fo];
              if (F[vf] & (V | L | $)) {
                ye(vf, Y);
                for (var zo = Fo - 1; zo >= 0 && F[Ke[zo]] & u; zo--)
                  ye(Ke[zo], Y);
                for (var sn = Fo + 1; sn < Ke.length && F[Ke[sn]] & u; sn++)
                  ye(Ke[sn], Y);
              }
            }
          if (xe.get(O))
            for (var ls = 0, fa = Dt; ls < Ke.length; ls++) {
              var Bl = Ke[ls],
                Vl = F[Bl];
              Vl & O ? fa === I && ye(Bl, I) : Vl & s && (fa = Vl);
            }
          if (xe.get(l)) {
            var us = U | O | H,
              $a = us | I,
              vo = [];
            {
              for (var Bo = [], ri = 0; ri < Ke.length; ri++)
                if (F[Ke[ri]] & l) {
                  var $t = Le[Ke[ri]],
                    yo = void 0;
                  if (A($t) !== null)
                    if (Bo.length < 63) Bo.push({ char: $t, seqIndex: ri });
                    else break;
                  else if ((yo = R($t)) !== null)
                    for (var to = Bo.length - 1; to >= 0; to--) {
                      var cs = Bo[to].char;
                      if (cs === yo || cs === R(D($t)) || A(D(cs)) === $t) {
                        vo.push([Bo[to].seqIndex, ri]), (Bo.length = to);
                        break;
                      }
                    }
                }
              vo.sort(function (vr, Ar) {
                return vr[0] - Ar[0];
              });
            }
            for (var xo = 0; xo < vo.length; xo++) {
              for (
                var yf = vo[xo],
                  Gn = yf[0],
                  Vo = yf[1],
                  xf = !1,
                  fi = 0,
                  da = Gn + 1;
                da < Vo;
                da++
              ) {
                var ha = Ke[da];
                if (F[ha] & $a) {
                  xf = !0;
                  var no = F[ha] & us ? U : I;
                  if (no === At) {
                    fi = no;
                    break;
                  }
                }
              }
              if (xf && !fi) {
                fi = Dt;
                for (var Ps = Gn - 1; Ps >= 0; Ps--) {
                  var pa = Ke[Ps];
                  if (F[pa] & $a) {
                    var zr = F[pa] & us ? U : I;
                    zr !== At ? (fi = zr) : (fi = At);
                    break;
                  }
                }
              }
              if (fi) {
                if (((F[Ke[Gn]] = F[Ke[Vo]] = fi), fi !== At)) {
                  for (var Br = Gn + 1; Br < Ke.length; Br++)
                    if (!(F[Ke[Br]] & u)) {
                      g(Le[Ke[Br]]) & j && (F[Ke[Br]] = fi);
                      break;
                    }
                }
                if (fi !== At) {
                  for (var fs = Vo + 1; fs < Ke.length; fs++)
                    if (!(F[Ke[fs]] & u)) {
                      g(Le[Ke[fs]]) & j && (F[Ke[fs]] = fi);
                      break;
                    }
                }
              }
            }
            for (var _o = 0; _o < Ke.length; _o++)
              if (F[Ke[_o]] & l) {
                for (var Xa = _o, ma = _o, di = Dt, ga = _o - 1; ga >= 0; ga--)
                  if (F[Ke[ga]] & u) Xa = ga;
                  else {
                    di = F[Ke[ga]] & us ? U : I;
                    break;
                  }
                for (var Ni = Ut, Is = _o + 1; Is < Ke.length; Is++)
                  if (F[Ke[Is]] & (l | u)) ma = Is;
                  else {
                    Ni = F[Ke[Is]] & us ? U : I;
                    break;
                  }
                for (var Vr = Xa; Vr <= ma; Vr++)
                  F[Ke[Vr]] = di === Ni ? di : At;
                _o = ma;
              }
          }
        }
        for (var Cr = ze.start; Cr <= ze.end; Cr++) {
          var Ls = Me[Cr],
            Ui = F[Cr];
          if (
            (Ls & 1
              ? Ui & (I | O | H) && Me[Cr]++
              : Ui & U
              ? Me[Cr]++
              : Ui & (H | O) && (Me[Cr] += 2),
            Ui & u && (Me[Cr] = Cr === 0 ? ze.level : Me[Cr - 1]),
            Cr === ze.end || g(Le[Cr]) & (K | q))
          )
            for (var Ds = Cr; Ds >= 0 && g(Le[Ds]) & f; Ds--) Me[Ds] = ze.level;
        }
      }
      return { levels: Me, paragraphs: Fe };
      function Hr(vr, Ar) {
        for (var sr = vr; sr < Le.length; sr++) {
          var Yn = F[sr];
          if (Yn & (U | re)) return 1;
          if (Yn & (q | I) || (Ar && Yn === ue)) return 0;
          if (Yn & o) {
            var _i = ks(sr);
            sr = _i === -1 ? Le.length : _i;
          }
        }
        return 0;
      }
      function ks(vr) {
        for (var Ar = 1, sr = vr + 1; sr < Le.length; sr++) {
          var Yn = F[sr];
          if (Yn & q) break;
          if (Yn & ue) {
            if (--Ar === 0) return sr;
          } else Yn & o && Ar++;
        }
        return -1;
      }
    }
    var Ne =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      Ae;
    function W() {
      if (!Ae) {
        var Le = S(Ne, !0),
          Xe = Le.map,
          Z = Le.reverseMap;
        Z.forEach(function (F, me) {
          Xe.set(me, F);
        }),
          (Ae = Xe);
      }
    }
    function _e(Le) {
      return W(), Ae.get(Le) || null;
    }
    function Te(Le, Xe, Z, F) {
      var me = Le.length;
      (Z = Math.max(0, Z == null ? 0 : +Z)),
        (F = Math.min(me - 1, F == null ? me - 1 : +F));
      for (var xe = new Map(), ye = Z; ye <= F; ye++)
        if (Xe[ye] & 1) {
          var Me = _e(Le[ye]);
          Me !== null && xe.set(ye, Me);
        }
      return xe;
    }
    function ke(Le, Xe, Z, F) {
      var me = Le.length;
      (Z = Math.max(0, Z == null ? 0 : +Z)),
        (F = Math.min(me - 1, F == null ? me - 1 : +F));
      var xe = [];
      return (
        Xe.paragraphs.forEach(function (ye) {
          var Me = Math.max(Z, ye.start),
            at = Math.min(F, ye.end);
          if (Me < at) {
            for (
              var Fe = Xe.levels.slice(Me, at + 1), ze = at;
              ze >= Me && g(Le[ze]) & f;
              ze--
            )
              Fe[ze] = ye.level;
            for (var We = ye.level, Ye = 1 / 0, nt = 0; nt < Fe.length; nt++) {
              var yt = Fe[nt];
              yt > We && (We = yt), yt < Ye && (Ye = yt | 1);
            }
            for (var $e = We; $e >= Ye; $e--)
              for (var qe = 0; qe < Fe.length; qe++)
                if (Fe[qe] >= $e) {
                  for (var et = qe; qe + 1 < Fe.length && Fe[qe + 1] >= $e; )
                    qe++;
                  qe > et && xe.push([et + Me, qe + Me]);
                }
          }
        }),
        xe
      );
    }
    function Pe(Le, Xe, Z, F) {
      var me = rt(Le, Xe, Z, F),
        xe = [].concat(Le);
      return (
        me.forEach(function (ye, Me) {
          xe[Me] = (Xe.levels[ye] & 1 ? _e(Le[ye]) : null) || Le[ye];
        }),
        xe.join("")
      );
    }
    function rt(Le, Xe, Z, F) {
      for (var me = ke(Le, Xe, Z, F), xe = [], ye = 0; ye < Le.length; ye++)
        xe[ye] = ye;
      return (
        me.forEach(function (Me) {
          for (
            var at = Me[0],
              Fe = Me[1],
              ze = xe.slice(at, Fe + 1),
              We = ze.length;
            We--;

          )
            xe[Fe - We] = ze[We];
        }),
        xe
      );
    }
    return (
      (e.closingToOpeningBracket = R),
      (e.getBidiCharType = g),
      (e.getBidiCharTypeName = y),
      (e.getCanonicalBracket = D),
      (e.getEmbeddingLevels = Ee),
      (e.getMirroredCharacter = _e),
      (e.getMirroredCharactersMap = Te),
      (e.getReorderSegments = ke),
      (e.getReorderedIndices = rt),
      (e.getReorderedString = Pe),
      (e.openingToClosingBracket = A),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
const XR = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function q1(n) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, i) {
    let o = rn[i];
    return o ? q1(o) : r;
  }
  return n.replace(e, t);
}
const Ii = [];
for (let n = 0; n < 256; n++) Ii[n] = (n < 16 ? "0" : "") + n.toString(16);
function _G() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Ii[n & 255] +
    Ii[(n >> 8) & 255] +
    Ii[(n >> 16) & 255] +
    Ii[(n >> 24) & 255] +
    "-" +
    Ii[e & 255] +
    Ii[(e >> 8) & 255] +
    "-" +
    Ii[((e >> 16) & 15) | 64] +
    Ii[(e >> 24) & 255] +
    "-" +
    Ii[(t & 63) | 128] +
    Ii[(t >> 8) & 255] +
    "-" +
    Ii[(t >> 16) & 255] +
    Ii[(t >> 24) & 255] +
    Ii[r & 255] +
    Ii[(r >> 8) & 255] +
    Ii[(r >> 16) & 255] +
    Ii[(r >> 24) & 255]
  ).toUpperCase();
}
const Uc =
    Object.assign ||
    function () {
      let n = arguments[0];
      for (let e = 1, t = arguments.length; e < t; e++) {
        let r = arguments[e];
        if (r)
          for (let i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }
      return n;
    },
  SG = Date.now(),
  zT = new WeakMap(),
  BT = new Map();
let wG = 1e10;
function K1(n, e) {
  const t = TG(e);
  let r = zT.get(n);
  if ((r || zT.set(n, (r = Object.create(null))), r[t])) return new r[t]();
  const i = `_onBeforeCompile${t}`,
    o = function (f, h) {
      n.onBeforeCompile.call(this, f, h);
      const m =
        this.customProgramCacheKey() +
        "|" +
        f.vertexShader +
        "|" +
        f.fragmentShader;
      let g = BT[m];
      if (!g) {
        const y = MG(this, f, e, t);
        g = BT[m] = y;
      }
      (f.vertexShader = g.vertexShader),
        (f.fragmentShader = g.fragmentShader),
        Uc(f.uniforms, this.uniforms),
        e.timeUniform &&
          (f.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - SG;
            },
          }),
        this[i] && this[i](f);
    },
    s = function () {
      return l(e.chained ? n : n.clone());
    },
    l = function (f) {
      const h = Object.create(f, u);
      return (
        Object.defineProperty(h, "baseMaterial", { value: n }),
        Object.defineProperty(h, "id", { value: wG++ }),
        (h.uuid = _G()),
        (h.uniforms = Uc({}, f.uniforms, e.uniforms)),
        (h.defines = Uc({}, f.defines, e.defines)),
        (h.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = ""),
        (h.extensions = Uc({}, f.extensions, e.extensions)),
        (h._listeners = void 0),
        h
      );
    },
    u = {
      constructor: { value: s },
      isDerivedMaterial: { value: !0 },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return n.customProgramCacheKey() + "|" + t;
        },
      },
      onBeforeCompile: {
        get() {
          return o;
        },
        set(f) {
          this[i] = f;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (f) {
          return (
            n.copy.call(this, f),
            !n.isShaderMaterial &&
              !n.isDerivedMaterial &&
              (Uc(this.extensions, f.extensions),
              Uc(this.defines, f.defines),
              Uc(this.uniforms, $S.clone(f.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const f = new n.constructor();
          return l(f).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let f = this._depthMaterial;
          return (
            f ||
              ((f = this._depthMaterial =
                K1(
                  n.isDerivedMaterial
                    ? n.getDepthMaterial()
                    : new by({ depthPacking: BS }),
                  e
                )),
              (f.defines.IS_DEPTH_MATERIAL = ""),
              (f.uniforms = this.uniforms)),
            f
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let f = this._distanceMaterial;
          return (
            f ||
              ((f = this._distanceMaterial =
                K1(
                  n.isDerivedMaterial ? n.getDistanceMaterial() : new Ey(),
                  e
                )),
              (f.defines.IS_DISTANCE_MATERIAL = ""),
              (f.uniforms = this.uniforms)),
            f
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: f, _distanceMaterial: h } = this;
          f && f.dispose(), h && h.dispose(), n.dispose.call(this);
        },
      },
    };
  return (r[t] = s), new s();
}
function MG(n, { vertexShader: e, fragmentShader: t }, r, i) {
  let {
    vertexDefs: o,
    vertexMainIntro: s,
    vertexMainOutro: l,
    vertexTransform: u,
    fragmentDefs: f,
    fragmentMainIntro: h,
    fragmentMainOutro: m,
    fragmentColorTransform: g,
    customRewriter: y,
    timeUniform: _,
  } = r;
  if (
    ((o = o || ""),
    (s = s || ""),
    (l = l || ""),
    (f = f || ""),
    (h = h || ""),
    (m = m || ""),
    (u || y) && (e = q1(e)),
    (g || y) &&
      ((t = t.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (t = q1(t))),
    y)
  ) {
    let S = y({ vertexShader: e, fragmentShader: t });
    (e = S.vertexShader), (t = S.fragmentShader);
  }
  if (g) {
    let S = [];
    (t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (x) => (S.push(x), "")
    )),
      (m = `${g}
${S.join(`
`)}
${m}`);
  }
  if (_) {
    const S = `
uniform float ${_};
`;
    (o = S + o), (f = S + f);
  }
  return (
    u &&
      ((e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`),
      (o = `${o}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u}
}
`),
      (s = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${s}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (S, x, w, T) =>
        /\battribute\s+vec[23]\s+$/.test(T.substr(0, w))
          ? x
          : `troika_${x}_${i}`
      )),
      (n.map && n.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    (e = VT(e, i, o, s, l)),
    (t = VT(t, i, f, h, m)),
    { vertexShader: e, fragmentShader: t }
  );
}
function VT(n, e, t, r, i) {
  return (
    (r || i || t) &&
      ((n = n.replace(
        XR,
        `
${t}
void troikaOrigMain${e}() {`
      )),
      (n += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`)),
    n
  );
}
function bG(n, e) {
  return n === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let EG = 0;
const HT = new Map();
function TG(n) {
  const e = JSON.stringify(n, bG);
  let t = HT.get(e);
  return t == null && HT.set(e, (t = ++EG)), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function CG() {
  return (
    typeof window > "u" && (self.window = self),
    (function (n) {
      var e = {
        parse: function (i) {
          var o = e._bin,
            s = new Uint8Array(i);
          if (o.readASCII(s, 0, 4) == "ttcf") {
            var l = 4;
            o.readUshort(s, l), (l += 2), o.readUshort(s, l), (l += 2);
            var u = o.readUint(s, l);
            l += 4;
            for (var f = [], h = 0; h < u; h++) {
              var m = o.readUint(s, l);
              (l += 4), f.push(e._readFont(s, m));
            }
            return f;
          }
          return [e._readFont(s, 0)];
        },
        _readFont: function (i, o) {
          var s = e._bin,
            l = o;
          s.readFixed(i, o), (o += 4);
          var u = s.readUshort(i, o);
          (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2);
          for (
            var f = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              h = { _data: i, _offset: l },
              m = {},
              g = 0;
            g < u;
            g++
          ) {
            var y = s.readASCII(i, o, 4);
            (o += 4), s.readUint(i, o), (o += 4);
            var _ = s.readUint(i, o);
            o += 4;
            var S = s.readUint(i, o);
            (o += 4), (m[y] = { offset: _, length: S });
          }
          for (g = 0; g < f.length; g++) {
            var x = f[g];
            m[x] &&
              (h[x.trim()] = e[x.trim()].parse(i, m[x].offset, m[x].length, h));
          }
          return h;
        },
        _tabOffset: function (i, o, s) {
          for (
            var l = e._bin, u = l.readUshort(i, s + 4), f = s + 12, h = 0;
            h < u;
            h++
          ) {
            var m = l.readASCII(i, f, 4);
            (f += 4), l.readUint(i, f), (f += 4);
            var g = l.readUint(i, f);
            if (((f += 4), l.readUint(i, f), (f += 4), m == o)) return g;
          }
          return 0;
        },
      };
      (e._bin = {
        readFixed: function (i, o) {
          return (
            ((i[o] << 8) | i[o + 1]) + ((i[o + 2] << 8) | i[o + 3]) / 65540
          );
        },
        readF2dot14: function (i, o) {
          return e._bin.readShort(i, o) / 16384;
        },
        readInt: function (i, o) {
          return e._bin._view(i).getInt32(o);
        },
        readInt8: function (i, o) {
          return e._bin._view(i).getInt8(o);
        },
        readShort: function (i, o) {
          return e._bin._view(i).getInt16(o);
        },
        readUshort: function (i, o) {
          return e._bin._view(i).getUint16(o);
        },
        readUshorts: function (i, o, s) {
          for (var l = [], u = 0; u < s; u++)
            l.push(e._bin.readUshort(i, o + 2 * u));
          return l;
        },
        readUint: function (i, o) {
          return e._bin._view(i).getUint32(o);
        },
        readUint64: function (i, o) {
          return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4);
        },
        readASCII: function (i, o, s) {
          for (var l = "", u = 0; u < s; u++)
            l += String.fromCharCode(i[o + u]);
          return l;
        },
        readUnicode: function (i, o, s) {
          for (var l = "", u = 0; u < s; u++) {
            var f = (i[o++] << 8) | i[o++];
            l += String.fromCharCode(f);
          }
          return l;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (i, o, s) {
          var l = e._bin._tdec;
          return l && o == 0 && s == i.length
            ? l.decode(i)
            : e._bin.readASCII(i, o, s);
        },
        readBytes: function (i, o, s) {
          for (var l = [], u = 0; u < s; u++) l.push(i[o + u]);
          return l;
        },
        readASCIIArray: function (i, o, s) {
          for (var l = [], u = 0; u < s; u++)
            l.push(String.fromCharCode(i[o + u]));
          return l;
        },
        _view: function (i) {
          return (
            i._dataView ||
            (i._dataView = i.buffer
              ? new DataView(i.buffer, i.byteOffset, i.byteLength)
              : new DataView(new Uint8Array(i).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (i, o, s, l, u) {
          var f = e._bin,
            h = {},
            m = o;
          f.readFixed(i, o), (o += 4);
          var g = f.readUshort(i, o);
          o += 2;
          var y = f.readUshort(i, o);
          o += 2;
          var _ = f.readUshort(i, o);
          return (
            (o += 2),
            (h.scriptList = e._lctf.readScriptList(i, m + g)),
            (h.featureList = e._lctf.readFeatureList(i, m + y)),
            (h.lookupList = e._lctf.readLookupList(i, m + _, u)),
            h
          );
        }),
        (e._lctf.readLookupList = function (i, o, s) {
          var l = e._bin,
            u = o,
            f = [],
            h = l.readUshort(i, o);
          o += 2;
          for (var m = 0; m < h; m++) {
            var g = l.readUshort(i, o);
            o += 2;
            var y = e._lctf.readLookupTable(i, u + g, s);
            f.push(y);
          }
          return f;
        }),
        (e._lctf.readLookupTable = function (i, o, s) {
          var l = e._bin,
            u = o,
            f = { tabs: [] };
          (f.ltype = l.readUshort(i, o)),
            (o += 2),
            (f.flag = l.readUshort(i, o)),
            (o += 2);
          var h = l.readUshort(i, o);
          o += 2;
          for (var m = f.ltype, g = 0; g < h; g++) {
            var y = l.readUshort(i, o);
            o += 2;
            var _ = s(i, m, u + y, f);
            f.tabs.push(_);
          }
          return f;
        }),
        (e._lctf.numOfOnes = function (i) {
          for (var o = 0, s = 0; s < 32; s++) ((i >>> s) & 1) != 0 && o++;
          return o;
        }),
        (e._lctf.readClassDef = function (i, o) {
          var s = e._bin,
            l = [],
            u = s.readUshort(i, o);
          if (((o += 2), u == 1)) {
            var f = s.readUshort(i, o);
            o += 2;
            var h = s.readUshort(i, o);
            o += 2;
            for (var m = 0; m < h; m++)
              l.push(f + m),
                l.push(f + m),
                l.push(s.readUshort(i, o)),
                (o += 2);
          }
          if (u == 2) {
            var g = s.readUshort(i, o);
            for (o += 2, m = 0; m < g; m++)
              l.push(s.readUshort(i, o)),
                (o += 2),
                l.push(s.readUshort(i, o)),
                (o += 2),
                l.push(s.readUshort(i, o)),
                (o += 2);
          }
          return l;
        }),
        (e._lctf.getInterval = function (i, o) {
          for (var s = 0; s < i.length; s += 3) {
            var l = i[s],
              u = i[s + 1];
            if ((i[s + 2], l <= o && o <= u)) return s;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (i, o) {
          var s = e._bin,
            l = {};
          (l.fmt = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          return (
            (o += 2),
            l.fmt == 1 && (l.tab = s.readUshorts(i, o, u)),
            l.fmt == 2 && (l.tab = s.readUshorts(i, o, 3 * u)),
            l
          );
        }),
        (e._lctf.coverageIndex = function (i, o) {
          var s = i.tab;
          if (i.fmt == 1) return s.indexOf(o);
          if (i.fmt == 2) {
            var l = e._lctf.getInterval(s, o);
            if (l != -1) return s[l + 2] + (o - s[l]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (i, o) {
          var s = e._bin,
            l = o,
            u = [],
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readASCII(i, o, 4);
            o += 4;
            var g = s.readUshort(i, o);
            o += 2;
            var y = e._lctf.readFeatureTable(i, l + g);
            (y.tag = m.trim()), u.push(y);
          }
          return u;
        }),
        (e._lctf.readFeatureTable = function (i, o) {
          var s = e._bin,
            l = o,
            u = {},
            f = s.readUshort(i, o);
          (o += 2), f > 0 && (u.featureParams = l + f);
          var h = s.readUshort(i, o);
          (o += 2), (u.tab = []);
          for (var m = 0; m < h; m++) u.tab.push(s.readUshort(i, o + 2 * m));
          return u;
        }),
        (e._lctf.readScriptList = function (i, o) {
          var s = e._bin,
            l = o,
            u = {},
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readASCII(i, o, 4);
            o += 4;
            var g = s.readUshort(i, o);
            (o += 2), (u[m.trim()] = e._lctf.readScriptTable(i, l + g));
          }
          return u;
        }),
        (e._lctf.readScriptTable = function (i, o) {
          var s = e._bin,
            l = o,
            u = {},
            f = s.readUshort(i, o);
          (o += 2), f > 0 && (u.default = e._lctf.readLangSysTable(i, l + f));
          var h = s.readUshort(i, o);
          o += 2;
          for (var m = 0; m < h; m++) {
            var g = s.readASCII(i, o, 4);
            o += 4;
            var y = s.readUshort(i, o);
            (o += 2), (u[g.trim()] = e._lctf.readLangSysTable(i, l + y));
          }
          return u;
        }),
        (e._lctf.readLangSysTable = function (i, o) {
          var s = e._bin,
            l = {};
          s.readUshort(i, o),
            (o += 2),
            (l.reqFeature = s.readUshort(i, o)),
            (o += 2);
          var u = s.readUshort(i, o);
          return (o += 2), (l.features = s.readUshorts(i, o, u)), l;
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (i, o, s) {
          var l = e._bin;
          (i = new Uint8Array(i.buffer, o, s))[(o = 0)],
            i[++o],
            i[++o],
            i[++o],
            o++;
          var u = [];
          o = e.CFF.readIndex(i, o, u);
          for (var f = [], h = 0; h < u.length - 1; h++)
            f.push(l.readASCII(i, o + u[h], u[h + 1] - u[h]));
          o += u[u.length - 1];
          var m = [];
          o = e.CFF.readIndex(i, o, m);
          var g = [];
          for (h = 0; h < m.length - 1; h++)
            g.push(e.CFF.readDict(i, o + m[h], o + m[h + 1]));
          o += m[m.length - 1];
          var y = g[0],
            _ = [];
          o = e.CFF.readIndex(i, o, _);
          var S = [];
          for (h = 0; h < _.length - 1; h++)
            S.push(l.readASCII(i, o + _[h], _[h + 1] - _[h]));
          if (
            ((o += _[_.length - 1]), e.CFF.readSubrs(i, o, y), y.CharStrings)
          ) {
            (o = y.CharStrings), (_ = []), (o = e.CFF.readIndex(i, o, _));
            var x = [];
            for (h = 0; h < _.length - 1; h++)
              x.push(l.readBytes(i, o + _[h], _[h + 1] - _[h]));
            y.CharStrings = x;
          }
          if (y.ROS) {
            o = y.FDArray;
            var w = [];
            for (
              o = e.CFF.readIndex(i, o, w), y.FDArray = [], h = 0;
              h < w.length - 1;
              h++
            ) {
              var T = e.CFF.readDict(i, o + w[h], o + w[h + 1]);
              e.CFF._readFDict(i, T, S), y.FDArray.push(T);
            }
            (o += w[w.length - 1]), (o = y.FDSelect), (y.FDSelect = []);
            var E = i[o];
            if ((o++, E != 3)) throw E;
            var A = l.readUshort(i, o);
            for (o += 2, h = 0; h < A + 1; h++)
              y.FDSelect.push(l.readUshort(i, o), i[o + 2]), (o += 3);
          }
          return (
            y.Encoding &&
              (y.Encoding = e.CFF.readEncoding(
                i,
                y.Encoding,
                y.CharStrings.length
              )),
            y.charset &&
              (y.charset = e.CFF.readCharset(
                i,
                y.charset,
                y.CharStrings.length
              )),
            e.CFF._readFDict(i, y, S),
            y
          );
        }),
        (e.CFF._readFDict = function (i, o, s) {
          var l;
          for (var u in (o.Private &&
            ((l = o.Private[1]),
            (o.Private = e.CFF.readDict(i, l, l + o.Private[0])),
            o.Private.Subrs &&
              e.CFF.readSubrs(i, l + o.Private.Subrs, o.Private)),
          o))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(u) != -1 && (o[u] = s[o[u] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (i, o, s) {
          var l = e._bin,
            u = [];
          o = e.CFF.readIndex(i, o, u);
          var f,
            h = u.length;
          (f = h < 1240 ? 107 : h < 33900 ? 1131 : 32768),
            (s.Bias = f),
            (s.Subrs = []);
          for (var m = 0; m < u.length - 1; m++)
            s.Subrs.push(l.readBytes(i, o + u[m], u[m + 1] - u[m]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (i, o) {
          for (var s = 0; s < i.charset.length; s++)
            if (i.charset[s] == o) return s;
          return -1;
        }),
        (e.CFF.glyphBySE = function (i, o) {
          return o < 0 || o > 255
            ? -1
            : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]);
        }),
        (e.CFF.readEncoding = function (i, o, s) {
          e._bin;
          var l = [".notdef"],
            u = i[o];
          if ((o++, u != 0)) throw "error: unknown encoding format: " + u;
          var f = i[o];
          o++;
          for (var h = 0; h < f; h++) l.push(i[o + h]);
          return l;
        }),
        (e.CFF.readCharset = function (i, o, s) {
          var l = e._bin,
            u = [".notdef"],
            f = i[o];
          if ((o++, f == 0))
            for (var h = 0; h < s; h++) {
              var m = l.readUshort(i, o);
              (o += 2), u.push(m);
            }
          else {
            if (f != 1 && f != 2) throw "error: format: " + f;
            for (; u.length < s; ) {
              (m = l.readUshort(i, o)), (o += 2);
              var g = 0;
              for (
                f == 1
                  ? ((g = i[o]), o++)
                  : ((g = l.readUshort(i, o)), (o += 2)),
                  h = 0;
                h <= g;
                h++
              )
                u.push(m), m++;
            }
          }
          return u;
        }),
        (e.CFF.readIndex = function (i, o, s) {
          var l = e._bin,
            u = l.readUshort(i, o) + 1,
            f = i[(o += 2)];
          if ((o++, f == 1)) for (var h = 0; h < u; h++) s.push(i[o + h]);
          else if (f == 2)
            for (h = 0; h < u; h++) s.push(l.readUshort(i, o + 2 * h));
          else if (f == 3)
            for (h = 0; h < u; h++)
              s.push(16777215 & l.readUint(i, o + 3 * h - 1));
          else if (u != 1)
            throw "unsupported offset size: " + f + ", count: " + u;
          return (o += u * f) - 1;
        }),
        (e.CFF.getCharString = function (i, o, s) {
          var l = e._bin,
            u = i[o],
            f = i[o + 1];
          i[o + 2], i[o + 3], i[o + 4];
          var h = 1,
            m = null,
            g = null;
          u <= 20 && ((m = u), (h = 1)),
            u == 12 && ((m = 100 * u + f), (h = 2)),
            21 <= u && u <= 27 && ((m = u), (h = 1)),
            u == 28 && ((g = l.readShort(i, o + 1)), (h = 3)),
            29 <= u && u <= 31 && ((m = u), (h = 1)),
            32 <= u && u <= 246 && ((g = u - 139), (h = 1)),
            247 <= u && u <= 250 && ((g = 256 * (u - 247) + f + 108), (h = 2)),
            251 <= u && u <= 254 && ((g = 256 * -(u - 251) - f - 108), (h = 2)),
            u == 255 && ((g = l.readInt(i, o + 1) / 65535), (h = 5)),
            (s.val = g ?? "o" + m),
            (s.size = h);
        }),
        (e.CFF.readCharString = function (i, o, s) {
          for (var l = o + s, u = e._bin, f = []; o < l; ) {
            var h = i[o],
              m = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var g = 1,
              y = null,
              _ = null;
            h <= 20 && ((y = h), (g = 1)),
              h == 12 && ((y = 100 * h + m), (g = 2)),
              (h != 19 && h != 20) || ((y = h), (g = 2)),
              21 <= h && h <= 27 && ((y = h), (g = 1)),
              h == 28 && ((_ = u.readShort(i, o + 1)), (g = 3)),
              29 <= h && h <= 31 && ((y = h), (g = 1)),
              32 <= h && h <= 246 && ((_ = h - 139), (g = 1)),
              247 <= h &&
                h <= 250 &&
                ((_ = 256 * (h - 247) + m + 108), (g = 2)),
              251 <= h &&
                h <= 254 &&
                ((_ = 256 * -(h - 251) - m - 108), (g = 2)),
              h == 255 && ((_ = u.readInt(i, o + 1) / 65535), (g = 5)),
              f.push(_ ?? "o" + y),
              (o += g);
          }
          return f;
        }),
        (e.CFF.readDict = function (i, o, s) {
          for (var l = e._bin, u = {}, f = []; o < s; ) {
            var h = i[o],
              m = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var g = 1,
              y = null,
              _ = null;
            if (
              (h == 28 && ((_ = l.readShort(i, o + 1)), (g = 3)),
              h == 29 && ((_ = l.readInt(i, o + 1)), (g = 5)),
              32 <= h && h <= 246 && ((_ = h - 139), (g = 1)),
              247 <= h &&
                h <= 250 &&
                ((_ = 256 * (h - 247) + m + 108), (g = 2)),
              251 <= h &&
                h <= 254 &&
                ((_ = 256 * -(h - 251) - m - 108), (g = 2)),
              h == 255)
            )
              throw (
                ((_ = l.readInt(i, o + 1) / 65535), (g = 5), "unknown number")
              );
            if (h == 30) {
              var S = [];
              for (g = 1; ; ) {
                var x = i[o + g];
                g++;
                var w = x >> 4,
                  T = 15 & x;
                if ((w != 15 && S.push(w), T != 15 && S.push(T), T == 15))
                  break;
              }
              for (
                var E = "",
                  A = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  R = 0;
                R < S.length;
                R++
              )
                E += A[S[R]];
              _ = parseFloat(E);
            }
            h <= 21 &&
              ((y = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][h]),
              (g = 1),
              h == 12 &&
                ((y = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][m]),
                (g = 2))),
              y != null
                ? ((u[y] = f.length == 1 ? f[0] : f), (f = []))
                : f.push(_),
              (o += g);
          }
          return u;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (i, o, s) {
          (i = new Uint8Array(i.buffer, o, s)), (o = 0);
          var l = e._bin,
            u = {};
          l.readUshort(i, o), (o += 2);
          var f = l.readUshort(i, o);
          o += 2;
          var h = [];
          u.tables = [];
          for (var m = 0; m < f; m++) {
            var g = l.readUshort(i, o);
            o += 2;
            var y = l.readUshort(i, o);
            o += 2;
            var _ = l.readUint(i, o);
            o += 4;
            var S = "p" + g + "e" + y,
              x = h.indexOf(_);
            if (x == -1) {
              var w;
              (x = u.tables.length), h.push(_);
              var T = l.readUshort(i, _);
              T == 0
                ? (w = e.cmap.parse0(i, _))
                : T == 4
                ? (w = e.cmap.parse4(i, _))
                : T == 6
                ? (w = e.cmap.parse6(i, _))
                : T == 12
                ? (w = e.cmap.parse12(i, _))
                : console.debug("unknown format: " + T, g, y, _),
                u.tables.push(w);
            }
            if (u[S] != null) throw "multiple tables for one platform+encoding";
            u[S] = x;
          }
          return u;
        }),
        (e.cmap.parse0 = function (i, o) {
          var s = e._bin,
            l = {};
          (l.format = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2), (l.map = []);
          for (var f = 0; f < u - 6; f++) l.map.push(i[o + f]);
          return l;
        }),
        (e.cmap.parse4 = function (i, o) {
          var s = e._bin,
            l = o,
            u = {};
          (u.format = s.readUshort(i, o)), (o += 2);
          var f = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2);
          var h = s.readUshort(i, o);
          o += 2;
          var m = h / 2;
          (u.searchRange = s.readUshort(i, o)),
            (o += 2),
            (u.entrySelector = s.readUshort(i, o)),
            (o += 2),
            (u.rangeShift = s.readUshort(i, o)),
            (o += 2),
            (u.endCount = s.readUshorts(i, o, m)),
            (o += 2 * m),
            (o += 2),
            (u.startCount = s.readUshorts(i, o, m)),
            (o += 2 * m),
            (u.idDelta = []);
          for (var g = 0; g < m; g++)
            u.idDelta.push(s.readShort(i, o)), (o += 2);
          for (
            u.idRangeOffset = s.readUshorts(i, o, m),
              o += 2 * m,
              u.glyphIdArray = [];
            o < l + f;

          )
            u.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return u;
        }),
        (e.cmap.parse6 = function (i, o) {
          var s = e._bin,
            l = {};
          (l.format = s.readUshort(i, o)),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            (l.firstCode = s.readUshort(i, o)),
            (o += 2);
          var u = s.readUshort(i, o);
          (o += 2), (l.glyphIdArray = []);
          for (var f = 0; f < u; f++)
            l.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return l;
        }),
        (e.cmap.parse12 = function (i, o) {
          var s = e._bin,
            l = {};
          (l.format = s.readUshort(i, o)),
            (o += 2),
            (o += 2),
            s.readUint(i, o),
            (o += 4),
            s.readUint(i, o),
            (o += 4);
          var u = s.readUint(i, o);
          (o += 4), (l.groups = []);
          for (var f = 0; f < u; f++) {
            var h = o + 12 * f,
              m = s.readUint(i, h + 0),
              g = s.readUint(i, h + 4),
              y = s.readUint(i, h + 8);
            l.groups.push([m, g, y]);
          }
          return l;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (i, o, s, l) {
          for (var u = [], f = 0; f < l.maxp.numGlyphs; f++) u.push(null);
          return u;
        }),
        (e.glyf._parseGlyf = function (i, o) {
          var s = e._bin,
            l = i._data,
            u = e._tabOffset(l, "glyf", i._offset) + i.loca[o];
          if (i.loca[o] == i.loca[o + 1]) return null;
          var f = {};
          if (
            ((f.noc = s.readShort(l, u)),
            (u += 2),
            (f.xMin = s.readShort(l, u)),
            (u += 2),
            (f.yMin = s.readShort(l, u)),
            (u += 2),
            (f.xMax = s.readShort(l, u)),
            (u += 2),
            (f.yMax = s.readShort(l, u)),
            (u += 2),
            f.xMin >= f.xMax || f.yMin >= f.yMax)
          )
            return null;
          if (f.noc > 0) {
            f.endPts = [];
            for (var h = 0; h < f.noc; h++)
              f.endPts.push(s.readUshort(l, u)), (u += 2);
            var m = s.readUshort(l, u);
            if (((u += 2), l.length - u < m)) return null;
            (f.instructions = s.readBytes(l, u, m)), (u += m);
            var g = f.endPts[f.noc - 1] + 1;
            for (f.flags = [], h = 0; h < g; h++) {
              var y = l[u];
              if ((u++, f.flags.push(y), (8 & y) != 0)) {
                var _ = l[u];
                u++;
                for (var S = 0; S < _; S++) f.flags.push(y), h++;
              }
            }
            for (f.xs = [], h = 0; h < g; h++) {
              var x = (2 & f.flags[h]) != 0,
                w = (16 & f.flags[h]) != 0;
              x
                ? (f.xs.push(w ? l[u] : -l[u]), u++)
                : w
                ? f.xs.push(0)
                : (f.xs.push(s.readShort(l, u)), (u += 2));
            }
            for (f.ys = [], h = 0; h < g; h++)
              (x = (4 & f.flags[h]) != 0),
                (w = (32 & f.flags[h]) != 0),
                x
                  ? (f.ys.push(w ? l[u] : -l[u]), u++)
                  : w
                  ? f.ys.push(0)
                  : (f.ys.push(s.readShort(l, u)), (u += 2));
            var T = 0,
              E = 0;
            for (h = 0; h < g; h++)
              (T += f.xs[h]), (E += f.ys[h]), (f.xs[h] = T), (f.ys[h] = E);
          } else {
            var A;
            f.parts = [];
            do {
              (A = s.readUshort(l, u)), (u += 2);
              var R = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (f.parts.push(R),
                (R.glyphIndex = s.readUshort(l, u)),
                (u += 2),
                1 & A)
              ) {
                var D = s.readShort(l, u);
                u += 2;
                var I = s.readShort(l, u);
                u += 2;
              } else (D = s.readInt8(l, u)), u++, (I = s.readInt8(l, u)), u++;
              2 & A ? ((R.m.tx = D), (R.m.ty = I)) : ((R.p1 = D), (R.p2 = I)),
                8 & A
                  ? ((R.m.a = R.m.d = s.readF2dot14(l, u)), (u += 2))
                  : 64 & A
                  ? ((R.m.a = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.d = s.readF2dot14(l, u)),
                    (u += 2))
                  : 128 & A &&
                    ((R.m.a = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.b = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.c = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.d = s.readF2dot14(l, u)),
                    (u += 2));
            } while (32 & A);
            if (256 & A) {
              var U = s.readUshort(l, u);
              for (u += 2, f.instr = [], h = 0; h < U; h++)
                f.instr.push(l[u]), u++;
            }
          }
          return f;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (i, o, s, l) {
          var u = o;
          o += 4;
          var f = e._bin.readUshort(i, o);
          return {
            glyphClassDef: f === 0 ? null : e._lctf.readClassDef(i, u + f),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (i, o, s, l) {
          return e._lctf.parse(i, o, s, l, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (i, o, s, l) {
          var u = e._bin,
            f = s,
            h = {};
          if (
            ((h.fmt = u.readUshort(i, s)),
            (s += 2),
            o == 1 || o == 2 || o == 3 || o == 7 || (o == 8 && h.fmt <= 2))
          ) {
            var m = u.readUshort(i, s);
            (s += 2), (h.coverage = e._lctf.readCoverage(i, m + f));
          }
          if (o == 1 && h.fmt == 1) {
            var g = u.readUshort(i, s);
            (s += 2), g != 0 && (h.pos = e.GPOS.readValueRecord(i, s, g));
          } else if (o == 2 && h.fmt >= 1 && h.fmt <= 2) {
            (g = u.readUshort(i, s)), (s += 2);
            var y = u.readUshort(i, s);
            s += 2;
            var _ = e._lctf.numOfOnes(g),
              S = e._lctf.numOfOnes(y);
            if (h.fmt == 1) {
              h.pairsets = [];
              var x = u.readUshort(i, s);
              s += 2;
              for (var w = 0; w < x; w++) {
                var T = f + u.readUshort(i, s);
                s += 2;
                var E = u.readUshort(i, T);
                T += 2;
                for (var A = [], R = 0; R < E; R++) {
                  var D = u.readUshort(i, T);
                  (T += 2),
                    g != 0 &&
                      ((H = e.GPOS.readValueRecord(i, T, g)), (T += 2 * _)),
                    y != 0 &&
                      (($ = e.GPOS.readValueRecord(i, T, y)), (T += 2 * S)),
                    A.push({ gid2: D, val1: H, val2: $ });
                }
                h.pairsets.push(A);
              }
            }
            if (h.fmt == 2) {
              var I = u.readUshort(i, s);
              s += 2;
              var U = u.readUshort(i, s);
              s += 2;
              var O = u.readUshort(i, s);
              s += 2;
              var L = u.readUshort(i, s);
              for (
                s += 2,
                  h.classDef1 = e._lctf.readClassDef(i, f + I),
                  h.classDef2 = e._lctf.readClassDef(i, f + U),
                  h.matrix = [],
                  w = 0;
                w < O;
                w++
              ) {
                var V = [];
                for (R = 0; R < L; R++) {
                  var H = null,
                    $ = null;
                  g != 0 &&
                    ((H = e.GPOS.readValueRecord(i, s, g)), (s += 2 * _)),
                    y != 0 &&
                      (($ = e.GPOS.readValueRecord(i, s, y)), (s += 2 * S)),
                    V.push({ val1: H, val2: $ });
                }
                h.matrix.push(V);
              }
            }
          } else if (o == 4 && h.fmt == 1)
            (h.markCoverage = e._lctf.readCoverage(i, u.readUshort(i, s) + f)),
              (h.baseCoverage = e._lctf.readCoverage(
                i,
                u.readUshort(i, s + 2) + f
              )),
              (h.markClassCount = u.readUshort(i, s + 4)),
              (h.markArray = e.GPOS.readMarkArray(
                i,
                u.readUshort(i, s + 6) + f
              )),
              (h.baseArray = e.GPOS.readBaseArray(
                i,
                u.readUshort(i, s + 8) + f,
                h.markClassCount
              ));
          else if (o == 6 && h.fmt == 1)
            (h.mark1Coverage = e._lctf.readCoverage(i, u.readUshort(i, s) + f)),
              (h.mark2Coverage = e._lctf.readCoverage(
                i,
                u.readUshort(i, s + 2) + f
              )),
              (h.markClassCount = u.readUshort(i, s + 4)),
              (h.mark1Array = e.GPOS.readMarkArray(
                i,
                u.readUshort(i, s + 6) + f
              )),
              (h.mark2Array = e.GPOS.readBaseArray(
                i,
                u.readUshort(i, s + 8) + f,
                h.markClassCount
              ));
          else {
            if (o == 9 && h.fmt == 1) {
              var q = u.readUshort(i, s);
              s += 2;
              var K = u.readUint(i, s);
              if (((s += 4), l.ltype == 9)) l.ltype = q;
              else if (l.ltype != q) throw "invalid extension substitution";
              return e.GPOS.subt(i, l.ltype, f + K);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              o,
              "format",
              h.fmt
            );
          }
          return h;
        }),
        (e.GPOS.readValueRecord = function (i, o, s) {
          var l = e._bin,
            u = [];
          return (
            u.push(1 & s ? l.readShort(i, o) : 0),
            (o += 1 & s ? 2 : 0),
            u.push(2 & s ? l.readShort(i, o) : 0),
            (o += 2 & s ? 2 : 0),
            u.push(4 & s ? l.readShort(i, o) : 0),
            (o += 4 & s ? 2 : 0),
            u.push(8 & s ? l.readShort(i, o) : 0),
            (o += 8 & s ? 2 : 0),
            u
          );
        }),
        (e.GPOS.readBaseArray = function (i, o, s) {
          var l = e._bin,
            u = [],
            f = o,
            h = l.readUshort(i, o);
          o += 2;
          for (var m = 0; m < h; m++) {
            for (var g = [], y = 0; y < s; y++)
              g.push(e.GPOS.readAnchorRecord(i, f + l.readUshort(i, o))),
                (o += 2);
            u.push(g);
          }
          return u;
        }),
        (e.GPOS.readMarkArray = function (i, o) {
          var s = e._bin,
            l = [],
            u = o,
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = e.GPOS.readAnchorRecord(i, s.readUshort(i, o + 2) + u);
            (m.markClass = s.readUshort(i, o)), l.push(m), (o += 4);
          }
          return l;
        }),
        (e.GPOS.readAnchorRecord = function (i, o) {
          var s = e._bin,
            l = {};
          return (
            (l.fmt = s.readUshort(i, o)),
            (l.x = s.readShort(i, o + 2)),
            (l.y = s.readShort(i, o + 4)),
            l
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (i, o, s, l) {
          return e._lctf.parse(i, o, s, l, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (i, o, s, l) {
          var u = e._bin,
            f = s,
            h = {};
          if (
            ((h.fmt = u.readUshort(i, s)),
            (s += 2),
            o != 1 && o != 2 && o != 4 && o != 5 && o != 6)
          )
            return null;
          if (
            o == 1 ||
            o == 2 ||
            o == 4 ||
            (o == 5 && h.fmt <= 2) ||
            (o == 6 && h.fmt <= 2)
          ) {
            var m = u.readUshort(i, s);
            (s += 2), (h.coverage = e._lctf.readCoverage(i, f + m));
          }
          if (o == 1 && h.fmt >= 1 && h.fmt <= 2) {
            if (h.fmt == 1) (h.delta = u.readShort(i, s)), (s += 2);
            else if (h.fmt == 2) {
              var g = u.readUshort(i, s);
              (s += 2),
                (h.newg = u.readUshorts(i, s, g)),
                (s += 2 * h.newg.length);
            }
          } else if (o == 2 && h.fmt == 1) {
            (g = u.readUshort(i, s)), (s += 2), (h.seqs = []);
            for (var y = 0; y < g; y++) {
              var _ = u.readUshort(i, s) + f;
              s += 2;
              var S = u.readUshort(i, _);
              h.seqs.push(u.readUshorts(i, _ + 2, S));
            }
          } else if (o == 4)
            for (
              h.vals = [], g = u.readUshort(i, s), s += 2, y = 0;
              y < g;
              y++
            ) {
              var x = u.readUshort(i, s);
              (s += 2), h.vals.push(e.GSUB.readLigatureSet(i, f + x));
            }
          else if (o == 5 && h.fmt == 2) {
            if (h.fmt == 2) {
              var w = u.readUshort(i, s);
              (s += 2),
                (h.cDef = e._lctf.readClassDef(i, f + w)),
                (h.scset = []);
              var T = u.readUshort(i, s);
              for (s += 2, y = 0; y < T; y++) {
                var E = u.readUshort(i, s);
                (s += 2),
                  h.scset.push(
                    E == 0 ? null : e.GSUB.readSubClassSet(i, f + E)
                  );
              }
            }
          } else if (o == 6 && h.fmt == 3) {
            if (h.fmt == 3) {
              for (y = 0; y < 3; y++) {
                (g = u.readUshort(i, s)), (s += 2);
                for (var A = [], R = 0; R < g; R++)
                  A.push(
                    e._lctf.readCoverage(i, f + u.readUshort(i, s + 2 * R))
                  );
                (s += 2 * g),
                  y == 0 && (h.backCvg = A),
                  y == 1 && (h.inptCvg = A),
                  y == 2 && (h.ahedCvg = A);
              }
              (g = u.readUshort(i, s)),
                (s += 2),
                (h.lookupRec = e.GSUB.readSubstLookupRecords(i, s, g));
            }
          } else {
            if (o == 7 && h.fmt == 1) {
              var D = u.readUshort(i, s);
              s += 2;
              var I = u.readUint(i, s);
              if (((s += 4), l.ltype == 9)) l.ltype = D;
              else if (l.ltype != D) throw "invalid extension substitution";
              return e.GSUB.subt(i, l.ltype, f + I);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              o,
              "format",
              h.fmt
            );
          }
          return h;
        }),
        (e.GSUB.readSubClassSet = function (i, o) {
          var s = e._bin.readUshort,
            l = o,
            u = [],
            f = s(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s(i, o);
            (o += 2), u.push(e.GSUB.readSubClassRule(i, l + m));
          }
          return u;
        }),
        (e.GSUB.readSubClassRule = function (i, o) {
          var s = e._bin.readUshort,
            l = {},
            u = s(i, o),
            f = s(i, (o += 2));
          (o += 2), (l.input = []);
          for (var h = 0; h < u - 1; h++) l.input.push(s(i, o)), (o += 2);
          return (
            (l.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, f)), l
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (i, o, s) {
          for (var l = e._bin.readUshort, u = [], f = 0; f < s; f++)
            u.push(l(i, o), l(i, o + 2)), (o += 4);
          return u;
        }),
        (e.GSUB.readChainSubClassSet = function (i, o) {
          var s = e._bin,
            l = o,
            u = [],
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readUshort(i, o);
            (o += 2), u.push(e.GSUB.readChainSubClassRule(i, l + m));
          }
          return u;
        }),
        (e.GSUB.readChainSubClassRule = function (i, o) {
          for (
            var s = e._bin,
              l = {},
              u = ["backtrack", "input", "lookahead"],
              f = 0;
            f < u.length;
            f++
          ) {
            var h = s.readUshort(i, o);
            (o += 2),
              f == 1 && h--,
              (l[u[f]] = s.readUshorts(i, o, h)),
              (o += 2 * l[u[f]].length);
          }
          return (
            (h = s.readUshort(i, o)),
            (o += 2),
            (l.subst = s.readUshorts(i, o, 2 * h)),
            (o += 2 * l.subst.length),
            l
          );
        }),
        (e.GSUB.readLigatureSet = function (i, o) {
          var s = e._bin,
            l = o,
            u = [],
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readUshort(i, o);
            (o += 2), u.push(e.GSUB.readLigature(i, l + m));
          }
          return u;
        }),
        (e.GSUB.readLigature = function (i, o) {
          var s = e._bin,
            l = { chain: [] };
          (l.nglyph = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          o += 2;
          for (var f = 0; f < u - 1; f++)
            l.chain.push(s.readUshort(i, o)), (o += 2);
          return l;
        }),
        (e.head = {}),
        (e.head.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          return (
            l.readFixed(i, o),
            (o += 4),
            (u.fontRevision = l.readFixed(i, o)),
            (o += 4),
            l.readUint(i, o),
            (o += 4),
            l.readUint(i, o),
            (o += 4),
            (u.flags = l.readUshort(i, o)),
            (o += 2),
            (u.unitsPerEm = l.readUshort(i, o)),
            (o += 2),
            (u.created = l.readUint64(i, o)),
            (o += 8),
            (u.modified = l.readUint64(i, o)),
            (o += 8),
            (u.xMin = l.readShort(i, o)),
            (o += 2),
            (u.yMin = l.readShort(i, o)),
            (o += 2),
            (u.xMax = l.readShort(i, o)),
            (o += 2),
            (u.yMax = l.readShort(i, o)),
            (o += 2),
            (u.macStyle = l.readUshort(i, o)),
            (o += 2),
            (u.lowestRecPPEM = l.readUshort(i, o)),
            (o += 2),
            (u.fontDirectionHint = l.readShort(i, o)),
            (o += 2),
            (u.indexToLocFormat = l.readShort(i, o)),
            (o += 2),
            (u.glyphDataFormat = l.readShort(i, o)),
            (o += 2),
            u
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          return (
            l.readFixed(i, o),
            (o += 4),
            (u.ascender = l.readShort(i, o)),
            (o += 2),
            (u.descender = l.readShort(i, o)),
            (o += 2),
            (u.lineGap = l.readShort(i, o)),
            (o += 2),
            (u.advanceWidthMax = l.readUshort(i, o)),
            (o += 2),
            (u.minLeftSideBearing = l.readShort(i, o)),
            (o += 2),
            (u.minRightSideBearing = l.readShort(i, o)),
            (o += 2),
            (u.xMaxExtent = l.readShort(i, o)),
            (o += 2),
            (u.caretSlopeRise = l.readShort(i, o)),
            (o += 2),
            (u.caretSlopeRun = l.readShort(i, o)),
            (o += 2),
            (u.caretOffset = l.readShort(i, o)),
            (o += 2),
            (o += 8),
            (u.metricDataFormat = l.readShort(i, o)),
            (o += 2),
            (u.numberOfHMetrics = l.readUshort(i, o)),
            (o += 2),
            u
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (i, o, s, l) {
          for (
            var u = e._bin,
              f = { aWidth: [], lsBearing: [] },
              h = 0,
              m = 0,
              g = 0;
            g < l.maxp.numGlyphs;
            g++
          )
            g < l.hhea.numberOfHMetrics &&
              ((h = u.readUshort(i, o)),
              (o += 2),
              (m = u.readShort(i, o)),
              (o += 2)),
              f.aWidth.push(h),
              f.lsBearing.push(m);
          return f;
        }),
        (e.kern = {}),
        (e.kern.parse = function (i, o, s, l) {
          var u = e._bin,
            f = u.readUshort(i, o);
          if (((o += 2), f == 1)) return e.kern.parseV1(i, o - 2, s, l);
          var h = u.readUshort(i, o);
          o += 2;
          for (var m = { glyph1: [], rval: [] }, g = 0; g < h; g++) {
            (o += 2), (s = u.readUshort(i, o)), (o += 2);
            var y = u.readUshort(i, o);
            o += 2;
            var _ = y >>> 8;
            if ((_ &= 15) != 0) throw "unknown kern table format: " + _;
            o = e.kern.readFormat0(i, o, m);
          }
          return m;
        }),
        (e.kern.parseV1 = function (i, o, s, l) {
          var u = e._bin;
          u.readFixed(i, o), (o += 4);
          var f = u.readUint(i, o);
          o += 4;
          for (var h = { glyph1: [], rval: [] }, m = 0; m < f; m++) {
            u.readUint(i, o), (o += 4);
            var g = u.readUshort(i, o);
            (o += 2), u.readUshort(i, o), (o += 2);
            var y = g >>> 8;
            if ((y &= 15) != 0) throw "unknown kern table format: " + y;
            o = e.kern.readFormat0(i, o, h);
          }
          return h;
        }),
        (e.kern.readFormat0 = function (i, o, s) {
          var l = e._bin,
            u = -1,
            f = l.readUshort(i, o);
          (o += 2),
            l.readUshort(i, o),
            (o += 2),
            l.readUshort(i, o),
            (o += 2),
            l.readUshort(i, o),
            (o += 2);
          for (var h = 0; h < f; h++) {
            var m = l.readUshort(i, o);
            o += 2;
            var g = l.readUshort(i, o);
            o += 2;
            var y = l.readShort(i, o);
            (o += 2),
              m != u &&
                (s.glyph1.push(m), s.rval.push({ glyph2: [], vals: [] }));
            var _ = s.rval[s.rval.length - 1];
            _.glyph2.push(g), _.vals.push(y), (u = m);
          }
          return o;
        }),
        (e.loca = {}),
        (e.loca.parse = function (i, o, s, l) {
          var u = e._bin,
            f = [],
            h = l.head.indexToLocFormat,
            m = l.maxp.numGlyphs + 1;
          if (h == 0)
            for (var g = 0; g < m; g++)
              f.push(u.readUshort(i, o + (g << 1)) << 1);
          if (h == 1)
            for (g = 0; g < m; g++) f.push(u.readUint(i, o + (g << 2)));
          return f;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (i, o, s) {
          var l = e._bin,
            u = {},
            f = l.readUint(i, o);
          return (
            (o += 4),
            (u.numGlyphs = l.readUshort(i, o)),
            (o += 2),
            f == 65536 &&
              ((u.maxPoints = l.readUshort(i, o)),
              (o += 2),
              (u.maxContours = l.readUshort(i, o)),
              (o += 2),
              (u.maxCompositePoints = l.readUshort(i, o)),
              (o += 2),
              (u.maxCompositeContours = l.readUshort(i, o)),
              (o += 2),
              (u.maxZones = l.readUshort(i, o)),
              (o += 2),
              (u.maxTwilightPoints = l.readUshort(i, o)),
              (o += 2),
              (u.maxStorage = l.readUshort(i, o)),
              (o += 2),
              (u.maxFunctionDefs = l.readUshort(i, o)),
              (o += 2),
              (u.maxInstructionDefs = l.readUshort(i, o)),
              (o += 2),
              (u.maxStackElements = l.readUshort(i, o)),
              (o += 2),
              (u.maxSizeOfInstructions = l.readUshort(i, o)),
              (o += 2),
              (u.maxComponentElements = l.readUshort(i, o)),
              (o += 2),
              (u.maxComponentDepth = l.readUshort(i, o)),
              (o += 2)),
            u
          );
        }),
        (e.name = {}),
        (e.name.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          l.readUshort(i, o), (o += 2);
          var f = l.readUshort(i, o);
          (o += 2), l.readUshort(i, o);
          for (
            var h,
              m = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              g = (o += 2),
              y = 0;
            y < f;
            y++
          ) {
            var _ = l.readUshort(i, o);
            o += 2;
            var S = l.readUshort(i, o);
            o += 2;
            var x = l.readUshort(i, o);
            o += 2;
            var w = l.readUshort(i, o);
            o += 2;
            var T = l.readUshort(i, o);
            o += 2;
            var E = l.readUshort(i, o);
            o += 2;
            var A,
              R = m[w],
              D = g + 12 * f + E;
            if (_ == 0) A = l.readUnicode(i, D, T / 2);
            else if (_ == 3 && S == 0) A = l.readUnicode(i, D, T / 2);
            else if (S == 0) A = l.readASCII(i, D, T);
            else if (S == 1) A = l.readUnicode(i, D, T / 2);
            else if (S == 3) A = l.readUnicode(i, D, T / 2);
            else {
              if (_ != 1) throw "unknown encoding " + S + ", platformID: " + _;
              (A = l.readASCII(i, D, T)),
                console.debug(
                  "reading unknown MAC encoding " + S + " as ASCII"
                );
            }
            var I = "p" + _ + "," + x.toString(16);
            u[I] == null && (u[I] = {}),
              (u[I][R !== void 0 ? R : w] = A),
              (u[I]._lang = x);
          }
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 1033) return u[U];
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 0) return u[U];
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 3084) return u[U];
          for (var U in u) if (u[U].postScriptName != null) return u[U];
          for (var U in u) {
            h = U;
            break;
          }
          return (
            console.debug("returning name table with languageID " + u[h]._lang),
            u[h]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (i, o, s) {
          var l = e._bin.readUshort(i, o);
          o += 2;
          var u = {};
          if (l == 0) e["OS/2"].version0(i, o, u);
          else if (l == 1) e["OS/2"].version1(i, o, u);
          else if (l == 2 || l == 3 || l == 4) e["OS/2"].version2(i, o, u);
          else {
            if (l != 5) throw "unknown OS/2 table version: " + l;
            e["OS/2"].version5(i, o, u);
          }
          return u;
        }),
        (e["OS/2"].version0 = function (i, o, s) {
          var l = e._bin;
          return (
            (s.xAvgCharWidth = l.readShort(i, o)),
            (o += 2),
            (s.usWeightClass = l.readUshort(i, o)),
            (o += 2),
            (s.usWidthClass = l.readUshort(i, o)),
            (o += 2),
            (s.fsType = l.readUshort(i, o)),
            (o += 2),
            (s.ySubscriptXSize = l.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYSize = l.readShort(i, o)),
            (o += 2),
            (s.ySubscriptXOffset = l.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYOffset = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXSize = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYSize = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXOffset = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYOffset = l.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutSize = l.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutPosition = l.readShort(i, o)),
            (o += 2),
            (s.sFamilyClass = l.readShort(i, o)),
            (o += 2),
            (s.panose = l.readBytes(i, o, 10)),
            (o += 10),
            (s.ulUnicodeRange1 = l.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange2 = l.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange3 = l.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange4 = l.readUint(i, o)),
            (o += 4),
            (s.achVendID = [
              l.readInt8(i, o),
              l.readInt8(i, o + 1),
              l.readInt8(i, o + 2),
              l.readInt8(i, o + 3),
            ]),
            (o += 4),
            (s.fsSelection = l.readUshort(i, o)),
            (o += 2),
            (s.usFirstCharIndex = l.readUshort(i, o)),
            (o += 2),
            (s.usLastCharIndex = l.readUshort(i, o)),
            (o += 2),
            (s.sTypoAscender = l.readShort(i, o)),
            (o += 2),
            (s.sTypoDescender = l.readShort(i, o)),
            (o += 2),
            (s.sTypoLineGap = l.readShort(i, o)),
            (o += 2),
            (s.usWinAscent = l.readUshort(i, o)),
            (o += 2),
            (s.usWinDescent = l.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version1 = function (i, o, s) {
          var l = e._bin;
          return (
            (o = e["OS/2"].version0(i, o, s)),
            (s.ulCodePageRange1 = l.readUint(i, o)),
            (o += 4),
            (s.ulCodePageRange2 = l.readUint(i, o)),
            (o += 4)
          );
        }),
        (e["OS/2"].version2 = function (i, o, s) {
          var l = e._bin;
          return (
            (o = e["OS/2"].version1(i, o, s)),
            (s.sxHeight = l.readShort(i, o)),
            (o += 2),
            (s.sCapHeight = l.readShort(i, o)),
            (o += 2),
            (s.usDefault = l.readUshort(i, o)),
            (o += 2),
            (s.usBreak = l.readUshort(i, o)),
            (o += 2),
            (s.usMaxContext = l.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version5 = function (i, o, s) {
          var l = e._bin;
          return (
            (o = e["OS/2"].version2(i, o, s)),
            (s.usLowerOpticalPointSize = l.readUshort(i, o)),
            (o += 2),
            (s.usUpperOpticalPointSize = l.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          return (
            (u.version = l.readFixed(i, o)),
            (o += 4),
            (u.italicAngle = l.readFixed(i, o)),
            (o += 4),
            (u.underlinePosition = l.readShort(i, o)),
            (o += 2),
            (u.underlineThickness = l.readShort(i, o)),
            (o += 2),
            u
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (i, o) {
          var s = i.cmap,
            l = -1;
          if (
            (s.p0e4 != null
              ? (l = s.p0e4)
              : s.p3e1 != null
              ? (l = s.p3e1)
              : s.p1e0 != null
              ? (l = s.p1e0)
              : s.p0e3 != null && (l = s.p0e3),
            l == -1)
          )
            throw "no familiar platform and encoding!";
          var u = s.tables[l];
          if (u.format == 0) return o >= u.map.length ? 0 : u.map[o];
          if (u.format == 4) {
            for (var f = -1, h = 0; h < u.endCount.length; h++)
              if (o <= u.endCount[h]) {
                f = h;
                break;
              }
            return f == -1 || u.startCount[f] > o
              ? 0
              : 65535 &
                  (u.idRangeOffset[f] != 0
                    ? u.glyphIdArray[
                        o -
                          u.startCount[f] +
                          (u.idRangeOffset[f] >> 1) -
                          (u.idRangeOffset.length - f)
                      ]
                    : o + u.idDelta[f]);
          }
          if (u.format == 12) {
            if (o > u.groups[u.groups.length - 1][1]) return 0;
            for (h = 0; h < u.groups.length; h++) {
              var m = u.groups[h];
              if (m[0] <= o && o <= m[1]) return m[2] + (o - m[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + u.format;
        }),
        (e.U.glyphToPath = function (i, o) {
          var s = { cmds: [], crds: [] };
          if (i.SVG && i.SVG.entries[o]) {
            var l = i.SVG.entries[o];
            return l == null
              ? s
              : (typeof l == "string" &&
                  ((l = e.SVG.toPath(l)), (i.SVG.entries[o] = l)),
                l);
          }
          if (i.CFF) {
            var u = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              f = i.CFF,
              h = i.CFF.Private;
            if (f.ROS) {
              for (var m = 0; f.FDSelect[m + 2] <= o; ) m += 2;
              h = f.FDArray[f.FDSelect[m + 1]].Private;
            }
            e.U._drawCFF(i.CFF.CharStrings[o], u, f, h, s);
          } else i.glyf && e.U._drawGlyf(o, i, s);
          return s;
        }),
        (e.U._drawGlyf = function (i, o, s) {
          var l = o.glyf[i];
          l == null && (l = o.glyf[i] = e.glyf._parseGlyf(o, i)),
            l != null &&
              (l.noc > -1 ? e.U._simpleGlyph(l, s) : e.U._compoGlyph(l, o, s));
        }),
        (e.U._simpleGlyph = function (i, o) {
          for (var s = 0; s < i.noc; s++) {
            for (
              var l = s == 0 ? 0 : i.endPts[s - 1] + 1, u = i.endPts[s], f = l;
              f <= u;
              f++
            ) {
              var h = f == l ? u : f - 1,
                m = f == u ? l : f + 1,
                g = 1 & i.flags[f],
                y = 1 & i.flags[h],
                _ = 1 & i.flags[m],
                S = i.xs[f],
                x = i.ys[f];
              if (f == l)
                if (g) {
                  if (!y) {
                    e.U.P.moveTo(o, S, x);
                    continue;
                  }
                  e.U.P.moveTo(o, i.xs[h], i.ys[h]);
                } else
                  y
                    ? e.U.P.moveTo(o, i.xs[h], i.ys[h])
                    : e.U.P.moveTo(o, (i.xs[h] + S) / 2, (i.ys[h] + x) / 2);
              g
                ? y && e.U.P.lineTo(o, S, x)
                : _
                ? e.U.P.qcurveTo(o, S, x, i.xs[m], i.ys[m])
                : e.U.P.qcurveTo(o, S, x, (S + i.xs[m]) / 2, (x + i.ys[m]) / 2);
            }
            e.U.P.closePath(o);
          }
        }),
        (e.U._compoGlyph = function (i, o, s) {
          for (var l = 0; l < i.parts.length; l++) {
            var u = { cmds: [], crds: [] },
              f = i.parts[l];
            e.U._drawGlyf(f.glyphIndex, o, u);
            for (var h = f.m, m = 0; m < u.crds.length; m += 2) {
              var g = u.crds[m],
                y = u.crds[m + 1];
              s.crds.push(g * h.a + y * h.b + h.tx),
                s.crds.push(g * h.c + y * h.d + h.ty);
            }
            for (m = 0; m < u.cmds.length; m++) s.cmds.push(u.cmds[m]);
          }
        }),
        (e.U._getGlyphClass = function (i, o) {
          var s = e._lctf.getInterval(o, i);
          return s == -1 ? 0 : o[s + 2];
        }),
        (e.U._applySubs = function (i, o, s, l) {
          for (var u = i.length - o - 1, f = 0; f < s.tabs.length; f++)
            if (s.tabs[f] != null) {
              var h,
                m = s.tabs[f];
              if (
                !m.coverage ||
                (h = e._lctf.coverageIndex(m.coverage, i[o])) != -1
              ) {
                if (s.ltype == 1)
                  i[o],
                    m.fmt == 1 ? (i[o] = i[o] + m.delta) : (i[o] = m.newg[h]);
                else if (s.ltype == 4)
                  for (var g = m.vals[h], y = 0; y < g.length; y++) {
                    var _ = g[y],
                      S = _.chain.length;
                    if (!(S > u)) {
                      for (var x = !0, w = 0, T = 0; T < S; T++) {
                        for (; i[o + w + (1 + T)] == -1; ) w++;
                        _.chain[T] != i[o + w + (1 + T)] && (x = !1);
                      }
                      if (x) {
                        for (i[o] = _.nglyph, T = 0; T < S + w; T++)
                          i[o + T + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (s.ltype == 5 && m.fmt == 2)
                  for (
                    var E = e._lctf.getInterval(m.cDef, i[o]),
                      A = m.cDef[E + 2],
                      R = m.scset[A],
                      D = 0;
                    D < R.length;
                    D++
                  ) {
                    var I = R[D],
                      U = I.input;
                    if (!(U.length > u)) {
                      for (x = !0, T = 0; T < U.length; T++) {
                        var O = e._lctf.getInterval(m.cDef, i[o + 1 + T]);
                        if (E == -1 && m.cDef[O + 2] != U[T]) {
                          x = !1;
                          break;
                        }
                      }
                      if (x) {
                        var L = I.substLookupRecords;
                        for (y = 0; y < L.length; y += 2) L[y], L[y + 1];
                      }
                    }
                  }
                else if (s.ltype == 6 && m.fmt == 3) {
                  if (
                    !e.U._glsCovered(i, m.backCvg, o - m.backCvg.length) ||
                    !e.U._glsCovered(i, m.inptCvg, o) ||
                    !e.U._glsCovered(i, m.ahedCvg, o + m.inptCvg.length)
                  )
                    continue;
                  var V = m.lookupRec;
                  for (D = 0; D < V.length; D += 2) {
                    E = V[D];
                    var H = l[V[D + 1]];
                    e.U._applySubs(i, o + E, H, l);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (i, o, s) {
          for (var l = 0; l < o.length; l++)
            if (e._lctf.coverageIndex(o[l], i[s + l]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (i, o, s) {
          for (
            var l = { cmds: [], crds: [] }, u = 0, f = 0;
            f < o.length;
            f++
          ) {
            var h = o[f];
            if (h != -1) {
              for (
                var m = f < o.length - 1 && o[f + 1] != -1 ? o[f + 1] : 0,
                  g = e.U.glyphToPath(i, h),
                  y = 0;
                y < g.crds.length;
                y += 2
              )
                l.crds.push(g.crds[y] + u), l.crds.push(g.crds[y + 1]);
              for (s && l.cmds.push(s), y = 0; y < g.cmds.length; y++)
                l.cmds.push(g.cmds[y]);
              s && l.cmds.push("X"),
                (u += i.hmtx.aWidth[h]),
                f < o.length - 1 && (u += e.U.getPairAdjustment(i, h, m));
            }
          }
          return l;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (i, o, s) {
          i.cmds.push("M"), i.crds.push(o, s);
        }),
        (e.U.P.lineTo = function (i, o, s) {
          i.cmds.push("L"), i.crds.push(o, s);
        }),
        (e.U.P.curveTo = function (i, o, s, l, u, f, h) {
          i.cmds.push("C"), i.crds.push(o, s, l, u, f, h);
        }),
        (e.U.P.qcurveTo = function (i, o, s, l, u) {
          i.cmds.push("Q"), i.crds.push(o, s, l, u);
        }),
        (e.U.P.closePath = function (i) {
          i.cmds.push("Z");
        }),
        (e.U._drawCFF = function (i, o, s, l, u) {
          for (
            var f = o.stack,
              h = o.nStems,
              m = o.haveWidth,
              g = o.width,
              y = o.open,
              _ = 0,
              S = o.x,
              x = o.y,
              w = 0,
              T = 0,
              E = 0,
              A = 0,
              R = 0,
              D = 0,
              I = 0,
              U = 0,
              O = 0,
              L = 0,
              V = { val: 0, size: 0 };
            _ < i.length;

          ) {
            e.CFF.getCharString(i, _, V);
            var H = V.val;
            if (((_ += V.size), H == "o1" || H == "o18"))
              f.length % 2 != 0 && !m && (g = f.shift() + l.nominalWidthX),
                (h += f.length >> 1),
                (f.length = 0),
                (m = !0);
            else if (H == "o3" || H == "o23")
              f.length % 2 != 0 && !m && (g = f.shift() + l.nominalWidthX),
                (h += f.length >> 1),
                (f.length = 0),
                (m = !0);
            else if (H == "o4")
              f.length > 1 &&
                !m &&
                ((g = f.shift() + l.nominalWidthX), (m = !0)),
                y && e.U.P.closePath(u),
                (x += f.pop()),
                e.U.P.moveTo(u, S, x),
                (y = !0);
            else if (H == "o5")
              for (; f.length > 0; )
                (S += f.shift()), (x += f.shift()), e.U.P.lineTo(u, S, x);
            else if (H == "o6" || H == "o7")
              for (var $ = f.length, q = H == "o6", K = 0; K < $; K++) {
                var Y = f.shift();
                q ? (S += Y) : (x += Y), (q = !q), e.U.P.lineTo(u, S, x);
              }
            else if (H == "o8" || H == "o24") {
              $ = f.length;
              for (var ne = 0; ne + 6 <= $; )
                (w = S + f.shift()),
                  (T = x + f.shift()),
                  (E = w + f.shift()),
                  (A = T + f.shift()),
                  (S = E + f.shift()),
                  (x = A + f.shift()),
                  e.U.P.curveTo(u, w, T, E, A, S, x),
                  (ne += 6);
              H == "o24" &&
                ((S += f.shift()), (x += f.shift()), e.U.P.lineTo(u, S, x));
            } else {
              if (H == "o11") break;
              if (H == "o1234" || H == "o1235" || H == "o1236" || H == "o1237")
                H == "o1234" &&
                  ((T = x),
                  (E = (w = S + f.shift()) + f.shift()),
                  (L = A = T + f.shift()),
                  (D = A),
                  (U = x),
                  (S =
                    (I = (R = (O = E + f.shift()) + f.shift()) + f.shift()) +
                    f.shift()),
                  e.U.P.curveTo(u, w, T, E, A, O, L),
                  e.U.P.curveTo(u, R, D, I, U, S, x)),
                  H == "o1235" &&
                    ((w = S + f.shift()),
                    (T = x + f.shift()),
                    (E = w + f.shift()),
                    (A = T + f.shift()),
                    (O = E + f.shift()),
                    (L = A + f.shift()),
                    (R = O + f.shift()),
                    (D = L + f.shift()),
                    (I = R + f.shift()),
                    (U = D + f.shift()),
                    (S = I + f.shift()),
                    (x = U + f.shift()),
                    f.shift(),
                    e.U.P.curveTo(u, w, T, E, A, O, L),
                    e.U.P.curveTo(u, R, D, I, U, S, x)),
                  H == "o1236" &&
                    ((w = S + f.shift()),
                    (T = x + f.shift()),
                    (E = w + f.shift()),
                    (L = A = T + f.shift()),
                    (D = A),
                    (I = (R = (O = E + f.shift()) + f.shift()) + f.shift()),
                    (U = D + f.shift()),
                    (S = I + f.shift()),
                    e.U.P.curveTo(u, w, T, E, A, O, L),
                    e.U.P.curveTo(u, R, D, I, U, S, x)),
                  H == "o1237" &&
                    ((w = S + f.shift()),
                    (T = x + f.shift()),
                    (E = w + f.shift()),
                    (A = T + f.shift()),
                    (O = E + f.shift()),
                    (L = A + f.shift()),
                    (R = O + f.shift()),
                    (D = L + f.shift()),
                    (I = R + f.shift()),
                    (U = D + f.shift()),
                    Math.abs(I - S) > Math.abs(U - x)
                      ? (S = I + f.shift())
                      : (x = U + f.shift()),
                    e.U.P.curveTo(u, w, T, E, A, O, L),
                    e.U.P.curveTo(u, R, D, I, U, S, x));
              else if (H == "o14") {
                if (
                  (f.length > 0 &&
                    !m &&
                    ((g = f.shift() + s.nominalWidthX), (m = !0)),
                  f.length == 4)
                ) {
                  var j = f.shift(),
                    re = f.shift(),
                    B = f.shift(),
                    G = f.shift(),
                    te = e.CFF.glyphBySE(s, B),
                    le = e.CFF.glyphBySE(s, G);
                  e.U._drawCFF(s.CharStrings[te], o, s, l, u),
                    (o.x = j),
                    (o.y = re),
                    e.U._drawCFF(s.CharStrings[le], o, s, l, u);
                }
                y && (e.U.P.closePath(u), (y = !1));
              } else if (H == "o19" || H == "o20")
                f.length % 2 != 0 && !m && (g = f.shift() + l.nominalWidthX),
                  (h += f.length >> 1),
                  (f.length = 0),
                  (m = !0),
                  (_ += (h + 7) >> 3);
              else if (H == "o21")
                f.length > 2 &&
                  !m &&
                  ((g = f.shift() + l.nominalWidthX), (m = !0)),
                  (x += f.pop()),
                  (S += f.pop()),
                  y && e.U.P.closePath(u),
                  e.U.P.moveTo(u, S, x),
                  (y = !0);
              else if (H == "o22")
                f.length > 1 &&
                  !m &&
                  ((g = f.shift() + l.nominalWidthX), (m = !0)),
                  (S += f.pop()),
                  y && e.U.P.closePath(u),
                  e.U.P.moveTo(u, S, x),
                  (y = !0);
              else if (H == "o25") {
                for (; f.length > 6; )
                  (S += f.shift()), (x += f.shift()), e.U.P.lineTo(u, S, x);
                (w = S + f.shift()),
                  (T = x + f.shift()),
                  (E = w + f.shift()),
                  (A = T + f.shift()),
                  (S = E + f.shift()),
                  (x = A + f.shift()),
                  e.U.P.curveTo(u, w, T, E, A, S, x);
              } else if (H == "o26")
                for (f.length % 2 && (S += f.shift()); f.length > 0; )
                  (w = S),
                    (T = x + f.shift()),
                    (S = E = w + f.shift()),
                    (x = (A = T + f.shift()) + f.shift()),
                    e.U.P.curveTo(u, w, T, E, A, S, x);
              else if (H == "o27")
                for (f.length % 2 && (x += f.shift()); f.length > 0; )
                  (T = x),
                    (E = (w = S + f.shift()) + f.shift()),
                    (A = T + f.shift()),
                    (S = E + f.shift()),
                    (x = A),
                    e.U.P.curveTo(u, w, T, E, A, S, x);
              else if (H == "o10" || H == "o29") {
                var J = H == "o10" ? l : s;
                if (f.length == 0) console.debug("error: empty stack");
                else {
                  var oe = f.pop(),
                    he = J.Subrs[oe + J.Bias];
                  (o.x = S),
                    (o.y = x),
                    (o.nStems = h),
                    (o.haveWidth = m),
                    (o.width = g),
                    (o.open = y),
                    e.U._drawCFF(he, o, s, l, u),
                    (S = o.x),
                    (x = o.y),
                    (h = o.nStems),
                    (m = o.haveWidth),
                    (g = o.width),
                    (y = o.open);
                }
              } else if (H == "o30" || H == "o31") {
                var ae = f.length,
                  ue = ((ne = 0), H == "o31");
                for (ne += ae - ($ = -3 & ae); ne < $; )
                  ue
                    ? ((T = x),
                      (E = (w = S + f.shift()) + f.shift()),
                      (x = (A = T + f.shift()) + f.shift()),
                      $ - ne == 5 ? ((S = E + f.shift()), ne++) : (S = E),
                      (ue = !1))
                    : ((w = S),
                      (T = x + f.shift()),
                      (E = w + f.shift()),
                      (A = T + f.shift()),
                      (S = E + f.shift()),
                      $ - ne == 5 ? ((x = A + f.shift()), ne++) : (x = A),
                      (ue = !0)),
                    e.U.P.curveTo(u, w, T, E, A, S, x),
                    (ne += 4);
              } else {
                if ((H + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + H, i), H);
                f.push(H);
              }
            }
          }
          (o.x = S),
            (o.y = x),
            (o.nStems = h),
            (o.haveWidth = m),
            (o.width = g),
            (o.open = y);
        });
      var t = e,
        r = { Typr: t };
      return (
        (n.Typr = t),
        (n.default = r),
        Object.defineProperty(n, "__esModule", { value: !0 }),
        n
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function AG() {
  return (function (n) {
    var e = Uint8Array,
      t = Uint16Array,
      r = Uint32Array,
      i = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      o = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      s = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      l = function (H, $) {
        for (var q = new t(31), K = 0; K < 31; ++K) q[K] = $ += 1 << H[K - 1];
        var Y = new r(q[30]);
        for (K = 1; K < 30; ++K)
          for (var ne = q[K]; ne < q[K + 1]; ++ne)
            Y[ne] = ((ne - q[K]) << 5) | K;
        return [q, Y];
      },
      u = l(i, 2),
      f = u[0],
      h = u[1];
    (f[28] = 258), (h[258] = 28);
    for (var m = l(o, 0)[0], g = new t(32768), y = 0; y < 32768; ++y) {
      var _ = ((43690 & y) >>> 1) | ((21845 & y) << 1);
      (_ =
        ((61680 & (_ = ((52428 & _) >>> 2) | ((13107 & _) << 2))) >>> 4) |
        ((3855 & _) << 4)),
        (g[y] = (((65280 & _) >>> 8) | ((255 & _) << 8)) >>> 1);
    }
    var S = function (H, $, q) {
        for (var K = H.length, Y = 0, ne = new t($); Y < K; ++Y) ++ne[H[Y] - 1];
        var j,
          re = new t($);
        for (Y = 0; Y < $; ++Y) re[Y] = (re[Y - 1] + ne[Y - 1]) << 1;
        {
          j = new t(1 << $);
          var B = 15 - $;
          for (Y = 0; Y < K; ++Y)
            if (H[Y])
              for (
                var G = (Y << 4) | H[Y],
                  te = $ - H[Y],
                  le = re[H[Y] - 1]++ << te,
                  J = le | ((1 << te) - 1);
                le <= J;
                ++le
              )
                j[g[le] >>> B] = G;
        }
        return j;
      },
      x = new e(288);
    for (y = 0; y < 144; ++y) x[y] = 8;
    for (y = 144; y < 256; ++y) x[y] = 9;
    for (y = 256; y < 280; ++y) x[y] = 7;
    for (y = 280; y < 288; ++y) x[y] = 8;
    var w = new e(32);
    for (y = 0; y < 32; ++y) w[y] = 5;
    var T = S(x, 9),
      E = S(w, 5),
      A = function (H) {
        for (var $ = H[0], q = 1; q < H.length; ++q) H[q] > $ && ($ = H[q]);
        return $;
      },
      R = function (H, $, q) {
        var K = ($ / 8) | 0;
        return ((H[K] | (H[K + 1] << 8)) >> (7 & $)) & q;
      },
      D = function (H, $) {
        var q = ($ / 8) | 0;
        return (H[q] | (H[q + 1] << 8) | (H[q + 2] << 16)) >> (7 & $);
      },
      I = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      U = function (H, $, q) {
        var K = new Error($ || I[H]);
        if (
          ((K.code = H),
          Error.captureStackTrace && Error.captureStackTrace(K, U),
          !q)
        )
          throw K;
        return K;
      },
      O = function (H, $, q) {
        var K = H.length;
        if (!K || (q && !q.l && K < 5)) return $ || new e(0);
        var Y = !$ || q,
          ne = !q || q.i;
        q || (q = {}), $ || ($ = new e(3 * K));
        var j,
          re = function (et) {
            var ce = $.length;
            if (et > ce) {
              var Je = new e(Math.max(2 * ce, et));
              Je.set($), ($ = Je);
            }
          },
          B = q.f || 0,
          G = q.p || 0,
          te = q.b || 0,
          le = q.l,
          J = q.d,
          oe = q.m,
          he = q.n,
          ae = 8 * K;
        do {
          if (!le) {
            q.f = B = R(H, G, 1);
            var ue = R(H, G + 1, 3);
            if (((G += 3), !ue)) {
              var Ee =
                  H[(Z = (((j = G) / 8) | 0) + (7 & j && 1) + 4) - 4] |
                  (H[Z - 3] << 8),
                Ne = Z + Ee;
              if (Ne > K) {
                ne && U(0);
                break;
              }
              Y && re(te + Ee),
                $.set(H.subarray(Z, Ne), te),
                (q.b = te += Ee),
                (q.p = G = 8 * Ne);
              continue;
            }
            if (ue == 1) (le = T), (J = E), (oe = 9), (he = 5);
            else if (ue == 2) {
              var Ae = R(H, G, 31) + 257,
                W = R(H, G + 10, 15) + 4,
                _e = Ae + R(H, G + 5, 31) + 1;
              G += 14;
              for (var Te = new e(_e), ke = new e(19), Pe = 0; Pe < W; ++Pe)
                ke[s[Pe]] = R(H, G + 3 * Pe, 7);
              G += 3 * W;
              var rt = A(ke),
                Le = (1 << rt) - 1,
                Xe = S(ke, rt);
              for (Pe = 0; Pe < _e; ) {
                var Z,
                  F = Xe[R(H, G, Le)];
                if (((G += 15 & F), (Z = F >>> 4) < 16)) Te[Pe++] = Z;
                else {
                  var me = 0,
                    xe = 0;
                  for (
                    Z == 16
                      ? ((xe = 3 + R(H, G, 3)), (G += 2), (me = Te[Pe - 1]))
                      : Z == 17
                      ? ((xe = 3 + R(H, G, 7)), (G += 3))
                      : Z == 18 && ((xe = 11 + R(H, G, 127)), (G += 7));
                    xe--;

                  )
                    Te[Pe++] = me;
                }
              }
              var ye = Te.subarray(0, Ae),
                Me = Te.subarray(Ae);
              (oe = A(ye)), (he = A(Me)), (le = S(ye, oe)), (J = S(Me, he));
            } else U(1);
            if (G > ae) {
              ne && U(0);
              break;
            }
          }
          Y && re(te + 131072);
          for (var at = (1 << oe) - 1, Fe = (1 << he) - 1, ze = G; ; ze = G) {
            var We = (me = le[D(H, G) & at]) >>> 4;
            if ((G += 15 & me) > ae) {
              ne && U(0);
              break;
            }
            if ((me || U(2), We < 256)) $[te++] = We;
            else {
              if (We == 256) {
                (ze = G), (le = null);
                break;
              }
              var Ye = We - 254;
              if (We > 264) {
                var nt = i[(Pe = We - 257)];
                (Ye = R(H, G, (1 << nt) - 1) + f[Pe]), (G += nt);
              }
              var yt = J[D(H, G) & Fe],
                $e = yt >>> 4;
              if (
                (yt || U(3),
                (G += 15 & yt),
                (Me = m[$e]),
                $e > 3 &&
                  ((nt = o[$e]), (Me += D(H, G) & ((1 << nt) - 1)), (G += nt)),
                G > ae)
              ) {
                ne && U(0);
                break;
              }
              Y && re(te + 131072);
              for (var qe = te + Ye; te < qe; te += 4)
                ($[te] = $[te - Me]),
                  ($[te + 1] = $[te + 1 - Me]),
                  ($[te + 2] = $[te + 2 - Me]),
                  ($[te + 3] = $[te + 3 - Me]);
              te = qe;
            }
          }
          (q.l = le),
            (q.p = ze),
            (q.b = te),
            le && ((B = 1), (q.m = oe), (q.d = J), (q.n = he));
        } while (!B);
        return te == $.length
          ? $
          : (function (et, ce, Je) {
              (Je == null || Je > et.length) && (Je = et.length);
              var de = new (et instanceof t ? t : et instanceof r ? r : e)(
                Je - ce
              );
              return de.set(et.subarray(ce, Je)), de;
            })($, 0, te);
      },
      L = new e(0),
      V = typeof TextDecoder < "u" && new TextDecoder();
    try {
      V.decode(L, { stream: !0 });
    } catch {}
    return (
      (n.convert_streams = function (H) {
        var $ = new DataView(H),
          q = 0;
        function K() {
          var Ae = $.getUint16(q);
          return (q += 2), Ae;
        }
        function Y() {
          var Ae = $.getUint32(q);
          return (q += 4), Ae;
        }
        function ne(Ae) {
          Ee.setUint16(Ne, Ae), (Ne += 2);
        }
        function j(Ae) {
          Ee.setUint32(Ne, Ae), (Ne += 4);
        }
        for (
          var re = {
              signature: Y(),
              flavor: Y(),
              length: Y(),
              numTables: K(),
              reserved: K(),
              totalSfntSize: Y(),
              majorVersion: K(),
              minorVersion: K(),
              metaOffset: Y(),
              metaLength: Y(),
              metaOrigLength: Y(),
              privOffset: Y(),
              privLength: Y(),
            },
            B = 0;
          Math.pow(2, B) <= re.numTables;

        )
          B++;
        B--;
        for (
          var G = 16 * Math.pow(2, B),
            te = 16 * re.numTables - G,
            le = 12,
            J = [],
            oe = 0;
          oe < re.numTables;
          oe++
        )
          J.push({
            tag: Y(),
            offset: Y(),
            compLength: Y(),
            origLength: Y(),
            origChecksum: Y(),
          }),
            (le += 16);
        var he,
          ae = new Uint8Array(
            12 +
              16 * J.length +
              J.reduce(function (Ae, W) {
                return Ae + W.origLength + 4;
              }, 0)
          ),
          ue = ae.buffer,
          Ee = new DataView(ue),
          Ne = 0;
        return (
          j(re.flavor),
          ne(re.numTables),
          ne(G),
          ne(B),
          ne(te),
          J.forEach(function (Ae) {
            j(Ae.tag),
              j(Ae.origChecksum),
              j(le),
              j(Ae.origLength),
              (Ae.outOffset = le),
              (le += Ae.origLength) % 4 != 0 && (le += 4 - (le % 4));
          }),
          J.forEach(function (Ae) {
            var W,
              _e = H.slice(Ae.offset, Ae.offset + Ae.compLength);
            if (Ae.compLength != Ae.origLength) {
              var Te = new Uint8Array(Ae.origLength);
              (W = new Uint8Array(_e, 2)), O(W, Te);
            } else Te = new Uint8Array(_e);
            ae.set(Te, Ae.outOffset);
            var ke = 0;
            (le = Ae.outOffset + Ae.origLength) % 4 != 0 && (ke = 4 - (le % 4)),
              ae.set(new Uint8Array(ke).buffer, Ae.outOffset + Ae.origLength),
              (he = le + ke);
          }),
          ue.slice(0, he)
        );
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({}).convert_streams;
}
function RG(n, e) {
  const t = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    r = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    i = 1,
    o = 2,
    s = 4,
    l = 8,
    u = 16,
    f = 32;
  let h;
  function m(I) {
    if (!h) {
      const U = { R: o, L: i, D: s, C: u, U: f, T: l };
      h = new Map();
      for (let O in r) {
        let L = 0;
        r[O].split(",").forEach((V) => {
          let [H, $] = V.split("+");
          (H = parseInt(H, 36)),
            ($ = $ ? parseInt($, 36) : 0),
            h.set((L += H), U[O]);
          for (let q = $; q--; ) h.set(++L, U[O]);
        });
      }
    }
    return h.get(I) || f;
  }
  const g = 1,
    y = 2,
    _ = 3,
    S = 4,
    x = [null, "isol", "init", "fina", "medi"];
  function w(I) {
    const U = new Uint8Array(I.length);
    let O = f,
      L = g,
      V = -1;
    for (let H = 0; H < I.length; H++) {
      const $ = I.codePointAt(H);
      let q = m($) | 0,
        K = g;
      q & l ||
        (O & (i | s | u)
          ? q & (o | s | u)
            ? ((K = _), (L === g || L === _) && U[V]++)
            : q & (i | f) && (L === y || L === S) && U[V]--
          : O & (o | f) && (L === y || L === S) && U[V]--,
        (L = U[H] = K),
        (O = q),
        (V = H),
        $ > 65535 && H++);
    }
    return U;
  }
  function T(I, U) {
    const O = [];
    for (let V = 0; V < U.length; V++) {
      const H = U.codePointAt(V);
      H > 65535 && V++, O.push(n.U.codeToGlyph(I, H));
    }
    const L = I.GSUB;
    if (L) {
      const { lookupList: V, featureList: H } = L;
      let $;
      const q = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        K = [];
      H.forEach((Y) => {
        if (q.test(Y.tag))
          for (let ne = 0; ne < Y.tab.length; ne++) {
            if (K[Y.tab[ne]]) continue;
            K[Y.tab[ne]] = !0;
            const j = V[Y.tab[ne]],
              re = /^(isol|init|fina|medi)$/.test(Y.tag);
            re && !$ && ($ = w(U));
            for (let B = 0; B < O.length; B++)
              (!$ || !re || x[$[B]] === Y.tag) && n.U._applySubs(O, B, j, V);
          }
      });
    }
    return O;
  }
  function E(I, U) {
    const O = new Int16Array(U.length * 3);
    let L = 0;
    for (; L < U.length; L++) {
      const q = U[L];
      if (q === -1) continue;
      O[L * 3 + 2] = I.hmtx.aWidth[q];
      const K = I.GPOS;
      if (K) {
        const Y = K.lookupList;
        for (let ne = 0; ne < Y.length; ne++) {
          const j = Y[ne];
          for (let re = 0; re < j.tabs.length; re++) {
            const B = j.tabs[re];
            if (j.ltype === 1) {
              if (n._lctf.coverageIndex(B.coverage, q) !== -1 && B.pos) {
                $(B.pos, L);
                break;
              }
            } else if (j.ltype === 2) {
              let G = null,
                te = V();
              if (te !== -1) {
                const le = n._lctf.coverageIndex(B.coverage, U[te]);
                if (le !== -1) {
                  if (B.fmt === 1) {
                    const J = B.pairsets[le];
                    for (let oe = 0; oe < J.length; oe++)
                      J[oe].gid2 === q && (G = J[oe]);
                  } else if (B.fmt === 2) {
                    const J = n.U._getGlyphClass(U[te], B.classDef1),
                      oe = n.U._getGlyphClass(q, B.classDef2);
                    G = B.matrix[J][oe];
                  }
                  if (G) {
                    G.val1 && $(G.val1, te), G.val2 && $(G.val2, L);
                    break;
                  }
                }
              }
            } else if (j.ltype === 4) {
              const G = n._lctf.coverageIndex(B.markCoverage, q);
              if (G !== -1) {
                const te = V(H),
                  le =
                    te === -1
                      ? -1
                      : n._lctf.coverageIndex(B.baseCoverage, U[te]);
                if (le !== -1) {
                  const J = B.markArray[G],
                    oe = B.baseArray[le][J.markClass];
                  (O[L * 3] = oe.x - J.x + O[te * 3] - O[te * 3 + 2]),
                    (O[L * 3 + 1] = oe.y - J.y + O[te * 3 + 1]);
                  break;
                }
              }
            } else if (j.ltype === 6) {
              const G = n._lctf.coverageIndex(B.mark1Coverage, q);
              if (G !== -1) {
                const te = V();
                if (te !== -1) {
                  const le = U[te];
                  if (A(I, le) === 3) {
                    const J = n._lctf.coverageIndex(B.mark2Coverage, le);
                    if (J !== -1) {
                      const oe = B.mark1Array[G],
                        he = B.mark2Array[J][oe.markClass];
                      (O[L * 3] = he.x - oe.x + O[te * 3] - O[te * 3 + 2]),
                        (O[L * 3 + 1] = he.y - oe.y + O[te * 3 + 1]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (I.kern && !I.cff) {
        const Y = V();
        if (Y !== -1) {
          const ne = I.kern.glyph1.indexOf(U[Y]);
          if (ne !== -1) {
            const j = I.kern.rval[ne].glyph2.indexOf(q);
            j !== -1 && (O[Y * 3 + 2] += I.kern.rval[ne].vals[j]);
          }
        }
      }
    }
    return O;
    function V(q) {
      for (let K = L - 1; K >= 0; K--)
        if (U[K] !== -1 && (!q || q(U[K]))) return K;
      return -1;
    }
    function H(q) {
      return A(I, q) === 1;
    }
    function $(q, K) {
      for (let Y = 0; Y < 3; Y++) O[K * 3 + Y] += q[Y] || 0;
    }
  }
  function A(I, U) {
    const O = I.GDEF && I.GDEF.glyphClassDef;
    return O ? n.U._getGlyphClass(U, O) : 0;
  }
  function R(...I) {
    for (let U = 0; U < I.length; U++) if (typeof I[U] == "number") return I[U];
  }
  function D(I) {
    const U = Object.create(null),
      O = I["OS/2"],
      L = I.hhea,
      V = I.head.unitsPerEm,
      H = R(O && O.sTypoAscender, L && L.ascender, V),
      $ = {
        unitsPerEm: V,
        ascender: H,
        descender: R(O && O.sTypoDescender, L && L.descender, 0),
        capHeight: R(O && O.sCapHeight, H),
        xHeight: R(O && O.sxHeight, H),
        lineGap: R(O && O.sTypoLineGap, L && L.lineGap),
        supportsCodePoint(q) {
          return n.U.codeToGlyph(I, q) > 0;
        },
        forEachGlyph(q, K, Y, ne) {
          let j = 0;
          const re = (1 / $.unitsPerEm) * K,
            B = T(I, q);
          let G = 0;
          const te = E(I, B);
          return (
            B.forEach((le, J) => {
              if (le !== -1) {
                let oe = U[le];
                if (!oe) {
                  const { cmds: he, crds: ae } = n.U.glyphToPath(I, le);
                  let ue = "",
                    Ee = 0;
                  for (let Te = 0, ke = he.length; Te < ke; Te++) {
                    const Pe = t[he[Te]];
                    ue += he[Te];
                    for (let rt = 1; rt <= Pe; rt++)
                      ue += (rt > 1 ? "," : "") + ae[Ee++];
                  }
                  let Ne, Ae, W, _e;
                  if (ae.length) {
                    (Ne = Ae = 1 / 0), (W = _e = -1 / 0);
                    for (let Te = 0, ke = ae.length; Te < ke; Te += 2) {
                      let Pe = ae[Te],
                        rt = ae[Te + 1];
                      Pe < Ne && (Ne = Pe),
                        rt < Ae && (Ae = rt),
                        Pe > W && (W = Pe),
                        rt > _e && (_e = rt);
                    }
                  } else Ne = W = Ae = _e = 0;
                  oe = U[le] = {
                    index: le,
                    advanceWidth: I.hmtx.aWidth[le],
                    xMin: Ne,
                    yMin: Ae,
                    xMax: W,
                    yMax: _e,
                    path: ue,
                  };
                }
                ne.call(null, oe, j + te[J * 3] * re, te[J * 3 + 1] * re, G),
                  (j += te[J * 3 + 2] * re),
                  Y && (j += Y * K);
              }
              G += q.codePointAt(G) > 65535 ? 2 : 1;
            }),
            j
          );
        },
      };
    return $;
  }
  return function (U) {
    const O = new Uint8Array(U, 0, 4),
      L = n._bin.readASCII(O, 0, 4);
    if (L === "wOFF") U = e(U);
    else if (L === "wOF2") throw new Error("woff2 fonts not supported");
    return D(n.parse(U)[0]);
  };
}
const PG = Sh({
  name: "Typr Font Parser",
  dependencies: [CG, AG, RG],
  init(n, e, t) {
    const r = n(),
      i = e();
    return t(r, i);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function IG() {
  return (function (n) {
    var e = function () {
      this.buckets = new Map();
    };
    (e.prototype.add = function (E) {
      var A = E >> 5;
      this.buckets.set(A, (this.buckets.get(A) || 0) | (1 << (31 & E)));
    }),
      (e.prototype.has = function (E) {
        var A = this.buckets.get(E >> 5);
        return A !== void 0 && (A & (1 << (31 & E))) != 0;
      }),
      (e.prototype.serialize = function () {
        var E = [];
        return (
          this.buckets.forEach(function (A, R) {
            E.push((+R).toString(36) + ":" + A.toString(36));
          }),
          E.join(",")
        );
      }),
      (e.prototype.deserialize = function (E) {
        var A = this;
        this.buckets.clear(),
          E.split(",").forEach(function (R) {
            var D = R.split(":");
            A.buckets.set(parseInt(D[0], 36), parseInt(D[1], 36));
          });
      });
    var t = Math.pow(2, 8),
      r = t - 1,
      i = ~r;
    function o(E) {
      var A = (function (D) {
          return D & i;
        })(E).toString(16),
        R = (function (D) {
          return (D & i) + t - 1;
        })(E).toString(16);
      return "codepoint-index/plane" + (E >> 16) + "/" + A + "-" + R + ".json";
    }
    function s(E, A) {
      var R = E & r,
        D = A.codePointAt((R / 6) | 0);
      return ((D = (D || 48) - 48) & (1 << R % 6)) != 0;
    }
    function l(E, A) {
      var R;
      ((R = E),
      R.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (D) {
          return D.split("-").map(function (I) {
            return parseInt(I.trim(), 16);
          });
        })).forEach(function (D) {
        var I = D[0],
          U = D[1];
        U === void 0 && (U = I), A(I, U);
      });
    }
    function u(E, A) {
      l(E, function (R, D) {
        for (var I = R; I <= D; I++) A(I);
      });
    }
    var f = {},
      h = {},
      m = new WeakMap(),
      g =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function y(E) {
      var A = m.get(E);
      return (
        A ||
          ((A = new e()),
          u(E.ranges, function (R) {
            return A.add(R);
          }),
          m.set(E, A)),
        A
      );
    }
    var _,
      S = new Map();
    function x(E, A, R) {
      return E[A]
        ? A
        : E[R]
        ? R
        : (function (D) {
            for (var I in D) return I;
          })(E);
    }
    function w(E, A) {
      var R = A;
      if (!E.includes(R)) {
        R = 1 / 0;
        for (var D = 0; D < E.length; D++)
          Math.abs(E[D] - A) < Math.abs(R - A) && (R = E[D]);
      }
      return R;
    }
    function T(E) {
      return (
        _ ||
          ((_ = new Set()),
          u("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (A) {
            _.add(A);
          })),
        _.has(E)
      );
    }
    return (
      (n.CodePointSet = e),
      (n.clearCache = function () {
        (f = {}), (h = {});
      }),
      (n.getFontsForString = function (E, A) {
        A === void 0 && (A = {});
        var R,
          D = A.lang;
        D === void 0 &&
          (D = new RegExp("\\p{Script=Hangul}", "u").test((R = E))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                R
              )
            ? "ja"
            : "en");
        var I = A.category;
        I === void 0 && (I = "sans-serif");
        var U = A.style;
        U === void 0 && (U = "normal");
        var O = A.weight;
        O === void 0 && (O = 400);
        var L = (A.dataUrl || g).replace(/\/$/g, ""),
          V = new Map(),
          H = new Uint8Array(E.length),
          $ = {},
          q = {},
          K = new Array(E.length),
          Y = new Map(),
          ne = !1;
        function j(G) {
          var te = S.get(G);
          return (
            te ||
              ((te = fetch(L + "/" + G)
                .then(function (le) {
                  if (!le.ok) throw new Error(le.statusText);
                  return le.json().then(function (J) {
                    if (!Array.isArray(J) || J[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + J[0]
                      );
                    return J[1];
                  });
                })
                .catch(function (le) {
                  if (L !== g)
                    return (
                      ne ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            L +
                            '", trying default CDN. ' +
                            le.message
                        ),
                        (ne = !0)),
                      (L = g),
                      S.delete(G),
                      j(G)
                    );
                  throw le;
                })),
              S.set(G, te)),
            te
          );
        }
        for (
          var re = function (G) {
              var te = E.codePointAt(G),
                le = o(te);
              (K[G] = le),
                f[le] ||
                  Y.has(le) ||
                  Y.set(
                    le,
                    j(le).then(function (J) {
                      f[le] = J;
                    })
                  ),
                te > 65535 && (G++, (B = G));
            },
            B = 0;
          B < E.length;
          B++
        )
          re(B);
        return Promise.all(Y.values())
          .then(function () {
            Y.clear();
            for (
              var G = function (le) {
                  var J = E.codePointAt(le),
                    oe = null,
                    he = f[K[le]],
                    ae = void 0;
                  for (var ue in he) {
                    var Ee = q[ue];
                    if (
                      (Ee === void 0 &&
                        (Ee = q[ue] = new RegExp(ue).test(D || "en")),
                      Ee)
                    ) {
                      for (var Ne in ((ae = ue), he[ue]))
                        if (s(J, he[ue][Ne])) {
                          oe = Ne;
                          break;
                        }
                      break;
                    }
                  }
                  if (!oe) {
                    e: for (var Ae in he)
                      if (Ae !== ae) {
                        for (var W in he[Ae])
                          if (s(J, he[Ae][W])) {
                            oe = W;
                            break e;
                          }
                      }
                  }
                  oe ||
                    (console.debug("No font coverage for U+" + J.toString(16)),
                    (oe = "latin")),
                    (K[le] = oe),
                    h[oe] ||
                      Y.has(oe) ||
                      Y.set(
                        oe,
                        j("font-meta/" + oe + ".json").then(function (_e) {
                          h[oe] = _e;
                        })
                      ),
                    J > 65535 && (le++, (te = le));
                },
                te = 0;
              te < E.length;
              te++
            )
              G(te);
            return Promise.all(Y.values());
          })
          .then(function () {
            for (var G, te = null, le = 0; le < E.length; le++) {
              var J = E.codePointAt(le);
              if (te && (T(J) || y(te).has(J))) H[le] = H[le - 1];
              else {
                te = h[K[le]];
                var oe = $[te.id];
                if (!oe) {
                  var he = te.typeforms,
                    ae = x(he, I, "sans-serif"),
                    ue = x(he[ae], U, "normal"),
                    Ee = w(
                      (G = he[ae]) === null || G === void 0 ? void 0 : G[ue],
                      O
                    );
                  oe = $[te.id] =
                    L +
                    "/font-files/" +
                    te.id +
                    "/" +
                    ae +
                    "." +
                    ue +
                    "." +
                    Ee +
                    ".woff";
                }
                var Ne = V.get(oe);
                Ne == null && ((Ne = V.size), V.set(oe, Ne)), (H[le] = Ne);
              }
              J > 65535 && (le++, (H[le] = H[le - 1]));
            }
            return { fontUrls: Array.from(V.keys()), chars: H };
          });
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({});
}
function LG(n, e) {
  const t = Object.create(null),
    r = Object.create(null);
  function i(s, l) {
    const u = (f) => {
      console.error(`Failure loading font ${s}`, f);
    };
    try {
      const f = new XMLHttpRequest();
      f.open("get", s, !0),
        (f.responseType = "arraybuffer"),
        (f.onload = function () {
          if (f.status >= 400) u(new Error(f.statusText));
          else if (f.status > 0)
            try {
              const h = n(f.response);
              (h.src = s), l(h);
            } catch (h) {
              u(h);
            }
        }),
        (f.onerror = u),
        f.send();
    } catch (f) {
      u(f);
    }
  }
  function o(s, l) {
    let u = t[s];
    u
      ? l(u)
      : r[s]
      ? r[s].push(l)
      : ((r[s] = [l]),
        i(s, (f) => {
          (f.src = s), (t[s] = f), r[s].forEach((h) => h(f)), delete r[s];
        }));
  }
  return function (
    s,
    l,
    {
      lang: u,
      fonts: f = [],
      style: h = "normal",
      weight: m = "normal",
      unicodeFontsURL: g,
    } = {}
  ) {
    const y = new Uint8Array(s.length),
      _ = [];
    s.length || T();
    const S = new Map(),
      x = [];
    if (
      (h !== "italic" && (h = "normal"),
      typeof m != "number" && (m = m === "bold" ? 700 : 400),
      f && !Array.isArray(f) && (f = [f]),
      (f = f
        .slice()
        .filter((A) => !A.lang || A.lang.test(u))
        .reverse()),
      f.length)
    ) {
      let I = 0;
      (function U(O = 0) {
        for (let L = O, V = s.length; L < V; L++) {
          const H = s.codePointAt(L);
          if ((I === 1 && _[y[L - 1]].supportsCodePoint(H)) || /\s/.test(s[L]))
            (y[L] = y[L - 1]), I === 2 && (x[x.length - 1][1] = L);
          else
            for (let $ = y[L], q = f.length; $ <= q; $++)
              if ($ === q) {
                const K = I === 2 ? x[x.length - 1] : (x[x.length] = [L, L]);
                (K[1] = L), (I = 2);
              } else {
                y[L] = $;
                const { src: K, unicodeRange: Y } = f[$];
                if (!Y || E(H, Y)) {
                  const ne = t[K];
                  if (!ne) {
                    o(K, () => {
                      U(L);
                    });
                    return;
                  }
                  if (ne.supportsCodePoint(H)) {
                    let j = S.get(ne);
                    typeof j != "number" &&
                      ((j = _.length), _.push(ne), S.set(ne, j)),
                      (y[L] = j),
                      (I = 1);
                    break;
                  }
                }
              }
          H > 65535 &&
            L + 1 < V &&
            ((y[L + 1] = y[L]), L++, I === 2 && (x[x.length - 1][1] = L));
        }
        w();
      })();
    } else x.push([0, s.length - 1]), w();
    function w() {
      if (x.length) {
        const A = x.map((R) => s.substring(R[0], R[1] + 1)).join(`
`);
        e.getFontsForString(A, {
          lang: u || void 0,
          style: h,
          weight: m,
          dataUrl: g,
        }).then(({ fontUrls: R, chars: D }) => {
          const I = _.length;
          let U = 0;
          x.forEach((L) => {
            for (let V = 0, H = L[1] - L[0]; V <= H; V++)
              y[L[0] + V] = D[U++] + I;
            U++;
          });
          let O = 0;
          R.forEach((L, V) => {
            o(L, (H) => {
              (_[V + I] = H), ++O === R.length && T();
            });
          });
        });
      } else T();
    }
    function T() {
      l({ chars: y, fonts: _ });
    }
    function E(A, R) {
      for (let D = 0; D < R.length; D++) {
        const [I, U = I] = R[D];
        if (I <= A && A <= U) return !0;
      }
      return !1;
    }
  };
}
const DG = Sh({
  name: "FontResolver",
  dependencies: [LG, PG, IG],
  init(n, e, t) {
    return n(e, t());
  },
});
function kG(n, e) {
  const r =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    i = "[^\\S\\u00A0]",
    o = new RegExp(
      `${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function s(
    {
      text: _,
      lang: S,
      fonts: x,
      style: w,
      weight: T,
      preResolvedFonts: E,
      unicodeFontsURL: A,
    },
    R
  ) {
    const D = ({ chars: I, fonts: U }) => {
      let O, L;
      const V = [];
      for (let H = 0; H < I.length; H++)
        I[H] !== L
          ? ((L = I[H]), V.push((O = { start: H, end: H, fontObj: U[I[H]] })))
          : (O.end = H);
      R(V);
    };
    E
      ? D(E)
      : n(_, D, { lang: S, fonts: x, style: w, weight: T, unicodeFontsURL: A });
  }
  function l(
    {
      text: _ = "",
      font: S,
      lang: x,
      sdfGlyphSize: w = 64,
      fontSize: T = 400,
      fontWeight: E = 1,
      fontStyle: A = "normal",
      letterSpacing: R = 0,
      lineHeight: D = "normal",
      maxWidth: I = 1 / 0,
      direction: U,
      textAlign: O = "left",
      textIndent: L = 0,
      whiteSpace: V = "normal",
      overflowWrap: H = "normal",
      anchorX: $ = 0,
      anchorY: q = 0,
      metricsOnly: K = !1,
      unicodeFontsURL: Y,
      preResolvedFonts: ne = null,
      includeCaretPositions: j = !1,
      chunkedBoundsSize: re = 8192,
      colorRanges: B = null,
    },
    G
  ) {
    const te = m(),
      le = { fontLoad: 0, typesetting: 0 };
    _.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (_ = _.replace(
        /\r\n/g,
        `
`
      ).replace(
        /\r/g,
        `
`
      ))),
      (T = +T),
      (R = +R),
      (I = +I),
      (D = D || "normal"),
      (L = +L),
      s(
        {
          text: _,
          lang: x,
          style: A,
          weight: E,
          fonts: typeof S == "string" ? [{ src: S }] : S,
          unicodeFontsURL: Y,
          preResolvedFonts: ne,
        },
        (J) => {
          le.fontLoad = m() - te;
          const oe = isFinite(I);
          let he = null,
            ae = null,
            ue = null,
            Ee = null,
            Ne = null,
            Ae = null,
            W = null,
            _e = null,
            Te = 0,
            ke = 0,
            Pe = V !== "nowrap";
          const rt = new Map(),
            Le = m();
          let Xe = L,
            Z = 0,
            F = new g();
          const me = [F];
          J.forEach((Fe) => {
            const { fontObj: ze } = Fe,
              {
                ascender: We,
                descender: Ye,
                unitsPerEm: nt,
                lineGap: yt,
                capHeight: $e,
                xHeight: qe,
              } = ze;
            let et = rt.get(ze);
            if (!et) {
              const Ce = T / nt,
                Ue = D === "normal" ? (We - Ye + yt) * Ce : D * T,
                it = (Ue - (We - Ye) * Ce) / 2,
                mt = Math.min(Ue, (We - Ye) * Ce),
                gt = ((We + Ye) / 2) * Ce + mt / 2;
              (et = {
                index: rt.size,
                src: ze.src,
                fontObj: ze,
                fontSizeMult: Ce,
                unitsPerEm: nt,
                ascender: We * Ce,
                descender: Ye * Ce,
                capHeight: $e * Ce,
                xHeight: qe * Ce,
                lineHeight: Ue,
                baseline: -it - We * Ce,
                caretTop: ((We + Ye) / 2) * Ce + mt / 2,
                caretBottom: gt - mt,
              }),
                rt.set(ze, et);
            }
            const { fontSizeMult: ce } = et,
              Je = _.slice(Fe.start, Fe.end + 1);
            let de, He;
            ze.forEachGlyph(Je, T, R, (Ce, Ue, it, mt) => {
              (Ue += Z), (mt += Fe.start), (de = Ue), (He = Ce);
              const gt = _.charAt(mt),
                Ot = Ce.advanceWidth * ce,
                Nt = F.count;
              let ht;
              if (
                ("isEmpty" in Ce ||
                  ((Ce.isWhitespace = !!gt && new RegExp(i).test(gt)),
                  (Ce.canBreakAfter = !!gt && o.test(gt)),
                  (Ce.isEmpty =
                    Ce.xMin === Ce.xMax || Ce.yMin === Ce.yMax || r.test(gt))),
                !Ce.isWhitespace && !Ce.isEmpty && ke++,
                Pe && oe && !Ce.isWhitespace && Ue + Ot + Xe > I && Nt)
              ) {
                if (F.glyphAt(Nt - 1).glyphObj.canBreakAfter)
                  (ht = new g()), (Xe = -Ue);
                else
                  for (let an = Nt; an--; )
                    if (an === 0 && H === "break-word") {
                      (ht = new g()), (Xe = -Ue);
                      break;
                    } else if (F.glyphAt(an).glyphObj.canBreakAfter) {
                      ht = F.splitAt(an + 1);
                      const _n = ht.glyphAt(0).x;
                      Xe -= _n;
                      for (let mn = ht.count; mn--; ) ht.glyphAt(mn).x -= _n;
                      break;
                    }
                ht && ((F.isSoftWrapped = !0), (F = ht), me.push(F), (Te = I));
              }
              let jt = F.glyphAt(F.count);
              (jt.glyphObj = Ce),
                (jt.x = Ue + Xe),
                (jt.y = it),
                (jt.width = Ot),
                (jt.charIndex = mt),
                (jt.fontData = et),
                gt ===
                  `
` && ((F = new g()), me.push(F), (Xe = -(Ue + Ot + R * T) + L));
            }),
              (Z = de + He.advanceWidth * ce + R * T);
          });
          let xe = 0;
          me.forEach((Fe) => {
            let ze = !0;
            for (let We = Fe.count; We--; ) {
              const Ye = Fe.glyphAt(We);
              ze &&
                !Ye.glyphObj.isWhitespace &&
                ((Fe.width = Ye.x + Ye.width),
                Fe.width > Te && (Te = Fe.width),
                (ze = !1));
              let {
                lineHeight: nt,
                capHeight: yt,
                xHeight: $e,
                baseline: qe,
              } = Ye.fontData;
              nt > Fe.lineHeight && (Fe.lineHeight = nt);
              const et = qe - Fe.baseline;
              et < 0 && ((Fe.baseline += et), (Fe.cap += et), (Fe.ex += et)),
                (Fe.cap = Math.max(Fe.cap, Fe.baseline + yt)),
                (Fe.ex = Math.max(Fe.ex, Fe.baseline + $e));
            }
            (Fe.baseline -= xe),
              (Fe.cap -= xe),
              (Fe.ex -= xe),
              (xe += Fe.lineHeight);
          });
          let ye = 0,
            Me = 0;
          if (
            ($ &&
              (typeof $ == "number"
                ? (ye = -$)
                : typeof $ == "string" &&
                  (ye =
                    -Te *
                    ($ === "left"
                      ? 0
                      : $ === "center"
                      ? 0.5
                      : $ === "right"
                      ? 1
                      : f($)))),
            q &&
              (typeof q == "number"
                ? (Me = -q)
                : typeof q == "string" &&
                  (Me =
                    q === "top"
                      ? 0
                      : q === "top-baseline"
                      ? -me[0].baseline
                      : q === "top-cap"
                      ? -me[0].cap
                      : q === "top-ex"
                      ? -me[0].ex
                      : q === "middle"
                      ? xe / 2
                      : q === "bottom"
                      ? xe
                      : q === "bottom-baseline"
                      ? me[me.length - 1].baseline
                      : f(q) * xe)),
            !K)
          ) {
            const Fe = e.getEmbeddingLevels(_, U);
            (he = new Uint16Array(ke)),
              (ae = new Uint8Array(ke)),
              (ue = new Float32Array(ke * 2)),
              (Ee = {}),
              (W = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (_e = []),
              j && (Ae = new Float32Array(_.length * 4)),
              B && (Ne = new Uint8Array(ke * 3));
            let ze = 0,
              We = -1,
              Ye = -1,
              nt,
              yt;
            if (
              (me.forEach(($e, qe) => {
                let { count: et, width: ce } = $e;
                if (et > 0) {
                  let Je = 0;
                  for (
                    let mt = et;
                    mt-- && $e.glyphAt(mt).glyphObj.isWhitespace;

                  )
                    Je++;
                  let de = 0,
                    He = 0;
                  if (O === "center") de = (Te - ce) / 2;
                  else if (O === "right") de = Te - ce;
                  else if (O === "justify" && $e.isSoftWrapped) {
                    let mt = 0;
                    for (let gt = et - Je; gt--; )
                      $e.glyphAt(gt).glyphObj.isWhitespace && mt++;
                    He = (Te - ce) / mt;
                  }
                  if (He || de) {
                    let mt = 0;
                    for (let gt = 0; gt < et; gt++) {
                      let Ot = $e.glyphAt(gt);
                      const Nt = Ot.glyphObj;
                      (Ot.x += de + mt),
                        He !== 0 &&
                          Nt.isWhitespace &&
                          gt < et - Je &&
                          ((mt += He), (Ot.width += He));
                    }
                  }
                  const Ce = e.getReorderSegments(
                    _,
                    Fe,
                    $e.glyphAt(0).charIndex,
                    $e.glyphAt($e.count - 1).charIndex
                  );
                  for (let mt = 0; mt < Ce.length; mt++) {
                    const [gt, Ot] = Ce[mt];
                    let Nt = 1 / 0,
                      ht = -1 / 0;
                    for (let jt = 0; jt < et; jt++)
                      if ($e.glyphAt(jt).charIndex >= gt) {
                        let an = jt,
                          _n = jt;
                        for (; _n < et; _n++) {
                          let mn = $e.glyphAt(_n);
                          if (mn.charIndex > Ot) break;
                          _n < et - Je &&
                            ((Nt = Math.min(Nt, mn.x)),
                            (ht = Math.max(ht, mn.x + mn.width)));
                        }
                        for (let mn = an; mn < _n; mn++) {
                          const ir = $e.glyphAt(mn);
                          ir.x = ht - (ir.x + ir.width - Nt);
                        }
                        break;
                      }
                  }
                  let Ue;
                  const it = (mt) => (Ue = mt);
                  for (let mt = 0; mt < et; mt++) {
                    const gt = $e.glyphAt(mt);
                    Ue = gt.glyphObj;
                    const Ot = Ue.index,
                      Nt = Fe.levels[gt.charIndex] & 1;
                    if (Nt) {
                      const ht = e.getMirroredCharacter(_[gt.charIndex]);
                      ht && gt.fontData.fontObj.forEachGlyph(ht, 0, 0, it);
                    }
                    if (j) {
                      const { charIndex: ht, fontData: jt } = gt,
                        an = gt.x + ye,
                        _n = gt.x + gt.width + ye;
                      (Ae[ht * 4] = Nt ? _n : an),
                        (Ae[ht * 4 + 1] = Nt ? an : _n),
                        (Ae[ht * 4 + 2] = $e.baseline + jt.caretBottom + Me),
                        (Ae[ht * 4 + 3] = $e.baseline + jt.caretTop + Me);
                      const mn = ht - We;
                      mn > 1 && h(Ae, We, mn), (We = ht);
                    }
                    if (B) {
                      const { charIndex: ht } = gt;
                      for (; ht > Ye; )
                        Ye++, B.hasOwnProperty(Ye) && (yt = B[Ye]);
                    }
                    if (!Ue.isWhitespace && !Ue.isEmpty) {
                      const ht = ze++,
                        { fontSizeMult: jt, src: an, index: _n } = gt.fontData,
                        mn = Ee[an] || (Ee[an] = {});
                      mn[Ot] ||
                        (mn[Ot] = {
                          path: Ue.path,
                          pathBounds: [Ue.xMin, Ue.yMin, Ue.xMax, Ue.yMax],
                        });
                      const ir = gt.x + ye,
                        Oi = gt.y + $e.baseline + Me;
                      (ue[ht * 2] = ir), (ue[ht * 2 + 1] = Oi);
                      const mr = ir + Ue.xMin * jt,
                        Nr = Oi + Ue.yMin * jt,
                        Er = ir + Ue.xMax * jt,
                        Ur = Oi + Ue.yMax * jt;
                      mr < W[0] && (W[0] = mr),
                        Nr < W[1] && (W[1] = Nr),
                        Er > W[2] && (W[2] = Er),
                        Ur > W[3] && (W[3] = Ur),
                        ht % re === 0 &&
                          ((nt = {
                            start: ht,
                            end: ht,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          _e.push(nt)),
                        nt.end++;
                      const gr = nt.rect;
                      if (
                        (mr < gr[0] && (gr[0] = mr),
                        Nr < gr[1] && (gr[1] = Nr),
                        Er > gr[2] && (gr[2] = Er),
                        Ur > gr[3] && (gr[3] = Ur),
                        (he[ht] = Ot),
                        (ae[ht] = _n),
                        B)
                      ) {
                        const go = ht * 3;
                        (Ne[go] = (yt >> 16) & 255),
                          (Ne[go + 1] = (yt >> 8) & 255),
                          (Ne[go + 2] = yt & 255);
                      }
                    }
                  }
                }
              }),
              Ae)
            ) {
              const $e = _.length - We;
              $e > 1 && h(Ae, We, $e);
            }
          }
          const at = [];
          rt.forEach(
            ({
              index: Fe,
              src: ze,
              unitsPerEm: We,
              ascender: Ye,
              descender: nt,
              lineHeight: yt,
              capHeight: $e,
              xHeight: qe,
            }) => {
              at[Fe] = {
                src: ze,
                unitsPerEm: We,
                ascender: Ye,
                descender: nt,
                lineHeight: yt,
                capHeight: $e,
                xHeight: qe,
              };
            }
          ),
            (le.typesetting = m() - Le),
            G({
              glyphIds: he,
              glyphFontIndices: ae,
              glyphPositions: ue,
              glyphData: Ee,
              fontData: at,
              caretPositions: Ae,
              glyphColors: Ne,
              chunkedBounds: _e,
              fontSize: T,
              topBaseline: Me + me[0].baseline,
              blockBounds: [ye, Me - xe, ye + Te, Me],
              visibleBounds: W,
              timings: le,
            });
        }
      );
  }
  function u(_, S) {
    l({ ..._, metricsOnly: !0 }, (x) => {
      const [w, T, E, A] = x.blockBounds;
      S({ width: E - w, height: A - T });
    });
  }
  function f(_) {
    let S = _.match(/^([\d.]+)%$/),
      x = S ? parseFloat(S[1]) : NaN;
    return isNaN(x) ? 0 : x / 100;
  }
  function h(_, S, x) {
    const w = _[S * 4],
      T = _[S * 4 + 1],
      E = _[S * 4 + 2],
      A = _[S * 4 + 3],
      R = (T - w) / x;
    for (let D = 0; D < x; D++) {
      const I = (S + D) * 4;
      (_[I] = w + R * D),
        (_[I + 1] = w + R * (D + 1)),
        (_[I + 2] = E),
        (_[I + 3] = A);
    }
  }
  function m() {
    return (self.performance || Date).now();
  }
  function g() {
    this.data = [];
  }
  const y = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (g.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / y.length);
      },
      glyphAt(_) {
        let S = g.flyweight;
        return (S.data = this.data), (S.index = _), S;
      },
      splitAt(_) {
        let S = new g();
        return (S.data = this.data.splice(_ * y.length)), S;
      },
    }),
    (g.flyweight = y.reduce(
      (_, S, x, w) => (
        Object.defineProperty(_, S, {
          get() {
            return this.data[this.index * y.length + x];
          },
          set(T) {
            this.data[this.index * y.length + x] = T;
          },
        }),
        _
      ),
      { data: null, index: 0 }
    )),
    { typeset: l, measure: u }
  );
}
const nf = () => (self.performance || Date).now(),
  Xy = $R();
let GT;
function OG(n, e, t, r, i, o, s, l, u, f, h = !0) {
  return h
    ? UG(n, e, t, r, i, o, s, l, u, f).then(
        null,
        (m) => (
          GT ||
            (console.warn("WebGL SDF generation failed, falling back to JS", m),
            (GT = !0)),
          jT(n, e, t, r, i, o, s, l, u, f)
        )
      )
    : jT(n, e, t, r, i, o, s, l, u, f);
}
const Zv = [],
  NG = 5;
let Z1 = 0;
function YR() {
  const n = nf();
  for (; Zv.length && nf() - n < NG; ) Zv.shift()();
  Z1 = Zv.length ? setTimeout(YR, 0) : 0;
}
const UG = (...n) =>
    new Promise((e, t) => {
      Zv.push(() => {
        const r = nf();
        try {
          Xy.webgl.generateIntoCanvas(...n), e({ timing: nf() - r });
        } catch (i) {
          t(i);
        }
      }),
        Z1 || (Z1 = setTimeout(YR, 0));
    }),
  FG = 4,
  zG = 2e3,
  WT = {};
let BG = 0;
function jT(n, e, t, r, i, o, s, l, u, f) {
  const h = "TroikaTextSDFGenerator_JS_" + (BG++ % FG);
  let m = WT[h];
  return (
    m ||
      (m = WT[h] =
        {
          workerModule: Sh({
            name: h,
            workerId: h,
            dependencies: [$R, nf],
            init(g, y) {
              const _ = g().javascript.generate;
              return function (...S) {
                const x = y();
                return { textureData: _(...S), timing: y() - x };
              };
            },
            getTransferables(g) {
              return [g.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    m.requests++,
    clearTimeout(m.idleTimer),
    m.workerModule(n, e, t, r, i, o).then(({ textureData: g, timing: y }) => {
      const _ = nf(),
        S = new Uint8Array(g.length * 4);
      for (let x = 0; x < g.length; x++) S[x * 4 + f] = g[x];
      return (
        Xy.webglUtils.renderImageData(s, S, l, u, n, e, 1 << (3 - f)),
        (y += nf() - _),
        --m.requests === 0 &&
          (m.idleTimer = setTimeout(() => {
            vG(h);
          }, zG)),
        { timing: y }
      );
    })
  );
}
function VG(n) {
  n._warm || (Xy.webgl.isSupported(n), (n._warm = !0));
}
const HG = Xy.webglUtils.resizeWebGLCanvasWithoutClearing,
  kp = {
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  GG = new St();
function Vd() {
  return (self.performance || Date).now();
}
const $T = Object.create(null);
function qR(n, e) {
  n = $G({}, n);
  const t = Vd(),
    r = [];
  if (
    (n.font && r.push({ label: "user", src: XG(n.font) }),
    (n.font = r),
    (n.text = "" + n.text),
    (n.sdfGlyphSize = n.sdfGlyphSize || kp.sdfGlyphSize),
    (n.unicodeFontsURL = n.unicodeFontsURL || kp.unicodeFontsURL),
    n.colorRanges != null)
  ) {
    let m = {};
    for (let g in n.colorRanges)
      if (n.colorRanges.hasOwnProperty(g)) {
        let y = n.colorRanges[g];
        typeof y != "number" && (y = GG.set(y).getHex()), (m[g] = y);
      }
    n.colorRanges = m;
  }
  Object.freeze(n);
  const { textureWidth: i, sdfExponent: o } = kp,
    { sdfGlyphSize: s } = n,
    l = (i / s) * 4;
  let u = $T[s];
  if (!u) {
    const m = document.createElement("canvas");
    (m.width = i),
      (m.height = (s * 256) / l),
      (u = $T[s] =
        {
          glyphCount: 0,
          sdfGlyphSize: s,
          sdfCanvas: m,
          sdfTexture: new rr(m, void 0, void 0, void 0, br, br),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (u.sdfTexture.generateMipmaps = !1),
      WG(u);
  }
  const { sdfTexture: f, sdfCanvas: h } = u;
  qG(n).then((m) => {
    const {
        glyphIds: g,
        glyphFontIndices: y,
        fontData: _,
        glyphPositions: S,
        fontSize: x,
        timings: w,
      } = m,
      T = [],
      E = new Float32Array(g.length * 4);
    let A = 0,
      R = 0;
    const D = Vd(),
      I = _.map((H) => {
        let $ = u.glyphsByFont.get(H.src);
        return $ || u.glyphsByFont.set(H.src, ($ = new Map())), $;
      });
    g.forEach((H, $) => {
      const q = y[$],
        { src: K, unitsPerEm: Y } = _[q];
      let ne = I[q].get(H);
      if (!ne) {
        const { path: te, pathBounds: le } = m.glyphData[K][H],
          J =
            (Math.max(le[2] - le[0], le[3] - le[1]) / s) *
            (kp.sdfMargin * s + 0.5),
          oe = u.glyphCount++,
          he = [le[0] - J, le[1] - J, le[2] + J, le[3] + J];
        I[q].set(H, (ne = { path: te, atlasIndex: oe, sdfViewBox: he })),
          T.push(ne);
      }
      const { sdfViewBox: j } = ne,
        re = S[R++],
        B = S[R++],
        G = x / Y;
      (E[A++] = re + j[0] * G),
        (E[A++] = B + j[1] * G),
        (E[A++] = re + j[2] * G),
        (E[A++] = B + j[3] * G),
        (g[$] = ne.atlasIndex);
    }),
      (w.quads = (w.quads || 0) + (Vd() - D));
    const U = Vd();
    w.sdf = {};
    const O = h.height,
      L = Math.ceil(u.glyphCount / l),
      V = Math.pow(2, Math.ceil(Math.log2(L * s)));
    V > O &&
      (console.info(`Increasing SDF texture size ${O}->${V}`),
      HG(h, i, V),
      f.dispose()),
      Promise.all(
        T.map((H) =>
          KR(H, u, n.gpuAccelerateSDF).then(({ timing: $ }) => {
            w.sdf[H.atlasIndex] = $;
          })
        )
      ).then(() => {
        T.length && !u.contextLost && (ZR(u), (f.needsUpdate = !0)),
          (w.sdfTotal = Vd() - U),
          (w.total = Vd() - t),
          e(
            Object.freeze({
              parameters: n,
              sdfTexture: f,
              sdfGlyphSize: s,
              sdfExponent: o,
              glyphBounds: E,
              glyphAtlasIndices: g,
              glyphColors: m.glyphColors,
              caretPositions: m.caretPositions,
              chunkedBounds: m.chunkedBounds,
              ascender: m.ascender,
              descender: m.descender,
              lineHeight: m.lineHeight,
              capHeight: m.capHeight,
              xHeight: m.xHeight,
              topBaseline: m.topBaseline,
              blockBounds: m.blockBounds,
              visibleBounds: m.visibleBounds,
              timings: m.timings,
            })
          );
      });
  }),
    Promise.resolve().then(() => {
      u.contextLost || VG(h);
    });
}
function KR(
  { path: n, atlasIndex: e, sdfViewBox: t },
  { sdfGlyphSize: r, sdfCanvas: i, contextLost: o },
  s
) {
  if (o) return Promise.resolve({ timing: -1 });
  const { textureWidth: l, sdfExponent: u } = kp,
    f = Math.max(t[2] - t[0], t[3] - t[1]),
    h = Math.floor(e / 4),
    m = (h % (l / r)) * r,
    g = Math.floor(h / (l / r)) * r,
    y = e % 4;
  return OG(r, r, n, t, f, u, i, m, g, y, s);
}
function WG(n) {
  const e = n.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), (n.contextLost = !0);
  }),
    e.addEventListener("webglcontextrestored", (t) => {
      console.log("Context Restored", t), (n.contextLost = !1);
      const r = [];
      n.glyphsByFont.forEach((i) => {
        i.forEach((o) => {
          r.push(KR(o, n, !0));
        });
      }),
        Promise.all(r).then(() => {
          ZR(n), (n.sdfTexture.needsUpdate = !0);
        });
    });
}
function jG({ font: n, characters: e, sdfGlyphSize: t }, r) {
  let i = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  qR({ font: n, sdfGlyphSize: t, text: i }, r);
}
function $G(n, e) {
  for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
  return n;
}
let zv;
function XG(n) {
  return (
    zv || (zv = typeof document > "u" ? {} : document.createElement("a")),
    (zv.href = n),
    zv.href
  );
}
function ZR(n) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = n,
      { width: r, height: i } = e,
      o = n.sdfCanvas.getContext("webgl");
    let s = t.image.data;
    (!s || s.length !== r * i * 4) &&
      ((s = new Uint8Array(r * i * 4)),
      (t.image = { width: r, height: i, data: s }),
      (t.flipY = !1),
      (t.isDataTexture = !0)),
      o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, s);
  }
}
const YG = Sh({
    name: "Typesetter",
    dependencies: [kG, DG, xG],
    init(n, e, t) {
      return n(e, t());
    },
  }),
  qG = Sh({
    name: "Typesetter",
    dependencies: [YG],
    init(n) {
      return function (e) {
        return new Promise((t) => {
          n.typeset(e, t);
        });
      };
    },
    getTransferables(n) {
      const e = [];
      for (let t in n) n[t] && n[t].buffer && e.push(n[t].buffer);
      return e;
    },
  }),
  XT = {};
function KG(n) {
  let e = XT[n];
  if (!e) {
    const t = new Ul(1, 1, n, n),
      r = t.clone(),
      i = t.attributes,
      o = r.attributes,
      s = new Kt(),
      l = i.uv.count;
    for (let u = 0; u < l; u++)
      (o.position.array[u * 3] *= -1), (o.normal.array[u * 3 + 2] *= -1);
    ["position", "normal", "uv"].forEach((u) => {
      s.setAttribute(u, new Lt([...i[u].array, ...o[u].array], i[u].itemSize));
    }),
      s.setIndex([...t.index.array, ...r.index.array.map((u) => u + l)]),
      s.translate(0.5, 0.5, 0),
      (e = XT[n] = s);
  }
  return e;
}
const ZG = "aTroikaGlyphBounds",
  YT = "aTroikaGlyphIndex",
  JG = "aTroikaGlyphColor";
class QG extends cw {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new Di()),
      (this.boundingBox = new Qi());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === Zi ? t / 2 : 0, e === Es ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      (this._detail = e), (typeof e != "number" || e < 1) && (e = 1);
      let t = KG(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }),
        this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, t, r, i, o) {
    a1(this, ZG, e, 4),
      a1(this, YT, t, 1),
      a1(this, JG, o, 3),
      (this._blockBounds = r),
      (this._chunkedBounds = i),
      (this.instanceCount = t.length),
      this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: i, floor: o, min: s, max: l, sin: u, cos: f } = Math,
          h = i / 2,
          m = i * 2,
          g = Math.abs(t),
          y = e[0] / g,
          _ = e[2] / g,
          S = o((y + h) / m) !== o((_ + h) / m) ? -g : s(u(y) * g, u(_) * g),
          x = o((y - h) / m) !== o((_ - h) / m) ? g : l(u(y) * g, u(_) * g),
          w =
            o((y + i) / m) !== o((_ + i) / m)
              ? g * 2
              : l(g - f(y) * g, g - f(_) * g);
        r.min.set(S, e[1], t < 0 ? -w : 0), r.max.set(x, e[3], t < 0 ? 0 : w);
      } else r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let t = this.getAttribute(YT).count,
      r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        t = r[i].end;
        let o = r[i].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x) break;
      }
    this.instanceCount = t;
  }
}
function a1(n, e, t, r) {
  const i = n.getAttribute(e);
  t
    ? i && i.array.length === t.length
      ? (i.array.set(t), (i.needsUpdate = !0))
      : (n.setAttribute(e, new cf(t, r)),
        delete n._maxInstanceCount,
        n.dispose())
    : i && n.deleteAttribute(e);
}
const eW = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  tW = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  nW = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  rW = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function iW(n) {
  const e = K1(n, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new tt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new En(0, 0, 0, 0) },
      uTroikaClipRect: { value: new En(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new tt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new St() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Qt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: eW,
    vertexTransform: tW,
    fragmentDefs: nW,
    fragmentColorTransform: rW,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return (
        i.test(r) &&
          ((r = r
            .replace(i, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          i.test(t) ||
            (t = t.replace(
              XR,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: t, fragmentShader: r }
      );
    },
  });
  return (
    (e.transparent = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const xw = new Nl({ color: 16777215, side: Es, transparent: !0 }),
  qT = 8421504,
  KT = new Wt(),
  Bv = new ie(),
  l1 = new ie(),
  Ap = [],
  oW = new ie(),
  u1 = "+x+y";
function ZT(n) {
  return Array.isArray(n) ? n[0] : n;
}
let JR = () => {
    const n = new dr(new Ul(1, 1), xw);
    return (JR = () => n), n;
  },
  QR = () => {
    const n = new dr(new Ul(1, 1, 32, 1), xw);
    return (QR = () => n), n;
  };
const sW = { type: "syncstart" },
  aW = { type: "synccomplete" },
  eP = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  lW = eP.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let tP = class extends dr {
  constructor() {
    const e = new QG();
    super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = qT),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = u1),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(sW),
          qR(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (t) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = t),
                this.geometry.updateGlyphs(
                  t.glyphBounds,
                  t.glyphAtlasIndices,
                  t.blockBounds,
                  t.chunkedBounds,
                  t.glyphColors
                );
              const r = this._queuedSyncs;
              r &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  r.forEach((i) => i && i());
                })),
                this.dispatchEvent(aW),
                e && e();
            }
          )));
  }
  onBeforeRender(e, t, r, i, o, s) {
    this.sync(),
      o.isTroikaTextMaterial && this._prepareForRender(o),
      (o._hadOwnSide = o.hasOwnProperty("side")),
      this.geometry.setSide((o._actualSide = o.side)),
      (o.side = Ga);
  }
  onAfterRender(e, t, r, i, o, s) {
    o._hadOwnSide ? (o.side = o._actualSide) : delete o.side;
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  get material() {
    let e = this._derivedMaterial;
    const t =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = xw.clone());
    if (
      ((!e || e.baseMaterial !== t) &&
        ((e = this._derivedMaterial = iW(t)),
        t.addEventListener("dispose", function r() {
          t.removeEventListener("dispose", r), e.dispose();
        })),
      this.outlineWidth ||
        this.outlineBlur ||
        this.outlineOffsetX ||
        this.outlineOffsetY)
    ) {
      let r = e._outlineMtl;
      return (
        r ||
          ((r = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (r.isTextOutlineMaterial = !0),
          (r.depthWrite = !1),
          (r.map = null),
          e.addEventListener("dispose", function i() {
            e.removeEventListener("dispose", i), r.dispose();
          })),
        [r, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return ZT(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return ZT(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial,
      r = e.uniforms,
      i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: l, blockBounds: u } = i;
      (r.uTroikaSDFTexture.value = l),
        r.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height),
        (r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize),
        (r.uTroikaSDFExponent.value = i.sdfExponent),
        r.uTroikaTotalBounds.value.fromArray(u),
        (r.uTroikaUseGlyphColors.value = !t && !!i.glyphColors);
      let f = 0,
        h = 0,
        m = 0,
        g,
        y,
        _,
        S = 0,
        x = 0;
      if (t) {
        let {
          outlineWidth: T,
          outlineOffsetX: E,
          outlineOffsetY: A,
          outlineBlur: R,
          outlineOpacity: D,
        } = this;
        (f = this._parsePercent(T) || 0),
          (h = Math.max(0, this._parsePercent(R) || 0)),
          (g = D),
          (S = this._parsePercent(E) || 0),
          (x = this._parsePercent(A) || 0);
      } else
        (m = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          m &&
            ((_ = this.strokeColor),
            r.uTroikaStrokeColor.value.set(_ ?? qT),
            (y = this.strokeOpacity),
            y == null && (y = 1)),
          (g = this.fillOpacity);
      (r.uTroikaDistanceOffset.value = f),
        r.uTroikaPositionOffset.value.set(S, x),
        (r.uTroikaBlurRadius.value = h),
        (r.uTroikaStrokeWidth.value = m),
        (r.uTroikaStrokeOpacity.value = y),
        (r.uTroikaFillOpacity.value = g ?? 1),
        (r.uTroikaCurveRadius.value = this.curveRadius || 0);
      let w = this.clipRect;
      if (w && Array.isArray(w) && w.length === 4)
        r.uTroikaClipRect.value.fromArray(w);
      else {
        const T = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(u[0] - T, u[1] - T, u[2] + T, u[3] + T);
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    (r.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0);
    const o = t ? this.outlineColor || 0 : this.color;
    if (o == null) delete e.color;
    else {
      const l = e.hasOwnProperty("color") ? e.color : (e.color = new St());
      (o !== l._input || typeof o == "object") && l.set((l._input = o));
    }
    let s = this.orientation || u1;
    if (s !== e._orientation) {
      let l = r.uTroikaOrient.value;
      s = s.replace(/[^-+xyz]/g, "");
      let u = s !== u1 && s.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (u) {
        let [, f, h, m, g] = u;
        (Bv.set(0, 0, 0)[h] = f === "-" ? 1 : -1),
          (l1.set(0, 0, 0)[g] = m === "-" ? -1 : 1),
          KT.lookAt(oW, Bv.cross(l1), l1),
          l.setFromMatrix4(KT);
      } else l.identity();
      e._orientation = s;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/),
        r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, t = new tt()) {
    t.copy(e);
    const r = this.curveRadius;
    return (
      r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t
    );
  }
  worldPositionToTextCoords(e, t = new tt()) {
    return Bv.copy(e), this.localPositionToTextCoords(this.worldToLocal(Bv), t);
  }
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const o = r.blockBounds,
        s = i ? QR() : JR(),
        l = s.geometry,
        { position: u, uv: f } = l.attributes;
      for (let h = 0; h < f.count; h++) {
        let m = o[0] + f.getX(h) * (o[2] - o[0]);
        const g = o[1] + f.getY(h) * (o[3] - o[1]);
        let y = 0;
        i && ((y = i - Math.cos(m / i) * i), (m = Math.sin(m / i) * i)),
          u.setXYZ(h, m, g, y);
      }
      (l.boundingSphere = this.geometry.boundingSphere),
        (l.boundingBox = this.geometry.boundingBox),
        (s.matrixWorld = this.matrixWorld),
        (s.material.side = this.material.side),
        (Ap.length = 0),
        s.raycast(e, Ap);
      for (let h = 0; h < Ap.length; h++) (Ap[h].object = this), t.push(Ap[h]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return (
      super.copy(e),
      (this.geometry = t),
      lW.forEach((r) => {
        this[r] = e[r];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
eP.forEach((n) => {
  const e = "_private_" + n;
  Object.defineProperty(tP.prototype, n, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && ((this[e] = t), (this._needsSync = !0));
    },
  });
});
const J1 = ee.forwardRef(
    (
      {
        sdfGlyphSize: n = 64,
        anchorX: e = "center",
        anchorY: t = "middle",
        font: r,
        fontSize: i = 1,
        children: o,
        characters: s,
        onSync: l,
        ...u
      },
      f
    ) => {
      const h = Sl(({ invalidate: _ }) => _),
        [m] = ee.useState(() => new tP()),
        [g, y] = ee.useMemo(() => {
          const _ = [];
          let S = "";
          return (
            ee.Children.forEach(o, (x) => {
              typeof x == "string" || typeof x == "number"
                ? (S += x)
                : _.push(x);
            }),
            [_, S]
          );
        }, [o]);
      return (
        M8(
          () => new Promise((_) => jG({ font: r, characters: s }, _)),
          ["troika-text", r, s]
        ),
        ee.useLayoutEffect(
          () =>
            void m.sync(() => {
              h(), l && l(m);
            })
        ),
        ee.useEffect(() => () => m.dispose(), [m]),
        ee.createElement(
          "primitive",
          pe(
            {
              object: m,
              ref: f,
              font: r,
              text: y,
              anchorX: e,
              anchorY: t,
              fontSize: i,
              sdfGlyphSize: n,
            },
            u
          ),
          g
        )
      );
    }
  ),
  nP = ee.forwardRef(
    (
      {
        makeDefault: n,
        camera: e,
        regress: t,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: o = !1,
        onChange: s,
        onStart: l,
        onEnd: u,
        ...f
      },
      h
    ) => {
      const m = Sl((D) => D.invalidate),
        g = Sl((D) => D.camera),
        y = Sl((D) => D.gl),
        _ = Sl((D) => D.events),
        S = Sl((D) => D.setEvents),
        x = Sl((D) => D.set),
        w = Sl((D) => D.get),
        T = Sl((D) => D.performance),
        E = e || g,
        A = r || _.connected || y.domElement,
        R = ee.useMemo(() => new dG(E), [E]);
      return (
        $y(() => {
          R.enabled && R.update();
        }, -1),
        ee.useEffect(
          () => (
            o && R.connect(o === !0 ? A : o),
            R.connect(A),
            () => void R.dispose()
          ),
          [o, A, t, R, m]
        ),
        ee.useEffect(() => {
          const D = (O) => {
              m(), t && T.regress(), s && s(O);
            },
            I = (O) => {
              l && l(O);
            },
            U = (O) => {
              u && u(O);
            };
          return (
            R.addEventListener("change", D),
            R.addEventListener("start", I),
            R.addEventListener("end", U),
            () => {
              R.removeEventListener("start", I),
                R.removeEventListener("end", U),
                R.removeEventListener("change", D);
            }
          );
        }, [s, l, u, R, m, S]),
        ee.useEffect(() => {
          if (n) {
            const D = w().controls;
            return x({ controls: R }), () => x({ controls: D });
          }
        }, [n, R]),
        ee.createElement(
          "primitive",
          pe({ ref: h, object: R, enableDamping: i }, f)
        )
      );
    }
  );
yn.enabled = !0;
const Vv = 5,
  JT = 1,
  Tl = Array.from({ length: 10 }, (n, e) => {
    const t = (e / 10) * 2 * Math.PI,
      r = Math.cos(t) * Vv,
      i = Math.sin(t) * Vv,
      o = Math.cos(t) * (Vv + JT),
      s = Math.sin(t) * (Vv + JT);
    return {
      id: e,
      position: [r, 0, i],
      labelPosition: [o, 0.4, s],
      label: ` ${e + 1}`,
    };
  }),
  rP = [];
for (let n = 0; n < Tl.length; n++)
  for (let e = n + 1; e < Tl.length; e++)
    rP.push({ start: Tl[n].position, end: Tl[e].position, key: `${n}-${e}` });
function uW({
  position: n,
  label: e,
  isValidator: t,
  isSender: r,
  isReceiver: i,
  isHighlighted: o,
  phase: s,
}) {
  const l = ee.useRef();
  $y(({ camera: f }) => {
    l.current && l.current.quaternion.copy(f.quaternion);
  });
  let u = "#c62828";
  return (
    s === "transaction" && r
      ? (u = "#2e7d32")
      : s === "transaction" && i
      ? (u = "#ad1457")
      : t && o && (u = "blue"),
    ve.jsxs("group", {
      position: n,
      scale: [1, 1, 1],
      children: [
        ve.jsxs("mesh", {
          children: [
            ve.jsx("sphereGeometry", { args: [0.3, 32, 32] }),
            ve.jsx("meshBasicMaterial", { color: u }),
          ],
        }),
        ve.jsx(J1, {
          ref: l,
          position: [0, 1, 0],
          fontSize: 0.4,
          color: "white",
          anchorX: "center",
          anchorY: "middle",
          children: e,
        }),
      ],
    })
  );
}
function cW({ start: n, end: e, isActive: t }) {
  const r = [new ie(...n), new ie(...e)],
    i = new Kt().setFromPoints(r);
  return ve.jsxs("line", {
    children: [
      ve.jsx("bufferGeometry", { attach: "geometry", ...i }),
      ve.jsx("lineBasicMaterial", {
        color: t ? "yellow" : "#00695c",
        linewidth: t ? 4 : 2,
      }),
    ],
  });
}
function fW({ start: n, end: e, progress: t }) {
  const r = [
    n[0] + (e[0] - n[0]) * t,
    n[1] + (e[1] - n[1]) * t,
    n[2] + (e[2] - n[2]) * t,
  ];
  return ve.jsxs("mesh", {
    position: r,
    children: [
      ve.jsx("boxGeometry", { args: [0.3, 0.3, 0.3] }),
      ve.jsx("meshBasicMaterial", { color: "#2e7d32" }),
    ],
  });
}
function dW({ start: n, end: e, progress: t }) {
  const r = [
    n[0] + (e[0] - n[0]) * t,
    n[1] + (e[1] - n[1]) * t,
    n[2] + (e[2] - n[2]) * t,
  ];
  return ve.jsxs("mesh", {
    position: r,
    children: [
      ve.jsx("boxGeometry", { args: [0.3, 0.3, 0.3] }),
      ve.jsx("meshBasicMaterial", { color: "blue" }),
    ],
  });
}
function hW({ controlsRef: n }) {
  const e = cC(),
    {
      sender: t,
      receiver: r,
      validator: i,
      phase: o,
      transactionProgress: s,
    } = W0((g) => g.simulation),
    [l, u] = ee.useState(0);
  ee.useEffect(() => {
    console.log("Scene phase:", o), o === "idle" && u(0);
  }, [o]),
    $y((g, y) => {
      if (o === "transaction" && s < 1) {
        const _ = Math.min(s + y / 5, 1);
        e(o_(_)), _ >= 1 && e(JU());
      } else if (o === "validation")
        u((_) => _ + y), l >= 2 && (e(QU()), e(o_(0)), u(0));
      else if (o === "broadcast" && s < 1) {
        const _ = Math.min(s + y / 4, 1);
        e(o_(_)), _ >= 1 && setTimeout(() => e(eF()), 1e3);
      }
    });
  const f = t !== null ? Tl[t] : null,
    h = r !== null ? Tl[r] : null,
    m = i !== null ? Tl[i] : null;
  return ve.jsxs(ve.Fragment, {
    children: [
      ve.jsx("ambientLight", { intensity: 0.5 }),
      ve.jsx("pointLight", { position: [10, 10, 10], intensity: 1 }),
      Tl.map((g) =>
        ve.jsx(
          uW,
          {
            position: g.position,
            label: g.label,
            isValidator: m && g.id === m.id,
            isSender: f && g.id === f.id,
            isReceiver: h && g.id === h.id,
            isHighlighted:
              o === "validation" || o === "broadcast" || o === "complete",
            phase: o,
          },
          g.id
        )
      ),
      rP.map((g) => {
        const y =
          o === "transaction" &&
          f &&
          h &&
          ((g.start === f.position && g.end === h.position) ||
            (g.start === h.position && g.end === f.position));
        return ve.jsx(cW, { start: g.start, end: g.end, isActive: y }, g.key);
      }),
      o === "transaction" &&
        f &&
        h &&
        s < 1 &&
        ve.jsx(fW, { start: f.position, end: h.position, progress: s }),
      o === "broadcast" &&
        m &&
        Tl.filter((g) => g.id !== m.id).map((g) =>
          ve.jsx(
            dW,
            { start: m.position, end: g.position, progress: s },
            `broadcast-${g.id}`
          )
        ),
      (o === "validation" || o === "broadcast" || o === "complete") &&
        m &&
        ve.jsx(ve.Fragment, {}),
      ve.jsx(nP, {
        ref: n,
        enablePan: !0,
        enableZoom: !0,
        enableRotate: !0,
        target: [0, 0, 0],
      }),
    ],
  });
}
function QT({ position: n, opacity: e = 1 }) {
  return ve.jsxs("mesh", {
    position: n,
    scale: [1, 1, 1],
    children: [
      ve.jsx("boxGeometry", { args: [0.6, 0.6, 0.6] }),
      ve.jsx("meshBasicMaterial", {
        color: "#2e7d32",
        opacity: e,
        transparent: !0,
      }),
    ],
  });
}
function pW({ start: n, end: e }) {
  const t = [new ie(...n), new ie(...e)],
    r = new Kt().setFromPoints(t);
  return ve.jsxs("line", {
    children: [
      ve.jsx("bufferGeometry", { attach: "geometry", ...r }),
      ve.jsx("lineBasicMaterial", { color: "#b0bec5", linewidth: 6 }),
    ],
  });
}
function mW({ phase: n }) {
  const [e, t] = ee.useState([
      { id: 1, x: -12 },
      { id: 2, x: -8 },
      { id: 3, x: -4 },
      { id: 4, x: 0 },
    ]),
    [r, i] = ee.useState(null),
    [o, s] = ee.useState(null),
    [l, u] = ee.useState(!1),
    [f, h] = ee.useState(null),
    m = [
      { id: 1, x: -12 },
      { id: 2, x: -8 },
      { id: 3, x: -4 },
      { id: 4, x: 0 },
    ];
  ee.useEffect(() => {
    if ((console.log("Ledger phase:", n, "LedgerBlocks:", e), n === "idle"))
      t(m), i(null), s(null), u(!1), h(null), console.log("Ledger reset");
    else if (n === "broadcast" && !r && !l) {
      const y = e.length + 1;
      i({ id: y }), s(8), u(!0), console.log("New block initialized at x=8.0");
    } else
      n === "complete" &&
        (u(!1), console.log("Reset hasAddedBlock for next cycle"));
  }, [n, r, l, e.length]),
    $y((y, _) => {
      r &&
        o !== null &&
        s((S) => {
          const w = Math.max(S - (_ * 4) / 2, 4);
          return (
            console.log(`New block x: ${w}`),
            w <= 4 &&
              (t((T) => [...T, { id: r.id, x: 4 }]),
              h(r.id),
              i(null),
              s(null),
              console.log("New block added to ledger at x=4.0, id:", r.id)),
            w
          );
        });
    });
  const g = [];
  for (let y = 0; y < e.length - 1; y++)
    g.push({
      start: [e[y].x + 0.3, 0, 0],
      end: [e[y + 1].x - 0.3, 0, 0],
      key: `line-${y}`,
    });
  if (r && o !== null && o <= 4.5 && e.length > 0) {
    const y = e[e.length - 1].x;
    g.push({
      start: [y + 0.3, 0, 0],
      end: [o - 0.3, 0, 0],
      key: `line-new-${r.id}`,
    }),
      console.log(`Line: start=${y + 0.3}, end=${o - 0.3}`);
  }
  return ve.jsxs(ve.Fragment, {
    children: [
      ve.jsx("ambientLight", { intensity: 0.5 }),
      ve.jsx("pointLight", { position: [10, 10, 10], intensity: 1 }),
      e.map((y) =>
        ve.jsxs(
          Ts.Fragment,
          {
            children: [
              ve.jsx(QT, { position: [y.x, 0, 0] }),
              y.id === f &&
                ve.jsx(J1, {
                  position: [y.x, -0.5, 0],
                  fontSize: 0.35,
                  color: "white",
                  anchorX: "center",
                  anchorY: "middle",
                  children: "Newly Mined Block",
                }),
            ],
          },
          y.id
        )
      ),
      r &&
        o !== null &&
        ve.jsx(
          QT,
          { position: [o, 0, 0], opacity: (8 - o) / 4 },
          `new-${r.id}`
        ),
      g.map((y) => ve.jsx(pW, { start: y.start, end: y.end }, y.key)),
      ve.jsx(J1, {
        position: [-6, -0.5, 0],
        fontSize: 0.35,
        color: "white",
        anchorX: "center",
        anchorY: "middle",
        children: "Ledger",
      }),
    ],
  });
}
function gW({ phase: n }) {
  const [e, t] = ee.useState("2d"),
    r = ee.useRef(),
    i = () => {
      t("3d");
    };
  return (
    ee.useEffect(() => {
      console.log("Ledger viewMode:", e);
      const o = r.current;
      if (o)
        return (
          o.addEventListener("start", i),
          () => o.removeEventListener("start", i)
        );
    }, []),
    ve.jsx(Qr, {
      sx: {
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
      },
      children: ve.jsxs(WR, {
        orthographic: e === "2d",
        camera:
          e === "2d"
            ? {
                position: [0, 0, 10],
                zoom: 30,
                up: [0, 1, 0],
                near: 0.1,
                far: 1e3,
              }
            : { position: [0, 15, 20], fov: 60, near: 0.1, far: 1e3 },
        style: { height: "120px", width: "100%" },
        gl: { outputEncoding: void 0 },
        children: [
          ve.jsx(mW, { phase: n }),
          ve.jsx(nP, {
            ref: r,
            enablePan: !0,
            enableZoom: !0,
            enableRotate: !0,
            target: [-6, 0, 0],
          }),
        ],
      }),
    })
  );
}
function vW() {
  return ve.jsx(Qr, {
    sx: {
      width: "100%",
      backgroundColor: "#1a202c",
      color: "white",
      padding: 2,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
    },
    children: ve.jsxs(o2, {
      spacing: 1,
      children: [
        ve.jsxs(Qr, {
          display: "flex",
          alignItems: "center",
          children: [
            ve.jsx(Qr, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "#2e7d32",
                marginRight: 1,
              },
            }),
            ve.jsx(Np, { variant: "body2", children: "Sender" }),
          ],
        }),
        ve.jsxs(Qr, {
          display: "flex",
          alignItems: "center",
          children: [
            ve.jsx(Qr, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "#ad1457",
                marginRight: 1,
              },
            }),
            ve.jsx(Np, { variant: "body2", children: "Receiver" }),
          ],
        }),
        ve.jsxs(Qr, {
          display: "flex",
          alignItems: "center",
          children: [
            ve.jsx(Qr, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "blue",
                marginRight: 1,
              },
            }),
            ve.jsx(Np, { variant: "body2", children: "Validator" }),
          ],
        }),
      ],
    }),
  });
}
function yW() {
  const { phase: n, validator: e } = W0((o) => o.simulation),
    [t, r] = ee.useState([]);
  ee.useEffect(() => {
    console.log("Steps phase:", n, "Steps:", t),
      n === "idle"
        ? (r([]), console.log("Steps reset"))
        : n === "transaction" && !t.includes("step1")
        ? r((o) => [...o, "step1"])
        : n === "broadcast" && !t.includes("step2")
        ? r((o) => [...o, "step2"])
        : n === "complete" && !t.includes("step3") && r((o) => [...o, "step3"]);
  }, [n, t]);
  const i = (o) => {
    switch (o) {
      case "step1":
        return "Step 1: The sender initiates a transaction to the receiver.";
      case "step2":
        return `Step 2: Node ${
          e + 1
        } validates the transaction, adds the new block to the ledger, and distributes it to all nodes in the network.`;
      case "step3":
        return "Step 3: The transaction is finalized on the blockchain. A smart contract enforces predefined rules to ensure trust and transparency. The validator records the new block in the ledger, synchronizing it across all nodes and demonstrating decentralized consensus.";
      default:
        return "";
    }
  };
  return ve.jsx(Qr, {
    sx: {
      width: "100%",
      backgroundColor: "#1a202c",
      color: "white",
      padding: 3,
      display: "flex",
      flexDirection: "column",
      overflow: "auto",
      flexGrow: 1,
    },
    children: ve.jsx(o2, {
      spacing: 1.5,
      children: t.map((o, s) =>
        ve.jsx(
          Np,
          {
            variant: "body2",
            sx: {
              lineHeight: 1.7,
              fontSize: "1rem",
              whiteSpace: "normal",
              overflowWrap: "break-word",
              display: "block",
              paddingRight: 5,
              color: o === "step3" ? "#FFD700" : "white",
            },
            children: i(o),
          },
          s
        )
      ),
    }),
  });
}
function xW() {
  const [n, e] = ee.useState("2d"),
    t = ee.useRef(),
    { phase: r } = W0((s) => s.simulation),
    i = () => {
      e("3d");
    };
  ee.useEffect(() => {
    console.log("DecagonSimulation phase:", r);
    const s = t.current;
    if (s)
      return (
        s.addEventListener("start", i), () => s.removeEventListener("start", i)
      );
  }, [r]);
  const o =
    r === "transaction"
      ? "Transaction Initiation"
      : r === "validation" || r === "broadcast" || r === "complete"
      ? "Transaction Process"
      : "Smart Contract - Transaction Process";
  return ve.jsxs(Qr, {
    sx: { display: "flex", height: "100%", width: "100%" },
    children: [
      ve.jsxs(Qr, {
        sx: {
          width: "75%",
          height: "100%",
          display: "flex",
          flexDirection: "column",
        },
        children: [
          ve.jsx(Qr, {
            sx: {
              padding: 1,
              textAlign: "center",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
            },
            children: ve.jsx(Np, {
              variant: "h5",
              sx: {
                color: "white",
                fontSize: "1.5rem",
                width: "100%",
                textAlign: "center",
              },
              children: o,
            }),
          }),
          ve.jsx(Qr, {
            sx: { flexGrow: 1, overflow: "hidden" },
            children: ve.jsx(WR, {
              orthographic: n === "2d",
              camera:
                n === "2d"
                  ? {
                      position: [0, 10, 0],
                      zoom: 30,
                      up: [0, 1, 0],
                      near: 0.1,
                      far: 1e3,
                    }
                  : { position: [0, 10, 15], fov: 60, near: 0.1, far: 1e3 },
              style: { width: "100%" },
              gl: { outputEncoding: void 0 },
              children: ve.jsx(hW, { controlsRef: t }),
            }),
          }),
          ve.jsx(gW, { phase: r }),
        ],
      }),
      ve.jsxs(Qr, {
        sx: {
          width: "25%",
          minWidth: "280px",
          display: "flex",
          flexDirection: "column",
          height: "100%",
          boxSizing: "border-box",
          padding: 0.5,
        },
        children: [ve.jsx(vW, {}), ve.jsx(yW, {})],
      }),
    ],
  });
}
function _W(n) {
  const { rootElementName: e = "" } = n,
    [t, r] = ee.useState(e.toUpperCase()),
    i = ee.useCallback((o) => {
      var s;
      r((s = o == null ? void 0 : o.tagName) != null ? s : "");
    }, []);
  return [t, i];
}
function SW(n = {}) {
  const {
      disabled: e = !1,
      focusableWhenDisabled: t,
      href: r,
      rootRef: i,
      tabIndex: o,
      to: s,
      type: l,
      rootElementName: u,
    } = n,
    f = ee.useRef(null),
    [h, m] = ee.useState(!1),
    { isFocusVisibleRef: g, onFocus: y, onBlur: _, ref: S } = GC(),
    [x, w] = ee.useState(!1);
  e && !t && x && w(!1),
    ee.useEffect(() => {
      g.current = x;
    }, [x, g]);
  const [T, E] = _W({ rootElementName: u ?? (r || s ? "a" : void 0) }),
    A = (K) => (Y) => {
      var ne;
      x && Y.preventDefault(), (ne = K.onMouseLeave) == null || ne.call(K, Y);
    },
    R = (K) => (Y) => {
      var ne;
      _(Y), g.current === !1 && w(!1), (ne = K.onBlur) == null || ne.call(K, Y);
    },
    D = (K) => (Y) => {
      var ne;
      if (
        (f.current || (f.current = Y.currentTarget), y(Y), g.current === !0)
      ) {
        var j;
        w(!0), (j = K.onFocusVisible) == null || j.call(K, Y);
      }
      (ne = K.onFocus) == null || ne.call(K, Y);
    },
    I = () => {
      const K = f.current;
      return (
        T === "BUTTON" ||
        (T === "INPUT" &&
          ["button", "submit", "reset"].includes(
            K == null ? void 0 : K.type
          )) ||
        (T === "A" && (K == null ? void 0 : K.href))
      );
    },
    U = (K) => (Y) => {
      if (!e) {
        var ne;
        (ne = K.onClick) == null || ne.call(K, Y);
      }
    },
    O = (K) => (Y) => {
      var ne;
      e ||
        (m(!0),
        document.addEventListener(
          "mouseup",
          () => {
            m(!1);
          },
          { once: !0 }
        )),
        (ne = K.onMouseDown) == null || ne.call(K, Y);
    },
    L = (K) => (Y) => {
      var ne;
      if (
        ((ne = K.onKeyDown) == null || ne.call(K, Y),
        !Y.defaultMuiPrevented &&
          (Y.target === Y.currentTarget &&
            !I() &&
            Y.key === " " &&
            Y.preventDefault(),
          Y.target === Y.currentTarget && Y.key === " " && !e && m(!0),
          Y.target === Y.currentTarget && !I() && Y.key === "Enter" && !e))
      ) {
        var j;
        (j = K.onClick) == null || j.call(K, Y), Y.preventDefault();
      }
    },
    V = (K) => (Y) => {
      var ne;
      if (
        (Y.target === Y.currentTarget && m(!1),
        (ne = K.onKeyUp) == null || ne.call(K, Y),
        Y.target === Y.currentTarget &&
          !I() &&
          !e &&
          Y.key === " " &&
          !Y.defaultMuiPrevented)
      ) {
        var j;
        (j = K.onClick) == null || j.call(K, Y);
      }
    },
    H = xi(E, i, S, f),
    $ = {};
  return (
    o !== void 0 && ($.tabIndex = o),
    T === "BUTTON"
      ? (($.type = l ?? "button"),
        t ? ($["aria-disabled"] = e) : ($.disabled = e))
      : T === "INPUT"
      ? l &&
        ["button", "submit", "reset"].includes(l) &&
        (t ? ($["aria-disabled"] = e) : ($.disabled = e))
      : T !== "" &&
        (!r && !s && (($.role = "button"), ($.tabIndex = o ?? 0)),
        e && (($["aria-disabled"] = e), ($.tabIndex = t ? o ?? 0 : -1))),
    {
      getRootProps: (K = {}) => {
        const Y = pe({}, t0(n), t0(K)),
          ne = pe({ type: l }, Y, $, K, {
            onBlur: R(Y),
            onClick: U(Y),
            onFocus: D(Y),
            onKeyDown: L(Y),
            onKeyUp: V(Y),
            onMouseDown: O(Y),
            onMouseLeave: A(Y),
            ref: H,
          });
        return delete ne.onFocusVisible, ne;
      },
      focusVisible: x,
      setFocusVisible: w,
      active: h,
      rootRef: H,
    }
  );
}
const iP = "$$joy",
  wW = pe({}, mh, {
    borderRadius: { themeKey: "radius" },
    boxShadow: { themeKey: "shadow" },
    fontFamily: { themeKey: "fontFamily" },
    fontSize: { themeKey: "fontSize" },
    fontWeight: { themeKey: "fontWeight" },
    letterSpacing: { themeKey: "letterSpacing" },
    lineHeight: { themeKey: "lineHeight" },
  }),
  Rp = {
    grey: {
      50: "#FBFCFE",
      100: "#F0F4F8",
      200: "#DDE7EE",
      300: "#CDD7E1",
      400: "#9FA6AD",
      500: "#636B74",
      600: "#555E68",
      700: "#32383E",
      800: "#171A1C",
      900: "#0B0D0E",
    },
    blue: {
      50: "#EDF5FD",
      100: "#E3EFFB",
      200: "#C7DFF7",
      300: "#97C3F0",
      400: "#4393E4",
      500: "#0B6BCB",
      600: "#185EA5",
      700: "#12467B",
      800: "#0A2744",
      900: "#051423",
    },
    yellow: {
      50: "#FEFAF6",
      100: "#FDF0E1",
      200: "#FCE1C2",
      300: "#F3C896",
      400: "#EA9A3E",
      500: "#9A5B13",
      600: "#72430D",
      700: "#492B08",
      800: "#2E1B05",
      900: "#1D1002",
    },
    red: {
      50: "#FEF6F6",
      100: "#FCE4E4",
      200: "#F7C5C5",
      300: "#F09898",
      400: "#E47474",
      500: "#C41C1C",
      600: "#A51818",
      700: "#7D1212",
      800: "#430A0A",
      900: "#240505",
    },
    green: {
      50: "#F6FEF6",
      100: "#E3FBE3",
      200: "#C7F7C7",
      300: "#A1E8A1",
      400: "#51BC51",
      500: "#1F7A1F",
      600: "#136C13",
      700: "#0A470A",
      800: "#042F04",
      900: "#021D02",
    },
  };
function MW(n) {
  var e;
  return (
    !!n[0].match(/^(typography|variants|breakpoints)$/) ||
    !!n[0].match(/sxConfig$/) ||
    (n[0] === "palette" && !!((e = n[1]) != null && e.match(/^(mode)$/))) ||
    (n[0] === "focus" && n[1] !== "thickness")
  );
}
const _w = (n, e) => hr(n, e, "Mui"),
  oP = (n, e) => Xn(n, e, "Mui"),
  bW = (n) =>
    n &&
    typeof n == "object" &&
    Object.keys(n).some((e) => {
      var t;
      return (t = e.match) == null
        ? void 0
        : t.call(
            e,
            /^(plain(Hover|Active|Disabled)?(Color|Bg)|outlined(Hover|Active|Disabled)?(Color|Border|Bg)|soft(Hover|Active|Disabled)?(Color|Bg)|solid(Hover|Active|Disabled)?(Color|Bg))$/
          );
    }),
  eC = (n, e, t) => {
    e.includes("Color") && (n.color = t),
      e.includes("Bg") && (n.backgroundColor = t),
      e.includes("Border") && (n.borderColor = t);
  },
  tC = (n, e, t) => {
    const r = {};
    return (
      Object.entries(e || {}).forEach(([i, o]) => {
        if (i.match(new RegExp(`${n}(color|bg|border)`, "i")) && o) {
          const s = t ? t(i) : o;
          i.includes("Disabled") &&
            ((r.pointerEvents = "none"),
            (r.cursor = "default"),
            (r["--Icon-color"] = "currentColor")),
            i.match(/(Hover|Active|Disabled)/) ||
              (r["--variant-borderWidth"] ||
                (r["--variant-borderWidth"] = "0px"),
              i.includes("Border") &&
                ((r["--variant-borderWidth"] = "1px"),
                (r.border = "var(--variant-borderWidth) solid"))),
            eC(r, i, s);
        }
      }),
      r
    );
  },
  Xi = (n, e) => {
    let t = {};
    if (e) {
      const { getCssVar: r, palette: i } = e;
      Object.entries(i).forEach((o) => {
        const [s, l] = o;
        bW(l) &&
          typeof l == "object" &&
          (t = pe({}, t, {
            [s]: tC(
              n,
              l,
              (u) => `var(--variant-${u}, ${r(`palette-${s}-${u}`, i[s][u])})`
            ),
          }));
      });
    }
    return (
      (t.context = tC(n, {
        plainColor: "var(--variant-plainColor)",
        plainHoverColor: "var(--variant-plainHoverColor)",
        plainHoverBg: "var(--variant-plainHoverBg)",
        plainActiveBg: "var(--variant-plainActiveBg)",
        plainDisabledColor: "var(--variant-plainDisabledColor)",
        outlinedColor: "var(--variant-outlinedColor)",
        outlinedBorder: "var(--variant-outlinedBorder)",
        outlinedHoverColor: "var(--variant-outlinedHoverColor)",
        outlinedHoverBorder: "var(--variant-outlinedHoverBorder)",
        outlinedHoverBg: "var(--variant-outlinedHoverBg)",
        outlinedActiveBg: "var(--variant-outlinedActiveBg)",
        outlinedDisabledColor: "var(--variant-outlinedDisabledColor)",
        outlinedDisabledBorder: "var(--variant-outlinedDisabledBorder)",
        softColor: "var(--variant-softColor)",
        softBg: "var(--variant-softBg)",
        softHoverColor: "var(--variant-softHoverColor)",
        softHoverBg: "var(--variant-softHoverBg)",
        softActiveBg: "var(--variant-softActiveBg)",
        softDisabledColor: "var(--variant-softDisabledColor)",
        softDisabledBg: "var(--variant-softDisabledBg)",
        solidColor: "var(--variant-solidColor)",
        solidBg: "var(--variant-solidBg)",
        solidHoverBg: "var(--variant-solidHoverBg)",
        solidActiveBg: "var(--variant-solidActiveBg)",
        solidDisabledColor: "var(--variant-solidDisabledColor)",
        solidDisabledBg: "var(--variant-solidDisabledBg)",
      })),
      t
    );
  },
  EW = [
    "cssVarPrefix",
    "breakpoints",
    "spacing",
    "components",
    "variants",
    "shouldSkipGeneratingVar",
  ],
  TW = ["colorSchemes"],
  CW = (n = "joy") => KL(n);
function AW(n) {
  var e, t, r, i, o, s, l, u, f, h;
  const m = {},
    {
      cssVarPrefix: g = "joy",
      breakpoints: y,
      spacing: _,
      components: S,
      variants: x,
      shouldSkipGeneratingVar: w = MW,
    } = m,
    T = Ft(m, EW),
    E = CW(g),
    A = {
      primary: Rp.blue,
      neutral: Rp.grey,
      danger: Rp.red,
      success: Rp.green,
      warning: Rp.yellow,
      common: { white: "#FFF", black: "#000" },
    },
    R = (ue) => {
      var Ee;
      const Ne = ue.split("-"),
        Ae = Ne[1],
        W = Ne[2];
      return E(ue, (Ee = A[Ae]) == null ? void 0 : Ee[W]);
    },
    D = (ue) => ({
      plainColor: R(`palette-${ue}-500`),
      plainHoverBg: R(`palette-${ue}-100`),
      plainActiveBg: R(`palette-${ue}-200`),
      plainDisabledColor: R("palette-neutral-400"),
      outlinedColor: R(`palette-${ue}-500`),
      outlinedBorder: R(`palette-${ue}-300`),
      outlinedHoverBg: R(`palette-${ue}-100`),
      outlinedActiveBg: R(`palette-${ue}-200`),
      outlinedDisabledColor: R("palette-neutral-400"),
      outlinedDisabledBorder: R("palette-neutral-200"),
      softColor: R(`palette-${ue}-700`),
      softBg: R(`palette-${ue}-100`),
      softHoverBg: R(`palette-${ue}-200`),
      softActiveColor: R(`palette-${ue}-800`),
      softActiveBg: R(`palette-${ue}-300`),
      softDisabledColor: R("palette-neutral-400"),
      softDisabledBg: R("palette-neutral-50"),
      solidColor: R("palette-common-white"),
      solidBg: R(`palette-${ue}-500`),
      solidHoverBg: R(`palette-${ue}-600`),
      solidActiveBg: R(`palette-${ue}-700`),
      solidDisabledColor: R("palette-neutral-400"),
      solidDisabledBg: R("palette-neutral-100"),
    }),
    I = (ue) => ({
      plainColor: R(`palette-${ue}-300`),
      plainHoverBg: R(`palette-${ue}-800`),
      plainActiveBg: R(`palette-${ue}-700`),
      plainDisabledColor: R("palette-neutral-500"),
      outlinedColor: R(`palette-${ue}-200`),
      outlinedBorder: R(`palette-${ue}-700`),
      outlinedHoverBg: R(`palette-${ue}-800`),
      outlinedActiveBg: R(`palette-${ue}-700`),
      outlinedDisabledColor: R("palette-neutral-500"),
      outlinedDisabledBorder: R("palette-neutral-800"),
      softColor: R(`palette-${ue}-200`),
      softBg: R(`palette-${ue}-800`),
      softHoverBg: R(`palette-${ue}-700`),
      softActiveColor: R(`palette-${ue}-100`),
      softActiveBg: R(`palette-${ue}-600`),
      softDisabledColor: R("palette-neutral-500"),
      softDisabledBg: R("palette-neutral-800"),
      solidColor: R("palette-common-white"),
      solidBg: R(`palette-${ue}-500`),
      solidHoverBg: R(`palette-${ue}-600`),
      solidActiveBg: R(`palette-${ue}-700`),
      solidDisabledColor: R("palette-neutral-500"),
      solidDisabledBg: R("palette-neutral-800"),
    }),
    U = {
      palette: {
        mode: "light",
        primary: pe({}, A.primary, D("primary")),
        neutral: pe({}, A.neutral, D("neutral"), {
          plainColor: R("palette-neutral-700"),
          plainHoverColor: R("palette-neutral-900"),
          outlinedColor: R("palette-neutral-700"),
        }),
        danger: pe({}, A.danger, D("danger")),
        success: pe({}, A.success, D("success")),
        warning: pe({}, A.warning, D("warning")),
        common: { white: "#FFF", black: "#000" },
        text: {
          primary: R("palette-neutral-800"),
          secondary: R("palette-neutral-700"),
          tertiary: R("palette-neutral-600"),
          icon: R("palette-neutral-500"),
        },
        background: {
          body: R("palette-common-white"),
          surface: R("palette-neutral-50"),
          popup: R("palette-common-white"),
          level1: R("palette-neutral-100"),
          level2: R("palette-neutral-200"),
          level3: R("palette-neutral-300"),
          tooltip: R("palette-neutral-500"),
          backdrop: `rgba(${E(
            "palette-neutral-darkChannel",
            wc(A.neutral[900])
          )} / 0.25)`,
        },
        divider: `rgba(${E(
          "palette-neutral-mainChannel",
          wc(A.neutral[500])
        )} / 0.2)`,
        focusVisible: R("palette-primary-500"),
      },
      shadowRing: "0 0 #000",
      shadowChannel: "21 21 21",
      shadowOpacity: "0.08",
    },
    O = {
      palette: {
        mode: "dark",
        primary: pe({}, A.primary, I("primary")),
        neutral: pe({}, A.neutral, I("neutral"), {
          plainColor: R("palette-neutral-300"),
          plainHoverColor: R("palette-neutral-300"),
        }),
        danger: pe({}, A.danger, I("danger")),
        success: pe({}, A.success, I("success")),
        warning: pe({}, A.warning, I("warning")),
        common: { white: "#FFF", black: "#000" },
        text: {
          primary: R("palette-neutral-100"),
          secondary: R("palette-neutral-300"),
          tertiary: R("palette-neutral-400"),
          icon: R("palette-neutral-400"),
        },
        background: {
          body: R("palette-common-black"),
          surface: R("palette-neutral-900"),
          popup: R("palette-common-black"),
          level1: R("palette-neutral-800"),
          level2: R("palette-neutral-700"),
          level3: R("palette-neutral-600"),
          tooltip: R("palette-neutral-600"),
          backdrop: `rgba(${E(
            "palette-neutral-darkChannel",
            wc(A.neutral[50])
          )} / 0.25)`,
        },
        divider: `rgba(${E(
          "palette-neutral-mainChannel",
          wc(A.neutral[500])
        )} / 0.16)`,
        focusVisible: R("palette-primary-500"),
      },
      shadowRing: "0 0 #000",
      shadowChannel: "0 0 0",
      shadowOpacity: "0.6",
    },
    L =
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    V = pe(
      {
        body: `"Inter", ${E(`fontFamily-fallback, ${L}`)}`,
        display: `"Inter", ${E(`fontFamily-fallback, ${L}`)}`,
        code: "Source Code Pro,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace",
        fallback: L,
      },
      T.fontFamily
    ),
    H = pe({ sm: 300, md: 500, lg: 600, xl: 700 }, T.fontWeight),
    $ = pe(
      {
        xs: "0.75rem",
        sm: "0.875rem",
        md: "1rem",
        lg: "1.125rem",
        xl: "1.25rem",
        xl2: "1.5rem",
        xl3: "1.875rem",
        xl4: "2.25rem",
      },
      T.fontSize
    ),
    q = pe(
      { xs: "1.33334", sm: "1.42858", md: "1.5", lg: "1.55556", xl: "1.66667" },
      T.lineHeight
    ),
    K =
      (e =
        (t = T.colorSchemes) == null || (t = t.light) == null
          ? void 0
          : t.shadowRing) != null
        ? e
        : U.shadowRing,
    Y =
      (r =
        (i = T.colorSchemes) == null || (i = i.light) == null
          ? void 0
          : i.shadowChannel) != null
        ? r
        : U.shadowChannel,
    ne =
      (o =
        (s = T.colorSchemes) == null || (s = s.light) == null
          ? void 0
          : s.shadowOpacity) != null
        ? o
        : U.shadowOpacity,
    j = {
      colorSchemes: { light: U, dark: O },
      fontSize: $,
      fontFamily: V,
      fontWeight: H,
      focus: {
        thickness: "2px",
        selector: `&.${_w("", "focusVisible")}, &:focus-visible`,
        default: {
          outlineOffset: `var(--focus-outline-offset, ${E(
            "focus-thickness",
            (l = (u = T.focus) == null ? void 0 : u.thickness) != null
              ? l
              : "2px"
          )})`,
          outline: `${E(
            "focus-thickness",
            (f = (h = T.focus) == null ? void 0 : h.thickness) != null
              ? f
              : "2px"
          )} solid ${E("palette-focusVisible", A.primary[500])}`,
        },
      },
      lineHeight: q,
      radius: { xs: "2px", sm: "6px", md: "8px", lg: "12px", xl: "16px" },
      shadow: {
        xs: `${E("shadowRing", K)}, 0px 1px 2px 0px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)})`,
        sm: `${E("shadowRing", K)}, 0px 1px 2px 0px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)}), 0px 2px 4px 0px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)})`,
        md: `${E("shadowRing", K)}, 0px 2px 8px -2px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)}), 0px 6px 12px -2px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)})`,
        lg: `${E("shadowRing", K)}, 0px 2px 8px -2px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)}), 0px 12px 16px -4px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)})`,
        xl: `${E("shadowRing", K)}, 0px 2px 8px -2px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)}), 0px 20px 24px -4px rgba(${E(
          "shadowChannel",
          Y
        )} / ${E("shadowOpacity", ne)})`,
      },
      zIndex: {
        badge: 1,
        table: 10,
        popup: 1e3,
        modal: 1300,
        snackbar: 1400,
        tooltip: 1500,
      },
      typography: {
        h1: {
          fontFamily: E(`fontFamily-display, ${V.display}`),
          fontWeight: E(`fontWeight-xl, ${H.xl}`),
          fontSize: E(`fontSize-xl4, ${$.xl4}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h2: {
          fontFamily: E(`fontFamily-display, ${V.display}`),
          fontWeight: E(`fontWeight-xl, ${H.xl}`),
          fontSize: E(`fontSize-xl3, ${$.xl3}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h3: {
          fontFamily: E(`fontFamily-display, ${V.display}`),
          fontWeight: E(`fontWeight-lg, ${H.lg}`),
          fontSize: E(`fontSize-xl2, ${$.xl2}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h4: {
          fontFamily: E(`fontFamily-display, ${V.display}`),
          fontWeight: E(`fontWeight-lg, ${H.lg}`),
          fontSize: E(`fontSize-xl, ${$.xl}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-lg": {
          fontFamily: E(`fontFamily-body, ${V.body}`),
          fontWeight: E(`fontWeight-lg, ${H.lg}`),
          fontSize: E(`fontSize-lg, ${$.lg}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-md": {
          fontFamily: E(`fontFamily-body, ${V.body}`),
          fontWeight: E(`fontWeight-md, ${H.md}`),
          fontSize: E(`fontSize-md, ${$.md}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-sm": {
          fontFamily: E(`fontFamily-body, ${V.body}`),
          fontWeight: E(`fontWeight-md, ${H.md}`),
          fontSize: E(`fontSize-sm, ${$.sm}`),
          lineHeight: E(`lineHeight-sm, ${q.sm}`),
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "body-lg": {
          fontFamily: E(`fontFamily-body, ${V.body}`),
          fontSize: E(`fontSize-lg, ${$.lg}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-secondary, ${U.palette.text.secondary}`),
        },
        "body-md": {
          fontFamily: E(`fontFamily-body, ${V.body}`),
          fontSize: E(`fontSize-md, ${$.md}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-secondary, ${U.palette.text.secondary}`),
        },
        "body-sm": {
          fontFamily: E(`fontFamily-body, ${V.body}`),
          fontSize: E(`fontSize-sm, ${$.sm}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-tertiary, ${U.palette.text.tertiary}`),
        },
        "body-xs": {
          fontFamily: E(`fontFamily-body, ${V.body}`),
          fontWeight: E(`fontWeight-md, ${H.md}`),
          fontSize: E(`fontSize-xs, ${$.xs}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-tertiary, ${U.palette.text.tertiary}`),
        },
      },
    },
    re = T ? ti(j, T) : j,
    { colorSchemes: B } = re,
    G = Ft(re, TW),
    te = pe({ colorSchemes: B }, G, {
      breakpoints: aS(y ?? {}),
      components: ti(
        {
          MuiSvgIcon: {
            defaultProps: { fontSize: "xl2" },
            styleOverrides: {
              root: ({ ownerState: ue, theme: Ee }) => {
                var Ne;
                const Ae = ue.instanceFontSize;
                return pe(
                  { margin: "var(--Icon-margin)" },
                  ue.fontSize &&
                    ue.fontSize !== "inherit" && {
                      fontSize: `var(--Icon-fontSize, ${
                        Ee.vars.fontSize[ue.fontSize]
                      })`,
                    },
                  !ue.htmlColor &&
                    pe(
                      {
                        color: `var(--Icon-color, ${te.vars.palette.text.icon})`,
                      },
                      ue.color &&
                        ue.color !== "inherit" &&
                        Ee.vars.palette[ue.color] && {
                          color: `rgba(${
                            (Ne = Ee.vars.palette[ue.color]) == null
                              ? void 0
                              : Ne.mainChannel
                          } / 1)`,
                        }
                    ),
                  Ae &&
                    Ae !== "inherit" && {
                      "--Icon-fontSize": Ee.vars.fontSize[Ae],
                    }
                );
              },
            },
          },
        },
        S
      ),
      cssVarPrefix: g,
      getCssVar: E,
      spacing: LC(_),
    });
  function le(ue, Ee) {
    Object.keys(Ee).forEach((Ne) => {
      const Ae = { main: "500", light: "200", dark: "700" };
      ue === "dark" && (Ae.main = 400),
        !Ee[Ne].mainChannel &&
          Ee[Ne][Ae.main] &&
          (Ee[Ne].mainChannel = wc(Ee[Ne][Ae.main])),
        !Ee[Ne].lightChannel &&
          Ee[Ne][Ae.light] &&
          (Ee[Ne].lightChannel = wc(Ee[Ne][Ae.light])),
        !Ee[Ne].darkChannel &&
          Ee[Ne][Ae.dark] &&
          (Ee[Ne].darkChannel = wc(Ee[Ne][Ae.dark]));
    });
  }
  Object.entries(te.colorSchemes).forEach(([ue, Ee]) => {
    le(ue, Ee.palette);
  });
  const J = { prefix: g, shouldSkipGeneratingVar: w },
    { vars: oe, generateCssVars: he } = tD(pe({ colorSchemes: B }, G), J);
  (te.vars = oe),
    (te.generateCssVars = he),
    (te.unstable_sxConfig = pe({}, wW, void 0)),
    (te.unstable_sx = function (Ee) {
      return df({ sx: Ee, theme: this });
    }),
    (te.getColorSchemeSelector = (ue) =>
      ue === "light"
        ? "&"
        : `&[data-joy-color-scheme="${ue}"], [data-joy-color-scheme="${ue}"] &`);
  const ae = { getCssVar: E, palette: te.colorSchemes.light.palette };
  return (
    (te.variants = ti(
      {
        plain: Xi("plain", ae),
        plainHover: Xi("plainHover", ae),
        plainActive: Xi("plainActive", ae),
        plainDisabled: Xi("plainDisabled", ae),
        outlined: Xi("outlined", ae),
        outlinedHover: Xi("outlinedHover", ae),
        outlinedActive: Xi("outlinedActive", ae),
        outlinedDisabled: Xi("outlinedDisabled", ae),
        soft: Xi("soft", ae),
        softHover: Xi("softHover", ae),
        softActive: Xi("softActive", ae),
        softDisabled: Xi("softDisabled", ae),
        solid: Xi("solid", ae),
        solidHover: Xi("solidHover", ae),
        solidActive: Xi("solidActive", ae),
        solidDisabled: Xi("solidDisabled", ae),
      },
      x
    )),
    (te.palette = pe({}, te.colorSchemes.light.palette, {
      colorScheme: "light",
    })),
    (te.shouldSkipGeneratingVar = w),
    (te.applyStyles = hS),
    te
  );
}
const sP = AW(),
  $u = FC({ defaultTheme: sP, themeId: iP });
function aP({ props: n, name: e }) {
  return zC({
    props: n,
    name: e,
    defaultTheme: pe({}, sP, { components: {} }),
    themeId: iP,
  });
}
const RW = [
    "className",
    "elementType",
    "ownerState",
    "externalForwardedProps",
    "getSlotOwnerState",
    "internalForwardedProps",
  ],
  PW = ["component", "slots", "slotProps"],
  IW = ["component"];
function Du(n, e) {
  const {
      className: t,
      elementType: r,
      ownerState: i,
      externalForwardedProps: o,
      getSlotOwnerState: s,
      internalForwardedProps: l,
    } = e,
    u = Ft(e, RW),
    {
      component: f,
      slots: h = { [n]: void 0 },
      slotProps: m = { [n]: void 0 },
    } = o,
    g = Ft(o, PW),
    y = h[n] || r,
    _ = XC(m[n], i),
    S = $C(
      pe({ className: t }, u, {
        externalForwardedProps: n === "root" ? g : void 0,
        externalSlotProps: _,
      })
    ),
    {
      props: { component: x },
      internalRef: w,
    } = S,
    T = Ft(S.props, IW),
    E = xi(w, _ == null ? void 0 : _.ref, e.ref),
    A = s ? s(T) : {},
    R = pe({}, i, A),
    D = n === "root" ? x || f : x,
    I = jC(
      y,
      pe(
        {},
        n === "root" && !f && !h[n] && l,
        n !== "root" && !h[n] && l,
        T,
        D && { as: D },
        { ref: E }
      ),
      R
    );
  return (
    Object.keys(A).forEach((U) => {
      delete I[U];
    }),
    [y, I]
  );
}
function LW(n) {
  return _w("MuiCircularProgress", n);
}
oP("MuiCircularProgress", [
  "root",
  "determinate",
  "svg",
  "track",
  "progress",
  "colorPrimary",
  "colorNeutral",
  "colorDanger",
  "colorSuccess",
  "colorWarning",
  "colorContext",
  "sizeSm",
  "sizeMd",
  "sizeLg",
  "variantPlain",
  "variantOutlined",
  "variantSoft",
  "variantSolid",
]);
let DW = (n) => n,
  nC;
const kW = ["color", "backgroundColor"],
  OW = [
    "children",
    "className",
    "color",
    "size",
    "variant",
    "thickness",
    "determinate",
    "value",
    "component",
    "slots",
    "slotProps",
  ],
  NW = Am({
    "0%": { transform: "rotate(-90deg)" },
    "100%": { transform: "rotate(270deg)" },
  }),
  UW = (n) => {
    const { determinate: e, color: t, variant: r, size: i } = n,
      o = {
        root: [
          "root",
          e && "determinate",
          t && `color${fn(t)}`,
          r && `variant${fn(r)}`,
          i && `size${fn(i)}`,
        ],
        svg: ["svg"],
        track: ["track"],
        progress: ["progress"],
      };
    return pr(o, LW, {});
  };
function Hd(n, e) {
  return `var(--CircularProgress-${n}Thickness, var(--CircularProgress-thickness, ${e}))`;
}
const FW = $u("span", {
    name: "JoyCircularProgress",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })(({ ownerState: n, theme: e }) => {
    var t, r, i, o;
    const s = ((t = e.variants[n.variant]) == null ? void 0 : t[n.color]) || {},
      { color: l, backgroundColor: u } = s,
      f = Ft(s, kW);
    return pe(
      {
        "--Icon-fontSize": "calc(0.4 * var(--_root-size))",
        "--CircularProgress-trackColor": u,
        "--CircularProgress-progressColor": l,
        "--CircularProgress-percent": n.value,
        "--CircularProgress-linecap": "round",
      },
      n.size === "sm" && {
        "--_root-size": "var(--CircularProgress-size, 24px)",
        "--_track-thickness": Hd("track", "3px"),
        "--_progress-thickness": Hd("progress", "3px"),
      },
      n.instanceSize === "sm" && { "--CircularProgress-size": "24px" },
      n.size === "md" && {
        "--_track-thickness": Hd("track", "6px"),
        "--_progress-thickness": Hd("progress", "6px"),
        "--_root-size": "var(--CircularProgress-size, 40px)",
      },
      n.instanceSize === "md" && { "--CircularProgress-size": "40px" },
      n.size === "lg" && {
        "--_track-thickness": Hd("track", "8px"),
        "--_progress-thickness": Hd("progress", "8px"),
        "--_root-size": "var(--CircularProgress-size, 64px)",
      },
      n.instanceSize === "lg" && { "--CircularProgress-size": "64px" },
      n.thickness && {
        "--_track-thickness": `${n.thickness}px`,
        "--_progress-thickness": `${n.thickness}px`,
      },
      {
        "--_thickness-diff":
          "calc(var(--_track-thickness) - var(--_progress-thickness))",
        "--_inner-size":
          "calc(var(--_root-size) - 2 * var(--variant-borderWidth, 0px))",
        "--_outlined-inset":
          "max(var(--_track-thickness), var(--_progress-thickness))",
        width: "var(--_root-size)",
        height: "var(--_root-size)",
        borderRadius: "var(--_root-size)",
        margin: "var(--CircularProgress-margin)",
        boxSizing: "border-box",
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        flexShrink: 0,
        position: "relative",
        color: l,
      },
      n.children && {
        fontFamily: e.vars.fontFamily.body,
        fontWeight: e.vars.fontWeight.md,
        fontSize: "calc(0.2 * var(--_root-size))",
      },
      f,
      n.variant === "outlined" && {
        "&::before": pe(
          {
            content: '""',
            display: "block",
            position: "absolute",
            borderRadius: "inherit",
            top: "var(--_outlined-inset)",
            left: "var(--_outlined-inset)",
            right: "var(--_outlined-inset)",
            bottom: "var(--_outlined-inset)",
          },
          f
        ),
      },
      n.variant === "soft" && {
        "--CircularProgress-trackColor":
          e.variants.soft.neutral.backgroundColor,
        "--CircularProgress-progressColor":
          (r = e.variants.solid) == null ? void 0 : r[n.color].backgroundColor,
      },
      n.variant === "solid" && {
        "--CircularProgress-trackColor":
          (i = e.variants.softHover) == null
            ? void 0
            : i[n.color].backgroundColor,
        "--CircularProgress-progressColor":
          (o = e.variants.solid) == null ? void 0 : o[n.color].backgroundColor,
      }
    );
  }),
  zW = $u("svg", {
    name: "JoyCircularProgress",
    slot: "Svg",
    overridesResolver: (n, e) => e.svg,
  })({
    width: "inherit",
    height: "inherit",
    display: "inherit",
    boxSizing: "inherit",
    position: "absolute",
    top: "calc(-1 * var(--variant-borderWidth, 0px))",
    left: "calc(-1 * var(--variant-borderWidth, 0px))",
  }),
  BW = $u("circle", {
    name: "JoyCircularProgress",
    slot: "track",
    overridesResolver: (n, e) => e.track,
  })({
    cx: "50%",
    cy: "50%",
    r: "calc(var(--_inner-size) / 2 - var(--_track-thickness) / 2 + min(0px, var(--_thickness-diff) / 2))",
    fill: "transparent",
    strokeWidth: "var(--_track-thickness)",
    stroke: "var(--CircularProgress-trackColor)",
  }),
  VW = $u("circle", {
    name: "JoyCircularProgress",
    slot: "progress",
    overridesResolver: (n, e) => e.progress,
  })(
    {
      "--_progress-radius":
        "calc(var(--_inner-size) / 2 - var(--_progress-thickness) / 2 - max(0px, var(--_thickness-diff) / 2))",
      "--_progress-length": "calc(2 * 3.1415926535 * var(--_progress-radius))",
      cx: "50%",
      cy: "50%",
      r: "var(--_progress-radius)",
      fill: "transparent",
      strokeWidth: "var(--_progress-thickness)",
      stroke: "var(--CircularProgress-progressColor)",
      strokeLinecap: "var(--CircularProgress-linecap, round)",
      strokeDasharray: "var(--_progress-length)",
      strokeDashoffset:
        "calc(var(--_progress-length) - var(--CircularProgress-percent) * var(--_progress-length) / 100)",
      transformOrigin: "center",
      transform: "rotate(-90deg)",
    },
    ({ ownerState: n }) =>
      !n.determinate &&
      oS(
        nC ||
          (nC = DW`
      animation: var(--CircularProgress-circulation, 0.8s linear 0s infinite normal none running)
        ${0};
    `),
        NW
      )
  ),
  HW = ee.forwardRef(function (e, t) {
    const r = aP({ props: e, name: "JoyCircularProgress" }),
      {
        children: i,
        className: o,
        color: s = "primary",
        size: l = "md",
        variant: u = "soft",
        thickness: f,
        determinate: h = !1,
        value: m = h ? 0 : 25,
        component: g,
        slots: y = {},
        slotProps: _ = {},
      } = r,
      S = Ft(r, OW),
      x = pe({}, r, {
        color: s,
        size: l,
        variant: u,
        thickness: f,
        value: m,
        determinate: h,
        instanceSize: e.size,
      }),
      w = UW(x),
      T = pe({}, S, { component: g, slots: y, slotProps: _ }),
      [E, A] = Du("root", {
        ref: t,
        className: cn(w.root, o),
        elementType: FW,
        externalForwardedProps: T,
        ownerState: x,
        additionalProps: pe(
          { role: "progressbar", style: { "--CircularProgress-percent": m } },
          m &&
            h && {
              "aria-valuenow": Math.round(
                typeof m == "number" ? m : Number(m || 0)
              ),
            }
        ),
      }),
      [R, D] = Du("svg", {
        className: w.svg,
        elementType: zW,
        externalForwardedProps: T,
        ownerState: x,
      }),
      [I, U] = Du("track", {
        className: w.track,
        elementType: BW,
        externalForwardedProps: T,
        ownerState: x,
      }),
      [O, L] = Du("progress", {
        className: w.progress,
        elementType: VW,
        externalForwardedProps: T,
        ownerState: x,
      });
    return ve.jsxs(
      E,
      pe({}, A, {
        children: [
          ve.jsxs(
            R,
            pe({}, D, {
              children: [ve.jsx(I, pe({}, U)), ve.jsx(O, pe({}, L))],
            })
          ),
          i,
        ],
      })
    );
  });
function GW(n) {
  return _w("MuiButton", n);
}
const rC = oP("MuiButton", [
    "root",
    "colorPrimary",
    "colorNeutral",
    "colorDanger",
    "colorSuccess",
    "colorWarning",
    "colorContext",
    "variantPlain",
    "variantOutlined",
    "variantSoft",
    "variantSolid",
    "focusVisible",
    "disabled",
    "sizeSm",
    "sizeMd",
    "sizeLg",
    "fullWidth",
    "startDecorator",
    "endDecorator",
    "loading",
    "loadingIndicatorCenter",
  ]),
  WW = ee.createContext({}),
  jW = ee.createContext(void 0),
  $W = [
    "children",
    "action",
    "color",
    "variant",
    "size",
    "fullWidth",
    "startDecorator",
    "endDecorator",
    "loading",
    "loadingPosition",
    "loadingIndicator",
    "disabled",
    "component",
    "slots",
    "slotProps",
  ],
  XW = (n) => {
    const {
        color: e,
        disabled: t,
        focusVisible: r,
        focusVisibleClassName: i,
        fullWidth: o,
        size: s,
        variant: l,
        loading: u,
      } = n,
      f = {
        root: [
          "root",
          t && "disabled",
          r && "focusVisible",
          o && "fullWidth",
          l && `variant${fn(l)}`,
          e && `color${fn(e)}`,
          s && `size${fn(s)}`,
          u && "loading",
        ],
        startDecorator: ["startDecorator"],
        endDecorator: ["endDecorator"],
        loadingIndicatorCenter: ["loadingIndicatorCenter"],
      },
      h = pr(f, GW, {});
    return r && i && (h.root += ` ${i}`), h;
  },
  YW = $u("span", {
    name: "JoyButton",
    slot: "StartDecorator",
    overridesResolver: (n, e) => e.startDecorator,
  })({
    "--Icon-margin": "0 0 0 calc(var(--Button-gap) / -2)",
    "--CircularProgress-margin": "0 0 0 calc(var(--Button-gap) / -2)",
    display: "inherit",
    marginRight: "var(--Button-gap)",
  }),
  qW = $u("span", {
    name: "JoyButton",
    slot: "EndDecorator",
    overridesResolver: (n, e) => e.endDecorator,
  })({
    "--Icon-margin": "0 calc(var(--Button-gap) / -2) 0 0",
    "--CircularProgress-margin": "0 calc(var(--Button-gap) / -2) 0 0",
    display: "inherit",
    marginLeft: "var(--Button-gap)",
  }),
  KW = $u("span", {
    name: "JoyButton",
    slot: "LoadingCenter",
    overridesResolver: (n, e) => e.loadingIndicatorCenter,
  })(({ theme: n, ownerState: e }) => {
    var t, r;
    return pe(
      {
        display: "inherit",
        position: "absolute",
        left: "50%",
        transform: "translateX(-50%)",
        color:
          (t = n.variants[e.variant]) == null || (t = t[e.color]) == null
            ? void 0
            : t.color,
      },
      e.disabled && {
        color:
          (r = n.variants[`${e.variant}Disabled`]) == null ||
          (r = r[e.color]) == null
            ? void 0
            : r.color,
      }
    );
  }),
  ZW = ({ theme: n, ownerState: e }) => {
    var t, r, i, o;
    return [
      pe(
        {
          "--Icon-margin": "initial",
          "--Icon-color":
            e.color !== "neutral" || e.variant === "solid"
              ? "currentColor"
              : n.vars.palette.text.icon,
        },
        e.size === "sm" && {
          "--Icon-fontSize": n.vars.fontSize.lg,
          "--CircularProgress-size": "20px",
          "--CircularProgress-thickness": "2px",
          "--Button-gap": "0.375rem",
          minHeight: "var(--Button-minHeight, 2rem)",
          fontSize: n.vars.fontSize.sm,
          paddingBlock: "var(--Button-paddingBlock, 0.25rem)",
          paddingInline: "0.75rem",
        },
        e.size === "md" && {
          "--Icon-fontSize": n.vars.fontSize.xl,
          "--CircularProgress-size": "20px",
          "--CircularProgress-thickness": "2px",
          "--Button-gap": "0.5rem",
          minHeight: "var(--Button-minHeight, 2.25rem)",
          fontSize: n.vars.fontSize.sm,
          paddingBlock: "var(--Button-paddingBlock, 0.375rem)",
          paddingInline: "1rem",
        },
        e.size === "lg" && {
          "--Icon-fontSize": n.vars.fontSize.xl2,
          "--CircularProgress-size": "28px",
          "--CircularProgress-thickness": "4px",
          "--Button-gap": "0.75rem",
          minHeight: "var(--Button-minHeight, 2.75rem)",
          fontSize: n.vars.fontSize.md,
          paddingBlock: "var(--Button-paddingBlock, 0.5rem)",
          paddingInline: "1.5rem",
        },
        {
          WebkitTapHighlightColor: "transparent",
          boxSizing: "border-box",
          borderRadius: `var(--Button-radius, ${n.vars.radius.sm})`,
          margin: "var(--Button-margin)",
          border: "none",
          backgroundColor: "transparent",
          cursor: "pointer",
          userSelect: "none",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          position: "relative",
          textDecoration: "none",
          fontFamily: n.vars.fontFamily.body,
          fontWeight: n.vars.fontWeight.lg,
          lineHeight: n.vars.lineHeight.md,
        },
        e.fullWidth && { width: "100%" },
        { [n.focus.selector]: n.focus.default }
      ),
      pe(
        {},
        (t = n.variants[e.variant]) == null ? void 0 : t[e.color],
        {
          "&:hover": {
            "@media (hover: hover)":
              (r = n.variants[`${e.variant}Hover`]) == null
                ? void 0
                : r[e.color],
          },
          '&:active, &[aria-pressed="true"]':
            (i = n.variants[`${e.variant}Active`]) == null
              ? void 0
              : i[e.color],
          [`&.${rC.disabled}`]:
            (o = n.variants[`${e.variant}Disabled`]) == null
              ? void 0
              : o[e.color],
        },
        e.loadingPosition === "center" && {
          [`&.${rC.loading}`]: { color: "transparent" },
        }
      ),
    ];
  },
  JW = $u("button", {
    name: "JoyButton",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })(ZW),
  lP = ee.forwardRef(function (e, t) {
    var r;
    const i = aP({ props: e, name: "JoyButton" }),
      {
        children: o,
        action: s,
        color: l = "primary",
        variant: u = "solid",
        size: f = "md",
        fullWidth: h = !1,
        startDecorator: m,
        endDecorator: g,
        loading: y = !1,
        loadingPosition: _ = "center",
        loadingIndicator: S,
        disabled: x,
        component: w,
        slots: T = {},
        slotProps: E = {},
      } = i,
      A = Ft(i, $W),
      R = ee.useContext(WW),
      D = ee.useContext(jW),
      I = e.variant || R.variant || u,
      U = e.size || R.size || f,
      O = e.color || R.color || l,
      L = (r = e.loading || e.disabled) != null ? r : R.disabled || y || x,
      V = ee.useRef(null),
      H = xi(V, t),
      {
        focusVisible: $,
        setFocusVisible: q,
        getRootProps: K,
      } = SW(pe({}, i, { disabled: L, rootRef: H })),
      Y =
        S ??
        ve.jsx(HW, { color: O, thickness: { sm: 2, md: 3, lg: 4 }[U] || 3 });
    ee.useImperativeHandle(
      s,
      () => ({
        focusVisible: () => {
          var Ne;
          q(!0), (Ne = V.current) == null || Ne.focus();
        },
      }),
      [q]
    );
    const ne = pe({}, i, {
        color: O,
        fullWidth: h,
        variant: I,
        size: U,
        focusVisible: $,
        loading: y,
        loadingPosition: _,
        disabled: L,
      }),
      j = XW(ne),
      re = (Ne) => {
        var Ae;
        let W = i.onClick;
        if (
          (typeof E.root == "function"
            ? (W = E.root(ne).onClick)
            : E.root && (W = E.root.onClick),
          (Ae = W) == null || Ae(Ne),
          D)
        ) {
          var _e;
          (_e = D.onClick) == null || _e.call(D, Ne, i.value);
        }
      };
    let B = i["aria-pressed"];
    typeof E.root == "function"
      ? (B = E.root(ne)["aria-pressed"])
      : E.root && (B = E.root["aria-pressed"]),
      D != null &&
        D.value &&
        (Array.isArray(D.value)
          ? (B = D.value.indexOf(i.value) !== -1)
          : (B = D.value === i.value));
    const G = pe({}, A, { component: w, slots: T, slotProps: E }),
      [te, le] = Du("root", {
        ref: t,
        className: j.root,
        elementType: JW,
        externalForwardedProps: G,
        getSlotProps: K,
        ownerState: ne,
        additionalProps: { onClick: re, "aria-pressed": B },
      }),
      [J, oe] = Du("startDecorator", {
        className: j.startDecorator,
        elementType: YW,
        externalForwardedProps: G,
        ownerState: ne,
      }),
      [he, ae] = Du("endDecorator", {
        className: j.endDecorator,
        elementType: qW,
        externalForwardedProps: G,
        ownerState: ne,
      }),
      [ue, Ee] = Du("loadingIndicatorCenter", {
        className: j.loadingIndicatorCenter,
        elementType: KW,
        externalForwardedProps: G,
        ownerState: ne,
      });
    return ve.jsxs(
      te,
      pe({}, le, {
        children: [
          (m || (y && _ === "start")) &&
            ve.jsx(J, pe({}, oe, { children: y && _ === "start" ? Y : m })),
          o,
          y && _ === "center" && ve.jsx(ue, pe({}, Ee, { children: Y })),
          (g || (y && _ === "end")) &&
            ve.jsx(he, pe({}, ae, { children: y && _ === "end" ? Y : g })),
        ],
      })
    );
  });
lP.muiName = "Button";
const QW = QC(
    ve.jsx("path", { d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z" }),
    "KeyboardArrowRight"
  ),
  e9 = ({ onStart: n }) =>
    ve.jsxs("div", {
      style: {
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        backgroundColor: "#1A202C",
        justifyContent: "center",
        alignItems: "center",
        textAlign: "center",
        padding: "20px",
      },
      children: [
        ve.jsx("h1", {
          style: { color: "white", marginBottom: "20px" },
          children: "Demonstration of Smart Contract",
        }),
        ve.jsx("video", {
          width: "800",
          height: "450",
          controls: !0,
          className: "animation-video",
          children: ve.jsx("source", {
            src: "images/Smart-contract.mp4",
            type: "video/mp4",
          }),
        }),
        ve.jsx("div", {
          style: {
            marginTop: "20px",
            width: "800px",
            display: "flex",
            justifyContent: "flex-end",
          },
          children: ve.jsx(lP, {
            endDecorator: ve.jsx(QW, {}),
            color: "success",
            size: "lg",
            onClick: n,
            children: "Go to Simulation",
          }),
        }),
      ],
    });
function t9() {
  const [n, e] = ee.useState(!1),
    [t, r] = ee.useState(0),
    i = () => {
      e(!0);
    },
    o = () => {
      r((s) => s + 1);
    };
  return ve.jsx(c3, {
    store: rF,
    children: n
      ? ve.jsxs(
          Qr,
          {
            sx: {
              height: "100vh",
              width: "100vw",
              display: "flex",
              bgcolor: "#1a202c",
            },
            children: [
              ve.jsx(Qr, {
                sx: { width: "25%", height: "100%" },
                children: ve.jsx(iF, { onReset: o }),
              }),
              ve.jsx(Qr, {
                sx: { width: "75%", height: "100%" },
                children: ve.jsx(xW, {}),
              }),
            ],
          },
          t
        )
      : ve.jsx(e9, { onStart: i }),
  });
}
HP.createRoot(document.getElementById("root")).render(
  ve.jsx(Ts.StrictMode, { children: ve.jsx(t9, {}) })
);
