function u3(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o &&
            Object.defineProperty(
              n,
              i,
              o.get ? o : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const s of o.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const o = {};
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (o.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (o.credentials = "omit")
        : (o.credentials = "same-origin"),
      o
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const o = t(i);
    fetch(i.href, o);
  }
})();
function Ah(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function Ul(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(
        t,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return n[r];
              },
            }
      );
    }),
    t
  );
}
var zx = { exports: {} },
  Mp = {},
  Hx = { exports: {} },
  fn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Tb;
function c3() {
  if (Tb) return fn;
  Tb = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.forward_ref"),
    u = Symbol.for("react.suspense"),
    f = Symbol.for("react.memo"),
    h = Symbol.for("react.lazy"),
    m = Symbol.iterator;
  function g(F) {
    return F === null || typeof F != "object"
      ? null
      : ((F = (m && F[m]) || F["@@iterator"]),
        typeof F == "function" ? F : null);
  }
  var y = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    x = Object.assign,
    S = {};
  function _(F, V, ne) {
    (this.props = F),
      (this.context = V),
      (this.refs = S),
      (this.updater = ne || y);
  }
  (_.prototype.isReactComponent = {}),
    (_.prototype.setState = function (F, V) {
      if (typeof F != "object" && typeof F != "function" && F != null)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, F, V, "setState");
    }),
    (_.prototype.forceUpdate = function (F) {
      this.updater.enqueueForceUpdate(this, F, "forceUpdate");
    });
  function w() {}
  w.prototype = _.prototype;
  function T(F, V, ne) {
    (this.props = F),
      (this.context = V),
      (this.refs = S),
      (this.updater = ne || y);
  }
  var E = (T.prototype = new w());
  (E.constructor = T), x(E, _.prototype), (E.isPureReactComponent = !0);
  var A = Array.isArray,
    R = Object.prototype.hasOwnProperty,
    k = { current: null },
    P = { key: !0, ref: !0, __self: !0, __source: !0 };
  function U(F, V, ne) {
    var ae,
      J = {},
      oe = null,
      de = null;
    if (V != null)
      for (ae in (V.ref !== void 0 && (de = V.ref),
      V.key !== void 0 && (oe = "" + V.key),
      V))
        R.call(V, ae) && !P.hasOwnProperty(ae) && (J[ae] = V[ae]);
    var le = arguments.length - 2;
    if (le === 1) J.children = ne;
    else if (1 < le) {
      for (var fe = Array(le), Ee = 0; Ee < le; Ee++)
        fe[Ee] = arguments[Ee + 2];
      J.children = fe;
    }
    if (F && F.defaultProps)
      for (ae in ((le = F.defaultProps), le))
        J[ae] === void 0 && (J[ae] = le[ae]);
    return {
      $$typeof: n,
      type: F,
      key: oe,
      ref: de,
      props: J,
      _owner: k.current,
    };
  }
  function N(F, V) {
    return {
      $$typeof: n,
      type: F.type,
      key: V,
      ref: F.ref,
      props: F.props,
      _owner: F._owner,
    };
  }
  function L(F) {
    return typeof F == "object" && F !== null && F.$$typeof === n;
  }
  function H(F) {
    var V = { "=": "=0", ":": "=2" };
    return (
      "$" +
      F.replace(/[=:]/g, function (ne) {
        return V[ne];
      })
    );
  }
  var G = /\/+/g;
  function $(F, V) {
    return typeof F == "object" && F !== null && F.key != null
      ? H("" + F.key)
      : V.toString(36);
  }
  function q(F, V, ne, ae, J) {
    var oe = typeof F;
    (oe === "undefined" || oe === "boolean") && (F = null);
    var de = !1;
    if (F === null) de = !0;
    else
      switch (oe) {
        case "string":
        case "number":
          de = !0;
          break;
        case "object":
          switch (F.$$typeof) {
            case n:
            case e:
              de = !0;
          }
      }
    if (de)
      return (
        (de = F),
        (J = J(de)),
        (F = ae === "" ? "." + $(de, 0) : ae),
        A(J)
          ? ((ne = ""),
            F != null && (ne = F.replace(G, "$&/") + "/"),
            q(J, V, ne, "", function (Ee) {
              return Ee;
            }))
          : J != null &&
            (L(J) &&
              (J = N(
                J,
                ne +
                  (!J.key || (de && de.key === J.key)
                    ? ""
                    : ("" + J.key).replace(G, "$&/") + "/") +
                  F
              )),
            V.push(J)),
        1
      );
    if (((de = 0), (ae = ae === "" ? "." : ae + ":"), A(F)))
      for (var le = 0; le < F.length; le++) {
        oe = F[le];
        var fe = ae + $(oe, le);
        de += q(oe, V, ne, fe, J);
      }
    else if (((fe = g(F)), typeof fe == "function"))
      for (F = fe.call(F), le = 0; !(oe = F.next()).done; )
        (oe = oe.value), (fe = ae + $(oe, le++)), (de += q(oe, V, ne, fe, J));
    else if (oe === "object")
      throw (
        ((V = String(F)),
        Error(
          "Objects are not valid as a React child (found: " +
            (V === "[object Object]"
              ? "object with keys {" + Object.keys(F).join(", ") + "}"
              : V) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    return de;
  }
  function Z(F, V, ne) {
    if (F == null) return F;
    var ae = [],
      J = 0;
    return (
      q(F, ae, "", "", function (oe) {
        return V.call(ne, oe, J++);
      }),
      ae
    );
  }
  function X(F) {
    if (F._status === -1) {
      var V = F._result;
      (V = V()),
        V.then(
          function (ne) {
            (F._status === 0 || F._status === -1) &&
              ((F._status = 1), (F._result = ne));
          },
          function (ne) {
            (F._status === 0 || F._status === -1) &&
              ((F._status = 2), (F._result = ne));
          }
        ),
        F._status === -1 && ((F._status = 0), (F._result = V));
    }
    if (F._status === 1) return F._result.default;
    throw F._result;
  }
  var re = { current: null },
    W = { transition: null },
    te = {
      ReactCurrentDispatcher: re,
      ReactCurrentBatchConfig: W,
      ReactCurrentOwner: k,
    };
  return (
    (fn.Children = {
      map: Z,
      forEach: function (F, V, ne) {
        Z(
          F,
          function () {
            V.apply(this, arguments);
          },
          ne
        );
      },
      count: function (F) {
        var V = 0;
        return (
          Z(F, function () {
            V++;
          }),
          V
        );
      },
      toArray: function (F) {
        return (
          Z(F, function (V) {
            return V;
          }) || []
        );
      },
      only: function (F) {
        if (!L(F))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return F;
      },
    }),
    (fn.Component = _),
    (fn.Fragment = t),
    (fn.Profiler = i),
    (fn.PureComponent = T),
    (fn.StrictMode = r),
    (fn.Suspense = u),
    (fn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = te),
    (fn.cloneElement = function (F, V, ne) {
      if (F == null)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            F +
            "."
        );
      var ae = x({}, F.props),
        J = F.key,
        oe = F.ref,
        de = F._owner;
      if (V != null) {
        if (
          (V.ref !== void 0 && ((oe = V.ref), (de = k.current)),
          V.key !== void 0 && (J = "" + V.key),
          F.type && F.type.defaultProps)
        )
          var le = F.type.defaultProps;
        for (fe in V)
          R.call(V, fe) &&
            !P.hasOwnProperty(fe) &&
            (ae[fe] = V[fe] === void 0 && le !== void 0 ? le[fe] : V[fe]);
      }
      var fe = arguments.length - 2;
      if (fe === 1) ae.children = ne;
      else if (1 < fe) {
        le = Array(fe);
        for (var Ee = 0; Ee < fe; Ee++) le[Ee] = arguments[Ee + 2];
        ae.children = le;
      }
      return {
        $$typeof: n,
        type: F.type,
        key: J,
        ref: oe,
        props: ae,
        _owner: de,
      };
    }),
    (fn.createContext = function (F) {
      return (
        (F = {
          $$typeof: s,
          _currentValue: F,
          _currentValue2: F,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (F.Provider = { $$typeof: o, _context: F }),
        (F.Consumer = F)
      );
    }),
    (fn.createElement = U),
    (fn.createFactory = function (F) {
      var V = U.bind(null, F);
      return (V.type = F), V;
    }),
    (fn.createRef = function () {
      return { current: null };
    }),
    (fn.forwardRef = function (F) {
      return { $$typeof: l, render: F };
    }),
    (fn.isValidElement = L),
    (fn.lazy = function (F) {
      return { $$typeof: h, _payload: { _status: -1, _result: F }, _init: X };
    }),
    (fn.memo = function (F, V) {
      return { $$typeof: f, type: F, compare: V === void 0 ? null : V };
    }),
    (fn.startTransition = function (F) {
      var V = W.transition;
      W.transition = {};
      try {
        F();
      } finally {
        W.transition = V;
      }
    }),
    (fn.unstable_act = function () {
      throw Error("act(...) is not supported in production builds of React.");
    }),
    (fn.useCallback = function (F, V) {
      return re.current.useCallback(F, V);
    }),
    (fn.useContext = function (F) {
      return re.current.useContext(F);
    }),
    (fn.useDebugValue = function () {}),
    (fn.useDeferredValue = function (F) {
      return re.current.useDeferredValue(F);
    }),
    (fn.useEffect = function (F, V) {
      return re.current.useEffect(F, V);
    }),
    (fn.useId = function () {
      return re.current.useId();
    }),
    (fn.useImperativeHandle = function (F, V, ne) {
      return re.current.useImperativeHandle(F, V, ne);
    }),
    (fn.useInsertionEffect = function (F, V) {
      return re.current.useInsertionEffect(F, V);
    }),
    (fn.useLayoutEffect = function (F, V) {
      return re.current.useLayoutEffect(F, V);
    }),
    (fn.useMemo = function (F, V) {
      return re.current.useMemo(F, V);
    }),
    (fn.useReducer = function (F, V, ne) {
      return re.current.useReducer(F, V, ne);
    }),
    (fn.useRef = function (F) {
      return re.current.useRef(F);
    }),
    (fn.useState = function (F) {
      return re.current.useState(F);
    }),
    (fn.useSyncExternalStore = function (F, V, ne) {
      return re.current.useSyncExternalStore(F, V, ne);
    }),
    (fn.useTransition = function () {
      return re.current.useTransition();
    }),
    (fn.version = "18.2.0"),
    fn
  );
}
var Cb;
function Rh() {
  return Cb || ((Cb = 1), (Hx.exports = c3())), Hx.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ab;
function f3() {
  if (Ab) return Mp;
  Ab = 1;
  var n = Rh(),
    e = Symbol.for("react.element"),
    t = Symbol.for("react.fragment"),
    r = Object.prototype.hasOwnProperty,
    i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(l, u, f) {
    var h,
      m = {},
      g = null,
      y = null;
    f !== void 0 && (g = "" + f),
      u.key !== void 0 && (g = "" + u.key),
      u.ref !== void 0 && (y = u.ref);
    for (h in u) r.call(u, h) && !o.hasOwnProperty(h) && (m[h] = u[h]);
    if (l && l.defaultProps)
      for (h in ((u = l.defaultProps), u)) m[h] === void 0 && (m[h] = u[h]);
    return {
      $$typeof: e,
      type: l,
      key: g,
      ref: y,
      props: m,
      _owner: i.current,
    };
  }
  return (Mp.Fragment = t), (Mp.jsx = s), (Mp.jsxs = s), Mp;
}
var Rb;
function DC() {
  return Rb || ((Rb = 1), (zx.exports = f3())), zx.exports;
}
var Q = DC(),
  K = Rh();
const Cs = Ah(K),
  A1 = u3({ __proto__: null, default: Cs }, [K]);
var rv = {},
  Vx = { exports: {} },
  Do = {},
  Gx = { exports: {} },
  Wx = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Pb;
function d3() {
  return (
    Pb ||
      ((Pb = 1),
      (function (n) {
        function e(W, te) {
          var F = W.length;
          W.push(te);
          e: for (; 0 < F; ) {
            var V = (F - 1) >>> 1,
              ne = W[V];
            if (0 < i(ne, te)) (W[V] = te), (W[F] = ne), (F = V);
            else break e;
          }
        }
        function t(W) {
          return W.length === 0 ? null : W[0];
        }
        function r(W) {
          if (W.length === 0) return null;
          var te = W[0],
            F = W.pop();
          if (F !== te) {
            W[0] = F;
            e: for (var V = 0, ne = W.length, ae = ne >>> 1; V < ae; ) {
              var J = 2 * (V + 1) - 1,
                oe = W[J],
                de = J + 1,
                le = W[de];
              if (0 > i(oe, F))
                de < ne && 0 > i(le, oe)
                  ? ((W[V] = le), (W[de] = F), (V = de))
                  : ((W[V] = oe), (W[J] = F), (V = J));
              else if (de < ne && 0 > i(le, F))
                (W[V] = le), (W[de] = F), (V = de);
              else break e;
            }
          }
          return te;
        }
        function i(W, te) {
          var F = W.sortIndex - te.sortIndex;
          return F !== 0 ? F : W.id - te.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var s = Date,
            l = s.now();
          n.unstable_now = function () {
            return s.now() - l;
          };
        }
        var u = [],
          f = [],
          h = 1,
          m = null,
          g = 3,
          y = !1,
          x = !1,
          S = !1,
          _ = typeof setTimeout == "function" ? setTimeout : null,
          w = typeof clearTimeout == "function" ? clearTimeout : null,
          T = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function E(W) {
          for (var te = t(f); te !== null; ) {
            if (te.callback === null) r(f);
            else if (te.startTime <= W)
              r(f), (te.sortIndex = te.expirationTime), e(u, te);
            else break;
            te = t(f);
          }
        }
        function A(W) {
          if (((S = !1), E(W), !x))
            if (t(u) !== null) (x = !0), X(R);
            else {
              var te = t(f);
              te !== null && re(A, te.startTime - W);
            }
        }
        function R(W, te) {
          (x = !1), S && ((S = !1), w(U), (U = -1)), (y = !0);
          var F = g;
          try {
            for (
              E(te), m = t(u);
              m !== null && (!(m.expirationTime > te) || (W && !H()));

            ) {
              var V = m.callback;
              if (typeof V == "function") {
                (m.callback = null), (g = m.priorityLevel);
                var ne = V(m.expirationTime <= te);
                (te = n.unstable_now()),
                  typeof ne == "function"
                    ? (m.callback = ne)
                    : m === t(u) && r(u),
                  E(te);
              } else r(u);
              m = t(u);
            }
            if (m !== null) var ae = !0;
            else {
              var J = t(f);
              J !== null && re(A, J.startTime - te), (ae = !1);
            }
            return ae;
          } finally {
            (m = null), (g = F), (y = !1);
          }
        }
        var k = !1,
          P = null,
          U = -1,
          N = 5,
          L = -1;
        function H() {
          return !(n.unstable_now() - L < N);
        }
        function G() {
          if (P !== null) {
            var W = n.unstable_now();
            L = W;
            var te = !0;
            try {
              te = P(!0, W);
            } finally {
              te ? $() : ((k = !1), (P = null));
            }
          } else k = !1;
        }
        var $;
        if (typeof T == "function")
          $ = function () {
            T(G);
          };
        else if (typeof MessageChannel < "u") {
          var q = new MessageChannel(),
            Z = q.port2;
          (q.port1.onmessage = G),
            ($ = function () {
              Z.postMessage(null);
            });
        } else
          $ = function () {
            _(G, 0);
          };
        function X(W) {
          (P = W), k || ((k = !0), $());
        }
        function re(W, te) {
          U = _(function () {
            W(n.unstable_now());
          }, te);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (W) {
            W.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            x || y || ((x = !0), X(R));
          }),
          (n.unstable_forceFrameRate = function (W) {
            0 > W || 125 < W
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (N = 0 < W ? Math.floor(1e3 / W) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(u);
          }),
          (n.unstable_next = function (W) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var te = 3;
                break;
              default:
                te = g;
            }
            var F = g;
            g = te;
            try {
              return W();
            } finally {
              g = F;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (W, te) {
            switch (W) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                W = 3;
            }
            var F = g;
            g = W;
            try {
              return te();
            } finally {
              g = F;
            }
          }),
          (n.unstable_scheduleCallback = function (W, te, F) {
            var V = n.unstable_now();
            switch (
              (typeof F == "object" && F !== null
                ? ((F = F.delay),
                  (F = typeof F == "number" && 0 < F ? V + F : V))
                : (F = V),
              W)
            ) {
              case 1:
                var ne = -1;
                break;
              case 2:
                ne = 250;
                break;
              case 5:
                ne = 1073741823;
                break;
              case 4:
                ne = 1e4;
                break;
              default:
                ne = 5e3;
            }
            return (
              (ne = F + ne),
              (W = {
                id: h++,
                callback: te,
                priorityLevel: W,
                startTime: F,
                expirationTime: ne,
                sortIndex: -1,
              }),
              F > V
                ? ((W.sortIndex = F),
                  e(f, W),
                  t(u) === null &&
                    W === t(f) &&
                    (S ? (w(U), (U = -1)) : (S = !0), re(A, F - V)))
                : ((W.sortIndex = ne), e(u, W), x || y || ((x = !0), X(R))),
              W
            );
          }),
          (n.unstable_shouldYield = H),
          (n.unstable_wrapCallback = function (W) {
            var te = g;
            return function () {
              var F = g;
              g = te;
              try {
                return W.apply(this, arguments);
              } finally {
                g = F;
              }
            };
          });
      })(Wx)),
    Wx
  );
}
var Ib;
function h3() {
  return Ib || ((Ib = 1), (Gx.exports = d3())), Gx.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Lb;
function p3() {
  if (Lb) return Do;
  Lb = 1;
  var n = Rh(),
    e = h3();
  function t(a) {
    for (
      var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + a,
        v = 1;
      v < arguments.length;
      v++
    )
      c += "&args[]=" + encodeURIComponent(arguments[v]);
    return (
      "Minified React error #" +
      a +
      "; visit " +
      c +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var r = new Set(),
    i = {};
  function o(a, c) {
    s(a, c), s(a + "Capture", c);
  }
  function s(a, c) {
    for (i[a] = c, a = 0; a < c.length; a++) r.add(c[a]);
  }
  var l = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    u = Object.prototype.hasOwnProperty,
    f =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    h = {},
    m = {};
  function g(a) {
    return u.call(m, a)
      ? !0
      : u.call(h, a)
      ? !1
      : f.test(a)
      ? (m[a] = !0)
      : ((h[a] = !0), !1);
  }
  function y(a, c, v, M) {
    if (v !== null && v.type === 0) return !1;
    switch (typeof c) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return M
          ? !1
          : v !== null
          ? !v.acceptsBooleans
          : ((a = a.toLowerCase().slice(0, 5)), a !== "data-" && a !== "aria-");
      default:
        return !1;
    }
  }
  function x(a, c, v, M) {
    if (c === null || typeof c > "u" || y(a, c, v, M)) return !0;
    if (M) return !1;
    if (v !== null)
      switch (v.type) {
        case 3:
          return !c;
        case 4:
          return c === !1;
        case 5:
          return isNaN(c);
        case 6:
          return isNaN(c) || 1 > c;
      }
    return !1;
  }
  function S(a, c, v, M, I, O, Y) {
    (this.acceptsBooleans = c === 2 || c === 3 || c === 4),
      (this.attributeName = M),
      (this.attributeNamespace = I),
      (this.mustUseProperty = v),
      (this.propertyName = a),
      (this.type = c),
      (this.sanitizeURL = O),
      (this.removeEmptyString = Y);
  }
  var _ = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (a) {
      _[a] = new S(a, 0, !1, a, null, !1, !1);
    }),
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (a) {
      var c = a[0];
      _[c] = new S(c, 1, !1, a[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (
      a
    ) {
      _[a] = new S(a, 2, !1, a.toLowerCase(), null, !1, !1);
    }),
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (a) {
      _[a] = new S(a, 2, !1, a, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (a) {
        _[a] = new S(a, 3, !1, a.toLowerCase(), null, !1, !1);
      }),
    ["checked", "multiple", "muted", "selected"].forEach(function (a) {
      _[a] = new S(a, 3, !0, a, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (a) {
      _[a] = new S(a, 4, !1, a, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (a) {
      _[a] = new S(a, 6, !1, a, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (a) {
      _[a] = new S(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
  var w = /[\-:]([a-z])/g;
  function T(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (a) {
      var c = a.replace(w, T);
      _[c] = new S(c, 1, !1, a, null, !1, !1);
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (a) {
        var c = a.replace(w, T);
        _[c] = new S(c, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
      }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
      var c = a.replace(w, T);
      _[c] = new S(c, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (a) {
      _[a] = new S(a, 1, !1, a.toLowerCase(), null, !1, !1);
    }),
    (_.xlinkHref = new S(
      "xlinkHref",
      1,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    )),
    ["src", "href", "action", "formAction"].forEach(function (a) {
      _[a] = new S(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
  function E(a, c, v, M) {
    var I = _.hasOwnProperty(c) ? _[c] : null;
    (I !== null
      ? I.type !== 0
      : M ||
        !(2 < c.length) ||
        (c[0] !== "o" && c[0] !== "O") ||
        (c[1] !== "n" && c[1] !== "N")) &&
      (x(c, v, I, M) && (v = null),
      M || I === null
        ? g(c) &&
          (v === null ? a.removeAttribute(c) : a.setAttribute(c, "" + v))
        : I.mustUseProperty
        ? (a[I.propertyName] = v === null ? (I.type === 3 ? !1 : "") : v)
        : ((c = I.attributeName),
          (M = I.attributeNamespace),
          v === null
            ? a.removeAttribute(c)
            : ((I = I.type),
              (v = I === 3 || (I === 4 && v === !0) ? "" : "" + v),
              M ? a.setAttributeNS(M, c, v) : a.setAttribute(c, v))));
  }
  var A = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    R = Symbol.for("react.element"),
    k = Symbol.for("react.portal"),
    P = Symbol.for("react.fragment"),
    U = Symbol.for("react.strict_mode"),
    N = Symbol.for("react.profiler"),
    L = Symbol.for("react.provider"),
    H = Symbol.for("react.context"),
    G = Symbol.for("react.forward_ref"),
    $ = Symbol.for("react.suspense"),
    q = Symbol.for("react.suspense_list"),
    Z = Symbol.for("react.memo"),
    X = Symbol.for("react.lazy"),
    re = Symbol.for("react.offscreen"),
    W = Symbol.iterator;
  function te(a) {
    return a === null || typeof a != "object"
      ? null
      : ((a = (W && a[W]) || a["@@iterator"]),
        typeof a == "function" ? a : null);
  }
  var F = Object.assign,
    V;
  function ne(a) {
    if (V === void 0)
      try {
        throw Error();
      } catch (v) {
        var c = v.stack.trim().match(/\n( *(at )?)/);
        V = (c && c[1]) || "";
      }
    return (
      `
` +
      V +
      a
    );
  }
  var ae = !1;
  function J(a, c) {
    if (!a || ae) return "";
    ae = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c)
        if (
          ((c = function () {
            throw Error();
          }),
          Object.defineProperty(c.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(c, []);
          } catch (je) {
            var M = je;
          }
          Reflect.construct(a, [], c);
        } else {
          try {
            c.call();
          } catch (je) {
            M = je;
          }
          a.call(c.prototype);
        }
      else {
        try {
          throw Error();
        } catch (je) {
          M = je;
        }
        a();
      }
    } catch (je) {
      if (je && M && typeof je.stack == "string") {
        for (
          var I = je.stack.split(`
`),
            O = M.stack.split(`
`),
            Y = I.length - 1,
            pe = O.length - 1;
          1 <= Y && 0 <= pe && I[Y] !== O[pe];

        )
          pe--;
        for (; 1 <= Y && 0 <= pe; Y--, pe--)
          if (I[Y] !== O[pe]) {
            if (Y !== 1 || pe !== 1)
              do
                if ((Y--, pe--, 0 > pe || I[Y] !== O[pe])) {
                  var ye =
                    `
` + I[Y].replace(" at new ", " at ");
                  return (
                    a.displayName &&
                      ye.includes("<anonymous>") &&
                      (ye = ye.replace("<anonymous>", a.displayName)),
                    ye
                  );
                }
              while (1 <= Y && 0 <= pe);
            break;
          }
      }
    } finally {
      (ae = !1), (Error.prepareStackTrace = v);
    }
    return (a = a ? a.displayName || a.name : "") ? ne(a) : "";
  }
  function oe(a) {
    switch (a.tag) {
      case 5:
        return ne(a.type);
      case 16:
        return ne("Lazy");
      case 13:
        return ne("Suspense");
      case 19:
        return ne("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (a = J(a.type, !1)), a;
      case 11:
        return (a = J(a.type.render, !1)), a;
      case 1:
        return (a = J(a.type, !0)), a;
      default:
        return "";
    }
  }
  function de(a) {
    if (a == null) return null;
    if (typeof a == "function") return a.displayName || a.name || null;
    if (typeof a == "string") return a;
    switch (a) {
      case P:
        return "Fragment";
      case k:
        return "Portal";
      case N:
        return "Profiler";
      case U:
        return "StrictMode";
      case $:
        return "Suspense";
      case q:
        return "SuspenseList";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case H:
          return (a.displayName || "Context") + ".Consumer";
        case L:
          return (a._context.displayName || "Context") + ".Provider";
        case G:
          var c = a.render;
          return (
            (a = a.displayName),
            a ||
              ((a = c.displayName || c.name || ""),
              (a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef")),
            a
          );
        case Z:
          return (
            (c = a.displayName || null), c !== null ? c : de(a.type) || "Memo"
          );
        case X:
          (c = a._payload), (a = a._init);
          try {
            return de(a(c));
          } catch {}
      }
    return null;
  }
  function le(a) {
    var c = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (a = c.render),
          (a = a.displayName || a.name || ""),
          c.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return de(c);
      case 8:
        return c === U ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function") return c.displayName || c.name || null;
        if (typeof c == "string") return c;
    }
    return null;
  }
  function fe(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ee(a) {
    var c = a.type;
    return (
      (a = a.nodeName) &&
      a.toLowerCase() === "input" &&
      (c === "checkbox" || c === "radio")
    );
  }
  function ge(a) {
    var c = Ee(a) ? "checked" : "value",
      v = Object.getOwnPropertyDescriptor(a.constructor.prototype, c),
      M = "" + a[c];
    if (
      !a.hasOwnProperty(c) &&
      typeof v < "u" &&
      typeof v.get == "function" &&
      typeof v.set == "function"
    ) {
      var I = v.get,
        O = v.set;
      return (
        Object.defineProperty(a, c, {
          configurable: !0,
          get: function () {
            return I.call(this);
          },
          set: function (Y) {
            (M = "" + Y), O.call(this, Y);
          },
        }),
        Object.defineProperty(a, c, { enumerable: v.enumerable }),
        {
          getValue: function () {
            return M;
          },
          setValue: function (Y) {
            M = "" + Y;
          },
          stopTracking: function () {
            (a._valueTracker = null), delete a[c];
          },
        }
      );
    }
  }
  function xe(a) {
    a._valueTracker || (a._valueTracker = ge(a));
  }
  function j(a) {
    if (!a) return !1;
    var c = a._valueTracker;
    if (!c) return !0;
    var v = c.getValue(),
      M = "";
    return (
      a && (M = Ee(a) ? (a.checked ? "true" : "false") : a.value),
      (a = M),
      a !== v ? (c.setValue(a), !0) : !1
    );
  }
  function we(a) {
    if (
      ((a = a || (typeof document < "u" ? document : void 0)), typeof a > "u")
    )
      return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  function Ae(a, c) {
    var v = c.checked;
    return F({}, c, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: v ?? a._wrapperState.initialChecked,
    });
  }
  function Ne(a, c) {
    var v = c.defaultValue == null ? "" : c.defaultValue,
      M = c.checked != null ? c.checked : c.defaultChecked;
    (v = fe(c.value != null ? c.value : v)),
      (a._wrapperState = {
        initialChecked: M,
        initialValue: v,
        controlled:
          c.type === "checkbox" || c.type === "radio"
            ? c.checked != null
            : c.value != null,
      });
  }
  function Ie(a, c) {
    (c = c.checked), c != null && E(a, "checked", c, !1);
  }
  function rt(a, c) {
    Ie(a, c);
    var v = fe(c.value),
      M = c.type;
    if (v != null)
      M === "number"
        ? ((v === 0 && a.value === "") || a.value != v) && (a.value = "" + v)
        : a.value !== "" + v && (a.value = "" + v);
    else if (M === "submit" || M === "reset") {
      a.removeAttribute("value");
      return;
    }
    c.hasOwnProperty("value")
      ? Xe(a, c.type, v)
      : c.hasOwnProperty("defaultValue") && Xe(a, c.type, fe(c.defaultValue)),
      c.checked == null &&
        c.defaultChecked != null &&
        (a.defaultChecked = !!c.defaultChecked);
  }
  function ke(a, c, v) {
    if (c.hasOwnProperty("value") || c.hasOwnProperty("defaultValue")) {
      var M = c.type;
      if (
        !(
          (M !== "submit" && M !== "reset") ||
          (c.value !== void 0 && c.value !== null)
        )
      )
        return;
      (c = "" + a._wrapperState.initialValue),
        v || c === a.value || (a.value = c),
        (a.defaultValue = c);
    }
    (v = a.name),
      v !== "" && (a.name = ""),
      (a.defaultChecked = !!a._wrapperState.initialChecked),
      v !== "" && (a.name = v);
  }
  function Xe(a, c, v) {
    (c !== "number" || we(a.ownerDocument) !== a) &&
      (v == null
        ? (a.defaultValue = "" + a._wrapperState.initialValue)
        : a.defaultValue !== "" + v && (a.defaultValue = "" + v));
  }
  var ee = Array.isArray;
  function B(a, c, v, M) {
    if (((a = a.options), c)) {
      c = {};
      for (var I = 0; I < v.length; I++) c["$" + v[I]] = !0;
      for (v = 0; v < a.length; v++)
        (I = c.hasOwnProperty("$" + a[v].value)),
          a[v].selected !== I && (a[v].selected = I),
          I && M && (a[v].defaultSelected = !0);
    } else {
      for (v = "" + fe(v), c = null, I = 0; I < a.length; I++) {
        if (a[I].value === v) {
          (a[I].selected = !0), M && (a[I].defaultSelected = !0);
          return;
        }
        c !== null || a[I].disabled || (c = a[I]);
      }
      c !== null && (c.selected = !0);
    }
  }
  function ve(a, c) {
    if (c.dangerouslySetInnerHTML != null) throw Error(t(91));
    return F({}, c, {
      value: void 0,
      defaultValue: void 0,
      children: "" + a._wrapperState.initialValue,
    });
  }
  function Se(a, c) {
    var v = c.value;
    if (v == null) {
      if (((v = c.children), (c = c.defaultValue), v != null)) {
        if (c != null) throw Error(t(92));
        if (ee(v)) {
          if (1 < v.length) throw Error(t(93));
          v = v[0];
        }
        c = v;
      }
      c == null && (c = ""), (v = c);
    }
    a._wrapperState = { initialValue: fe(v) };
  }
  function _e(a, c) {
    var v = fe(c.value),
      M = fe(c.defaultValue);
    v != null &&
      ((v = "" + v),
      v !== a.value && (a.value = v),
      c.defaultValue == null && a.defaultValue !== v && (a.defaultValue = v)),
      M != null && (a.defaultValue = "" + M);
  }
  function Te(a) {
    var c = a.textContent;
    c === a._wrapperState.initialValue &&
      c !== "" &&
      c !== null &&
      (a.value = c);
  }
  function at(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Fe(a, c) {
    return a == null || a === "http://www.w3.org/1999/xhtml"
      ? at(c)
      : a === "http://www.w3.org/2000/svg" && c === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : a;
  }
  var Be,
    We = (function (a) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (c, v, M, I) {
            MSApp.execUnsafeLocalFunction(function () {
              return a(c, v, M, I);
            });
          }
        : a;
    })(function (a, c) {
      if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
        a.innerHTML = c;
      else {
        for (
          Be = Be || document.createElement("div"),
            Be.innerHTML = "<svg>" + c.valueOf().toString() + "</svg>",
            c = Be.firstChild;
          a.firstChild;

        )
          a.removeChild(a.firstChild);
        for (; c.firstChild; ) a.appendChild(c.firstChild);
      }
    });
  function Ye(a, c) {
    if (c) {
      var v = a.firstChild;
      if (v && v === a.lastChild && v.nodeType === 3) {
        v.nodeValue = c;
        return;
      }
    }
    a.textContent = c;
  }
  var nt = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    yt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(nt).forEach(function (a) {
    yt.forEach(function (c) {
      (c = c + a.charAt(0).toUpperCase() + a.substring(1)), (nt[c] = nt[a]);
    });
  });
  function $e(a, c, v) {
    return c == null || typeof c == "boolean" || c === ""
      ? ""
      : v || typeof c != "number" || c === 0 || (nt.hasOwnProperty(a) && nt[a])
      ? ("" + c).trim()
      : c + "px";
  }
  function qe(a, c) {
    a = a.style;
    for (var v in c)
      if (c.hasOwnProperty(v)) {
        var M = v.indexOf("--") === 0,
          I = $e(v, c[v], M);
        v === "float" && (v = "cssFloat"), M ? a.setProperty(v, I) : (a[v] = I);
      }
  }
  var et = F(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    }
  );
  function he(a, c) {
    if (c) {
      if (et[a] && (c.children != null || c.dangerouslySetInnerHTML != null))
        throw Error(t(137, a));
      if (c.dangerouslySetInnerHTML != null) {
        if (c.children != null) throw Error(t(60));
        if (
          typeof c.dangerouslySetInnerHTML != "object" ||
          !("__html" in c.dangerouslySetInnerHTML)
        )
          throw Error(t(61));
      }
      if (c.style != null && typeof c.style != "object") throw Error(t(62));
    }
  }
  function Je(a, c) {
    if (a.indexOf("-") === -1) return typeof c.is == "string";
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var me = null;
  function Ve(a) {
    return (
      (a = a.target || a.srcElement || window),
      a.correspondingUseElement && (a = a.correspondingUseElement),
      a.nodeType === 3 ? a.parentNode : a
    );
  }
  var Re = null,
    Ue = null,
    it = null;
  function mt(a) {
    if ((a = Vs(a))) {
      if (typeof Re != "function") throw Error(t(280));
      var c = a.stateNode;
      c && ((c = nd(c)), Re(a.stateNode, a.type, c));
    }
  }
  function gt(a) {
    Ue ? (it ? it.push(a) : (it = [a])) : (Ue = a);
  }
  function Ot() {
    if (Ue) {
      var a = Ue,
        c = it;
      if (((it = Ue = null), mt(a), c)) for (a = 0; a < c.length; a++) mt(c[a]);
    }
  }
  function Ut(a, c) {
    return a(c);
  }
  function ht() {}
  var $t = !1;
  function un(a, c, v) {
    if ($t) return a(c, v);
    $t = !0;
    try {
      return Ut(a, c, v);
    } finally {
      ($t = !1), (Ue !== null || it !== null) && (ht(), Ot());
    }
  }
  function Sn(a, c) {
    var v = a.stateNode;
    if (v === null) return null;
    var M = nd(v);
    if (M === null) return null;
    v = M[c];
    e: switch (c) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (M = !M.disabled) ||
          ((a = a.type),
          (M = !(
            a === "button" ||
            a === "input" ||
            a === "select" ||
            a === "textarea"
          ))),
          (a = !M);
        break e;
      default:
        a = !1;
    }
    if (a) return null;
    if (v && typeof v != "function") throw Error(t(231, c, typeof v));
    return v;
  }
  var mn = !1;
  if (l)
    try {
      var lr = {};
      Object.defineProperty(lr, "passive", {
        get: function () {
          mn = !0;
        },
      }),
        window.addEventListener("test", lr, lr),
        window.removeEventListener("test", lr, lr);
    } catch {
      mn = !1;
    }
  function Ui(a, c, v, M, I, O, Y, pe, ye) {
    var je = Array.prototype.slice.call(arguments, 3);
    try {
      c.apply(v, je);
    } catch (st) {
      this.onError(st);
    }
  }
  var yr = !1,
    Fr = null,
    Ar = !1,
    Br = null,
    xr = {
      onError: function (a) {
        (yr = !0), (Fr = a);
      },
    };
  function yo(a, c, v, M, I, O, Y, pe, ye) {
    (yr = !1), (Fr = null), Ui.apply(xr, arguments);
  }
  function Vl(a, c, v, M, I, O, Y, pe, ye) {
    if ((yo.apply(this, arguments), yr)) {
      if (yr) {
        var je = Fr;
        (yr = !1), (Fr = null);
      } else throw Error(t(198));
      Ar || ((Ar = !0), (Br = je));
    }
  }
  function no(a) {
    var c = a,
      v = a;
    if (a.alternate) for (; c.return; ) c = c.return;
    else {
      a = c;
      do (c = a), (c.flags & 4098) !== 0 && (v = c.return), (a = c.return);
      while (a);
    }
    return c.tag === 3 ? v : null;
  }
  function Gl(a) {
    if (a.tag === 13) {
      var c = a.memoizedState;
      if (
        (c === null && ((a = a.alternate), a !== null && (c = a.memoizedState)),
        c !== null)
      )
        return c.dehydrated;
    }
    return null;
  }
  function ie(a) {
    if (no(a) !== a) throw Error(t(188));
  }
  function Ce(a) {
    var c = a.alternate;
    if (!c) {
      if (((c = no(a)), c === null)) throw Error(t(188));
      return c !== a ? null : a;
    }
    for (var v = a, M = c; ; ) {
      var I = v.return;
      if (I === null) break;
      var O = I.alternate;
      if (O === null) {
        if (((M = I.return), M !== null)) {
          v = M;
          continue;
        }
        break;
      }
      if (I.child === O.child) {
        for (O = I.child; O; ) {
          if (O === v) return ie(I), a;
          if (O === M) return ie(I), c;
          O = O.sibling;
        }
        throw Error(t(188));
      }
      if (v.return !== M.return) (v = I), (M = O);
      else {
        for (var Y = !1, pe = I.child; pe; ) {
          if (pe === v) {
            (Y = !0), (v = I), (M = O);
            break;
          }
          if (pe === M) {
            (Y = !0), (M = I), (v = O);
            break;
          }
          pe = pe.sibling;
        }
        if (!Y) {
          for (pe = O.child; pe; ) {
            if (pe === v) {
              (Y = !0), (v = O), (M = I);
              break;
            }
            if (pe === M) {
              (Y = !0), (M = O), (v = I);
              break;
            }
            pe = pe.sibling;
          }
          if (!Y) throw Error(t(189));
        }
      }
      if (v.alternate !== M) throw Error(t(190));
    }
    if (v.tag !== 3) throw Error(t(188));
    return v.stateNode.current === v ? a : c;
  }
  function ze(a) {
    return (a = Ce(a)), a !== null ? Ge(a) : null;
  }
  function Ge(a) {
    if (a.tag === 5 || a.tag === 6) return a;
    for (a = a.child; a !== null; ) {
      var c = Ge(a);
      if (c !== null) return c;
      a = a.sibling;
    }
    return null;
  }
  var Le = e.unstable_scheduleCallback,
    ut = e.unstable_cancelCallback,
    vt = e.unstable_shouldYield,
    Et = e.unstable_requestPaint,
    Ke = e.unstable_now,
    Dt = e.unstable_getCurrentPriorityLevel,
    Ft = e.unstable_ImmediatePriority,
    At = e.unstable_UserBlockingPriority,
    nn = e.unstable_NormalPriority,
    Cn = e.unstable_LowPriority,
    dn = e.unstable_IdlePriority,
    wn = null,
    wt = null;
  function dt(a) {
    if (wt && typeof wt.onCommitFiberRoot == "function")
      try {
        wt.onCommitFiberRoot(wn, a, void 0, (a.current.flags & 128) === 128);
      } catch {}
  }
  var Qt = Math.clz32 ? Math.clz32 : ii,
    zt = Math.log,
    bn = Math.LN2;
  function ii(a) {
    return (a >>>= 0), a === 0 ? 32 : (31 - ((zt(a) / bn) | 0)) | 0;
  }
  var An = 64,
    Wn = 4194304;
  function cn(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function zr(a, c) {
    var v = a.pendingLanes;
    if (v === 0) return 0;
    var M = 0,
      I = a.suspendedLanes,
      O = a.pingedLanes,
      Y = v & 268435455;
    if (Y !== 0) {
      var pe = Y & ~I;
      pe !== 0 ? (M = cn(pe)) : ((O &= Y), O !== 0 && (M = cn(O)));
    } else (Y = v & ~I), Y !== 0 ? (M = cn(Y)) : O !== 0 && (M = cn(O));
    if (M === 0) return 0;
    if (
      c !== 0 &&
      c !== M &&
      (c & I) === 0 &&
      ((I = M & -M), (O = c & -c), I >= O || (I === 16 && (O & 4194240) !== 0))
    )
      return c;
    if (((M & 4) !== 0 && (M |= v & 16), (c = a.entangledLanes), c !== 0))
      for (a = a.entanglements, c &= M; 0 < c; )
        (v = 31 - Qt(c)), (I = 1 << v), (M |= a[v]), (c &= ~I);
    return M;
  }
  function ls(a, c) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function ur(a, c) {
    for (
      var v = a.suspendedLanes,
        M = a.pingedLanes,
        I = a.expirationTimes,
        O = a.pendingLanes;
      0 < O;

    ) {
      var Y = 31 - Qt(O),
        pe = 1 << Y,
        ye = I[Y];
      ye === -1
        ? ((pe & v) === 0 || (pe & M) !== 0) && (I[Y] = ls(pe, c))
        : ye <= c && (a.expiredLanes |= pe),
        (O &= ~pe);
    }
  }
  function Rr(a) {
    return (
      (a = a.pendingLanes & -1073741825),
      a !== 0 ? a : a & 1073741824 ? 1073741824 : 0
    );
  }
  function di() {
    var a = An;
    return (An <<= 1), (An & 4194240) === 0 && (An = 64), a;
  }
  function zo(a) {
    for (var c = [], v = 0; 31 > v; v++) c.push(a);
    return c;
  }
  function Ho(a, c, v) {
    (a.pendingLanes |= c),
      c !== 536870912 && ((a.suspendedLanes = 0), (a.pingedLanes = 0)),
      (a = a.eventTimes),
      (c = 31 - Qt(c)),
      (a[c] = v);
  }
  function Pf(a, c) {
    var v = a.pendingLanes & ~c;
    (a.pendingLanes = c),
      (a.suspendedLanes = 0),
      (a.pingedLanes = 0),
      (a.expiredLanes &= c),
      (a.mutableReadLanes &= c),
      (a.entangledLanes &= c),
      (c = a.entanglements);
    var M = a.eventTimes;
    for (a = a.expirationTimes; 0 < v; ) {
      var I = 31 - Qt(v),
        O = 1 << I;
      (c[I] = 0), (M[I] = -1), (a[I] = -1), (v &= ~O);
    }
  }
  function Vo(a, c) {
    var v = (a.entangledLanes |= c);
    for (a = a.entanglements; v; ) {
      var M = 31 - Qt(v),
        I = 1 << M;
      (I & c) | (a[M] & c) && (a[M] |= c), (v &= ~I);
    }
  }
  var ln = 0;
  function us(a) {
    return (
      (a &= -a),
      1 < a ? (4 < a ? ((a & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
    );
  }
  var da,
    Wl,
    jl,
    cs,
    Ka,
    xo = !1,
    Go = [],
    oi = null,
    Xt = null,
    _o = null,
    ro = new Map(),
    fs = new Map(),
    So = [],
    If =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
  function Yn(a, c) {
    switch (a) {
      case "focusin":
      case "focusout":
        oi = null;
        break;
      case "dragenter":
      case "dragleave":
        Xt = null;
        break;
      case "mouseover":
      case "mouseout":
        _o = null;
        break;
      case "pointerover":
      case "pointerout":
        ro.delete(c.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        fs.delete(c.pointerId);
    }
  }
  function Wo(a, c, v, M, I, O) {
    return a === null || a.nativeEvent !== O
      ? ((a = {
          blockedOn: c,
          domEventName: v,
          eventSystemFlags: M,
          nativeEvent: O,
          targetContainers: [I],
        }),
        c !== null && ((c = Vs(c)), c !== null && Wl(c)),
        a)
      : ((a.eventSystemFlags |= M),
        (c = a.targetContainers),
        I !== null && c.indexOf(I) === -1 && c.push(I),
        a);
  }
  function Lf(a, c, v, M, I) {
    switch (c) {
      case "focusin":
        return (oi = Wo(oi, a, c, v, M, I)), !0;
      case "dragenter":
        return (Xt = Wo(Xt, a, c, v, M, I)), !0;
      case "mouseover":
        return (_o = Wo(_o, a, c, v, M, I)), !0;
      case "pointerover":
        var O = I.pointerId;
        return ro.set(O, Wo(ro.get(O) || null, a, c, v, M, I)), !0;
      case "gotpointercapture":
        return (
          (O = I.pointerId), fs.set(O, Wo(fs.get(O) || null, a, c, v, M, I)), !0
        );
    }
    return !1;
  }
  function hi(a) {
    var c = Ma(a.target);
    if (c !== null) {
      var v = no(c);
      if (v !== null) {
        if (((c = v.tag), c === 13)) {
          if (((c = Gl(v)), c !== null)) {
            (a.blockedOn = c),
              Ka(a.priority, function () {
                jl(v);
              });
            return;
          }
        } else if (c === 3 && v.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = v.tag === 3 ? v.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function ha(a) {
    if (a.blockedOn !== null) return !1;
    for (var c = a.targetContainers; 0 < c.length; ) {
      var v = pi(a.domEventName, a.eventSystemFlags, c[0], a.nativeEvent);
      if (v === null) {
        v = a.nativeEvent;
        var M = new v.constructor(v.type, v);
        (me = M), v.target.dispatchEvent(M), (me = null);
      } else return (c = Vs(v)), c !== null && Wl(c), (a.blockedOn = v), !1;
      c.shift();
    }
    return !0;
  }
  function pa(a, c, v) {
    ha(a) && v.delete(c);
  }
  function io() {
    (xo = !1),
      oi !== null && ha(oi) && (oi = null),
      Xt !== null && ha(Xt) && (Xt = null),
      _o !== null && ha(_o) && (_o = null),
      ro.forEach(pa),
      fs.forEach(pa);
  }
  function Is(a, c) {
    a.blockedOn === c &&
      ((a.blockedOn = null),
      xo ||
        ((xo = !0),
        e.unstable_scheduleCallback(e.unstable_NormalPriority, io)));
  }
  function ma(a) {
    function c(I) {
      return Is(I, a);
    }
    if (0 < Go.length) {
      Is(Go[0], a);
      for (var v = 1; v < Go.length; v++) {
        var M = Go[v];
        M.blockedOn === a && (M.blockedOn = null);
      }
    }
    for (
      oi !== null && Is(oi, a),
        Xt !== null && Is(Xt, a),
        _o !== null && Is(_o, a),
        ro.forEach(c),
        fs.forEach(c),
        v = 0;
      v < So.length;
      v++
    )
      (M = So[v]), M.blockedOn === a && (M.blockedOn = null);
    for (; 0 < So.length && ((v = So[0]), v.blockedOn === null); )
      hi(v), v.blockedOn === null && So.shift();
  }
  var Hr = A.ReactCurrentBatchConfig,
    Vr = !0;
  function ds(a, c, v, M) {
    var I = ln,
      O = Hr.transition;
    Hr.transition = null;
    try {
      (ln = 1), Za(a, c, v, M);
    } finally {
      (ln = I), (Hr.transition = O);
    }
  }
  function wo(a, c, v, M) {
    var I = ln,
      O = Hr.transition;
    Hr.transition = null;
    try {
      (ln = 4), Za(a, c, v, M);
    } finally {
      (ln = I), (Hr.transition = O);
    }
  }
  function Za(a, c, v, M) {
    if (Vr) {
      var I = pi(a, c, v, M);
      if (I === null) Kf(a, c, M, ga, v), Yn(a, M);
      else if (Lf(I, a, c, v, M)) M.stopPropagation();
      else if ((Yn(a, M), c & 4 && -1 < If.indexOf(a))) {
        for (; I !== null; ) {
          var O = Vs(I);
          if (
            (O !== null && da(O),
            (O = pi(a, c, v, M)),
            O === null && Kf(a, c, M, ga, v),
            O === I)
          )
            break;
          I = O;
        }
        I !== null && M.stopPropagation();
      } else Kf(a, c, M, null, v);
    }
  }
  var ga = null;
  function pi(a, c, v, M) {
    if (((ga = null), (a = Ve(M)), (a = Ma(a)), a !== null))
      if (((c = no(a)), c === null)) a = null;
      else if (((v = c.tag), v === 13)) {
        if (((a = Gl(c)), a !== null)) return a;
        a = null;
      } else if (v === 3) {
        if (c.stateNode.current.memoizedState.isDehydrated)
          return c.tag === 3 ? c.stateNode.containerInfo : null;
        a = null;
      } else c !== a && (a = null);
    return (ga = a), null;
  }
  function va(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Dt()) {
          case Ft:
            return 1;
          case At:
            return 4;
          case nn:
          case Cn:
            return 16;
          case dn:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Fi = null,
    Ls = null,
    Gr = null;
  function Pr() {
    if (Gr) return Gr;
    var a,
      c = Ls,
      v = c.length,
      M,
      I = "value" in Fi ? Fi.value : Fi.textContent,
      O = I.length;
    for (a = 0; a < v && c[a] === I[a]; a++);
    var Y = v - a;
    for (M = 1; M <= Y && c[v - M] === I[O - M]; M++);
    return (Gr = I.slice(a, 1 < M ? 1 - M : void 0));
  }
  function ks(a) {
    var c = a.keyCode;
    return (
      "charCode" in a
        ? ((a = a.charCode), a === 0 && c === 13 && (a = 13))
        : (a = c),
      a === 10 && (a = 13),
      32 <= a || a === 13 ? a : 0
    );
  }
  function Bi() {
    return !0;
  }
  function Ds() {
    return !1;
  }
  function Wr(a) {
    function c(v, M, I, O, Y) {
      (this._reactName = v),
        (this._targetInst = I),
        (this.type = M),
        (this.nativeEvent = O),
        (this.target = Y),
        (this.currentTarget = null);
      for (var pe in a)
        a.hasOwnProperty(pe) && ((v = a[pe]), (this[pe] = v ? v(O) : O[pe]));
      return (
        (this.isDefaultPrevented = (
          O.defaultPrevented != null ? O.defaultPrevented : O.returnValue === !1
        )
          ? Bi
          : Ds),
        (this.isPropagationStopped = Ds),
        this
      );
    }
    return (
      F(c.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var v = this.nativeEvent;
          v &&
            (v.preventDefault
              ? v.preventDefault()
              : typeof v.returnValue != "unknown" && (v.returnValue = !1),
            (this.isDefaultPrevented = Bi));
        },
        stopPropagation: function () {
          var v = this.nativeEvent;
          v &&
            (v.stopPropagation
              ? v.stopPropagation()
              : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0),
            (this.isPropagationStopped = Bi));
        },
        persist: function () {},
        isPersistent: Bi,
      }),
      c
    );
  }
  var Ns = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    _r = Wr(Ns),
    Ir = F({}, Ns, { view: 0, detail: 0 }),
    cr = Wr(Ir),
    er,
    Si,
    bo,
    $l = F({}, Ir, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: xa,
      button: 0,
      buttons: 0,
      relatedTarget: function (a) {
        return a.relatedTarget === void 0
          ? a.fromElement === a.srcElement
            ? a.toElement
            : a.fromElement
          : a.relatedTarget;
      },
      movementX: function (a) {
        return "movementX" in a
          ? a.movementX
          : (a !== bo &&
              (bo && a.type === "mousemove"
                ? ((er = a.screenX - bo.screenX), (Si = a.screenY - bo.screenY))
                : (Si = er = 0),
              (bo = a)),
            er);
      },
      movementY: function (a) {
        return "movementY" in a ? a.movementY : Si;
      },
    }),
    zh = Wr($l),
    Os = F({}, $l, { dataTransfer: 0 }),
    ya = Wr(Os),
    kf = F({}, Ir, { relatedTarget: 0 }),
    Df = Wr(kf),
    Nf = F({}, Ns, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    fg = Wr(Nf),
    dg = F({}, Ns, {
      clipboardData: function (a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      },
    }),
    Hh = Wr(dg),
    Of = F({}, Ns, { data: 0 }),
    Vh = Wr(Of),
    hg = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    pg = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    Gh = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function Xl(a) {
    var c = this.nativeEvent;
    return c.getModifierState
      ? c.getModifierState(a)
      : (a = Gh[a])
      ? !!c[a]
      : !1;
  }
  function xa() {
    return Xl;
  }
  var Uf = F({}, Ir, {
      key: function (a) {
        if (a.key) {
          var c = hg[a.key] || a.key;
          if (c !== "Unidentified") return c;
        }
        return a.type === "keypress"
          ? ((a = ks(a)), a === 13 ? "Enter" : String.fromCharCode(a))
          : a.type === "keydown" || a.type === "keyup"
          ? pg[a.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: xa,
      charCode: function (a) {
        return a.type === "keypress" ? ks(a) : 0;
      },
      keyCode: function (a) {
        return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      },
      which: function (a) {
        return a.type === "keypress"
          ? ks(a)
          : a.type === "keydown" || a.type === "keyup"
          ? a.keyCode
          : 0;
      },
    }),
    Ff = Wr(Uf),
    Mo = F({}, $l, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    oo = Wr(Mo),
    Ja = F({}, Ir, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: xa,
    }),
    Us = Wr(Ja),
    Fs = F({}, Ns, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Qa = Wr(Fs),
    mg = F({}, $l, {
      deltaX: function (a) {
        return "deltaX" in a
          ? a.deltaX
          : "wheelDeltaX" in a
          ? -a.wheelDeltaX
          : 0;
      },
      deltaY: function (a) {
        return "deltaY" in a
          ? a.deltaY
          : "wheelDeltaY" in a
          ? -a.wheelDeltaY
          : "wheelDelta" in a
          ? -a.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    Wh = Wr(mg),
    jh = [9, 13, 27, 32],
    wi = l && "CompositionEvent" in window,
    si = null;
  l && "documentMode" in document && (si = document.documentMode);
  var qn = l && "TextEvent" in window && !si,
    Yl = l && (!wi || (si && 8 < si && 11 >= si)),
    Eo = " ",
    $h = !1;
  function Xh(a, c) {
    switch (a) {
      case "keyup":
        return jh.indexOf(c.keyCode) !== -1;
      case "keydown":
        return c.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Bf(a) {
    return (a = a.detail), typeof a == "object" && "data" in a ? a.data : null;
  }
  var _a = !1;
  function gg(a, c) {
    switch (a) {
      case "compositionend":
        return Bf(c);
      case "keypress":
        return c.which !== 32 ? null : (($h = !0), Eo);
      case "textInput":
        return (a = c.data), a === Eo && $h ? null : a;
      default:
        return null;
    }
  }
  function Zu(a, c) {
    if (_a)
      return a === "compositionend" || (!wi && Xh(a, c))
        ? ((a = Pr()), (Gr = Ls = Fi = null), (_a = !1), a)
        : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(c.ctrlKey || c.altKey || c.metaKey) || (c.ctrlKey && c.altKey)) {
          if (c.char && 1 < c.char.length) return c.char;
          if (c.which) return String.fromCharCode(c.which);
        }
        return null;
      case "compositionend":
        return Yl && c.locale !== "ko" ? null : c.data;
      default:
        return null;
    }
  }
  var ql = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function zf(a) {
    var c = a && a.nodeName && a.nodeName.toLowerCase();
    return c === "input" ? !!ql[a.type] : c === "textarea";
  }
  function Kl(a, c, v, M) {
    gt(M),
      (c = Zf(c, "onChange")),
      0 < c.length &&
        ((v = new _r("onChange", "change", null, v, M)),
        a.push({ event: v, listeners: c }));
  }
  var Sa = null,
    Zl = null;
  function vg(a) {
    tu(a, 0);
  }
  function Bs(a) {
    var c = fr(a);
    if (j(c)) return a;
  }
  function yg(a, c) {
    if (a === "change") return c;
  }
  var Jl = !1;
  if (l) {
    var zi;
    if (l) {
      var el = "oninput" in document;
      if (!el) {
        var tl = document.createElement("div");
        tl.setAttribute("oninput", "return;"),
          (el = typeof tl.oninput == "function");
      }
      zi = el;
    } else zi = !1;
    Jl = zi && (!document.documentMode || 9 < document.documentMode);
  }
  function jo() {
    Sa && (Sa.detachEvent("onpropertychange", Hf), (Zl = Sa = null));
  }
  function Hf(a) {
    if (a.propertyName === "value" && Bs(Zl)) {
      var c = [];
      Kl(c, Zl, a, Ve(a)), un(vg, c);
    }
  }
  function Ql(a, c, v) {
    a === "focusin"
      ? (jo(), (Sa = c), (Zl = v), Sa.attachEvent("onpropertychange", Hf))
      : a === "focusout" && jo();
  }
  function xg(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return Bs(Zl);
  }
  function Yh(a, c) {
    if (a === "click") return Bs(c);
  }
  function tr(a, c) {
    if (a === "input" || a === "change") return Bs(c);
  }
  function Vf(a, c) {
    return (a === c && (a !== 0 || 1 / a === 1 / c)) || (a !== a && c !== c);
  }
  var so = typeof Object.is == "function" ? Object.is : Vf;
  function nl(a, c) {
    if (so(a, c)) return !0;
    if (
      typeof a != "object" ||
      a === null ||
      typeof c != "object" ||
      c === null
    )
      return !1;
    var v = Object.keys(a),
      M = Object.keys(c);
    if (v.length !== M.length) return !1;
    for (M = 0; M < v.length; M++) {
      var I = v[M];
      if (!u.call(c, I) || !so(a[I], c[I])) return !1;
    }
    return !0;
  }
  function Ju(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function ao(a, c) {
    var v = Ju(a);
    a = 0;
    for (var M; v; ) {
      if (v.nodeType === 3) {
        if (((M = a + v.textContent.length), a <= c && M >= c))
          return { node: v, offset: c - a };
        a = M;
      }
      e: {
        for (; v; ) {
          if (v.nextSibling) {
            v = v.nextSibling;
            break e;
          }
          v = v.parentNode;
        }
        v = void 0;
      }
      v = Ju(v);
    }
  }
  function rl(a, c) {
    return a && c
      ? a === c
        ? !0
        : a && a.nodeType === 3
        ? !1
        : c && c.nodeType === 3
        ? rl(a, c.parentNode)
        : "contains" in a
        ? a.contains(c)
        : a.compareDocumentPosition
        ? !!(a.compareDocumentPosition(c) & 16)
        : !1
      : !1;
  }
  function nr() {
    for (var a = window, c = we(); c instanceof a.HTMLIFrameElement; ) {
      try {
        var v = typeof c.contentWindow.location.href == "string";
      } catch {
        v = !1;
      }
      if (v) a = c.contentWindow;
      else break;
      c = we(a.document);
    }
    return c;
  }
  function jr(a) {
    var c = a && a.nodeName && a.nodeName.toLowerCase();
    return (
      c &&
      ((c === "input" &&
        (a.type === "text" ||
          a.type === "search" ||
          a.type === "tel" ||
          a.type === "url" ||
          a.type === "password")) ||
        c === "textarea" ||
        a.contentEditable === "true")
    );
  }
  function $r(a) {
    var c = nr(),
      v = a.focusedElem,
      M = a.selectionRange;
    if (
      c !== v &&
      v &&
      v.ownerDocument &&
      rl(v.ownerDocument.documentElement, v)
    ) {
      if (M !== null && jr(v)) {
        if (
          ((c = M.start),
          (a = M.end),
          a === void 0 && (a = c),
          "selectionStart" in v)
        )
          (v.selectionStart = c),
            (v.selectionEnd = Math.min(a, v.value.length));
        else if (
          ((a = ((c = v.ownerDocument || document) && c.defaultView) || window),
          a.getSelection)
        ) {
          a = a.getSelection();
          var I = v.textContent.length,
            O = Math.min(M.start, I);
          (M = M.end === void 0 ? O : Math.min(M.end, I)),
            !a.extend && O > M && ((I = M), (M = O), (O = I)),
            (I = ao(v, O));
          var Y = ao(v, M);
          I &&
            Y &&
            (a.rangeCount !== 1 ||
              a.anchorNode !== I.node ||
              a.anchorOffset !== I.offset ||
              a.focusNode !== Y.node ||
              a.focusOffset !== Y.offset) &&
            ((c = c.createRange()),
            c.setStart(I.node, I.offset),
            a.removeAllRanges(),
            O > M
              ? (a.addRange(c), a.extend(Y.node, Y.offset))
              : (c.setEnd(Y.node, Y.offset), a.addRange(c)));
        }
      }
      for (c = [], a = v; (a = a.parentNode); )
        a.nodeType === 1 &&
          c.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      for (typeof v.focus == "function" && v.focus(), v = 0; v < c.length; v++)
        (a = c[v]),
          (a.element.scrollLeft = a.left),
          (a.element.scrollTop = a.top);
    }
  }
  var Gf = l && "documentMode" in document && 11 >= document.documentMode,
    hs = null,
    il = null,
    Qu = null,
    Xr = !1;
  function Wf(a, c, v) {
    var M =
      v.window === v ? v.document : v.nodeType === 9 ? v : v.ownerDocument;
    Xr ||
      hs == null ||
      hs !== we(M) ||
      ((M = hs),
      "selectionStart" in M && jr(M)
        ? (M = { start: M.selectionStart, end: M.selectionEnd })
        : ((M = (
            (M.ownerDocument && M.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (M = {
            anchorNode: M.anchorNode,
            anchorOffset: M.anchorOffset,
            focusNode: M.focusNode,
            focusOffset: M.focusOffset,
          })),
      (Qu && nl(Qu, M)) ||
        ((Qu = M),
        (M = Zf(il, "onSelect")),
        0 < M.length &&
          ((c = new _r("onSelect", "select", null, c, v)),
          a.push({ event: c, listeners: M }),
          (c.target = hs))));
  }
  function eu(a, c) {
    var v = {};
    return (
      (v[a.toLowerCase()] = c.toLowerCase()),
      (v["Webkit" + a] = "webkit" + c),
      (v["Moz" + a] = "moz" + c),
      v
    );
  }
  var wa = {
      animationend: eu("Animation", "AnimationEnd"),
      animationiteration: eu("Animation", "AnimationIteration"),
      animationstart: eu("Animation", "AnimationStart"),
      transitionend: eu("Transition", "TransitionEnd"),
    },
    $o = {},
    Xo = {};
  l &&
    ((Xo = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete wa.animationend.animation,
      delete wa.animationiteration.animation,
      delete wa.animationstart.animation),
    "TransitionEvent" in window || delete wa.transitionend.transition);
  function ps(a) {
    if ($o[a]) return $o[a];
    if (!wa[a]) return a;
    var c = wa[a],
      v;
    for (v in c) if (c.hasOwnProperty(v) && v in Xo) return ($o[a] = c[v]);
    return a;
  }
  var ec = ps("animationend"),
    tc = ps("animationiteration"),
    qh = ps("animationstart"),
    Kh = ps("transitionend"),
    Zh = new Map(),
    Jh =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  function zs(a, c) {
    Zh.set(a, c), o(c, [a]);
  }
  for (var jf = 0; jf < Jh.length; jf++) {
    var nc = Jh[jf],
      rc = nc.toLowerCase(),
      _g = nc[0].toUpperCase() + nc.slice(1);
    zs(rc, "on" + _g);
  }
  zs(ec, "onAnimationEnd"),
    zs(tc, "onAnimationIteration"),
    zs(qh, "onAnimationStart"),
    zs("dblclick", "onDoubleClick"),
    zs("focusin", "onFocus"),
    zs("focusout", "onBlur"),
    zs(Kh, "onTransitionEnd"),
    s("onMouseEnter", ["mouseout", "mouseover"]),
    s("onMouseLeave", ["mouseout", "mouseover"]),
    s("onPointerEnter", ["pointerout", "pointerover"]),
    s("onPointerLeave", ["pointerout", "pointerover"]),
    o(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    o(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    o(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var ba =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    $f = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(ba)
    );
  function Xf(a, c, v) {
    var M = a.type || "unknown-event";
    (a.currentTarget = v), Vl(M, c, void 0, a), (a.currentTarget = null);
  }
  function tu(a, c) {
    c = (c & 4) !== 0;
    for (var v = 0; v < a.length; v++) {
      var M = a[v],
        I = M.event;
      M = M.listeners;
      e: {
        var O = void 0;
        if (c)
          for (var Y = M.length - 1; 0 <= Y; Y--) {
            var pe = M[Y],
              ye = pe.instance,
              je = pe.currentTarget;
            if (((pe = pe.listener), ye !== O && I.isPropagationStopped()))
              break e;
            Xf(I, pe, je), (O = ye);
          }
        else
          for (Y = 0; Y < M.length; Y++) {
            if (
              ((pe = M[Y]),
              (ye = pe.instance),
              (je = pe.currentTarget),
              (pe = pe.listener),
              ye !== O && I.isPropagationStopped())
            )
              break e;
            Xf(I, pe, je), (O = ye);
          }
      }
    }
    if (Ar) throw ((a = Br), (Ar = !1), (Br = null), a);
  }
  function Bn(a, c) {
    var v = c[al];
    v === void 0 && (v = c[al] = new Set());
    var M = a + "__bubble";
    v.has(M) || (qf(c, a, 2, !1), v.add(M));
  }
  function Yf(a, c, v) {
    var M = 0;
    c && (M |= 4), qf(v, a, M, c);
  }
  var ic = "_reactListening" + Math.random().toString(36).slice(2);
  function nu(a) {
    if (!a[ic]) {
      (a[ic] = !0),
        r.forEach(function (v) {
          v !== "selectionchange" && ($f.has(v) || Yf(v, !1, a), Yf(v, !0, a));
        });
      var c = a.nodeType === 9 ? a : a.ownerDocument;
      c === null || c[ic] || ((c[ic] = !0), Yf("selectionchange", !1, c));
    }
  }
  function qf(a, c, v, M) {
    switch (va(c)) {
      case 1:
        var I = ds;
        break;
      case 4:
        I = wo;
        break;
      default:
        I = Za;
    }
    (v = I.bind(null, c, v, a)),
      (I = void 0),
      !mn ||
        (c !== "touchstart" && c !== "touchmove" && c !== "wheel") ||
        (I = !0),
      M
        ? I !== void 0
          ? a.addEventListener(c, v, { capture: !0, passive: I })
          : a.addEventListener(c, v, !0)
        : I !== void 0
        ? a.addEventListener(c, v, { passive: I })
        : a.addEventListener(c, v, !1);
  }
  function Kf(a, c, v, M, I) {
    var O = M;
    if ((c & 1) === 0 && (c & 2) === 0 && M !== null)
      e: for (;;) {
        if (M === null) return;
        var Y = M.tag;
        if (Y === 3 || Y === 4) {
          var pe = M.stateNode.containerInfo;
          if (pe === I || (pe.nodeType === 8 && pe.parentNode === I)) break;
          if (Y === 4)
            for (Y = M.return; Y !== null; ) {
              var ye = Y.tag;
              if (
                (ye === 3 || ye === 4) &&
                ((ye = Y.stateNode.containerInfo),
                ye === I || (ye.nodeType === 8 && ye.parentNode === I))
              )
                return;
              Y = Y.return;
            }
          for (; pe !== null; ) {
            if (((Y = Ma(pe)), Y === null)) return;
            if (((ye = Y.tag), ye === 5 || ye === 6)) {
              M = O = Y;
              continue e;
            }
            pe = pe.parentNode;
          }
        }
        M = M.return;
      }
    un(function () {
      var je = O,
        st = Ve(v),
        lt = [];
      e: {
        var ot = Zh.get(a);
        if (ot !== void 0) {
          var Mt = _r,
            Rt = a;
          switch (a) {
            case "keypress":
              if (ks(v) === 0) break e;
            case "keydown":
            case "keyup":
              Mt = Ff;
              break;
            case "focusin":
              (Rt = "focus"), (Mt = Df);
              break;
            case "focusout":
              (Rt = "blur"), (Mt = Df);
              break;
            case "beforeblur":
            case "afterblur":
              Mt = Df;
              break;
            case "click":
              if (v.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Mt = zh;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Mt = ya;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Mt = Us;
              break;
            case ec:
            case tc:
            case qh:
              Mt = fg;
              break;
            case Kh:
              Mt = Qa;
              break;
            case "scroll":
              Mt = cr;
              break;
            case "wheel":
              Mt = Wh;
              break;
            case "copy":
            case "cut":
            case "paste":
              Mt = Hh;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Mt = oo;
          }
          var Lt = (c & 4) !== 0,
            Dr = !Lt && a === "scroll",
            De = Lt ? (ot !== null ? ot + "Capture" : null) : ot;
          Lt = [];
          for (var be = je, Oe; be !== null; ) {
            Oe = be;
            var ft = Oe.stateNode;
            if (
              (Oe.tag === 5 &&
                ft !== null &&
                ((Oe = ft),
                De !== null &&
                  ((ft = Sn(be, De)), ft != null && Lt.push(ru(be, ft, Oe)))),
              Dr)
            )
              break;
            be = be.return;
          }
          0 < Lt.length &&
            ((ot = new Mt(ot, Rt, null, v, st)),
            lt.push({ event: ot, listeners: Lt }));
        }
      }
      if ((c & 7) === 0) {
        e: {
          if (
            ((ot = a === "mouseover" || a === "pointerover"),
            (Mt = a === "mouseout" || a === "pointerout"),
            ot &&
              v !== me &&
              (Rt = v.relatedTarget || v.fromElement) &&
              (Ma(Rt) || Rt[lo]))
          )
            break e;
          if (
            (Mt || ot) &&
            ((ot =
              st.window === st
                ? st
                : (ot = st.ownerDocument)
                ? ot.defaultView || ot.parentWindow
                : window),
            Mt
              ? ((Rt = v.relatedTarget || v.toElement),
                (Mt = je),
                (Rt = Rt ? Ma(Rt) : null),
                Rt !== null &&
                  ((Dr = no(Rt)),
                  Rt !== Dr || (Rt.tag !== 5 && Rt.tag !== 6)) &&
                  (Rt = null))
              : ((Mt = null), (Rt = je)),
            Mt !== Rt)
          ) {
            if (
              ((Lt = zh),
              (ft = "onMouseLeave"),
              (De = "onMouseEnter"),
              (be = "mouse"),
              (a === "pointerout" || a === "pointerover") &&
                ((Lt = oo),
                (ft = "onPointerLeave"),
                (De = "onPointerEnter"),
                (be = "pointer")),
              (Dr = Mt == null ? ot : fr(Mt)),
              (Oe = Rt == null ? ot : fr(Rt)),
              (ot = new Lt(ft, be + "leave", Mt, v, st)),
              (ot.target = Dr),
              (ot.relatedTarget = Oe),
              (ft = null),
              Ma(st) === je &&
                ((Lt = new Lt(De, be + "enter", Rt, v, st)),
                (Lt.target = Oe),
                (Lt.relatedTarget = Dr),
                (ft = Lt)),
              (Dr = ft),
              Mt && Rt)
            )
              t: {
                for (Lt = Mt, De = Rt, be = 0, Oe = Lt; Oe; Oe = ol(Oe)) be++;
                for (Oe = 0, ft = De; ft; ft = ol(ft)) Oe++;
                for (; 0 < be - Oe; ) (Lt = ol(Lt)), be--;
                for (; 0 < Oe - be; ) (De = ol(De)), Oe--;
                for (; be--; ) {
                  if (Lt === De || (De !== null && Lt === De.alternate))
                    break t;
                  (Lt = ol(Lt)), (De = ol(De));
                }
                Lt = null;
              }
            else Lt = null;
            Mt !== null && Sg(lt, ot, Mt, Lt, !1),
              Rt !== null && Dr !== null && Sg(lt, Dr, Rt, Lt, !0);
          }
        }
        e: {
          if (
            ((ot = je ? fr(je) : window),
            (Mt = ot.nodeName && ot.nodeName.toLowerCase()),
            Mt === "select" || (Mt === "input" && ot.type === "file"))
          )
            var Nt = yg;
          else if (zf(ot))
            if (Jl) Nt = tr;
            else {
              Nt = xg;
              var Ht = Ql;
            }
          else
            (Mt = ot.nodeName) &&
              Mt.toLowerCase() === "input" &&
              (ot.type === "checkbox" || ot.type === "radio") &&
              (Nt = Yh);
          if (Nt && (Nt = Nt(a, je))) {
            Kl(lt, Nt, v, st);
            break e;
          }
          Ht && Ht(a, ot, je),
            a === "focusout" &&
              (Ht = ot._wrapperState) &&
              Ht.controlled &&
              ot.type === "number" &&
              Xe(ot, "number", ot.value);
        }
        switch (((Ht = je ? fr(je) : window), a)) {
          case "focusin":
            (zf(Ht) || Ht.contentEditable === "true") &&
              ((hs = Ht), (il = je), (Qu = null));
            break;
          case "focusout":
            Qu = il = hs = null;
            break;
          case "mousedown":
            Xr = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (Xr = !1), Wf(lt, v, st);
            break;
          case "selectionchange":
            if (Gf) break;
          case "keydown":
          case "keyup":
            Wf(lt, v, st);
        }
        var Vt;
        if (wi)
          e: {
            switch (a) {
              case "compositionstart":
                var qt = "onCompositionStart";
                break e;
              case "compositionend":
                qt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                qt = "onCompositionUpdate";
                break e;
            }
            qt = void 0;
          }
        else
          _a
            ? Xh(a, v) && (qt = "onCompositionEnd")
            : a === "keydown" &&
              v.keyCode === 229 &&
              (qt = "onCompositionStart");
        qt &&
          (Yl &&
            v.locale !== "ko" &&
            (_a || qt !== "onCompositionStart"
              ? qt === "onCompositionEnd" && _a && (Vt = Pr())
              : ((Fi = st),
                (Ls = "value" in Fi ? Fi.value : Fi.textContent),
                (_a = !0))),
          (Ht = Zf(je, qt)),
          0 < Ht.length &&
            ((qt = new Vh(qt, a, null, v, st)),
            lt.push({ event: qt, listeners: Ht }),
            Vt
              ? (qt.data = Vt)
              : ((Vt = Bf(v)), Vt !== null && (qt.data = Vt)))),
          (Vt = qn ? gg(a, v) : Zu(a, v)) &&
            ((je = Zf(je, "onBeforeInput")),
            0 < je.length &&
              ((st = new Vh("onBeforeInput", "beforeinput", null, v, st)),
              lt.push({ event: st, listeners: je }),
              (st.data = Vt)));
      }
      tu(lt, c);
    });
  }
  function ru(a, c, v) {
    return { instance: a, listener: c, currentTarget: v };
  }
  function Zf(a, c) {
    for (var v = c + "Capture", M = []; a !== null; ) {
      var I = a,
        O = I.stateNode;
      I.tag === 5 &&
        O !== null &&
        ((I = O),
        (O = Sn(a, v)),
        O != null && M.unshift(ru(a, O, I)),
        (O = Sn(a, c)),
        O != null && M.push(ru(a, O, I))),
        (a = a.return);
    }
    return M;
  }
  function ol(a) {
    if (a === null) return null;
    do a = a.return;
    while (a && a.tag !== 5);
    return a || null;
  }
  function Sg(a, c, v, M, I) {
    for (var O = c._reactName, Y = []; v !== null && v !== M; ) {
      var pe = v,
        ye = pe.alternate,
        je = pe.stateNode;
      if (ye !== null && ye === M) break;
      pe.tag === 5 &&
        je !== null &&
        ((pe = je),
        I
          ? ((ye = Sn(v, O)), ye != null && Y.unshift(ru(v, ye, pe)))
          : I || ((ye = Sn(v, O)), ye != null && Y.push(ru(v, ye, pe)))),
        (v = v.return);
    }
    Y.length !== 0 && a.push({ event: c, listeners: Y });
  }
  var hx = /\r\n?/g,
    wg = /\u0000|\uFFFD/g;
  function Qh(a) {
    return (typeof a == "string" ? a : "" + a)
      .replace(
        hx,
        `
`
      )
      .replace(wg, "");
  }
  function oc(a, c, v) {
    if (((c = Qh(c)), Qh(a) !== c && v)) throw Error(t(425));
  }
  function sc() {}
  var iu = null,
    ep = null;
  function tp(a, c) {
    return (
      a === "textarea" ||
      a === "noscript" ||
      typeof c.children == "string" ||
      typeof c.children == "number" ||
      (typeof c.dangerouslySetInnerHTML == "object" &&
        c.dangerouslySetInnerHTML !== null &&
        c.dangerouslySetInnerHTML.__html != null)
    );
  }
  var np = typeof setTimeout == "function" ? setTimeout : void 0,
    rp = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Jf = typeof Promise == "function" ? Promise : void 0,
    px =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof Jf < "u"
        ? function (a) {
            return Jf.resolve(null).then(a).catch(bg);
          }
        : np;
  function bg(a) {
    setTimeout(function () {
      throw a;
    });
  }
  function Qf(a, c) {
    var v = c,
      M = 0;
    do {
      var I = v.nextSibling;
      if ((a.removeChild(v), I && I.nodeType === 8))
        if (((v = I.data), v === "/$")) {
          if (M === 0) {
            a.removeChild(I), ma(c);
            return;
          }
          M--;
        } else (v !== "$" && v !== "$?" && v !== "$!") || M++;
      v = I;
    } while (v);
    ma(c);
  }
  function Hs(a) {
    for (; a != null; a = a.nextSibling) {
      var c = a.nodeType;
      if (c === 1 || c === 3) break;
      if (c === 8) {
        if (((c = a.data), c === "$" || c === "$!" || c === "$?")) break;
        if (c === "/$") return null;
      }
    }
    return a;
  }
  function ip(a) {
    a = a.previousSibling;
    for (var c = 0; a; ) {
      if (a.nodeType === 8) {
        var v = a.data;
        if (v === "$" || v === "$!" || v === "$?") {
          if (c === 0) return a;
          c--;
        } else v === "/$" && c++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var sl = Math.random().toString(36).slice(2),
    Lr = "__reactFiber$" + sl,
    ou = "__reactProps$" + sl,
    lo = "__reactContainer$" + sl,
    al = "__reactEvents$" + sl,
    ed = "__reactListeners$" + sl,
    td = "__reactHandles$" + sl;
  function Ma(a) {
    var c = a[Lr];
    if (c) return c;
    for (var v = a.parentNode; v; ) {
      if ((c = v[lo] || v[Lr])) {
        if (
          ((v = c.alternate),
          c.child !== null || (v !== null && v.child !== null))
        )
          for (a = ip(a); a !== null; ) {
            if ((v = a[Lr])) return v;
            a = ip(a);
          }
        return c;
      }
      (a = v), (v = a.parentNode);
    }
    return null;
  }
  function Vs(a) {
    return (
      (a = a[Lr] || a[lo]),
      !a || (a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3)
        ? null
        : a
    );
  }
  function fr(a) {
    if (a.tag === 5 || a.tag === 6) return a.stateNode;
    throw Error(t(33));
  }
  function nd(a) {
    return a[ou] || null;
  }
  var op = [],
    Yr = -1;
  function ir(a) {
    return { current: a };
  }
  function zn(a) {
    0 > Yr || ((a.current = op[Yr]), (op[Yr] = null), Yr--);
  }
  function Nn(a, c) {
    Yr++, (op[Yr] = a.current), (a.current = c);
  }
  var Gs = {},
    ai = ir(Gs),
    bi = ir(!1),
    Ws = Gs;
  function ll(a, c) {
    var v = a.type.contextTypes;
    if (!v) return Gs;
    var M = a.stateNode;
    if (M && M.__reactInternalMemoizedUnmaskedChildContext === c)
      return M.__reactInternalMemoizedMaskedChildContext;
    var I = {},
      O;
    for (O in v) I[O] = c[O];
    return (
      M &&
        ((a = a.stateNode),
        (a.__reactInternalMemoizedUnmaskedChildContext = c),
        (a.__reactInternalMemoizedMaskedChildContext = I)),
      I
    );
  }
  function mi(a) {
    return (a = a.childContextTypes), a != null;
  }
  function ac() {
    zn(bi), zn(ai);
  }
  function sp(a, c, v) {
    if (ai.current !== Gs) throw Error(t(168));
    Nn(ai, c), Nn(bi, v);
  }
  function lc(a, c, v) {
    var M = a.stateNode;
    if (((c = c.childContextTypes), typeof M.getChildContext != "function"))
      return v;
    M = M.getChildContext();
    for (var I in M) if (!(I in c)) throw Error(t(108, le(a) || "Unknown", I));
    return F({}, v, M);
  }
  function ul(a) {
    return (
      (a =
        ((a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext) ||
        Gs),
      (Ws = ai.current),
      Nn(ai, a),
      Nn(bi, bi.current),
      !0
    );
  }
  function ap(a, c, v) {
    var M = a.stateNode;
    if (!M) throw Error(t(169));
    v
      ? ((a = lc(a, c, Ws)),
        (M.__reactInternalMemoizedMergedChildContext = a),
        zn(bi),
        zn(ai),
        Nn(ai, a))
      : zn(bi),
      Nn(bi, v);
  }
  var Yo = null,
    uc = !1,
    rd = !1;
  function cc(a) {
    Yo === null ? (Yo = [a]) : Yo.push(a);
  }
  function Mg(a) {
    (uc = !0), cc(a);
  }
  function ms() {
    if (!rd && Yo !== null) {
      rd = !0;
      var a = 0,
        c = ln;
      try {
        var v = Yo;
        for (ln = 1; a < v.length; a++) {
          var M = v[a];
          do M = M(!0);
          while (M !== null);
        }
        (Yo = null), (uc = !1);
      } catch (I) {
        throw (Yo !== null && (Yo = Yo.slice(a + 1)), Le(Ft, ms), I);
      } finally {
        (ln = c), (rd = !1);
      }
    }
    return null;
  }
  var cl = [],
    Hi = 0,
    id = null,
    od = 0,
    Mi = [],
    qr = 0,
    fl = null,
    pt = 1,
    To = "";
  function js(a, c) {
    (cl[Hi++] = od), (cl[Hi++] = id), (id = a), (od = c);
  }
  function lp(a, c, v) {
    (Mi[qr++] = pt), (Mi[qr++] = To), (Mi[qr++] = fl), (fl = a);
    var M = pt;
    a = To;
    var I = 32 - Qt(M) - 1;
    (M &= ~(1 << I)), (v += 1);
    var O = 32 - Qt(c) + I;
    if (30 < O) {
      var Y = I - (I % 5);
      (O = (M & ((1 << Y) - 1)).toString(32)),
        (M >>= Y),
        (I -= Y),
        (pt = (1 << (32 - Qt(c) + I)) | (v << I) | M),
        (To = O + a);
    } else (pt = (1 << O) | (v << I) | M), (To = a);
  }
  function up(a) {
    a.return !== null && (js(a, 1), lp(a, 1, 0));
  }
  function $s(a) {
    for (; a === id; )
      (id = cl[--Hi]), (cl[Hi] = null), (od = cl[--Hi]), (cl[Hi] = null);
    for (; a === fl; )
      (fl = Mi[--qr]),
        (Mi[qr] = null),
        (To = Mi[--qr]),
        (Mi[qr] = null),
        (pt = Mi[--qr]),
        (Mi[qr] = null);
  }
  var li = null,
    Ei = null,
    jn = !1,
    Co = null;
  function cp(a, c) {
    var v = Ss(5, null, null, 0);
    (v.elementType = "DELETED"),
      (v.stateNode = c),
      (v.return = a),
      (c = a.deletions),
      c === null ? ((a.deletions = [v]), (a.flags |= 16)) : c.push(v);
  }
  function fp(a, c) {
    switch (a.tag) {
      case 5:
        var v = a.type;
        return (
          (c =
            c.nodeType !== 1 || v.toLowerCase() !== c.nodeName.toLowerCase()
              ? null
              : c),
          c !== null
            ? ((a.stateNode = c), (li = a), (Ei = Hs(c.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (c = a.pendingProps === "" || c.nodeType !== 3 ? null : c),
          c !== null ? ((a.stateNode = c), (li = a), (Ei = null), !0) : !1
        );
      case 13:
        return (
          (c = c.nodeType !== 8 ? null : c),
          c !== null
            ? ((v = fl !== null ? { id: pt, overflow: To } : null),
              (a.memoizedState = {
                dehydrated: c,
                treeContext: v,
                retryLane: 1073741824,
              }),
              (v = Ss(18, null, null, 0)),
              (v.stateNode = c),
              (v.return = a),
              (a.child = v),
              (li = a),
              (Ei = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function sd(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function ad(a) {
    if (jn) {
      var c = Ei;
      if (c) {
        var v = c;
        if (!fp(a, c)) {
          if (sd(a)) throw Error(t(418));
          c = Hs(v.nextSibling);
          var M = li;
          c && fp(a, c)
            ? cp(M, v)
            : ((a.flags = (a.flags & -4097) | 2), (jn = !1), (li = a));
        }
      } else {
        if (sd(a)) throw Error(t(418));
        (a.flags = (a.flags & -4097) | 2), (jn = !1), (li = a);
      }
    }
  }
  function ld(a) {
    for (
      a = a.return;
      a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13;

    )
      a = a.return;
    li = a;
  }
  function su(a) {
    if (a !== li) return !1;
    if (!jn) return ld(a), (jn = !0), !1;
    var c;
    if (
      ((c = a.tag !== 3) &&
        !(c = a.tag !== 5) &&
        ((c = a.type),
        (c = c !== "head" && c !== "body" && !tp(a.type, a.memoizedProps))),
      c && (c = Ei))
    ) {
      if (sd(a)) throw (dp(), Error(t(418)));
      for (; c; ) cp(a, c), (c = Hs(c.nextSibling));
    }
    if ((ld(a), a.tag === 13)) {
      if (((a = a.memoizedState), (a = a !== null ? a.dehydrated : null), !a))
        throw Error(t(317));
      e: {
        for (a = a.nextSibling, c = 0; a; ) {
          if (a.nodeType === 8) {
            var v = a.data;
            if (v === "/$") {
              if (c === 0) {
                Ei = Hs(a.nextSibling);
                break e;
              }
              c--;
            } else (v !== "$" && v !== "$!" && v !== "$?") || c++;
          }
          a = a.nextSibling;
        }
        Ei = null;
      }
    } else Ei = li ? Hs(a.stateNode.nextSibling) : null;
    return !0;
  }
  function dp() {
    for (var a = Ei; a; ) a = Hs(a.nextSibling);
  }
  function Ea() {
    (Ei = li = null), (jn = !1);
  }
  function au(a) {
    Co === null ? (Co = [a]) : Co.push(a);
  }
  var mx = A.ReactCurrentBatchConfig;
  function qo(a, c) {
    if (a && a.defaultProps) {
      (c = F({}, c)), (a = a.defaultProps);
      for (var v in a) c[v] === void 0 && (c[v] = a[v]);
      return c;
    }
    return c;
  }
  var fc = ir(null),
    dc = null,
    dl = null,
    ud = null;
  function lu() {
    ud = dl = dc = null;
  }
  function uu(a) {
    var c = fc.current;
    zn(fc), (a._currentValue = c);
  }
  function cu(a, c, v) {
    for (; a !== null; ) {
      var M = a.alternate;
      if (
        ((a.childLanes & c) !== c
          ? ((a.childLanes |= c), M !== null && (M.childLanes |= c))
          : M !== null && (M.childLanes & c) !== c && (M.childLanes |= c),
        a === v)
      )
        break;
      a = a.return;
    }
  }
  function Xs(a, c) {
    (dc = a),
      (ud = dl = null),
      (a = a.dependencies),
      a !== null &&
        a.firstContext !== null &&
        ((a.lanes & c) !== 0 && (bt = !0), (a.firstContext = null));
  }
  function Ti(a) {
    var c = a._currentValue;
    if (ud !== a)
      if (((a = { context: a, memoizedValue: c, next: null }), dl === null)) {
        if (dc === null) throw Error(t(308));
        (dl = a), (dc.dependencies = { lanes: 0, firstContext: a });
      } else dl = dl.next = a;
    return c;
  }
  var Ko = null;
  function hc(a) {
    Ko === null ? (Ko = [a]) : Ko.push(a);
  }
  function cd(a, c, v, M) {
    var I = c.interleaved;
    return (
      I === null ? ((v.next = v), hc(c)) : ((v.next = I.next), (I.next = v)),
      (c.interleaved = v),
      Zo(a, M)
    );
  }
  function Zo(a, c) {
    a.lanes |= c;
    var v = a.alternate;
    for (v !== null && (v.lanes |= c), v = a, a = a.return; a !== null; )
      (a.childLanes |= c),
        (v = a.alternate),
        v !== null && (v.childLanes |= c),
        (v = a),
        (a = a.return);
    return v.tag === 3 ? v.stateNode : null;
  }
  var Ys = !1;
  function pc(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function Eg(a, c) {
    (a = a.updateQueue),
      c.updateQueue === a &&
        (c.updateQueue = {
          baseState: a.baseState,
          firstBaseUpdate: a.firstBaseUpdate,
          lastBaseUpdate: a.lastBaseUpdate,
          shared: a.shared,
          effects: a.effects,
        });
  }
  function Ao(a, c) {
    return {
      eventTime: a,
      lane: c,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function gs(a, c, v) {
    var M = a.updateQueue;
    if (M === null) return null;
    if (((M = M.shared), (gn & 2) !== 0)) {
      var I = M.pending;
      return (
        I === null ? (c.next = c) : ((c.next = I.next), (I.next = c)),
        (M.pending = c),
        Zo(a, v)
      );
    }
    return (
      (I = M.interleaved),
      I === null ? ((c.next = c), hc(M)) : ((c.next = I.next), (I.next = c)),
      (M.interleaved = c),
      Zo(a, v)
    );
  }
  function Kn(a, c, v) {
    if (
      ((c = c.updateQueue), c !== null && ((c = c.shared), (v & 4194240) !== 0))
    ) {
      var M = c.lanes;
      (M &= a.pendingLanes), (v |= M), (c.lanes = v), Vo(a, v);
    }
  }
  function rn(a, c) {
    var v = a.updateQueue,
      M = a.alternate;
    if (M !== null && ((M = M.updateQueue), v === M)) {
      var I = null,
        O = null;
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var Y = {
            eventTime: v.eventTime,
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null,
          };
          O === null ? (I = O = Y) : (O = O.next = Y), (v = v.next);
        } while (v !== null);
        O === null ? (I = O = c) : (O = O.next = c);
      } else I = O = c;
      (v = {
        baseState: M.baseState,
        firstBaseUpdate: I,
        lastBaseUpdate: O,
        shared: M.shared,
        effects: M.effects,
      }),
        (a.updateQueue = v);
      return;
    }
    (a = v.lastBaseUpdate),
      a === null ? (v.firstBaseUpdate = c) : (a.next = c),
      (v.lastBaseUpdate = c);
  }
  function rr(a, c, v, M) {
    var I = a.updateQueue;
    Ys = !1;
    var O = I.firstBaseUpdate,
      Y = I.lastBaseUpdate,
      pe = I.shared.pending;
    if (pe !== null) {
      I.shared.pending = null;
      var ye = pe,
        je = ye.next;
      (ye.next = null), Y === null ? (O = je) : (Y.next = je), (Y = ye);
      var st = a.alternate;
      st !== null &&
        ((st = st.updateQueue),
        (pe = st.lastBaseUpdate),
        pe !== Y &&
          (pe === null ? (st.firstBaseUpdate = je) : (pe.next = je),
          (st.lastBaseUpdate = ye)));
    }
    if (O !== null) {
      var lt = I.baseState;
      (Y = 0), (st = je = ye = null), (pe = O);
      do {
        var ot = pe.lane,
          Mt = pe.eventTime;
        if ((M & ot) === ot) {
          st !== null &&
            (st = st.next =
              {
                eventTime: Mt,
                lane: 0,
                tag: pe.tag,
                payload: pe.payload,
                callback: pe.callback,
                next: null,
              });
          e: {
            var Rt = a,
              Lt = pe;
            switch (((ot = c), (Mt = v), Lt.tag)) {
              case 1:
                if (((Rt = Lt.payload), typeof Rt == "function")) {
                  lt = Rt.call(Mt, lt, ot);
                  break e;
                }
                lt = Rt;
                break e;
              case 3:
                Rt.flags = (Rt.flags & -65537) | 128;
              case 0:
                if (
                  ((Rt = Lt.payload),
                  (ot = typeof Rt == "function" ? Rt.call(Mt, lt, ot) : Rt),
                  ot == null)
                )
                  break e;
                lt = F({}, lt, ot);
                break e;
              case 2:
                Ys = !0;
            }
          }
          pe.callback !== null &&
            pe.lane !== 0 &&
            ((a.flags |= 64),
            (ot = I.effects),
            ot === null ? (I.effects = [pe]) : ot.push(pe));
        } else
          (Mt = {
            eventTime: Mt,
            lane: ot,
            tag: pe.tag,
            payload: pe.payload,
            callback: pe.callback,
            next: null,
          }),
            st === null ? ((je = st = Mt), (ye = lt)) : (st = st.next = Mt),
            (Y |= ot);
        if (((pe = pe.next), pe === null)) {
          if (((pe = I.shared.pending), pe === null)) break;
          (ot = pe),
            (pe = ot.next),
            (ot.next = null),
            (I.lastBaseUpdate = ot),
            (I.shared.pending = null);
        }
      } while (!0);
      if (
        (st === null && (ye = lt),
        (I.baseState = ye),
        (I.firstBaseUpdate = je),
        (I.lastBaseUpdate = st),
        (c = I.shared.interleaved),
        c !== null)
      ) {
        I = c;
        do (Y |= I.lane), (I = I.next);
        while (I !== c);
      } else O === null && (I.shared.lanes = 0);
      (Sc |= Y), (a.lanes = Y), (a.memoizedState = lt);
    }
  }
  function dr(a, c, v) {
    if (((a = c.effects), (c.effects = null), a !== null))
      for (c = 0; c < a.length; c++) {
        var M = a[c],
          I = M.callback;
        if (I !== null) {
          if (((M.callback = null), (M = v), typeof I != "function"))
            throw Error(t(191, I));
          I.call(M);
        }
      }
  }
  var Kr = new n.Component().refs;
  function Ci(a, c, v, M) {
    (c = a.memoizedState),
      (v = v(M, c)),
      (v = v == null ? c : F({}, c, v)),
      (a.memoizedState = v),
      a.lanes === 0 && (a.updateQueue.baseState = v);
  }
  var qs = {
    isMounted: function (a) {
      return (a = a._reactInternals) ? no(a) === a : !1;
    },
    enqueueSetState: function (a, c, v) {
      a = a._reactInternals;
      var M = ho(),
        I = Su(a),
        O = Ao(M, I);
      (O.payload = c),
        v != null && (O.callback = v),
        (c = gs(a, O, I)),
        c !== null && (Qs(c, a, I, M), Kn(c, a, I));
    },
    enqueueReplaceState: function (a, c, v) {
      a = a._reactInternals;
      var M = ho(),
        I = Su(a),
        O = Ao(M, I);
      (O.tag = 1),
        (O.payload = c),
        v != null && (O.callback = v),
        (c = gs(a, O, I)),
        c !== null && (Qs(c, a, I, M), Kn(c, a, I));
    },
    enqueueForceUpdate: function (a, c) {
      a = a._reactInternals;
      var v = ho(),
        M = Su(a),
        I = Ao(v, M);
      (I.tag = 2),
        c != null && (I.callback = c),
        (c = gs(a, I, M)),
        c !== null && (Qs(c, a, M, v), Kn(c, a, M));
    },
  };
  function Sr(a, c, v, M, I, O, Y) {
    return (
      (a = a.stateNode),
      typeof a.shouldComponentUpdate == "function"
        ? a.shouldComponentUpdate(M, O, Y)
        : c.prototype && c.prototype.isPureReactComponent
        ? !nl(v, M) || !nl(I, O)
        : !0
    );
  }
  function fu(a, c, v) {
    var M = !1,
      I = Gs,
      O = c.contextType;
    return (
      typeof O == "object" && O !== null
        ? (O = Ti(O))
        : ((I = mi(c) ? Ws : ai.current),
          (M = c.contextTypes),
          (O = (M = M != null) ? ll(a, I) : Gs)),
      (c = new c(v, O)),
      (a.memoizedState =
        c.state !== null && c.state !== void 0 ? c.state : null),
      (c.updater = qs),
      (a.stateNode = c),
      (c._reactInternals = a),
      M &&
        ((a = a.stateNode),
        (a.__reactInternalMemoizedUnmaskedChildContext = I),
        (a.__reactInternalMemoizedMaskedChildContext = O)),
      c
    );
  }
  function hl(a, c, v, M) {
    (a = c.state),
      typeof c.componentWillReceiveProps == "function" &&
        c.componentWillReceiveProps(v, M),
      typeof c.UNSAFE_componentWillReceiveProps == "function" &&
        c.UNSAFE_componentWillReceiveProps(v, M),
      c.state !== a && qs.enqueueReplaceState(c, c.state, null);
  }
  function du(a, c, v, M) {
    var I = a.stateNode;
    (I.props = v), (I.state = a.memoizedState), (I.refs = Kr), pc(a);
    var O = c.contextType;
    typeof O == "object" && O !== null
      ? (I.context = Ti(O))
      : ((O = mi(c) ? Ws : ai.current), (I.context = ll(a, O))),
      (I.state = a.memoizedState),
      (O = c.getDerivedStateFromProps),
      typeof O == "function" && (Ci(a, c, O, v), (I.state = a.memoizedState)),
      typeof c.getDerivedStateFromProps == "function" ||
        typeof I.getSnapshotBeforeUpdate == "function" ||
        (typeof I.UNSAFE_componentWillMount != "function" &&
          typeof I.componentWillMount != "function") ||
        ((c = I.state),
        typeof I.componentWillMount == "function" && I.componentWillMount(),
        typeof I.UNSAFE_componentWillMount == "function" &&
          I.UNSAFE_componentWillMount(),
        c !== I.state && qs.enqueueReplaceState(I, I.state, null),
        rr(a, v, I, M),
        (I.state = a.memoizedState)),
      typeof I.componentDidMount == "function" && (a.flags |= 4194308);
  }
  function pl(a, c, v) {
    if (
      ((a = v.ref),
      a !== null && typeof a != "function" && typeof a != "object")
    ) {
      if (v._owner) {
        if (((v = v._owner), v)) {
          if (v.tag !== 1) throw Error(t(309));
          var M = v.stateNode;
        }
        if (!M) throw Error(t(147, a));
        var I = M,
          O = "" + a;
        return c !== null &&
          c.ref !== null &&
          typeof c.ref == "function" &&
          c.ref._stringRef === O
          ? c.ref
          : ((c = function (Y) {
              var pe = I.refs;
              pe === Kr && (pe = I.refs = {}),
                Y === null ? delete pe[O] : (pe[O] = Y);
            }),
            (c._stringRef = O),
            c);
      }
      if (typeof a != "string") throw Error(t(284));
      if (!v._owner) throw Error(t(290, a));
    }
    return a;
  }
  function Ta(a, c) {
    throw (
      ((a = Object.prototype.toString.call(c)),
      Error(
        t(
          31,
          a === "[object Object]"
            ? "object with keys {" + Object.keys(c).join(", ") + "}"
            : a
        )
      ))
    );
  }
  function Ai(a) {
    var c = a._init;
    return c(a._payload);
  }
  function fd(a) {
    function c(De, be) {
      if (a) {
        var Oe = De.deletions;
        Oe === null ? ((De.deletions = [be]), (De.flags |= 16)) : Oe.push(be);
      }
    }
    function v(De, be) {
      if (!a) return null;
      for (; be !== null; ) c(De, be), (be = be.sibling);
      return null;
    }
    function M(De, be) {
      for (De = new Map(); be !== null; )
        be.key !== null ? De.set(be.key, be) : De.set(be.index, be),
          (be = be.sibling);
      return De;
    }
    function I(De, be) {
      return (De = bu(De, be)), (De.index = 0), (De.sibling = null), De;
    }
    function O(De, be, Oe) {
      return (
        (De.index = Oe),
        a
          ? ((Oe = De.alternate),
            Oe !== null
              ? ((Oe = Oe.index), Oe < be ? ((De.flags |= 2), be) : Oe)
              : ((De.flags |= 2), be))
          : ((De.flags |= 1048576), be)
      );
    }
    function Y(De) {
      return a && De.alternate === null && (De.flags |= 2), De;
    }
    function pe(De, be, Oe, ft) {
      return be === null || be.tag !== 6
        ? ((be = Dx(Oe, De.mode, ft)), (be.return = De), be)
        : ((be = I(be, Oe)), (be.return = De), be);
    }
    function ye(De, be, Oe, ft) {
      var Nt = Oe.type;
      return Nt === P
        ? st(De, be, Oe.props.children, ft, Oe.key)
        : be !== null &&
          (be.elementType === Nt ||
            (typeof Nt == "object" &&
              Nt !== null &&
              Nt.$$typeof === X &&
              Ai(Nt) === be.type))
        ? ((ft = I(be, Oe.props)),
          (ft.ref = pl(De, be, Oe)),
          (ft.return = De),
          ft)
        : ((ft = qg(Oe.type, Oe.key, Oe.props, null, De.mode, ft)),
          (ft.ref = pl(De, be, Oe)),
          (ft.return = De),
          ft);
    }
    function je(De, be, Oe, ft) {
      return be === null ||
        be.tag !== 4 ||
        be.stateNode.containerInfo !== Oe.containerInfo ||
        be.stateNode.implementation !== Oe.implementation
        ? ((be = Nx(Oe, De.mode, ft)), (be.return = De), be)
        : ((be = I(be, Oe.children || [])), (be.return = De), be);
    }
    function st(De, be, Oe, ft, Nt) {
      return be === null || be.tag !== 7
        ? ((be = Ec(Oe, De.mode, ft, Nt)), (be.return = De), be)
        : ((be = I(be, Oe)), (be.return = De), be);
    }
    function lt(De, be, Oe) {
      if ((typeof be == "string" && be !== "") || typeof be == "number")
        return (be = Dx("" + be, De.mode, Oe)), (be.return = De), be;
      if (typeof be == "object" && be !== null) {
        switch (be.$$typeof) {
          case R:
            return (
              (Oe = qg(be.type, be.key, be.props, null, De.mode, Oe)),
              (Oe.ref = pl(De, null, be)),
              (Oe.return = De),
              Oe
            );
          case k:
            return (be = Nx(be, De.mode, Oe)), (be.return = De), be;
          case X:
            var ft = be._init;
            return lt(De, ft(be._payload), Oe);
        }
        if (ee(be) || te(be))
          return (be = Ec(be, De.mode, Oe, null)), (be.return = De), be;
        Ta(De, be);
      }
      return null;
    }
    function ot(De, be, Oe, ft) {
      var Nt = be !== null ? be.key : null;
      if ((typeof Oe == "string" && Oe !== "") || typeof Oe == "number")
        return Nt !== null ? null : pe(De, be, "" + Oe, ft);
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case R:
            return Oe.key === Nt ? ye(De, be, Oe, ft) : null;
          case k:
            return Oe.key === Nt ? je(De, be, Oe, ft) : null;
          case X:
            return (Nt = Oe._init), ot(De, be, Nt(Oe._payload), ft);
        }
        if (ee(Oe) || te(Oe))
          return Nt !== null ? null : st(De, be, Oe, ft, null);
        Ta(De, Oe);
      }
      return null;
    }
    function Mt(De, be, Oe, ft, Nt) {
      if ((typeof ft == "string" && ft !== "") || typeof ft == "number")
        return (De = De.get(Oe) || null), pe(be, De, "" + ft, Nt);
      if (typeof ft == "object" && ft !== null) {
        switch (ft.$$typeof) {
          case R:
            return (
              (De = De.get(ft.key === null ? Oe : ft.key) || null),
              ye(be, De, ft, Nt)
            );
          case k:
            return (
              (De = De.get(ft.key === null ? Oe : ft.key) || null),
              je(be, De, ft, Nt)
            );
          case X:
            var Ht = ft._init;
            return Mt(De, be, Oe, Ht(ft._payload), Nt);
        }
        if (ee(ft) || te(ft))
          return (De = De.get(Oe) || null), st(be, De, ft, Nt, null);
        Ta(be, ft);
      }
      return null;
    }
    function Rt(De, be, Oe, ft) {
      for (
        var Nt = null, Ht = null, Vt = be, qt = (be = 0), yi = null;
        Vt !== null && qt < Oe.length;
        qt++
      ) {
        Vt.index > qt ? ((yi = Vt), (Vt = null)) : (yi = Vt.sibling);
        var En = ot(De, Vt, Oe[qt], ft);
        if (En === null) {
          Vt === null && (Vt = yi);
          break;
        }
        a && Vt && En.alternate === null && c(De, Vt),
          (be = O(En, be, qt)),
          Ht === null ? (Nt = En) : (Ht.sibling = En),
          (Ht = En),
          (Vt = yi);
      }
      if (qt === Oe.length) return v(De, Vt), jn && js(De, qt), Nt;
      if (Vt === null) {
        for (; qt < Oe.length; qt++)
          (Vt = lt(De, Oe[qt], ft)),
            Vt !== null &&
              ((be = O(Vt, be, qt)),
              Ht === null ? (Nt = Vt) : (Ht.sibling = Vt),
              (Ht = Vt));
        return jn && js(De, qt), Nt;
      }
      for (Vt = M(De, Vt); qt < Oe.length; qt++)
        (yi = Mt(Vt, De, qt, Oe[qt], ft)),
          yi !== null &&
            (a &&
              yi.alternate !== null &&
              Vt.delete(yi.key === null ? qt : yi.key),
            (be = O(yi, be, qt)),
            Ht === null ? (Nt = yi) : (Ht.sibling = yi),
            (Ht = yi));
      return (
        a &&
          Vt.forEach(function (Mu) {
            return c(De, Mu);
          }),
        jn && js(De, qt),
        Nt
      );
    }
    function Lt(De, be, Oe, ft) {
      var Nt = te(Oe);
      if (typeof Nt != "function") throw Error(t(150));
      if (((Oe = Nt.call(Oe)), Oe == null)) throw Error(t(151));
      for (
        var Ht = (Nt = null), Vt = be, qt = (be = 0), yi = null, En = Oe.next();
        Vt !== null && !En.done;
        qt++, En = Oe.next()
      ) {
        Vt.index > qt ? ((yi = Vt), (Vt = null)) : (yi = Vt.sibling);
        var Mu = ot(De, Vt, En.value, ft);
        if (Mu === null) {
          Vt === null && (Vt = yi);
          break;
        }
        a && Vt && Mu.alternate === null && c(De, Vt),
          (be = O(Mu, be, qt)),
          Ht === null ? (Nt = Mu) : (Ht.sibling = Mu),
          (Ht = Mu),
          (Vt = yi);
      }
      if (En.done) return v(De, Vt), jn && js(De, qt), Nt;
      if (Vt === null) {
        for (; !En.done; qt++, En = Oe.next())
          (En = lt(De, En.value, ft)),
            En !== null &&
              ((be = O(En, be, qt)),
              Ht === null ? (Nt = En) : (Ht.sibling = En),
              (Ht = En));
        return jn && js(De, qt), Nt;
      }
      for (Vt = M(De, Vt); !En.done; qt++, En = Oe.next())
        (En = Mt(Vt, De, qt, En.value, ft)),
          En !== null &&
            (a &&
              En.alternate !== null &&
              Vt.delete(En.key === null ? qt : En.key),
            (be = O(En, be, qt)),
            Ht === null ? (Nt = En) : (Ht.sibling = En),
            (Ht = En));
      return (
        a &&
          Vt.forEach(function (l3) {
            return c(De, l3);
          }),
        jn && js(De, qt),
        Nt
      );
    }
    function Dr(De, be, Oe, ft) {
      if (
        (typeof Oe == "object" &&
          Oe !== null &&
          Oe.type === P &&
          Oe.key === null &&
          (Oe = Oe.props.children),
        typeof Oe == "object" && Oe !== null)
      ) {
        switch (Oe.$$typeof) {
          case R:
            e: {
              for (var Nt = Oe.key, Ht = be; Ht !== null; ) {
                if (Ht.key === Nt) {
                  if (((Nt = Oe.type), Nt === P)) {
                    if (Ht.tag === 7) {
                      v(De, Ht.sibling),
                        (be = I(Ht, Oe.props.children)),
                        (be.return = De),
                        (De = be);
                      break e;
                    }
                  } else if (
                    Ht.elementType === Nt ||
                    (typeof Nt == "object" &&
                      Nt !== null &&
                      Nt.$$typeof === X &&
                      Ai(Nt) === Ht.type)
                  ) {
                    v(De, Ht.sibling),
                      (be = I(Ht, Oe.props)),
                      (be.ref = pl(De, Ht, Oe)),
                      (be.return = De),
                      (De = be);
                    break e;
                  }
                  v(De, Ht);
                  break;
                } else c(De, Ht);
                Ht = Ht.sibling;
              }
              Oe.type === P
                ? ((be = Ec(Oe.props.children, De.mode, ft, Oe.key)),
                  (be.return = De),
                  (De = be))
                : ((ft = qg(Oe.type, Oe.key, Oe.props, null, De.mode, ft)),
                  (ft.ref = pl(De, be, Oe)),
                  (ft.return = De),
                  (De = ft));
            }
            return Y(De);
          case k:
            e: {
              for (Ht = Oe.key; be !== null; ) {
                if (be.key === Ht)
                  if (
                    be.tag === 4 &&
                    be.stateNode.containerInfo === Oe.containerInfo &&
                    be.stateNode.implementation === Oe.implementation
                  ) {
                    v(De, be.sibling),
                      (be = I(be, Oe.children || [])),
                      (be.return = De),
                      (De = be);
                    break e;
                  } else {
                    v(De, be);
                    break;
                  }
                else c(De, be);
                be = be.sibling;
              }
              (be = Nx(Oe, De.mode, ft)), (be.return = De), (De = be);
            }
            return Y(De);
          case X:
            return (Ht = Oe._init), Dr(De, be, Ht(Oe._payload), ft);
        }
        if (ee(Oe)) return Rt(De, be, Oe, ft);
        if (te(Oe)) return Lt(De, be, Oe, ft);
        Ta(De, Oe);
      }
      return (typeof Oe == "string" && Oe !== "") || typeof Oe == "number"
        ? ((Oe = "" + Oe),
          be !== null && be.tag === 6
            ? (v(De, be.sibling), (be = I(be, Oe)), (be.return = De), (De = be))
            : (v(De, be),
              (be = Dx(Oe, De.mode, ft)),
              (be.return = De),
              (De = be)),
          Y(De))
        : v(De, be);
    }
    return Dr;
  }
  var Ca = fd(!0),
    ml = fd(!1),
    Aa = {},
    Ro = ir(Aa),
    Po = ir(Aa),
    Ra = ir(Aa);
  function Vi(a) {
    if (a === Aa) throw Error(t(174));
    return a;
  }
  function hu(a, c) {
    switch ((Nn(Ra, c), Nn(Po, a), Nn(Ro, Aa), (a = c.nodeType), a)) {
      case 9:
      case 11:
        c = (c = c.documentElement) ? c.namespaceURI : Fe(null, "");
        break;
      default:
        (a = a === 8 ? c.parentNode : c),
          (c = a.namespaceURI || null),
          (a = a.tagName),
          (c = Fe(c, a));
    }
    zn(Ro), Nn(Ro, c);
  }
  function vs() {
    zn(Ro), zn(Po), zn(Ra);
  }
  function dd(a) {
    Vi(Ra.current);
    var c = Vi(Ro.current),
      v = Fe(c, a.type);
    c !== v && (Nn(Po, a), Nn(Ro, v));
  }
  function pu(a) {
    Po.current === a && (zn(Ro), zn(Po));
  }
  var Hn = ir(0);
  function Zr(a) {
    for (var c = a; c !== null; ) {
      if (c.tag === 13) {
        var v = c.memoizedState;
        if (
          v !== null &&
          ((v = v.dehydrated), v === null || v.data === "$?" || v.data === "$!")
        )
          return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if ((c.flags & 128) !== 0) return c;
      } else if (c.child !== null) {
        (c.child.return = c), (c = c.child);
        continue;
      }
      if (c === a) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === a) return null;
        c = c.return;
      }
      (c.sibling.return = c.return), (c = c.sibling);
    }
    return null;
  }
  var ys = [];
  function Gi() {
    for (var a = 0; a < ys.length; a++)
      ys[a]._workInProgressVersionPrimary = null;
    ys.length = 0;
  }
  var gl = A.ReactCurrentDispatcher,
    gi = A.ReactCurrentBatchConfig,
    Pa = 0,
    $n = null,
    hr = null,
    Jr = null,
    Jo = !1,
    mu = !1,
    gu = 0,
    hp = 0;
  function or() {
    throw Error(t(321));
  }
  function hd(a, c) {
    if (c === null) return !1;
    for (var v = 0; v < c.length && v < a.length; v++)
      if (!so(a[v], c[v])) return !1;
    return !0;
  }
  function pd(a, c, v, M, I, O) {
    if (
      ((Pa = O),
      ($n = c),
      (c.memoizedState = null),
      (c.updateQueue = null),
      (c.lanes = 0),
      (gl.current = a === null || a.memoizedState === null ? p : b),
      (a = v(M, I)),
      mu)
    ) {
      O = 0;
      do {
        if (((mu = !1), (gu = 0), 25 <= O)) throw Error(t(301));
        (O += 1),
          (Jr = hr = null),
          (c.updateQueue = null),
          (gl.current = C),
          (a = v(M, I));
      } while (mu);
    }
    if (
      ((gl.current = d),
      (c = hr !== null && hr.next !== null),
      (Pa = 0),
      (Jr = hr = $n = null),
      (Jo = !1),
      c)
    )
      throw Error(t(300));
    return a;
  }
  function mc() {
    var a = gu !== 0;
    return (gu = 0), a;
  }
  function uo() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Jr === null ? ($n.memoizedState = Jr = a) : (Jr = Jr.next = a), Jr;
  }
  function Io() {
    if (hr === null) {
      var a = $n.alternate;
      a = a !== null ? a.memoizedState : null;
    } else a = hr.next;
    var c = Jr === null ? $n.memoizedState : Jr.next;
    if (c !== null) (Jr = c), (hr = a);
    else {
      if (a === null) throw Error(t(310));
      (hr = a),
        (a = {
          memoizedState: hr.memoizedState,
          baseState: hr.baseState,
          baseQueue: hr.baseQueue,
          queue: hr.queue,
          next: null,
        }),
        Jr === null ? ($n.memoizedState = Jr = a) : (Jr = Jr.next = a);
    }
    return Jr;
  }
  function gc(a, c) {
    return typeof c == "function" ? c(a) : c;
  }
  function md(a) {
    var c = Io(),
      v = c.queue;
    if (v === null) throw Error(t(311));
    v.lastRenderedReducer = a;
    var M = hr,
      I = M.baseQueue,
      O = v.pending;
    if (O !== null) {
      if (I !== null) {
        var Y = I.next;
        (I.next = O.next), (O.next = Y);
      }
      (M.baseQueue = I = O), (v.pending = null);
    }
    if (I !== null) {
      (O = I.next), (M = M.baseState);
      var pe = (Y = null),
        ye = null,
        je = O;
      do {
        var st = je.lane;
        if ((Pa & st) === st)
          ye !== null &&
            (ye = ye.next =
              {
                lane: 0,
                action: je.action,
                hasEagerState: je.hasEagerState,
                eagerState: je.eagerState,
                next: null,
              }),
            (M = je.hasEagerState ? je.eagerState : a(M, je.action));
        else {
          var lt = {
            lane: st,
            action: je.action,
            hasEagerState: je.hasEagerState,
            eagerState: je.eagerState,
            next: null,
          };
          ye === null ? ((pe = ye = lt), (Y = M)) : (ye = ye.next = lt),
            ($n.lanes |= st),
            (Sc |= st);
        }
        je = je.next;
      } while (je !== null && je !== O);
      ye === null ? (Y = M) : (ye.next = pe),
        so(M, c.memoizedState) || (bt = !0),
        (c.memoizedState = M),
        (c.baseState = Y),
        (c.baseQueue = ye),
        (v.lastRenderedState = M);
    }
    if (((a = v.interleaved), a !== null)) {
      I = a;
      do (O = I.lane), ($n.lanes |= O), (Sc |= O), (I = I.next);
      while (I !== a);
    } else I === null && (v.lanes = 0);
    return [c.memoizedState, v.dispatch];
  }
  function gd(a) {
    var c = Io(),
      v = c.queue;
    if (v === null) throw Error(t(311));
    v.lastRenderedReducer = a;
    var M = v.dispatch,
      I = v.pending,
      O = c.memoizedState;
    if (I !== null) {
      v.pending = null;
      var Y = (I = I.next);
      do (O = a(O, Y.action)), (Y = Y.next);
      while (Y !== I);
      so(O, c.memoizedState) || (bt = !0),
        (c.memoizedState = O),
        c.baseQueue === null && (c.baseState = O),
        (v.lastRenderedState = O);
    }
    return [O, M];
  }
  function Ia() {}
  function Tg(a, c) {
    var v = $n,
      M = Io(),
      I = c(),
      O = !so(M.memoizedState, I);
    if (
      (O && ((M.memoizedState = I), (bt = !0)),
      (M = M.queue),
      xc(Ri.bind(null, v, M, a), [a]),
      M.getSnapshot !== c || O || (Jr !== null && Jr.memoizedState.tag & 1))
    ) {
      if (
        ((v.flags |= 2048),
        vc(9, pp.bind(null, v, M, I, c), void 0, null),
        vi === null)
      )
        throw Error(t(349));
      (Pa & 30) !== 0 || La(v, c, I);
    }
    return I;
  }
  function La(a, c, v) {
    (a.flags |= 16384),
      (a = { getSnapshot: c, value: v }),
      (c = $n.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          ($n.updateQueue = c),
          (c.stores = [a]))
        : ((v = c.stores), v === null ? (c.stores = [a]) : v.push(a));
  }
  function pp(a, c, v, M) {
    (c.value = v), (c.getSnapshot = M), Cg(c) && mp(a);
  }
  function Ri(a, c, v) {
    return v(function () {
      Cg(c) && mp(a);
    });
  }
  function Cg(a) {
    var c = a.getSnapshot;
    a = a.value;
    try {
      var v = c();
      return !so(a, v);
    } catch {
      return !0;
    }
  }
  function mp(a) {
    var c = Zo(a, 1);
    c !== null && Qs(c, a, 1, -1);
  }
  function Ag(a) {
    var c = uo();
    return (
      typeof a == "function" && (a = a()),
      (c.memoizedState = c.baseState = a),
      (a = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: gc,
        lastRenderedState: a,
      }),
      (c.queue = a),
      (a = a.dispatch = kg.bind(null, $n, a)),
      [c.memoizedState, a]
    );
  }
  function vc(a, c, v, M) {
    return (
      (a = { tag: a, create: c, destroy: v, deps: M, next: null }),
      (c = $n.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          ($n.updateQueue = c),
          (c.lastEffect = a.next = a))
        : ((v = c.lastEffect),
          v === null
            ? (c.lastEffect = a.next = a)
            : ((M = v.next), (v.next = a), (a.next = M), (c.lastEffect = a))),
      a
    );
  }
  function gp() {
    return Io().memoizedState;
  }
  function yc(a, c, v, M) {
    var I = uo();
    ($n.flags |= a),
      (I.memoizedState = vc(1 | c, v, void 0, M === void 0 ? null : M));
  }
  function vd(a, c, v, M) {
    var I = Io();
    M = M === void 0 ? null : M;
    var O = void 0;
    if (hr !== null) {
      var Y = hr.memoizedState;
      if (((O = Y.destroy), M !== null && hd(M, Y.deps))) {
        I.memoizedState = vc(c, v, O, M);
        return;
      }
    }
    ($n.flags |= a), (I.memoizedState = vc(1 | c, v, O, M));
  }
  function co(a, c) {
    return yc(8390656, 8, a, c);
  }
  function xc(a, c) {
    return vd(2048, 8, a, c);
  }
  function Rg(a, c) {
    return vd(4, 2, a, c);
  }
  function Ks(a, c) {
    return vd(4, 4, a, c);
  }
  function _c(a, c) {
    if (typeof c == "function")
      return (
        (a = a()),
        c(a),
        function () {
          c(null);
        }
      );
    if (c != null)
      return (
        (a = a()),
        (c.current = a),
        function () {
          c.current = null;
        }
      );
  }
  function ka(a, c, v) {
    return (
      (v = v != null ? v.concat([a]) : null), vd(4, 4, _c.bind(null, c, a), v)
    );
  }
  function vu() {}
  function yd(a, c) {
    var v = Io();
    c = c === void 0 ? null : c;
    var M = v.memoizedState;
    return M !== null && c !== null && hd(c, M[1])
      ? M[0]
      : ((v.memoizedState = [a, c]), a);
  }
  function xd(a, c) {
    var v = Io();
    c = c === void 0 ? null : c;
    var M = v.memoizedState;
    return M !== null && c !== null && hd(c, M[1])
      ? M[0]
      : ((a = a()), (v.memoizedState = [a, c]), a);
  }
  function Pg(a, c, v) {
    return (Pa & 21) === 0
      ? (a.baseState && ((a.baseState = !1), (bt = !0)), (a.memoizedState = v))
      : (so(v, c) ||
          ((v = di()), ($n.lanes |= v), (Sc |= v), (a.baseState = !0)),
        c);
  }
  function Ig(a, c) {
    var v = ln;
    (ln = v !== 0 && 4 > v ? v : 4), a(!0);
    var M = gi.transition;
    gi.transition = {};
    try {
      a(!1), c();
    } finally {
      (ln = v), (gi.transition = M);
    }
  }
  function vp() {
    return Io().memoizedState;
  }
  function Lg(a, c, v) {
    var M = Su(a);
    if (
      ((v = {
        lane: M,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      _d(a))
    )
      Dg(c, v);
    else if (((v = cd(a, c, v, M)), v !== null)) {
      var I = ho();
      Qs(v, a, M, I), Ng(v, c, M);
    }
  }
  function kg(a, c, v) {
    var M = Su(a),
      I = {
        lane: M,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (_d(a)) Dg(c, I);
    else {
      var O = a.alternate;
      if (
        a.lanes === 0 &&
        (O === null || O.lanes === 0) &&
        ((O = c.lastRenderedReducer), O !== null)
      )
        try {
          var Y = c.lastRenderedState,
            pe = O(Y, v);
          if (((I.hasEagerState = !0), (I.eagerState = pe), so(pe, Y))) {
            var ye = c.interleaved;
            ye === null
              ? ((I.next = I), hc(c))
              : ((I.next = ye.next), (ye.next = I)),
              (c.interleaved = I);
            return;
          }
        } catch {
        } finally {
        }
      (v = cd(a, c, I, M)),
        v !== null && ((I = ho()), Qs(v, a, M, I), Ng(v, c, M));
    }
  }
  function _d(a) {
    var c = a.alternate;
    return a === $n || (c !== null && c === $n);
  }
  function Dg(a, c) {
    mu = Jo = !0;
    var v = a.pending;
    v === null ? (c.next = c) : ((c.next = v.next), (v.next = c)),
      (a.pending = c);
  }
  function Ng(a, c, v) {
    if ((v & 4194240) !== 0) {
      var M = c.lanes;
      (M &= a.pendingLanes), (v |= M), (c.lanes = v), Vo(a, v);
    }
  }
  var d = {
      readContext: Ti,
      useCallback: or,
      useContext: or,
      useEffect: or,
      useImperativeHandle: or,
      useInsertionEffect: or,
      useLayoutEffect: or,
      useMemo: or,
      useReducer: or,
      useRef: or,
      useState: or,
      useDebugValue: or,
      useDeferredValue: or,
      useTransition: or,
      useMutableSource: or,
      useSyncExternalStore: or,
      useId: or,
      unstable_isNewReconciler: !1,
    },
    p = {
      readContext: Ti,
      useCallback: function (a, c) {
        return (uo().memoizedState = [a, c === void 0 ? null : c]), a;
      },
      useContext: Ti,
      useEffect: co,
      useImperativeHandle: function (a, c, v) {
        return (
          (v = v != null ? v.concat([a]) : null),
          yc(4194308, 4, _c.bind(null, c, a), v)
        );
      },
      useLayoutEffect: function (a, c) {
        return yc(4194308, 4, a, c);
      },
      useInsertionEffect: function (a, c) {
        return yc(4, 2, a, c);
      },
      useMemo: function (a, c) {
        var v = uo();
        return (
          (c = c === void 0 ? null : c),
          (a = a()),
          (v.memoizedState = [a, c]),
          a
        );
      },
      useReducer: function (a, c, v) {
        var M = uo();
        return (
          (c = v !== void 0 ? v(c) : c),
          (M.memoizedState = M.baseState = c),
          (a = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: a,
            lastRenderedState: c,
          }),
          (M.queue = a),
          (a = a.dispatch = Lg.bind(null, $n, a)),
          [M.memoizedState, a]
        );
      },
      useRef: function (a) {
        var c = uo();
        return (a = { current: a }), (c.memoizedState = a);
      },
      useState: Ag,
      useDebugValue: vu,
      useDeferredValue: function (a) {
        return (uo().memoizedState = a);
      },
      useTransition: function () {
        var a = Ag(!1),
          c = a[0];
        return (a = Ig.bind(null, a[1])), (uo().memoizedState = a), [c, a];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (a, c, v) {
        var M = $n,
          I = uo();
        if (jn) {
          if (v === void 0) throw Error(t(407));
          v = v();
        } else {
          if (((v = c()), vi === null)) throw Error(t(349));
          (Pa & 30) !== 0 || La(M, c, v);
        }
        I.memoizedState = v;
        var O = { value: v, getSnapshot: c };
        return (
          (I.queue = O),
          co(Ri.bind(null, M, O, a), [a]),
          (M.flags |= 2048),
          vc(9, pp.bind(null, M, O, v, c), void 0, null),
          v
        );
      },
      useId: function () {
        var a = uo(),
          c = vi.identifierPrefix;
        if (jn) {
          var v = To,
            M = pt;
          (v = (M & ~(1 << (32 - Qt(M) - 1))).toString(32) + v),
            (c = ":" + c + "R" + v),
            (v = gu++),
            0 < v && (c += "H" + v.toString(32)),
            (c += ":");
        } else (v = hp++), (c = ":" + c + "r" + v.toString(32) + ":");
        return (a.memoizedState = c);
      },
      unstable_isNewReconciler: !1,
    },
    b = {
      readContext: Ti,
      useCallback: yd,
      useContext: Ti,
      useEffect: xc,
      useImperativeHandle: ka,
      useInsertionEffect: Rg,
      useLayoutEffect: Ks,
      useMemo: xd,
      useReducer: md,
      useRef: gp,
      useState: function () {
        return md(gc);
      },
      useDebugValue: vu,
      useDeferredValue: function (a) {
        var c = Io();
        return Pg(c, hr.memoizedState, a);
      },
      useTransition: function () {
        var a = md(gc)[0],
          c = Io().memoizedState;
        return [a, c];
      },
      useMutableSource: Ia,
      useSyncExternalStore: Tg,
      useId: vp,
      unstable_isNewReconciler: !1,
    },
    C = {
      readContext: Ti,
      useCallback: yd,
      useContext: Ti,
      useEffect: xc,
      useImperativeHandle: ka,
      useInsertionEffect: Rg,
      useLayoutEffect: Ks,
      useMemo: xd,
      useReducer: gd,
      useRef: gp,
      useState: function () {
        return gd(gc);
      },
      useDebugValue: vu,
      useDeferredValue: function (a) {
        var c = Io();
        return hr === null ? (c.memoizedState = a) : Pg(c, hr.memoizedState, a);
      },
      useTransition: function () {
        var a = gd(gc)[0],
          c = Io().memoizedState;
        return [a, c];
      },
      useMutableSource: Ia,
      useSyncExternalStore: Tg,
      useId: vp,
      unstable_isNewReconciler: !1,
    };
  function D(a, c) {
    try {
      var v = "",
        M = c;
      do (v += oe(M)), (M = M.return);
      while (M);
      var I = v;
    } catch (O) {
      I =
        `
Error generating stack: ` +
        O.message +
        `
` +
        O.stack;
    }
    return { value: a, source: c, stack: I, digest: null };
  }
  function z(a, c, v) {
    return { value: a, source: null, stack: v ?? null, digest: c ?? null };
  }
  function ce(a, c) {
    try {
      console.error(c.value);
    } catch (v) {
      setTimeout(function () {
        throw v;
      });
    }
  }
  var Me = typeof WeakMap == "function" ? WeakMap : Map;
  function Qe(a, c, v) {
    (v = Ao(-1, v)), (v.tag = 3), (v.payload = { element: null });
    var M = c.value;
    return (
      (v.callback = function () {
        Gg || ((Gg = !0), (Tx = M)), ce(a, c);
      }),
      v
    );
  }
  function ct(a, c, v) {
    (v = Ao(-1, v)), (v.tag = 3);
    var M = a.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var I = c.value;
      (v.payload = function () {
        return M(I);
      }),
        (v.callback = function () {
          ce(a, c);
        });
    }
    var O = a.stateNode;
    return (
      O !== null &&
        typeof O.componentDidCatch == "function" &&
        (v.callback = function () {
          ce(a, c),
            typeof M != "function" &&
              (xu === null ? (xu = new Set([this])) : xu.add(this));
          var Y = c.stack;
          this.componentDidCatch(c.value, {
            componentStack: Y !== null ? Y : "",
          });
        }),
      v
    );
  }
  function Tt(a, c, v) {
    var M = a.pingCache;
    if (M === null) {
      M = a.pingCache = new Me();
      var I = new Set();
      M.set(c, I);
    } else (I = M.get(c)), I === void 0 && ((I = new Set()), M.set(c, I));
    I.has(v) || (I.add(v), (a = ZP.bind(null, a, c, v)), c.then(a, a));
  }
  function Kt(a) {
    do {
      var c;
      if (
        ((c = a.tag === 13) &&
          ((c = a.memoizedState),
          (c = c !== null ? c.dehydrated !== null : !0)),
        c)
      )
        return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function Bt(a, c, v, M, I) {
    return (a.mode & 1) === 0
      ? (a === c
          ? (a.flags |= 65536)
          : ((a.flags |= 128),
            (v.flags |= 131072),
            (v.flags &= -52805),
            v.tag === 1 &&
              (v.alternate === null
                ? (v.tag = 17)
                : ((c = Ao(-1, 1)), (c.tag = 2), gs(v, c, 1))),
            (v.lanes |= 1)),
        a)
      : ((a.flags |= 65536), (a.lanes = I), a);
  }
  var On = A.ReactCurrentOwner,
    bt = !1;
  function Mn(a, c, v, M) {
    c.child = a === null ? ml(c, null, v, M) : Ca(c, a.child, v, M);
  }
  function fo(a, c, v, M, I) {
    v = v.render;
    var O = c.ref;
    return (
      Xs(c, I),
      (M = pd(a, c, v, M, O, I)),
      (v = mc()),
      a !== null && !bt
        ? ((c.updateQueue = a.updateQueue),
          (c.flags &= -2053),
          (a.lanes &= ~I),
          vl(a, c, I))
        : (jn && v && up(c), (c.flags |= 1), Mn(a, c, M, I), c.child)
    );
  }
  function He(a, c, v, M, I) {
    if (a === null) {
      var O = v.type;
      return typeof O == "function" &&
        !kx(O) &&
        O.defaultProps === void 0 &&
        v.compare === null &&
        v.defaultProps === void 0
        ? ((c.tag = 15), (c.type = O), Pe(a, c, O, M, I))
        : ((a = qg(v.type, null, M, c, c.mode, I)),
          (a.ref = c.ref),
          (a.return = c),
          (c.child = a));
    }
    if (((O = a.child), (a.lanes & I) === 0)) {
      var Y = O.memoizedProps;
      if (
        ((v = v.compare), (v = v !== null ? v : nl), v(Y, M) && a.ref === c.ref)
      )
        return vl(a, c, I);
    }
    return (
      (c.flags |= 1),
      (a = bu(O, M)),
      (a.ref = c.ref),
      (a.return = c),
      (c.child = a)
    );
  }
  function Pe(a, c, v, M, I) {
    if (a !== null) {
      var O = a.memoizedProps;
      if (nl(O, M) && a.ref === c.ref)
        if (((bt = !1), (c.pendingProps = M = O), (a.lanes & I) !== 0))
          (a.flags & 131072) !== 0 && (bt = !0);
        else return (c.lanes = a.lanes), vl(a, c, I);
    }
    return It(a, c, v, M, I);
  }
  function Ze(a, c, v) {
    var M = c.pendingProps,
      I = M.children,
      O = a !== null ? a.memoizedState : null;
    if (M.mode === "hidden")
      if ((c.mode & 1) === 0)
        (c.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          Nn(wd, Qo),
          (Qo |= v);
      else {
        if ((v & 1073741824) === 0)
          return (
            (a = O !== null ? O.baseLanes | v : v),
            (c.lanes = c.childLanes = 1073741824),
            (c.memoizedState = {
              baseLanes: a,
              cachePool: null,
              transitions: null,
            }),
            (c.updateQueue = null),
            Nn(wd, Qo),
            (Qo |= a),
            null
          );
        (c.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (M = O !== null ? O.baseLanes : v),
          Nn(wd, Qo),
          (Qo |= M);
      }
    else
      O !== null ? ((M = O.baseLanes | v), (c.memoizedState = null)) : (M = v),
        Nn(wd, Qo),
        (Qo |= M);
    return Mn(a, c, I, v), c.child;
  }
  function _t(a, c) {
    var v = c.ref;
    ((a === null && v !== null) || (a !== null && a.ref !== v)) &&
      ((c.flags |= 512), (c.flags |= 2097152));
  }
  function It(a, c, v, M, I) {
    var O = mi(v) ? Ws : ai.current;
    return (
      (O = ll(c, O)),
      Xs(c, I),
      (v = pd(a, c, v, M, O, I)),
      (M = mc()),
      a !== null && !bt
        ? ((c.updateQueue = a.updateQueue),
          (c.flags &= -2053),
          (a.lanes &= ~I),
          vl(a, c, I))
        : (jn && M && up(c), (c.flags |= 1), Mn(a, c, v, I), c.child)
    );
  }
  function en(a, c, v, M, I) {
    if (mi(v)) {
      var O = !0;
      ul(c);
    } else O = !1;
    if ((Xs(c, I), c.stateNode === null))
      Fg(a, c), fu(c, v, M), du(c, v, M, I), (M = !0);
    else if (a === null) {
      var Y = c.stateNode,
        pe = c.memoizedProps;
      Y.props = pe;
      var ye = Y.context,
        je = v.contextType;
      typeof je == "object" && je !== null
        ? (je = Ti(je))
        : ((je = mi(v) ? Ws : ai.current), (je = ll(c, je)));
      var st = v.getDerivedStateFromProps,
        lt =
          typeof st == "function" ||
          typeof Y.getSnapshotBeforeUpdate == "function";
      lt ||
        (typeof Y.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Y.componentWillReceiveProps != "function") ||
        ((pe !== M || ye !== je) && hl(c, Y, M, je)),
        (Ys = !1);
      var ot = c.memoizedState;
      (Y.state = ot),
        rr(c, M, Y, I),
        (ye = c.memoizedState),
        pe !== M || ot !== ye || bi.current || Ys
          ? (typeof st == "function" &&
              (Ci(c, v, st, M), (ye = c.memoizedState)),
            (pe = Ys || Sr(c, v, pe, M, ot, ye, je))
              ? (lt ||
                  (typeof Y.UNSAFE_componentWillMount != "function" &&
                    typeof Y.componentWillMount != "function") ||
                  (typeof Y.componentWillMount == "function" &&
                    Y.componentWillMount(),
                  typeof Y.UNSAFE_componentWillMount == "function" &&
                    Y.UNSAFE_componentWillMount()),
                typeof Y.componentDidMount == "function" &&
                  (c.flags |= 4194308))
              : (typeof Y.componentDidMount == "function" &&
                  (c.flags |= 4194308),
                (c.memoizedProps = M),
                (c.memoizedState = ye)),
            (Y.props = M),
            (Y.state = ye),
            (Y.context = je),
            (M = pe))
          : (typeof Y.componentDidMount == "function" && (c.flags |= 4194308),
            (M = !1));
    } else {
      (Y = c.stateNode),
        Eg(a, c),
        (pe = c.memoizedProps),
        (je = c.type === c.elementType ? pe : qo(c.type, pe)),
        (Y.props = je),
        (lt = c.pendingProps),
        (ot = Y.context),
        (ye = v.contextType),
        typeof ye == "object" && ye !== null
          ? (ye = Ti(ye))
          : ((ye = mi(v) ? Ws : ai.current), (ye = ll(c, ye)));
      var Mt = v.getDerivedStateFromProps;
      (st =
        typeof Mt == "function" ||
        typeof Y.getSnapshotBeforeUpdate == "function") ||
        (typeof Y.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Y.componentWillReceiveProps != "function") ||
        ((pe !== lt || ot !== ye) && hl(c, Y, M, ye)),
        (Ys = !1),
        (ot = c.memoizedState),
        (Y.state = ot),
        rr(c, M, Y, I);
      var Rt = c.memoizedState;
      pe !== lt || ot !== Rt || bi.current || Ys
        ? (typeof Mt == "function" && (Ci(c, v, Mt, M), (Rt = c.memoizedState)),
          (je = Ys || Sr(c, v, je, M, ot, Rt, ye) || !1)
            ? (st ||
                (typeof Y.UNSAFE_componentWillUpdate != "function" &&
                  typeof Y.componentWillUpdate != "function") ||
                (typeof Y.componentWillUpdate == "function" &&
                  Y.componentWillUpdate(M, Rt, ye),
                typeof Y.UNSAFE_componentWillUpdate == "function" &&
                  Y.UNSAFE_componentWillUpdate(M, Rt, ye)),
              typeof Y.componentDidUpdate == "function" && (c.flags |= 4),
              typeof Y.getSnapshotBeforeUpdate == "function" &&
                (c.flags |= 1024))
            : (typeof Y.componentDidUpdate != "function" ||
                (pe === a.memoizedProps && ot === a.memoizedState) ||
                (c.flags |= 4),
              typeof Y.getSnapshotBeforeUpdate != "function" ||
                (pe === a.memoizedProps && ot === a.memoizedState) ||
                (c.flags |= 1024),
              (c.memoizedProps = M),
              (c.memoizedState = Rt)),
          (Y.props = M),
          (Y.state = Rt),
          (Y.context = ye),
          (M = je))
        : (typeof Y.componentDidUpdate != "function" ||
            (pe === a.memoizedProps && ot === a.memoizedState) ||
            (c.flags |= 4),
          typeof Y.getSnapshotBeforeUpdate != "function" ||
            (pe === a.memoizedProps && ot === a.memoizedState) ||
            (c.flags |= 1024),
          (M = !1));
    }
    return Yt(a, c, v, M, O, I);
  }
  function Yt(a, c, v, M, I, O) {
    _t(a, c);
    var Y = (c.flags & 128) !== 0;
    if (!M && !Y) return I && ap(c, v, !1), vl(a, c, O);
    (M = c.stateNode), (On.current = c);
    var pe =
      Y && typeof v.getDerivedStateFromError != "function" ? null : M.render();
    return (
      (c.flags |= 1),
      a !== null && Y
        ? ((c.child = Ca(c, a.child, null, O)), (c.child = Ca(c, null, pe, O)))
        : Mn(a, c, pe, O),
      (c.memoizedState = M.state),
      I && ap(c, v, !0),
      c.child
    );
  }
  function pn(a) {
    var c = a.stateNode;
    c.pendingContext
      ? sp(a, c.pendingContext, c.pendingContext !== c.context)
      : c.context && sp(a, c.context, !1),
      hu(a, c.containerInfo);
  }
  function kr(a, c, v, M, I) {
    return Ea(), au(I), (c.flags |= 256), Mn(a, c, v, M), c.child;
  }
  var hn = { dehydrated: null, treeContext: null, retryLane: 0 };
  function xs(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function Og(a, c, v) {
    var M = c.pendingProps,
      I = Hn.current,
      O = !1,
      Y = (c.flags & 128) !== 0,
      pe;
    if (
      ((pe = Y) ||
        (pe = a !== null && a.memoizedState === null ? !1 : (I & 2) !== 0),
      pe
        ? ((O = !0), (c.flags &= -129))
        : (a === null || a.memoizedState !== null) && (I |= 1),
      Nn(Hn, I & 1),
      a === null)
    )
      return (
        ad(c),
        (a = c.memoizedState),
        a !== null && ((a = a.dehydrated), a !== null)
          ? ((c.mode & 1) === 0
              ? (c.lanes = 1)
              : a.data === "$!"
              ? (c.lanes = 8)
              : (c.lanes = 1073741824),
            null)
          : ((Y = M.children),
            (a = M.fallback),
            O
              ? ((M = c.mode),
                (O = c.child),
                (Y = { mode: "hidden", children: Y }),
                (M & 1) === 0 && O !== null
                  ? ((O.childLanes = 0), (O.pendingProps = Y))
                  : (O = Kg(Y, M, 0, null)),
                (a = Ec(a, M, v, null)),
                (O.return = c),
                (a.return = c),
                (O.sibling = a),
                (c.child = O),
                (c.child.memoizedState = xs(v)),
                (c.memoizedState = hn),
                a)
              : gx(c, Y))
      );
    if (
      ((I = a.memoizedState), I !== null && ((pe = I.dehydrated), pe !== null))
    )
      return BP(a, c, Y, M, pe, I, v);
    if (O) {
      (O = M.fallback), (Y = c.mode), (I = a.child), (pe = I.sibling);
      var ye = { mode: "hidden", children: M.children };
      return (
        (Y & 1) === 0 && c.child !== I
          ? ((M = c.child),
            (M.childLanes = 0),
            (M.pendingProps = ye),
            (c.deletions = null))
          : ((M = bu(I, ye)), (M.subtreeFlags = I.subtreeFlags & 14680064)),
        pe !== null
          ? (O = bu(pe, O))
          : ((O = Ec(O, Y, v, null)), (O.flags |= 2)),
        (O.return = c),
        (M.return = c),
        (M.sibling = O),
        (c.child = M),
        (M = O),
        (O = c.child),
        (Y = a.child.memoizedState),
        (Y =
          Y === null
            ? xs(v)
            : {
                baseLanes: Y.baseLanes | v,
                cachePool: null,
                transitions: Y.transitions,
              }),
        (O.memoizedState = Y),
        (O.childLanes = a.childLanes & ~v),
        (c.memoizedState = hn),
        M
      );
    }
    return (
      (O = a.child),
      (a = O.sibling),
      (M = bu(O, { mode: "visible", children: M.children })),
      (c.mode & 1) === 0 && (M.lanes = v),
      (M.return = c),
      (M.sibling = null),
      a !== null &&
        ((v = c.deletions),
        v === null ? ((c.deletions = [a]), (c.flags |= 16)) : v.push(a)),
      (c.child = M),
      (c.memoizedState = null),
      M
    );
  }
  function gx(a, c) {
    return (
      (c = Kg({ mode: "visible", children: c }, a.mode, 0, null)),
      (c.return = a),
      (a.child = c)
    );
  }
  function Ug(a, c, v, M) {
    return (
      M !== null && au(M),
      Ca(c, a.child, null, v),
      (a = gx(c, c.pendingProps.children)),
      (a.flags |= 2),
      (c.memoizedState = null),
      a
    );
  }
  function BP(a, c, v, M, I, O, Y) {
    if (v)
      return c.flags & 256
        ? ((c.flags &= -257), (M = z(Error(t(422)))), Ug(a, c, Y, M))
        : c.memoizedState !== null
        ? ((c.child = a.child), (c.flags |= 128), null)
        : ((O = M.fallback),
          (I = c.mode),
          (M = Kg({ mode: "visible", children: M.children }, I, 0, null)),
          (O = Ec(O, I, Y, null)),
          (O.flags |= 2),
          (M.return = c),
          (O.return = c),
          (M.sibling = O),
          (c.child = M),
          (c.mode & 1) !== 0 && Ca(c, a.child, null, Y),
          (c.child.memoizedState = xs(Y)),
          (c.memoizedState = hn),
          O);
    if ((c.mode & 1) === 0) return Ug(a, c, Y, null);
    if (I.data === "$!") {
      if (((M = I.nextSibling && I.nextSibling.dataset), M)) var pe = M.dgst;
      return (
        (M = pe), (O = Error(t(419))), (M = z(O, M, void 0)), Ug(a, c, Y, M)
      );
    }
    if (((pe = (Y & a.childLanes) !== 0), bt || pe)) {
      if (((M = vi), M !== null)) {
        switch (Y & -Y) {
          case 4:
            I = 2;
            break;
          case 16:
            I = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            I = 32;
            break;
          case 536870912:
            I = 268435456;
            break;
          default:
            I = 0;
        }
        (I = (I & (M.suspendedLanes | Y)) !== 0 ? 0 : I),
          I !== 0 &&
            I !== O.retryLane &&
            ((O.retryLane = I), Zo(a, I), Qs(M, a, I, -1));
      }
      return Lx(), (M = z(Error(t(421)))), Ug(a, c, Y, M);
    }
    return I.data === "$?"
      ? ((c.flags |= 128),
        (c.child = a.child),
        (c = JP.bind(null, a)),
        (I._reactRetry = c),
        null)
      : ((a = O.treeContext),
        (Ei = Hs(I.nextSibling)),
        (li = c),
        (jn = !0),
        (Co = null),
        a !== null &&
          ((Mi[qr++] = pt),
          (Mi[qr++] = To),
          (Mi[qr++] = fl),
          (pt = a.id),
          (To = a.overflow),
          (fl = c)),
        (c = gx(c, M.children)),
        (c.flags |= 4096),
        c);
  }
  function qw(a, c, v) {
    a.lanes |= c;
    var M = a.alternate;
    M !== null && (M.lanes |= c), cu(a.return, c, v);
  }
  function vx(a, c, v, M, I) {
    var O = a.memoizedState;
    O === null
      ? (a.memoizedState = {
          isBackwards: c,
          rendering: null,
          renderingStartTime: 0,
          last: M,
          tail: v,
          tailMode: I,
        })
      : ((O.isBackwards = c),
        (O.rendering = null),
        (O.renderingStartTime = 0),
        (O.last = M),
        (O.tail = v),
        (O.tailMode = I));
  }
  function Kw(a, c, v) {
    var M = c.pendingProps,
      I = M.revealOrder,
      O = M.tail;
    if ((Mn(a, c, M.children, v), (M = Hn.current), (M & 2) !== 0))
      (M = (M & 1) | 2), (c.flags |= 128);
    else {
      if (a !== null && (a.flags & 128) !== 0)
        e: for (a = c.child; a !== null; ) {
          if (a.tag === 13) a.memoizedState !== null && qw(a, v, c);
          else if (a.tag === 19) qw(a, v, c);
          else if (a.child !== null) {
            (a.child.return = a), (a = a.child);
            continue;
          }
          if (a === c) break e;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === c) break e;
            a = a.return;
          }
          (a.sibling.return = a.return), (a = a.sibling);
        }
      M &= 1;
    }
    if ((Nn(Hn, M), (c.mode & 1) === 0)) c.memoizedState = null;
    else
      switch (I) {
        case "forwards":
          for (v = c.child, I = null; v !== null; )
            (a = v.alternate),
              a !== null && Zr(a) === null && (I = v),
              (v = v.sibling);
          (v = I),
            v === null
              ? ((I = c.child), (c.child = null))
              : ((I = v.sibling), (v.sibling = null)),
            vx(c, !1, I, v, O);
          break;
        case "backwards":
          for (v = null, I = c.child, c.child = null; I !== null; ) {
            if (((a = I.alternate), a !== null && Zr(a) === null)) {
              c.child = I;
              break;
            }
            (a = I.sibling), (I.sibling = v), (v = I), (I = a);
          }
          vx(c, !0, v, null, O);
          break;
        case "together":
          vx(c, !1, null, null, void 0);
          break;
        default:
          c.memoizedState = null;
      }
    return c.child;
  }
  function Fg(a, c) {
    (c.mode & 1) === 0 &&
      a !== null &&
      ((a.alternate = null), (c.alternate = null), (c.flags |= 2));
  }
  function vl(a, c, v) {
    if (
      (a !== null && (c.dependencies = a.dependencies),
      (Sc |= c.lanes),
      (v & c.childLanes) === 0)
    )
      return null;
    if (a !== null && c.child !== a.child) throw Error(t(153));
    if (c.child !== null) {
      for (
        a = c.child, v = bu(a, a.pendingProps), c.child = v, v.return = c;
        a.sibling !== null;

      )
        (a = a.sibling),
          (v = v.sibling = bu(a, a.pendingProps)),
          (v.return = c);
      v.sibling = null;
    }
    return c.child;
  }
  function zP(a, c, v) {
    switch (c.tag) {
      case 3:
        pn(c), Ea();
        break;
      case 5:
        dd(c);
        break;
      case 1:
        mi(c.type) && ul(c);
        break;
      case 4:
        hu(c, c.stateNode.containerInfo);
        break;
      case 10:
        var M = c.type._context,
          I = c.memoizedProps.value;
        Nn(fc, M._currentValue), (M._currentValue = I);
        break;
      case 13:
        if (((M = c.memoizedState), M !== null))
          return M.dehydrated !== null
            ? (Nn(Hn, Hn.current & 1), (c.flags |= 128), null)
            : (v & c.child.childLanes) !== 0
            ? Og(a, c, v)
            : (Nn(Hn, Hn.current & 1),
              (a = vl(a, c, v)),
              a !== null ? a.sibling : null);
        Nn(Hn, Hn.current & 1);
        break;
      case 19:
        if (((M = (v & c.childLanes) !== 0), (a.flags & 128) !== 0)) {
          if (M) return Kw(a, c, v);
          c.flags |= 128;
        }
        if (
          ((I = c.memoizedState),
          I !== null &&
            ((I.rendering = null), (I.tail = null), (I.lastEffect = null)),
          Nn(Hn, Hn.current),
          M)
        )
          break;
        return null;
      case 22:
      case 23:
        return (c.lanes = 0), Ze(a, c, v);
    }
    return vl(a, c, v);
  }
  var Zw, yx, Jw, Qw;
  (Zw = function (a, c) {
    for (var v = c.child; v !== null; ) {
      if (v.tag === 5 || v.tag === 6) a.appendChild(v.stateNode);
      else if (v.tag !== 4 && v.child !== null) {
        (v.child.return = v), (v = v.child);
        continue;
      }
      if (v === c) break;
      for (; v.sibling === null; ) {
        if (v.return === null || v.return === c) return;
        v = v.return;
      }
      (v.sibling.return = v.return), (v = v.sibling);
    }
  }),
    (yx = function () {}),
    (Jw = function (a, c, v, M) {
      var I = a.memoizedProps;
      if (I !== M) {
        (a = c.stateNode), Vi(Ro.current);
        var O = null;
        switch (v) {
          case "input":
            (I = Ae(a, I)), (M = Ae(a, M)), (O = []);
            break;
          case "select":
            (I = F({}, I, { value: void 0 })),
              (M = F({}, M, { value: void 0 })),
              (O = []);
            break;
          case "textarea":
            (I = ve(a, I)), (M = ve(a, M)), (O = []);
            break;
          default:
            typeof I.onClick != "function" &&
              typeof M.onClick == "function" &&
              (a.onclick = sc);
        }
        he(v, M);
        var Y;
        v = null;
        for (je in I)
          if (!M.hasOwnProperty(je) && I.hasOwnProperty(je) && I[je] != null)
            if (je === "style") {
              var pe = I[je];
              for (Y in pe)
                pe.hasOwnProperty(Y) && (v || (v = {}), (v[Y] = ""));
            } else
              je !== "dangerouslySetInnerHTML" &&
                je !== "children" &&
                je !== "suppressContentEditableWarning" &&
                je !== "suppressHydrationWarning" &&
                je !== "autoFocus" &&
                (i.hasOwnProperty(je)
                  ? O || (O = [])
                  : (O = O || []).push(je, null));
        for (je in M) {
          var ye = M[je];
          if (
            ((pe = I != null ? I[je] : void 0),
            M.hasOwnProperty(je) && ye !== pe && (ye != null || pe != null))
          )
            if (je === "style")
              if (pe) {
                for (Y in pe)
                  !pe.hasOwnProperty(Y) ||
                    (ye && ye.hasOwnProperty(Y)) ||
                    (v || (v = {}), (v[Y] = ""));
                for (Y in ye)
                  ye.hasOwnProperty(Y) &&
                    pe[Y] !== ye[Y] &&
                    (v || (v = {}), (v[Y] = ye[Y]));
              } else v || (O || (O = []), O.push(je, v)), (v = ye);
            else
              je === "dangerouslySetInnerHTML"
                ? ((ye = ye ? ye.__html : void 0),
                  (pe = pe ? pe.__html : void 0),
                  ye != null && pe !== ye && (O = O || []).push(je, ye))
                : je === "children"
                ? (typeof ye != "string" && typeof ye != "number") ||
                  (O = O || []).push(je, "" + ye)
                : je !== "suppressContentEditableWarning" &&
                  je !== "suppressHydrationWarning" &&
                  (i.hasOwnProperty(je)
                    ? (ye != null && je === "onScroll" && Bn("scroll", a),
                      O || pe === ye || (O = []))
                    : (O = O || []).push(je, ye));
        }
        v && (O = O || []).push("style", v);
        var je = O;
        (c.updateQueue = je) && (c.flags |= 4);
      }
    }),
    (Qw = function (a, c, v, M) {
      v !== M && (c.flags |= 4);
    });
  function yp(a, c) {
    if (!jn)
      switch (a.tailMode) {
        case "hidden":
          c = a.tail;
          for (var v = null; c !== null; )
            c.alternate !== null && (v = c), (c = c.sibling);
          v === null ? (a.tail = null) : (v.sibling = null);
          break;
        case "collapsed":
          v = a.tail;
          for (var M = null; v !== null; )
            v.alternate !== null && (M = v), (v = v.sibling);
          M === null
            ? c || a.tail === null
              ? (a.tail = null)
              : (a.tail.sibling = null)
            : (M.sibling = null);
      }
  }
  function Wi(a) {
    var c = a.alternate !== null && a.alternate.child === a.child,
      v = 0,
      M = 0;
    if (c)
      for (var I = a.child; I !== null; )
        (v |= I.lanes | I.childLanes),
          (M |= I.subtreeFlags & 14680064),
          (M |= I.flags & 14680064),
          (I.return = a),
          (I = I.sibling);
    else
      for (I = a.child; I !== null; )
        (v |= I.lanes | I.childLanes),
          (M |= I.subtreeFlags),
          (M |= I.flags),
          (I.return = a),
          (I = I.sibling);
    return (a.subtreeFlags |= M), (a.childLanes = v), c;
  }
  function HP(a, c, v) {
    var M = c.pendingProps;
    switch (($s(c), c.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Wi(c), null;
      case 1:
        return mi(c.type) && ac(), Wi(c), null;
      case 3:
        return (
          (M = c.stateNode),
          vs(),
          zn(bi),
          zn(ai),
          Gi(),
          M.pendingContext &&
            ((M.context = M.pendingContext), (M.pendingContext = null)),
          (a === null || a.child === null) &&
            (su(c)
              ? (c.flags |= 4)
              : a === null ||
                (a.memoizedState.isDehydrated && (c.flags & 256) === 0) ||
                ((c.flags |= 1024), Co !== null && (Rx(Co), (Co = null)))),
          yx(a, c),
          Wi(c),
          null
        );
      case 5:
        pu(c);
        var I = Vi(Ra.current);
        if (((v = c.type), a !== null && c.stateNode != null))
          Jw(a, c, v, M, I),
            a.ref !== c.ref && ((c.flags |= 512), (c.flags |= 2097152));
        else {
          if (!M) {
            if (c.stateNode === null) throw Error(t(166));
            return Wi(c), null;
          }
          if (((a = Vi(Ro.current)), su(c))) {
            (M = c.stateNode), (v = c.type);
            var O = c.memoizedProps;
            switch (((M[Lr] = c), (M[ou] = O), (a = (c.mode & 1) !== 0), v)) {
              case "dialog":
                Bn("cancel", M), Bn("close", M);
                break;
              case "iframe":
              case "object":
              case "embed":
                Bn("load", M);
                break;
              case "video":
              case "audio":
                for (I = 0; I < ba.length; I++) Bn(ba[I], M);
                break;
              case "source":
                Bn("error", M);
                break;
              case "img":
              case "image":
              case "link":
                Bn("error", M), Bn("load", M);
                break;
              case "details":
                Bn("toggle", M);
                break;
              case "input":
                Ne(M, O), Bn("invalid", M);
                break;
              case "select":
                (M._wrapperState = { wasMultiple: !!O.multiple }),
                  Bn("invalid", M);
                break;
              case "textarea":
                Se(M, O), Bn("invalid", M);
            }
            he(v, O), (I = null);
            for (var Y in O)
              if (O.hasOwnProperty(Y)) {
                var pe = O[Y];
                Y === "children"
                  ? typeof pe == "string"
                    ? M.textContent !== pe &&
                      (O.suppressHydrationWarning !== !0 &&
                        oc(M.textContent, pe, a),
                      (I = ["children", pe]))
                    : typeof pe == "number" &&
                      M.textContent !== "" + pe &&
                      (O.suppressHydrationWarning !== !0 &&
                        oc(M.textContent, pe, a),
                      (I = ["children", "" + pe]))
                  : i.hasOwnProperty(Y) &&
                    pe != null &&
                    Y === "onScroll" &&
                    Bn("scroll", M);
              }
            switch (v) {
              case "input":
                xe(M), ke(M, O, !0);
                break;
              case "textarea":
                xe(M), Te(M);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof O.onClick == "function" && (M.onclick = sc);
            }
            (M = I), (c.updateQueue = M), M !== null && (c.flags |= 4);
          } else {
            (Y = I.nodeType === 9 ? I : I.ownerDocument),
              a === "http://www.w3.org/1999/xhtml" && (a = at(v)),
              a === "http://www.w3.org/1999/xhtml"
                ? v === "script"
                  ? ((a = Y.createElement("div")),
                    (a.innerHTML = "<script></script>"),
                    (a = a.removeChild(a.firstChild)))
                  : typeof M.is == "string"
                  ? (a = Y.createElement(v, { is: M.is }))
                  : ((a = Y.createElement(v)),
                    v === "select" &&
                      ((Y = a),
                      M.multiple
                        ? (Y.multiple = !0)
                        : M.size && (Y.size = M.size)))
                : (a = Y.createElementNS(a, v)),
              (a[Lr] = c),
              (a[ou] = M),
              Zw(a, c, !1, !1),
              (c.stateNode = a);
            e: {
              switch (((Y = Je(v, M)), v)) {
                case "dialog":
                  Bn("cancel", a), Bn("close", a), (I = M);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Bn("load", a), (I = M);
                  break;
                case "video":
                case "audio":
                  for (I = 0; I < ba.length; I++) Bn(ba[I], a);
                  I = M;
                  break;
                case "source":
                  Bn("error", a), (I = M);
                  break;
                case "img":
                case "image":
                case "link":
                  Bn("error", a), Bn("load", a), (I = M);
                  break;
                case "details":
                  Bn("toggle", a), (I = M);
                  break;
                case "input":
                  Ne(a, M), (I = Ae(a, M)), Bn("invalid", a);
                  break;
                case "option":
                  I = M;
                  break;
                case "select":
                  (a._wrapperState = { wasMultiple: !!M.multiple }),
                    (I = F({}, M, { value: void 0 })),
                    Bn("invalid", a);
                  break;
                case "textarea":
                  Se(a, M), (I = ve(a, M)), Bn("invalid", a);
                  break;
                default:
                  I = M;
              }
              he(v, I), (pe = I);
              for (O in pe)
                if (pe.hasOwnProperty(O)) {
                  var ye = pe[O];
                  O === "style"
                    ? qe(a, ye)
                    : O === "dangerouslySetInnerHTML"
                    ? ((ye = ye ? ye.__html : void 0), ye != null && We(a, ye))
                    : O === "children"
                    ? typeof ye == "string"
                      ? (v !== "textarea" || ye !== "") && Ye(a, ye)
                      : typeof ye == "number" && Ye(a, "" + ye)
                    : O !== "suppressContentEditableWarning" &&
                      O !== "suppressHydrationWarning" &&
                      O !== "autoFocus" &&
                      (i.hasOwnProperty(O)
                        ? ye != null && O === "onScroll" && Bn("scroll", a)
                        : ye != null && E(a, O, ye, Y));
                }
              switch (v) {
                case "input":
                  xe(a), ke(a, M, !1);
                  break;
                case "textarea":
                  xe(a), Te(a);
                  break;
                case "option":
                  M.value != null && a.setAttribute("value", "" + fe(M.value));
                  break;
                case "select":
                  (a.multiple = !!M.multiple),
                    (O = M.value),
                    O != null
                      ? B(a, !!M.multiple, O, !1)
                      : M.defaultValue != null &&
                        B(a, !!M.multiple, M.defaultValue, !0);
                  break;
                default:
                  typeof I.onClick == "function" && (a.onclick = sc);
              }
              switch (v) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  M = !!M.autoFocus;
                  break e;
                case "img":
                  M = !0;
                  break e;
                default:
                  M = !1;
              }
            }
            M && (c.flags |= 4);
          }
          c.ref !== null && ((c.flags |= 512), (c.flags |= 2097152));
        }
        return Wi(c), null;
      case 6:
        if (a && c.stateNode != null) Qw(a, c, a.memoizedProps, M);
        else {
          if (typeof M != "string" && c.stateNode === null) throw Error(t(166));
          if (((v = Vi(Ra.current)), Vi(Ro.current), su(c))) {
            if (
              ((M = c.stateNode),
              (v = c.memoizedProps),
              (M[Lr] = c),
              (O = M.nodeValue !== v) && ((a = li), a !== null))
            )
              switch (a.tag) {
                case 3:
                  oc(M.nodeValue, v, (a.mode & 1) !== 0);
                  break;
                case 5:
                  a.memoizedProps.suppressHydrationWarning !== !0 &&
                    oc(M.nodeValue, v, (a.mode & 1) !== 0);
              }
            O && (c.flags |= 4);
          } else
            (M = (v.nodeType === 9 ? v : v.ownerDocument).createTextNode(M)),
              (M[Lr] = c),
              (c.stateNode = M);
        }
        return Wi(c), null;
      case 13:
        if (
          (zn(Hn),
          (M = c.memoizedState),
          a === null ||
            (a.memoizedState !== null && a.memoizedState.dehydrated !== null))
        ) {
          if (jn && Ei !== null && (c.mode & 1) !== 0 && (c.flags & 128) === 0)
            dp(), Ea(), (c.flags |= 98560), (O = !1);
          else if (((O = su(c)), M !== null && M.dehydrated !== null)) {
            if (a === null) {
              if (!O) throw Error(t(318));
              if (
                ((O = c.memoizedState),
                (O = O !== null ? O.dehydrated : null),
                !O)
              )
                throw Error(t(317));
              O[Lr] = c;
            } else
              Ea(),
                (c.flags & 128) === 0 && (c.memoizedState = null),
                (c.flags |= 4);
            Wi(c), (O = !1);
          } else Co !== null && (Rx(Co), (Co = null)), (O = !0);
          if (!O) return c.flags & 65536 ? c : null;
        }
        return (c.flags & 128) !== 0
          ? ((c.lanes = v), c)
          : ((M = M !== null),
            M !== (a !== null && a.memoizedState !== null) &&
              M &&
              ((c.child.flags |= 8192),
              (c.mode & 1) !== 0 &&
                (a === null || (Hn.current & 1) !== 0
                  ? ui === 0 && (ui = 3)
                  : Lx())),
            c.updateQueue !== null && (c.flags |= 4),
            Wi(c),
            null);
      case 4:
        return (
          vs(),
          yx(a, c),
          a === null && nu(c.stateNode.containerInfo),
          Wi(c),
          null
        );
      case 10:
        return uu(c.type._context), Wi(c), null;
      case 17:
        return mi(c.type) && ac(), Wi(c), null;
      case 19:
        if ((zn(Hn), (O = c.memoizedState), O === null)) return Wi(c), null;
        if (((M = (c.flags & 128) !== 0), (Y = O.rendering), Y === null))
          if (M) yp(O, !1);
          else {
            if (ui !== 0 || (a !== null && (a.flags & 128) !== 0))
              for (a = c.child; a !== null; ) {
                if (((Y = Zr(a)), Y !== null)) {
                  for (
                    c.flags |= 128,
                      yp(O, !1),
                      M = Y.updateQueue,
                      M !== null && ((c.updateQueue = M), (c.flags |= 4)),
                      c.subtreeFlags = 0,
                      M = v,
                      v = c.child;
                    v !== null;

                  )
                    (O = v),
                      (a = M),
                      (O.flags &= 14680066),
                      (Y = O.alternate),
                      Y === null
                        ? ((O.childLanes = 0),
                          (O.lanes = a),
                          (O.child = null),
                          (O.subtreeFlags = 0),
                          (O.memoizedProps = null),
                          (O.memoizedState = null),
                          (O.updateQueue = null),
                          (O.dependencies = null),
                          (O.stateNode = null))
                        : ((O.childLanes = Y.childLanes),
                          (O.lanes = Y.lanes),
                          (O.child = Y.child),
                          (O.subtreeFlags = 0),
                          (O.deletions = null),
                          (O.memoizedProps = Y.memoizedProps),
                          (O.memoizedState = Y.memoizedState),
                          (O.updateQueue = Y.updateQueue),
                          (O.type = Y.type),
                          (a = Y.dependencies),
                          (O.dependencies =
                            a === null
                              ? null
                              : {
                                  lanes: a.lanes,
                                  firstContext: a.firstContext,
                                })),
                      (v = v.sibling);
                  return Nn(Hn, (Hn.current & 1) | 2), c.child;
                }
                a = a.sibling;
              }
            O.tail !== null &&
              Ke() > bd &&
              ((c.flags |= 128), (M = !0), yp(O, !1), (c.lanes = 4194304));
          }
        else {
          if (!M)
            if (((a = Zr(Y)), a !== null)) {
              if (
                ((c.flags |= 128),
                (M = !0),
                (v = a.updateQueue),
                v !== null && ((c.updateQueue = v), (c.flags |= 4)),
                yp(O, !0),
                O.tail === null &&
                  O.tailMode === "hidden" &&
                  !Y.alternate &&
                  !jn)
              )
                return Wi(c), null;
            } else
              2 * Ke() - O.renderingStartTime > bd &&
                v !== 1073741824 &&
                ((c.flags |= 128), (M = !0), yp(O, !1), (c.lanes = 4194304));
          O.isBackwards
            ? ((Y.sibling = c.child), (c.child = Y))
            : ((v = O.last),
              v !== null ? (v.sibling = Y) : (c.child = Y),
              (O.last = Y));
        }
        return O.tail !== null
          ? ((c = O.tail),
            (O.rendering = c),
            (O.tail = c.sibling),
            (O.renderingStartTime = Ke()),
            (c.sibling = null),
            (v = Hn.current),
            Nn(Hn, M ? (v & 1) | 2 : v & 1),
            c)
          : (Wi(c), null);
      case 22:
      case 23:
        return (
          Ix(),
          (M = c.memoizedState !== null),
          a !== null && (a.memoizedState !== null) !== M && (c.flags |= 8192),
          M && (c.mode & 1) !== 0
            ? (Qo & 1073741824) !== 0 &&
              (Wi(c), c.subtreeFlags & 6 && (c.flags |= 8192))
            : Wi(c),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, c.tag));
  }
  function VP(a, c) {
    switch (($s(c), c.tag)) {
      case 1:
        return (
          mi(c.type) && ac(),
          (a = c.flags),
          a & 65536 ? ((c.flags = (a & -65537) | 128), c) : null
        );
      case 3:
        return (
          vs(),
          zn(bi),
          zn(ai),
          Gi(),
          (a = c.flags),
          (a & 65536) !== 0 && (a & 128) === 0
            ? ((c.flags = (a & -65537) | 128), c)
            : null
        );
      case 5:
        return pu(c), null;
      case 13:
        if (
          (zn(Hn), (a = c.memoizedState), a !== null && a.dehydrated !== null)
        ) {
          if (c.alternate === null) throw Error(t(340));
          Ea();
        }
        return (
          (a = c.flags), a & 65536 ? ((c.flags = (a & -65537) | 128), c) : null
        );
      case 19:
        return zn(Hn), null;
      case 4:
        return vs(), null;
      case 10:
        return uu(c.type._context), null;
      case 22:
      case 23:
        return Ix(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Bg = !1,
    ji = !1,
    GP = typeof WeakSet == "function" ? WeakSet : Set,
    Ct = null;
  function Sd(a, c) {
    var v = a.ref;
    if (v !== null)
      if (typeof v == "function")
        try {
          v(null);
        } catch (M) {
          wr(a, c, M);
        }
      else v.current = null;
  }
  function xx(a, c, v) {
    try {
      v();
    } catch (M) {
      wr(a, c, M);
    }
  }
  var eb = !1;
  function WP(a, c) {
    if (((iu = Vr), (a = nr()), jr(a))) {
      if ("selectionStart" in a)
        var v = { start: a.selectionStart, end: a.selectionEnd };
      else
        e: {
          v = ((v = a.ownerDocument) && v.defaultView) || window;
          var M = v.getSelection && v.getSelection();
          if (M && M.rangeCount !== 0) {
            v = M.anchorNode;
            var I = M.anchorOffset,
              O = M.focusNode;
            M = M.focusOffset;
            try {
              v.nodeType, O.nodeType;
            } catch {
              v = null;
              break e;
            }
            var Y = 0,
              pe = -1,
              ye = -1,
              je = 0,
              st = 0,
              lt = a,
              ot = null;
            t: for (;;) {
              for (
                var Mt;
                lt !== v || (I !== 0 && lt.nodeType !== 3) || (pe = Y + I),
                  lt !== O || (M !== 0 && lt.nodeType !== 3) || (ye = Y + M),
                  lt.nodeType === 3 && (Y += lt.nodeValue.length),
                  (Mt = lt.firstChild) !== null;

              )
                (ot = lt), (lt = Mt);
              for (;;) {
                if (lt === a) break t;
                if (
                  (ot === v && ++je === I && (pe = Y),
                  ot === O && ++st === M && (ye = Y),
                  (Mt = lt.nextSibling) !== null)
                )
                  break;
                (lt = ot), (ot = lt.parentNode);
              }
              lt = Mt;
            }
            v = pe === -1 || ye === -1 ? null : { start: pe, end: ye };
          } else v = null;
        }
      v = v || { start: 0, end: 0 };
    } else v = null;
    for (
      ep = { focusedElem: a, selectionRange: v }, Vr = !1, Ct = c;
      Ct !== null;

    )
      if (
        ((c = Ct), (a = c.child), (c.subtreeFlags & 1028) !== 0 && a !== null)
      )
        (a.return = c), (Ct = a);
      else
        for (; Ct !== null; ) {
          c = Ct;
          try {
            var Rt = c.alternate;
            if ((c.flags & 1024) !== 0)
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Rt !== null) {
                    var Lt = Rt.memoizedProps,
                      Dr = Rt.memoizedState,
                      De = c.stateNode,
                      be = De.getSnapshotBeforeUpdate(
                        c.elementType === c.type ? Lt : qo(c.type, Lt),
                        Dr
                      );
                    De.__reactInternalSnapshotBeforeUpdate = be;
                  }
                  break;
                case 3:
                  var Oe = c.stateNode.containerInfo;
                  Oe.nodeType === 1
                    ? (Oe.textContent = "")
                    : Oe.nodeType === 9 &&
                      Oe.documentElement &&
                      Oe.removeChild(Oe.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (ft) {
            wr(c, c.return, ft);
          }
          if (((a = c.sibling), a !== null)) {
            (a.return = c.return), (Ct = a);
            break;
          }
          Ct = c.return;
        }
    return (Rt = eb), (eb = !1), Rt;
  }
  function xp(a, c, v) {
    var M = c.updateQueue;
    if (((M = M !== null ? M.lastEffect : null), M !== null)) {
      var I = (M = M.next);
      do {
        if ((I.tag & a) === a) {
          var O = I.destroy;
          (I.destroy = void 0), O !== void 0 && xx(c, v, O);
        }
        I = I.next;
      } while (I !== M);
    }
  }
  function zg(a, c) {
    if (
      ((c = c.updateQueue), (c = c !== null ? c.lastEffect : null), c !== null)
    ) {
      var v = (c = c.next);
      do {
        if ((v.tag & a) === a) {
          var M = v.create;
          v.destroy = M();
        }
        v = v.next;
      } while (v !== c);
    }
  }
  function _x(a) {
    var c = a.ref;
    if (c !== null) {
      var v = a.stateNode;
      switch (a.tag) {
        case 5:
          a = v;
          break;
        default:
          a = v;
      }
      typeof c == "function" ? c(a) : (c.current = a);
    }
  }
  function tb(a) {
    var c = a.alternate;
    c !== null && ((a.alternate = null), tb(c)),
      (a.child = null),
      (a.deletions = null),
      (a.sibling = null),
      a.tag === 5 &&
        ((c = a.stateNode),
        c !== null &&
          (delete c[Lr],
          delete c[ou],
          delete c[al],
          delete c[ed],
          delete c[td])),
      (a.stateNode = null),
      (a.return = null),
      (a.dependencies = null),
      (a.memoizedProps = null),
      (a.memoizedState = null),
      (a.pendingProps = null),
      (a.stateNode = null),
      (a.updateQueue = null);
  }
  function nb(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function rb(a) {
    e: for (;;) {
      for (; a.sibling === null; ) {
        if (a.return === null || nb(a.return)) return null;
        a = a.return;
      }
      for (
        a.sibling.return = a.return, a = a.sibling;
        a.tag !== 5 && a.tag !== 6 && a.tag !== 18;

      ) {
        if (a.flags & 2 || a.child === null || a.tag === 4) continue e;
        (a.child.return = a), (a = a.child);
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Sx(a, c, v) {
    var M = a.tag;
    if (M === 5 || M === 6)
      (a = a.stateNode),
        c
          ? v.nodeType === 8
            ? v.parentNode.insertBefore(a, c)
            : v.insertBefore(a, c)
          : (v.nodeType === 8
              ? ((c = v.parentNode), c.insertBefore(a, v))
              : ((c = v), c.appendChild(a)),
            (v = v._reactRootContainer),
            v != null || c.onclick !== null || (c.onclick = sc));
    else if (M !== 4 && ((a = a.child), a !== null))
      for (Sx(a, c, v), a = a.sibling; a !== null; )
        Sx(a, c, v), (a = a.sibling);
  }
  function wx(a, c, v) {
    var M = a.tag;
    if (M === 5 || M === 6)
      (a = a.stateNode), c ? v.insertBefore(a, c) : v.appendChild(a);
    else if (M !== 4 && ((a = a.child), a !== null))
      for (wx(a, c, v), a = a.sibling; a !== null; )
        wx(a, c, v), (a = a.sibling);
  }
  var Pi = null,
    Zs = !1;
  function yu(a, c, v) {
    for (v = v.child; v !== null; ) ib(a, c, v), (v = v.sibling);
  }
  function ib(a, c, v) {
    if (wt && typeof wt.onCommitFiberUnmount == "function")
      try {
        wt.onCommitFiberUnmount(wn, v);
      } catch {}
    switch (v.tag) {
      case 5:
        ji || Sd(v, c);
      case 6:
        var M = Pi,
          I = Zs;
        (Pi = null),
          yu(a, c, v),
          (Pi = M),
          (Zs = I),
          Pi !== null &&
            (Zs
              ? ((a = Pi),
                (v = v.stateNode),
                a.nodeType === 8
                  ? a.parentNode.removeChild(v)
                  : a.removeChild(v))
              : Pi.removeChild(v.stateNode));
        break;
      case 18:
        Pi !== null &&
          (Zs
            ? ((a = Pi),
              (v = v.stateNode),
              a.nodeType === 8
                ? Qf(a.parentNode, v)
                : a.nodeType === 1 && Qf(a, v),
              ma(a))
            : Qf(Pi, v.stateNode));
        break;
      case 4:
        (M = Pi),
          (I = Zs),
          (Pi = v.stateNode.containerInfo),
          (Zs = !0),
          yu(a, c, v),
          (Pi = M),
          (Zs = I);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !ji &&
          ((M = v.updateQueue), M !== null && ((M = M.lastEffect), M !== null))
        ) {
          I = M = M.next;
          do {
            var O = I,
              Y = O.destroy;
            (O = O.tag),
              Y !== void 0 && ((O & 2) !== 0 || (O & 4) !== 0) && xx(v, c, Y),
              (I = I.next);
          } while (I !== M);
        }
        yu(a, c, v);
        break;
      case 1:
        if (
          !ji &&
          (Sd(v, c),
          (M = v.stateNode),
          typeof M.componentWillUnmount == "function")
        )
          try {
            (M.props = v.memoizedProps),
              (M.state = v.memoizedState),
              M.componentWillUnmount();
          } catch (pe) {
            wr(v, c, pe);
          }
        yu(a, c, v);
        break;
      case 21:
        yu(a, c, v);
        break;
      case 22:
        v.mode & 1
          ? ((ji = (M = ji) || v.memoizedState !== null), yu(a, c, v), (ji = M))
          : yu(a, c, v);
        break;
      default:
        yu(a, c, v);
    }
  }
  function ob(a) {
    var c = a.updateQueue;
    if (c !== null) {
      a.updateQueue = null;
      var v = a.stateNode;
      v === null && (v = a.stateNode = new GP()),
        c.forEach(function (M) {
          var I = QP.bind(null, a, M);
          v.has(M) || (v.add(M), M.then(I, I));
        });
    }
  }
  function Js(a, c) {
    var v = c.deletions;
    if (v !== null)
      for (var M = 0; M < v.length; M++) {
        var I = v[M];
        try {
          var O = a,
            Y = c,
            pe = Y;
          e: for (; pe !== null; ) {
            switch (pe.tag) {
              case 5:
                (Pi = pe.stateNode), (Zs = !1);
                break e;
              case 3:
                (Pi = pe.stateNode.containerInfo), (Zs = !0);
                break e;
              case 4:
                (Pi = pe.stateNode.containerInfo), (Zs = !0);
                break e;
            }
            pe = pe.return;
          }
          if (Pi === null) throw Error(t(160));
          ib(O, Y, I), (Pi = null), (Zs = !1);
          var ye = I.alternate;
          ye !== null && (ye.return = null), (I.return = null);
        } catch (je) {
          wr(I, c, je);
        }
      }
    if (c.subtreeFlags & 12854)
      for (c = c.child; c !== null; ) sb(c, a), (c = c.sibling);
  }
  function sb(a, c) {
    var v = a.alternate,
      M = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((Js(c, a), Da(a), M & 4)) {
          try {
            xp(3, a, a.return), zg(3, a);
          } catch (Lt) {
            wr(a, a.return, Lt);
          }
          try {
            xp(5, a, a.return);
          } catch (Lt) {
            wr(a, a.return, Lt);
          }
        }
        break;
      case 1:
        Js(c, a), Da(a), M & 512 && v !== null && Sd(v, v.return);
        break;
      case 5:
        if (
          (Js(c, a),
          Da(a),
          M & 512 && v !== null && Sd(v, v.return),
          a.flags & 32)
        ) {
          var I = a.stateNode;
          try {
            Ye(I, "");
          } catch (Lt) {
            wr(a, a.return, Lt);
          }
        }
        if (M & 4 && ((I = a.stateNode), I != null)) {
          var O = a.memoizedProps,
            Y = v !== null ? v.memoizedProps : O,
            pe = a.type,
            ye = a.updateQueue;
          if (((a.updateQueue = null), ye !== null))
            try {
              pe === "input" &&
                O.type === "radio" &&
                O.name != null &&
                Ie(I, O),
                Je(pe, Y);
              var je = Je(pe, O);
              for (Y = 0; Y < ye.length; Y += 2) {
                var st = ye[Y],
                  lt = ye[Y + 1];
                st === "style"
                  ? qe(I, lt)
                  : st === "dangerouslySetInnerHTML"
                  ? We(I, lt)
                  : st === "children"
                  ? Ye(I, lt)
                  : E(I, st, lt, je);
              }
              switch (pe) {
                case "input":
                  rt(I, O);
                  break;
                case "textarea":
                  _e(I, O);
                  break;
                case "select":
                  var ot = I._wrapperState.wasMultiple;
                  I._wrapperState.wasMultiple = !!O.multiple;
                  var Mt = O.value;
                  Mt != null
                    ? B(I, !!O.multiple, Mt, !1)
                    : ot !== !!O.multiple &&
                      (O.defaultValue != null
                        ? B(I, !!O.multiple, O.defaultValue, !0)
                        : B(I, !!O.multiple, O.multiple ? [] : "", !1));
              }
              I[ou] = O;
            } catch (Lt) {
              wr(a, a.return, Lt);
            }
        }
        break;
      case 6:
        if ((Js(c, a), Da(a), M & 4)) {
          if (a.stateNode === null) throw Error(t(162));
          (I = a.stateNode), (O = a.memoizedProps);
          try {
            I.nodeValue = O;
          } catch (Lt) {
            wr(a, a.return, Lt);
          }
        }
        break;
      case 3:
        if (
          (Js(c, a), Da(a), M & 4 && v !== null && v.memoizedState.isDehydrated)
        )
          try {
            ma(c.containerInfo);
          } catch (Lt) {
            wr(a, a.return, Lt);
          }
        break;
      case 4:
        Js(c, a), Da(a);
        break;
      case 13:
        Js(c, a),
          Da(a),
          (I = a.child),
          I.flags & 8192 &&
            ((O = I.memoizedState !== null),
            (I.stateNode.isHidden = O),
            !O ||
              (I.alternate !== null && I.alternate.memoizedState !== null) ||
              (Ex = Ke())),
          M & 4 && ob(a);
        break;
      case 22:
        if (
          ((st = v !== null && v.memoizedState !== null),
          a.mode & 1 ? ((ji = (je = ji) || st), Js(c, a), (ji = je)) : Js(c, a),
          Da(a),
          M & 8192)
        ) {
          if (
            ((je = a.memoizedState !== null),
            (a.stateNode.isHidden = je) && !st && (a.mode & 1) !== 0)
          )
            for (Ct = a, st = a.child; st !== null; ) {
              for (lt = Ct = st; Ct !== null; ) {
                switch (((ot = Ct), (Mt = ot.child), ot.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    xp(4, ot, ot.return);
                    break;
                  case 1:
                    Sd(ot, ot.return);
                    var Rt = ot.stateNode;
                    if (typeof Rt.componentWillUnmount == "function") {
                      (M = ot), (v = ot.return);
                      try {
                        (c = M),
                          (Rt.props = c.memoizedProps),
                          (Rt.state = c.memoizedState),
                          Rt.componentWillUnmount();
                      } catch (Lt) {
                        wr(M, v, Lt);
                      }
                    }
                    break;
                  case 5:
                    Sd(ot, ot.return);
                    break;
                  case 22:
                    if (ot.memoizedState !== null) {
                      ub(lt);
                      continue;
                    }
                }
                Mt !== null ? ((Mt.return = ot), (Ct = Mt)) : ub(lt);
              }
              st = st.sibling;
            }
          e: for (st = null, lt = a; ; ) {
            if (lt.tag === 5) {
              if (st === null) {
                st = lt;
                try {
                  (I = lt.stateNode),
                    je
                      ? ((O = I.style),
                        typeof O.setProperty == "function"
                          ? O.setProperty("display", "none", "important")
                          : (O.display = "none"))
                      : ((pe = lt.stateNode),
                        (ye = lt.memoizedProps.style),
                        (Y =
                          ye != null && ye.hasOwnProperty("display")
                            ? ye.display
                            : null),
                        (pe.style.display = $e("display", Y)));
                } catch (Lt) {
                  wr(a, a.return, Lt);
                }
              }
            } else if (lt.tag === 6) {
              if (st === null)
                try {
                  lt.stateNode.nodeValue = je ? "" : lt.memoizedProps;
                } catch (Lt) {
                  wr(a, a.return, Lt);
                }
            } else if (
              ((lt.tag !== 22 && lt.tag !== 23) ||
                lt.memoizedState === null ||
                lt === a) &&
              lt.child !== null
            ) {
              (lt.child.return = lt), (lt = lt.child);
              continue;
            }
            if (lt === a) break e;
            for (; lt.sibling === null; ) {
              if (lt.return === null || lt.return === a) break e;
              st === lt && (st = null), (lt = lt.return);
            }
            st === lt && (st = null),
              (lt.sibling.return = lt.return),
              (lt = lt.sibling);
          }
        }
        break;
      case 19:
        Js(c, a), Da(a), M & 4 && ob(a);
        break;
      case 21:
        break;
      default:
        Js(c, a), Da(a);
    }
  }
  function Da(a) {
    var c = a.flags;
    if (c & 2) {
      try {
        e: {
          for (var v = a.return; v !== null; ) {
            if (nb(v)) {
              var M = v;
              break e;
            }
            v = v.return;
          }
          throw Error(t(160));
        }
        switch (M.tag) {
          case 5:
            var I = M.stateNode;
            M.flags & 32 && (Ye(I, ""), (M.flags &= -33));
            var O = rb(a);
            wx(a, O, I);
            break;
          case 3:
          case 4:
            var Y = M.stateNode.containerInfo,
              pe = rb(a);
            Sx(a, pe, Y);
            break;
          default:
            throw Error(t(161));
        }
      } catch (ye) {
        wr(a, a.return, ye);
      }
      a.flags &= -3;
    }
    c & 4096 && (a.flags &= -4097);
  }
  function jP(a, c, v) {
    (Ct = a), ab(a);
  }
  function ab(a, c, v) {
    for (var M = (a.mode & 1) !== 0; Ct !== null; ) {
      var I = Ct,
        O = I.child;
      if (I.tag === 22 && M) {
        var Y = I.memoizedState !== null || Bg;
        if (!Y) {
          var pe = I.alternate,
            ye = (pe !== null && pe.memoizedState !== null) || ji;
          pe = Bg;
          var je = ji;
          if (((Bg = Y), (ji = ye) && !je))
            for (Ct = I; Ct !== null; )
              (Y = Ct),
                (ye = Y.child),
                Y.tag === 22 && Y.memoizedState !== null
                  ? cb(I)
                  : ye !== null
                  ? ((ye.return = Y), (Ct = ye))
                  : cb(I);
          for (; O !== null; ) (Ct = O), ab(O), (O = O.sibling);
          (Ct = I), (Bg = pe), (ji = je);
        }
        lb(a);
      } else
        (I.subtreeFlags & 8772) !== 0 && O !== null
          ? ((O.return = I), (Ct = O))
          : lb(a);
    }
  }
  function lb(a) {
    for (; Ct !== null; ) {
      var c = Ct;
      if ((c.flags & 8772) !== 0) {
        var v = c.alternate;
        try {
          if ((c.flags & 8772) !== 0)
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                ji || zg(5, c);
                break;
              case 1:
                var M = c.stateNode;
                if (c.flags & 4 && !ji)
                  if (v === null) M.componentDidMount();
                  else {
                    var I =
                      c.elementType === c.type
                        ? v.memoizedProps
                        : qo(c.type, v.memoizedProps);
                    M.componentDidUpdate(
                      I,
                      v.memoizedState,
                      M.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var O = c.updateQueue;
                O !== null && dr(c, O, M);
                break;
              case 3:
                var Y = c.updateQueue;
                if (Y !== null) {
                  if (((v = null), c.child !== null))
                    switch (c.child.tag) {
                      case 5:
                        v = c.child.stateNode;
                        break;
                      case 1:
                        v = c.child.stateNode;
                    }
                  dr(c, Y, v);
                }
                break;
              case 5:
                var pe = c.stateNode;
                if (v === null && c.flags & 4) {
                  v = pe;
                  var ye = c.memoizedProps;
                  switch (c.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ye.autoFocus && v.focus();
                      break;
                    case "img":
                      ye.src && (v.src = ye.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (c.memoizedState === null) {
                  var je = c.alternate;
                  if (je !== null) {
                    var st = je.memoizedState;
                    if (st !== null) {
                      var lt = st.dehydrated;
                      lt !== null && ma(lt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          ji || (c.flags & 512 && _x(c));
        } catch (ot) {
          wr(c, c.return, ot);
        }
      }
      if (c === a) {
        Ct = null;
        break;
      }
      if (((v = c.sibling), v !== null)) {
        (v.return = c.return), (Ct = v);
        break;
      }
      Ct = c.return;
    }
  }
  function ub(a) {
    for (; Ct !== null; ) {
      var c = Ct;
      if (c === a) {
        Ct = null;
        break;
      }
      var v = c.sibling;
      if (v !== null) {
        (v.return = c.return), (Ct = v);
        break;
      }
      Ct = c.return;
    }
  }
  function cb(a) {
    for (; Ct !== null; ) {
      var c = Ct;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var v = c.return;
            try {
              zg(4, c);
            } catch (ye) {
              wr(c, v, ye);
            }
            break;
          case 1:
            var M = c.stateNode;
            if (typeof M.componentDidMount == "function") {
              var I = c.return;
              try {
                M.componentDidMount();
              } catch (ye) {
                wr(c, I, ye);
              }
            }
            var O = c.return;
            try {
              _x(c);
            } catch (ye) {
              wr(c, O, ye);
            }
            break;
          case 5:
            var Y = c.return;
            try {
              _x(c);
            } catch (ye) {
              wr(c, Y, ye);
            }
        }
      } catch (ye) {
        wr(c, c.return, ye);
      }
      if (c === a) {
        Ct = null;
        break;
      }
      var pe = c.sibling;
      if (pe !== null) {
        (pe.return = c.return), (Ct = pe);
        break;
      }
      Ct = c.return;
    }
  }
  var $P = Math.ceil,
    Hg = A.ReactCurrentDispatcher,
    bx = A.ReactCurrentOwner,
    _s = A.ReactCurrentBatchConfig,
    gn = 0,
    vi = null,
    Qr = null,
    Ii = 0,
    Qo = 0,
    wd = ir(0),
    ui = 0,
    _p = null,
    Sc = 0,
    Vg = 0,
    Mx = 0,
    Sp = null,
    Lo = null,
    Ex = 0,
    bd = 1 / 0,
    yl = null,
    Gg = !1,
    Tx = null,
    xu = null,
    Wg = !1,
    _u = null,
    jg = 0,
    wp = 0,
    Cx = null,
    $g = -1,
    Xg = 0;
  function ho() {
    return (gn & 6) !== 0 ? Ke() : $g !== -1 ? $g : ($g = Ke());
  }
  function Su(a) {
    return (a.mode & 1) === 0
      ? 1
      : (gn & 2) !== 0 && Ii !== 0
      ? Ii & -Ii
      : mx.transition !== null
      ? (Xg === 0 && (Xg = di()), Xg)
      : ((a = ln),
        a !== 0 || ((a = window.event), (a = a === void 0 ? 16 : va(a.type))),
        a);
  }
  function Qs(a, c, v, M) {
    if (50 < wp) throw ((wp = 0), (Cx = null), Error(t(185)));
    Ho(a, v, M),
      ((gn & 2) === 0 || a !== vi) &&
        (a === vi && ((gn & 2) === 0 && (Vg |= v), ui === 4 && wu(a, Ii)),
        ko(a, M),
        v === 1 &&
          gn === 0 &&
          (c.mode & 1) === 0 &&
          ((bd = Ke() + 500), uc && ms()));
  }
  function ko(a, c) {
    var v = a.callbackNode;
    ur(a, c);
    var M = zr(a, a === vi ? Ii : 0);
    if (M === 0)
      v !== null && ut(v), (a.callbackNode = null), (a.callbackPriority = 0);
    else if (((c = M & -M), a.callbackPriority !== c)) {
      if ((v != null && ut(v), c === 1))
        a.tag === 0 ? Mg(db.bind(null, a)) : cc(db.bind(null, a)),
          px(function () {
            (gn & 6) === 0 && ms();
          }),
          (v = null);
      else {
        switch (us(M)) {
          case 1:
            v = Ft;
            break;
          case 4:
            v = At;
            break;
          case 16:
            v = nn;
            break;
          case 536870912:
            v = dn;
            break;
          default:
            v = nn;
        }
        v = _b(v, fb.bind(null, a));
      }
      (a.callbackPriority = c), (a.callbackNode = v);
    }
  }
  function fb(a, c) {
    if ((($g = -1), (Xg = 0), (gn & 6) !== 0)) throw Error(t(327));
    var v = a.callbackNode;
    if (Md() && a.callbackNode !== v) return null;
    var M = zr(a, a === vi ? Ii : 0);
    if (M === 0) return null;
    if ((M & 30) !== 0 || (M & a.expiredLanes) !== 0 || c) c = Yg(a, M);
    else {
      c = M;
      var I = gn;
      gn |= 2;
      var O = pb();
      (vi !== a || Ii !== c) && ((yl = null), (bd = Ke() + 500), bc(a, c));
      do
        try {
          qP();
          break;
        } catch (pe) {
          hb(a, pe);
        }
      while (!0);
      lu(),
        (Hg.current = O),
        (gn = I),
        Qr !== null ? (c = 0) : ((vi = null), (Ii = 0), (c = ui));
    }
    if (c !== 0) {
      if (
        (c === 2 && ((I = Rr(a)), I !== 0 && ((M = I), (c = Ax(a, I)))),
        c === 1)
      )
        throw ((v = _p), bc(a, 0), wu(a, M), ko(a, Ke()), v);
      if (c === 6) wu(a, M);
      else {
        if (
          ((I = a.current.alternate),
          (M & 30) === 0 &&
            !XP(I) &&
            ((c = Yg(a, M)),
            c === 2 && ((O = Rr(a)), O !== 0 && ((M = O), (c = Ax(a, O)))),
            c === 1))
        )
          throw ((v = _p), bc(a, 0), wu(a, M), ko(a, Ke()), v);
        switch (((a.finishedWork = I), (a.finishedLanes = M), c)) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            Mc(a, Lo, yl);
            break;
          case 3:
            if (
              (wu(a, M),
              (M & 130023424) === M && ((c = Ex + 500 - Ke()), 10 < c))
            ) {
              if (zr(a, 0) !== 0) break;
              if (((I = a.suspendedLanes), (I & M) !== M)) {
                ho(), (a.pingedLanes |= a.suspendedLanes & I);
                break;
              }
              a.timeoutHandle = np(Mc.bind(null, a, Lo, yl), c);
              break;
            }
            Mc(a, Lo, yl);
            break;
          case 4:
            if ((wu(a, M), (M & 4194240) === M)) break;
            for (c = a.eventTimes, I = -1; 0 < M; ) {
              var Y = 31 - Qt(M);
              (O = 1 << Y), (Y = c[Y]), Y > I && (I = Y), (M &= ~O);
            }
            if (
              ((M = I),
              (M = Ke() - M),
              (M =
                (120 > M
                  ? 120
                  : 480 > M
                  ? 480
                  : 1080 > M
                  ? 1080
                  : 1920 > M
                  ? 1920
                  : 3e3 > M
                  ? 3e3
                  : 4320 > M
                  ? 4320
                  : 1960 * $P(M / 1960)) - M),
              10 < M)
            ) {
              a.timeoutHandle = np(Mc.bind(null, a, Lo, yl), M);
              break;
            }
            Mc(a, Lo, yl);
            break;
          case 5:
            Mc(a, Lo, yl);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return ko(a, Ke()), a.callbackNode === v ? fb.bind(null, a) : null;
  }
  function Ax(a, c) {
    var v = Sp;
    return (
      a.current.memoizedState.isDehydrated && (bc(a, c).flags |= 256),
      (a = Yg(a, c)),
      a !== 2 && ((c = Lo), (Lo = v), c !== null && Rx(c)),
      a
    );
  }
  function Rx(a) {
    Lo === null ? (Lo = a) : Lo.push.apply(Lo, a);
  }
  function XP(a) {
    for (var c = a; ; ) {
      if (c.flags & 16384) {
        var v = c.updateQueue;
        if (v !== null && ((v = v.stores), v !== null))
          for (var M = 0; M < v.length; M++) {
            var I = v[M],
              O = I.getSnapshot;
            I = I.value;
            try {
              if (!so(O(), I)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((v = c.child), c.subtreeFlags & 16384 && v !== null))
        (v.return = c), (c = v);
      else {
        if (c === a) break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === a) return !0;
          c = c.return;
        }
        (c.sibling.return = c.return), (c = c.sibling);
      }
    }
    return !0;
  }
  function wu(a, c) {
    for (
      c &= ~Mx,
        c &= ~Vg,
        a.suspendedLanes |= c,
        a.pingedLanes &= ~c,
        a = a.expirationTimes;
      0 < c;

    ) {
      var v = 31 - Qt(c),
        M = 1 << v;
      (a[v] = -1), (c &= ~M);
    }
  }
  function db(a) {
    if ((gn & 6) !== 0) throw Error(t(327));
    Md();
    var c = zr(a, 0);
    if ((c & 1) === 0) return ko(a, Ke()), null;
    var v = Yg(a, c);
    if (a.tag !== 0 && v === 2) {
      var M = Rr(a);
      M !== 0 && ((c = M), (v = Ax(a, M)));
    }
    if (v === 1) throw ((v = _p), bc(a, 0), wu(a, c), ko(a, Ke()), v);
    if (v === 6) throw Error(t(345));
    return (
      (a.finishedWork = a.current.alternate),
      (a.finishedLanes = c),
      Mc(a, Lo, yl),
      ko(a, Ke()),
      null
    );
  }
  function Px(a, c) {
    var v = gn;
    gn |= 1;
    try {
      return a(c);
    } finally {
      (gn = v), gn === 0 && ((bd = Ke() + 500), uc && ms());
    }
  }
  function wc(a) {
    _u !== null && _u.tag === 0 && (gn & 6) === 0 && Md();
    var c = gn;
    gn |= 1;
    var v = _s.transition,
      M = ln;
    try {
      if (((_s.transition = null), (ln = 1), a)) return a();
    } finally {
      (ln = M), (_s.transition = v), (gn = c), (gn & 6) === 0 && ms();
    }
  }
  function Ix() {
    (Qo = wd.current), zn(wd);
  }
  function bc(a, c) {
    (a.finishedWork = null), (a.finishedLanes = 0);
    var v = a.timeoutHandle;
    if ((v !== -1 && ((a.timeoutHandle = -1), rp(v)), Qr !== null))
      for (v = Qr.return; v !== null; ) {
        var M = v;
        switch (($s(M), M.tag)) {
          case 1:
            (M = M.type.childContextTypes), M != null && ac();
            break;
          case 3:
            vs(), zn(bi), zn(ai), Gi();
            break;
          case 5:
            pu(M);
            break;
          case 4:
            vs();
            break;
          case 13:
            zn(Hn);
            break;
          case 19:
            zn(Hn);
            break;
          case 10:
            uu(M.type._context);
            break;
          case 22:
          case 23:
            Ix();
        }
        v = v.return;
      }
    if (
      ((vi = a),
      (Qr = a = bu(a.current, null)),
      (Ii = Qo = c),
      (ui = 0),
      (_p = null),
      (Mx = Vg = Sc = 0),
      (Lo = Sp = null),
      Ko !== null)
    ) {
      for (c = 0; c < Ko.length; c++)
        if (((v = Ko[c]), (M = v.interleaved), M !== null)) {
          v.interleaved = null;
          var I = M.next,
            O = v.pending;
          if (O !== null) {
            var Y = O.next;
            (O.next = I), (M.next = Y);
          }
          v.pending = M;
        }
      Ko = null;
    }
    return a;
  }
  function hb(a, c) {
    do {
      var v = Qr;
      try {
        if ((lu(), (gl.current = d), Jo)) {
          for (var M = $n.memoizedState; M !== null; ) {
            var I = M.queue;
            I !== null && (I.pending = null), (M = M.next);
          }
          Jo = !1;
        }
        if (
          ((Pa = 0),
          (Jr = hr = $n = null),
          (mu = !1),
          (gu = 0),
          (bx.current = null),
          v === null || v.return === null)
        ) {
          (ui = 1), (_p = c), (Qr = null);
          break;
        }
        e: {
          var O = a,
            Y = v.return,
            pe = v,
            ye = c;
          if (
            ((c = Ii),
            (pe.flags |= 32768),
            ye !== null &&
              typeof ye == "object" &&
              typeof ye.then == "function")
          ) {
            var je = ye,
              st = pe,
              lt = st.tag;
            if ((st.mode & 1) === 0 && (lt === 0 || lt === 11 || lt === 15)) {
              var ot = st.alternate;
              ot
                ? ((st.updateQueue = ot.updateQueue),
                  (st.memoizedState = ot.memoizedState),
                  (st.lanes = ot.lanes))
                : ((st.updateQueue = null), (st.memoizedState = null));
            }
            var Mt = Kt(Y);
            if (Mt !== null) {
              (Mt.flags &= -257),
                Bt(Mt, Y, pe, O, c),
                Mt.mode & 1 && Tt(O, je, c),
                (c = Mt),
                (ye = je);
              var Rt = c.updateQueue;
              if (Rt === null) {
                var Lt = new Set();
                Lt.add(ye), (c.updateQueue = Lt);
              } else Rt.add(ye);
              break e;
            } else {
              if ((c & 1) === 0) {
                Tt(O, je, c), Lx();
                break e;
              }
              ye = Error(t(426));
            }
          } else if (jn && pe.mode & 1) {
            var Dr = Kt(Y);
            if (Dr !== null) {
              (Dr.flags & 65536) === 0 && (Dr.flags |= 256),
                Bt(Dr, Y, pe, O, c),
                au(D(ye, pe));
              break e;
            }
          }
          (O = ye = D(ye, pe)),
            ui !== 4 && (ui = 2),
            Sp === null ? (Sp = [O]) : Sp.push(O),
            (O = Y);
          do {
            switch (O.tag) {
              case 3:
                (O.flags |= 65536), (c &= -c), (O.lanes |= c);
                var De = Qe(O, ye, c);
                rn(O, De);
                break e;
              case 1:
                pe = ye;
                var be = O.type,
                  Oe = O.stateNode;
                if (
                  (O.flags & 128) === 0 &&
                  (typeof be.getDerivedStateFromError == "function" ||
                    (Oe !== null &&
                      typeof Oe.componentDidCatch == "function" &&
                      (xu === null || !xu.has(Oe))))
                ) {
                  (O.flags |= 65536), (c &= -c), (O.lanes |= c);
                  var ft = ct(O, pe, c);
                  rn(O, ft);
                  break e;
                }
            }
            O = O.return;
          } while (O !== null);
        }
        gb(v);
      } catch (Nt) {
        (c = Nt), Qr === v && v !== null && (Qr = v = v.return);
        continue;
      }
      break;
    } while (!0);
  }
  function pb() {
    var a = Hg.current;
    return (Hg.current = d), a === null ? d : a;
  }
  function Lx() {
    (ui === 0 || ui === 3 || ui === 2) && (ui = 4),
      vi === null ||
        ((Sc & 268435455) === 0 && (Vg & 268435455) === 0) ||
        wu(vi, Ii);
  }
  function Yg(a, c) {
    var v = gn;
    gn |= 2;
    var M = pb();
    (vi !== a || Ii !== c) && ((yl = null), bc(a, c));
    do
      try {
        YP();
        break;
      } catch (I) {
        hb(a, I);
      }
    while (!0);
    if ((lu(), (gn = v), (Hg.current = M), Qr !== null)) throw Error(t(261));
    return (vi = null), (Ii = 0), ui;
  }
  function YP() {
    for (; Qr !== null; ) mb(Qr);
  }
  function qP() {
    for (; Qr !== null && !vt(); ) mb(Qr);
  }
  function mb(a) {
    var c = xb(a.alternate, a, Qo);
    (a.memoizedProps = a.pendingProps),
      c === null ? gb(a) : (Qr = c),
      (bx.current = null);
  }
  function gb(a) {
    var c = a;
    do {
      var v = c.alternate;
      if (((a = c.return), (c.flags & 32768) === 0)) {
        if (((v = HP(v, c, Qo)), v !== null)) {
          Qr = v;
          return;
        }
      } else {
        if (((v = VP(v, c)), v !== null)) {
          (v.flags &= 32767), (Qr = v);
          return;
        }
        if (a !== null)
          (a.flags |= 32768), (a.subtreeFlags = 0), (a.deletions = null);
        else {
          (ui = 6), (Qr = null);
          return;
        }
      }
      if (((c = c.sibling), c !== null)) {
        Qr = c;
        return;
      }
      Qr = c = a;
    } while (c !== null);
    ui === 0 && (ui = 5);
  }
  function Mc(a, c, v) {
    var M = ln,
      I = _s.transition;
    try {
      (_s.transition = null), (ln = 1), KP(a, c, v, M);
    } finally {
      (_s.transition = I), (ln = M);
    }
    return null;
  }
  function KP(a, c, v, M) {
    do Md();
    while (_u !== null);
    if ((gn & 6) !== 0) throw Error(t(327));
    v = a.finishedWork;
    var I = a.finishedLanes;
    if (v === null) return null;
    if (((a.finishedWork = null), (a.finishedLanes = 0), v === a.current))
      throw Error(t(177));
    (a.callbackNode = null), (a.callbackPriority = 0);
    var O = v.lanes | v.childLanes;
    if (
      (Pf(a, O),
      a === vi && ((Qr = vi = null), (Ii = 0)),
      ((v.subtreeFlags & 2064) === 0 && (v.flags & 2064) === 0) ||
        Wg ||
        ((Wg = !0),
        _b(nn, function () {
          return Md(), null;
        })),
      (O = (v.flags & 15990) !== 0),
      (v.subtreeFlags & 15990) !== 0 || O)
    ) {
      (O = _s.transition), (_s.transition = null);
      var Y = ln;
      ln = 1;
      var pe = gn;
      (gn |= 4),
        (bx.current = null),
        WP(a, v),
        sb(v, a),
        $r(ep),
        (Vr = !!iu),
        (ep = iu = null),
        (a.current = v),
        jP(v),
        Et(),
        (gn = pe),
        (ln = Y),
        (_s.transition = O);
    } else a.current = v;
    if (
      (Wg && ((Wg = !1), (_u = a), (jg = I)),
      (O = a.pendingLanes),
      O === 0 && (xu = null),
      dt(v.stateNode),
      ko(a, Ke()),
      c !== null)
    )
      for (M = a.onRecoverableError, v = 0; v < c.length; v++)
        (I = c[v]), M(I.value, { componentStack: I.stack, digest: I.digest });
    if (Gg) throw ((Gg = !1), (a = Tx), (Tx = null), a);
    return (
      (jg & 1) !== 0 && a.tag !== 0 && Md(),
      (O = a.pendingLanes),
      (O & 1) !== 0 ? (a === Cx ? wp++ : ((wp = 0), (Cx = a))) : (wp = 0),
      ms(),
      null
    );
  }
  function Md() {
    if (_u !== null) {
      var a = us(jg),
        c = _s.transition,
        v = ln;
      try {
        if (((_s.transition = null), (ln = 16 > a ? 16 : a), _u === null))
          var M = !1;
        else {
          if (((a = _u), (_u = null), (jg = 0), (gn & 6) !== 0))
            throw Error(t(331));
          var I = gn;
          for (gn |= 4, Ct = a.current; Ct !== null; ) {
            var O = Ct,
              Y = O.child;
            if ((Ct.flags & 16) !== 0) {
              var pe = O.deletions;
              if (pe !== null) {
                for (var ye = 0; ye < pe.length; ye++) {
                  var je = pe[ye];
                  for (Ct = je; Ct !== null; ) {
                    var st = Ct;
                    switch (st.tag) {
                      case 0:
                      case 11:
                      case 15:
                        xp(8, st, O);
                    }
                    var lt = st.child;
                    if (lt !== null) (lt.return = st), (Ct = lt);
                    else
                      for (; Ct !== null; ) {
                        st = Ct;
                        var ot = st.sibling,
                          Mt = st.return;
                        if ((tb(st), st === je)) {
                          Ct = null;
                          break;
                        }
                        if (ot !== null) {
                          (ot.return = Mt), (Ct = ot);
                          break;
                        }
                        Ct = Mt;
                      }
                  }
                }
                var Rt = O.alternate;
                if (Rt !== null) {
                  var Lt = Rt.child;
                  if (Lt !== null) {
                    Rt.child = null;
                    do {
                      var Dr = Lt.sibling;
                      (Lt.sibling = null), (Lt = Dr);
                    } while (Lt !== null);
                  }
                }
                Ct = O;
              }
            }
            if ((O.subtreeFlags & 2064) !== 0 && Y !== null)
              (Y.return = O), (Ct = Y);
            else
              e: for (; Ct !== null; ) {
                if (((O = Ct), (O.flags & 2048) !== 0))
                  switch (O.tag) {
                    case 0:
                    case 11:
                    case 15:
                      xp(9, O, O.return);
                  }
                var De = O.sibling;
                if (De !== null) {
                  (De.return = O.return), (Ct = De);
                  break e;
                }
                Ct = O.return;
              }
          }
          var be = a.current;
          for (Ct = be; Ct !== null; ) {
            Y = Ct;
            var Oe = Y.child;
            if ((Y.subtreeFlags & 2064) !== 0 && Oe !== null)
              (Oe.return = Y), (Ct = Oe);
            else
              e: for (Y = be; Ct !== null; ) {
                if (((pe = Ct), (pe.flags & 2048) !== 0))
                  try {
                    switch (pe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        zg(9, pe);
                    }
                  } catch (Nt) {
                    wr(pe, pe.return, Nt);
                  }
                if (pe === Y) {
                  Ct = null;
                  break e;
                }
                var ft = pe.sibling;
                if (ft !== null) {
                  (ft.return = pe.return), (Ct = ft);
                  break e;
                }
                Ct = pe.return;
              }
          }
          if (
            ((gn = I),
            ms(),
            wt && typeof wt.onPostCommitFiberRoot == "function")
          )
            try {
              wt.onPostCommitFiberRoot(wn, a);
            } catch {}
          M = !0;
        }
        return M;
      } finally {
        (ln = v), (_s.transition = c);
      }
    }
    return !1;
  }
  function vb(a, c, v) {
    (c = D(v, c)),
      (c = Qe(a, c, 1)),
      (a = gs(a, c, 1)),
      (c = ho()),
      a !== null && (Ho(a, 1, c), ko(a, c));
  }
  function wr(a, c, v) {
    if (a.tag === 3) vb(a, a, v);
    else
      for (; c !== null; ) {
        if (c.tag === 3) {
          vb(c, a, v);
          break;
        } else if (c.tag === 1) {
          var M = c.stateNode;
          if (
            typeof c.type.getDerivedStateFromError == "function" ||
            (typeof M.componentDidCatch == "function" &&
              (xu === null || !xu.has(M)))
          ) {
            (a = D(v, a)),
              (a = ct(c, a, 1)),
              (c = gs(c, a, 1)),
              (a = ho()),
              c !== null && (Ho(c, 1, a), ko(c, a));
            break;
          }
        }
        c = c.return;
      }
  }
  function ZP(a, c, v) {
    var M = a.pingCache;
    M !== null && M.delete(c),
      (c = ho()),
      (a.pingedLanes |= a.suspendedLanes & v),
      vi === a &&
        (Ii & v) === v &&
        (ui === 4 || (ui === 3 && (Ii & 130023424) === Ii && 500 > Ke() - Ex)
          ? bc(a, 0)
          : (Mx |= v)),
      ko(a, c);
  }
  function yb(a, c) {
    c === 0 &&
      ((a.mode & 1) === 0
        ? (c = 1)
        : ((c = Wn), (Wn <<= 1), (Wn & 130023424) === 0 && (Wn = 4194304)));
    var v = ho();
    (a = Zo(a, c)), a !== null && (Ho(a, c, v), ko(a, v));
  }
  function JP(a) {
    var c = a.memoizedState,
      v = 0;
    c !== null && (v = c.retryLane), yb(a, v);
  }
  function QP(a, c) {
    var v = 0;
    switch (a.tag) {
      case 13:
        var M = a.stateNode,
          I = a.memoizedState;
        I !== null && (v = I.retryLane);
        break;
      case 19:
        M = a.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    M !== null && M.delete(c), yb(a, v);
  }
  var xb;
  xb = function (a, c, v) {
    if (a !== null)
      if (a.memoizedProps !== c.pendingProps || bi.current) bt = !0;
      else {
        if ((a.lanes & v) === 0 && (c.flags & 128) === 0)
          return (bt = !1), zP(a, c, v);
        bt = (a.flags & 131072) !== 0;
      }
    else (bt = !1), jn && (c.flags & 1048576) !== 0 && lp(c, od, c.index);
    switch (((c.lanes = 0), c.tag)) {
      case 2:
        var M = c.type;
        Fg(a, c), (a = c.pendingProps);
        var I = ll(c, ai.current);
        Xs(c, v), (I = pd(null, c, M, a, I, v));
        var O = mc();
        return (
          (c.flags |= 1),
          typeof I == "object" &&
          I !== null &&
          typeof I.render == "function" &&
          I.$$typeof === void 0
            ? ((c.tag = 1),
              (c.memoizedState = null),
              (c.updateQueue = null),
              mi(M) ? ((O = !0), ul(c)) : (O = !1),
              (c.memoizedState =
                I.state !== null && I.state !== void 0 ? I.state : null),
              pc(c),
              (I.updater = qs),
              (c.stateNode = I),
              (I._reactInternals = c),
              du(c, M, a, v),
              (c = Yt(null, c, M, !0, O, v)))
            : ((c.tag = 0), jn && O && up(c), Mn(null, c, I, v), (c = c.child)),
          c
        );
      case 16:
        M = c.elementType;
        e: {
          switch (
            (Fg(a, c),
            (a = c.pendingProps),
            (I = M._init),
            (M = I(M._payload)),
            (c.type = M),
            (I = c.tag = t3(M)),
            (a = qo(M, a)),
            I)
          ) {
            case 0:
              c = It(null, c, M, a, v);
              break e;
            case 1:
              c = en(null, c, M, a, v);
              break e;
            case 11:
              c = fo(null, c, M, a, v);
              break e;
            case 14:
              c = He(null, c, M, qo(M.type, a), v);
              break e;
          }
          throw Error(t(306, M, ""));
        }
        return c;
      case 0:
        return (
          (M = c.type),
          (I = c.pendingProps),
          (I = c.elementType === M ? I : qo(M, I)),
          It(a, c, M, I, v)
        );
      case 1:
        return (
          (M = c.type),
          (I = c.pendingProps),
          (I = c.elementType === M ? I : qo(M, I)),
          en(a, c, M, I, v)
        );
      case 3:
        e: {
          if ((pn(c), a === null)) throw Error(t(387));
          (M = c.pendingProps),
            (O = c.memoizedState),
            (I = O.element),
            Eg(a, c),
            rr(c, M, null, v);
          var Y = c.memoizedState;
          if (((M = Y.element), O.isDehydrated))
            if (
              ((O = {
                element: M,
                isDehydrated: !1,
                cache: Y.cache,
                pendingSuspenseBoundaries: Y.pendingSuspenseBoundaries,
                transitions: Y.transitions,
              }),
              (c.updateQueue.baseState = O),
              (c.memoizedState = O),
              c.flags & 256)
            ) {
              (I = D(Error(t(423)), c)), (c = kr(a, c, M, v, I));
              break e;
            } else if (M !== I) {
              (I = D(Error(t(424)), c)), (c = kr(a, c, M, v, I));
              break e;
            } else
              for (
                Ei = Hs(c.stateNode.containerInfo.firstChild),
                  li = c,
                  jn = !0,
                  Co = null,
                  v = ml(c, null, M, v),
                  c.child = v;
                v;

              )
                (v.flags = (v.flags & -3) | 4096), (v = v.sibling);
          else {
            if ((Ea(), M === I)) {
              c = vl(a, c, v);
              break e;
            }
            Mn(a, c, M, v);
          }
          c = c.child;
        }
        return c;
      case 5:
        return (
          dd(c),
          a === null && ad(c),
          (M = c.type),
          (I = c.pendingProps),
          (O = a !== null ? a.memoizedProps : null),
          (Y = I.children),
          tp(M, I) ? (Y = null) : O !== null && tp(M, O) && (c.flags |= 32),
          _t(a, c),
          Mn(a, c, Y, v),
          c.child
        );
      case 6:
        return a === null && ad(c), null;
      case 13:
        return Og(a, c, v);
      case 4:
        return (
          hu(c, c.stateNode.containerInfo),
          (M = c.pendingProps),
          a === null ? (c.child = Ca(c, null, M, v)) : Mn(a, c, M, v),
          c.child
        );
      case 11:
        return (
          (M = c.type),
          (I = c.pendingProps),
          (I = c.elementType === M ? I : qo(M, I)),
          fo(a, c, M, I, v)
        );
      case 7:
        return Mn(a, c, c.pendingProps, v), c.child;
      case 8:
        return Mn(a, c, c.pendingProps.children, v), c.child;
      case 12:
        return Mn(a, c, c.pendingProps.children, v), c.child;
      case 10:
        e: {
          if (
            ((M = c.type._context),
            (I = c.pendingProps),
            (O = c.memoizedProps),
            (Y = I.value),
            Nn(fc, M._currentValue),
            (M._currentValue = Y),
            O !== null)
          )
            if (so(O.value, Y)) {
              if (O.children === I.children && !bi.current) {
                c = vl(a, c, v);
                break e;
              }
            } else
              for (O = c.child, O !== null && (O.return = c); O !== null; ) {
                var pe = O.dependencies;
                if (pe !== null) {
                  Y = O.child;
                  for (var ye = pe.firstContext; ye !== null; ) {
                    if (ye.context === M) {
                      if (O.tag === 1) {
                        (ye = Ao(-1, v & -v)), (ye.tag = 2);
                        var je = O.updateQueue;
                        if (je !== null) {
                          je = je.shared;
                          var st = je.pending;
                          st === null
                            ? (ye.next = ye)
                            : ((ye.next = st.next), (st.next = ye)),
                            (je.pending = ye);
                        }
                      }
                      (O.lanes |= v),
                        (ye = O.alternate),
                        ye !== null && (ye.lanes |= v),
                        cu(O.return, v, c),
                        (pe.lanes |= v);
                      break;
                    }
                    ye = ye.next;
                  }
                } else if (O.tag === 10) Y = O.type === c.type ? null : O.child;
                else if (O.tag === 18) {
                  if (((Y = O.return), Y === null)) throw Error(t(341));
                  (Y.lanes |= v),
                    (pe = Y.alternate),
                    pe !== null && (pe.lanes |= v),
                    cu(Y, v, c),
                    (Y = O.sibling);
                } else Y = O.child;
                if (Y !== null) Y.return = O;
                else
                  for (Y = O; Y !== null; ) {
                    if (Y === c) {
                      Y = null;
                      break;
                    }
                    if (((O = Y.sibling), O !== null)) {
                      (O.return = Y.return), (Y = O);
                      break;
                    }
                    Y = Y.return;
                  }
                O = Y;
              }
          Mn(a, c, I.children, v), (c = c.child);
        }
        return c;
      case 9:
        return (
          (I = c.type),
          (M = c.pendingProps.children),
          Xs(c, v),
          (I = Ti(I)),
          (M = M(I)),
          (c.flags |= 1),
          Mn(a, c, M, v),
          c.child
        );
      case 14:
        return (
          (M = c.type),
          (I = qo(M, c.pendingProps)),
          (I = qo(M.type, I)),
          He(a, c, M, I, v)
        );
      case 15:
        return Pe(a, c, c.type, c.pendingProps, v);
      case 17:
        return (
          (M = c.type),
          (I = c.pendingProps),
          (I = c.elementType === M ? I : qo(M, I)),
          Fg(a, c),
          (c.tag = 1),
          mi(M) ? ((a = !0), ul(c)) : (a = !1),
          Xs(c, v),
          fu(c, M, I),
          du(c, M, I, v),
          Yt(null, c, M, !0, a, v)
        );
      case 19:
        return Kw(a, c, v);
      case 22:
        return Ze(a, c, v);
    }
    throw Error(t(156, c.tag));
  };
  function _b(a, c) {
    return Le(a, c);
  }
  function e3(a, c, v, M) {
    (this.tag = a),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = c),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = M),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Ss(a, c, v, M) {
    return new e3(a, c, v, M);
  }
  function kx(a) {
    return (a = a.prototype), !(!a || !a.isReactComponent);
  }
  function t3(a) {
    if (typeof a == "function") return kx(a) ? 1 : 0;
    if (a != null) {
      if (((a = a.$$typeof), a === G)) return 11;
      if (a === Z) return 14;
    }
    return 2;
  }
  function bu(a, c) {
    var v = a.alternate;
    return (
      v === null
        ? ((v = Ss(a.tag, c, a.key, a.mode)),
          (v.elementType = a.elementType),
          (v.type = a.type),
          (v.stateNode = a.stateNode),
          (v.alternate = a),
          (a.alternate = v))
        : ((v.pendingProps = c),
          (v.type = a.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = a.flags & 14680064),
      (v.childLanes = a.childLanes),
      (v.lanes = a.lanes),
      (v.child = a.child),
      (v.memoizedProps = a.memoizedProps),
      (v.memoizedState = a.memoizedState),
      (v.updateQueue = a.updateQueue),
      (c = a.dependencies),
      (v.dependencies =
        c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }),
      (v.sibling = a.sibling),
      (v.index = a.index),
      (v.ref = a.ref),
      v
    );
  }
  function qg(a, c, v, M, I, O) {
    var Y = 2;
    if (((M = a), typeof a == "function")) kx(a) && (Y = 1);
    else if (typeof a == "string") Y = 5;
    else
      e: switch (a) {
        case P:
          return Ec(v.children, I, O, c);
        case U:
          (Y = 8), (I |= 8);
          break;
        case N:
          return (
            (a = Ss(12, v, c, I | 2)), (a.elementType = N), (a.lanes = O), a
          );
        case $:
          return (a = Ss(13, v, c, I)), (a.elementType = $), (a.lanes = O), a;
        case q:
          return (a = Ss(19, v, c, I)), (a.elementType = q), (a.lanes = O), a;
        case re:
          return Kg(v, I, O, c);
        default:
          if (typeof a == "object" && a !== null)
            switch (a.$$typeof) {
              case L:
                Y = 10;
                break e;
              case H:
                Y = 9;
                break e;
              case G:
                Y = 11;
                break e;
              case Z:
                Y = 14;
                break e;
              case X:
                (Y = 16), (M = null);
                break e;
            }
          throw Error(t(130, a == null ? a : typeof a, ""));
      }
    return (
      (c = Ss(Y, v, c, I)), (c.elementType = a), (c.type = M), (c.lanes = O), c
    );
  }
  function Ec(a, c, v, M) {
    return (a = Ss(7, a, M, c)), (a.lanes = v), a;
  }
  function Kg(a, c, v, M) {
    return (
      (a = Ss(22, a, M, c)),
      (a.elementType = re),
      (a.lanes = v),
      (a.stateNode = { isHidden: !1 }),
      a
    );
  }
  function Dx(a, c, v) {
    return (a = Ss(6, a, null, c)), (a.lanes = v), a;
  }
  function Nx(a, c, v) {
    return (
      (c = Ss(4, a.children !== null ? a.children : [], a.key, c)),
      (c.lanes = v),
      (c.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        implementation: a.implementation,
      }),
      c
    );
  }
  function n3(a, c, v, M, I) {
    (this.tag = c),
      (this.containerInfo = a),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = zo(0)),
      (this.expirationTimes = zo(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = zo(0)),
      (this.identifierPrefix = M),
      (this.onRecoverableError = I),
      (this.mutableSourceEagerHydrationData = null);
  }
  function Ox(a, c, v, M, I, O, Y, pe, ye) {
    return (
      (a = new n3(a, c, v, pe, ye)),
      c === 1 ? ((c = 1), O === !0 && (c |= 8)) : (c = 0),
      (O = Ss(3, null, null, c)),
      (a.current = O),
      (O.stateNode = a),
      (O.memoizedState = {
        element: M,
        isDehydrated: v,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      pc(O),
      a
    );
  }
  function r3(a, c, v) {
    var M =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: k,
      key: M == null ? null : "" + M,
      children: a,
      containerInfo: c,
      implementation: v,
    };
  }
  function Sb(a) {
    if (!a) return Gs;
    a = a._reactInternals;
    e: {
      if (no(a) !== a || a.tag !== 1) throw Error(t(170));
      var c = a;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (mi(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(t(171));
    }
    if (a.tag === 1) {
      var v = a.type;
      if (mi(v)) return lc(a, v, c);
    }
    return c;
  }
  function wb(a, c, v, M, I, O, Y, pe, ye) {
    return (
      (a = Ox(v, M, !0, a, I, O, Y, pe, ye)),
      (a.context = Sb(null)),
      (v = a.current),
      (M = ho()),
      (I = Su(v)),
      (O = Ao(M, I)),
      (O.callback = c ?? null),
      gs(v, O, I),
      (a.current.lanes = I),
      Ho(a, I, M),
      ko(a, M),
      a
    );
  }
  function Zg(a, c, v, M) {
    var I = c.current,
      O = ho(),
      Y = Su(I);
    return (
      (v = Sb(v)),
      c.context === null ? (c.context = v) : (c.pendingContext = v),
      (c = Ao(O, Y)),
      (c.payload = { element: a }),
      (M = M === void 0 ? null : M),
      M !== null && (c.callback = M),
      (a = gs(I, c, Y)),
      a !== null && (Qs(a, I, Y, O), Kn(a, I, Y)),
      Y
    );
  }
  function Jg(a) {
    if (((a = a.current), !a.child)) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function bb(a, c) {
    if (((a = a.memoizedState), a !== null && a.dehydrated !== null)) {
      var v = a.retryLane;
      a.retryLane = v !== 0 && v < c ? v : c;
    }
  }
  function Ux(a, c) {
    bb(a, c), (a = a.alternate) && bb(a, c);
  }
  function i3() {
    return null;
  }
  var Mb =
    typeof reportError == "function"
      ? reportError
      : function (a) {
          console.error(a);
        };
  function Fx(a) {
    this._internalRoot = a;
  }
  (Qg.prototype.render = Fx.prototype.render =
    function (a) {
      var c = this._internalRoot;
      if (c === null) throw Error(t(409));
      Zg(a, c, null, null);
    }),
    (Qg.prototype.unmount = Fx.prototype.unmount =
      function () {
        var a = this._internalRoot;
        if (a !== null) {
          this._internalRoot = null;
          var c = a.containerInfo;
          wc(function () {
            Zg(null, a, null, null);
          }),
            (c[lo] = null);
        }
      });
  function Qg(a) {
    this._internalRoot = a;
  }
  Qg.prototype.unstable_scheduleHydration = function (a) {
    if (a) {
      var c = cs();
      a = { blockedOn: null, target: a, priority: c };
      for (var v = 0; v < So.length && c !== 0 && c < So[v].priority; v++);
      So.splice(v, 0, a), v === 0 && hi(a);
    }
  };
  function Bx(a) {
    return !(!a || (a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11));
  }
  function ev(a) {
    return !(
      !a ||
      (a.nodeType !== 1 &&
        a.nodeType !== 9 &&
        a.nodeType !== 11 &&
        (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function Eb() {}
  function o3(a, c, v, M, I) {
    if (I) {
      if (typeof M == "function") {
        var O = M;
        M = function () {
          var je = Jg(Y);
          O.call(je);
        };
      }
      var Y = wb(c, M, a, 0, null, !1, !1, "", Eb);
      return (
        (a._reactRootContainer = Y),
        (a[lo] = Y.current),
        nu(a.nodeType === 8 ? a.parentNode : a),
        wc(),
        Y
      );
    }
    for (; (I = a.lastChild); ) a.removeChild(I);
    if (typeof M == "function") {
      var pe = M;
      M = function () {
        var je = Jg(ye);
        pe.call(je);
      };
    }
    var ye = Ox(a, 0, !1, null, null, !1, !1, "", Eb);
    return (
      (a._reactRootContainer = ye),
      (a[lo] = ye.current),
      nu(a.nodeType === 8 ? a.parentNode : a),
      wc(function () {
        Zg(c, ye, v, M);
      }),
      ye
    );
  }
  function tv(a, c, v, M, I) {
    var O = v._reactRootContainer;
    if (O) {
      var Y = O;
      if (typeof I == "function") {
        var pe = I;
        I = function () {
          var ye = Jg(Y);
          pe.call(ye);
        };
      }
      Zg(c, Y, a, I);
    } else Y = o3(v, c, a, I, M);
    return Jg(Y);
  }
  (da = function (a) {
    switch (a.tag) {
      case 3:
        var c = a.stateNode;
        if (c.current.memoizedState.isDehydrated) {
          var v = cn(c.pendingLanes);
          v !== 0 &&
            (Vo(c, v | 1),
            ko(c, Ke()),
            (gn & 6) === 0 && ((bd = Ke() + 500), ms()));
        }
        break;
      case 13:
        wc(function () {
          var M = Zo(a, 1);
          if (M !== null) {
            var I = ho();
            Qs(M, a, 1, I);
          }
        }),
          Ux(a, 1);
    }
  }),
    (Wl = function (a) {
      if (a.tag === 13) {
        var c = Zo(a, 134217728);
        if (c !== null) {
          var v = ho();
          Qs(c, a, 134217728, v);
        }
        Ux(a, 134217728);
      }
    }),
    (jl = function (a) {
      if (a.tag === 13) {
        var c = Su(a),
          v = Zo(a, c);
        if (v !== null) {
          var M = ho();
          Qs(v, a, c, M);
        }
        Ux(a, c);
      }
    }),
    (cs = function () {
      return ln;
    }),
    (Ka = function (a, c) {
      var v = ln;
      try {
        return (ln = a), c();
      } finally {
        ln = v;
      }
    }),
    (Re = function (a, c, v) {
      switch (c) {
        case "input":
          if ((rt(a, v), (c = v.name), v.type === "radio" && c != null)) {
            for (v = a; v.parentNode; ) v = v.parentNode;
            for (
              v = v.querySelectorAll(
                "input[name=" + JSON.stringify("" + c) + '][type="radio"]'
              ),
                c = 0;
              c < v.length;
              c++
            ) {
              var M = v[c];
              if (M !== a && M.form === a.form) {
                var I = nd(M);
                if (!I) throw Error(t(90));
                j(M), rt(M, I);
              }
            }
          }
          break;
        case "textarea":
          _e(a, v);
          break;
        case "select":
          (c = v.value), c != null && B(a, !!v.multiple, c, !1);
      }
    }),
    (Ut = Px),
    (ht = wc);
  var s3 = { usingClientEntryPoint: !1, Events: [Vs, fr, nd, gt, Ot, Px] },
    bp = {
      findFiberByHostInstance: Ma,
      bundleType: 0,
      version: "18.2.0",
      rendererPackageName: "react-dom",
    },
    a3 = {
      bundleType: bp.bundleType,
      version: bp.version,
      rendererPackageName: bp.rendererPackageName,
      rendererConfig: bp.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: A.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (a) {
        return (a = ze(a)), a === null ? null : a.stateNode;
      },
      findFiberByHostInstance: bp.findFiberByHostInstance || i3,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var nv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!nv.isDisabled && nv.supportsFiber)
      try {
        (wn = nv.inject(a3)), (wt = nv);
      } catch {}
  }
  return (
    (Do.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = s3),
    (Do.createPortal = function (a, c) {
      var v =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Bx(c)) throw Error(t(200));
      return r3(a, c, null, v);
    }),
    (Do.createRoot = function (a, c) {
      if (!Bx(a)) throw Error(t(299));
      var v = !1,
        M = "",
        I = Mb;
      return (
        c != null &&
          (c.unstable_strictMode === !0 && (v = !0),
          c.identifierPrefix !== void 0 && (M = c.identifierPrefix),
          c.onRecoverableError !== void 0 && (I = c.onRecoverableError)),
        (c = Ox(a, 1, !1, null, null, v, !1, M, I)),
        (a[lo] = c.current),
        nu(a.nodeType === 8 ? a.parentNode : a),
        new Fx(c)
      );
    }),
    (Do.findDOMNode = function (a) {
      if (a == null) return null;
      if (a.nodeType === 1) return a;
      var c = a._reactInternals;
      if (c === void 0)
        throw typeof a.render == "function"
          ? Error(t(188))
          : ((a = Object.keys(a).join(",")), Error(t(268, a)));
      return (a = ze(c)), (a = a === null ? null : a.stateNode), a;
    }),
    (Do.flushSync = function (a) {
      return wc(a);
    }),
    (Do.hydrate = function (a, c, v) {
      if (!ev(c)) throw Error(t(200));
      return tv(null, a, c, !0, v);
    }),
    (Do.hydrateRoot = function (a, c, v) {
      if (!Bx(a)) throw Error(t(405));
      var M = (v != null && v.hydratedSources) || null,
        I = !1,
        O = "",
        Y = Mb;
      if (
        (v != null &&
          (v.unstable_strictMode === !0 && (I = !0),
          v.identifierPrefix !== void 0 && (O = v.identifierPrefix),
          v.onRecoverableError !== void 0 && (Y = v.onRecoverableError)),
        (c = wb(c, null, a, 1, v ?? null, I, !1, O, Y)),
        (a[lo] = c.current),
        nu(a),
        M)
      )
        for (a = 0; a < M.length; a++)
          (v = M[a]),
            (I = v._getVersion),
            (I = I(v._source)),
            c.mutableSourceEagerHydrationData == null
              ? (c.mutableSourceEagerHydrationData = [v, I])
              : c.mutableSourceEagerHydrationData.push(v, I);
      return new Qg(c);
    }),
    (Do.render = function (a, c, v) {
      if (!ev(c)) throw Error(t(200));
      return tv(null, a, c, !1, v);
    }),
    (Do.unmountComponentAtNode = function (a) {
      if (!ev(a)) throw Error(t(40));
      return a._reactRootContainer
        ? (wc(function () {
            tv(null, null, a, !1, function () {
              (a._reactRootContainer = null), (a[lo] = null);
            });
          }),
          !0)
        : !1;
    }),
    (Do.unstable_batchedUpdates = Px),
    (Do.unstable_renderSubtreeIntoContainer = function (a, c, v, M) {
      if (!ev(v)) throw Error(t(200));
      if (a == null || a._reactInternals === void 0) throw Error(t(38));
      return tv(a, c, v, !1, M);
    }),
    (Do.version = "18.2.0-next-9e3b772b8-20220608"),
    Do
  );
}
var kb;
function NC() {
  if (kb) return Vx.exports;
  kb = 1;
  function n() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
  }
  return n(), (Vx.exports = p3()), Vx.exports;
}
var Db;
function m3() {
  if (Db) return rv;
  Db = 1;
  var n = NC();
  return (rv.createRoot = n.createRoot), (rv.hydrateRoot = n.hydrateRoot), rv;
}
var g3 = m3();
const v3 = Ah(g3);
var jx = { exports: {} },
  $x = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Nb;
function y3() {
  if (Nb) return $x;
  Nb = 1;
  var n = Rh();
  function e(m, g) {
    return (m === g && (m !== 0 || 1 / m === 1 / g)) || (m !== m && g !== g);
  }
  var t = typeof Object.is == "function" ? Object.is : e,
    r = n.useState,
    i = n.useEffect,
    o = n.useLayoutEffect,
    s = n.useDebugValue;
  function l(m, g) {
    var y = g(),
      x = r({ inst: { value: y, getSnapshot: g } }),
      S = x[0].inst,
      _ = x[1];
    return (
      o(
        function () {
          (S.value = y), (S.getSnapshot = g), u(S) && _({ inst: S });
        },
        [m, y, g]
      ),
      i(
        function () {
          return (
            u(S) && _({ inst: S }),
            m(function () {
              u(S) && _({ inst: S });
            })
          );
        },
        [m]
      ),
      s(y),
      y
    );
  }
  function u(m) {
    var g = m.getSnapshot;
    m = m.value;
    try {
      var y = g();
      return !t(m, y);
    } catch {
      return !0;
    }
  }
  function f(m, g) {
    return g();
  }
  var h =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? f
      : l;
  return (
    ($x.useSyncExternalStore =
      n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : h),
    $x
  );
}
var Ob;
function OC() {
  return Ob || ((Ob = 1), (jx.exports = y3())), jx.exports;
}
OC();
var Xx = { exports: {} },
  Yx = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ub;
function x3() {
  if (Ub) return Yx;
  Ub = 1;
  var n = Rh(),
    e = OC();
  function t(f, h) {
    return (f === h && (f !== 0 || 1 / f === 1 / h)) || (f !== f && h !== h);
  }
  var r = typeof Object.is == "function" ? Object.is : t,
    i = e.useSyncExternalStore,
    o = n.useRef,
    s = n.useEffect,
    l = n.useMemo,
    u = n.useDebugValue;
  return (
    (Yx.useSyncExternalStoreWithSelector = function (f, h, m, g, y) {
      var x = o(null);
      if (x.current === null) {
        var S = { hasValue: !1, value: null };
        x.current = S;
      } else S = x.current;
      x = l(
        function () {
          function w(k) {
            if (!T) {
              if (((T = !0), (E = k), (k = g(k)), y !== void 0 && S.hasValue)) {
                var P = S.value;
                if (y(P, k)) return (A = P);
              }
              return (A = k);
            }
            if (((P = A), r(E, k))) return P;
            var U = g(k);
            return y !== void 0 && y(P, U) ? ((E = k), P) : ((E = k), (A = U));
          }
          var T = !1,
            E,
            A,
            R = m === void 0 ? null : m;
          return [
            function () {
              return w(h());
            },
            R === null
              ? void 0
              : function () {
                  return w(R());
                },
          ];
        },
        [h, m, g, y]
      );
      var _ = i(f, x[0], x[1]);
      return (
        s(
          function () {
            (S.hasValue = !0), (S.value = _);
          },
          [_]
        ),
        u(_),
        _
      );
    }),
    Yx
  );
}
var Fb;
function _3() {
  return Fb || ((Fb = 1), (Xx.exports = x3())), Xx.exports;
}
var S3 = _3(),
  gS = NC();
const iv = Ah(gS);
function w3(n) {
  n();
}
let UC = w3;
const b3 = (n) => (UC = n),
  M3 = () => UC,
  Bb = Symbol.for("react-redux-context"),
  zb = typeof globalThis < "u" ? globalThis : {};
function E3() {
  var n;
  if (!K.createContext) return {};
  const e = (n = zb[Bb]) != null ? n : (zb[Bb] = new Map());
  let t = e.get(K.createContext);
  return t || ((t = K.createContext(null)), e.set(K.createContext, t)), t;
}
const Hu = E3();
function vS(n = Hu) {
  return function () {
    return K.useContext(n);
  };
}
const FC = vS(),
  T3 = () => {
    throw new Error("uSES not initialized!");
  };
let BC = T3;
const C3 = (n) => {
    BC = n;
  },
  A3 = (n, e) => n === e;
function R3(n = Hu) {
  const e = n === Hu ? FC : vS(n);
  return function (r, i = {}) {
    const {
        equalityFn: o = A3,
        stabilityCheck: s = void 0,
        noopCheck: l = void 0,
      } = typeof i == "function" ? { equalityFn: i } : i,
      {
        store: u,
        subscription: f,
        getServerState: h,
        stabilityCheck: m,
        noopCheck: g,
      } = e();
    K.useRef(!0);
    const y = K.useCallback(
        {
          [r.name](S) {
            return r(S);
          },
        }[r.name],
        [r, m, s]
      ),
      x = BC(f.addNestedSub, u.getState, h || u.getState, y, o);
    return K.useDebugValue(x), x;
  };
}
const $u = R3();
function ue() {
  return (
    (ue = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    ue.apply(null, arguments)
  );
}
function Pt(n, e) {
  if (n == null) return {};
  var t = {};
  for (var r in n)
    if ({}.hasOwnProperty.call(n, r)) {
      if (e.indexOf(r) !== -1) continue;
      t[r] = n[r];
    }
  return t;
}
var qx = { exports: {} },
  Ln = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Hb;
function P3() {
  if (Hb) return Ln;
  Hb = 1;
  var n = typeof Symbol == "function" && Symbol.for,
    e = n ? Symbol.for("react.element") : 60103,
    t = n ? Symbol.for("react.portal") : 60106,
    r = n ? Symbol.for("react.fragment") : 60107,
    i = n ? Symbol.for("react.strict_mode") : 60108,
    o = n ? Symbol.for("react.profiler") : 60114,
    s = n ? Symbol.for("react.provider") : 60109,
    l = n ? Symbol.for("react.context") : 60110,
    u = n ? Symbol.for("react.async_mode") : 60111,
    f = n ? Symbol.for("react.concurrent_mode") : 60111,
    h = n ? Symbol.for("react.forward_ref") : 60112,
    m = n ? Symbol.for("react.suspense") : 60113,
    g = n ? Symbol.for("react.suspense_list") : 60120,
    y = n ? Symbol.for("react.memo") : 60115,
    x = n ? Symbol.for("react.lazy") : 60116,
    S = n ? Symbol.for("react.block") : 60121,
    _ = n ? Symbol.for("react.fundamental") : 60117,
    w = n ? Symbol.for("react.responder") : 60118,
    T = n ? Symbol.for("react.scope") : 60119;
  function E(R) {
    if (typeof R == "object" && R !== null) {
      var k = R.$$typeof;
      switch (k) {
        case e:
          switch (((R = R.type), R)) {
            case u:
            case f:
            case r:
            case o:
            case i:
            case m:
              return R;
            default:
              switch (((R = R && R.$$typeof), R)) {
                case l:
                case h:
                case x:
                case y:
                case s:
                  return R;
                default:
                  return k;
              }
          }
        case t:
          return k;
      }
    }
  }
  function A(R) {
    return E(R) === f;
  }
  return (
    (Ln.AsyncMode = u),
    (Ln.ConcurrentMode = f),
    (Ln.ContextConsumer = l),
    (Ln.ContextProvider = s),
    (Ln.Element = e),
    (Ln.ForwardRef = h),
    (Ln.Fragment = r),
    (Ln.Lazy = x),
    (Ln.Memo = y),
    (Ln.Portal = t),
    (Ln.Profiler = o),
    (Ln.StrictMode = i),
    (Ln.Suspense = m),
    (Ln.isAsyncMode = function (R) {
      return A(R) || E(R) === u;
    }),
    (Ln.isConcurrentMode = A),
    (Ln.isContextConsumer = function (R) {
      return E(R) === l;
    }),
    (Ln.isContextProvider = function (R) {
      return E(R) === s;
    }),
    (Ln.isElement = function (R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }),
    (Ln.isForwardRef = function (R) {
      return E(R) === h;
    }),
    (Ln.isFragment = function (R) {
      return E(R) === r;
    }),
    (Ln.isLazy = function (R) {
      return E(R) === x;
    }),
    (Ln.isMemo = function (R) {
      return E(R) === y;
    }),
    (Ln.isPortal = function (R) {
      return E(R) === t;
    }),
    (Ln.isProfiler = function (R) {
      return E(R) === o;
    }),
    (Ln.isStrictMode = function (R) {
      return E(R) === i;
    }),
    (Ln.isSuspense = function (R) {
      return E(R) === m;
    }),
    (Ln.isValidElementType = function (R) {
      return (
        typeof R == "string" ||
        typeof R == "function" ||
        R === r ||
        R === f ||
        R === o ||
        R === i ||
        R === m ||
        R === g ||
        (typeof R == "object" &&
          R !== null &&
          (R.$$typeof === x ||
            R.$$typeof === y ||
            R.$$typeof === s ||
            R.$$typeof === l ||
            R.$$typeof === h ||
            R.$$typeof === _ ||
            R.$$typeof === w ||
            R.$$typeof === T ||
            R.$$typeof === S))
      );
    }),
    (Ln.typeOf = E),
    Ln
  );
}
var Vb;
function I3() {
  return Vb || ((Vb = 1), (qx.exports = P3())), qx.exports;
}
var Kx, Gb;
function L3() {
  if (Gb) return Kx;
  Gb = 1;
  var n = I3(),
    e = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0,
    },
    t = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0,
    },
    r = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
    },
    i = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0,
    },
    o = {};
  (o[n.ForwardRef] = r), (o[n.Memo] = i);
  function s(x) {
    return n.isMemo(x) ? i : o[x.$$typeof] || e;
  }
  var l = Object.defineProperty,
    u = Object.getOwnPropertyNames,
    f = Object.getOwnPropertySymbols,
    h = Object.getOwnPropertyDescriptor,
    m = Object.getPrototypeOf,
    g = Object.prototype;
  function y(x, S, _) {
    if (typeof S != "string") {
      if (g) {
        var w = m(S);
        w && w !== g && y(x, w, _);
      }
      var T = u(S);
      f && (T = T.concat(f(S)));
      for (var E = s(x), A = s(S), R = 0; R < T.length; ++R) {
        var k = T[R];
        if (!t[k] && !(_ && _[k]) && !(A && A[k]) && !(E && E[k])) {
          var P = h(S, k);
          try {
            l(x, k, P);
          } catch {}
        }
      }
    }
    return x;
  }
  return (Kx = y), Kx;
}
L3();
var Zx = { exports: {} },
  kn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Wb;
function k3() {
  if (Wb) return kn;
  Wb = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.server_context"),
    u = Symbol.for("react.forward_ref"),
    f = Symbol.for("react.suspense"),
    h = Symbol.for("react.suspense_list"),
    m = Symbol.for("react.memo"),
    g = Symbol.for("react.lazy"),
    y = Symbol.for("react.offscreen"),
    x;
  x = Symbol.for("react.module.reference");
  function S(_) {
    if (typeof _ == "object" && _ !== null) {
      var w = _.$$typeof;
      switch (w) {
        case n:
          switch (((_ = _.type), _)) {
            case t:
            case i:
            case r:
            case f:
            case h:
              return _;
            default:
              switch (((_ = _ && _.$$typeof), _)) {
                case l:
                case s:
                case u:
                case g:
                case m:
                case o:
                  return _;
                default:
                  return w;
              }
          }
        case e:
          return w;
      }
    }
  }
  return (
    (kn.ContextConsumer = s),
    (kn.ContextProvider = o),
    (kn.Element = n),
    (kn.ForwardRef = u),
    (kn.Fragment = t),
    (kn.Lazy = g),
    (kn.Memo = m),
    (kn.Portal = e),
    (kn.Profiler = i),
    (kn.StrictMode = r),
    (kn.Suspense = f),
    (kn.SuspenseList = h),
    (kn.isAsyncMode = function () {
      return !1;
    }),
    (kn.isConcurrentMode = function () {
      return !1;
    }),
    (kn.isContextConsumer = function (_) {
      return S(_) === s;
    }),
    (kn.isContextProvider = function (_) {
      return S(_) === o;
    }),
    (kn.isElement = function (_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === n;
    }),
    (kn.isForwardRef = function (_) {
      return S(_) === u;
    }),
    (kn.isFragment = function (_) {
      return S(_) === t;
    }),
    (kn.isLazy = function (_) {
      return S(_) === g;
    }),
    (kn.isMemo = function (_) {
      return S(_) === m;
    }),
    (kn.isPortal = function (_) {
      return S(_) === e;
    }),
    (kn.isProfiler = function (_) {
      return S(_) === i;
    }),
    (kn.isStrictMode = function (_) {
      return S(_) === r;
    }),
    (kn.isSuspense = function (_) {
      return S(_) === f;
    }),
    (kn.isSuspenseList = function (_) {
      return S(_) === h;
    }),
    (kn.isValidElementType = function (_) {
      return (
        typeof _ == "string" ||
        typeof _ == "function" ||
        _ === t ||
        _ === i ||
        _ === r ||
        _ === f ||
        _ === h ||
        _ === y ||
        (typeof _ == "object" &&
          _ !== null &&
          (_.$$typeof === g ||
            _.$$typeof === m ||
            _.$$typeof === o ||
            _.$$typeof === s ||
            _.$$typeof === u ||
            _.$$typeof === x ||
            _.getModuleId !== void 0))
      );
    }),
    (kn.typeOf = S),
    kn
  );
}
var jb;
function D3() {
  return jb || ((jb = 1), (Zx.exports = k3())), Zx.exports;
}
D3();
function N3() {
  const n = M3();
  let e = null,
    t = null;
  return {
    clear() {
      (e = null), (t = null);
    },
    notify() {
      n(() => {
        let r = e;
        for (; r; ) r.callback(), (r = r.next);
      });
    },
    get() {
      let r = [],
        i = e;
      for (; i; ) r.push(i), (i = i.next);
      return r;
    },
    subscribe(r) {
      let i = !0,
        o = (t = { callback: r, next: null, prev: t });
      return (
        o.prev ? (o.prev.next = o) : (e = o),
        function () {
          !i ||
            e === null ||
            ((i = !1),
            o.next ? (o.next.prev = o.prev) : (t = o.prev),
            o.prev ? (o.prev.next = o.next) : (e = o.next));
        }
      );
    },
  };
}
const $b = { notify() {}, get: () => [] };
function O3(n, e) {
  let t,
    r = $b,
    i = 0,
    o = !1;
  function s(S) {
    h();
    const _ = r.subscribe(S);
    let w = !1;
    return () => {
      w || ((w = !0), _(), m());
    };
  }
  function l() {
    r.notify();
  }
  function u() {
    x.onStateChange && x.onStateChange();
  }
  function f() {
    return o;
  }
  function h() {
    i++, t || ((t = n.subscribe(u)), (r = N3()));
  }
  function m() {
    i--, t && i === 0 && (t(), (t = void 0), r.clear(), (r = $b));
  }
  function g() {
    o || ((o = !0), h());
  }
  function y() {
    o && ((o = !1), m());
  }
  const x = {
    addNestedSub: s,
    notifyNestedSubs: l,
    handleChangeWrapper: u,
    isSubscribed: f,
    trySubscribe: g,
    tryUnsubscribe: y,
    getListeners: () => r,
  };
  return x;
}
const U3 =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  F3 = U3 ? K.useLayoutEffect : K.useEffect;
function zC({
  store: n,
  context: e,
  children: t,
  serverState: r,
  stabilityCheck: i = "once",
  noopCheck: o = "once",
}) {
  const s = K.useMemo(() => {
      const f = O3(n);
      return {
        store: n,
        subscription: f,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        noopCheck: o,
      };
    }, [n, r, i, o]),
    l = K.useMemo(() => n.getState(), [n]);
  F3(() => {
    const { subscription: f } = s;
    return (
      (f.onStateChange = f.notifyNestedSubs),
      f.trySubscribe(),
      l !== n.getState() && f.notifyNestedSubs(),
      () => {
        f.tryUnsubscribe(), (f.onStateChange = void 0);
      }
    );
  }, [s, l]);
  const u = e || Hu;
  return K.createElement(u.Provider, { value: s }, t);
}
function HC(n = Hu) {
  const e = n === Hu ? FC : vS(n);
  return function () {
    const { store: r } = e();
    return r;
  };
}
const B3 = HC();
function z3(n = Hu) {
  const e = n === Hu ? B3 : HC(n);
  return function () {
    return e().dispatch;
  };
}
const yS = z3();
C3(S3.useSyncExternalStoreWithSelector);
b3(gS.unstable_batchedUpdates);
const ym = { black: "#000", white: "#fff" },
  Ed = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828",
  },
  Td = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2",
  },
  Cd = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0",
  },
  Ad = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b",
  },
  Rd = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
  },
  Ep = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100",
  },
  H3 = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161",
  };
function Ll(n) {
  let e = "https://mui.com/production-error/?code=" + n;
  for (let t = 1; t < arguments.length; t += 1)
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified MUI error #" + n + "; visit " + e + " for the full message.";
}
const V3 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: Ll },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  cy = "$$material";
function VC(n) {
  var e = Object.create(null);
  return function (t) {
    return e[t] === void 0 && (e[t] = n(t)), e[t];
  };
}
var G3 =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  W3 = VC(function (n) {
    return (
      G3.test(n) ||
      (n.charCodeAt(0) === 111 &&
        n.charCodeAt(1) === 110 &&
        n.charCodeAt(2) < 91)
    );
  });
function j3(n) {
  if (n.sheet) return n.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === n) return document.styleSheets[e];
}
function $3(n) {
  var e = document.createElement("style");
  return (
    e.setAttribute("data-emotion", n.key),
    n.nonce !== void 0 && e.setAttribute("nonce", n.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
  );
}
var X3 = (function () {
    function n(t) {
      var r = this;
      (this._insertTag = function (i) {
        var o;
        r.tags.length === 0
          ? r.insertionPoint
            ? (o = r.insertionPoint.nextSibling)
            : r.prepend
            ? (o = r.container.firstChild)
            : (o = r.before)
          : (o = r.tags[r.tags.length - 1].nextSibling),
          r.container.insertBefore(i, o),
          r.tags.push(i);
      }),
        (this.isSpeedy = t.speedy === void 0 ? !0 : t.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = t.nonce),
        (this.key = t.key),
        (this.container = t.container),
        (this.prepend = t.prepend),
        (this.insertionPoint = t.insertionPoint),
        (this.before = null);
    }
    var e = n.prototype;
    return (
      (e.hydrate = function (r) {
        r.forEach(this._insertTag);
      }),
      (e.insert = function (r) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag($3(this));
        var i = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var o = j3(i);
          try {
            o.insertRule(r, o.cssRules.length);
          } catch {}
        } else i.appendChild(document.createTextNode(r));
        this.ctr++;
      }),
      (e.flush = function () {
        this.tags.forEach(function (r) {
          var i;
          return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      n
    );
  })(),
  Ki = "-ms-",
  g0 = "-moz-",
  Rn = "-webkit-",
  GC = "comm",
  xS = "rule",
  _S = "decl",
  Y3 = "@import",
  WC = "@keyframes",
  q3 = "@layer",
  K3 = Math.abs,
  fy = String.fromCharCode,
  Z3 = Object.assign;
function J3(n, e) {
  return ki(n, 0) ^ 45
    ? (((((((e << 2) ^ ki(n, 0)) << 2) ^ ki(n, 1)) << 2) ^ ki(n, 2)) << 2) ^
        ki(n, 3)
    : 0;
}
function jC(n) {
  return n.trim();
}
function Q3(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function Pn(n, e, t) {
  return n.replace(e, t);
}
function R1(n, e) {
  return n.indexOf(e);
}
function ki(n, e) {
  return n.charCodeAt(e) | 0;
}
function xm(n, e, t) {
  return n.slice(e, t);
}
function Oa(n) {
  return n.length;
}
function SS(n) {
  return n.length;
}
function ov(n, e) {
  return e.push(n), n;
}
function eI(n, e) {
  return n.map(e).join("");
}
var dy = 1,
  xh = 1,
  $C = 0,
  Fo = 0,
  ti = 0,
  Ph = "";
function hy(n, e, t, r, i, o, s) {
  return {
    value: n,
    root: e,
    parent: t,
    type: r,
    props: i,
    children: o,
    line: dy,
    column: xh,
    length: s,
    return: "",
  };
}
function Tp(n, e) {
  return Z3(hy("", null, null, "", null, null, 0), n, { length: -n.length }, e);
}
function tI() {
  return ti;
}
function nI() {
  return (
    (ti = Fo > 0 ? ki(Ph, --Fo) : 0), xh--, ti === 10 && ((xh = 1), dy--), ti
  );
}
function is() {
  return (
    (ti = Fo < $C ? ki(Ph, Fo++) : 0), xh++, ti === 10 && ((xh = 1), dy++), ti
  );
}
function Ha() {
  return ki(Ph, Fo);
}
function a0() {
  return Fo;
}
function Xm(n, e) {
  return xm(Ph, n, e);
}
function _m(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function XC(n) {
  return (dy = xh = 1), ($C = Oa((Ph = n))), (Fo = 0), [];
}
function YC(n) {
  return (Ph = ""), n;
}
function l0(n) {
  return jC(Xm(Fo - 1, P1(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function rI(n) {
  for (; (ti = Ha()) && ti < 33; ) is();
  return _m(n) > 2 || _m(ti) > 3 ? "" : " ";
}
function iI(n, e) {
  for (
    ;
    --e &&
    is() &&
    !(ti < 48 || ti > 102 || (ti > 57 && ti < 65) || (ti > 70 && ti < 97));

  );
  return Xm(n, a0() + (e < 6 && Ha() == 32 && is() == 32));
}
function P1(n) {
  for (; is(); )
    switch (ti) {
      case n:
        return Fo;
      case 34:
      case 39:
        n !== 34 && n !== 39 && P1(ti);
        break;
      case 40:
        n === 41 && P1(n);
        break;
      case 92:
        is();
        break;
    }
  return Fo;
}
function oI(n, e) {
  for (; is() && n + ti !== 57; ) if (n + ti === 84 && Ha() === 47) break;
  return "/*" + Xm(e, Fo - 1) + "*" + fy(n === 47 ? n : is());
}
function sI(n) {
  for (; !_m(Ha()); ) is();
  return Xm(n, Fo);
}
function aI(n) {
  return YC(u0("", null, null, null, [""], (n = XC(n)), 0, [0], n));
}
function u0(n, e, t, r, i, o, s, l, u) {
  for (
    var f = 0,
      h = 0,
      m = s,
      g = 0,
      y = 0,
      x = 0,
      S = 1,
      _ = 1,
      w = 1,
      T = 0,
      E = "",
      A = i,
      R = o,
      k = r,
      P = E;
    _;

  )
    switch (((x = T), (T = is()))) {
      case 40:
        if (x != 108 && ki(P, m - 1) == 58) {
          R1((P += Pn(l0(T), "&", "&\f")), "&\f") != -1 && (w = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        P += l0(T);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        P += rI(x);
        break;
      case 92:
        P += iI(a0() - 1, 7);
        continue;
      case 47:
        switch (Ha()) {
          case 42:
          case 47:
            ov(lI(oI(is(), a0()), e, t), u);
            break;
          default:
            P += "/";
        }
        break;
      case 123 * S:
        l[f++] = Oa(P) * w;
      case 125 * S:
      case 59:
      case 0:
        switch (T) {
          case 0:
          case 125:
            _ = 0;
          case 59 + h:
            w == -1 && (P = Pn(P, /\f/g, "")),
              y > 0 &&
                Oa(P) - m &&
                ov(
                  y > 32
                    ? Yb(P + ";", r, t, m - 1)
                    : Yb(Pn(P, " ", "") + ";", r, t, m - 2),
                  u
                );
            break;
          case 59:
            P += ";";
          default:
            if (
              (ov((k = Xb(P, e, t, f, h, i, l, E, (A = []), (R = []), m)), o),
              T === 123)
            )
              if (h === 0) u0(P, e, k, k, A, o, m, l, R);
              else
                switch (g === 99 && ki(P, 3) === 110 ? 100 : g) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    u0(
                      n,
                      k,
                      k,
                      r && ov(Xb(n, k, k, 0, 0, i, l, E, i, (A = []), m), R),
                      i,
                      R,
                      m,
                      l,
                      r ? A : R
                    );
                    break;
                  default:
                    u0(P, k, k, k, [""], R, 0, l, R);
                }
        }
        (f = h = y = 0), (S = w = 1), (E = P = ""), (m = s);
        break;
      case 58:
        (m = 1 + Oa(P)), (y = x);
      default:
        if (S < 1) {
          if (T == 123) --S;
          else if (T == 125 && S++ == 0 && nI() == 125) continue;
        }
        switch (((P += fy(T)), T * S)) {
          case 38:
            w = h > 0 ? 1 : ((P += "\f"), -1);
            break;
          case 44:
            (l[f++] = (Oa(P) - 1) * w), (w = 1);
            break;
          case 64:
            Ha() === 45 && (P += l0(is())),
              (g = Ha()),
              (h = m = Oa((E = P += sI(a0())))),
              T++;
            break;
          case 45:
            x === 45 && Oa(P) == 2 && (S = 0);
        }
    }
  return o;
}
function Xb(n, e, t, r, i, o, s, l, u, f, h) {
  for (
    var m = i - 1, g = i === 0 ? o : [""], y = SS(g), x = 0, S = 0, _ = 0;
    x < r;
    ++x
  )
    for (var w = 0, T = xm(n, m + 1, (m = K3((S = s[x])))), E = n; w < y; ++w)
      (E = jC(S > 0 ? g[w] + " " + T : Pn(T, /&\f/g, g[w]))) && (u[_++] = E);
  return hy(n, e, t, i === 0 ? xS : l, u, f, h);
}
function lI(n, e, t) {
  return hy(n, e, t, GC, fy(tI()), xm(n, 2, -2), 0);
}
function Yb(n, e, t, r) {
  return hy(n, e, t, _S, xm(n, 0, r), xm(n, r + 1, -1), r);
}
function hh(n, e) {
  for (var t = "", r = SS(n), i = 0; i < r; i++) t += e(n[i], i, n, e) || "";
  return t;
}
function uI(n, e, t, r) {
  switch (n.type) {
    case q3:
      if (n.children.length) break;
    case Y3:
    case _S:
      return (n.return = n.return || n.value);
    case GC:
      return "";
    case WC:
      return (n.return = n.value + "{" + hh(n.children, r) + "}");
    case xS:
      n.value = n.props.join(",");
  }
  return Oa((t = hh(n.children, r)))
    ? (n.return = n.value + "{" + t + "}")
    : "";
}
function cI(n) {
  var e = SS(n);
  return function (t, r, i, o) {
    for (var s = "", l = 0; l < e; l++) s += n[l](t, r, i, o) || "";
    return s;
  };
}
function fI(n) {
  return function (e) {
    e.root || ((e = e.return) && n(e));
  };
}
var dI = function (e, t, r) {
    for (
      var i = 0, o = 0;
      (i = o), (o = Ha()), i === 38 && o === 12 && (t[r] = 1), !_m(o);

    )
      is();
    return Xm(e, Fo);
  },
  hI = function (e, t) {
    var r = -1,
      i = 44;
    do
      switch (_m(i)) {
        case 0:
          i === 38 && Ha() === 12 && (t[r] = 1), (e[r] += dI(Fo - 1, t, r));
          break;
        case 2:
          e[r] += l0(i);
          break;
        case 4:
          if (i === 44) {
            (e[++r] = Ha() === 58 ? "&\f" : ""), (t[r] = e[r].length);
            break;
          }
        default:
          e[r] += fy(i);
      }
    while ((i = is()));
    return e;
  },
  pI = function (e, t) {
    return YC(hI(XC(e), t));
  },
  qb = new WeakMap(),
  mI = function (e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (
        var t = e.value,
          r = e.parent,
          i = e.column === r.column && e.line === r.line;
        r.type !== "rule";

      )
        if (((r = r.parent), !r)) return;
      if (
        !(e.props.length === 1 && t.charCodeAt(0) !== 58 && !qb.get(r)) &&
        !i
      ) {
        qb.set(e, !0);
        for (
          var o = [], s = pI(t, o), l = r.props, u = 0, f = 0;
          u < s.length;
          u++
        )
          for (var h = 0; h < l.length; h++, f++)
            e.props[f] = o[u] ? s[u].replace(/&\f/g, l[h]) : l[h] + " " + s[u];
      }
    }
  },
  gI = function (e) {
    if (e.type === "decl") {
      var t = e.value;
      t.charCodeAt(0) === 108 &&
        t.charCodeAt(2) === 98 &&
        ((e.return = ""), (e.value = ""));
    }
  };
function qC(n, e) {
  switch (J3(n, e)) {
    case 5103:
      return Rn + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Rn + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Rn + n + g0 + n + Ki + n + n;
    case 6828:
    case 4268:
      return Rn + n + Ki + n + n;
    case 6165:
      return Rn + n + Ki + "flex-" + n + n;
    case 5187:
      return (
        Rn + n + Pn(n, /(\w+).+(:[^]+)/, Rn + "box-$1$2" + Ki + "flex-$1$2") + n
      );
    case 5443:
      return Rn + n + Ki + "flex-item-" + Pn(n, /flex-|-self/, "") + n;
    case 4675:
      return (
        Rn +
        n +
        Ki +
        "flex-line-pack" +
        Pn(n, /align-content|flex-|-self/, "") +
        n
      );
    case 5548:
      return Rn + n + Ki + Pn(n, "shrink", "negative") + n;
    case 5292:
      return Rn + n + Ki + Pn(n, "basis", "preferred-size") + n;
    case 6060:
      return (
        Rn +
        "box-" +
        Pn(n, "-grow", "") +
        Rn +
        n +
        Ki +
        Pn(n, "grow", "positive") +
        n
      );
    case 4554:
      return Rn + Pn(n, /([^-])(transform)/g, "$1" + Rn + "$2") + n;
    case 6187:
      return (
        Pn(
          Pn(Pn(n, /(zoom-|grab)/, Rn + "$1"), /(image-set)/, Rn + "$1"),
          n,
          ""
        ) + n
      );
    case 5495:
    case 3959:
      return Pn(n, /(image-set\([^]*)/, Rn + "$1$`$1");
    case 4968:
      return (
        Pn(
          Pn(n, /(.+:)(flex-)?(.*)/, Rn + "box-pack:$3" + Ki + "flex-pack:$3"),
          /s.+-b[^;]+/,
          "justify"
        ) +
        Rn +
        n +
        n
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Pn(n, /(.+)-inline(.+)/, Rn + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Oa(n) - 1 - e > 6)
        switch (ki(n, e + 1)) {
          case 109:
            if (ki(n, e + 4) !== 45) break;
          case 102:
            return (
              Pn(
                n,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  Rn +
                  "$2-$3$1" +
                  g0 +
                  (ki(n, e + 3) == 108 ? "$3" : "$2-$3")
              ) + n
            );
          case 115:
            return ~R1(n, "stretch")
              ? qC(Pn(n, "stretch", "fill-available"), e) + n
              : n;
        }
      break;
    case 4949:
      if (ki(n, e + 1) !== 115) break;
    case 6444:
      switch (ki(n, Oa(n) - 3 - (~R1(n, "!important") && 10))) {
        case 107:
          return Pn(n, ":", ":" + Rn) + n;
        case 101:
          return (
            Pn(
              n,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                Rn +
                (ki(n, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                Rn +
                "$2$3$1" +
                Ki +
                "$2box$3"
            ) + n
          );
      }
      break;
    case 5936:
      switch (ki(n, e + 11)) {
        case 114:
          return Rn + n + Ki + Pn(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return Rn + n + Ki + Pn(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return Rn + n + Ki + Pn(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
      return Rn + n + Ki + n + n;
  }
  return n;
}
var vI = function (e, t, r, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case _S:
          e.return = qC(e.value, e.length);
          break;
        case WC:
          return hh([Tp(e, { value: Pn(e.value, "@", "@" + Rn) })], i);
        case xS:
          if (e.length)
            return eI(e.props, function (o) {
              switch (Q3(o, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return hh(
                    [Tp(e, { props: [Pn(o, /:(read-\w+)/, ":" + g0 + "$1")] })],
                    i
                  );
                case "::placeholder":
                  return hh(
                    [
                      Tp(e, {
                        props: [Pn(o, /:(plac\w+)/, ":" + Rn + "input-$1")],
                      }),
                      Tp(e, { props: [Pn(o, /:(plac\w+)/, ":" + g0 + "$1")] }),
                      Tp(e, { props: [Pn(o, /:(plac\w+)/, Ki + "input-$1")] }),
                    ],
                    i
                  );
              }
              return "";
            });
      }
  },
  yI = [vI],
  KC = function (e) {
    var t = e.key;
    if (t === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function (S) {
        var _ = S.getAttribute("data-emotion");
        _.indexOf(" ") !== -1 &&
          (document.head.appendChild(S), S.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || yI,
      o = {},
      s,
      l = [];
    (s = e.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
        function (S) {
          for (
            var _ = S.getAttribute("data-emotion").split(" "), w = 1;
            w < _.length;
            w++
          )
            o[_[w]] = !0;
          l.push(S);
        }
      );
    var u,
      f = [mI, gI];
    {
      var h,
        m = [
          uI,
          fI(function (S) {
            h.insert(S);
          }),
        ],
        g = cI(f.concat(i, m)),
        y = function (_) {
          return hh(aI(_), g);
        };
      u = function (_, w, T, E) {
        (h = T),
          y(_ ? _ + "{" + w.styles + "}" : w.styles),
          E && (x.inserted[w.name] = !0);
      };
    }
    var x = {
      key: t,
      sheet: new X3({
        key: t,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint,
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: u,
    };
    return x.sheet.hydrate(l), x;
  },
  xI = !0;
function _I(n, e, t) {
  var r = "";
  return (
    t.split(" ").forEach(function (i) {
      n[i] !== void 0 ? e.push(n[i] + ";") : i && (r += i + " ");
    }),
    r
  );
}
var ZC = function (e, t, r) {
    var i = e.key + "-" + t.name;
    (r === !1 || xI === !1) &&
      e.registered[i] === void 0 &&
      (e.registered[i] = t.styles);
  },
  JC = function (e, t, r) {
    ZC(e, t, r);
    var i = e.key + "-" + t.name;
    if (e.inserted[t.name] === void 0) {
      var o = t;
      do e.insert(t === o ? "." + i : "", o, e.sheet, !0), (o = o.next);
      while (o !== void 0);
    }
  };
function SI(n) {
  for (var e = 0, t, r = 0, i = n.length; i >= 4; ++r, i -= 4)
    (t =
      (n.charCodeAt(r) & 255) |
      ((n.charCodeAt(++r) & 255) << 8) |
      ((n.charCodeAt(++r) & 255) << 16) |
      ((n.charCodeAt(++r) & 255) << 24)),
      (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)),
      (t ^= t >>> 24),
      (e =
        ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (n.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (n.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= n.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
var wI = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  bI = /[A-Z]|^ms/g,
  MI = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  QC = function (e) {
    return e.charCodeAt(1) === 45;
  },
  Kb = function (e) {
    return e != null && typeof e != "boolean";
  },
  Jx = VC(function (n) {
    return QC(n) ? n : n.replace(bI, "-$&").toLowerCase();
  }),
  Zb = function (e, t) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof t == "string")
          return t.replace(MI, function (r, i, o) {
            return (Ua = { name: i, styles: o, next: Ua }), i;
          });
    }
    return wI[e] !== 1 && !QC(e) && typeof t == "number" && t !== 0
      ? t + "px"
      : t;
  };
function Sm(n, e, t) {
  if (t == null) return "";
  var r = t;
  if (r.__emotion_styles !== void 0) return r;
  switch (typeof t) {
    case "boolean":
      return "";
    case "object": {
      var i = t;
      if (i.anim === 1)
        return (Ua = { name: i.name, styles: i.styles, next: Ua }), i.name;
      var o = t;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            (Ua = { name: s.name, styles: s.styles, next: Ua }), (s = s.next);
        var l = o.styles + ";";
        return l;
      }
      return EI(n, e, t);
    }
    case "function": {
      if (n !== void 0) {
        var u = Ua,
          f = t(n);
        return (Ua = u), Sm(n, e, f);
      }
      break;
    }
  }
  var h = t;
  if (e == null) return h;
  var m = e[h];
  return m !== void 0 ? m : h;
}
function EI(n, e, t) {
  var r = "";
  if (Array.isArray(t))
    for (var i = 0; i < t.length; i++) r += Sm(n, e, t[i]) + ";";
  else
    for (var o in t) {
      var s = t[o];
      if (typeof s != "object") {
        var l = s;
        e != null && e[l] !== void 0
          ? (r += o + "{" + e[l] + "}")
          : Kb(l) && (r += Jx(o) + ":" + Zb(o, l) + ";");
      } else if (
        Array.isArray(s) &&
        typeof s[0] == "string" &&
        (e == null || e[s[0]] === void 0)
      )
        for (var u = 0; u < s.length; u++)
          Kb(s[u]) && (r += Jx(o) + ":" + Zb(o, s[u]) + ";");
      else {
        var f = Sm(n, e, s);
        switch (o) {
          case "animation":
          case "animationName": {
            r += Jx(o) + ":" + f + ";";
            break;
          }
          default:
            r += o + "{" + f + "}";
        }
      }
    }
  return r;
}
var Jb = /label:\s*([^\s;{]+)\s*(;|$)/g,
  Ua;
function wS(n, e, t) {
  if (
    n.length === 1 &&
    typeof n[0] == "object" &&
    n[0] !== null &&
    n[0].styles !== void 0
  )
    return n[0];
  var r = !0,
    i = "";
  Ua = void 0;
  var o = n[0];
  if (o == null || o.raw === void 0) (r = !1), (i += Sm(t, e, o));
  else {
    var s = o;
    i += s[0];
  }
  for (var l = 1; l < n.length; l++)
    if (((i += Sm(t, e, n[l])), r)) {
      var u = o;
      i += u[l];
    }
  Jb.lastIndex = 0;
  for (var f = "", h; (h = Jb.exec(i)) !== null; ) f += "-" + h[1];
  var m = SI(i) + f;
  return { name: m, styles: i, next: Ua };
}
var TI = function (e) {
    return e();
  },
  e2 = A1.useInsertionEffect ? A1.useInsertionEffect : !1,
  CI = e2 || TI,
  Qb = e2 || K.useLayoutEffect,
  t2 = K.createContext(typeof HTMLElement < "u" ? KC({ key: "css" }) : null),
  AI = t2.Provider,
  n2 = function (e) {
    return K.forwardRef(function (t, r) {
      var i = K.useContext(t2);
      return e(t, i, r);
    });
  },
  py = K.createContext({}),
  RI = n2(function (n, e) {
    var t = n.styles,
      r = wS([t], void 0, K.useContext(py)),
      i = K.useRef();
    return (
      Qb(
        function () {
          var o = e.key + "-global",
            s = new e.sheet.constructor({
              key: o,
              nonce: e.sheet.nonce,
              container: e.sheet.container,
              speedy: e.sheet.isSpeedy,
            }),
            l = !1,
            u = document.querySelector(
              'style[data-emotion="' + o + " " + r.name + '"]'
            );
          return (
            e.sheet.tags.length && (s.before = e.sheet.tags[0]),
            u !== null &&
              ((l = !0), u.setAttribute("data-emotion", o), s.hydrate([u])),
            (i.current = [s, l]),
            function () {
              s.flush();
            }
          );
        },
        [e]
      ),
      Qb(
        function () {
          var o = i.current,
            s = o[0],
            l = o[1];
          if (l) {
            o[1] = !1;
            return;
          }
          if ((r.next !== void 0 && JC(e, r.next, !0), s.tags.length)) {
            var u = s.tags[s.tags.length - 1].nextElementSibling;
            (s.before = u), s.flush();
          }
          e.insert("", r, s, !1);
        },
        [e, r.name]
      ),
      null
    );
  });
function bS() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return wS(e);
}
var Ym = function () {
    var e = bS.apply(void 0, arguments),
      t = "animation-" + e.name;
    return {
      name: t,
      styles: "@keyframes " + t + "{" + e.styles + "}",
      anim: 1,
      toString: function () {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      },
    };
  },
  PI = W3,
  II = function (e) {
    return e !== "theme";
  },
  eM = function (e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? PI : II;
  },
  tM = function (e, t, r) {
    var i;
    if (t) {
      var o = t.shouldForwardProp;
      i =
        e.__emotion_forwardProp && o
          ? function (s) {
              return e.__emotion_forwardProp(s) && o(s);
            }
          : o;
    }
    return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
  },
  LI = function (e) {
    var t = e.cache,
      r = e.serialized,
      i = e.isStringTag;
    return (
      ZC(t, r, i),
      CI(function () {
        return JC(t, r, i);
      }),
      null
    );
  },
  kI = function n(e, t) {
    var r = e.__emotion_real === e,
      i = (r && e.__emotion_base) || e,
      o,
      s;
    t !== void 0 && ((o = t.label), (s = t.target));
    var l = tM(e, t, r),
      u = l || eM(i),
      f = !u("as");
    return function () {
      var h = arguments,
        m =
          r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (
        (o !== void 0 && m.push("label:" + o + ";"),
        h[0] == null || h[0].raw === void 0)
      )
        m.push.apply(m, h);
      else {
        m.push(h[0][0]);
        for (var g = h.length, y = 1; y < g; y++) m.push(h[y], h[0][y]);
      }
      var x = n2(function (S, _, w) {
        var T = (f && S.as) || i,
          E = "",
          A = [],
          R = S;
        if (S.theme == null) {
          R = {};
          for (var k in S) R[k] = S[k];
          R.theme = K.useContext(py);
        }
        typeof S.className == "string"
          ? (E = _I(_.registered, A, S.className))
          : S.className != null && (E = S.className + " ");
        var P = wS(m.concat(A), _.registered, R);
        (E += _.key + "-" + P.name), s !== void 0 && (E += " " + s);
        var U = f && l === void 0 ? eM(T) : u,
          N = {};
        for (var L in S) (f && L === "as") || (U(L) && (N[L] = S[L]));
        return (
          (N.className = E),
          w && (N.ref = w),
          K.createElement(
            K.Fragment,
            null,
            K.createElement(LI, {
              cache: _,
              serialized: P,
              isStringTag: typeof T == "string",
            }),
            K.createElement(T, N)
          )
        );
      });
      return (
        (x.displayName =
          o !== void 0
            ? o
            : "Styled(" +
              (typeof i == "string"
                ? i
                : i.displayName || i.name || "Component") +
              ")"),
        (x.defaultProps = e.defaultProps),
        (x.__emotion_real = x),
        (x.__emotion_base = i),
        (x.__emotion_styles = m),
        (x.__emotion_forwardProp = l),
        Object.defineProperty(x, "toString", {
          value: function () {
            return "." + s;
          },
        }),
        (x.withComponent = function (S, _) {
          return n(S, ue({}, t, _, { shouldForwardProp: tM(x, _, !0) })).apply(
            void 0,
            m
          );
        }),
        x
      );
    };
  },
  DI = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  I1 = kI.bind();
DI.forEach(function (n) {
  I1[n] = I1(n);
});
let L1;
typeof document == "object" && (L1 = KC({ key: "css", prepend: !0 }));
function NI(n) {
  const { injectFirst: e, children: t } = n;
  return e && L1 ? Q.jsx(AI, { value: L1, children: t }) : t;
}
function OI(n) {
  return n == null || Object.keys(n).length === 0;
}
function r2(n) {
  const { styles: e, defaultTheme: t = {} } = n,
    r = typeof e == "function" ? (i) => e(OI(i) ? t : i) : e;
  return Q.jsx(RI, { styles: r });
}
function MS(n, e) {
  return I1(n, e);
}
const i2 = (n, e) => {
    Array.isArray(n.__emotion_styles) &&
      (n.__emotion_styles = e(n.__emotion_styles));
  },
  UI = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        GlobalStyles: r2,
        StyledEngineProvider: NI,
        ThemeContext: py,
        css: bS,
        default: MS,
        internal_processStyles: i2,
        keyframes: Ym,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
function Tl(n) {
  if (typeof n != "object" || n === null) return !1;
  const e = Object.getPrototypeOf(n);
  return (
    (e === null ||
      e === Object.prototype ||
      Object.getPrototypeOf(e) === null) &&
    !(Symbol.toStringTag in n) &&
    !(Symbol.iterator in n)
  );
}
function o2(n) {
  if (K.isValidElement(n) || !Tl(n)) return n;
  const e = {};
  return (
    Object.keys(n).forEach((t) => {
      e[t] = o2(n[t]);
    }),
    e
  );
}
function ni(n, e, t = { clone: !0 }) {
  const r = t.clone ? ue({}, n) : n;
  return (
    Tl(n) &&
      Tl(e) &&
      Object.keys(e).forEach((i) => {
        K.isValidElement(e[i])
          ? (r[i] = e[i])
          : Tl(e[i]) && Object.prototype.hasOwnProperty.call(n, i) && Tl(n[i])
          ? (r[i] = ni(n[i], e[i], t))
          : t.clone
          ? (r[i] = Tl(e[i]) ? o2(e[i]) : e[i])
          : (r[i] = e[i]);
      }),
    r
  );
}
const FI = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: ni, isPlainObject: Tl },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  BI = ["values", "unit", "step"],
  zI = (n) => {
    const e = Object.keys(n).map((t) => ({ key: t, val: n[t] })) || [];
    return (
      e.sort((t, r) => t.val - r.val),
      e.reduce((t, r) => ue({}, t, { [r.key]: r.val }), {})
    );
  };
function ES(n) {
  const {
      values: e = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
      unit: t = "px",
      step: r = 5,
    } = n,
    i = Pt(n, BI),
    o = zI(e),
    s = Object.keys(o);
  function l(g) {
    return `@media (min-width:${typeof e[g] == "number" ? e[g] : g}${t})`;
  }
  function u(g) {
    return `@media (max-width:${
      (typeof e[g] == "number" ? e[g] : g) - r / 100
    }${t})`;
  }
  function f(g, y) {
    const x = s.indexOf(y);
    return `@media (min-width:${
      typeof e[g] == "number" ? e[g] : g
    }${t}) and (max-width:${
      (x !== -1 && typeof e[s[x]] == "number" ? e[s[x]] : y) - r / 100
    }${t})`;
  }
  function h(g) {
    return s.indexOf(g) + 1 < s.length ? f(g, s[s.indexOf(g) + 1]) : l(g);
  }
  function m(g) {
    const y = s.indexOf(g);
    return y === 0
      ? l(s[1])
      : y === s.length - 1
      ? u(s[y])
      : f(g, s[s.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return ue(
    {
      keys: s,
      values: o,
      up: l,
      down: u,
      between: f,
      only: h,
      not: m,
      unit: t,
    },
    i
  );
}
const HI = { borderRadius: 4 };
function tm(n, e) {
  return e ? ni(n, e, { clone: !1 }) : n;
}
const TS = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
  nM = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (n) => `@media (min-width:${TS[n]}px)`,
  };
function sa(n, e, t) {
  const r = n.theme || {};
  if (Array.isArray(e)) {
    const o = r.breakpoints || nM;
    return e.reduce((s, l, u) => ((s[o.up(o.keys[u])] = t(e[u])), s), {});
  }
  if (typeof e == "object") {
    const o = r.breakpoints || nM;
    return Object.keys(e).reduce((s, l) => {
      if (Object.keys(o.values || TS).indexOf(l) !== -1) {
        const u = o.up(l);
        s[u] = t(e[l], l);
      } else {
        const u = l;
        s[u] = e[u];
      }
      return s;
    }, {});
  }
  return t(e);
}
function s2(n = {}) {
  var e;
  return (
    ((e = n.keys) == null
      ? void 0
      : e.reduce((r, i) => {
          const o = n.up(i);
          return (r[o] = {}), r;
        }, {})) || {}
  );
}
function a2(n, e) {
  return n.reduce((t, r) => {
    const i = t[r];
    return (!i || Object.keys(i).length === 0) && delete t[r], t;
  }, e);
}
function VI(n, ...e) {
  const t = s2(n),
    r = [t, ...e].reduce((i, o) => ni(i, o), {});
  return a2(Object.keys(t), r);
}
function GI(n, e) {
  if (typeof n != "object") return {};
  const t = {},
    r = Object.keys(e);
  return (
    Array.isArray(n)
      ? r.forEach((i, o) => {
          o < n.length && (t[i] = !0);
        })
      : r.forEach((i) => {
          n[i] != null && (t[i] = !0);
        }),
    t
  );
}
function Qx({ values: n, breakpoints: e, base: t }) {
  const r = t || GI(n, e),
    i = Object.keys(r);
  if (i.length === 0) return n;
  let o;
  return i.reduce(
    (s, l, u) => (
      Array.isArray(n)
        ? ((s[l] = n[u] != null ? n[u] : n[o]), (o = u))
        : typeof n == "object"
        ? ((s[l] = n[l] != null ? n[l] : n[o]), (o = l))
        : (s[l] = n),
      s
    ),
    {}
  );
}
function an(n) {
  if (typeof n != "string") throw new Error(Ll(7));
  return n.charAt(0).toUpperCase() + n.slice(1);
}
const WI = Object.freeze(
  Object.defineProperty({ __proto__: null, default: an }, Symbol.toStringTag, {
    value: "Module",
  })
);
function my(n, e, t = !0) {
  if (!e || typeof e != "string") return null;
  if (n && n.vars && t) {
    const r = `vars.${e}`
      .split(".")
      .reduce((i, o) => (i && i[o] ? i[o] : null), n);
    if (r != null) return r;
  }
  return e.split(".").reduce((r, i) => (r && r[i] != null ? r[i] : null), n);
}
function v0(n, e, t, r = t) {
  let i;
  return (
    typeof n == "function"
      ? (i = n(t))
      : Array.isArray(n)
      ? (i = n[t] || r)
      : (i = my(n, t) || r),
    e && (i = e(i, r, n)),
    i
  );
}
function Ur(n) {
  const { prop: e, cssProperty: t = n.prop, themeKey: r, transform: i } = n,
    o = (s) => {
      if (s[e] == null) return null;
      const l = s[e],
        u = s.theme,
        f = my(u, r) || {};
      return sa(s, l, (m) => {
        let g = v0(f, i, m);
        return (
          m === g &&
            typeof m == "string" &&
            (g = v0(f, i, `${e}${m === "default" ? "" : an(m)}`, m)),
          t === !1 ? g : { [t]: g }
        );
      });
    };
  return (o.propTypes = {}), (o.filterProps = [e]), o;
}
function jI(n) {
  const e = {};
  return (t) => (e[t] === void 0 && (e[t] = n(t)), e[t]);
}
const $I = { m: "margin", p: "padding" },
  XI = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"],
  },
  rM = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" },
  YI = jI((n) => {
    if (n.length > 2)
      if (rM[n]) n = rM[n];
      else return [n];
    const [e, t] = n.split(""),
      r = $I[e],
      i = XI[t] || "";
    return Array.isArray(i) ? i.map((o) => r + o) : [r + i];
  }),
  CS = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",
    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",
  ],
  AS = [
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
  ];
[...CS, ...AS];
function qm(n, e, t, r) {
  var i;
  const o = (i = my(n, e, !1)) != null ? i : t;
  return typeof o == "number"
    ? (s) => (typeof s == "string" ? s : o * s)
    : Array.isArray(o)
    ? (s) => (typeof s == "string" ? s : o[s])
    : typeof o == "function"
    ? o
    : () => {};
}
function RS(n) {
  return qm(n, "spacing", 8);
}
function vf(n, e) {
  if (typeof e == "string" || e == null) return e;
  const t = Math.abs(e),
    r = n(t);
  return e >= 0 ? r : typeof r == "number" ? -r : `-${r}`;
}
function qI(n, e) {
  return (t) => n.reduce((r, i) => ((r[i] = vf(e, t)), r), {});
}
function KI(n, e, t, r) {
  if (e.indexOf(t) === -1) return null;
  const i = YI(t),
    o = qI(i, r),
    s = n[t];
  return sa(n, s, o);
}
function l2(n, e) {
  const t = RS(n.theme);
  return Object.keys(n)
    .map((r) => KI(n, e, r, t))
    .reduce(tm, {});
}
function Mr(n) {
  return l2(n, CS);
}
Mr.propTypes = {};
Mr.filterProps = CS;
function Er(n) {
  return l2(n, AS);
}
Er.propTypes = {};
Er.filterProps = AS;
function u2(n = 8) {
  if (n.mui) return n;
  const e = RS({ spacing: n }),
    t = (...r) =>
      (r.length === 0 ? [1] : r)
        .map((o) => {
          const s = e(o);
          return typeof s == "number" ? `${s}px` : s;
        })
        .join(" ");
  return (t.mui = !0), t;
}
function gy(...n) {
  const e = n.reduce(
      (r, i) => (
        i.filterProps.forEach((o) => {
          r[o] = i;
        }),
        r
      ),
      {}
    ),
    t = (r) => Object.keys(r).reduce((i, o) => (e[o] ? tm(i, e[o](r)) : i), {});
  return (
    (t.propTypes = {}),
    (t.filterProps = n.reduce((r, i) => r.concat(i.filterProps), [])),
    t
  );
}
function Es(n) {
  return typeof n != "number" ? n : `${n}px solid`;
}
function Rs(n, e) {
  return Ur({ prop: n, themeKey: "borders", transform: e });
}
const ZI = Rs("border", Es),
  JI = Rs("borderTop", Es),
  QI = Rs("borderRight", Es),
  eL = Rs("borderBottom", Es),
  tL = Rs("borderLeft", Es),
  nL = Rs("borderColor"),
  rL = Rs("borderTopColor"),
  iL = Rs("borderRightColor"),
  oL = Rs("borderBottomColor"),
  sL = Rs("borderLeftColor"),
  aL = Rs("outline", Es),
  lL = Rs("outlineColor"),
  vy = (n) => {
    if (n.borderRadius !== void 0 && n.borderRadius !== null) {
      const e = qm(n.theme, "shape.borderRadius", 4),
        t = (r) => ({ borderRadius: vf(e, r) });
      return sa(n, n.borderRadius, t);
    }
    return null;
  };
vy.propTypes = {};
vy.filterProps = ["borderRadius"];
gy(ZI, JI, QI, eL, tL, nL, rL, iL, oL, sL, vy, aL, lL);
const yy = (n) => {
  if (n.gap !== void 0 && n.gap !== null) {
    const e = qm(n.theme, "spacing", 8),
      t = (r) => ({ gap: vf(e, r) });
    return sa(n, n.gap, t);
  }
  return null;
};
yy.propTypes = {};
yy.filterProps = ["gap"];
const xy = (n) => {
  if (n.columnGap !== void 0 && n.columnGap !== null) {
    const e = qm(n.theme, "spacing", 8),
      t = (r) => ({ columnGap: vf(e, r) });
    return sa(n, n.columnGap, t);
  }
  return null;
};
xy.propTypes = {};
xy.filterProps = ["columnGap"];
const _y = (n) => {
  if (n.rowGap !== void 0 && n.rowGap !== null) {
    const e = qm(n.theme, "spacing", 8),
      t = (r) => ({ rowGap: vf(e, r) });
    return sa(n, n.rowGap, t);
  }
  return null;
};
_y.propTypes = {};
_y.filterProps = ["rowGap"];
const uL = Ur({ prop: "gridColumn" }),
  cL = Ur({ prop: "gridRow" }),
  fL = Ur({ prop: "gridAutoFlow" }),
  dL = Ur({ prop: "gridAutoColumns" }),
  hL = Ur({ prop: "gridAutoRows" }),
  pL = Ur({ prop: "gridTemplateColumns" }),
  mL = Ur({ prop: "gridTemplateRows" }),
  gL = Ur({ prop: "gridTemplateAreas" }),
  vL = Ur({ prop: "gridArea" });
gy(yy, xy, _y, uL, cL, fL, dL, hL, pL, mL, gL, vL);
function ph(n, e) {
  return e === "grey" ? e : n;
}
const yL = Ur({ prop: "color", themeKey: "palette", transform: ph }),
  xL = Ur({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: ph,
  }),
  _L = Ur({ prop: "backgroundColor", themeKey: "palette", transform: ph });
gy(yL, xL, _L);
function ns(n) {
  return n <= 1 && n !== 0 ? `${n * 100}%` : n;
}
const SL = Ur({ prop: "width", transform: ns }),
  PS = (n) => {
    if (n.maxWidth !== void 0 && n.maxWidth !== null) {
      const e = (t) => {
        var r, i;
        const o =
          ((r = n.theme) == null ||
          (r = r.breakpoints) == null ||
          (r = r.values) == null
            ? void 0
            : r[t]) || TS[t];
        return o
          ? ((i = n.theme) == null || (i = i.breakpoints) == null
              ? void 0
              : i.unit) !== "px"
            ? { maxWidth: `${o}${n.theme.breakpoints.unit}` }
            : { maxWidth: o }
          : { maxWidth: ns(t) };
      };
      return sa(n, n.maxWidth, e);
    }
    return null;
  };
PS.filterProps = ["maxWidth"];
const wL = Ur({ prop: "minWidth", transform: ns }),
  bL = Ur({ prop: "height", transform: ns }),
  ML = Ur({ prop: "maxHeight", transform: ns }),
  EL = Ur({ prop: "minHeight", transform: ns });
Ur({ prop: "size", cssProperty: "width", transform: ns });
Ur({ prop: "size", cssProperty: "height", transform: ns });
const TL = Ur({ prop: "boxSizing" });
gy(SL, PS, wL, bL, ML, EL, TL);
const Ih = {
  border: { themeKey: "borders", transform: Es },
  borderTop: { themeKey: "borders", transform: Es },
  borderRight: { themeKey: "borders", transform: Es },
  borderBottom: { themeKey: "borders", transform: Es },
  borderLeft: { themeKey: "borders", transform: Es },
  borderColor: { themeKey: "palette" },
  borderTopColor: { themeKey: "palette" },
  borderRightColor: { themeKey: "palette" },
  borderBottomColor: { themeKey: "palette" },
  borderLeftColor: { themeKey: "palette" },
  outline: { themeKey: "borders", transform: Es },
  outlineColor: { themeKey: "palette" },
  borderRadius: { themeKey: "shape.borderRadius", style: vy },
  color: { themeKey: "palette", transform: ph },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: ph,
  },
  backgroundColor: { themeKey: "palette", transform: ph },
  p: { style: Er },
  pt: { style: Er },
  pr: { style: Er },
  pb: { style: Er },
  pl: { style: Er },
  px: { style: Er },
  py: { style: Er },
  padding: { style: Er },
  paddingTop: { style: Er },
  paddingRight: { style: Er },
  paddingBottom: { style: Er },
  paddingLeft: { style: Er },
  paddingX: { style: Er },
  paddingY: { style: Er },
  paddingInline: { style: Er },
  paddingInlineStart: { style: Er },
  paddingInlineEnd: { style: Er },
  paddingBlock: { style: Er },
  paddingBlockStart: { style: Er },
  paddingBlockEnd: { style: Er },
  m: { style: Mr },
  mt: { style: Mr },
  mr: { style: Mr },
  mb: { style: Mr },
  ml: { style: Mr },
  mx: { style: Mr },
  my: { style: Mr },
  margin: { style: Mr },
  marginTop: { style: Mr },
  marginRight: { style: Mr },
  marginBottom: { style: Mr },
  marginLeft: { style: Mr },
  marginX: { style: Mr },
  marginY: { style: Mr },
  marginInline: { style: Mr },
  marginInlineStart: { style: Mr },
  marginInlineEnd: { style: Mr },
  marginBlock: { style: Mr },
  marginBlockStart: { style: Mr },
  marginBlockEnd: { style: Mr },
  displayPrint: {
    cssProperty: !1,
    transform: (n) => ({ "@media print": { display: n } }),
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  gap: { style: yy },
  rowGap: { style: _y },
  columnGap: { style: xy },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  position: {},
  zIndex: { themeKey: "zIndex" },
  top: {},
  right: {},
  bottom: {},
  left: {},
  boxShadow: { themeKey: "shadows" },
  width: { transform: ns },
  maxWidth: { style: PS },
  minWidth: { transform: ns },
  height: { transform: ns },
  maxHeight: { transform: ns },
  minHeight: { transform: ns },
  boxSizing: {},
  fontFamily: { themeKey: "typography" },
  fontSize: { themeKey: "typography" },
  fontStyle: { themeKey: "typography" },
  fontWeight: { themeKey: "typography" },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: { cssProperty: !1, themeKey: "typography" },
};
function CL(...n) {
  const e = n.reduce((r, i) => r.concat(Object.keys(i)), []),
    t = new Set(e);
  return n.every((r) => t.size === Object.keys(r).length);
}
function AL(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function c2() {
  function n(t, r, i, o) {
    const s = { [t]: r, theme: i },
      l = o[t];
    if (!l) return { [t]: r };
    const { cssProperty: u = t, themeKey: f, transform: h, style: m } = l;
    if (r == null) return null;
    if (f === "typography" && r === "inherit") return { [t]: r };
    const g = my(i, f) || {};
    return m
      ? m(s)
      : sa(s, r, (x) => {
          let S = v0(g, h, x);
          return (
            x === S &&
              typeof x == "string" &&
              (S = v0(g, h, `${t}${x === "default" ? "" : an(x)}`, x)),
            u === !1 ? S : { [u]: S }
          );
        });
  }
  function e(t) {
    var r;
    const { sx: i, theme: o = {} } = t || {};
    if (!i) return null;
    const s = (r = o.unstable_sxConfig) != null ? r : Ih;
    function l(u) {
      let f = u;
      if (typeof u == "function") f = u(o);
      else if (typeof u != "object") return u;
      if (!f) return null;
      const h = s2(o.breakpoints),
        m = Object.keys(h);
      let g = h;
      return (
        Object.keys(f).forEach((y) => {
          const x = AL(f[y], o);
          if (x != null)
            if (typeof x == "object")
              if (s[y]) g = tm(g, n(y, x, o, s));
              else {
                const S = sa({ theme: o }, x, (_) => ({ [y]: _ }));
                CL(S, x) ? (g[y] = e({ sx: x, theme: o })) : (g = tm(g, S));
              }
            else g = tm(g, n(y, x, o, s));
        }),
        a2(m, g)
      );
    }
    return Array.isArray(i) ? i.map(l) : l(i);
  }
  return e;
}
const Mf = c2();
Mf.filterProps = ["sx"];
function IS(n, e) {
  const t = this;
  return t.vars && typeof t.getColorSchemeSelector == "function"
    ? {
        [t.getColorSchemeSelector(n).replace(/(\[[^\]]+\])/, "*:where($1)")]: e,
      }
    : t.palette.mode === n
    ? e
    : {};
}
const RL = ["breakpoints", "palette", "spacing", "shape"];
function Km(n = {}, ...e) {
  const { breakpoints: t = {}, palette: r = {}, spacing: i, shape: o = {} } = n,
    s = Pt(n, RL),
    l = ES(t),
    u = u2(i);
  let f = ni(
    {
      breakpoints: l,
      direction: "ltr",
      components: {},
      palette: ue({ mode: "light" }, r),
      spacing: u,
      shape: ue({}, HI, o),
    },
    s
  );
  return (
    (f.applyStyles = IS),
    (f = e.reduce((h, m) => ni(h, m), f)),
    (f.unstable_sxConfig = ue(
      {},
      Ih,
      s == null ? void 0 : s.unstable_sxConfig
    )),
    (f.unstable_sx = function (m) {
      return Mf({ sx: m, theme: this });
    }),
    f
  );
}
const PL = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      default: Km,
      private_createBreakpoints: ES,
      unstable_applyStyles: IS,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
function IL(n) {
  return Object.keys(n).length === 0;
}
function LL(n = null) {
  const e = K.useContext(py);
  return !e || IL(e) ? n : e;
}
const kL = Km();
function Sy(n = kL) {
  return LL(n);
}
function DL({ styles: n, themeId: e, defaultTheme: t = {} }) {
  const r = Sy(t),
    i = typeof n == "function" ? n((e && r[e]) || r) : n;
  return Q.jsx(r2, { styles: i });
}
const NL = ["sx"],
  OL = (n) => {
    var e, t;
    const r = { systemProps: {}, otherProps: {} },
      i =
        (e =
          n == null || (t = n.theme) == null ? void 0 : t.unstable_sxConfig) !=
        null
          ? e
          : Ih;
    return (
      Object.keys(n).forEach((o) => {
        i[o] ? (r.systemProps[o] = n[o]) : (r.otherProps[o] = n[o]);
      }),
      r
    );
  };
function wy(n) {
  const { sx: e } = n,
    t = Pt(n, NL),
    { systemProps: r, otherProps: i } = OL(t);
  let o;
  return (
    Array.isArray(e)
      ? (o = [r, ...e])
      : typeof e == "function"
      ? (o = (...s) => {
          const l = e(...s);
          return Tl(l) ? ue({}, r, l) : r;
        })
      : (o = ue({}, r, e)),
    ue({}, i, { sx: o })
  );
}
const UL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        default: Mf,
        extendSxProp: wy,
        unstable_createStyleFunctionSx: c2,
        unstable_defaultSxConfig: Ih,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  iM = (n) => n,
  FL = () => {
    let n = iM;
    return {
      configure(e) {
        n = e;
      },
      generate(e) {
        return n(e);
      },
      reset() {
        n = iM;
      },
    };
  },
  LS = FL();
function f2(n) {
  var e,
    t,
    r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object")
    if (Array.isArray(n)) {
      var i = n.length;
      for (e = 0; e < i; e++)
        n[e] && (t = f2(n[e])) && (r && (r += " "), (r += t));
    } else for (t in n) n[t] && (r && (r += " "), (r += t));
  return r;
}
function Zt() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++)
    (n = arguments[t]) && (e = f2(n)) && (r && (r += " "), (r += e));
  return r;
}
const BL = ["className", "component"];
function zL(n = {}) {
  const {
      themeId: e,
      defaultTheme: t,
      defaultClassName: r = "MuiBox-root",
      generateClassName: i,
    } = n,
    o = MS("div", {
      shouldForwardProp: (l) => l !== "theme" && l !== "sx" && l !== "as",
    })(Mf);
  return K.forwardRef(function (u, f) {
    const h = Sy(t),
      m = wy(u),
      { className: g, component: y = "div" } = m,
      x = Pt(m, BL);
    return Q.jsx(
      o,
      ue(
        {
          as: y,
          ref: f,
          className: Zt(g, i ? i(r) : r),
          theme: (e && h[e]) || h,
        },
        x
      )
    );
  });
}
const HL = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected",
};
function Un(n, e, t = "Mui") {
  const r = HL[e];
  return r ? `${t}-${r}` : `${LS.generate(n)}-${e}`;
}
function In(n, e, t = "Mui") {
  const r = {};
  return (
    e.forEach((i) => {
      r[i] = Un(n, i, t);
    }),
    r
  );
}
var e_ = { exports: {} },
  Vn = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var oM;
function VL() {
  if (oM) return Vn;
  oM = 1;
  var n = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.consumer"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.forward_ref"),
    u = Symbol.for("react.suspense"),
    f = Symbol.for("react.suspense_list"),
    h = Symbol.for("react.memo"),
    m = Symbol.for("react.lazy"),
    g = Symbol.for("react.view_transition"),
    y = Symbol.for("react.client.reference");
  function x(S) {
    if (typeof S == "object" && S !== null) {
      var _ = S.$$typeof;
      switch (_) {
        case n:
          switch (((S = S.type), S)) {
            case t:
            case i:
            case r:
            case u:
            case f:
            case g:
              return S;
            default:
              switch (((S = S && S.$$typeof), S)) {
                case s:
                case l:
                case m:
                case h:
                  return S;
                case o:
                  return S;
                default:
                  return _;
              }
          }
        case e:
          return _;
      }
    }
  }
  return (
    (Vn.ContextConsumer = o),
    (Vn.ContextProvider = s),
    (Vn.Element = n),
    (Vn.ForwardRef = l),
    (Vn.Fragment = t),
    (Vn.Lazy = m),
    (Vn.Memo = h),
    (Vn.Portal = e),
    (Vn.Profiler = i),
    (Vn.StrictMode = r),
    (Vn.Suspense = u),
    (Vn.SuspenseList = f),
    (Vn.isContextConsumer = function (S) {
      return x(S) === o;
    }),
    (Vn.isContextProvider = function (S) {
      return x(S) === s;
    }),
    (Vn.isElement = function (S) {
      return typeof S == "object" && S !== null && S.$$typeof === n;
    }),
    (Vn.isForwardRef = function (S) {
      return x(S) === l;
    }),
    (Vn.isFragment = function (S) {
      return x(S) === t;
    }),
    (Vn.isLazy = function (S) {
      return x(S) === m;
    }),
    (Vn.isMemo = function (S) {
      return x(S) === h;
    }),
    (Vn.isPortal = function (S) {
      return x(S) === e;
    }),
    (Vn.isProfiler = function (S) {
      return x(S) === i;
    }),
    (Vn.isStrictMode = function (S) {
      return x(S) === r;
    }),
    (Vn.isSuspense = function (S) {
      return x(S) === u;
    }),
    (Vn.isSuspenseList = function (S) {
      return x(S) === f;
    }),
    (Vn.isValidElementType = function (S) {
      return (
        typeof S == "string" ||
        typeof S == "function" ||
        S === t ||
        S === i ||
        S === r ||
        S === u ||
        S === f ||
        (typeof S == "object" &&
          S !== null &&
          (S.$$typeof === m ||
            S.$$typeof === h ||
            S.$$typeof === s ||
            S.$$typeof === o ||
            S.$$typeof === l ||
            S.$$typeof === y ||
            S.getModuleId !== void 0))
      );
    }),
    (Vn.typeOf = x),
    Vn
  );
}
var sM;
function GL() {
  return sM || ((sM = 1), (e_.exports = VL())), e_.exports;
}
var aM = GL();
const WL = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function d2(n) {
  const e = `${n}`.match(WL);
  return (e && e[1]) || "";
}
function h2(n, e = "") {
  return n.displayName || n.name || d2(n) || e;
}
function lM(n, e, t) {
  const r = h2(e);
  return n.displayName || (r !== "" ? `${t}(${r})` : t);
}
function jL(n) {
  if (n != null) {
    if (typeof n == "string") return n;
    if (typeof n == "function") return h2(n, "Component");
    if (typeof n == "object")
      switch (n.$$typeof) {
        case aM.ForwardRef:
          return lM(n, n.render, "ForwardRef");
        case aM.Memo:
          return lM(n, n.type, "memo");
        default:
          return;
      }
  }
}
const $L = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: jL, getFunctionName: d2 },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  XL = ["ownerState"],
  YL = ["variants"],
  qL = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function KL(n) {
  return Object.keys(n).length === 0;
}
function ZL(n) {
  return typeof n == "string" && n.charCodeAt(0) > 96;
}
function t_(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
const JL = Km(),
  QL = (n) => n && n.charAt(0).toLowerCase() + n.slice(1);
function sv({ defaultTheme: n, theme: e, themeId: t }) {
  return KL(e) ? n : e[t] || e;
}
function ek(n) {
  return n ? (e, t) => t[n] : null;
}
function c0(n, e) {
  let { ownerState: t } = e,
    r = Pt(e, XL);
  const i = typeof n == "function" ? n(ue({ ownerState: t }, r)) : n;
  if (Array.isArray(i))
    return i.flatMap((o) => c0(o, ue({ ownerState: t }, r)));
  if (i && typeof i == "object" && Array.isArray(i.variants)) {
    const { variants: o = [] } = i;
    let l = Pt(i, YL);
    return (
      o.forEach((u) => {
        let f = !0;
        typeof u.props == "function"
          ? (f = u.props(ue({ ownerState: t }, r, t)))
          : Object.keys(u.props).forEach((h) => {
              (t == null ? void 0 : t[h]) !== u.props[h] &&
                r[h] !== u.props[h] &&
                (f = !1);
            }),
          f &&
            (Array.isArray(l) || (l = [l]),
            l.push(
              typeof u.style == "function"
                ? u.style(ue({ ownerState: t }, r, t))
                : u.style
            ));
      }),
      l
    );
  }
  return i;
}
function p2(n = {}) {
  const {
      themeId: e,
      defaultTheme: t = JL,
      rootShouldForwardProp: r = t_,
      slotShouldForwardProp: i = t_,
    } = n,
    o = (s) =>
      Mf(ue({}, s, { theme: sv(ue({}, s, { defaultTheme: t, themeId: e })) }));
  return (
    (o.__mui_systemSx = !0),
    (s, l = {}) => {
      i2(s, (R) => R.filter((k) => !(k != null && k.__mui_systemSx)));
      const {
          name: u,
          slot: f,
          skipVariantsResolver: h,
          skipSx: m,
          overridesResolver: g = ek(QL(f)),
        } = l,
        y = Pt(l, qL),
        x = h !== void 0 ? h : (f && f !== "Root" && f !== "root") || !1,
        S = m || !1;
      let _,
        w = t_;
      f === "Root" || f === "root"
        ? (w = r)
        : f
        ? (w = i)
        : ZL(s) && (w = void 0);
      const T = MS(s, ue({ shouldForwardProp: w, label: _ }, y)),
        E = (R) =>
          (typeof R == "function" && R.__emotion_real !== R) || Tl(R)
            ? (k) =>
                c0(
                  R,
                  ue({}, k, {
                    theme: sv({ theme: k.theme, defaultTheme: t, themeId: e }),
                  })
                )
            : R,
        A = (R, ...k) => {
          let P = E(R);
          const U = k ? k.map(E) : [];
          u &&
            g &&
            U.push((H) => {
              const G = sv(ue({}, H, { defaultTheme: t, themeId: e }));
              if (
                !G.components ||
                !G.components[u] ||
                !G.components[u].styleOverrides
              )
                return null;
              const $ = G.components[u].styleOverrides,
                q = {};
              return (
                Object.entries($).forEach(([Z, X]) => {
                  q[Z] = c0(X, ue({}, H, { theme: G }));
                }),
                g(H, q)
              );
            }),
            u &&
              !x &&
              U.push((H) => {
                var G;
                const $ = sv(ue({}, H, { defaultTheme: t, themeId: e })),
                  q =
                    $ == null ||
                    (G = $.components) == null ||
                    (G = G[u]) == null
                      ? void 0
                      : G.variants;
                return c0({ variants: q }, ue({}, H, { theme: $ }));
              }),
            S || U.push(o);
          const N = U.length - k.length;
          if (Array.isArray(R) && N > 0) {
            const H = new Array(N).fill("");
            (P = [...R, ...H]), (P.raw = [...R.raw, ...H]);
          }
          const L = T(P, ...U);
          return s.muiName && (L.muiName = s.muiName), L;
        };
      return T.withConfig && (A.withConfig = T.withConfig), A;
    }
  );
}
const tk = p2();
function wm(n, e) {
  const t = ue({}, e);
  return (
    Object.keys(n).forEach((r) => {
      if (r.toString().match(/^(components|slots)$/)) t[r] = ue({}, n[r], t[r]);
      else if (r.toString().match(/^(componentsProps|slotProps)$/)) {
        const i = n[r] || {},
          o = e[r];
        (t[r] = {}),
          !o || !Object.keys(o)
            ? (t[r] = i)
            : !i || !Object.keys(i)
            ? (t[r] = o)
            : ((t[r] = ue({}, o)),
              Object.keys(i).forEach((s) => {
                t[r][s] = wm(i[s], o[s]);
              }));
      } else t[r] === void 0 && (t[r] = n[r]);
    }),
    t
  );
}
function nk(n) {
  const { theme: e, name: t, props: r } = n;
  return !e ||
    !e.components ||
    !e.components[t] ||
    !e.components[t].defaultProps
    ? r
    : wm(e.components[t].defaultProps, r);
}
function m2({ props: n, name: e, defaultTheme: t, themeId: r }) {
  let i = Sy(t);
  return r && (i = i[r] || i), nk({ theme: i, name: e, props: n });
}
const $a = typeof window < "u" ? K.useLayoutEffect : K.useEffect;
function rk(n, e = Number.MIN_SAFE_INTEGER, t = Number.MAX_SAFE_INTEGER) {
  return Math.max(e, Math.min(n, t));
}
const ik = Object.freeze(
  Object.defineProperty({ __proto__: null, default: rk }, Symbol.toStringTag, {
    value: "Module",
  })
);
function ok(n) {
  n = n.slice(1);
  const e = new RegExp(`.{1,${n.length >= 6 ? 2 : 1}}`, "g");
  let t = n.match(e);
  return (
    t && t[0].length === 1 && (t = t.map((r) => r + r)),
    t
      ? `rgb${t.length === 4 ? "a" : ""}(${t
          .map((r, i) =>
            i < 3
              ? parseInt(r, 16)
              : Math.round((parseInt(r, 16) / 255) * 1e3) / 1e3
          )
          .join(", ")})`
      : ""
  );
}
function g2(n) {
  if (n.type) return n;
  if (n.charAt(0) === "#") return g2(ok(n));
  const e = n.indexOf("("),
    t = n.substring(0, e);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(t) === -1)
    throw new Error(Ll(9, n));
  let r = n.substring(e + 1, n.length - 1),
    i;
  if (t === "color") {
    if (
      ((r = r.split(" ")),
      (i = r.shift()),
      r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)),
      ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(
        i
      ) === -1)
    )
      throw new Error(Ll(10, i));
  } else r = r.split(",");
  return (
    (r = r.map((o) => parseFloat(o))), { type: t, values: r, colorSpace: i }
  );
}
const Tc = (n) => {
  const e = g2(n);
  return e.values
    .slice(0, 3)
    .map((t, r) => (e.type.indexOf("hsl") !== -1 && r !== 0 ? `${t}%` : t))
    .join(" ");
};
function k1(...n) {
  return n.reduce(
    (e, t) =>
      t == null
        ? e
        : function (...i) {
            e.apply(this, i), t.apply(this, i);
          },
    () => {}
  );
}
function kS(n, e = 166) {
  let t;
  function r(...i) {
    const o = () => {
      n.apply(this, i);
    };
    clearTimeout(t), (t = setTimeout(o, e));
  }
  return (
    (r.clear = () => {
      clearTimeout(t);
    }),
    r
  );
}
function sk(n, e) {
  return () => null;
}
function nm(n, e) {
  var t, r;
  return (
    K.isValidElement(n) &&
    e.indexOf(
      (t = n.type.muiName) != null
        ? t
        : (r = n.type) == null ||
          (r = r._payload) == null ||
          (r = r.value) == null
        ? void 0
        : r.muiName
    ) !== -1
  );
}
function Uo(n) {
  return (n && n.ownerDocument) || document;
}
function Vu(n) {
  return Uo(n).defaultView || window;
}
function ak(n, e) {
  return () => null;
}
function y0(n, e) {
  typeof n == "function" ? n(e) : n && (n.current = e);
}
let uM = 0;
function lk(n) {
  const [e, t] = K.useState(n),
    r = n || e;
  return (
    K.useEffect(() => {
      e == null && ((uM += 1), t(`mui-${uM}`));
    }, [e]),
    r
  );
}
const cM = A1.useId;
function DS(n) {
  if (cM !== void 0) {
    const e = cM();
    return n ?? e;
  }
  return lk(n);
}
function uk(n, e, t, r, i) {
  return null;
}
function D1({ controlled: n, default: e, name: t, state: r = "value" }) {
  const { current: i } = K.useRef(n !== void 0),
    [o, s] = K.useState(e),
    l = i ? n : o,
    u = K.useCallback((f) => {
      i || s(f);
    }, []);
  return [l, u];
}
function rf(n) {
  const e = K.useRef(n);
  return (
    $a(() => {
      e.current = n;
    }),
    K.useRef((...t) => (0, e.current)(...t)).current
  );
}
function ri(...n) {
  return K.useMemo(
    () =>
      n.every((e) => e == null)
        ? null
        : (e) => {
            n.forEach((t) => {
              y0(t, e);
            });
          },
    n
  );
}
const fM = {};
function ck(n, e) {
  const t = K.useRef(fM);
  return t.current === fM && (t.current = n(e)), t;
}
const fk = [];
function dk(n) {
  K.useEffect(n, fk);
}
class by {
  constructor() {
    (this.currentId = null),
      (this.clear = () => {
        this.currentId !== null &&
          (clearTimeout(this.currentId), (this.currentId = null));
      }),
      (this.disposeEffect = () => this.clear);
  }
  static create() {
    return new by();
  }
  start(e, t) {
    this.clear(),
      (this.currentId = setTimeout(() => {
        (this.currentId = null), t();
      }, e));
  }
}
function v2() {
  const n = ck(by.create).current;
  return dk(n.disposeEffect), n;
}
let My = !0,
  N1 = !1;
const hk = new by(),
  pk = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    "datetime-local": !0,
  };
function mk(n) {
  const { type: e, tagName: t } = n;
  return !!(
    (t === "INPUT" && pk[e] && !n.readOnly) ||
    (t === "TEXTAREA" && !n.readOnly) ||
    n.isContentEditable
  );
}
function gk(n) {
  n.metaKey || n.altKey || n.ctrlKey || (My = !0);
}
function n_() {
  My = !1;
}
function vk() {
  this.visibilityState === "hidden" && N1 && (My = !0);
}
function yk(n) {
  n.addEventListener("keydown", gk, !0),
    n.addEventListener("mousedown", n_, !0),
    n.addEventListener("pointerdown", n_, !0),
    n.addEventListener("touchstart", n_, !0),
    n.addEventListener("visibilitychange", vk, !0);
}
function xk(n) {
  const { target: e } = n;
  try {
    return e.matches(":focus-visible");
  } catch {}
  return My || mk(e);
}
function NS() {
  const n = K.useCallback((i) => {
      i != null && yk(i.ownerDocument);
    }, []),
    e = K.useRef(!1);
  function t() {
    return e.current
      ? ((N1 = !0),
        hk.start(100, () => {
          N1 = !1;
        }),
        (e.current = !1),
        !0)
      : !1;
  }
  function r(i) {
    return xk(i) ? ((e.current = !0), !0) : !1;
  }
  return { isFocusVisibleRef: e, onFocus: r, onBlur: t, ref: n };
}
function y2(n) {
  const e = n.documentElement.clientWidth;
  return Math.abs(window.innerWidth - e);
}
function Fn(n, e, t = void 0) {
  const r = {};
  return (
    Object.keys(n).forEach((i) => {
      r[i] = n[i]
        .reduce((o, s) => {
          if (s) {
            const l = e(s);
            l !== "" && o.push(l), t && t[s] && o.push(t[s]);
          }
          return o;
        }, [])
        .join(" ");
    }),
    r
  );
}
function _h(n) {
  return typeof n == "string";
}
function x2(n, e, t) {
  return n === void 0 || _h(n)
    ? e
    : ue({}, e, { ownerState: ue({}, e.ownerState, t) });
}
function x0(n, e = []) {
  if (n === void 0) return {};
  const t = {};
  return (
    Object.keys(n)
      .filter(
        (r) =>
          r.match(/^on[A-Z]/) && typeof n[r] == "function" && !e.includes(r)
      )
      .forEach((r) => {
        t[r] = n[r];
      }),
    t
  );
}
function dM(n) {
  if (n === void 0) return {};
  const e = {};
  return (
    Object.keys(n)
      .filter((t) => !(t.match(/^on[A-Z]/) && typeof n[t] == "function"))
      .forEach((t) => {
        e[t] = n[t];
      }),
    e
  );
}
function _2(n) {
  const {
    getSlotProps: e,
    additionalProps: t,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: o,
  } = n;
  if (!e) {
    const y = Zt(
        t == null ? void 0 : t.className,
        o,
        i == null ? void 0 : i.className,
        r == null ? void 0 : r.className
      ),
      x = ue(
        {},
        t == null ? void 0 : t.style,
        i == null ? void 0 : i.style,
        r == null ? void 0 : r.style
      ),
      S = ue({}, t, i, r);
    return (
      y.length > 0 && (S.className = y),
      Object.keys(x).length > 0 && (S.style = x),
      { props: S, internalRef: void 0 }
    );
  }
  const s = x0(ue({}, i, r)),
    l = dM(r),
    u = dM(i),
    f = e(s),
    h = Zt(
      f == null ? void 0 : f.className,
      t == null ? void 0 : t.className,
      o,
      i == null ? void 0 : i.className,
      r == null ? void 0 : r.className
    ),
    m = ue(
      {},
      f == null ? void 0 : f.style,
      t == null ? void 0 : t.style,
      i == null ? void 0 : i.style,
      r == null ? void 0 : r.style
    ),
    g = ue({}, f, t, u, l);
  return (
    h.length > 0 && (g.className = h),
    Object.keys(m).length > 0 && (g.style = m),
    { props: g, internalRef: f.ref }
  );
}
function S2(n, e, t) {
  return typeof n == "function" ? n(e, t) : n;
}
const _k = [
  "elementType",
  "externalSlotProps",
  "ownerState",
  "skipResolvingSlotProps",
];
function Sh(n) {
  var e;
  const {
      elementType: t,
      externalSlotProps: r,
      ownerState: i,
      skipResolvingSlotProps: o = !1,
    } = n,
    s = Pt(n, _k),
    l = o ? {} : S2(r, i),
    { props: u, internalRef: f } = _2(ue({}, s, { externalSlotProps: l })),
    h = ri(
      f,
      l == null ? void 0 : l.ref,
      (e = n.additionalProps) == null ? void 0 : e.ref
    );
  return x2(t, ue({}, u, { ref: h }), i);
}
const Sk = K.createContext(),
  wk = () => {
    const n = K.useContext(Sk);
    return n ?? !1;
  },
  bk = K.createContext(void 0);
function Mk(n) {
  const { theme: e, name: t, props: r } = n;
  if (!e || !e.components || !e.components[t]) return r;
  const i = e.components[t];
  return i.defaultProps
    ? wm(i.defaultProps, r)
    : !i.styleOverrides && !i.variants
    ? wm(i, r)
    : r;
}
function Ek({ props: n, name: e }) {
  const t = K.useContext(bk);
  return Mk({ props: n, name: e, theme: { components: t } });
}
function Tk(n = "") {
  function e(...r) {
    if (!r.length) return "";
    const i = r[0];
    return typeof i == "string" &&
      !i.match(
        /(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/
      )
      ? `, var(--${n ? `${n}-` : ""}${i}${e(...r.slice(1))})`
      : `, ${i}`;
  }
  return (r, ...i) => `var(--${n ? `${n}-` : ""}${r}${e(...i)})`;
}
const hM = (n, e, t, r = []) => {
    let i = n;
    e.forEach((o, s) => {
      s === e.length - 1
        ? Array.isArray(i)
          ? (i[Number(o)] = t)
          : i && typeof i == "object" && (i[o] = t)
        : i &&
          typeof i == "object" &&
          (i[o] || (i[o] = r.includes(o) ? [] : {}), (i = i[o]));
    });
  },
  Ck = (n, e, t) => {
    function r(i, o = [], s = []) {
      Object.entries(i).forEach(([l, u]) => {
        (!t || (t && !t([...o, l]))) &&
          u != null &&
          (typeof u == "object" && Object.keys(u).length > 0
            ? r(u, [...o, l], Array.isArray(u) ? [...s, l] : s)
            : e([...o, l], u, s));
      });
    }
    r(n);
  },
  Ak = (n, e) =>
    typeof e == "number"
      ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) =>
          n.includes(r)
        ) || n[n.length - 1].toLowerCase().indexOf("opacity") >= 0
        ? e
        : `${e}px`
      : e;
function r_(n, e) {
  const { prefix: t, shouldSkipGeneratingVar: r } = e || {},
    i = {},
    o = {},
    s = {};
  return (
    Ck(
      n,
      (l, u, f) => {
        if (
          (typeof u == "string" || typeof u == "number") &&
          (!r || !r(l, u))
        ) {
          const h = `--${t ? `${t}-` : ""}${l.join("-")}`;
          Object.assign(i, { [h]: Ak(l, u) }),
            hM(o, l, `var(${h})`, f),
            hM(s, l, `var(${h}, ${u})`, f);
        }
      },
      (l) => l[0] === "vars"
    ),
    { css: i, vars: o, varsWithDefaults: s }
  );
}
function bm(n) {
  "@babel/helpers - typeof";
  return (
    (bm =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    bm(n)
  );
}
function Rk(n, e) {
  if (bm(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e);
    if (bm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function w2(n) {
  var e = Rk(n, "string");
  return bm(e) == "symbol" ? e : e + "";
}
const Pk = ["colorSchemes", "components", "defaultColorScheme"];
function Ik(n, e) {
  const { colorSchemes: t = {}, defaultColorScheme: r = "light" } = n,
    i = Pt(n, Pk),
    { vars: o, css: s, varsWithDefaults: l } = r_(i, e);
  let u = l;
  const f = {},
    { [r]: h } = t,
    m = Pt(t, [r].map(w2));
  if (
    (Object.entries(m || {}).forEach(([y, x]) => {
      const { vars: S, css: _, varsWithDefaults: w } = r_(x, e);
      (u = ni(u, w)), (f[y] = { css: _, vars: S });
    }),
    h)
  ) {
    const { css: y, vars: x, varsWithDefaults: S } = r_(h, e);
    (u = ni(u, S)), (f[r] = { css: y, vars: x });
  }
  return {
    vars: u,
    generateCssVars: (y) => {
      var x;
      if (!y) {
        var S;
        const w = ue({}, s);
        return {
          css: w,
          vars: o,
          selector:
            (e == null || (S = e.getSelector) == null
              ? void 0
              : S.call(e, y, w)) || ":root",
        };
      }
      const _ = ue({}, f[y].css);
      return {
        css: _,
        vars: f[y].vars,
        selector:
          (e == null || (x = e.getSelector) == null
            ? void 0
            : x.call(e, y, _)) || ":root",
      };
    },
  };
}
const Lk = [
    "component",
    "direction",
    "spacing",
    "divider",
    "children",
    "className",
    "useFlexGap",
  ],
  kk = Km(),
  Dk = tk("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  });
function Nk(n) {
  return m2({ props: n, name: "MuiStack", defaultTheme: kk });
}
function Ok(n, e) {
  const t = K.Children.toArray(n).filter(Boolean);
  return t.reduce(
    (r, i, o) => (
      r.push(i),
      o < t.length - 1 && r.push(K.cloneElement(e, { key: `separator-${o}` })),
      r
    ),
    []
  );
}
const Uk = (n) =>
    ({
      row: "Left",
      "row-reverse": "Right",
      column: "Top",
      "column-reverse": "Bottom",
    }[n]),
  Fk = ({ ownerState: n, theme: e }) => {
    let t = ue(
      { display: "flex", flexDirection: "column" },
      sa(
        { theme: e },
        Qx({ values: n.direction, breakpoints: e.breakpoints.values }),
        (r) => ({ flexDirection: r })
      )
    );
    if (n.spacing) {
      const r = RS(e),
        i = Object.keys(e.breakpoints.values).reduce(
          (u, f) => (
            ((typeof n.spacing == "object" && n.spacing[f] != null) ||
              (typeof n.direction == "object" && n.direction[f] != null)) &&
              (u[f] = !0),
            u
          ),
          {}
        ),
        o = Qx({ values: n.direction, base: i }),
        s = Qx({ values: n.spacing, base: i });
      typeof o == "object" &&
        Object.keys(o).forEach((u, f, h) => {
          if (!o[u]) {
            const g = f > 0 ? o[h[f - 1]] : "column";
            o[u] = g;
          }
        }),
        (t = ni(
          t,
          sa({ theme: e }, s, (u, f) =>
            n.useFlexGap
              ? { gap: vf(r, u) }
              : {
                  "& > :not(style):not(style)": { margin: 0 },
                  "& > :not(style) ~ :not(style)": {
                    [`margin${Uk(f ? o[f] : n.direction)}`]: vf(r, u),
                  },
                }
          )
        ));
    }
    return (t = VI(e.breakpoints, t)), t;
  };
function Bk(n = {}) {
  const {
      createStyledComponent: e = Dk,
      useThemeProps: t = Nk,
      componentName: r = "MuiStack",
    } = n,
    i = () => Fn({ root: ["root"] }, (u) => Un(r, u), {}),
    o = e(Fk);
  return K.forwardRef(function (u, f) {
    const h = t(u),
      m = wy(h),
      {
        component: g = "div",
        direction: y = "column",
        spacing: x = 0,
        divider: S,
        children: _,
        className: w,
        useFlexGap: T = !1,
      } = m,
      E = Pt(m, Lk),
      A = { direction: y, spacing: x, useFlexGap: T },
      R = i();
    return Q.jsx(
      o,
      ue({ as: g, ownerState: A, ref: f, className: Zt(R.root, w) }, E, {
        children: S ? Ok(_, S) : _,
      })
    );
  });
}
function zk(n, e) {
  return ue(
    {
      toolbar: {
        minHeight: 56,
        [n.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
        [n.up("sm")]: { minHeight: 64 },
      },
    },
    e
  );
}
var pr = {},
  i_ = { exports: {} },
  pM;
function OS() {
  return (
    pM ||
      ((pM = 1),
      (function (n) {
        function e(t) {
          return t && t.__esModule ? t : { default: t };
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(i_)),
    i_.exports
  );
}
const Hk = Ul(V3),
  Vk = Ul(ik);
var mM;
function Gk() {
  if (mM) return pr;
  mM = 1;
  var n = OS();
  Object.defineProperty(pr, "__esModule", { value: !0 }),
    (pr.alpha = x),
    (pr.blend = k),
    (pr.colorChannel = void 0),
    (pr.darken = _),
    (pr.decomposeColor = s),
    (pr.emphasize = A),
    (pr.getContrastRatio = y),
    (pr.getLuminance = g),
    (pr.hexToRgb = i),
    (pr.hslToRgb = m),
    (pr.lighten = T),
    (pr.private_safeAlpha = S),
    (pr.private_safeColorChannel = void 0),
    (pr.private_safeDarken = w),
    (pr.private_safeEmphasize = R),
    (pr.private_safeLighten = E),
    (pr.recomposeColor = f),
    (pr.rgbToHex = h);
  var e = n(Hk),
    t = n(Vk);
  function r(P, U = 0, N = 1) {
    return (0, t.default)(P, U, N);
  }
  function i(P) {
    P = P.slice(1);
    const U = new RegExp(`.{1,${P.length >= 6 ? 2 : 1}}`, "g");
    let N = P.match(U);
    return (
      N && N[0].length === 1 && (N = N.map((L) => L + L)),
      N
        ? `rgb${N.length === 4 ? "a" : ""}(${N.map((L, H) =>
            H < 3
              ? parseInt(L, 16)
              : Math.round((parseInt(L, 16) / 255) * 1e3) / 1e3
          ).join(", ")})`
        : ""
    );
  }
  function o(P) {
    const U = P.toString(16);
    return U.length === 1 ? `0${U}` : U;
  }
  function s(P) {
    if (P.type) return P;
    if (P.charAt(0) === "#") return s(i(P));
    const U = P.indexOf("("),
      N = P.substring(0, U);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(N) === -1)
      throw new Error((0, e.default)(9, P));
    let L = P.substring(U + 1, P.length - 1),
      H;
    if (N === "color") {
      if (
        ((L = L.split(" ")),
        (H = L.shift()),
        L.length === 4 && L[3].charAt(0) === "/" && (L[3] = L[3].slice(1)),
        ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(
          H
        ) === -1)
      )
        throw new Error((0, e.default)(10, H));
    } else L = L.split(",");
    return (
      (L = L.map((G) => parseFloat(G))), { type: N, values: L, colorSpace: H }
    );
  }
  const l = (P) => {
    const U = s(P);
    return U.values
      .slice(0, 3)
      .map((N, L) => (U.type.indexOf("hsl") !== -1 && L !== 0 ? `${N}%` : N))
      .join(" ");
  };
  pr.colorChannel = l;
  const u = (P, U) => {
    try {
      return l(P);
    } catch {
      return P;
    }
  };
  pr.private_safeColorChannel = u;
  function f(P) {
    const { type: U, colorSpace: N } = P;
    let { values: L } = P;
    return (
      U.indexOf("rgb") !== -1
        ? (L = L.map((H, G) => (G < 3 ? parseInt(H, 10) : H)))
        : U.indexOf("hsl") !== -1 && ((L[1] = `${L[1]}%`), (L[2] = `${L[2]}%`)),
      U.indexOf("color") !== -1
        ? (L = `${N} ${L.join(" ")}`)
        : (L = `${L.join(", ")}`),
      `${U}(${L})`
    );
  }
  function h(P) {
    if (P.indexOf("#") === 0) return P;
    const { values: U } = s(P);
    return `#${U.map((N, L) => o(L === 3 ? Math.round(255 * N) : N)).join("")}`;
  }
  function m(P) {
    P = s(P);
    const { values: U } = P,
      N = U[0],
      L = U[1] / 100,
      H = U[2] / 100,
      G = L * Math.min(H, 1 - H),
      $ = (X, re = (X + N / 30) % 12) =>
        H - G * Math.max(Math.min(re - 3, 9 - re, 1), -1);
    let q = "rgb";
    const Z = [
      Math.round($(0) * 255),
      Math.round($(8) * 255),
      Math.round($(4) * 255),
    ];
    return (
      P.type === "hsla" && ((q += "a"), Z.push(U[3])), f({ type: q, values: Z })
    );
  }
  function g(P) {
    P = s(P);
    let U = P.type === "hsl" || P.type === "hsla" ? s(m(P)).values : P.values;
    return (
      (U = U.map(
        (N) => (
          P.type !== "color" && (N /= 255),
          N <= 0.03928 ? N / 12.92 : ((N + 0.055) / 1.055) ** 2.4
        )
      )),
      Number((0.2126 * U[0] + 0.7152 * U[1] + 0.0722 * U[2]).toFixed(3))
    );
  }
  function y(P, U) {
    const N = g(P),
      L = g(U);
    return (Math.max(N, L) + 0.05) / (Math.min(N, L) + 0.05);
  }
  function x(P, U) {
    return (
      (P = s(P)),
      (U = r(U)),
      (P.type === "rgb" || P.type === "hsl") && (P.type += "a"),
      P.type === "color" ? (P.values[3] = `/${U}`) : (P.values[3] = U),
      f(P)
    );
  }
  function S(P, U, N) {
    try {
      return x(P, U);
    } catch {
      return P;
    }
  }
  function _(P, U) {
    if (((P = s(P)), (U = r(U)), P.type.indexOf("hsl") !== -1))
      P.values[2] *= 1 - U;
    else if (P.type.indexOf("rgb") !== -1 || P.type.indexOf("color") !== -1)
      for (let N = 0; N < 3; N += 1) P.values[N] *= 1 - U;
    return f(P);
  }
  function w(P, U, N) {
    try {
      return _(P, U);
    } catch {
      return P;
    }
  }
  function T(P, U) {
    if (((P = s(P)), (U = r(U)), P.type.indexOf("hsl") !== -1))
      P.values[2] += (100 - P.values[2]) * U;
    else if (P.type.indexOf("rgb") !== -1)
      for (let N = 0; N < 3; N += 1) P.values[N] += (255 - P.values[N]) * U;
    else if (P.type.indexOf("color") !== -1)
      for (let N = 0; N < 3; N += 1) P.values[N] += (1 - P.values[N]) * U;
    return f(P);
  }
  function E(P, U, N) {
    try {
      return T(P, U);
    } catch {
      return P;
    }
  }
  function A(P, U = 0.15) {
    return g(P) > 0.5 ? _(P, U) : T(P, U);
  }
  function R(P, U, N) {
    try {
      return A(P, U);
    } catch {
      return P;
    }
  }
  function k(P, U, N, L = 1) {
    const H = (Z, X) =>
        Math.round((Z ** (1 / L) * (1 - N) + X ** (1 / L) * N) ** L),
      G = s(P),
      $ = s(U),
      q = [
        H(G.values[0], $.values[0]),
        H(G.values[1], $.values[1]),
        H(G.values[2], $.values[2]),
      ];
    return f({ type: "rgb", values: q });
  }
  return pr;
}
var Di = Gk();
const Wk = ["mode", "contrastThreshold", "tonalOffset"],
  gM = {
    text: {
      primary: "rgba(0, 0, 0, 0.87)",
      secondary: "rgba(0, 0, 0, 0.6)",
      disabled: "rgba(0, 0, 0, 0.38)",
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: { paper: ym.white, default: ym.white },
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  },
  o_ = {
    text: {
      primary: ym.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)",
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: { paper: "#121212", default: "#121212" },
    action: {
      active: ym.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  };
function vM(n, e, t, r) {
  const i = r.light || r,
    o = r.dark || r * 1.5;
  n[e] ||
    (n.hasOwnProperty(t)
      ? (n[e] = n[t])
      : e === "light"
      ? (n.light = Di.lighten(n.main, i))
      : e === "dark" && (n.dark = Di.darken(n.main, o)));
}
function jk(n = "light") {
  return n === "dark"
    ? { main: Cd[200], light: Cd[50], dark: Cd[400] }
    : { main: Cd[700], light: Cd[400], dark: Cd[800] };
}
function $k(n = "light") {
  return n === "dark"
    ? { main: Td[200], light: Td[50], dark: Td[400] }
    : { main: Td[500], light: Td[300], dark: Td[700] };
}
function Xk(n = "light") {
  return n === "dark"
    ? { main: Ed[500], light: Ed[300], dark: Ed[700] }
    : { main: Ed[700], light: Ed[400], dark: Ed[800] };
}
function Yk(n = "light") {
  return n === "dark"
    ? { main: Ad[400], light: Ad[300], dark: Ad[700] }
    : { main: Ad[700], light: Ad[500], dark: Ad[900] };
}
function qk(n = "light") {
  return n === "dark"
    ? { main: Rd[400], light: Rd[300], dark: Rd[700] }
    : { main: Rd[800], light: Rd[500], dark: Rd[900] };
}
function Kk(n = "light") {
  return n === "dark"
    ? { main: Ep[400], light: Ep[300], dark: Ep[700] }
    : { main: "#ed6c02", light: Ep[500], dark: Ep[900] };
}
function Zk(n) {
  const {
      mode: e = "light",
      contrastThreshold: t = 3,
      tonalOffset: r = 0.2,
    } = n,
    i = Pt(n, Wk),
    o = n.primary || jk(e),
    s = n.secondary || $k(e),
    l = n.error || Xk(e),
    u = n.info || Yk(e),
    f = n.success || qk(e),
    h = n.warning || Kk(e);
  function m(S) {
    return Di.getContrastRatio(S, o_.text.primary) >= t
      ? o_.text.primary
      : gM.text.primary;
  }
  const g = ({
      color: S,
      name: _,
      mainShade: w = 500,
      lightShade: T = 300,
      darkShade: E = 700,
    }) => {
      if (
        ((S = ue({}, S)),
        !S.main && S[w] && (S.main = S[w]),
        !S.hasOwnProperty("main"))
      )
        throw new Error(Ll(11, _ ? ` (${_})` : "", w));
      if (typeof S.main != "string")
        throw new Error(Ll(12, _ ? ` (${_})` : "", JSON.stringify(S.main)));
      return (
        vM(S, "light", T, r),
        vM(S, "dark", E, r),
        S.contrastText || (S.contrastText = m(S.main)),
        S
      );
    },
    y = { dark: o_, light: gM };
  return ni(
    ue(
      {
        common: ue({}, ym),
        mode: e,
        primary: g({ color: o, name: "primary" }),
        secondary: g({
          color: s,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700",
        }),
        error: g({ color: l, name: "error" }),
        warning: g({ color: h, name: "warning" }),
        info: g({ color: u, name: "info" }),
        success: g({ color: f, name: "success" }),
        grey: H3,
        contrastThreshold: t,
        getContrastText: m,
        augmentColor: g,
        tonalOffset: r,
      },
      y[e]
    ),
    i
  );
}
const Jk = [
  "fontFamily",
  "fontSize",
  "fontWeightLight",
  "fontWeightRegular",
  "fontWeightMedium",
  "fontWeightBold",
  "htmlFontSize",
  "allVariants",
  "pxToRem",
];
function Qk(n) {
  return Math.round(n * 1e5) / 1e5;
}
const yM = { textTransform: "uppercase" },
  xM = '"Roboto", "Helvetica", "Arial", sans-serif';
function eD(n, e) {
  const t = typeof e == "function" ? e(n) : e,
    {
      fontFamily: r = xM,
      fontSize: i = 14,
      fontWeightLight: o = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: l = 500,
      fontWeightBold: u = 700,
      htmlFontSize: f = 16,
      allVariants: h,
      pxToRem: m,
    } = t,
    g = Pt(t, Jk),
    y = i / 14,
    x = m || ((w) => `${(w / f) * y}rem`),
    S = (w, T, E, A, R) =>
      ue(
        { fontFamily: r, fontWeight: w, fontSize: x(T), lineHeight: E },
        r === xM ? { letterSpacing: `${Qk(A / T)}em` } : {},
        R,
        h
      ),
    _ = {
      h1: S(o, 96, 1.167, -1.5),
      h2: S(o, 60, 1.2, -0.5),
      h3: S(s, 48, 1.167, 0),
      h4: S(s, 34, 1.235, 0.25),
      h5: S(s, 24, 1.334, 0),
      h6: S(l, 20, 1.6, 0.15),
      subtitle1: S(s, 16, 1.75, 0.15),
      subtitle2: S(l, 14, 1.57, 0.1),
      body1: S(s, 16, 1.5, 0.15),
      body2: S(s, 14, 1.43, 0.15),
      button: S(l, 14, 1.75, 0.4, yM),
      caption: S(s, 12, 1.66, 0.4),
      overline: S(s, 12, 2.66, 1, yM),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit",
      },
    };
  return ni(
    ue(
      {
        htmlFontSize: f,
        pxToRem: x,
        fontFamily: r,
        fontSize: i,
        fontWeightLight: o,
        fontWeightRegular: s,
        fontWeightMedium: l,
        fontWeightBold: u,
      },
      _
    ),
    g,
    { clone: !1 }
  );
}
const tD = 0.2,
  nD = 0.14,
  rD = 0.12;
function sr(...n) {
  return [
    `${n[0]}px ${n[1]}px ${n[2]}px ${n[3]}px rgba(0,0,0,${tD})`,
    `${n[4]}px ${n[5]}px ${n[6]}px ${n[7]}px rgba(0,0,0,${nD})`,
    `${n[8]}px ${n[9]}px ${n[10]}px ${n[11]}px rgba(0,0,0,${rD})`,
  ].join(",");
}
const iD = [
    "none",
    sr(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    sr(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    sr(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    sr(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    sr(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    sr(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    sr(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    sr(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    sr(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    sr(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    sr(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    sr(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    sr(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    sr(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    sr(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    sr(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    sr(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    sr(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    sr(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    sr(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    sr(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    sr(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    sr(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    sr(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  oD = ["duration", "easing", "delay"],
  sD = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
  },
  aD = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195,
  };
function _M(n) {
  return `${Math.round(n)}ms`;
}
function lD(n) {
  if (!n) return 0;
  const e = n / 36;
  return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
}
function uD(n) {
  const e = ue({}, sD, n.easing),
    t = ue({}, aD, n.duration);
  return ue(
    {
      getAutoHeightDuration: lD,
      create: (i = ["all"], o = {}) => {
        const {
          duration: s = t.standard,
          easing: l = e.easeInOut,
          delay: u = 0,
        } = o;
        return (
          Pt(o, oD),
          (Array.isArray(i) ? i : [i])
            .map(
              (f) =>
                `${f} ${typeof s == "string" ? s : _M(s)} ${l} ${
                  typeof u == "string" ? u : _M(u)
                }`
            )
            .join(",")
        );
      },
    },
    n,
    { easing: e, duration: t }
  );
}
const cD = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500,
  },
  fD = [
    "breakpoints",
    "mixins",
    "spacing",
    "palette",
    "transitions",
    "typography",
    "shape",
  ];
function b2(n = {}, ...e) {
  const {
      mixins: t = {},
      palette: r = {},
      transitions: i = {},
      typography: o = {},
    } = n,
    s = Pt(n, fD);
  if (n.vars) throw new Error(Ll(18));
  const l = Zk(r),
    u = Km(n);
  let f = ni(u, {
    mixins: zk(u.breakpoints, t),
    palette: l,
    shadows: iD.slice(),
    typography: eD(l, o),
    transitions: uD(i),
    zIndex: ue({}, cD),
  });
  return (
    (f = ni(f, s)),
    (f = e.reduce((h, m) => ni(h, m), f)),
    (f.unstable_sxConfig = ue(
      {},
      Ih,
      s == null ? void 0 : s.unstable_sxConfig
    )),
    (f.unstable_sx = function (m) {
      return Mf({ sx: m, theme: this });
    }),
    f
  );
}
const US = b2();
function M2() {
  const n = Sy(US);
  return n[cy] || n;
}
var Cc = {},
  s_ = { exports: {} },
  SM;
function dD() {
  return (
    SM ||
      ((SM = 1),
      (function (n) {
        function e() {
          return (
            (n.exports = e =
              Object.assign
                ? Object.assign.bind()
                : function (t) {
                    for (var r = 1; r < arguments.length; r++) {
                      var i = arguments[r];
                      for (var o in i)
                        ({}).hasOwnProperty.call(i, o) && (t[o] = i[o]);
                    }
                    return t;
                  }),
            (n.exports.__esModule = !0),
            (n.exports.default = n.exports),
            e.apply(null, arguments)
          );
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(s_)),
    s_.exports
  );
}
var a_ = { exports: {} },
  wM;
function hD() {
  return (
    wM ||
      ((wM = 1),
      (function (n) {
        function e(t, r) {
          if (t == null) return {};
          var i = {};
          for (var o in t)
            if ({}.hasOwnProperty.call(t, o)) {
              if (r.indexOf(o) !== -1) continue;
              i[o] = t[o];
            }
          return i;
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(a_)),
    a_.exports
  );
}
const pD = Ul(UI),
  mD = Ul(FI),
  gD = Ul(WI),
  vD = Ul($L),
  yD = Ul(PL),
  xD = Ul(UL);
var bM;
function _D() {
  if (bM) return Cc;
  bM = 1;
  var n = OS();
  Object.defineProperty(Cc, "__esModule", { value: !0 }),
    (Cc.default = A),
    (Cc.shouldForwardProp = x),
    (Cc.systemDefaultTheme = void 0);
  var e = n(dD()),
    t = n(hD()),
    r = m(pD),
    i = mD;
  n(gD), n(vD);
  var o = n(yD),
    s = n(xD);
  const l = ["ownerState"],
    u = ["variants"],
    f = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function h(R) {
    if (typeof WeakMap != "function") return null;
    var k = new WeakMap(),
      P = new WeakMap();
    return (h = function (U) {
      return U ? P : k;
    })(R);
  }
  function m(R, k) {
    if (R && R.__esModule) return R;
    if (R === null || (typeof R != "object" && typeof R != "function"))
      return { default: R };
    var P = h(k);
    if (P && P.has(R)) return P.get(R);
    var U = { __proto__: null },
      N = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var L in R)
      if (L !== "default" && Object.prototype.hasOwnProperty.call(R, L)) {
        var H = N ? Object.getOwnPropertyDescriptor(R, L) : null;
        H && (H.get || H.set) ? Object.defineProperty(U, L, H) : (U[L] = R[L]);
      }
    return (U.default = R), P && P.set(R, U), U;
  }
  function g(R) {
    return Object.keys(R).length === 0;
  }
  function y(R) {
    return typeof R == "string" && R.charCodeAt(0) > 96;
  }
  function x(R) {
    return R !== "ownerState" && R !== "theme" && R !== "sx" && R !== "as";
  }
  const S = (Cc.systemDefaultTheme = (0, o.default)()),
    _ = (R) => R && R.charAt(0).toLowerCase() + R.slice(1);
  function w({ defaultTheme: R, theme: k, themeId: P }) {
    return g(k) ? R : k[P] || k;
  }
  function T(R) {
    return R ? (k, P) => P[R] : null;
  }
  function E(R, k) {
    let { ownerState: P } = k,
      U = (0, t.default)(k, l);
    const N =
      typeof R == "function" ? R((0, e.default)({ ownerState: P }, U)) : R;
    if (Array.isArray(N))
      return N.flatMap((L) => E(L, (0, e.default)({ ownerState: P }, U)));
    if (N && typeof N == "object" && Array.isArray(N.variants)) {
      const { variants: L = [] } = N;
      let G = (0, t.default)(N, u);
      return (
        L.forEach(($) => {
          let q = !0;
          typeof $.props == "function"
            ? (q = $.props((0, e.default)({ ownerState: P }, U, P)))
            : Object.keys($.props).forEach((Z) => {
                (P == null ? void 0 : P[Z]) !== $.props[Z] &&
                  U[Z] !== $.props[Z] &&
                  (q = !1);
              }),
            q &&
              (Array.isArray(G) || (G = [G]),
              G.push(
                typeof $.style == "function"
                  ? $.style((0, e.default)({ ownerState: P }, U, P))
                  : $.style
              ));
        }),
        G
      );
    }
    return N;
  }
  function A(R = {}) {
    const {
        themeId: k,
        defaultTheme: P = S,
        rootShouldForwardProp: U = x,
        slotShouldForwardProp: N = x,
      } = R,
      L = (H) =>
        (0, s.default)(
          (0, e.default)({}, H, {
            theme: w((0, e.default)({}, H, { defaultTheme: P, themeId: k })),
          })
        );
    return (
      (L.__mui_systemSx = !0),
      (H, G = {}) => {
        (0, r.internal_processStyles)(H, (de) =>
          de.filter((le) => !(le != null && le.__mui_systemSx))
        );
        const {
            name: $,
            slot: q,
            skipVariantsResolver: Z,
            skipSx: X,
            overridesResolver: re = T(_(q)),
          } = G,
          W = (0, t.default)(G, f),
          te = Z !== void 0 ? Z : (q && q !== "Root" && q !== "root") || !1,
          F = X || !1;
        let V,
          ne = x;
        q === "Root" || q === "root"
          ? (ne = U)
          : q
          ? (ne = N)
          : y(H) && (ne = void 0);
        const ae = (0, r.default)(
            H,
            (0, e.default)({ shouldForwardProp: ne, label: V }, W)
          ),
          J = (de) =>
            (typeof de == "function" && de.__emotion_real !== de) ||
            (0, i.isPlainObject)(de)
              ? (le) =>
                  E(
                    de,
                    (0, e.default)({}, le, {
                      theme: w({
                        theme: le.theme,
                        defaultTheme: P,
                        themeId: k,
                      }),
                    })
                  )
              : de,
          oe = (de, ...le) => {
            let fe = J(de);
            const Ee = le ? le.map(J) : [];
            $ &&
              re &&
              Ee.push((j) => {
                const we = w(
                  (0, e.default)({}, j, { defaultTheme: P, themeId: k })
                );
                if (
                  !we.components ||
                  !we.components[$] ||
                  !we.components[$].styleOverrides
                )
                  return null;
                const Ae = we.components[$].styleOverrides,
                  Ne = {};
                return (
                  Object.entries(Ae).forEach(([Ie, rt]) => {
                    Ne[Ie] = E(rt, (0, e.default)({}, j, { theme: we }));
                  }),
                  re(j, Ne)
                );
              }),
              $ &&
                !te &&
                Ee.push((j) => {
                  var we;
                  const Ae = w(
                      (0, e.default)({}, j, { defaultTheme: P, themeId: k })
                    ),
                    Ne =
                      Ae == null ||
                      (we = Ae.components) == null ||
                      (we = we[$]) == null
                        ? void 0
                        : we.variants;
                  return E(
                    { variants: Ne },
                    (0, e.default)({}, j, { theme: Ae })
                  );
                }),
              F || Ee.push(L);
            const ge = Ee.length - le.length;
            if (Array.isArray(de) && ge > 0) {
              const j = new Array(ge).fill("");
              (fe = [...de, ...j]), (fe.raw = [...de.raw, ...j]);
            }
            const xe = ae(fe, ...Ee);
            return H.muiName && (xe.muiName = H.muiName), xe;
          };
        return ae.withConfig && (oe.withConfig = ae.withConfig), oe;
      }
    );
  }
  return Cc;
}
var SD = _D();
const wD = Ah(SD);
function E2(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
const Ps = (n) => E2(n) && n !== "classes",
  jt = wD({ themeId: cy, defaultTheme: US, rootShouldForwardProp: Ps }),
  MM = (n) => {
    let e;
    return (
      n < 1 ? (e = 5.11916 * n ** 2) : (e = 4.5 * Math.log(n + 1) + 2),
      (e / 100).toFixed(2)
    );
  };
function Xn(n) {
  return Ek(n);
}
function bD(n) {
  return Un("MuiSvgIcon", n);
}
In("MuiSvgIcon", [
  "root",
  "colorPrimary",
  "colorSecondary",
  "colorAction",
  "colorError",
  "colorDisabled",
  "fontSizeInherit",
  "fontSizeSmall",
  "fontSizeMedium",
  "fontSizeLarge",
]);
const MD = [
    "children",
    "className",
    "color",
    "component",
    "fontSize",
    "htmlColor",
    "inheritViewBox",
    "titleAccess",
    "viewBox",
  ],
  ED = (n) => {
    const { color: e, fontSize: t, classes: r } = n,
      i = {
        root: ["root", e !== "inherit" && `color${an(e)}`, `fontSize${an(t)}`],
      };
    return Fn(i, bD, r);
  },
  TD = jt("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.color !== "inherit" && e[`color${an(t.color)}`],
        e[`fontSize${an(t.fontSize)}`],
      ];
    },
  })(({ theme: n, ownerState: e }) => {
    var t, r, i, o, s, l, u, f, h, m, g, y, x;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: e.hasSvgAsChild ? void 0 : "currentColor",
      flexShrink: 0,
      transition:
        (t = n.transitions) == null || (r = t.create) == null
          ? void 0
          : r.call(t, "fill", {
              duration:
                (i = n.transitions) == null || (i = i.duration) == null
                  ? void 0
                  : i.shorter,
            }),
      fontSize: {
        inherit: "inherit",
        small:
          ((o = n.typography) == null || (s = o.pxToRem) == null
            ? void 0
            : s.call(o, 20)) || "1.25rem",
        medium:
          ((l = n.typography) == null || (u = l.pxToRem) == null
            ? void 0
            : u.call(l, 24)) || "1.5rem",
        large:
          ((f = n.typography) == null || (h = f.pxToRem) == null
            ? void 0
            : h.call(f, 35)) || "2.1875rem",
      }[e.fontSize],
      color:
        (m =
          (g = (n.vars || n).palette) == null || (g = g[e.color]) == null
            ? void 0
            : g.main) != null
          ? m
          : {
              action:
                (y = (n.vars || n).palette) == null || (y = y.action) == null
                  ? void 0
                  : y.active,
              disabled:
                (x = (n.vars || n).palette) == null || (x = x.action) == null
                  ? void 0
                  : x.disabled,
              inherit: void 0,
            }[e.color],
    };
  }),
  O1 = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiSvgIcon" }),
      {
        children: i,
        className: o,
        color: s = "inherit",
        component: l = "svg",
        fontSize: u = "medium",
        htmlColor: f,
        inheritViewBox: h = !1,
        titleAccess: m,
        viewBox: g = "0 0 24 24",
      } = r,
      y = Pt(r, MD),
      x = K.isValidElement(i) && i.type === "svg",
      S = ue({}, r, {
        color: s,
        component: l,
        fontSize: u,
        instanceFontSize: e.fontSize,
        inheritViewBox: h,
        viewBox: g,
        hasSvgAsChild: x,
      }),
      _ = {};
    h || (_.viewBox = g);
    const w = ED(S);
    return Q.jsxs(
      TD,
      ue(
        {
          as: l,
          className: Zt(w.root, o),
          focusable: "false",
          color: f,
          "aria-hidden": m ? void 0 : !0,
          role: m ? "img" : void 0,
          ref: t,
        },
        _,
        y,
        x && i.props,
        {
          ownerState: S,
          children: [
            x ? i.props.children : i,
            m ? Q.jsx("title", { children: m }) : null,
          ],
        }
      )
    );
  });
O1.muiName = "SvgIcon";
function Ef(n, e) {
  function t(r, i) {
    return Q.jsx(
      O1,
      ue({ "data-testid": `${e}Icon`, ref: i }, r, { children: n })
    );
  }
  return (t.muiName = O1.muiName), K.memo(K.forwardRef(t));
}
const CD = {
    configure: (n) => {
      LS.configure(n);
    },
  },
  AD = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        capitalize: an,
        createChainedFunction: k1,
        createSvgIcon: Ef,
        debounce: kS,
        deprecatedPropType: sk,
        isMuiElement: nm,
        ownerDocument: Uo,
        ownerWindow: Vu,
        requirePropFactory: ak,
        setRef: y0,
        unstable_ClassNameGenerator: CD,
        unstable_useEnhancedEffect: $a,
        unstable_useId: DS,
        unsupportedProp: uk,
        useControlled: D1,
        useEventCallback: rf,
        useForkRef: ri,
        useIsFocusVisible: NS,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
var l_ = { exports: {} },
  Dn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var EM;
function RD() {
  if (EM) return Dn;
  EM = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    l = Symbol.for("react.server_context"),
    u = Symbol.for("react.forward_ref"),
    f = Symbol.for("react.suspense"),
    h = Symbol.for("react.suspense_list"),
    m = Symbol.for("react.memo"),
    g = Symbol.for("react.lazy"),
    y = Symbol.for("react.offscreen"),
    x;
  x = Symbol.for("react.module.reference");
  function S(_) {
    if (typeof _ == "object" && _ !== null) {
      var w = _.$$typeof;
      switch (w) {
        case n:
          switch (((_ = _.type), _)) {
            case t:
            case i:
            case r:
            case f:
            case h:
              return _;
            default:
              switch (((_ = _ && _.$$typeof), _)) {
                case l:
                case s:
                case u:
                case g:
                case m:
                case o:
                  return _;
                default:
                  return w;
              }
          }
        case e:
          return w;
      }
    }
  }
  return (
    (Dn.ContextConsumer = s),
    (Dn.ContextProvider = o),
    (Dn.Element = n),
    (Dn.ForwardRef = u),
    (Dn.Fragment = t),
    (Dn.Lazy = g),
    (Dn.Memo = m),
    (Dn.Portal = e),
    (Dn.Profiler = i),
    (Dn.StrictMode = r),
    (Dn.Suspense = f),
    (Dn.SuspenseList = h),
    (Dn.isAsyncMode = function () {
      return !1;
    }),
    (Dn.isConcurrentMode = function () {
      return !1;
    }),
    (Dn.isContextConsumer = function (_) {
      return S(_) === s;
    }),
    (Dn.isContextProvider = function (_) {
      return S(_) === o;
    }),
    (Dn.isElement = function (_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === n;
    }),
    (Dn.isForwardRef = function (_) {
      return S(_) === u;
    }),
    (Dn.isFragment = function (_) {
      return S(_) === t;
    }),
    (Dn.isLazy = function (_) {
      return S(_) === g;
    }),
    (Dn.isMemo = function (_) {
      return S(_) === m;
    }),
    (Dn.isPortal = function (_) {
      return S(_) === e;
    }),
    (Dn.isProfiler = function (_) {
      return S(_) === i;
    }),
    (Dn.isStrictMode = function (_) {
      return S(_) === r;
    }),
    (Dn.isSuspense = function (_) {
      return S(_) === f;
    }),
    (Dn.isSuspenseList = function (_) {
      return S(_) === h;
    }),
    (Dn.isValidElementType = function (_) {
      return (
        typeof _ == "string" ||
        typeof _ == "function" ||
        _ === t ||
        _ === i ||
        _ === r ||
        _ === f ||
        _ === h ||
        _ === y ||
        (typeof _ == "object" &&
          _ !== null &&
          (_.$$typeof === g ||
            _.$$typeof === m ||
            _.$$typeof === o ||
            _.$$typeof === s ||
            _.$$typeof === u ||
            _.$$typeof === x ||
            _.getModuleId !== void 0))
      );
    }),
    (Dn.typeOf = S),
    Dn
  );
}
var TM;
function PD() {
  return TM || ((TM = 1), (l_.exports = RD())), l_.exports;
}
PD();
function U1(n, e) {
  return (
    (U1 = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (t, r) {
          return (t.__proto__ = r), t;
        }),
    U1(n, e)
  );
}
function T2(n, e) {
  (n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    U1(n, e);
}
const CM = { disabled: !1 },
  _0 = Cs.createContext(null);
var ID = function (e) {
    return e.scrollTop;
  },
  Kp = "unmounted",
  $c = "exited",
  Xc = "entering",
  nh = "entered",
  F1 = "exiting",
  Ya = (function (n) {
    T2(e, n);
    function e(r, i) {
      var o;
      o = n.call(this, r, i) || this;
      var s = i,
        l = s && !s.isMounting ? r.enter : r.appear,
        u;
      return (
        (o.appearStatus = null),
        r.in
          ? l
            ? ((u = $c), (o.appearStatus = Xc))
            : (u = nh)
          : r.unmountOnExit || r.mountOnEnter
          ? (u = Kp)
          : (u = $c),
        (o.state = { status: u }),
        (o.nextCallback = null),
        o
      );
    }
    e.getDerivedStateFromProps = function (i, o) {
      var s = i.in;
      return s && o.status === Kp ? { status: $c } : null;
    };
    var t = e.prototype;
    return (
      (t.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (t.componentDidUpdate = function (i) {
        var o = null;
        if (i !== this.props) {
          var s = this.state.status;
          this.props.in
            ? s !== Xc && s !== nh && (o = Xc)
            : (s === Xc || s === nh) && (o = F1);
        }
        this.updateStatus(!1, o);
      }),
      (t.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (t.getTimeouts = function () {
        var i = this.props.timeout,
          o,
          s,
          l;
        return (
          (o = s = l = i),
          i != null &&
            typeof i != "number" &&
            ((o = i.exit),
            (s = i.enter),
            (l = i.appear !== void 0 ? i.appear : s)),
          { exit: o, enter: s, appear: l }
        );
      }),
      (t.updateStatus = function (i, o) {
        if ((i === void 0 && (i = !1), o !== null))
          if ((this.cancelNextCallback(), o === Xc)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var s = this.props.nodeRef
                ? this.props.nodeRef.current
                : iv.findDOMNode(this);
              s && ID(s);
            }
            this.performEnter(i);
          } else this.performExit();
        else
          this.props.unmountOnExit &&
            this.state.status === $c &&
            this.setState({ status: Kp });
      }),
      (t.performEnter = function (i) {
        var o = this,
          s = this.props.enter,
          l = this.context ? this.context.isMounting : i,
          u = this.props.nodeRef ? [l] : [iv.findDOMNode(this), l],
          f = u[0],
          h = u[1],
          m = this.getTimeouts(),
          g = l ? m.appear : m.enter;
        if ((!i && !s) || CM.disabled) {
          this.safeSetState({ status: nh }, function () {
            o.props.onEntered(f);
          });
          return;
        }
        this.props.onEnter(f, h),
          this.safeSetState({ status: Xc }, function () {
            o.props.onEntering(f, h),
              o.onTransitionEnd(g, function () {
                o.safeSetState({ status: nh }, function () {
                  o.props.onEntered(f, h);
                });
              });
          });
      }),
      (t.performExit = function () {
        var i = this,
          o = this.props.exit,
          s = this.getTimeouts(),
          l = this.props.nodeRef ? void 0 : iv.findDOMNode(this);
        if (!o || CM.disabled) {
          this.safeSetState({ status: $c }, function () {
            i.props.onExited(l);
          });
          return;
        }
        this.props.onExit(l),
          this.safeSetState({ status: F1 }, function () {
            i.props.onExiting(l),
              i.onTransitionEnd(s.exit, function () {
                i.safeSetState({ status: $c }, function () {
                  i.props.onExited(l);
                });
              });
          });
      }),
      (t.cancelNextCallback = function () {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (t.safeSetState = function (i, o) {
        (o = this.setNextCallback(o)), this.setState(i, o);
      }),
      (t.setNextCallback = function (i) {
        var o = this,
          s = !0;
        return (
          (this.nextCallback = function (l) {
            s && ((s = !1), (o.nextCallback = null), i(l));
          }),
          (this.nextCallback.cancel = function () {
            s = !1;
          }),
          this.nextCallback
        );
      }),
      (t.onTransitionEnd = function (i, o) {
        this.setNextCallback(o);
        var s = this.props.nodeRef
            ? this.props.nodeRef.current
            : iv.findDOMNode(this),
          l = i == null && !this.props.addEndListener;
        if (!s || l) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var u = this.props.nodeRef
              ? [this.nextCallback]
              : [s, this.nextCallback],
            f = u[0],
            h = u[1];
          this.props.addEndListener(f, h);
        }
        i != null && setTimeout(this.nextCallback, i);
      }),
      (t.render = function () {
        var i = this.state.status;
        if (i === Kp) return null;
        var o = this.props,
          s = o.children;
        o.in,
          o.mountOnEnter,
          o.unmountOnExit,
          o.appear,
          o.enter,
          o.exit,
          o.timeout,
          o.addEndListener,
          o.onEnter,
          o.onEntering,
          o.onEntered,
          o.onExit,
          o.onExiting,
          o.onExited,
          o.nodeRef;
        var l = Pt(o, [
          "children",
          "in",
          "mountOnEnter",
          "unmountOnExit",
          "appear",
          "enter",
          "exit",
          "timeout",
          "addEndListener",
          "onEnter",
          "onEntering",
          "onEntered",
          "onExit",
          "onExiting",
          "onExited",
          "nodeRef",
        ]);
        return Cs.createElement(
          _0.Provider,
          { value: null },
          typeof s == "function"
            ? s(i, l)
            : Cs.cloneElement(Cs.Children.only(s), l)
        );
      }),
      e
    );
  })(Cs.Component);
Ya.contextType = _0;
Ya.propTypes = {};
function Pd() {}
Ya.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: Pd,
  onEntering: Pd,
  onEntered: Pd,
  onExit: Pd,
  onExiting: Pd,
  onExited: Pd,
};
Ya.UNMOUNTED = Kp;
Ya.EXITED = $c;
Ya.ENTERING = Xc;
Ya.ENTERED = nh;
Ya.EXITING = F1;
function LD(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function FS(n, e) {
  var t = function (o) {
      return e && K.isValidElement(o) ? e(o) : o;
    },
    r = Object.create(null);
  return (
    n &&
      K.Children.map(n, function (i) {
        return i;
      }).forEach(function (i) {
        r[i.key] = t(i);
      }),
    r
  );
}
function kD(n, e) {
  (n = n || {}), (e = e || {});
  function t(h) {
    return h in e ? e[h] : n[h];
  }
  var r = Object.create(null),
    i = [];
  for (var o in n) o in e ? i.length && ((r[o] = i), (i = [])) : i.push(o);
  var s,
    l = {};
  for (var u in e) {
    if (r[u])
      for (s = 0; s < r[u].length; s++) {
        var f = r[u][s];
        l[r[u][s]] = t(f);
      }
    l[u] = t(u);
  }
  for (s = 0; s < i.length; s++) l[i[s]] = t(i[s]);
  return l;
}
function of(n, e, t) {
  return t[e] != null ? t[e] : n.props[e];
}
function DD(n, e) {
  return FS(n.children, function (t) {
    return K.cloneElement(t, {
      onExited: e.bind(null, t),
      in: !0,
      appear: of(t, "appear", n),
      enter: of(t, "enter", n),
      exit: of(t, "exit", n),
    });
  });
}
function ND(n, e, t) {
  var r = FS(n.children),
    i = kD(e, r);
  return (
    Object.keys(i).forEach(function (o) {
      var s = i[o];
      if (K.isValidElement(s)) {
        var l = o in e,
          u = o in r,
          f = e[o],
          h = K.isValidElement(f) && !f.props.in;
        u && (!l || h)
          ? (i[o] = K.cloneElement(s, {
              onExited: t.bind(null, s),
              in: !0,
              exit: of(s, "exit", n),
              enter: of(s, "enter", n),
            }))
          : !u && l && !h
          ? (i[o] = K.cloneElement(s, { in: !1 }))
          : u &&
            l &&
            K.isValidElement(f) &&
            (i[o] = K.cloneElement(s, {
              onExited: t.bind(null, s),
              in: f.props.in,
              exit: of(s, "exit", n),
              enter: of(s, "enter", n),
            }));
      }
    }),
    i
  );
}
var OD =
    Object.values ||
    function (n) {
      return Object.keys(n).map(function (e) {
        return n[e];
      });
    },
  UD = {
    component: "div",
    childFactory: function (e) {
      return e;
    },
  },
  BS = (function (n) {
    T2(e, n);
    function e(r, i) {
      var o;
      o = n.call(this, r, i) || this;
      var s = o.handleExited.bind(LD(o));
      return (
        (o.state = {
          contextValue: { isMounting: !0 },
          handleExited: s,
          firstRender: !0,
        }),
        o
      );
    }
    var t = e.prototype;
    return (
      (t.componentDidMount = function () {
        (this.mounted = !0),
          this.setState({ contextValue: { isMounting: !1 } });
      }),
      (t.componentWillUnmount = function () {
        this.mounted = !1;
      }),
      (e.getDerivedStateFromProps = function (i, o) {
        var s = o.children,
          l = o.handleExited,
          u = o.firstRender;
        return { children: u ? DD(i, l) : ND(i, s, l), firstRender: !1 };
      }),
      (t.handleExited = function (i, o) {
        var s = FS(this.props.children);
        i.key in s ||
          (i.props.onExited && i.props.onExited(o),
          this.mounted &&
            this.setState(function (l) {
              var u = ue({}, l.children);
              return delete u[i.key], { children: u };
            }));
      }),
      (t.render = function () {
        var i = this.props,
          o = i.component,
          s = i.childFactory,
          l = Pt(i, ["component", "childFactory"]),
          u = this.state.contextValue,
          f = OD(this.state.children).map(s);
        return (
          delete l.appear,
          delete l.enter,
          delete l.exit,
          o === null
            ? Cs.createElement(_0.Provider, { value: u }, f)
            : Cs.createElement(
                _0.Provider,
                { value: u },
                Cs.createElement(o, l, f)
              )
        );
      }),
      e
    );
  })(Cs.Component);
BS.propTypes = {};
BS.defaultProps = UD;
const C2 = (n) => n.scrollTop;
function S0(n, e) {
  var t, r;
  const { timeout: i, easing: o, style: s = {} } = n;
  return {
    duration:
      (t = s.transitionDuration) != null
        ? t
        : typeof i == "number"
        ? i
        : i[e.mode] || 0,
    easing:
      (r = s.transitionTimingFunction) != null
        ? r
        : typeof o == "object"
        ? o[e.mode]
        : o,
    delay: s.transitionDelay,
  };
}
function FD(n) {
  return Un("MuiPaper", n);
}
In("MuiPaper", [
  "root",
  "rounded",
  "outlined",
  "elevation",
  "elevation0",
  "elevation1",
  "elevation2",
  "elevation3",
  "elevation4",
  "elevation5",
  "elevation6",
  "elevation7",
  "elevation8",
  "elevation9",
  "elevation10",
  "elevation11",
  "elevation12",
  "elevation13",
  "elevation14",
  "elevation15",
  "elevation16",
  "elevation17",
  "elevation18",
  "elevation19",
  "elevation20",
  "elevation21",
  "elevation22",
  "elevation23",
  "elevation24",
]);
const BD = ["className", "component", "elevation", "square", "variant"],
  zD = (n) => {
    const { square: e, elevation: t, variant: r, classes: i } = n,
      o = {
        root: [
          "root",
          r,
          !e && "rounded",
          r === "elevation" && `elevation${t}`,
        ],
      };
    return Fn(o, FD, i);
  },
  HD = jt("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        e[t.variant],
        !t.square && e.rounded,
        t.variant === "elevation" && e[`elevation${t.elevation}`],
      ];
    },
  })(({ theme: n, ownerState: e }) => {
    var t;
    return ue(
      {
        backgroundColor: (n.vars || n).palette.background.paper,
        color: (n.vars || n).palette.text.primary,
        transition: n.transitions.create("box-shadow"),
      },
      !e.square && { borderRadius: n.shape.borderRadius },
      e.variant === "outlined" && {
        border: `1px solid ${(n.vars || n).palette.divider}`,
      },
      e.variant === "elevation" &&
        ue(
          { boxShadow: (n.vars || n).shadows[e.elevation] },
          !n.vars &&
            n.palette.mode === "dark" && {
              backgroundImage: `linear-gradient(${Di.alpha(
                "#fff",
                MM(e.elevation)
              )}, ${Di.alpha("#fff", MM(e.elevation))})`,
            },
          n.vars && {
            backgroundImage:
              (t = n.vars.overlays) == null ? void 0 : t[e.elevation],
          }
        )
    );
  }),
  ef = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiPaper" }),
      {
        className: i,
        component: o = "div",
        elevation: s = 1,
        square: l = !1,
        variant: u = "elevation",
      } = r,
      f = Pt(r, BD),
      h = ue({}, r, { component: o, elevation: s, square: l, variant: u }),
      m = zD(h);
    return Q.jsx(
      HD,
      ue({ as: o, ownerState: h, className: Zt(m.root, i), ref: t }, f)
    );
  });
function VD(n) {
  const {
      className: e,
      classes: t,
      pulsate: r = !1,
      rippleX: i,
      rippleY: o,
      rippleSize: s,
      in: l,
      onExited: u,
      timeout: f,
    } = n,
    [h, m] = K.useState(!1),
    g = Zt(e, t.ripple, t.rippleVisible, r && t.ripplePulsate),
    y = { width: s, height: s, top: -(s / 2) + o, left: -(s / 2) + i },
    x = Zt(t.child, h && t.childLeaving, r && t.childPulsate);
  return (
    !l && !h && m(!0),
    K.useEffect(() => {
      if (!l && u != null) {
        const S = setTimeout(u, f);
        return () => {
          clearTimeout(S);
        };
      }
    }, [u, l, f]),
    Q.jsx("span", {
      className: g,
      style: y,
      children: Q.jsx("span", { className: x }),
    })
  );
}
const bs = In("MuiTouchRipple", [
    "root",
    "ripple",
    "rippleVisible",
    "ripplePulsate",
    "child",
    "childLeaving",
    "childPulsate",
  ]),
  GD = ["center", "classes", "className"];
let Ey = (n) => n,
  AM,
  RM,
  PM,
  IM;
const B1 = 550,
  WD = 80,
  jD = Ym(
    AM ||
      (AM = Ey`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
  ),
  $D = Ym(
    RM ||
      (RM = Ey`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
  ),
  XD = Ym(
    PM ||
      (PM = Ey`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
  ),
  YD = jt("span", { name: "MuiTouchRipple", slot: "Root" })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit",
  }),
  qD = jt(VD, { name: "MuiTouchRipple", slot: "Ripple" })(
    IM ||
      (IM = Ey`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
    bs.rippleVisible,
    jD,
    B1,
    ({ theme: n }) => n.transitions.easing.easeInOut,
    bs.ripplePulsate,
    ({ theme: n }) => n.transitions.duration.shorter,
    bs.child,
    bs.childLeaving,
    $D,
    B1,
    ({ theme: n }) => n.transitions.easing.easeInOut,
    bs.childPulsate,
    XD,
    ({ theme: n }) => n.transitions.easing.easeInOut
  ),
  KD = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiTouchRipple" }),
      { center: i = !1, classes: o = {}, className: s } = r,
      l = Pt(r, GD),
      [u, f] = K.useState([]),
      h = K.useRef(0),
      m = K.useRef(null);
    K.useEffect(() => {
      m.current && (m.current(), (m.current = null));
    }, [u]);
    const g = K.useRef(!1),
      y = v2(),
      x = K.useRef(null),
      S = K.useRef(null),
      _ = K.useCallback(
        (A) => {
          const {
            pulsate: R,
            rippleX: k,
            rippleY: P,
            rippleSize: U,
            cb: N,
          } = A;
          f((L) => [
            ...L,
            Q.jsx(
              qD,
              {
                classes: {
                  ripple: Zt(o.ripple, bs.ripple),
                  rippleVisible: Zt(o.rippleVisible, bs.rippleVisible),
                  ripplePulsate: Zt(o.ripplePulsate, bs.ripplePulsate),
                  child: Zt(o.child, bs.child),
                  childLeaving: Zt(o.childLeaving, bs.childLeaving),
                  childPulsate: Zt(o.childPulsate, bs.childPulsate),
                },
                timeout: B1,
                pulsate: R,
                rippleX: k,
                rippleY: P,
                rippleSize: U,
              },
              h.current
            ),
          ]),
            (h.current += 1),
            (m.current = N);
        },
        [o]
      ),
      w = K.useCallback(
        (A = {}, R = {}, k = () => {}) => {
          const {
            pulsate: P = !1,
            center: U = i || R.pulsate,
            fakeElement: N = !1,
          } = R;
          if ((A == null ? void 0 : A.type) === "mousedown" && g.current) {
            g.current = !1;
            return;
          }
          (A == null ? void 0 : A.type) === "touchstart" && (g.current = !0);
          const L = N ? null : S.current,
            H = L
              ? L.getBoundingClientRect()
              : { width: 0, height: 0, left: 0, top: 0 };
          let G, $, q;
          if (
            U ||
            A === void 0 ||
            (A.clientX === 0 && A.clientY === 0) ||
            (!A.clientX && !A.touches)
          )
            (G = Math.round(H.width / 2)), ($ = Math.round(H.height / 2));
          else {
            const { clientX: Z, clientY: X } =
              A.touches && A.touches.length > 0 ? A.touches[0] : A;
            (G = Math.round(Z - H.left)), ($ = Math.round(X - H.top));
          }
          if (U)
            (q = Math.sqrt((2 * H.width ** 2 + H.height ** 2) / 3)),
              q % 2 === 0 && (q += 1);
          else {
            const Z =
                Math.max(Math.abs((L ? L.clientWidth : 0) - G), G) * 2 + 2,
              X = Math.max(Math.abs((L ? L.clientHeight : 0) - $), $) * 2 + 2;
            q = Math.sqrt(Z ** 2 + X ** 2);
          }
          A != null && A.touches
            ? x.current === null &&
              ((x.current = () => {
                _({ pulsate: P, rippleX: G, rippleY: $, rippleSize: q, cb: k });
              }),
              y.start(WD, () => {
                x.current && (x.current(), (x.current = null));
              }))
            : _({ pulsate: P, rippleX: G, rippleY: $, rippleSize: q, cb: k });
        },
        [i, _, y]
      ),
      T = K.useCallback(() => {
        w({}, { pulsate: !0 });
      }, [w]),
      E = K.useCallback(
        (A, R) => {
          if (
            (y.clear(),
            (A == null ? void 0 : A.type) === "touchend" && x.current)
          ) {
            x.current(),
              (x.current = null),
              y.start(0, () => {
                E(A, R);
              });
            return;
          }
          (x.current = null),
            f((k) => (k.length > 0 ? k.slice(1) : k)),
            (m.current = R);
        },
        [y]
      );
    return (
      K.useImperativeHandle(t, () => ({ pulsate: T, start: w, stop: E }), [
        T,
        w,
        E,
      ]),
      Q.jsx(
        YD,
        ue({ className: Zt(bs.root, o.root, s), ref: S }, l, {
          children: Q.jsx(BS, { component: null, exit: !0, children: u }),
        })
      )
    );
  });
function ZD(n) {
  return Un("MuiButtonBase", n);
}
const JD = In("MuiButtonBase", ["root", "disabled", "focusVisible"]),
  QD = [
    "action",
    "centerRipple",
    "children",
    "className",
    "component",
    "disabled",
    "disableRipple",
    "disableTouchRipple",
    "focusRipple",
    "focusVisibleClassName",
    "LinkComponent",
    "onBlur",
    "onClick",
    "onContextMenu",
    "onDragLeave",
    "onFocus",
    "onFocusVisible",
    "onKeyDown",
    "onKeyUp",
    "onMouseDown",
    "onMouseLeave",
    "onMouseUp",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "tabIndex",
    "TouchRippleProps",
    "touchRippleRef",
    "type",
  ],
  eN = (n) => {
    const {
        disabled: e,
        focusVisible: t,
        focusVisibleClassName: r,
        classes: i,
      } = n,
      s = Fn({ root: ["root", e && "disabled", t && "focusVisible"] }, ZD, i);
    return t && r && (s.root += ` ${r}`), s;
  },
  tN = jt("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": { borderStyle: "none" },
    [`&.${JD.disabled}`]: { pointerEvents: "none", cursor: "default" },
    "@media print": { colorAdjust: "exact" },
  }),
  zS = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiButtonBase" }),
      {
        action: i,
        centerRipple: o = !1,
        children: s,
        className: l,
        component: u = "button",
        disabled: f = !1,
        disableRipple: h = !1,
        disableTouchRipple: m = !1,
        focusRipple: g = !1,
        LinkComponent: y = "a",
        onBlur: x,
        onClick: S,
        onContextMenu: _,
        onDragLeave: w,
        onFocus: T,
        onFocusVisible: E,
        onKeyDown: A,
        onKeyUp: R,
        onMouseDown: k,
        onMouseLeave: P,
        onMouseUp: U,
        onTouchEnd: N,
        onTouchMove: L,
        onTouchStart: H,
        tabIndex: G = 0,
        TouchRippleProps: $,
        touchRippleRef: q,
        type: Z,
      } = r,
      X = Pt(r, QD),
      re = K.useRef(null),
      W = K.useRef(null),
      te = ri(W, q),
      { isFocusVisibleRef: F, onFocus: V, onBlur: ne, ref: ae } = NS(),
      [J, oe] = K.useState(!1);
    f && J && oe(!1),
      K.useImperativeHandle(
        i,
        () => ({
          focusVisible: () => {
            oe(!0), re.current.focus();
          },
        }),
        []
      );
    const [de, le] = K.useState(!1);
    K.useEffect(() => {
      le(!0);
    }, []);
    const fe = de && !h && !f;
    K.useEffect(() => {
      J && g && !h && de && W.current.pulsate();
    }, [h, g, J, de]);
    function Ee(We, Ye, nt = m) {
      return rf(
        (yt) => (Ye && Ye(yt), !nt && W.current && W.current[We](yt), !0)
      );
    }
    const ge = Ee("start", k),
      xe = Ee("stop", _),
      j = Ee("stop", w),
      we = Ee("stop", U),
      Ae = Ee("stop", (We) => {
        J && We.preventDefault(), P && P(We);
      }),
      Ne = Ee("start", H),
      Ie = Ee("stop", N),
      rt = Ee("stop", L),
      ke = Ee(
        "stop",
        (We) => {
          ne(We), F.current === !1 && oe(!1), x && x(We);
        },
        !1
      ),
      Xe = rf((We) => {
        re.current || (re.current = We.currentTarget),
          V(We),
          F.current === !0 && (oe(!0), E && E(We)),
          T && T(We);
      }),
      ee = () => {
        const We = re.current;
        return u && u !== "button" && !(We.tagName === "A" && We.href);
      },
      B = K.useRef(!1),
      ve = rf((We) => {
        g &&
          !B.current &&
          J &&
          W.current &&
          We.key === " " &&
          ((B.current = !0),
          W.current.stop(We, () => {
            W.current.start(We);
          })),
          We.target === We.currentTarget &&
            ee() &&
            We.key === " " &&
            We.preventDefault(),
          A && A(We),
          We.target === We.currentTarget &&
            ee() &&
            We.key === "Enter" &&
            !f &&
            (We.preventDefault(), S && S(We));
      }),
      Se = rf((We) => {
        g &&
          We.key === " " &&
          W.current &&
          J &&
          !We.defaultPrevented &&
          ((B.current = !1),
          W.current.stop(We, () => {
            W.current.pulsate(We);
          })),
          R && R(We),
          S &&
            We.target === We.currentTarget &&
            ee() &&
            We.key === " " &&
            !We.defaultPrevented &&
            S(We);
      });
    let _e = u;
    _e === "button" && (X.href || X.to) && (_e = y);
    const Te = {};
    _e === "button"
      ? ((Te.type = Z === void 0 ? "button" : Z), (Te.disabled = f))
      : (!X.href && !X.to && (Te.role = "button"),
        f && (Te["aria-disabled"] = f));
    const at = ri(t, ae, re),
      Fe = ue({}, r, {
        centerRipple: o,
        component: u,
        disabled: f,
        disableRipple: h,
        disableTouchRipple: m,
        focusRipple: g,
        tabIndex: G,
        focusVisible: J,
      }),
      Be = eN(Fe);
    return Q.jsxs(
      tN,
      ue(
        {
          as: _e,
          className: Zt(Be.root, l),
          ownerState: Fe,
          onBlur: ke,
          onClick: S,
          onContextMenu: xe,
          onFocus: Xe,
          onKeyDown: ve,
          onKeyUp: Se,
          onMouseDown: ge,
          onMouseLeave: Ae,
          onMouseUp: we,
          onDragLeave: j,
          onTouchEnd: Ie,
          onTouchMove: rt,
          onTouchStart: Ne,
          ref: at,
          tabIndex: f ? -1 : G,
          type: Z,
        },
        Te,
        X,
        { children: [s, fe ? Q.jsx(KD, ue({ ref: te, center: o }, $)) : null] }
      )
    );
  });
function nN(n) {
  return Un("MuiTypography", n);
}
In("MuiTypography", [
  "root",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "subtitle1",
  "subtitle2",
  "body1",
  "body2",
  "inherit",
  "button",
  "caption",
  "overline",
  "alignLeft",
  "alignRight",
  "alignCenter",
  "alignJustify",
  "noWrap",
  "gutterBottom",
  "paragraph",
]);
const rN = [
    "align",
    "className",
    "component",
    "gutterBottom",
    "noWrap",
    "paragraph",
    "variant",
    "variantMapping",
  ],
  iN = (n) => {
    const {
        align: e,
        gutterBottom: t,
        noWrap: r,
        paragraph: i,
        variant: o,
        classes: s,
      } = n,
      l = {
        root: [
          "root",
          o,
          n.align !== "inherit" && `align${an(e)}`,
          t && "gutterBottom",
          r && "noWrap",
          i && "paragraph",
        ],
      };
    return Fn(l, nN, s);
  },
  oN = jt("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.variant && e[t.variant],
        t.align !== "inherit" && e[`align${an(t.align)}`],
        t.noWrap && e.noWrap,
        t.gutterBottom && e.gutterBottom,
        t.paragraph && e.paragraph,
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      { margin: 0 },
      e.variant === "inherit" && { font: "inherit" },
      e.variant !== "inherit" && n.typography[e.variant],
      e.align !== "inherit" && { textAlign: e.align },
      e.noWrap && {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
      },
      e.gutterBottom && { marginBottom: "0.35em" },
      e.paragraph && { marginBottom: 16 }
    )
  ),
  LM = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p",
  },
  sN = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main",
  },
  aN = (n) => sN[n] || n,
  mr = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiTypography" }),
      i = aN(r.color),
      o = wy(ue({}, r, { color: i })),
      {
        align: s = "inherit",
        className: l,
        component: u,
        gutterBottom: f = !1,
        noWrap: h = !1,
        paragraph: m = !1,
        variant: g = "body1",
        variantMapping: y = LM,
      } = o,
      x = Pt(o, rN),
      S = ue({}, o, {
        align: s,
        color: i,
        className: l,
        component: u,
        gutterBottom: f,
        noWrap: h,
        paragraph: m,
        variant: g,
        variantMapping: y,
      }),
      _ = u || (m ? "p" : y[g] || LM[g]) || "span",
      w = iN(S);
    return Q.jsx(
      oN,
      ue({ as: _, ref: t, ownerState: S, className: Zt(w.root, l) }, x)
    );
  });
function lN(n) {
  return typeof n == "function" ? n() : n;
}
const uN = K.forwardRef(function (e, t) {
    const { children: r, container: i, disablePortal: o = !1 } = e,
      [s, l] = K.useState(null),
      u = ri(K.isValidElement(r) ? r.ref : null, t);
    if (
      ($a(() => {
        o || l(lN(i) || document.body);
      }, [i, o]),
      $a(() => {
        if (s && !o)
          return (
            y0(t, s),
            () => {
              y0(t, null);
            }
          );
      }, [t, s, o]),
      o)
    ) {
      if (K.isValidElement(r)) {
        const f = { ref: u };
        return K.cloneElement(r, f);
      }
      return Q.jsx(K.Fragment, { children: r });
    }
    return Q.jsx(K.Fragment, { children: s && gS.createPortal(r, s) });
  }),
  cN = ["onChange", "maxRows", "minRows", "style", "value"];
function av(n) {
  return parseInt(n, 10) || 0;
}
const fN = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)",
  },
};
function dN(n) {
  return (
    n == null ||
    Object.keys(n).length === 0 ||
    (n.outerHeightStyle === 0 && !n.overflowing)
  );
}
const hN = K.forwardRef(function (e, t) {
  const { onChange: r, maxRows: i, minRows: o = 1, style: s, value: l } = e,
    u = Pt(e, cN),
    { current: f } = K.useRef(l != null),
    h = K.useRef(null),
    m = ri(t, h),
    g = K.useRef(null),
    y = K.useRef(null),
    x = K.useCallback(() => {
      const w = h.current,
        E = Vu(w).getComputedStyle(w);
      if (E.width === "0px") return { outerHeightStyle: 0, overflowing: !1 };
      const A = y.current;
      (A.style.width = E.width),
        (A.value = w.value || e.placeholder || "x"),
        A.value.slice(-1) ===
          `
` && (A.value += " ");
      const R = E.boxSizing,
        k = av(E.paddingBottom) + av(E.paddingTop),
        P = av(E.borderBottomWidth) + av(E.borderTopWidth),
        U = A.scrollHeight;
      A.value = "x";
      const N = A.scrollHeight;
      let L = U;
      o && (L = Math.max(Number(o) * N, L)),
        i && (L = Math.min(Number(i) * N, L)),
        (L = Math.max(L, N));
      const H = L + (R === "border-box" ? k + P : 0),
        G = Math.abs(L - U) <= 1;
      return { outerHeightStyle: H, overflowing: G };
    }, [i, o, e.placeholder]),
    S = K.useCallback(() => {
      const w = x();
      if (dN(w)) return;
      const T = w.outerHeightStyle,
        E = h.current;
      g.current !== T && ((g.current = T), (E.style.height = `${T}px`)),
        (E.style.overflow = w.overflowing ? "hidden" : "");
    }, [x]);
  $a(() => {
    const w = () => {
      S();
    };
    let T;
    const E = kS(w),
      A = h.current,
      R = Vu(A);
    R.addEventListener("resize", E);
    let k;
    return (
      typeof ResizeObserver < "u" &&
        ((k = new ResizeObserver(w)), k.observe(A)),
      () => {
        E.clear(),
          cancelAnimationFrame(T),
          R.removeEventListener("resize", E),
          k && k.disconnect();
      }
    );
  }, [x, S]),
    $a(() => {
      S();
    });
  const _ = (w) => {
    f || S(), r && r(w);
  };
  return Q.jsxs(K.Fragment, {
    children: [
      Q.jsx(
        "textarea",
        ue({ value: l, onChange: _, ref: m, rows: o, style: s }, u)
      ),
      Q.jsx("textarea", {
        "aria-hidden": !0,
        className: e.className,
        readOnly: !0,
        ref: y,
        tabIndex: -1,
        style: ue({}, fN.shadow, s, { paddingTop: 0, paddingBottom: 0 }),
      }),
    ],
  });
});
function Lh({ props: n, states: e, muiFormControl: t }) {
  return e.reduce(
    (r, i) => ((r[i] = n[i]), t && typeof n[i] > "u" && (r[i] = t[i]), r),
    {}
  );
}
const HS = K.createContext(void 0);
function kh() {
  return K.useContext(HS);
}
function pN(n) {
  return Q.jsx(DL, ue({}, n, { defaultTheme: US, themeId: cy }));
}
function kM(n) {
  return n != null && !(Array.isArray(n) && n.length === 0);
}
function w0(n, e = !1) {
  return (
    n &&
    ((kM(n.value) && n.value !== "") ||
      (e && kM(n.defaultValue) && n.defaultValue !== ""))
  );
}
function mN(n) {
  return n.startAdornment;
}
function gN(n) {
  return Un("MuiInputBase", n);
}
const wh = In("MuiInputBase", [
    "root",
    "formControl",
    "focused",
    "disabled",
    "adornedStart",
    "adornedEnd",
    "error",
    "sizeSmall",
    "multiline",
    "colorSecondary",
    "fullWidth",
    "hiddenLabel",
    "readOnly",
    "input",
    "inputSizeSmall",
    "inputMultiline",
    "inputTypeSearch",
    "inputAdornedStart",
    "inputAdornedEnd",
    "inputHiddenLabel",
  ]),
  vN = [
    "aria-describedby",
    "autoComplete",
    "autoFocus",
    "className",
    "color",
    "components",
    "componentsProps",
    "defaultValue",
    "disabled",
    "disableInjectingGlobalStyles",
    "endAdornment",
    "error",
    "fullWidth",
    "id",
    "inputComponent",
    "inputProps",
    "inputRef",
    "margin",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onClick",
    "onFocus",
    "onKeyDown",
    "onKeyUp",
    "placeholder",
    "readOnly",
    "renderSuffix",
    "rows",
    "size",
    "slotProps",
    "slots",
    "startAdornment",
    "type",
    "value",
  ],
  Ty = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.formControl && e.formControl,
      t.startAdornment && e.adornedStart,
      t.endAdornment && e.adornedEnd,
      t.error && e.error,
      t.size === "small" && e.sizeSmall,
      t.multiline && e.multiline,
      t.color && e[`color${an(t.color)}`],
      t.fullWidth && e.fullWidth,
      t.hiddenLabel && e.hiddenLabel,
    ];
  },
  Cy = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.input,
      t.size === "small" && e.inputSizeSmall,
      t.multiline && e.inputMultiline,
      t.type === "search" && e.inputTypeSearch,
      t.startAdornment && e.inputAdornedStart,
      t.endAdornment && e.inputAdornedEnd,
      t.hiddenLabel && e.inputHiddenLabel,
    ];
  },
  yN = (n) => {
    const {
        classes: e,
        color: t,
        disabled: r,
        error: i,
        endAdornment: o,
        focused: s,
        formControl: l,
        fullWidth: u,
        hiddenLabel: f,
        multiline: h,
        readOnly: m,
        size: g,
        startAdornment: y,
        type: x,
      } = n,
      S = {
        root: [
          "root",
          `color${an(t)}`,
          r && "disabled",
          i && "error",
          u && "fullWidth",
          s && "focused",
          l && "formControl",
          g && g !== "medium" && `size${an(g)}`,
          h && "multiline",
          y && "adornedStart",
          o && "adornedEnd",
          f && "hiddenLabel",
          m && "readOnly",
        ],
        input: [
          "input",
          r && "disabled",
          x === "search" && "inputTypeSearch",
          h && "inputMultiline",
          g === "small" && "inputSizeSmall",
          f && "inputHiddenLabel",
          y && "inputAdornedStart",
          o && "inputAdornedEnd",
          m && "readOnly",
        ],
      };
    return Fn(S, gN, e);
  },
  Ay = jt("div", { name: "MuiInputBase", slot: "Root", overridesResolver: Ty })(
    ({ theme: n, ownerState: e }) =>
      ue(
        {},
        n.typography.body1,
        {
          color: (n.vars || n).palette.text.primary,
          lineHeight: "1.4375em",
          boxSizing: "border-box",
          position: "relative",
          cursor: "text",
          display: "inline-flex",
          alignItems: "center",
          [`&.${wh.disabled}`]: {
            color: (n.vars || n).palette.text.disabled,
            cursor: "default",
          },
        },
        e.multiline &&
          ue({ padding: "4px 0 5px" }, e.size === "small" && { paddingTop: 1 }),
        e.fullWidth && { width: "100%" }
      )
  ),
  Ry = jt("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: Cy,
  })(({ theme: n, ownerState: e }) => {
    const t = n.palette.mode === "light",
      r = ue(
        { color: "currentColor" },
        n.vars
          ? { opacity: n.vars.opacity.inputPlaceholder }
          : { opacity: t ? 0.42 : 0.5 },
        {
          transition: n.transitions.create("opacity", {
            duration: n.transitions.duration.shorter,
          }),
        }
      ),
      i = { opacity: "0 !important" },
      o = n.vars
        ? { opacity: n.vars.opacity.inputPlaceholder }
        : { opacity: t ? 0.42 : 0.5 };
    return ue(
      {
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": r,
        "&::-moz-placeholder": r,
        "&:-ms-input-placeholder": r,
        "&::-ms-input-placeholder": r,
        "&:focus": { outline: 0 },
        "&:invalid": { boxShadow: "none" },
        "&::-webkit-search-decoration": { WebkitAppearance: "none" },
        [`label[data-shrink=false] + .${wh.formControl} &`]: {
          "&::-webkit-input-placeholder": i,
          "&::-moz-placeholder": i,
          "&:-ms-input-placeholder": i,
          "&::-ms-input-placeholder": i,
          "&:focus::-webkit-input-placeholder": o,
          "&:focus::-moz-placeholder": o,
          "&:focus:-ms-input-placeholder": o,
          "&:focus::-ms-input-placeholder": o,
        },
        [`&.${wh.disabled}`]: {
          opacity: 1,
          WebkitTextFillColor: (n.vars || n).palette.text.disabled,
        },
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill",
        },
      },
      e.size === "small" && { paddingTop: 1 },
      e.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0,
      },
      e.type === "search" && { MozAppearance: "textfield" }
    );
  }),
  xN = Q.jsx(pN, {
    styles: {
      "@keyframes mui-auto-fill": { from: { display: "block" } },
      "@keyframes mui-auto-fill-cancel": { from: { display: "block" } },
    },
  }),
  VS = K.forwardRef(function (e, t) {
    var r;
    const i = Xn({ props: e, name: "MuiInputBase" }),
      {
        "aria-describedby": o,
        autoComplete: s,
        autoFocus: l,
        className: u,
        components: f = {},
        componentsProps: h = {},
        defaultValue: m,
        disabled: g,
        disableInjectingGlobalStyles: y,
        endAdornment: x,
        fullWidth: S = !1,
        id: _,
        inputComponent: w = "input",
        inputProps: T = {},
        inputRef: E,
        maxRows: A,
        minRows: R,
        multiline: k = !1,
        name: P,
        onBlur: U,
        onChange: N,
        onClick: L,
        onFocus: H,
        onKeyDown: G,
        onKeyUp: $,
        placeholder: q,
        readOnly: Z,
        renderSuffix: X,
        rows: re,
        slotProps: W = {},
        slots: te = {},
        startAdornment: F,
        type: V = "text",
        value: ne,
      } = i,
      ae = Pt(i, vN),
      J = T.value != null ? T.value : ne,
      { current: oe } = K.useRef(J != null),
      de = K.useRef(),
      le = K.useCallback((Be) => {}, []),
      fe = ri(de, E, T.ref, le),
      [Ee, ge] = K.useState(!1),
      xe = kh(),
      j = Lh({
        props: i,
        muiFormControl: xe,
        states: [
          "color",
          "disabled",
          "error",
          "hiddenLabel",
          "size",
          "required",
          "filled",
        ],
      });
    (j.focused = xe ? xe.focused : Ee),
      K.useEffect(() => {
        !xe && g && Ee && (ge(!1), U && U());
      }, [xe, g, Ee, U]);
    const we = xe && xe.onFilled,
      Ae = xe && xe.onEmpty,
      Ne = K.useCallback(
        (Be) => {
          w0(Be) ? we && we() : Ae && Ae();
        },
        [we, Ae]
      );
    $a(() => {
      oe && Ne({ value: J });
    }, [J, Ne, oe]);
    const Ie = (Be) => {
        if (j.disabled) {
          Be.stopPropagation();
          return;
        }
        H && H(Be),
          T.onFocus && T.onFocus(Be),
          xe && xe.onFocus ? xe.onFocus(Be) : ge(!0);
      },
      rt = (Be) => {
        U && U(Be),
          T.onBlur && T.onBlur(Be),
          xe && xe.onBlur ? xe.onBlur(Be) : ge(!1);
      },
      ke = (Be, ...We) => {
        if (!oe) {
          const Ye = Be.target || de.current;
          if (Ye == null) throw new Error(Ll(1));
          Ne({ value: Ye.value });
        }
        T.onChange && T.onChange(Be, ...We), N && N(Be, ...We);
      };
    K.useEffect(() => {
      Ne(de.current);
    }, []);
    const Xe = (Be) => {
      de.current && Be.currentTarget === Be.target && de.current.focus(),
        L && L(Be);
    };
    let ee = w,
      B = T;
    k &&
      ee === "input" &&
      (re
        ? (B = ue({ type: void 0, minRows: re, maxRows: re }, B))
        : (B = ue({ type: void 0, maxRows: A, minRows: R }, B)),
      (ee = hN));
    const ve = (Be) => {
      Ne(
        Be.animationName === "mui-auto-fill-cancel"
          ? de.current
          : { value: "x" }
      );
    };
    K.useEffect(() => {
      xe && xe.setAdornedStart(!!F);
    }, [xe, F]);
    const Se = ue({}, i, {
        color: j.color || "primary",
        disabled: j.disabled,
        endAdornment: x,
        error: j.error,
        focused: j.focused,
        formControl: xe,
        fullWidth: S,
        hiddenLabel: j.hiddenLabel,
        multiline: k,
        size: j.size,
        startAdornment: F,
        type: V,
      }),
      _e = yN(Se),
      Te = te.root || f.Root || Ay,
      at = W.root || h.root || {},
      Fe = te.input || f.Input || Ry;
    return (
      (B = ue({}, B, (r = W.input) != null ? r : h.input)),
      Q.jsxs(K.Fragment, {
        children: [
          !y && xN,
          Q.jsxs(
            Te,
            ue(
              {},
              at,
              !_h(Te) && { ownerState: ue({}, Se, at.ownerState) },
              { ref: t, onClick: Xe },
              ae,
              {
                className: Zt(
                  _e.root,
                  at.className,
                  u,
                  Z && "MuiInputBase-readOnly"
                ),
                children: [
                  F,
                  Q.jsx(HS.Provider, {
                    value: null,
                    children: Q.jsx(
                      Fe,
                      ue(
                        {
                          ownerState: Se,
                          "aria-invalid": j.error,
                          "aria-describedby": o,
                          autoComplete: s,
                          autoFocus: l,
                          defaultValue: m,
                          disabled: j.disabled,
                          id: _,
                          onAnimationStart: ve,
                          name: P,
                          placeholder: q,
                          readOnly: Z,
                          required: j.required,
                          rows: re,
                          value: J,
                          onKeyDown: G,
                          onKeyUp: $,
                          type: V,
                        },
                        B,
                        !_h(Fe) && {
                          as: ee,
                          ownerState: ue({}, Se, B.ownerState),
                        },
                        {
                          ref: fe,
                          className: Zt(
                            _e.input,
                            B.className,
                            Z && "MuiInputBase-readOnly"
                          ),
                          onBlur: rt,
                          onChange: ke,
                          onFocus: Ie,
                        }
                      )
                    ),
                  }),
                  x,
                  X ? X(ue({}, j, { startAdornment: F })) : null,
                ],
              }
            )
          ),
        ],
      })
    );
  });
function _N(n) {
  return Un("MuiInput", n);
}
const Cp = ue({}, wh, In("MuiInput", ["root", "underline", "input"]));
function SN(n) {
  return Un("MuiOutlinedInput", n);
}
const Eu = ue(
  {},
  wh,
  In("MuiOutlinedInput", ["root", "notchedOutline", "input"])
);
function wN(n) {
  return Un("MuiFilledInput", n);
}
const Ac = ue({}, wh, In("MuiFilledInput", ["root", "underline", "input"])),
  bN = Ef(Q.jsx("path", { d: "M7 10l5 5 5-5z" }), "ArrowDropDown"),
  MN = [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    "TransitionComponent",
  ],
  EN = { entering: { opacity: 1 }, entered: { opacity: 1 } },
  TN = K.forwardRef(function (e, t) {
    const r = M2(),
      i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen,
      },
      {
        addEndListener: o,
        appear: s = !0,
        children: l,
        easing: u,
        in: f,
        onEnter: h,
        onEntered: m,
        onEntering: g,
        onExit: y,
        onExited: x,
        onExiting: S,
        style: _,
        timeout: w = i,
        TransitionComponent: T = Ya,
      } = e,
      E = Pt(e, MN),
      A = K.useRef(null),
      R = ri(A, l.ref, t),
      k = (q) => (Z) => {
        if (q) {
          const X = A.current;
          Z === void 0 ? q(X) : q(X, Z);
        }
      },
      P = k(g),
      U = k((q, Z) => {
        C2(q);
        const X = S0({ style: _, timeout: w, easing: u }, { mode: "enter" });
        (q.style.webkitTransition = r.transitions.create("opacity", X)),
          (q.style.transition = r.transitions.create("opacity", X)),
          h && h(q, Z);
      }),
      N = k(m),
      L = k(S),
      H = k((q) => {
        const Z = S0({ style: _, timeout: w, easing: u }, { mode: "exit" });
        (q.style.webkitTransition = r.transitions.create("opacity", Z)),
          (q.style.transition = r.transitions.create("opacity", Z)),
          y && y(q);
      }),
      G = k(x),
      $ = (q) => {
        o && o(A.current, q);
      };
    return Q.jsx(
      T,
      ue(
        {
          appear: s,
          in: f,
          nodeRef: A,
          onEnter: U,
          onEntered: N,
          onEntering: P,
          onExit: H,
          onExited: G,
          onExiting: L,
          addEndListener: $,
          timeout: w,
        },
        E,
        {
          children: (q, Z) =>
            K.cloneElement(
              l,
              ue(
                {
                  style: ue(
                    {
                      opacity: 0,
                      visibility: q === "exited" && !f ? "hidden" : void 0,
                    },
                    EN[q],
                    _,
                    l.props.style
                  ),
                  ref: R,
                },
                Z
              )
            ),
        }
      )
    );
  });
function CN(n) {
  return Un("MuiBackdrop", n);
}
In("MuiBackdrop", ["root", "invisible"]);
const AN = [
    "children",
    "className",
    "component",
    "components",
    "componentsProps",
    "invisible",
    "open",
    "slotProps",
    "slots",
    "TransitionComponent",
    "transitionDuration",
  ],
  RN = (n) => {
    const { classes: e, invisible: t } = n;
    return Fn({ root: ["root", t && "invisible"] }, CN, e);
  },
  PN = jt("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, t.invisible && e.invisible];
    },
  })(({ ownerState: n }) =>
    ue(
      {
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        WebkitTapHighlightColor: "transparent",
      },
      n.invisible && { backgroundColor: "transparent" }
    )
  ),
  IN = K.forwardRef(function (e, t) {
    var r, i, o;
    const s = Xn({ props: e, name: "MuiBackdrop" }),
      {
        children: l,
        className: u,
        component: f = "div",
        components: h = {},
        componentsProps: m = {},
        invisible: g = !1,
        open: y,
        slotProps: x = {},
        slots: S = {},
        TransitionComponent: _ = TN,
        transitionDuration: w,
      } = s,
      T = Pt(s, AN),
      E = ue({}, s, { component: f, invisible: g }),
      A = RN(E),
      R = (r = x.root) != null ? r : m.root;
    return Q.jsx(
      _,
      ue({ in: y, timeout: w }, T, {
        children: Q.jsx(
          PN,
          ue({ "aria-hidden": !0 }, R, {
            as: (i = (o = S.root) != null ? o : h.Root) != null ? i : f,
            className: Zt(A.root, u, R == null ? void 0 : R.className),
            ownerState: ue({}, E, R == null ? void 0 : R.ownerState),
            classes: A,
            ref: t,
            children: l,
          })
        ),
      })
    );
  }),
  LN = In("MuiBox", ["root"]),
  kN = b2(),
  xn = zL({
    themeId: cy,
    defaultTheme: kN,
    defaultClassName: LN.root,
    generateClassName: LS.generate,
  });
function DN(n) {
  return Un("MuiButton", n);
}
const lv = In("MuiButton", [
    "root",
    "text",
    "textInherit",
    "textPrimary",
    "textSecondary",
    "textSuccess",
    "textError",
    "textInfo",
    "textWarning",
    "outlined",
    "outlinedInherit",
    "outlinedPrimary",
    "outlinedSecondary",
    "outlinedSuccess",
    "outlinedError",
    "outlinedInfo",
    "outlinedWarning",
    "contained",
    "containedInherit",
    "containedPrimary",
    "containedSecondary",
    "containedSuccess",
    "containedError",
    "containedInfo",
    "containedWarning",
    "disableElevation",
    "focusVisible",
    "disabled",
    "colorInherit",
    "colorPrimary",
    "colorSecondary",
    "colorSuccess",
    "colorError",
    "colorInfo",
    "colorWarning",
    "textSizeSmall",
    "textSizeMedium",
    "textSizeLarge",
    "outlinedSizeSmall",
    "outlinedSizeMedium",
    "outlinedSizeLarge",
    "containedSizeSmall",
    "containedSizeMedium",
    "containedSizeLarge",
    "sizeMedium",
    "sizeSmall",
    "sizeLarge",
    "fullWidth",
    "startIcon",
    "endIcon",
    "icon",
    "iconSizeSmall",
    "iconSizeMedium",
    "iconSizeLarge",
  ]),
  NN = K.createContext({}),
  ON = K.createContext(void 0),
  UN = [
    "children",
    "color",
    "component",
    "className",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "endIcon",
    "focusVisibleClassName",
    "fullWidth",
    "size",
    "startIcon",
    "type",
    "variant",
  ],
  FN = (n) => {
    const {
        color: e,
        disableElevation: t,
        fullWidth: r,
        size: i,
        variant: o,
        classes: s,
      } = n,
      l = {
        root: [
          "root",
          o,
          `${o}${an(e)}`,
          `size${an(i)}`,
          `${o}Size${an(i)}`,
          `color${an(e)}`,
          t && "disableElevation",
          r && "fullWidth",
        ],
        label: ["label"],
        startIcon: ["icon", "startIcon", `iconSize${an(i)}`],
        endIcon: ["icon", "endIcon", `iconSize${an(i)}`],
      },
      u = Fn(l, DN, s);
    return ue({}, s, u);
  },
  A2 = (n) =>
    ue(
      {},
      n.size === "small" && { "& > *:nth-of-type(1)": { fontSize: 18 } },
      n.size === "medium" && { "& > *:nth-of-type(1)": { fontSize: 20 } },
      n.size === "large" && { "& > *:nth-of-type(1)": { fontSize: 22 } }
    ),
  BN = jt(zS, {
    shouldForwardProp: (n) => Ps(n) || n === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        e[t.variant],
        e[`${t.variant}${an(t.color)}`],
        e[`size${an(t.size)}`],
        e[`${t.variant}Size${an(t.size)}`],
        t.color === "inherit" && e.colorInherit,
        t.disableElevation && e.disableElevation,
        t.fullWidth && e.fullWidth,
      ];
    },
  })(
    ({ theme: n, ownerState: e }) => {
      var t, r;
      const i =
          n.palette.mode === "light"
            ? n.palette.grey[300]
            : n.palette.grey[800],
        o =
          n.palette.mode === "light"
            ? n.palette.grey.A100
            : n.palette.grey[700];
      return ue(
        {},
        n.typography.button,
        {
          minWidth: 64,
          padding: "6px 16px",
          borderRadius: (n.vars || n).shape.borderRadius,
          transition: n.transitions.create(
            ["background-color", "box-shadow", "border-color", "color"],
            { duration: n.transitions.duration.short }
          ),
          "&:hover": ue(
            {
              textDecoration: "none",
              backgroundColor: n.vars
                ? `rgba(${n.vars.palette.text.primaryChannel} / ${n.vars.palette.action.hoverOpacity})`
                : Di.alpha(
                    n.palette.text.primary,
                    n.palette.action.hoverOpacity
                  ),
              "@media (hover: none)": { backgroundColor: "transparent" },
            },
            e.variant === "text" &&
              e.color !== "inherit" && {
                backgroundColor: n.vars
                  ? `rgba(${n.vars.palette[e.color].mainChannel} / ${
                      n.vars.palette.action.hoverOpacity
                    })`
                  : Di.alpha(
                      n.palette[e.color].main,
                      n.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            e.variant === "outlined" &&
              e.color !== "inherit" && {
                border: `1px solid ${(n.vars || n).palette[e.color].main}`,
                backgroundColor: n.vars
                  ? `rgba(${n.vars.palette[e.color].mainChannel} / ${
                      n.vars.palette.action.hoverOpacity
                    })`
                  : Di.alpha(
                      n.palette[e.color].main,
                      n.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            e.variant === "contained" && {
              backgroundColor: n.vars
                ? n.vars.palette.Button.inheritContainedHoverBg
                : o,
              boxShadow: (n.vars || n).shadows[4],
              "@media (hover: none)": {
                boxShadow: (n.vars || n).shadows[2],
                backgroundColor: (n.vars || n).palette.grey[300],
              },
            },
            e.variant === "contained" &&
              e.color !== "inherit" && {
                backgroundColor: (n.vars || n).palette[e.color].dark,
                "@media (hover: none)": {
                  backgroundColor: (n.vars || n).palette[e.color].main,
                },
              }
          ),
          "&:active": ue(
            {},
            e.variant === "contained" && { boxShadow: (n.vars || n).shadows[8] }
          ),
          [`&.${lv.focusVisible}`]: ue(
            {},
            e.variant === "contained" && { boxShadow: (n.vars || n).shadows[6] }
          ),
          [`&.${lv.disabled}`]: ue(
            { color: (n.vars || n).palette.action.disabled },
            e.variant === "outlined" && {
              border: `1px solid ${
                (n.vars || n).palette.action.disabledBackground
              }`,
            },
            e.variant === "contained" && {
              color: (n.vars || n).palette.action.disabled,
              boxShadow: (n.vars || n).shadows[0],
              backgroundColor: (n.vars || n).palette.action.disabledBackground,
            }
          ),
        },
        e.variant === "text" && { padding: "6px 8px" },
        e.variant === "text" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].main,
          },
        e.variant === "outlined" && {
          padding: "5px 15px",
          border: "1px solid currentColor",
        },
        e.variant === "outlined" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].main,
            border: n.vars
              ? `1px solid rgba(${n.vars.palette[e.color].mainChannel} / 0.5)`
              : `1px solid ${Di.alpha(n.palette[e.color].main, 0.5)}`,
          },
        e.variant === "contained" && {
          color: n.vars
            ? n.vars.palette.text.primary
            : (t = (r = n.palette).getContrastText) == null
            ? void 0
            : t.call(r, n.palette.grey[300]),
          backgroundColor: n.vars
            ? n.vars.palette.Button.inheritContainedBg
            : i,
          boxShadow: (n.vars || n).shadows[2],
        },
        e.variant === "contained" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].contrastText,
            backgroundColor: (n.vars || n).palette[e.color].main,
          },
        e.color === "inherit" && {
          color: "inherit",
          borderColor: "currentColor",
        },
        e.size === "small" &&
          e.variant === "text" && {
            padding: "4px 5px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "text" && {
            padding: "8px 11px",
            fontSize: n.typography.pxToRem(15),
          },
        e.size === "small" &&
          e.variant === "outlined" && {
            padding: "3px 9px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "outlined" && {
            padding: "7px 21px",
            fontSize: n.typography.pxToRem(15),
          },
        e.size === "small" &&
          e.variant === "contained" && {
            padding: "4px 10px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "contained" && {
            padding: "8px 22px",
            fontSize: n.typography.pxToRem(15),
          },
        e.fullWidth && { width: "100%" }
      );
    },
    ({ ownerState: n }) =>
      n.disableElevation && {
        boxShadow: "none",
        "&:hover": { boxShadow: "none" },
        [`&.${lv.focusVisible}`]: { boxShadow: "none" },
        "&:active": { boxShadow: "none" },
        [`&.${lv.disabled}`]: { boxShadow: "none" },
      }
  ),
  zN = jt("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.startIcon, e[`iconSize${an(t.size)}`]];
    },
  })(({ ownerState: n }) =>
    ue(
      { display: "inherit", marginRight: 8, marginLeft: -4 },
      n.size === "small" && { marginLeft: -2 },
      A2(n)
    )
  ),
  HN = jt("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.endIcon, e[`iconSize${an(t.size)}`]];
    },
  })(({ ownerState: n }) =>
    ue(
      { display: "inherit", marginRight: -4, marginLeft: 8 },
      n.size === "small" && { marginRight: -2 },
      A2(n)
    )
  ),
  rm = K.forwardRef(function (e, t) {
    const r = K.useContext(NN),
      i = K.useContext(ON),
      o = wm(r, e),
      s = Xn({ props: o, name: "MuiButton" }),
      {
        children: l,
        color: u = "primary",
        component: f = "button",
        className: h,
        disabled: m = !1,
        disableElevation: g = !1,
        disableFocusRipple: y = !1,
        endIcon: x,
        focusVisibleClassName: S,
        fullWidth: _ = !1,
        size: w = "medium",
        startIcon: T,
        type: E,
        variant: A = "text",
      } = s,
      R = Pt(s, UN),
      k = ue({}, s, {
        color: u,
        component: f,
        disabled: m,
        disableElevation: g,
        disableFocusRipple: y,
        fullWidth: _,
        size: w,
        type: E,
        variant: A,
      }),
      P = FN(k),
      U =
        T && Q.jsx(zN, { className: P.startIcon, ownerState: k, children: T }),
      N = x && Q.jsx(HN, { className: P.endIcon, ownerState: k, children: x }),
      L = i || "";
    return Q.jsxs(
      BN,
      ue(
        {
          ownerState: k,
          className: Zt(r.className, P.root, h, L),
          component: f,
          disabled: m,
          focusRipple: !y,
          focusVisibleClassName: Zt(P.focusVisible, S),
          ref: t,
          type: E,
        },
        R,
        { classes: P, children: [U, l, N] }
      )
    );
  });
function VN(n) {
  const e = Uo(n);
  return e.body === n
    ? Vu(n).innerWidth > e.documentElement.clientWidth
    : n.scrollHeight > n.clientHeight;
}
function im(n, e) {
  e ? n.setAttribute("aria-hidden", "true") : n.removeAttribute("aria-hidden");
}
function DM(n) {
  return parseInt(Vu(n).getComputedStyle(n).paddingRight, 10) || 0;
}
function GN(n) {
  const t =
      [
        "TEMPLATE",
        "SCRIPT",
        "STYLE",
        "LINK",
        "MAP",
        "META",
        "NOSCRIPT",
        "PICTURE",
        "COL",
        "COLGROUP",
        "PARAM",
        "SLOT",
        "SOURCE",
        "TRACK",
      ].indexOf(n.tagName) !== -1,
    r = n.tagName === "INPUT" && n.getAttribute("type") === "hidden";
  return t || r;
}
function NM(n, e, t, r, i) {
  const o = [e, t, ...r];
  [].forEach.call(n.children, (s) => {
    const l = o.indexOf(s) === -1,
      u = !GN(s);
    l && u && im(s, i);
  });
}
function u_(n, e) {
  let t = -1;
  return n.some((r, i) => (e(r) ? ((t = i), !0) : !1)), t;
}
function WN(n, e) {
  const t = [],
    r = n.container;
  if (!e.disableScrollLock) {
    if (VN(r)) {
      const s = y2(Uo(r));
      t.push({ value: r.style.paddingRight, property: "padding-right", el: r }),
        (r.style.paddingRight = `${DM(r) + s}px`);
      const l = Uo(r).querySelectorAll(".mui-fixed");
      [].forEach.call(l, (u) => {
        t.push({
          value: u.style.paddingRight,
          property: "padding-right",
          el: u,
        }),
          (u.style.paddingRight = `${DM(u) + s}px`);
      });
    }
    let o;
    if (r.parentNode instanceof DocumentFragment) o = Uo(r).body;
    else {
      const s = r.parentElement,
        l = Vu(r);
      o =
        (s == null ? void 0 : s.nodeName) === "HTML" &&
        l.getComputedStyle(s).overflowY === "scroll"
          ? s
          : r;
    }
    t.push(
      { value: o.style.overflow, property: "overflow", el: o },
      { value: o.style.overflowX, property: "overflow-x", el: o },
      { value: o.style.overflowY, property: "overflow-y", el: o }
    ),
      (o.style.overflow = "hidden");
  }
  return () => {
    t.forEach(({ value: o, el: s, property: l }) => {
      o ? s.style.setProperty(l, o) : s.style.removeProperty(l);
    });
  };
}
function jN(n) {
  const e = [];
  return (
    [].forEach.call(n.children, (t) => {
      t.getAttribute("aria-hidden") === "true" && e.push(t);
    }),
    e
  );
}
class $N {
  constructor() {
    (this.containers = void 0),
      (this.modals = void 0),
      (this.modals = []),
      (this.containers = []);
  }
  add(e, t) {
    let r = this.modals.indexOf(e);
    if (r !== -1) return r;
    (r = this.modals.length),
      this.modals.push(e),
      e.modalRef && im(e.modalRef, !1);
    const i = jN(t);
    NM(t, e.mount, e.modalRef, i, !0);
    const o = u_(this.containers, (s) => s.container === t);
    return o !== -1
      ? (this.containers[o].modals.push(e), r)
      : (this.containers.push({
          modals: [e],
          container: t,
          restore: null,
          hiddenSiblings: i,
        }),
        r);
  }
  mount(e, t) {
    const r = u_(this.containers, (o) => o.modals.indexOf(e) !== -1),
      i = this.containers[r];
    i.restore || (i.restore = WN(i, t));
  }
  remove(e, t = !0) {
    const r = this.modals.indexOf(e);
    if (r === -1) return r;
    const i = u_(this.containers, (s) => s.modals.indexOf(e) !== -1),
      o = this.containers[i];
    if (
      (o.modals.splice(o.modals.indexOf(e), 1),
      this.modals.splice(r, 1),
      o.modals.length === 0)
    )
      o.restore && o.restore(),
        e.modalRef && im(e.modalRef, t),
        NM(o.container, e.mount, e.modalRef, o.hiddenSiblings, !1),
        this.containers.splice(i, 1);
    else {
      const s = o.modals[o.modals.length - 1];
      s.modalRef && im(s.modalRef, !1);
    }
    return r;
  }
  isTopModal(e) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === e;
  }
}
const XN = [
  "input",
  "select",
  "textarea",
  "a[href]",
  "button",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable="false"])',
].join(",");
function YN(n) {
  const e = parseInt(n.getAttribute("tabindex") || "", 10);
  return Number.isNaN(e)
    ? n.contentEditable === "true" ||
      ((n.nodeName === "AUDIO" ||
        n.nodeName === "VIDEO" ||
        n.nodeName === "DETAILS") &&
        n.getAttribute("tabindex") === null)
      ? 0
      : n.tabIndex
    : e;
}
function qN(n) {
  if (n.tagName !== "INPUT" || n.type !== "radio" || !n.name) return !1;
  const e = (r) => n.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let t = e(`[name="${n.name}"]:checked`);
  return t || (t = e(`[name="${n.name}"]`)), t !== n;
}
function KN(n) {
  return !(
    n.disabled ||
    (n.tagName === "INPUT" && n.type === "hidden") ||
    qN(n)
  );
}
function ZN(n) {
  const e = [],
    t = [];
  return (
    Array.from(n.querySelectorAll(XN)).forEach((r, i) => {
      const o = YN(r);
      o === -1 ||
        !KN(r) ||
        (o === 0
          ? e.push(r)
          : t.push({ documentOrder: i, tabIndex: o, node: r }));
    }),
    t
      .sort((r, i) =>
        r.tabIndex === i.tabIndex
          ? r.documentOrder - i.documentOrder
          : r.tabIndex - i.tabIndex
      )
      .map((r) => r.node)
      .concat(e)
  );
}
function JN() {
  return !0;
}
function QN(n) {
  const {
      children: e,
      disableAutoFocus: t = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: i = !1,
      getTabbable: o = ZN,
      isEnabled: s = JN,
      open: l,
    } = n,
    u = K.useRef(!1),
    f = K.useRef(null),
    h = K.useRef(null),
    m = K.useRef(null),
    g = K.useRef(null),
    y = K.useRef(!1),
    x = K.useRef(null),
    S = ri(e.ref, x),
    _ = K.useRef(null);
  K.useEffect(() => {
    !l || !x.current || (y.current = !t);
  }, [t, l]),
    K.useEffect(() => {
      if (!l || !x.current) return;
      const E = Uo(x.current);
      return (
        x.current.contains(E.activeElement) ||
          (x.current.hasAttribute("tabIndex") ||
            x.current.setAttribute("tabIndex", "-1"),
          y.current && x.current.focus()),
        () => {
          i ||
            (m.current &&
              m.current.focus &&
              ((u.current = !0), m.current.focus()),
            (m.current = null));
        }
      );
    }, [l]),
    K.useEffect(() => {
      if (!l || !x.current) return;
      const E = Uo(x.current),
        A = (P) => {
          (_.current = P),
            !(r || !s() || P.key !== "Tab") &&
              E.activeElement === x.current &&
              P.shiftKey &&
              ((u.current = !0), h.current && h.current.focus());
        },
        R = () => {
          const P = x.current;
          if (P === null) return;
          if (!E.hasFocus() || !s() || u.current) {
            u.current = !1;
            return;
          }
          if (
            P.contains(E.activeElement) ||
            (r &&
              E.activeElement !== f.current &&
              E.activeElement !== h.current)
          )
            return;
          if (E.activeElement !== g.current) g.current = null;
          else if (g.current !== null) return;
          if (!y.current) return;
          let U = [];
          if (
            ((E.activeElement === f.current || E.activeElement === h.current) &&
              (U = o(x.current)),
            U.length > 0)
          ) {
            var N, L;
            const H = !!(
                (N = _.current) != null &&
                N.shiftKey &&
                ((L = _.current) == null ? void 0 : L.key) === "Tab"
              ),
              G = U[0],
              $ = U[U.length - 1];
            typeof G != "string" &&
              typeof $ != "string" &&
              (H ? $.focus() : G.focus());
          } else P.focus();
        };
      E.addEventListener("focusin", R), E.addEventListener("keydown", A, !0);
      const k = setInterval(() => {
        E.activeElement && E.activeElement.tagName === "BODY" && R();
      }, 50);
      return () => {
        clearInterval(k),
          E.removeEventListener("focusin", R),
          E.removeEventListener("keydown", A, !0);
      };
    }, [t, r, i, s, l, o]);
  const w = (E) => {
      m.current === null && (m.current = E.relatedTarget),
        (y.current = !0),
        (g.current = E.target);
      const A = e.props.onFocus;
      A && A(E);
    },
    T = (E) => {
      m.current === null && (m.current = E.relatedTarget), (y.current = !0);
    };
  return Q.jsxs(K.Fragment, {
    children: [
      Q.jsx("div", {
        tabIndex: l ? 0 : -1,
        onFocus: T,
        ref: f,
        "data-testid": "sentinelStart",
      }),
      K.cloneElement(e, { ref: S, onFocus: w }),
      Q.jsx("div", {
        tabIndex: l ? 0 : -1,
        onFocus: T,
        ref: h,
        "data-testid": "sentinelEnd",
      }),
    ],
  });
}
function eO(n) {
  return typeof n == "function" ? n() : n;
}
function tO(n) {
  return n ? n.props.hasOwnProperty("in") : !1;
}
const nO = new $N();
function rO(n) {
  const {
      container: e,
      disableEscapeKeyDown: t = !1,
      disableScrollLock: r = !1,
      manager: i = nO,
      closeAfterTransition: o = !1,
      onTransitionEnter: s,
      onTransitionExited: l,
      children: u,
      onClose: f,
      open: h,
      rootRef: m,
    } = n,
    g = K.useRef({}),
    y = K.useRef(null),
    x = K.useRef(null),
    S = ri(x, m),
    [_, w] = K.useState(!h),
    T = tO(u);
  let E = !0;
  (n["aria-hidden"] === "false" || n["aria-hidden"] === !1) && (E = !1);
  const A = () => Uo(y.current),
    R = () => (
      (g.current.modalRef = x.current), (g.current.mount = y.current), g.current
    ),
    k = () => {
      i.mount(R(), { disableScrollLock: r }),
        x.current && (x.current.scrollTop = 0);
    },
    P = rf(() => {
      const X = eO(e) || A().body;
      i.add(R(), X), x.current && k();
    }),
    U = K.useCallback(() => i.isTopModal(R()), [i]),
    N = rf((X) => {
      (y.current = X), X && (h && U() ? k() : x.current && im(x.current, E));
    }),
    L = K.useCallback(() => {
      i.remove(R(), E);
    }, [E, i]);
  K.useEffect(
    () => () => {
      L();
    },
    [L]
  ),
    K.useEffect(() => {
      h ? P() : (!T || !o) && L();
    }, [h, L, T, o, P]);
  const H = (X) => (re) => {
      var W;
      (W = X.onKeyDown) == null || W.call(X, re),
        !(re.key !== "Escape" || re.which === 229 || !U()) &&
          (t || (re.stopPropagation(), f && f(re, "escapeKeyDown")));
    },
    G = (X) => (re) => {
      var W;
      (W = X.onClick) == null || W.call(X, re),
        re.target === re.currentTarget && f && f(re, "backdropClick");
    };
  return {
    getRootProps: (X = {}) => {
      const re = x0(n);
      delete re.onTransitionEnter, delete re.onTransitionExited;
      const W = ue({}, re, X);
      return ue({ role: "presentation" }, W, { onKeyDown: H(W), ref: S });
    },
    getBackdropProps: (X = {}) => {
      const re = X;
      return ue({ "aria-hidden": !0 }, re, { onClick: G(re), open: h });
    },
    getTransitionProps: () => {
      const X = () => {
          w(!1), s && s();
        },
        re = () => {
          w(!0), l && l(), o && L();
        };
      return {
        onEnter: k1(X, u == null ? void 0 : u.props.onEnter),
        onExited: k1(re, u == null ? void 0 : u.props.onExited),
      };
    },
    rootRef: S,
    portalRef: N,
    isTopModal: U,
    exited: _,
    hasTransition: T,
  };
}
function iO(n) {
  return Un("MuiModal", n);
}
In("MuiModal", ["root", "hidden", "backdrop"]);
const oO = [
    "BackdropComponent",
    "BackdropProps",
    "classes",
    "className",
    "closeAfterTransition",
    "children",
    "container",
    "component",
    "components",
    "componentsProps",
    "disableAutoFocus",
    "disableEnforceFocus",
    "disableEscapeKeyDown",
    "disablePortal",
    "disableRestoreFocus",
    "disableScrollLock",
    "hideBackdrop",
    "keepMounted",
    "onBackdropClick",
    "onClose",
    "onTransitionEnter",
    "onTransitionExited",
    "open",
    "slotProps",
    "slots",
    "theme",
  ],
  sO = (n) => {
    const { open: e, exited: t, classes: r } = n;
    return Fn(
      { root: ["root", !e && t && "hidden"], backdrop: ["backdrop"] },
      iO,
      r
    );
  },
  aO = jt("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, !t.open && t.exited && e.hidden];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      {
        position: "fixed",
        zIndex: (n.vars || n).zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
      },
      !e.open && e.exited && { visibility: "hidden" }
    )
  ),
  lO = jt(IN, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (n, e) => e.backdrop,
  })({ zIndex: -1 }),
  uO = K.forwardRef(function (e, t) {
    var r, i, o, s, l, u;
    const f = Xn({ name: "MuiModal", props: e }),
      {
        BackdropComponent: h = lO,
        BackdropProps: m,
        className: g,
        closeAfterTransition: y = !1,
        children: x,
        container: S,
        component: _,
        components: w = {},
        componentsProps: T = {},
        disableAutoFocus: E = !1,
        disableEnforceFocus: A = !1,
        disableEscapeKeyDown: R = !1,
        disablePortal: k = !1,
        disableRestoreFocus: P = !1,
        disableScrollLock: U = !1,
        hideBackdrop: N = !1,
        keepMounted: L = !1,
        onBackdropClick: H,
        open: G,
        slotProps: $,
        slots: q,
      } = f,
      Z = Pt(f, oO),
      X = ue({}, f, {
        closeAfterTransition: y,
        disableAutoFocus: E,
        disableEnforceFocus: A,
        disableEscapeKeyDown: R,
        disablePortal: k,
        disableRestoreFocus: P,
        disableScrollLock: U,
        hideBackdrop: N,
        keepMounted: L,
      }),
      {
        getRootProps: re,
        getBackdropProps: W,
        getTransitionProps: te,
        portalRef: F,
        isTopModal: V,
        exited: ne,
        hasTransition: ae,
      } = rO(ue({}, X, { rootRef: t })),
      J = ue({}, X, { exited: ne }),
      oe = sO(J),
      de = {};
    if ((x.props.tabIndex === void 0 && (de.tabIndex = "-1"), ae)) {
      const { onEnter: we, onExited: Ae } = te();
      (de.onEnter = we), (de.onExited = Ae);
    }
    const le =
        (r = (i = q == null ? void 0 : q.root) != null ? i : w.Root) != null
          ? r
          : aO,
      fe =
        (o = (s = q == null ? void 0 : q.backdrop) != null ? s : w.Backdrop) !=
        null
          ? o
          : h,
      Ee = (l = $ == null ? void 0 : $.root) != null ? l : T.root,
      ge = (u = $ == null ? void 0 : $.backdrop) != null ? u : T.backdrop,
      xe = Sh({
        elementType: le,
        externalSlotProps: Ee,
        externalForwardedProps: Z,
        getSlotProps: re,
        additionalProps: { ref: t, as: _ },
        ownerState: J,
        className: Zt(
          g,
          Ee == null ? void 0 : Ee.className,
          oe == null ? void 0 : oe.root,
          !J.open && J.exited && (oe == null ? void 0 : oe.hidden)
        ),
      }),
      j = Sh({
        elementType: fe,
        externalSlotProps: ge,
        additionalProps: m,
        getSlotProps: (we) =>
          W(
            ue({}, we, {
              onClick: (Ae) => {
                H && H(Ae), we != null && we.onClick && we.onClick(Ae);
              },
            })
          ),
        className: Zt(
          ge == null ? void 0 : ge.className,
          m == null ? void 0 : m.className,
          oe == null ? void 0 : oe.backdrop
        ),
        ownerState: J,
      });
    return !L && !G && (!ae || ne)
      ? null
      : Q.jsx(uN, {
          ref: F,
          container: S,
          disablePortal: k,
          children: Q.jsxs(
            le,
            ue({}, xe, {
              children: [
                !N && h ? Q.jsx(fe, ue({}, j)) : null,
                Q.jsx(QN, {
                  disableEnforceFocus: A,
                  disableAutoFocus: E,
                  disableRestoreFocus: P,
                  isEnabled: V,
                  open: G,
                  children: K.cloneElement(x, de),
                }),
              ],
            })
          ),
        });
  }),
  OM = In("MuiDivider", [
    "root",
    "absolute",
    "fullWidth",
    "inset",
    "middle",
    "flexItem",
    "light",
    "vertical",
    "withChildren",
    "withChildrenVertical",
    "textAlignRight",
    "textAlignLeft",
    "wrapper",
    "wrapperVertical",
  ]),
  cO = [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "hiddenLabel",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type",
  ],
  fO = (n) => {
    const { classes: e, disableUnderline: t } = n,
      i = Fn({ root: ["root", !t && "underline"], input: ["input"] }, wN, e);
    return ue({}, e, i);
  },
  dO = jt(Ay, {
    shouldForwardProp: (n) => Ps(n) || n === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [...Ty(n, e), !t.disableUnderline && e.underline];
    },
  })(({ theme: n, ownerState: e }) => {
    var t;
    const r = n.palette.mode === "light",
      i = r ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
      o = r ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
      s = r ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
      l = r ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return ue(
      {
        position: "relative",
        backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
        borderTopLeftRadius: (n.vars || n).shape.borderRadius,
        borderTopRightRadius: (n.vars || n).shape.borderRadius,
        transition: n.transitions.create("background-color", {
          duration: n.transitions.duration.shorter,
          easing: n.transitions.easing.easeOut,
        }),
        "&:hover": {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.hoverBg : s,
          "@media (hover: none)": {
            backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
          },
        },
        [`&.${Ac.focused}`]: {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
        },
        [`&.${Ac.disabled}`]: {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.disabledBg : l,
        },
      },
      !e.disableUnderline && {
        "&::after": {
          borderBottom: `2px solid ${
            (t = (n.vars || n).palette[e.color || "primary"]) == null
              ? void 0
              : t.main
          }`,
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: n.transitions.create("transform", {
            duration: n.transitions.duration.shorter,
            easing: n.transitions.easing.easeOut,
          }),
          pointerEvents: "none",
        },
        [`&.${Ac.focused}:after`]: { transform: "scaleX(1) translateX(0)" },
        [`&.${Ac.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (n.vars || n).palette.error.main,
          },
        },
        "&::before": {
          borderBottom: `1px solid ${
            n.vars
              ? `rgba(${n.vars.palette.common.onBackgroundChannel} / ${n.vars.opacity.inputUnderline})`
              : i
          }`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: n.transitions.create("border-bottom-color", {
            duration: n.transitions.duration.shorter,
          }),
          pointerEvents: "none",
        },
        [`&:hover:not(.${Ac.disabled}, .${Ac.error}):before`]: {
          borderBottom: `1px solid ${(n.vars || n).palette.text.primary}`,
        },
        [`&.${Ac.disabled}:before`]: { borderBottomStyle: "dotted" },
      },
      e.startAdornment && { paddingLeft: 12 },
      e.endAdornment && { paddingRight: 12 },
      e.multiline &&
        ue(
          { padding: "25px 12px 8px" },
          e.size === "small" && { paddingTop: 21, paddingBottom: 4 },
          e.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
          e.hiddenLabel &&
            e.size === "small" && { paddingTop: 8, paddingBottom: 9 }
        )
    );
  }),
  hO = jt(Ry, { name: "MuiFilledInput", slot: "Input", overridesResolver: Cy })(
    ({ theme: n, ownerState: e }) =>
      ue(
        { paddingTop: 25, paddingRight: 12, paddingBottom: 8, paddingLeft: 12 },
        !n.vars && {
          "&:-webkit-autofill": {
            WebkitBoxShadow:
              n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
            caretColor: n.palette.mode === "light" ? null : "#fff",
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit",
          },
        },
        n.vars && {
          "&:-webkit-autofill": {
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit",
          },
          [n.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
              WebkitBoxShadow: "0 0 0 100px #266798 inset",
              WebkitTextFillColor: "#fff",
              caretColor: "#fff",
            },
          },
        },
        e.size === "small" && { paddingTop: 21, paddingBottom: 4 },
        e.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
        e.startAdornment && { paddingLeft: 0 },
        e.endAdornment && { paddingRight: 0 },
        e.hiddenLabel &&
          e.size === "small" && { paddingTop: 8, paddingBottom: 9 },
        e.multiline && {
          paddingTop: 0,
          paddingBottom: 0,
          paddingLeft: 0,
          paddingRight: 0,
        }
      )
  ),
  GS = K.forwardRef(function (e, t) {
    var r, i, o, s;
    const l = Xn({ props: e, name: "MuiFilledInput" }),
      {
        components: u = {},
        componentsProps: f,
        fullWidth: h = !1,
        inputComponent: m = "input",
        multiline: g = !1,
        slotProps: y,
        slots: x = {},
        type: S = "text",
      } = l,
      _ = Pt(l, cO),
      w = ue({}, l, { fullWidth: h, inputComponent: m, multiline: g, type: S }),
      T = fO(l),
      E = { root: { ownerState: w }, input: { ownerState: w } },
      A = y ?? f ? ni(E, y ?? f) : E,
      R = (r = (i = x.root) != null ? i : u.Root) != null ? r : dO,
      k = (o = (s = x.input) != null ? s : u.Input) != null ? o : hO;
    return Q.jsx(
      VS,
      ue(
        {
          slots: { root: R, input: k },
          componentsProps: A,
          fullWidth: h,
          inputComponent: m,
          multiline: g,
          ref: t,
          type: S,
        },
        _,
        { classes: T }
      )
    );
  });
GS.muiName = "Input";
function pO(n) {
  return Un("MuiFormControl", n);
}
In("MuiFormControl", [
  "root",
  "marginNone",
  "marginNormal",
  "marginDense",
  "fullWidth",
  "disabled",
]);
const mO = [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "focused",
    "fullWidth",
    "hiddenLabel",
    "margin",
    "required",
    "size",
    "variant",
  ],
  gO = (n) => {
    const { classes: e, margin: t, fullWidth: r } = n,
      i = {
        root: ["root", t !== "none" && `margin${an(t)}`, r && "fullWidth"],
      };
    return Fn(i, pO, e);
  },
  vO = jt("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({ ownerState: n }, e) =>
      ue({}, e.root, e[`margin${an(n.margin)}`], n.fullWidth && e.fullWidth),
  })(({ ownerState: n }) =>
    ue(
      {
        display: "inline-flex",
        flexDirection: "column",
        position: "relative",
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: "top",
      },
      n.margin === "normal" && { marginTop: 16, marginBottom: 8 },
      n.margin === "dense" && { marginTop: 8, marginBottom: 4 },
      n.fullWidth && { width: "100%" }
    )
  ),
  Yc = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiFormControl" }),
      {
        children: i,
        className: o,
        color: s = "primary",
        component: l = "div",
        disabled: u = !1,
        error: f = !1,
        focused: h,
        fullWidth: m = !1,
        hiddenLabel: g = !1,
        margin: y = "none",
        required: x = !1,
        size: S = "medium",
        variant: _ = "outlined",
      } = r,
      w = Pt(r, mO),
      T = ue({}, r, {
        color: s,
        component: l,
        disabled: u,
        error: f,
        fullWidth: m,
        hiddenLabel: g,
        margin: y,
        required: x,
        size: S,
        variant: _,
      }),
      E = gO(T),
      [A, R] = K.useState(() => {
        let $ = !1;
        return (
          i &&
            K.Children.forEach(i, (q) => {
              if (!nm(q, ["Input", "Select"])) return;
              const Z = nm(q, ["Select"]) ? q.props.input : q;
              Z && mN(Z.props) && ($ = !0);
            }),
          $
        );
      }),
      [k, P] = K.useState(() => {
        let $ = !1;
        return (
          i &&
            K.Children.forEach(i, (q) => {
              nm(q, ["Input", "Select"]) &&
                (w0(q.props, !0) || w0(q.props.inputProps, !0)) &&
                ($ = !0);
            }),
          $
        );
      }),
      [U, N] = K.useState(!1);
    u && U && N(!1);
    const L = h !== void 0 && !u ? h : U;
    let H;
    const G = K.useMemo(
      () => ({
        adornedStart: A,
        setAdornedStart: R,
        color: s,
        disabled: u,
        error: f,
        filled: k,
        focused: L,
        fullWidth: m,
        hiddenLabel: g,
        size: S,
        onBlur: () => {
          N(!1);
        },
        onEmpty: () => {
          P(!1);
        },
        onFilled: () => {
          P(!0);
        },
        onFocus: () => {
          N(!0);
        },
        registerEffect: H,
        required: x,
        variant: _,
      }),
      [A, s, u, f, k, L, m, g, H, x, S, _]
    );
    return Q.jsx(HS.Provider, {
      value: G,
      children: Q.jsx(
        vO,
        ue({ as: l, ownerState: T, className: Zt(E.root, o), ref: t }, w, {
          children: i,
        })
      ),
    });
  }),
  R2 = Bk({
    createStyledComponent: jt("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (n, e) => e.root,
    }),
    useThemeProps: (n) => Xn({ props: n, name: "MuiStack" }),
  });
function yO(n) {
  return Un("MuiFormHelperText", n);
}
const UM = In("MuiFormHelperText", [
  "root",
  "error",
  "disabled",
  "sizeSmall",
  "sizeMedium",
  "contained",
  "focused",
  "filled",
  "required",
]);
var FM;
const xO = [
    "children",
    "className",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "margin",
    "required",
    "variant",
  ],
  _O = (n) => {
    const {
        classes: e,
        contained: t,
        size: r,
        disabled: i,
        error: o,
        filled: s,
        focused: l,
        required: u,
      } = n,
      f = {
        root: [
          "root",
          i && "disabled",
          o && "error",
          r && `size${an(r)}`,
          t && "contained",
          l && "focused",
          s && "filled",
          u && "required",
        ],
      };
    return Fn(f, yO, e);
  },
  SO = jt("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.size && e[`size${an(t.size)}`],
        t.contained && e.contained,
        t.filled && e.filled,
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      { color: (n.vars || n).palette.text.secondary },
      n.typography.caption,
      {
        textAlign: "left",
        marginTop: 3,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        [`&.${UM.disabled}`]: { color: (n.vars || n).palette.text.disabled },
        [`&.${UM.error}`]: { color: (n.vars || n).palette.error.main },
      },
      e.size === "small" && { marginTop: 4 },
      e.contained && { marginLeft: 14, marginRight: 14 }
    )
  ),
  wO = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiFormHelperText" }),
      { children: i, className: o, component: s = "p" } = r,
      l = Pt(r, xO),
      u = kh(),
      f = Lh({
        props: r,
        muiFormControl: u,
        states: [
          "variant",
          "size",
          "disabled",
          "error",
          "filled",
          "focused",
          "required",
        ],
      }),
      h = ue({}, r, {
        component: s,
        contained: f.variant === "filled" || f.variant === "outlined",
        variant: f.variant,
        size: f.size,
        disabled: f.disabled,
        error: f.error,
        filled: f.filled,
        focused: f.focused,
        required: f.required,
      }),
      m = _O(h);
    return Q.jsx(
      SO,
      ue({ as: s, ownerState: h, className: Zt(m.root, o), ref: t }, l, {
        children:
          i === " "
            ? FM ||
              (FM = Q.jsx("span", { className: "notranslate", children: "​" }))
            : i,
      })
    );
  });
function bO(n) {
  return Un("MuiFormLabel", n);
}
const om = In("MuiFormLabel", [
    "root",
    "colorSecondary",
    "focused",
    "disabled",
    "error",
    "filled",
    "required",
    "asterisk",
  ]),
  MO = [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "required",
  ],
  EO = (n) => {
    const {
        classes: e,
        color: t,
        focused: r,
        disabled: i,
        error: o,
        filled: s,
        required: l,
      } = n,
      u = {
        root: [
          "root",
          `color${an(t)}`,
          i && "disabled",
          o && "error",
          s && "filled",
          r && "focused",
          l && "required",
        ],
        asterisk: ["asterisk", o && "error"],
      };
    return Fn(u, bO, e);
  },
  TO = jt("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: ({ ownerState: n }, e) =>
      ue(
        {},
        e.root,
        n.color === "secondary" && e.colorSecondary,
        n.filled && e.filled
      ),
  })(({ theme: n, ownerState: e }) =>
    ue({ color: (n.vars || n).palette.text.secondary }, n.typography.body1, {
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      [`&.${om.focused}`]: { color: (n.vars || n).palette[e.color].main },
      [`&.${om.disabled}`]: { color: (n.vars || n).palette.text.disabled },
      [`&.${om.error}`]: { color: (n.vars || n).palette.error.main },
    })
  ),
  CO = jt("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (n, e) => e.asterisk,
  })(({ theme: n }) => ({
    [`&.${om.error}`]: { color: (n.vars || n).palette.error.main },
  })),
  AO = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiFormLabel" }),
      { children: i, className: o, component: s = "label" } = r,
      l = Pt(r, MO),
      u = kh(),
      f = Lh({
        props: r,
        muiFormControl: u,
        states: ["color", "required", "focused", "disabled", "error", "filled"],
      }),
      h = ue({}, r, {
        color: f.color || "primary",
        component: s,
        disabled: f.disabled,
        error: f.error,
        filled: f.filled,
        focused: f.focused,
        required: f.required,
      }),
      m = EO(h);
    return Q.jsxs(
      TO,
      ue({ as: s, ownerState: h, className: Zt(m.root, o), ref: t }, l, {
        children: [
          i,
          f.required &&
            Q.jsxs(CO, {
              ownerState: h,
              "aria-hidden": !0,
              className: m.asterisk,
              children: [" ", "*"],
            }),
        ],
      })
    );
  }),
  RO = [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    "TransitionComponent",
  ];
function z1(n) {
  return `scale(${n}, ${n ** 2})`;
}
const PO = {
    entering: { opacity: 1, transform: z1(1) },
    entered: { opacity: 1, transform: "none" },
  },
  c_ =
    typeof navigator < "u" &&
    /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
    /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  P2 = K.forwardRef(function (e, t) {
    const {
        addEndListener: r,
        appear: i = !0,
        children: o,
        easing: s,
        in: l,
        onEnter: u,
        onEntered: f,
        onEntering: h,
        onExit: m,
        onExited: g,
        onExiting: y,
        style: x,
        timeout: S = "auto",
        TransitionComponent: _ = Ya,
      } = e,
      w = Pt(e, RO),
      T = v2(),
      E = K.useRef(),
      A = M2(),
      R = K.useRef(null),
      k = ri(R, o.ref, t),
      P = (Z) => (X) => {
        if (Z) {
          const re = R.current;
          X === void 0 ? Z(re) : Z(re, X);
        }
      },
      U = P(h),
      N = P((Z, X) => {
        C2(Z);
        const {
          duration: re,
          delay: W,
          easing: te,
        } = S0({ style: x, timeout: S, easing: s }, { mode: "enter" });
        let F;
        S === "auto"
          ? ((F = A.transitions.getAutoHeightDuration(Z.clientHeight)),
            (E.current = F))
          : (F = re),
          (Z.style.transition = [
            A.transitions.create("opacity", { duration: F, delay: W }),
            A.transitions.create("transform", {
              duration: c_ ? F : F * 0.666,
              delay: W,
              easing: te,
            }),
          ].join(",")),
          u && u(Z, X);
      }),
      L = P(f),
      H = P(y),
      G = P((Z) => {
        const {
          duration: X,
          delay: re,
          easing: W,
        } = S0({ style: x, timeout: S, easing: s }, { mode: "exit" });
        let te;
        S === "auto"
          ? ((te = A.transitions.getAutoHeightDuration(Z.clientHeight)),
            (E.current = te))
          : (te = X),
          (Z.style.transition = [
            A.transitions.create("opacity", { duration: te, delay: re }),
            A.transitions.create("transform", {
              duration: c_ ? te : te * 0.666,
              delay: c_ ? re : re || te * 0.333,
              easing: W,
            }),
          ].join(",")),
          (Z.style.opacity = 0),
          (Z.style.transform = z1(0.75)),
          m && m(Z);
      }),
      $ = P(g),
      q = (Z) => {
        S === "auto" && T.start(E.current || 0, Z), r && r(R.current, Z);
      };
    return Q.jsx(
      _,
      ue(
        {
          appear: i,
          in: l,
          nodeRef: R,
          onEnter: N,
          onEntered: L,
          onEntering: U,
          onExit: G,
          onExited: $,
          onExiting: H,
          addEndListener: q,
          timeout: S === "auto" ? null : S,
        },
        w,
        {
          children: (Z, X) =>
            K.cloneElement(
              o,
              ue(
                {
                  style: ue(
                    {
                      opacity: 0,
                      transform: z1(0.75),
                      visibility: Z === "exited" && !l ? "hidden" : void 0,
                    },
                    PO[Z],
                    x,
                    o.props.style
                  ),
                  ref: k,
                },
                X
              )
            ),
        }
      )
    );
  });
P2.muiSupportAuto = !0;
const IO = [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type",
  ],
  LO = (n) => {
    const { classes: e, disableUnderline: t } = n,
      i = Fn({ root: ["root", !t && "underline"], input: ["input"] }, _N, e);
    return ue({}, e, i);
  },
  kO = jt(Ay, {
    shouldForwardProp: (n) => Ps(n) || n === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [...Ty(n, e), !t.disableUnderline && e.underline];
    },
  })(({ theme: n, ownerState: e }) => {
    let r =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.42)"
        : "rgba(255, 255, 255, 0.7)";
    return (
      n.vars &&
        (r = `rgba(${n.vars.palette.common.onBackgroundChannel} / ${n.vars.opacity.inputUnderline})`),
      ue(
        { position: "relative" },
        e.formControl && { "label + &": { marginTop: 16 } },
        !e.disableUnderline && {
          "&::after": {
            borderBottom: `2px solid ${(n.vars || n).palette[e.color].main}`,
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: n.transitions.create("transform", {
              duration: n.transitions.duration.shorter,
              easing: n.transitions.easing.easeOut,
            }),
            pointerEvents: "none",
          },
          [`&.${Cp.focused}:after`]: { transform: "scaleX(1) translateX(0)" },
          [`&.${Cp.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (n.vars || n).palette.error.main,
            },
          },
          "&::before": {
            borderBottom: `1px solid ${r}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: n.transitions.create("border-bottom-color", {
              duration: n.transitions.duration.shorter,
            }),
            pointerEvents: "none",
          },
          [`&:hover:not(.${Cp.disabled}, .${Cp.error}):before`]: {
            borderBottom: `2px solid ${(n.vars || n).palette.text.primary}`,
            "@media (hover: none)": { borderBottom: `1px solid ${r}` },
          },
          [`&.${Cp.disabled}:before`]: { borderBottomStyle: "dotted" },
        }
      )
    );
  }),
  DO = jt(Ry, { name: "MuiInput", slot: "Input", overridesResolver: Cy })({}),
  WS = K.forwardRef(function (e, t) {
    var r, i, o, s;
    const l = Xn({ props: e, name: "MuiInput" }),
      {
        disableUnderline: u,
        components: f = {},
        componentsProps: h,
        fullWidth: m = !1,
        inputComponent: g = "input",
        multiline: y = !1,
        slotProps: x,
        slots: S = {},
        type: _ = "text",
      } = l,
      w = Pt(l, IO),
      T = LO(l),
      A = { root: { ownerState: { disableUnderline: u } } },
      R = x ?? h ? ni(x ?? h, A) : A,
      k = (r = (i = S.root) != null ? i : f.Root) != null ? r : kO,
      P = (o = (s = S.input) != null ? s : f.Input) != null ? o : DO;
    return Q.jsx(
      VS,
      ue(
        {
          slots: { root: k, input: P },
          slotProps: R,
          fullWidth: m,
          inputComponent: g,
          multiline: y,
          ref: t,
          type: _,
        },
        w,
        { classes: T }
      )
    );
  });
WS.muiName = "Input";
function NO(n) {
  return Un("MuiInputLabel", n);
}
In("MuiInputLabel", [
  "root",
  "focused",
  "disabled",
  "error",
  "required",
  "asterisk",
  "formControl",
  "sizeSmall",
  "shrink",
  "animated",
  "standard",
  "filled",
  "outlined",
]);
const OO = ["disableAnimation", "margin", "shrink", "variant", "className"],
  UO = (n) => {
    const {
        classes: e,
        formControl: t,
        size: r,
        shrink: i,
        disableAnimation: o,
        variant: s,
        required: l,
      } = n,
      u = {
        root: [
          "root",
          t && "formControl",
          !o && "animated",
          i && "shrink",
          r && r !== "normal" && `size${an(r)}`,
          s,
        ],
        asterisk: [l && "asterisk"],
      },
      f = Fn(u, NO, e);
    return ue({}, e, f);
  },
  FO = jt(AO, {
    shouldForwardProp: (n) => Ps(n) || n === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`& .${om.asterisk}`]: e.asterisk },
        e.root,
        t.formControl && e.formControl,
        t.size === "small" && e.sizeSmall,
        t.shrink && e.shrink,
        !t.disableAnimation && e.animated,
        t.focused && e.focused,
        e[t.variant],
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      {
        display: "block",
        transformOrigin: "top left",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        maxWidth: "100%",
      },
      e.formControl && {
        position: "absolute",
        left: 0,
        top: 0,
        transform: "translate(0, 20px) scale(1)",
      },
      e.size === "small" && { transform: "translate(0, 17px) scale(1)" },
      e.shrink && {
        transform: "translate(0, -1.5px) scale(0.75)",
        transformOrigin: "top left",
        maxWidth: "133%",
      },
      !e.disableAnimation && {
        transition: n.transitions.create(["color", "transform", "max-width"], {
          duration: n.transitions.duration.shorter,
          easing: n.transitions.easing.easeOut,
        }),
      },
      e.variant === "filled" &&
        ue(
          {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(12px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
          e.size === "small" && { transform: "translate(12px, 13px) scale(1)" },
          e.shrink &&
            ue(
              {
                userSelect: "none",
                pointerEvents: "auto",
                transform: "translate(12px, 7px) scale(0.75)",
                maxWidth: "calc(133% - 24px)",
              },
              e.size === "small" && {
                transform: "translate(12px, 4px) scale(0.75)",
              }
            )
        ),
      e.variant === "outlined" &&
        ue(
          {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(14px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
          e.size === "small" && { transform: "translate(14px, 9px) scale(1)" },
          e.shrink && {
            userSelect: "none",
            pointerEvents: "auto",
            maxWidth: "calc(133% - 32px)",
            transform: "translate(14px, -9px) scale(0.75)",
          }
        )
    )
  ),
  rh = K.forwardRef(function (e, t) {
    const r = Xn({ name: "MuiInputLabel", props: e }),
      { disableAnimation: i = !1, shrink: o, className: s } = r,
      l = Pt(r, OO),
      u = kh();
    let f = o;
    typeof f > "u" && u && (f = u.filled || u.focused || u.adornedStart);
    const h = Lh({
        props: r,
        muiFormControl: u,
        states: ["size", "variant", "required", "focused"],
      }),
      m = ue({}, r, {
        disableAnimation: i,
        formControl: u,
        shrink: f,
        size: h.size,
        variant: h.variant,
        required: h.required,
        focused: h.focused,
      }),
      g = UO(m);
    return Q.jsx(
      FO,
      ue(
        { "data-shrink": f, ownerState: m, ref: t, className: Zt(g.root, s) },
        l,
        { classes: g }
      )
    );
  }),
  Pl = K.createContext({});
function BO(n) {
  return Un("MuiList", n);
}
In("MuiList", ["root", "padding", "dense", "subheader"]);
const zO = [
    "children",
    "className",
    "component",
    "dense",
    "disablePadding",
    "subheader",
  ],
  HO = (n) => {
    const { classes: e, disablePadding: t, dense: r, subheader: i } = n;
    return Fn(
      { root: ["root", !t && "padding", r && "dense", i && "subheader"] },
      BO,
      e
    );
  },
  VO = jt("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        !t.disablePadding && e.padding,
        t.dense && e.dense,
        t.subheader && e.subheader,
      ];
    },
  })(({ ownerState: n }) =>
    ue(
      { listStyle: "none", margin: 0, padding: 0, position: "relative" },
      !n.disablePadding && { paddingTop: 8, paddingBottom: 8 },
      n.subheader && { paddingTop: 0 }
    )
  ),
  I2 = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiList" }),
      {
        children: i,
        className: o,
        component: s = "ul",
        dense: l = !1,
        disablePadding: u = !1,
        subheader: f,
      } = r,
      h = Pt(r, zO),
      m = K.useMemo(() => ({ dense: l }), [l]),
      g = ue({}, r, { component: s, dense: l, disablePadding: u }),
      y = HO(g);
    return Q.jsx(Pl.Provider, {
      value: m,
      children: Q.jsxs(
        VO,
        ue({ as: s, className: Zt(y.root, o), ref: t, ownerState: g }, h, {
          children: [f, i],
        })
      ),
    });
  });
function GO(n) {
  return Un("MuiListItem", n);
}
const ih = In("MuiListItem", [
    "root",
    "container",
    "focusVisible",
    "dense",
    "alignItemsFlexStart",
    "disabled",
    "divider",
    "gutters",
    "padding",
    "button",
    "secondaryAction",
    "selected",
  ]),
  WO = In("MuiListItemButton", [
    "root",
    "focusVisible",
    "dense",
    "alignItemsFlexStart",
    "disabled",
    "divider",
    "gutters",
    "selected",
  ]);
function jO(n) {
  return Un("MuiListItemSecondaryAction", n);
}
In("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const $O = ["className"],
  XO = (n) => {
    const { disableGutters: e, classes: t } = n;
    return Fn({ root: ["root", e && "disableGutters"] }, jO, t);
  },
  YO = jt("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, t.disableGutters && e.disableGutters];
    },
  })(({ ownerState: n }) =>
    ue(
      {
        position: "absolute",
        right: 16,
        top: "50%",
        transform: "translateY(-50%)",
      },
      n.disableGutters && { right: 0 }
    )
  ),
  L2 = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiListItemSecondaryAction" }),
      { className: i } = r,
      o = Pt(r, $O),
      s = K.useContext(Pl),
      l = ue({}, r, { disableGutters: s.disableGutters }),
      u = XO(l);
    return Q.jsx(
      YO,
      ue({ className: Zt(u.root, i), ownerState: l, ref: t }, o)
    );
  });
L2.muiName = "ListItemSecondaryAction";
const qO = ["className"],
  KO = [
    "alignItems",
    "autoFocus",
    "button",
    "children",
    "className",
    "component",
    "components",
    "componentsProps",
    "ContainerComponent",
    "ContainerProps",
    "dense",
    "disabled",
    "disableGutters",
    "disablePadding",
    "divider",
    "focusVisibleClassName",
    "secondaryAction",
    "selected",
    "slotProps",
    "slots",
  ],
  ZO = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.dense && e.dense,
      t.alignItems === "flex-start" && e.alignItemsFlexStart,
      t.divider && e.divider,
      !t.disableGutters && e.gutters,
      !t.disablePadding && e.padding,
      t.button && e.button,
      t.hasSecondaryAction && e.secondaryAction,
    ];
  },
  JO = (n) => {
    const {
      alignItems: e,
      button: t,
      classes: r,
      dense: i,
      disabled: o,
      disableGutters: s,
      disablePadding: l,
      divider: u,
      hasSecondaryAction: f,
      selected: h,
    } = n;
    return Fn(
      {
        root: [
          "root",
          i && "dense",
          !s && "gutters",
          !l && "padding",
          u && "divider",
          o && "disabled",
          t && "button",
          e === "flex-start" && "alignItemsFlexStart",
          f && "secondaryAction",
          h && "selected",
        ],
        container: ["container"],
      },
      GO,
      r
    );
  },
  QO = jt("div", { name: "MuiListItem", slot: "Root", overridesResolver: ZO })(
    ({ theme: n, ownerState: e }) =>
      ue(
        {
          display: "flex",
          justifyContent: "flex-start",
          alignItems: "center",
          position: "relative",
          textDecoration: "none",
          width: "100%",
          boxSizing: "border-box",
          textAlign: "left",
        },
        !e.disablePadding &&
          ue(
            { paddingTop: 8, paddingBottom: 8 },
            e.dense && { paddingTop: 4, paddingBottom: 4 },
            !e.disableGutters && { paddingLeft: 16, paddingRight: 16 },
            !!e.secondaryAction && { paddingRight: 48 }
          ),
        !!e.secondaryAction && { [`& > .${WO.root}`]: { paddingRight: 48 } },
        {
          [`&.${ih.focusVisible}`]: {
            backgroundColor: (n.vars || n).palette.action.focus,
          },
          [`&.${ih.selected}`]: {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
              : Di.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity
                ),
            [`&.${ih.focusVisible}`]: {
              backgroundColor: n.vars
                ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.focusOpacity}))`
                : Di.alpha(
                    n.palette.primary.main,
                    n.palette.action.selectedOpacity +
                      n.palette.action.focusOpacity
                  ),
            },
          },
          [`&.${ih.disabled}`]: {
            opacity: (n.vars || n).palette.action.disabledOpacity,
          },
        },
        e.alignItems === "flex-start" && { alignItems: "flex-start" },
        e.divider && {
          borderBottom: `1px solid ${(n.vars || n).palette.divider}`,
          backgroundClip: "padding-box",
        },
        e.button && {
          transition: n.transitions.create("background-color", {
            duration: n.transitions.duration.shortest,
          }),
          "&:hover": {
            textDecoration: "none",
            backgroundColor: (n.vars || n).palette.action.hover,
            "@media (hover: none)": { backgroundColor: "transparent" },
          },
          [`&.${ih.selected}:hover`]: {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.hoverOpacity}))`
              : Di.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity +
                    n.palette.action.hoverOpacity
                ),
            "@media (hover: none)": {
              backgroundColor: n.vars
                ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
                : Di.alpha(
                    n.palette.primary.main,
                    n.palette.action.selectedOpacity
                  ),
            },
          },
        },
        e.hasSecondaryAction && { paddingRight: 48 }
      )
  ),
  eU = jt("li", {
    name: "MuiListItem",
    slot: "Container",
    overridesResolver: (n, e) => e.container,
  })({ position: "relative" }),
  Rc = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiListItem" }),
      {
        alignItems: i = "center",
        autoFocus: o = !1,
        button: s = !1,
        children: l,
        className: u,
        component: f,
        components: h = {},
        componentsProps: m = {},
        ContainerComponent: g = "li",
        ContainerProps: { className: y } = {},
        dense: x = !1,
        disabled: S = !1,
        disableGutters: _ = !1,
        disablePadding: w = !1,
        divider: T = !1,
        focusVisibleClassName: E,
        secondaryAction: A,
        selected: R = !1,
        slotProps: k = {},
        slots: P = {},
      } = r,
      U = Pt(r.ContainerProps, qO),
      N = Pt(r, KO),
      L = K.useContext(Pl),
      H = K.useMemo(
        () => ({ dense: x || L.dense || !1, alignItems: i, disableGutters: _ }),
        [i, L.dense, x, _]
      ),
      G = K.useRef(null);
    $a(() => {
      o && G.current && G.current.focus();
    }, [o]);
    const $ = K.Children.toArray(l),
      q = $.length && nm($[$.length - 1], ["ListItemSecondaryAction"]),
      Z = ue({}, r, {
        alignItems: i,
        autoFocus: o,
        button: s,
        dense: H.dense,
        disabled: S,
        disableGutters: _,
        disablePadding: w,
        divider: T,
        hasSecondaryAction: q,
        selected: R,
      }),
      X = JO(Z),
      re = ri(G, t),
      W = P.root || h.Root || QO,
      te = k.root || m.root || {},
      F = ue({ className: Zt(X.root, te.className, u), disabled: S }, N);
    let V = f || "li";
    return (
      s &&
        ((F.component = f || "div"),
        (F.focusVisibleClassName = Zt(ih.focusVisible, E)),
        (V = zS)),
      q
        ? ((V = !F.component && !f ? "div" : V),
          g === "li" &&
            (V === "li"
              ? (V = "div")
              : F.component === "li" && (F.component = "div")),
          Q.jsx(Pl.Provider, {
            value: H,
            children: Q.jsxs(
              eU,
              ue(
                {
                  as: g,
                  className: Zt(X.container, y),
                  ref: re,
                  ownerState: Z,
                },
                U,
                {
                  children: [
                    Q.jsx(
                      W,
                      ue(
                        {},
                        te,
                        !_h(W) && {
                          as: V,
                          ownerState: ue({}, Z, te.ownerState),
                        },
                        F,
                        { children: $ }
                      )
                    ),
                    $.pop(),
                  ],
                }
              )
            ),
          }))
        : Q.jsx(Pl.Provider, {
            value: H,
            children: Q.jsxs(
              W,
              ue(
                {},
                te,
                { as: V, ref: re },
                !_h(W) && { ownerState: ue({}, Z, te.ownerState) },
                F,
                { children: [$, A && Q.jsx(L2, { children: A })] }
              )
            ),
          })
    );
  });
function tU(n) {
  return Un("MuiListItemIcon", n);
}
const BM = In("MuiListItemIcon", ["root", "alignItemsFlexStart"]),
  nU = ["className"],
  rU = (n) => {
    const { alignItems: e, classes: t } = n;
    return Fn(
      { root: ["root", e === "flex-start" && "alignItemsFlexStart"] },
      tU,
      t
    );
  },
  iU = jt("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, t.alignItems === "flex-start" && e.alignItemsFlexStart];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      {
        minWidth: 56,
        color: (n.vars || n).palette.action.active,
        flexShrink: 0,
        display: "inline-flex",
      },
      e.alignItems === "flex-start" && { marginTop: 8 }
    )
  ),
  Pc = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiListItemIcon" }),
      { className: i } = r,
      o = Pt(r, nU),
      s = K.useContext(Pl),
      l = ue({}, r, { alignItems: s.alignItems }),
      u = rU(l);
    return Q.jsx(
      iU,
      ue({ className: Zt(u.root, i), ownerState: l, ref: t }, o)
    );
  });
function oU(n) {
  return Un("MuiListItemText", n);
}
const b0 = In("MuiListItemText", [
    "root",
    "multiline",
    "dense",
    "inset",
    "primary",
    "secondary",
  ]),
  sU = [
    "children",
    "className",
    "disableTypography",
    "inset",
    "primary",
    "primaryTypographyProps",
    "secondary",
    "secondaryTypographyProps",
  ],
  aU = (n) => {
    const { classes: e, inset: t, primary: r, secondary: i, dense: o } = n;
    return Fn(
      {
        root: ["root", t && "inset", o && "dense", r && i && "multiline"],
        primary: ["primary"],
        secondary: ["secondary"],
      },
      oU,
      e
    );
  },
  lU = jt("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`& .${b0.primary}`]: e.primary },
        { [`& .${b0.secondary}`]: e.secondary },
        e.root,
        t.inset && e.inset,
        t.primary && t.secondary && e.multiline,
        t.dense && e.dense,
      ];
    },
  })(({ ownerState: n }) =>
    ue(
      { flex: "1 1 auto", minWidth: 0, marginTop: 4, marginBottom: 4 },
      n.primary && n.secondary && { marginTop: 6, marginBottom: 6 },
      n.inset && { paddingLeft: 56 }
    )
  ),
  Ic = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiListItemText" }),
      {
        children: i,
        className: o,
        disableTypography: s = !1,
        inset: l = !1,
        primary: u,
        primaryTypographyProps: f,
        secondary: h,
        secondaryTypographyProps: m,
      } = r,
      g = Pt(r, sU),
      { dense: y } = K.useContext(Pl);
    let x = u ?? i,
      S = h;
    const _ = ue({}, r, {
        disableTypography: s,
        inset: l,
        primary: !!x,
        secondary: !!S,
        dense: y,
      }),
      w = aU(_);
    return (
      x != null &&
        x.type !== mr &&
        !s &&
        (x = Q.jsx(
          mr,
          ue(
            {
              variant: y ? "body2" : "body1",
              className: w.primary,
              component: f != null && f.variant ? void 0 : "span",
              display: "block",
            },
            f,
            { children: x }
          )
        )),
      S != null &&
        S.type !== mr &&
        !s &&
        (S = Q.jsx(
          mr,
          ue(
            {
              variant: "body2",
              className: w.secondary,
              color: "text.secondary",
              display: "block",
            },
            m,
            { children: S }
          )
        )),
      Q.jsxs(
        lU,
        ue({ className: Zt(w.root, o), ownerState: _, ref: t }, g, {
          children: [x, S],
        })
      )
    );
  }),
  uU = [
    "actions",
    "autoFocus",
    "autoFocusItem",
    "children",
    "className",
    "disabledItemsFocusable",
    "disableListWrap",
    "onKeyDown",
    "variant",
  ];
function f_(n, e, t) {
  return n === e
    ? n.firstChild
    : e && e.nextElementSibling
    ? e.nextElementSibling
    : t
    ? null
    : n.firstChild;
}
function zM(n, e, t) {
  return n === e
    ? t
      ? n.firstChild
      : n.lastChild
    : e && e.previousElementSibling
    ? e.previousElementSibling
    : t
    ? null
    : n.lastChild;
}
function k2(n, e) {
  if (e === void 0) return !0;
  let t = n.innerText;
  return (
    t === void 0 && (t = n.textContent),
    (t = t.trim().toLowerCase()),
    t.length === 0
      ? !1
      : e.repeating
      ? t[0] === e.keys[0]
      : t.indexOf(e.keys.join("")) === 0
  );
}
function Ap(n, e, t, r, i, o) {
  let s = !1,
    l = i(n, e, e ? t : !1);
  for (; l; ) {
    if (l === n.firstChild) {
      if (s) return !1;
      s = !0;
    }
    const u = r ? !1 : l.disabled || l.getAttribute("aria-disabled") === "true";
    if (!l.hasAttribute("tabindex") || !k2(l, o) || u) l = i(n, l, t);
    else return l.focus(), !0;
  }
  return !1;
}
const cU = K.forwardRef(function (e, t) {
  const {
      actions: r,
      autoFocus: i = !1,
      autoFocusItem: o = !1,
      children: s,
      className: l,
      disabledItemsFocusable: u = !1,
      disableListWrap: f = !1,
      onKeyDown: h,
      variant: m = "selectedMenu",
    } = e,
    g = Pt(e, uU),
    y = K.useRef(null),
    x = K.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null,
    });
  $a(() => {
    i && y.current.focus();
  }, [i]),
    K.useImperativeHandle(
      r,
      () => ({
        adjustStyleForScrollbar: (E, { direction: A }) => {
          const R = !y.current.style.width;
          if (E.clientHeight < y.current.clientHeight && R) {
            const k = `${y2(Uo(E))}px`;
            (y.current.style[A === "rtl" ? "paddingLeft" : "paddingRight"] = k),
              (y.current.style.width = `calc(100% + ${k})`);
          }
          return y.current;
        },
      }),
      []
    );
  const S = (E) => {
      const A = y.current,
        R = E.key,
        k = Uo(A).activeElement;
      if (R === "ArrowDown") E.preventDefault(), Ap(A, k, f, u, f_);
      else if (R === "ArrowUp") E.preventDefault(), Ap(A, k, f, u, zM);
      else if (R === "Home") E.preventDefault(), Ap(A, null, f, u, f_);
      else if (R === "End") E.preventDefault(), Ap(A, null, f, u, zM);
      else if (R.length === 1) {
        const P = x.current,
          U = R.toLowerCase(),
          N = performance.now();
        P.keys.length > 0 &&
          (N - P.lastTime > 500
            ? ((P.keys = []), (P.repeating = !0), (P.previousKeyMatched = !0))
            : P.repeating && U !== P.keys[0] && (P.repeating = !1)),
          (P.lastTime = N),
          P.keys.push(U);
        const L = k && !P.repeating && k2(k, P);
        P.previousKeyMatched && (L || Ap(A, k, !1, u, f_, P))
          ? E.preventDefault()
          : (P.previousKeyMatched = !1);
      }
      h && h(E);
    },
    _ = ri(y, t);
  let w = -1;
  K.Children.forEach(s, (E, A) => {
    if (!K.isValidElement(E)) {
      w === A && ((w += 1), w >= s.length && (w = -1));
      return;
    }
    E.props.disabled ||
      (((m === "selectedMenu" && E.props.selected) || w === -1) && (w = A)),
      w === A &&
        (E.props.disabled ||
          E.props.muiSkipListHighlight ||
          E.type.muiSkipListHighlight) &&
        ((w += 1), w >= s.length && (w = -1));
  });
  const T = K.Children.map(s, (E, A) => {
    if (A === w) {
      const R = {};
      return (
        o && (R.autoFocus = !0),
        E.props.tabIndex === void 0 && m === "selectedMenu" && (R.tabIndex = 0),
        K.cloneElement(E, R)
      );
    }
    return E;
  });
  return Q.jsx(
    I2,
    ue(
      {
        role: "menu",
        ref: _,
        className: l,
        onKeyDown: S,
        tabIndex: i ? 0 : -1,
      },
      g,
      { children: T }
    )
  );
});
function fU(n) {
  return Un("MuiPopover", n);
}
In("MuiPopover", ["root", "paper"]);
const dU = ["onEntering"],
  hU = [
    "action",
    "anchorEl",
    "anchorOrigin",
    "anchorPosition",
    "anchorReference",
    "children",
    "className",
    "container",
    "elevation",
    "marginThreshold",
    "open",
    "PaperProps",
    "slots",
    "slotProps",
    "transformOrigin",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps",
    "disableScrollLock",
  ],
  pU = ["slotProps"];
function HM(n, e) {
  let t = 0;
  return (
    typeof e == "number"
      ? (t = e)
      : e === "center"
      ? (t = n.height / 2)
      : e === "bottom" && (t = n.height),
    t
  );
}
function VM(n, e) {
  let t = 0;
  return (
    typeof e == "number"
      ? (t = e)
      : e === "center"
      ? (t = n.width / 2)
      : e === "right" && (t = n.width),
    t
  );
}
function GM(n) {
  return [n.horizontal, n.vertical]
    .map((e) => (typeof e == "number" ? `${e}px` : e))
    .join(" ");
}
function d_(n) {
  return typeof n == "function" ? n() : n;
}
const mU = (n) => {
    const { classes: e } = n;
    return Fn({ root: ["root"], paper: ["paper"] }, fU, e);
  },
  gU = jt(uO, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  D2 = jt(ef, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (n, e) => e.paper,
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0,
  }),
  vU = K.forwardRef(function (e, t) {
    var r, i, o;
    const s = Xn({ props: e, name: "MuiPopover" }),
      {
        action: l,
        anchorEl: u,
        anchorOrigin: f = { vertical: "top", horizontal: "left" },
        anchorPosition: h,
        anchorReference: m = "anchorEl",
        children: g,
        className: y,
        container: x,
        elevation: S = 8,
        marginThreshold: _ = 16,
        open: w,
        PaperProps: T = {},
        slots: E,
        slotProps: A,
        transformOrigin: R = { vertical: "top", horizontal: "left" },
        TransitionComponent: k = P2,
        transitionDuration: P = "auto",
        TransitionProps: { onEntering: U } = {},
        disableScrollLock: N = !1,
      } = s,
      L = Pt(s.TransitionProps, dU),
      H = Pt(s, hU),
      G = (r = A == null ? void 0 : A.paper) != null ? r : T,
      $ = K.useRef(),
      q = ri($, G.ref),
      Z = ue({}, s, {
        anchorOrigin: f,
        anchorReference: m,
        elevation: S,
        marginThreshold: _,
        externalPaperSlotProps: G,
        transformOrigin: R,
        TransitionComponent: k,
        transitionDuration: P,
        TransitionProps: L,
      }),
      X = mU(Z),
      re = K.useCallback(() => {
        if (m === "anchorPosition") return h;
        const we = d_(u),
          Ne = (
            we && we.nodeType === 1 ? we : Uo($.current).body
          ).getBoundingClientRect();
        return {
          top: Ne.top + HM(Ne, f.vertical),
          left: Ne.left + VM(Ne, f.horizontal),
        };
      }, [u, f.horizontal, f.vertical, h, m]),
      W = K.useCallback(
        (we) => ({
          vertical: HM(we, R.vertical),
          horizontal: VM(we, R.horizontal),
        }),
        [R.horizontal, R.vertical]
      ),
      te = K.useCallback(
        (we) => {
          const Ae = { width: we.offsetWidth, height: we.offsetHeight },
            Ne = W(Ae);
          if (m === "none")
            return { top: null, left: null, transformOrigin: GM(Ne) };
          const Ie = re();
          let rt = Ie.top - Ne.vertical,
            ke = Ie.left - Ne.horizontal;
          const Xe = rt + Ae.height,
            ee = ke + Ae.width,
            B = Vu(d_(u)),
            ve = B.innerHeight - _,
            Se = B.innerWidth - _;
          if (_ !== null && rt < _) {
            const _e = rt - _;
            (rt -= _e), (Ne.vertical += _e);
          } else if (_ !== null && Xe > ve) {
            const _e = Xe - ve;
            (rt -= _e), (Ne.vertical += _e);
          }
          if (_ !== null && ke < _) {
            const _e = ke - _;
            (ke -= _e), (Ne.horizontal += _e);
          } else if (ee > Se) {
            const _e = ee - Se;
            (ke -= _e), (Ne.horizontal += _e);
          }
          return {
            top: `${Math.round(rt)}px`,
            left: `${Math.round(ke)}px`,
            transformOrigin: GM(Ne),
          };
        },
        [u, m, re, W, _]
      ),
      [F, V] = K.useState(w),
      ne = K.useCallback(() => {
        const we = $.current;
        if (!we) return;
        const Ae = te(we);
        Ae.top !== null && (we.style.top = Ae.top),
          Ae.left !== null && (we.style.left = Ae.left),
          (we.style.transformOrigin = Ae.transformOrigin),
          V(!0);
      }, [te]);
    K.useEffect(
      () => (
        N && window.addEventListener("scroll", ne),
        () => window.removeEventListener("scroll", ne)
      ),
      [u, N, ne]
    );
    const ae = (we, Ae) => {
        U && U(we, Ae), ne();
      },
      J = () => {
        V(!1);
      };
    K.useEffect(() => {
      w && ne();
    }),
      K.useImperativeHandle(
        l,
        () =>
          w
            ? {
                updatePosition: () => {
                  ne();
                },
              }
            : null,
        [w, ne]
      ),
      K.useEffect(() => {
        if (!w) return;
        const we = kS(() => {
            ne();
          }),
          Ae = Vu(u);
        return (
          Ae.addEventListener("resize", we),
          () => {
            we.clear(), Ae.removeEventListener("resize", we);
          }
        );
      }, [u, w, ne]);
    let oe = P;
    P === "auto" && !k.muiSupportAuto && (oe = void 0);
    const de = x || (u ? Uo(d_(u)).body : void 0),
      le = (i = E == null ? void 0 : E.root) != null ? i : gU,
      fe = (o = E == null ? void 0 : E.paper) != null ? o : D2,
      Ee = Sh({
        elementType: fe,
        externalSlotProps: ue({}, G, {
          style: F ? G.style : ue({}, G.style, { opacity: 0 }),
        }),
        additionalProps: { elevation: S, ref: q },
        ownerState: Z,
        className: Zt(X.paper, G == null ? void 0 : G.className),
      }),
      ge = Sh({
        elementType: le,
        externalSlotProps: (A == null ? void 0 : A.root) || {},
        externalForwardedProps: H,
        additionalProps: {
          ref: t,
          slotProps: { backdrop: { invisible: !0 } },
          container: de,
          open: w,
        },
        ownerState: Z,
        className: Zt(X.root, y),
      }),
      { slotProps: xe } = ge,
      j = Pt(ge, pU);
    return Q.jsx(
      le,
      ue({}, j, !_h(le) && { slotProps: xe, disableScrollLock: N }, {
        children: Q.jsx(
          k,
          ue(
            { appear: !0, in: w, onEntering: ae, onExited: J, timeout: oe },
            L,
            { children: Q.jsx(fe, ue({}, Ee, { children: g })) }
          )
        ),
      })
    );
  });
function yU(n) {
  return Un("MuiMenu", n);
}
In("MuiMenu", ["root", "paper", "list"]);
const xU = ["onEntering"],
  _U = [
    "autoFocus",
    "children",
    "className",
    "disableAutoFocusItem",
    "MenuListProps",
    "onClose",
    "open",
    "PaperProps",
    "PopoverClasses",
    "transitionDuration",
    "TransitionProps",
    "variant",
    "slots",
    "slotProps",
  ],
  SU = { vertical: "top", horizontal: "right" },
  wU = { vertical: "top", horizontal: "left" },
  bU = (n) => {
    const { classes: e } = n;
    return Fn({ root: ["root"], paper: ["paper"], list: ["list"] }, yU, e);
  },
  MU = jt(vU, {
    shouldForwardProp: (n) => Ps(n) || n === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  EU = jt(D2, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (n, e) => e.paper,
  })({ maxHeight: "calc(100% - 96px)", WebkitOverflowScrolling: "touch" }),
  TU = jt(cU, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (n, e) => e.list,
  })({ outline: 0 }),
  CU = K.forwardRef(function (e, t) {
    var r, i;
    const o = Xn({ props: e, name: "MuiMenu" }),
      {
        autoFocus: s = !0,
        children: l,
        className: u,
        disableAutoFocusItem: f = !1,
        MenuListProps: h = {},
        onClose: m,
        open: g,
        PaperProps: y = {},
        PopoverClasses: x,
        transitionDuration: S = "auto",
        TransitionProps: { onEntering: _ } = {},
        variant: w = "selectedMenu",
        slots: T = {},
        slotProps: E = {},
      } = o,
      A = Pt(o.TransitionProps, xU),
      R = Pt(o, _U),
      k = wk(),
      P = ue({}, o, {
        autoFocus: s,
        disableAutoFocusItem: f,
        MenuListProps: h,
        onEntering: _,
        PaperProps: y,
        transitionDuration: S,
        TransitionProps: A,
        variant: w,
      }),
      U = bU(P),
      N = s && !f && g,
      L = K.useRef(null),
      H = (W, te) => {
        L.current &&
          L.current.adjustStyleForScrollbar(W, {
            direction: k ? "rtl" : "ltr",
          }),
          _ && _(W, te);
      },
      G = (W) => {
        W.key === "Tab" && (W.preventDefault(), m && m(W, "tabKeyDown"));
      };
    let $ = -1;
    K.Children.map(l, (W, te) => {
      K.isValidElement(W) &&
        (W.props.disabled ||
          (((w === "selectedMenu" && W.props.selected) || $ === -1) &&
            ($ = te)));
    });
    const q = (r = T.paper) != null ? r : EU,
      Z = (i = E.paper) != null ? i : y,
      X = Sh({
        elementType: T.root,
        externalSlotProps: E.root,
        ownerState: P,
        className: [U.root, u],
      }),
      re = Sh({
        elementType: q,
        externalSlotProps: Z,
        ownerState: P,
        className: U.paper,
      });
    return Q.jsx(
      MU,
      ue(
        {
          onClose: m,
          anchorOrigin: {
            vertical: "bottom",
            horizontal: k ? "right" : "left",
          },
          transformOrigin: k ? SU : wU,
          slots: { paper: q, root: T.root },
          slotProps: { root: X, paper: re },
          open: g,
          ref: t,
          transitionDuration: S,
          TransitionProps: ue({ onEntering: H }, A),
          ownerState: P,
        },
        R,
        {
          classes: x,
          children: Q.jsx(
            TU,
            ue(
              {
                onKeyDown: G,
                actions: L,
                autoFocus: s && ($ === -1 || f),
                autoFocusItem: N,
                variant: w,
              },
              h,
              { className: Zt(U.list, h.className), children: l }
            )
          ),
        }
      )
    );
  });
function AU(n) {
  return Un("MuiMenuItem", n);
}
const Rp = In("MuiMenuItem", [
    "root",
    "focusVisible",
    "dense",
    "disabled",
    "divider",
    "gutters",
    "selected",
  ]),
  RU = [
    "autoFocus",
    "component",
    "dense",
    "divider",
    "disableGutters",
    "focusVisibleClassName",
    "role",
    "tabIndex",
    "className",
  ],
  PU = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.dense && e.dense,
      t.divider && e.divider,
      !t.disableGutters && e.gutters,
    ];
  },
  IU = (n) => {
    const {
        disabled: e,
        dense: t,
        divider: r,
        disableGutters: i,
        selected: o,
        classes: s,
      } = n,
      u = Fn(
        {
          root: [
            "root",
            t && "dense",
            e && "disabled",
            !i && "gutters",
            r && "divider",
            o && "selected",
          ],
        },
        AU,
        s
      );
    return ue({}, s, u);
  },
  LU = jt(zS, {
    shouldForwardProp: (n) => Ps(n) || n === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: PU,
  })(({ theme: n, ownerState: e }) =>
    ue(
      {},
      n.typography.body1,
      {
        display: "flex",
        justifyContent: "flex-start",
        alignItems: "center",
        position: "relative",
        textDecoration: "none",
        minHeight: 48,
        paddingTop: 6,
        paddingBottom: 6,
        boxSizing: "border-box",
        whiteSpace: "nowrap",
      },
      !e.disableGutters && { paddingLeft: 16, paddingRight: 16 },
      e.divider && {
        borderBottom: `1px solid ${(n.vars || n).palette.divider}`,
        backgroundClip: "padding-box",
      },
      {
        "&:hover": {
          textDecoration: "none",
          backgroundColor: (n.vars || n).palette.action.hover,
          "@media (hover: none)": { backgroundColor: "transparent" },
        },
        [`&.${Rp.selected}`]: {
          backgroundColor: n.vars
            ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
            : Di.alpha(
                n.palette.primary.main,
                n.palette.action.selectedOpacity
              ),
          [`&.${Rp.focusVisible}`]: {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.focusOpacity}))`
              : Di.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity +
                    n.palette.action.focusOpacity
                ),
          },
        },
        [`&.${Rp.selected}:hover`]: {
          backgroundColor: n.vars
            ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.hoverOpacity}))`
            : Di.alpha(
                n.palette.primary.main,
                n.palette.action.selectedOpacity + n.palette.action.hoverOpacity
              ),
          "@media (hover: none)": {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
              : Di.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity
                ),
          },
        },
        [`&.${Rp.focusVisible}`]: {
          backgroundColor: (n.vars || n).palette.action.focus,
        },
        [`&.${Rp.disabled}`]: {
          opacity: (n.vars || n).palette.action.disabledOpacity,
        },
        [`& + .${OM.root}`]: {
          marginTop: n.spacing(1),
          marginBottom: n.spacing(1),
        },
        [`& + .${OM.inset}`]: { marginLeft: 52 },
        [`& .${b0.root}`]: { marginTop: 0, marginBottom: 0 },
        [`& .${b0.inset}`]: { paddingLeft: 36 },
        [`& .${BM.root}`]: { minWidth: 36 },
      },
      !e.dense && { [n.breakpoints.up("sm")]: { minHeight: "auto" } },
      e.dense &&
        ue(
          { minHeight: 32, paddingTop: 4, paddingBottom: 4 },
          n.typography.body2,
          { [`& .${BM.root} svg`]: { fontSize: "1.25rem" } }
        )
    )
  ),
  Pp = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiMenuItem" }),
      {
        autoFocus: i = !1,
        component: o = "li",
        dense: s = !1,
        divider: l = !1,
        disableGutters: u = !1,
        focusVisibleClassName: f,
        role: h = "menuitem",
        tabIndex: m,
        className: g,
      } = r,
      y = Pt(r, RU),
      x = K.useContext(Pl),
      S = K.useMemo(
        () => ({ dense: s || x.dense || !1, disableGutters: u }),
        [x.dense, s, u]
      ),
      _ = K.useRef(null);
    $a(() => {
      i && _.current && _.current.focus();
    }, [i]);
    const w = ue({}, r, { dense: S.dense, divider: l, disableGutters: u }),
      T = IU(r),
      E = ri(_, t);
    let A;
    return (
      r.disabled || (A = m !== void 0 ? m : -1),
      Q.jsx(Pl.Provider, {
        value: S,
        children: Q.jsx(
          LU,
          ue(
            {
              ref: E,
              role: h,
              tabIndex: A,
              component: o,
              focusVisibleClassName: Zt(T.focusVisible, f),
              className: Zt(T.root, g),
            },
            y,
            { ownerState: w, classes: T }
          )
        ),
      })
    );
  });
function kU(n) {
  return Un("MuiNativeSelect", n);
}
const jS = In("MuiNativeSelect", [
    "root",
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
  ]),
  DU = [
    "className",
    "disabled",
    "error",
    "IconComponent",
    "inputRef",
    "variant",
  ],
  NU = (n) => {
    const {
        classes: e,
        variant: t,
        disabled: r,
        multiple: i,
        open: o,
        error: s,
      } = n,
      l = {
        select: ["select", t, r && "disabled", i && "multiple", s && "error"],
        icon: ["icon", `icon${an(t)}`, o && "iconOpen", r && "disabled"],
      };
    return Fn(l, kU, e);
  },
  N2 = ({ ownerState: n, theme: e }) =>
    ue(
      {
        MozAppearance: "none",
        WebkitAppearance: "none",
        userSelect: "none",
        borderRadius: 0,
        cursor: "pointer",
        "&:focus": ue(
          {},
          e.vars
            ? {
                backgroundColor: `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.05)`,
              }
            : {
                backgroundColor:
                  e.palette.mode === "light"
                    ? "rgba(0, 0, 0, 0.05)"
                    : "rgba(255, 255, 255, 0.05)",
              },
          { borderRadius: 0 }
        ),
        "&::-ms-expand": { display: "none" },
        [`&.${jS.disabled}`]: { cursor: "default" },
        "&[multiple]": { height: "auto" },
        "&:not([multiple]) option, &:not([multiple]) optgroup": {
          backgroundColor: (e.vars || e).palette.background.paper,
        },
        "&&&": { paddingRight: 24, minWidth: 16 },
      },
      n.variant === "filled" && { "&&&": { paddingRight: 32 } },
      n.variant === "outlined" && {
        borderRadius: (e.vars || e).shape.borderRadius,
        "&:focus": { borderRadius: (e.vars || e).shape.borderRadius },
        "&&&": { paddingRight: 32 },
      }
    ),
  OU = jt("select", {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: Ps,
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.select,
        e[t.variant],
        t.error && e.error,
        { [`&.${jS.multiple}`]: e.multiple },
      ];
    },
  })(N2),
  O2 = ({ ownerState: n, theme: e }) =>
    ue(
      {
        position: "absolute",
        right: 0,
        top: "calc(50% - .5em)",
        pointerEvents: "none",
        color: (e.vars || e).palette.action.active,
        [`&.${jS.disabled}`]: { color: (e.vars || e).palette.action.disabled },
      },
      n.open && { transform: "rotate(180deg)" },
      n.variant === "filled" && { right: 7 },
      n.variant === "outlined" && { right: 7 }
    ),
  UU = jt("svg", {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.icon,
        t.variant && e[`icon${an(t.variant)}`],
        t.open && e.iconOpen,
      ];
    },
  })(O2),
  FU = K.forwardRef(function (e, t) {
    const {
        className: r,
        disabled: i,
        error: o,
        IconComponent: s,
        inputRef: l,
        variant: u = "standard",
      } = e,
      f = Pt(e, DU),
      h = ue({}, e, { disabled: i, variant: u, error: o }),
      m = NU(h);
    return Q.jsxs(K.Fragment, {
      children: [
        Q.jsx(
          OU,
          ue(
            {
              ownerState: h,
              className: Zt(m.select, r),
              disabled: i,
              ref: l || t,
            },
            f
          )
        ),
        e.multiple
          ? null
          : Q.jsx(UU, { as: s, ownerState: h, className: m.icon }),
      ],
    });
  });
var WM;
const BU = ["children", "classes", "className", "label", "notched"],
  zU = jt("fieldset", { shouldForwardProp: Ps })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
  }),
  HU = jt("legend", { shouldForwardProp: Ps })(({ ownerState: n, theme: e }) =>
    ue(
      { float: "unset", width: "auto", overflow: "hidden" },
      !n.withLabel && {
        padding: 0,
        lineHeight: "11px",
        transition: e.transitions.create("width", {
          duration: 150,
          easing: e.transitions.easing.easeOut,
        }),
      },
      n.withLabel &&
        ue(
          {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: 0.01,
            transition: e.transitions.create("max-width", {
              duration: 50,
              easing: e.transitions.easing.easeOut,
            }),
            whiteSpace: "nowrap",
            "& > span": {
              paddingLeft: 5,
              paddingRight: 5,
              display: "inline-block",
              opacity: 0,
              visibility: "visible",
            },
          },
          n.notched && {
            maxWidth: "100%",
            transition: e.transitions.create("max-width", {
              duration: 100,
              easing: e.transitions.easing.easeOut,
              delay: 50,
            }),
          }
        )
    )
  );
function VU(n) {
  const { className: e, label: t, notched: r } = n,
    i = Pt(n, BU),
    o = t != null && t !== "",
    s = ue({}, n, { notched: r, withLabel: o });
  return Q.jsx(
    zU,
    ue({ "aria-hidden": !0, className: e, ownerState: s }, i, {
      children: Q.jsx(HU, {
        ownerState: s,
        children: o
          ? Q.jsx("span", { children: t })
          : WM ||
            (WM = Q.jsx("span", { className: "notranslate", children: "​" })),
      }),
    })
  );
}
const GU = [
    "components",
    "fullWidth",
    "inputComponent",
    "label",
    "multiline",
    "notched",
    "slots",
    "type",
  ],
  WU = (n) => {
    const { classes: e } = n,
      r = Fn(
        {
          root: ["root"],
          notchedOutline: ["notchedOutline"],
          input: ["input"],
        },
        SN,
        e
      );
    return ue({}, e, r);
  },
  jU = jt(Ay, {
    shouldForwardProp: (n) => Ps(n) || n === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: Ty,
  })(({ theme: n, ownerState: e }) => {
    const t =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.23)"
        : "rgba(255, 255, 255, 0.23)";
    return ue(
      {
        position: "relative",
        borderRadius: (n.vars || n).shape.borderRadius,
        [`&:hover .${Eu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.text.primary,
        },
        "@media (hover: none)": {
          [`&:hover .${Eu.notchedOutline}`]: {
            borderColor: n.vars
              ? `rgba(${n.vars.palette.common.onBackgroundChannel} / 0.23)`
              : t,
          },
        },
        [`&.${Eu.focused} .${Eu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette[e.color].main,
          borderWidth: 2,
        },
        [`&.${Eu.error} .${Eu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.error.main,
        },
        [`&.${Eu.disabled} .${Eu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.action.disabled,
        },
      },
      e.startAdornment && { paddingLeft: 14 },
      e.endAdornment && { paddingRight: 14 },
      e.multiline &&
        ue(
          { padding: "16.5px 14px" },
          e.size === "small" && { padding: "8.5px 14px" }
        )
    );
  }),
  $U = jt(VU, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (n, e) => e.notchedOutline,
  })(({ theme: n }) => {
    const e =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.23)"
        : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: n.vars
        ? `rgba(${n.vars.palette.common.onBackgroundChannel} / 0.23)`
        : e,
    };
  }),
  XU = jt(Ry, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: Cy,
  })(({ theme: n, ownerState: e }) =>
    ue(
      { padding: "16.5px 14px" },
      !n.vars && {
        "&:-webkit-autofill": {
          WebkitBoxShadow:
            n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
          WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
          caretColor: n.palette.mode === "light" ? null : "#fff",
          borderRadius: "inherit",
        },
      },
      n.vars && {
        "&:-webkit-autofill": { borderRadius: "inherit" },
        [n.getColorSchemeSelector("dark")]: {
          "&:-webkit-autofill": {
            WebkitBoxShadow: "0 0 0 100px #266798 inset",
            WebkitTextFillColor: "#fff",
            caretColor: "#fff",
          },
        },
      },
      e.size === "small" && { padding: "8.5px 14px" },
      e.multiline && { padding: 0 },
      e.startAdornment && { paddingLeft: 0 },
      e.endAdornment && { paddingRight: 0 }
    )
  ),
  $S = K.forwardRef(function (e, t) {
    var r, i, o, s, l;
    const u = Xn({ props: e, name: "MuiOutlinedInput" }),
      {
        components: f = {},
        fullWidth: h = !1,
        inputComponent: m = "input",
        label: g,
        multiline: y = !1,
        notched: x,
        slots: S = {},
        type: _ = "text",
      } = u,
      w = Pt(u, GU),
      T = WU(u),
      E = kh(),
      A = Lh({
        props: u,
        muiFormControl: E,
        states: [
          "color",
          "disabled",
          "error",
          "focused",
          "hiddenLabel",
          "size",
          "required",
        ],
      }),
      R = ue({}, u, {
        color: A.color || "primary",
        disabled: A.disabled,
        error: A.error,
        focused: A.focused,
        formControl: E,
        fullWidth: h,
        hiddenLabel: A.hiddenLabel,
        multiline: y,
        size: A.size,
        type: _,
      }),
      k = (r = (i = S.root) != null ? i : f.Root) != null ? r : jU,
      P = (o = (s = S.input) != null ? s : f.Input) != null ? o : XU;
    return Q.jsx(
      VS,
      ue(
        {
          slots: { root: k, input: P },
          renderSuffix: (U) =>
            Q.jsx($U, {
              ownerState: R,
              className: T.notchedOutline,
              label:
                g != null && g !== "" && A.required
                  ? l || (l = Q.jsxs(K.Fragment, { children: [g, " ", "*"] }))
                  : g,
              notched:
                typeof x < "u"
                  ? x
                  : !!(U.startAdornment || U.filled || U.focused),
            }),
          fullWidth: h,
          inputComponent: m,
          multiline: y,
          ref: t,
          type: _,
        },
        w,
        { classes: ue({}, T, { notchedOutline: null }) }
      )
    );
  });
$S.muiName = "Input";
function YU(n) {
  return Un("MuiSelect", n);
}
const Ip = In("MuiSelect", [
  "root",
  "select",
  "multiple",
  "filled",
  "outlined",
  "standard",
  "disabled",
  "focused",
  "icon",
  "iconOpen",
  "iconFilled",
  "iconOutlined",
  "iconStandard",
  "nativeInput",
  "error",
]);
var jM;
const qU = [
    "aria-describedby",
    "aria-label",
    "autoFocus",
    "autoWidth",
    "children",
    "className",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "displayEmpty",
    "error",
    "IconComponent",
    "inputRef",
    "labelId",
    "MenuProps",
    "multiple",
    "name",
    "onBlur",
    "onChange",
    "onClose",
    "onFocus",
    "onOpen",
    "open",
    "readOnly",
    "renderValue",
    "SelectDisplayProps",
    "tabIndex",
    "type",
    "value",
    "variant",
  ],
  KU = jt("div", {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`&.${Ip.select}`]: e.select },
        { [`&.${Ip.select}`]: e[t.variant] },
        { [`&.${Ip.error}`]: e.error },
        { [`&.${Ip.multiple}`]: e.multiple },
      ];
    },
  })(N2, {
    [`&.${Ip.select}`]: {
      height: "auto",
      minHeight: "1.4375em",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
    },
  }),
  ZU = jt("svg", {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.icon,
        t.variant && e[`icon${an(t.variant)}`],
        t.open && e.iconOpen,
      ];
    },
  })(O2),
  JU = jt("input", {
    shouldForwardProp: (n) => E2(n) && n !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (n, e) => e.nativeInput,
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box",
  });
function $M(n, e) {
  return typeof e == "object" && e !== null ? n === e : String(n) === String(e);
}
function QU(n) {
  return n == null || (typeof n == "string" && !n.trim());
}
const eF = (n) => {
    const {
        classes: e,
        variant: t,
        disabled: r,
        multiple: i,
        open: o,
        error: s,
      } = n,
      l = {
        select: ["select", t, r && "disabled", i && "multiple", s && "error"],
        icon: ["icon", `icon${an(t)}`, o && "iconOpen", r && "disabled"],
        nativeInput: ["nativeInput"],
      };
    return Fn(l, YU, e);
  },
  tF = K.forwardRef(function (e, t) {
    var r;
    const {
        "aria-describedby": i,
        "aria-label": o,
        autoFocus: s,
        autoWidth: l,
        children: u,
        className: f,
        defaultOpen: h,
        defaultValue: m,
        disabled: g,
        displayEmpty: y,
        error: x = !1,
        IconComponent: S,
        inputRef: _,
        labelId: w,
        MenuProps: T = {},
        multiple: E,
        name: A,
        onBlur: R,
        onChange: k,
        onClose: P,
        onFocus: U,
        onOpen: N,
        open: L,
        readOnly: H,
        renderValue: G,
        SelectDisplayProps: $ = {},
        tabIndex: q,
        value: Z,
        variant: X = "standard",
      } = e,
      re = Pt(e, qU),
      [W, te] = D1({ controlled: Z, default: m, name: "Select" }),
      [F, V] = D1({ controlled: L, default: h, name: "Select" }),
      ne = K.useRef(null),
      ae = K.useRef(null),
      [J, oe] = K.useState(null),
      { current: de } = K.useRef(L != null),
      [le, fe] = K.useState(),
      Ee = ri(t, _),
      ge = K.useCallback(($e) => {
        (ae.current = $e), $e && oe($e);
      }, []),
      xe = J == null ? void 0 : J.parentNode;
    K.useImperativeHandle(
      Ee,
      () => ({
        focus: () => {
          ae.current.focus();
        },
        node: ne.current,
        value: W,
      }),
      [W]
    ),
      K.useEffect(() => {
        h &&
          F &&
          J &&
          !de &&
          (fe(l ? null : xe.clientWidth), ae.current.focus());
      }, [J, l]),
      K.useEffect(() => {
        s && ae.current.focus();
      }, [s]),
      K.useEffect(() => {
        if (!w) return;
        const $e = Uo(ae.current).getElementById(w);
        if ($e) {
          const qe = () => {
            getSelection().isCollapsed && ae.current.focus();
          };
          return (
            $e.addEventListener("click", qe),
            () => {
              $e.removeEventListener("click", qe);
            }
          );
        }
      }, [w]);
    const j = ($e, qe) => {
        $e ? N && N(qe) : P && P(qe),
          de || (fe(l ? null : xe.clientWidth), V($e));
      },
      we = ($e) => {
        $e.button === 0 && ($e.preventDefault(), ae.current.focus(), j(!0, $e));
      },
      Ae = ($e) => {
        j(!1, $e);
      },
      Ne = K.Children.toArray(u),
      Ie = ($e) => {
        const qe = Ne.find((et) => et.props.value === $e.target.value);
        qe !== void 0 && (te(qe.props.value), k && k($e, qe));
      },
      rt = ($e) => (qe) => {
        let et;
        if (qe.currentTarget.hasAttribute("tabindex")) {
          if (E) {
            et = Array.isArray(W) ? W.slice() : [];
            const he = W.indexOf($e.props.value);
            he === -1 ? et.push($e.props.value) : et.splice(he, 1);
          } else et = $e.props.value;
          if (
            ($e.props.onClick && $e.props.onClick(qe), W !== et && (te(et), k))
          ) {
            const he = qe.nativeEvent || qe,
              Je = new he.constructor(he.type, he);
            Object.defineProperty(Je, "target", {
              writable: !0,
              value: { value: et, name: A },
            }),
              k(Je, $e);
          }
          E || j(!1, qe);
        }
      },
      ke = ($e) => {
        H ||
          ([" ", "ArrowUp", "ArrowDown", "Enter"].indexOf($e.key) !== -1 &&
            ($e.preventDefault(), j(!0, $e)));
      },
      Xe = J !== null && F,
      ee = ($e) => {
        !Xe &&
          R &&
          (Object.defineProperty($e, "target", {
            writable: !0,
            value: { value: W, name: A },
          }),
          R($e));
      };
    delete re["aria-invalid"];
    let B, ve;
    const Se = [];
    let _e = !1;
    (w0({ value: W }) || y) && (G ? (B = G(W)) : (_e = !0));
    const Te = Ne.map(($e) => {
      if (!K.isValidElement($e)) return null;
      let qe;
      if (E) {
        if (!Array.isArray(W)) throw new Error(Ll(2));
        (qe = W.some((et) => $M(et, $e.props.value))),
          qe && _e && Se.push($e.props.children);
      } else (qe = $M(W, $e.props.value)), qe && _e && (ve = $e.props.children);
      return K.cloneElement($e, {
        "aria-selected": qe ? "true" : "false",
        onClick: rt($e),
        onKeyUp: (et) => {
          et.key === " " && et.preventDefault(),
            $e.props.onKeyUp && $e.props.onKeyUp(et);
        },
        role: "option",
        selected: qe,
        value: void 0,
        "data-value": $e.props.value,
      });
    });
    _e &&
      (E
        ? Se.length === 0
          ? (B = null)
          : (B = Se.reduce(
              ($e, qe, et) => (
                $e.push(qe), et < Se.length - 1 && $e.push(", "), $e
              ),
              []
            ))
        : (B = ve));
    let at = le;
    !l && de && J && (at = xe.clientWidth);
    let Fe;
    typeof q < "u" ? (Fe = q) : (Fe = g ? null : 0);
    const Be = $.id || (A ? `mui-component-select-${A}` : void 0),
      We = ue({}, e, { variant: X, value: W, open: Xe, error: x }),
      Ye = eF(We),
      nt = ue({}, T.PaperProps, (r = T.slotProps) == null ? void 0 : r.paper),
      yt = DS();
    return Q.jsxs(K.Fragment, {
      children: [
        Q.jsx(
          KU,
          ue(
            {
              ref: ge,
              tabIndex: Fe,
              role: "combobox",
              "aria-controls": yt,
              "aria-disabled": g ? "true" : void 0,
              "aria-expanded": Xe ? "true" : "false",
              "aria-haspopup": "listbox",
              "aria-label": o,
              "aria-labelledby": [w, Be].filter(Boolean).join(" ") || void 0,
              "aria-describedby": i,
              onKeyDown: ke,
              onMouseDown: g || H ? null : we,
              onBlur: ee,
              onFocus: U,
            },
            $,
            {
              ownerState: We,
              className: Zt($.className, Ye.select, f),
              id: Be,
              children: QU(B)
                ? jM ||
                  (jM = Q.jsx("span", {
                    className: "notranslate",
                    children: "​",
                  }))
                : B,
            }
          )
        ),
        Q.jsx(
          JU,
          ue(
            {
              "aria-invalid": x,
              value: Array.isArray(W) ? W.join(",") : W,
              name: A,
              ref: ne,
              "aria-hidden": !0,
              onChange: Ie,
              tabIndex: -1,
              disabled: g,
              className: Ye.nativeInput,
              autoFocus: s,
              ownerState: We,
            },
            re
          )
        ),
        Q.jsx(ZU, { as: S, className: Ye.icon, ownerState: We }),
        Q.jsx(
          CU,
          ue(
            {
              id: `menu-${A || ""}`,
              anchorEl: xe,
              open: Xe,
              onClose: Ae,
              anchorOrigin: { vertical: "bottom", horizontal: "center" },
              transformOrigin: { vertical: "top", horizontal: "center" },
            },
            T,
            {
              MenuListProps: ue(
                {
                  "aria-labelledby": w,
                  role: "listbox",
                  "aria-multiselectable": E ? "true" : void 0,
                  disableListWrap: !0,
                  id: yt,
                },
                T.MenuListProps
              ),
              slotProps: ue({}, T.slotProps, {
                paper: ue({}, nt, {
                  style: ue({ minWidth: at }, nt != null ? nt.style : null),
                }),
              }),
              children: Te,
            }
          )
        ),
      ],
    });
  }),
  nF = [
    "autoWidth",
    "children",
    "classes",
    "className",
    "defaultOpen",
    "displayEmpty",
    "IconComponent",
    "id",
    "input",
    "inputProps",
    "label",
    "labelId",
    "MenuProps",
    "multiple",
    "native",
    "onClose",
    "onOpen",
    "open",
    "renderValue",
    "SelectDisplayProps",
    "variant",
  ],
  rF = ["root"],
  iF = (n) => {
    const { classes: e } = n;
    return e;
  },
  XS = {
    name: "MuiSelect",
    overridesResolver: (n, e) => e.root,
    shouldForwardProp: (n) => Ps(n) && n !== "variant",
    slot: "Root",
  },
  oF = jt(WS, XS)(""),
  sF = jt($S, XS)(""),
  aF = jt(GS, XS)(""),
  tf = K.forwardRef(function (e, t) {
    const r = Xn({ name: "MuiSelect", props: e }),
      {
        autoWidth: i = !1,
        children: o,
        classes: s = {},
        className: l,
        defaultOpen: u = !1,
        displayEmpty: f = !1,
        IconComponent: h = bN,
        id: m,
        input: g,
        inputProps: y,
        label: x,
        labelId: S,
        MenuProps: _,
        multiple: w = !1,
        native: T = !1,
        onClose: E,
        onOpen: A,
        open: R,
        renderValue: k,
        SelectDisplayProps: P,
        variant: U = "outlined",
      } = r,
      N = Pt(r, nF),
      L = T ? FU : tF,
      H = kh(),
      G = Lh({ props: r, muiFormControl: H, states: ["variant", "error"] }),
      $ = G.variant || U,
      q = ue({}, r, { variant: $, classes: s }),
      Z = iF(q),
      X = Pt(Z, rF),
      re =
        g ||
        {
          standard: Q.jsx(oF, { ownerState: q }),
          outlined: Q.jsx(sF, { label: x, ownerState: q }),
          filled: Q.jsx(aF, { ownerState: q }),
        }[$],
      W = ri(t, re.ref);
    return Q.jsx(K.Fragment, {
      children: K.cloneElement(
        re,
        ue(
          {
            inputComponent: L,
            inputProps: ue(
              {
                children: o,
                error: G.error,
                IconComponent: h,
                variant: $,
                type: void 0,
                multiple: w,
              },
              T
                ? { id: m }
                : {
                    autoWidth: i,
                    defaultOpen: u,
                    displayEmpty: f,
                    labelId: S,
                    MenuProps: _,
                    onClose: E,
                    onOpen: A,
                    open: R,
                    renderValue: k,
                    SelectDisplayProps: ue({ id: m }, P),
                  },
              y,
              { classes: y ? ni(X, y.classes) : X },
              g ? g.props.inputProps : {}
            ),
          },
          ((w && T) || f) && $ === "outlined" ? { notched: !0 } : {},
          { ref: W, className: Zt(re.props.className, l, Z.root) },
          !g && { variant: $ },
          N
        )
      ),
    });
  });
tf.muiName = "Select";
function lF(n) {
  return Un("MuiTextField", n);
}
In("MuiTextField", ["root"]);
const uF = [
    "autoComplete",
    "autoFocus",
    "children",
    "className",
    "color",
    "defaultValue",
    "disabled",
    "error",
    "FormHelperTextProps",
    "fullWidth",
    "helperText",
    "id",
    "InputLabelProps",
    "inputProps",
    "InputProps",
    "inputRef",
    "label",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "placeholder",
    "required",
    "rows",
    "select",
    "SelectProps",
    "type",
    "value",
    "variant",
  ],
  cF = { standard: WS, filled: GS, outlined: $S },
  fF = (n) => {
    const { classes: e } = n;
    return Fn({ root: ["root"] }, lF, e);
  },
  dF = jt(Yc, {
    name: "MuiTextField",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  hF = K.forwardRef(function (e, t) {
    const r = Xn({ props: e, name: "MuiTextField" }),
      {
        autoComplete: i,
        autoFocus: o = !1,
        children: s,
        className: l,
        color: u = "primary",
        defaultValue: f,
        disabled: h = !1,
        error: m = !1,
        FormHelperTextProps: g,
        fullWidth: y = !1,
        helperText: x,
        id: S,
        InputLabelProps: _,
        inputProps: w,
        InputProps: T,
        inputRef: E,
        label: A,
        maxRows: R,
        minRows: k,
        multiline: P = !1,
        name: U,
        onBlur: N,
        onChange: L,
        onFocus: H,
        placeholder: G,
        required: $ = !1,
        rows: q,
        select: Z = !1,
        SelectProps: X,
        type: re,
        value: W,
        variant: te = "outlined",
      } = r,
      F = Pt(r, uF),
      V = ue({}, r, {
        autoFocus: o,
        color: u,
        disabled: h,
        error: m,
        fullWidth: y,
        multiline: P,
        required: $,
        select: Z,
        variant: te,
      }),
      ne = fF(V),
      ae = {};
    te === "outlined" &&
      (_ && typeof _.shrink < "u" && (ae.notched = _.shrink), (ae.label = A)),
      Z &&
        ((!X || !X.native) && (ae.id = void 0),
        (ae["aria-describedby"] = void 0));
    const J = DS(S),
      oe = x && J ? `${J}-helper-text` : void 0,
      de = A && J ? `${J}-label` : void 0,
      le = cF[te],
      fe = Q.jsx(
        le,
        ue(
          {
            "aria-describedby": oe,
            autoComplete: i,
            autoFocus: o,
            defaultValue: f,
            fullWidth: y,
            multiline: P,
            name: U,
            rows: q,
            maxRows: R,
            minRows: k,
            type: re,
            value: W,
            id: J,
            inputRef: E,
            onBlur: N,
            onChange: L,
            onFocus: H,
            placeholder: G,
            inputProps: w,
          },
          ae,
          T
        )
      );
    return Q.jsxs(
      dF,
      ue(
        {
          className: Zt(ne.root, l),
          disabled: h,
          error: m,
          fullWidth: y,
          ref: t,
          required: $,
          color: u,
          variant: te,
          ownerState: V,
        },
        F,
        {
          children: [
            A != null &&
              A !== "" &&
              Q.jsx(rh, ue({ htmlFor: J, id: de }, _, { children: A })),
            Z
              ? Q.jsx(
                  tf,
                  ue(
                    {
                      "aria-describedby": oe,
                      id: J,
                      labelId: de,
                      value: W,
                      input: fe,
                    },
                    X,
                    { children: s }
                  )
                )
              : fe,
            x && Q.jsx(wO, ue({ id: oe }, g, { children: x })),
          ],
        }
      )
    );
  });
function oa(n) {
  for (
    var e = arguments.length, t = Array(e > 1 ? e - 1 : 0), r = 1;
    r < e;
    r++
  )
    t[r - 1] = arguments[r];
  throw Error(
    "[Immer] minified error nr: " +
      n +
      (t.length
        ? " " +
          t
            .map(function (i) {
              return "'" + i + "'";
            })
            .join(",")
        : "") +
      ". Find the full error at: https://bit.ly/3cXEKWf"
  );
}
function Gu(n) {
  return !!n && !!n[ar];
}
function kl(n) {
  var e;
  return (
    !!n &&
    ((function (t) {
      if (!t || typeof t != "object") return !1;
      var r = Object.getPrototypeOf(t);
      if (r === null) return !0;
      var i = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
      return (
        i === Object ||
        (typeof i == "function" && Function.toString.call(i) === wF)
      );
    })(n) ||
      Array.isArray(n) ||
      !!n[QM] ||
      !!(!((e = n.constructor) === null || e === void 0) && e[QM]) ||
      YS(n) ||
      qS(n))
  );
}
function yf(n, e, t) {
  t === void 0 && (t = !1),
    Dh(n) === 0
      ? (t ? Object.keys : gh)(n).forEach(function (r) {
          (t && typeof r == "symbol") || e(r, n[r], n);
        })
      : n.forEach(function (r, i) {
          return e(i, r, n);
        });
}
function Dh(n) {
  var e = n[ar];
  return e
    ? e.i > 3
      ? e.i - 4
      : e.i
    : Array.isArray(n)
    ? 1
    : YS(n)
    ? 2
    : qS(n)
    ? 3
    : 0;
}
function mh(n, e) {
  return Dh(n) === 2 ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e);
}
function pF(n, e) {
  return Dh(n) === 2 ? n.get(e) : n[e];
}
function U2(n, e, t) {
  var r = Dh(n);
  r === 2 ? n.set(e, t) : r === 3 ? n.add(t) : (n[e] = t);
}
function F2(n, e) {
  return n === e ? n !== 0 || 1 / n == 1 / e : n != n && e != e;
}
function YS(n) {
  return _F && n instanceof Map;
}
function qS(n) {
  return SF && n instanceof Set;
}
function qc(n) {
  return n.o || n.t;
}
function KS(n) {
  if (Array.isArray(n)) return Array.prototype.slice.call(n);
  var e = z2(n);
  delete e[ar];
  for (var t = gh(e), r = 0; r < t.length; r++) {
    var i = t[r],
      o = e[i];
    o.writable === !1 && ((o.writable = !0), (o.configurable = !0)),
      (o.get || o.set) &&
        (e[i] = {
          configurable: !0,
          writable: !0,
          enumerable: o.enumerable,
          value: n[i],
        });
  }
  return Object.create(Object.getPrototypeOf(n), e);
}
function ZS(n, e) {
  return (
    e === void 0 && (e = !1),
    JS(n) ||
      Gu(n) ||
      !kl(n) ||
      (Dh(n) > 1 && (n.set = n.add = n.clear = n.delete = mF),
      Object.freeze(n),
      e &&
        yf(
          n,
          function (t, r) {
            return ZS(r, !0);
          },
          !0
        )),
    n
  );
}
function mF() {
  oa(2);
}
function JS(n) {
  return n == null || typeof n != "object" || Object.isFrozen(n);
}
function Va(n) {
  var e = W1[n];
  return e || oa(18, n), e;
}
function gF(n, e) {
  W1[n] || (W1[n] = e);
}
function H1() {
  return Mm;
}
function h_(n, e) {
  e && (Va("Patches"), (n.u = []), (n.s = []), (n.v = e));
}
function M0(n) {
  V1(n), n.p.forEach(vF), (n.p = null);
}
function V1(n) {
  n === Mm && (Mm = n.l);
}
function XM(n) {
  return (Mm = { p: [], l: Mm, h: n, m: !0, _: 0 });
}
function vF(n) {
  var e = n[ar];
  e.i === 0 || e.i === 1 ? e.j() : (e.g = !0);
}
function p_(n, e) {
  e._ = e.p.length;
  var t = e.p[0],
    r = n !== void 0 && n !== t;
  return (
    e.h.O || Va("ES5").S(e, n, r),
    r
      ? (t[ar].P && (M0(e), oa(4)),
        kl(n) && ((n = E0(e, n)), e.l || T0(e, n)),
        e.u && Va("Patches").M(t[ar].t, n, e.u, e.s))
      : (n = E0(e, t, [])),
    M0(e),
    e.u && e.v(e.u, e.s),
    n !== B2 ? n : void 0
  );
}
function E0(n, e, t) {
  if (JS(e)) return e;
  var r = e[ar];
  if (!r)
    return (
      yf(
        e,
        function (l, u) {
          return YM(n, r, e, l, u, t);
        },
        !0
      ),
      e
    );
  if (r.A !== n) return e;
  if (!r.P) return T0(n, r.t, !0), r.t;
  if (!r.I) {
    (r.I = !0), r.A._--;
    var i = r.i === 4 || r.i === 5 ? (r.o = KS(r.k)) : r.o,
      o = i,
      s = !1;
    r.i === 3 && ((o = new Set(i)), i.clear(), (s = !0)),
      yf(o, function (l, u) {
        return YM(n, r, i, l, u, t, s);
      }),
      T0(n, i, !1),
      t && n.u && Va("Patches").N(r, t, n.u, n.s);
  }
  return r.o;
}
function YM(n, e, t, r, i, o, s) {
  if (Gu(i)) {
    var l = E0(n, i, o && e && e.i !== 3 && !mh(e.R, r) ? o.concat(r) : void 0);
    if ((U2(t, r, l), !Gu(l))) return;
    n.m = !1;
  } else s && t.add(i);
  if (kl(i) && !JS(i)) {
    if (!n.h.D && n._ < 1) return;
    E0(n, i), (e && e.A.l) || T0(n, i);
  }
}
function T0(n, e, t) {
  t === void 0 && (t = !1), !n.l && n.h.D && n.m && ZS(e, t);
}
function m_(n, e) {
  var t = n[ar];
  return (t ? qc(t) : n)[e];
}
function qM(n, e) {
  if (e in n)
    for (var t = Object.getPrototypeOf(n); t; ) {
      var r = Object.getOwnPropertyDescriptor(t, e);
      if (r) return r;
      t = Object.getPrototypeOf(t);
    }
}
function Nu(n) {
  n.P || ((n.P = !0), n.l && Nu(n.l));
}
function g_(n) {
  n.o || (n.o = KS(n.t));
}
function G1(n, e, t) {
  var r = YS(e)
    ? Va("MapSet").F(e, t)
    : qS(e)
    ? Va("MapSet").T(e, t)
    : n.O
    ? (function (i, o) {
        var s = Array.isArray(i),
          l = {
            i: s ? 1 : 0,
            A: o ? o.A : H1(),
            P: !1,
            I: !1,
            R: {},
            l: o,
            t: i,
            k: null,
            o: null,
            j: null,
            C: !1,
          },
          u = l,
          f = Em;
        s && ((u = [l]), (f = Zp));
        var h = Proxy.revocable(u, f),
          m = h.revoke,
          g = h.proxy;
        return (l.k = g), (l.j = m), g;
      })(e, t)
    : Va("ES5").J(e, t);
  return (t ? t.A : H1()).p.push(r), r;
}
function yF(n) {
  return (
    Gu(n) || oa(22, n),
    (function e(t) {
      if (!kl(t)) return t;
      var r,
        i = t[ar],
        o = Dh(t);
      if (i) {
        if (!i.P && (i.i < 4 || !Va("ES5").K(i))) return i.t;
        (i.I = !0), (r = KM(t, o)), (i.I = !1);
      } else r = KM(t, o);
      return (
        yf(r, function (s, l) {
          (i && pF(i.t, s) === l) || U2(r, s, e(l));
        }),
        o === 3 ? new Set(r) : r
      );
    })(n)
  );
}
function KM(n, e) {
  switch (e) {
    case 2:
      return new Map(n);
    case 3:
      return Array.from(n);
  }
  return KS(n);
}
function xF() {
  function n(o, s) {
    var l = i[o];
    return (
      l
        ? (l.enumerable = s)
        : (i[o] = l =
            {
              configurable: !0,
              enumerable: s,
              get: function () {
                var u = this[ar];
                return Em.get(u, o);
              },
              set: function (u) {
                var f = this[ar];
                Em.set(f, o, u);
              },
            }),
      l
    );
  }
  function e(o) {
    for (var s = o.length - 1; s >= 0; s--) {
      var l = o[s][ar];
      if (!l.P)
        switch (l.i) {
          case 5:
            r(l) && Nu(l);
            break;
          case 4:
            t(l) && Nu(l);
        }
    }
  }
  function t(o) {
    for (var s = o.t, l = o.k, u = gh(l), f = u.length - 1; f >= 0; f--) {
      var h = u[f];
      if (h !== ar) {
        var m = s[h];
        if (m === void 0 && !mh(s, h)) return !0;
        var g = l[h],
          y = g && g[ar];
        if (y ? y.t !== m : !F2(g, m)) return !0;
      }
    }
    var x = !!s[ar];
    return u.length !== gh(s).length + (x ? 0 : 1);
  }
  function r(o) {
    var s = o.k;
    if (s.length !== o.t.length) return !0;
    var l = Object.getOwnPropertyDescriptor(s, s.length - 1);
    if (l && !l.get) return !0;
    for (var u = 0; u < s.length; u++) if (!s.hasOwnProperty(u)) return !0;
    return !1;
  }
  var i = {};
  gF("ES5", {
    J: function (o, s) {
      var l = Array.isArray(o),
        u = (function (h, m) {
          if (h) {
            for (var g = Array(m.length), y = 0; y < m.length; y++)
              Object.defineProperty(g, "" + y, n(y, !0));
            return g;
          }
          var x = z2(m);
          delete x[ar];
          for (var S = gh(x), _ = 0; _ < S.length; _++) {
            var w = S[_];
            x[w] = n(w, h || !!x[w].enumerable);
          }
          return Object.create(Object.getPrototypeOf(m), x);
        })(l, o),
        f = {
          i: l ? 5 : 4,
          A: s ? s.A : H1(),
          P: !1,
          I: !1,
          R: {},
          l: s,
          t: o,
          k: u,
          o: null,
          g: !1,
          C: !1,
        };
      return Object.defineProperty(u, ar, { value: f, writable: !0 }), u;
    },
    S: function (o, s, l) {
      l
        ? Gu(s) && s[ar].A === o && e(o.p)
        : (o.u &&
            (function u(f) {
              if (f && typeof f == "object") {
                var h = f[ar];
                if (h) {
                  var m = h.t,
                    g = h.k,
                    y = h.R,
                    x = h.i;
                  if (x === 4)
                    yf(g, function (E) {
                      E !== ar &&
                        (m[E] !== void 0 || mh(m, E)
                          ? y[E] || u(g[E])
                          : ((y[E] = !0), Nu(h)));
                    }),
                      yf(m, function (E) {
                        g[E] !== void 0 || mh(g, E) || ((y[E] = !1), Nu(h));
                      });
                  else if (x === 5) {
                    if ((r(h) && (Nu(h), (y.length = !0)), g.length < m.length))
                      for (var S = g.length; S < m.length; S++) y[S] = !1;
                    else for (var _ = m.length; _ < g.length; _++) y[_] = !0;
                    for (
                      var w = Math.min(g.length, m.length), T = 0;
                      T < w;
                      T++
                    )
                      g.hasOwnProperty(T) || (y[T] = !0),
                        y[T] === void 0 && u(g[T]);
                  }
                }
              }
            })(o.p[0]),
          e(o.p));
    },
    K: function (o) {
      return o.i === 4 ? t(o) : r(o);
    },
  });
}
var ZM,
  Mm,
  QS = typeof Symbol < "u" && typeof Symbol("x") == "symbol",
  _F = typeof Map < "u",
  SF = typeof Set < "u",
  JM = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u",
  B2 = QS
    ? Symbol.for("immer-nothing")
    : (((ZM = {})["immer-nothing"] = !0), ZM),
  QM = QS ? Symbol.for("immer-draftable") : "__$immer_draftable",
  ar = QS ? Symbol.for("immer-state") : "__$immer_state",
  wF = "" + Object.prototype.constructor,
  gh =
    typeof Reflect < "u" && Reflect.ownKeys
      ? Reflect.ownKeys
      : Object.getOwnPropertySymbols !== void 0
      ? function (n) {
          return Object.getOwnPropertyNames(n).concat(
            Object.getOwnPropertySymbols(n)
          );
        }
      : Object.getOwnPropertyNames,
  z2 =
    Object.getOwnPropertyDescriptors ||
    function (n) {
      var e = {};
      return (
        gh(n).forEach(function (t) {
          e[t] = Object.getOwnPropertyDescriptor(n, t);
        }),
        e
      );
    },
  W1 = {},
  Em = {
    get: function (n, e) {
      if (e === ar) return n;
      var t = qc(n);
      if (!mh(t, e))
        return (function (i, o, s) {
          var l,
            u = qM(o, s);
          return u
            ? "value" in u
              ? u.value
              : (l = u.get) === null || l === void 0
              ? void 0
              : l.call(i.k)
            : void 0;
        })(n, t, e);
      var r = t[e];
      return n.I || !kl(r)
        ? r
        : r === m_(n.t, e)
        ? (g_(n), (n.o[e] = G1(n.A.h, r, n)))
        : r;
    },
    has: function (n, e) {
      return e in qc(n);
    },
    ownKeys: function (n) {
      return Reflect.ownKeys(qc(n));
    },
    set: function (n, e, t) {
      var r = qM(qc(n), e);
      if (r != null && r.set) return r.set.call(n.k, t), !0;
      if (!n.P) {
        var i = m_(qc(n), e),
          o = i == null ? void 0 : i[ar];
        if (o && o.t === t) return (n.o[e] = t), (n.R[e] = !1), !0;
        if (F2(t, i) && (t !== void 0 || mh(n.t, e))) return !0;
        g_(n), Nu(n);
      }
      return (
        (n.o[e] === t && (t !== void 0 || e in n.o)) ||
          (Number.isNaN(t) && Number.isNaN(n.o[e])) ||
          ((n.o[e] = t), (n.R[e] = !0)),
        !0
      );
    },
    deleteProperty: function (n, e) {
      return (
        m_(n.t, e) !== void 0 || e in n.t
          ? ((n.R[e] = !1), g_(n), Nu(n))
          : delete n.R[e],
        n.o && delete n.o[e],
        !0
      );
    },
    getOwnPropertyDescriptor: function (n, e) {
      var t = qc(n),
        r = Reflect.getOwnPropertyDescriptor(t, e);
      return (
        r && {
          writable: !0,
          configurable: n.i !== 1 || e !== "length",
          enumerable: r.enumerable,
          value: t[e],
        }
      );
    },
    defineProperty: function () {
      oa(11);
    },
    getPrototypeOf: function (n) {
      return Object.getPrototypeOf(n.t);
    },
    setPrototypeOf: function () {
      oa(12);
    },
  },
  Zp = {};
yf(Em, function (n, e) {
  Zp[n] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
}),
  (Zp.deleteProperty = function (n, e) {
    return Zp.set.call(this, n, e, void 0);
  }),
  (Zp.set = function (n, e, t) {
    return Em.set.call(this, n[0], e, t, n[0]);
  });
var bF = (function () {
    function n(t) {
      var r = this;
      (this.O = JM),
        (this.D = !0),
        (this.produce = function (i, o, s) {
          if (typeof i == "function" && typeof o != "function") {
            var l = o;
            o = i;
            var u = r;
            return function (S) {
              var _ = this;
              S === void 0 && (S = l);
              for (
                var w = arguments.length, T = Array(w > 1 ? w - 1 : 0), E = 1;
                E < w;
                E++
              )
                T[E - 1] = arguments[E];
              return u.produce(S, function (A) {
                var R;
                return (R = o).call.apply(R, [_, A].concat(T));
              });
            };
          }
          var f;
          if (
            (typeof o != "function" && oa(6),
            s !== void 0 && typeof s != "function" && oa(7),
            kl(i))
          ) {
            var h = XM(r),
              m = G1(r, i, void 0),
              g = !0;
            try {
              (f = o(m)), (g = !1);
            } finally {
              g ? M0(h) : V1(h);
            }
            return typeof Promise < "u" && f instanceof Promise
              ? f.then(
                  function (S) {
                    return h_(h, s), p_(S, h);
                  },
                  function (S) {
                    throw (M0(h), S);
                  }
                )
              : (h_(h, s), p_(f, h));
          }
          if (!i || typeof i != "object") {
            if (
              ((f = o(i)) === void 0 && (f = i),
              f === B2 && (f = void 0),
              r.D && ZS(f, !0),
              s)
            ) {
              var y = [],
                x = [];
              Va("Patches").M(i, f, y, x), s(y, x);
            }
            return f;
          }
          oa(21, i);
        }),
        (this.produceWithPatches = function (i, o) {
          if (typeof i == "function")
            return function (f) {
              for (
                var h = arguments.length, m = Array(h > 1 ? h - 1 : 0), g = 1;
                g < h;
                g++
              )
                m[g - 1] = arguments[g];
              return r.produceWithPatches(f, function (y) {
                return i.apply(void 0, [y].concat(m));
              });
            };
          var s,
            l,
            u = r.produce(i, o, function (f, h) {
              (s = f), (l = h);
            });
          return typeof Promise < "u" && u instanceof Promise
            ? u.then(function (f) {
                return [f, s, l];
              })
            : [u, s, l];
        }),
        typeof (t == null ? void 0 : t.useProxies) == "boolean" &&
          this.setUseProxies(t.useProxies),
        typeof (t == null ? void 0 : t.autoFreeze) == "boolean" &&
          this.setAutoFreeze(t.autoFreeze);
    }
    var e = n.prototype;
    return (
      (e.createDraft = function (t) {
        kl(t) || oa(8), Gu(t) && (t = yF(t));
        var r = XM(this),
          i = G1(this, t, void 0);
        return (i[ar].C = !0), V1(r), i;
      }),
      (e.finishDraft = function (t, r) {
        var i = t && t[ar],
          o = i.A;
        return h_(o, r), p_(void 0, o);
      }),
      (e.setAutoFreeze = function (t) {
        this.D = t;
      }),
      (e.setUseProxies = function (t) {
        t && !JM && oa(20), (this.O = t);
      }),
      (e.applyPatches = function (t, r) {
        var i;
        for (i = r.length - 1; i >= 0; i--) {
          var o = r[i];
          if (o.path.length === 0 && o.op === "replace") {
            t = o.value;
            break;
          }
        }
        i > -1 && (r = r.slice(i + 1));
        var s = Va("Patches").$;
        return Gu(t)
          ? s(t, r)
          : this.produce(t, function (l) {
              return s(l, r);
            });
      }),
      n
    );
  })(),
  ss = new bF(),
  H2 = ss.produce;
ss.produceWithPatches.bind(ss);
ss.setAutoFreeze.bind(ss);
ss.setUseProxies.bind(ss);
ss.applyPatches.bind(ss);
ss.createDraft.bind(ss);
ss.finishDraft.bind(ss);
function MF(n, e, t) {
  return (
    (e = w2(e)) in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function eE(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable;
      })),
      t.push.apply(t, r);
  }
  return t;
}
function tE(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? eE(Object(t), !0).forEach(function (r) {
          MF(n, r, t[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : eE(Object(t)).forEach(function (r) {
          Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
        });
  }
  return n;
}
function Zi(n) {
  return (
    "Minified Redux error #" +
    n +
    "; visit https://redux.js.org/Errors?code=" +
    n +
    " for the full message or use the non-minified dev environment for full errors. "
  );
}
var nE = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })(),
  v_ = function () {
    return Math.random().toString(36).substring(7).split("").join(".");
  },
  C0 = {
    INIT: "@@redux/INIT" + v_(),
    REPLACE: "@@redux/REPLACE" + v_(),
    PROBE_UNKNOWN_ACTION: function () {
      return "@@redux/PROBE_UNKNOWN_ACTION" + v_();
    },
  };
function EF(n) {
  if (typeof n != "object" || n === null) return !1;
  for (var e = n; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(n) === e;
}
function V2(n, e, t) {
  var r;
  if (
    (typeof e == "function" && typeof t == "function") ||
    (typeof t == "function" && typeof arguments[3] == "function")
  )
    throw new Error(Zi(0));
  if (
    (typeof e == "function" && typeof t > "u" && ((t = e), (e = void 0)),
    typeof t < "u")
  ) {
    if (typeof t != "function") throw new Error(Zi(1));
    return t(V2)(n, e);
  }
  if (typeof n != "function") throw new Error(Zi(2));
  var i = n,
    o = e,
    s = [],
    l = s,
    u = !1;
  function f() {
    l === s && (l = s.slice());
  }
  function h() {
    if (u) throw new Error(Zi(3));
    return o;
  }
  function m(S) {
    if (typeof S != "function") throw new Error(Zi(4));
    if (u) throw new Error(Zi(5));
    var _ = !0;
    return (
      f(),
      l.push(S),
      function () {
        if (_) {
          if (u) throw new Error(Zi(6));
          (_ = !1), f();
          var T = l.indexOf(S);
          l.splice(T, 1), (s = null);
        }
      }
    );
  }
  function g(S) {
    if (!EF(S)) throw new Error(Zi(7));
    if (typeof S.type > "u") throw new Error(Zi(8));
    if (u) throw new Error(Zi(9));
    try {
      (u = !0), (o = i(o, S));
    } finally {
      u = !1;
    }
    for (var _ = (s = l), w = 0; w < _.length; w++) {
      var T = _[w];
      T();
    }
    return S;
  }
  function y(S) {
    if (typeof S != "function") throw new Error(Zi(10));
    (i = S), g({ type: C0.REPLACE });
  }
  function x() {
    var S,
      _ = m;
    return (
      (S = {
        subscribe: function (T) {
          if (typeof T != "object" || T === null) throw new Error(Zi(11));
          function E() {
            T.next && T.next(h());
          }
          E();
          var A = _(E);
          return { unsubscribe: A };
        },
      }),
      (S[nE] = function () {
        return this;
      }),
      S
    );
  }
  return (
    g({ type: C0.INIT }),
    (r = { dispatch: g, subscribe: m, getState: h, replaceReducer: y }),
    (r[nE] = x),
    r
  );
}
function TF(n) {
  Object.keys(n).forEach(function (e) {
    var t = n[e],
      r = t(void 0, { type: C0.INIT });
    if (typeof r > "u") throw new Error(Zi(12));
    if (typeof t(void 0, { type: C0.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(Zi(13));
  });
}
function CF(n) {
  for (var e = Object.keys(n), t = {}, r = 0; r < e.length; r++) {
    var i = e[r];
    typeof n[i] == "function" && (t[i] = n[i]);
  }
  var o = Object.keys(t),
    s;
  try {
    TF(t);
  } catch (l) {
    s = l;
  }
  return function (u, f) {
    if ((u === void 0 && (u = {}), s)) throw s;
    for (var h = !1, m = {}, g = 0; g < o.length; g++) {
      var y = o[g],
        x = t[y],
        S = u[y],
        _ = x(S, f);
      if (typeof _ > "u") throw (f && f.type, new Error(Zi(14)));
      (m[y] = _), (h = h || _ !== S);
    }
    return (h = h || o.length !== Object.keys(u).length), h ? m : u;
  };
}
function A0() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return e.length === 0
    ? function (r) {
        return r;
      }
    : e.length === 1
    ? e[0]
    : e.reduce(function (r, i) {
        return function () {
          return r(i.apply(void 0, arguments));
        };
      });
}
function AF() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return function (r) {
    return function () {
      var i = r.apply(void 0, arguments),
        o = function () {
          throw new Error(Zi(15));
        },
        s = {
          getState: i.getState,
          dispatch: function () {
            return o.apply(void 0, arguments);
          },
        },
        l = e.map(function (u) {
          return u(s);
        });
      return (
        (o = A0.apply(void 0, l)(i.dispatch)),
        tE(tE({}, i), {}, { dispatch: o })
      );
    };
  };
}
function G2(n) {
  var e = function (r) {
    var i = r.dispatch,
      o = r.getState;
    return function (s) {
      return function (l) {
        return typeof l == "function" ? l(i, o, n) : s(l);
      };
    };
  };
  return e;
}
var j1 = G2();
j1.withExtraArgument = G2;
var W2 = (function () {
    var n = function (e, t) {
      return (
        (n =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
          }),
        n(e, t)
      );
    };
    return function (e, t) {
      if (typeof t != "function" && t !== null)
        throw new TypeError(
          "Class extends value " + String(t) + " is not a constructor or null"
        );
      n(e, t);
      function r() {
        this.constructor = e;
      }
      e.prototype =
        t === null ? Object.create(t) : ((r.prototype = t.prototype), new r());
    };
  })(),
  RF = function (n, e) {
    var t = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      s;
    return (
      (s = { next: l(0), throw: l(1), return: l(2) }),
      typeof Symbol == "function" &&
        (s[Symbol.iterator] = function () {
          return this;
        }),
      s
    );
    function l(f) {
      return function (h) {
        return u([f, h]);
      };
    }
    function u(f) {
      if (r) throw new TypeError("Generator is already executing.");
      for (; t; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                f[0] & 2
                  ? i.return
                  : f[0]
                  ? i.throw || ((o = i.return) && o.call(i), 0)
                  : i.next) &&
              !(o = o.call(i, f[1])).done)
          )
            return o;
          switch (((i = 0), o && (f = [f[0] & 2, o.value]), f[0])) {
            case 0:
            case 1:
              o = f;
              break;
            case 4:
              return t.label++, { value: f[1], done: !1 };
            case 5:
              t.label++, (i = f[1]), (f = [0]);
              continue;
            case 7:
              (f = t.ops.pop()), t.trys.pop();
              continue;
            default:
              if (
                ((o = t.trys),
                !(o = o.length > 0 && o[o.length - 1]) &&
                  (f[0] === 6 || f[0] === 2))
              ) {
                t = 0;
                continue;
              }
              if (f[0] === 3 && (!o || (f[1] > o[0] && f[1] < o[3]))) {
                t.label = f[1];
                break;
              }
              if (f[0] === 6 && t.label < o[1]) {
                (t.label = o[1]), (o = f);
                break;
              }
              if (o && t.label < o[2]) {
                (t.label = o[2]), t.ops.push(f);
                break;
              }
              o[2] && t.ops.pop(), t.trys.pop();
              continue;
          }
          f = e.call(n, t);
        } catch (h) {
          (f = [6, h]), (i = 0);
        } finally {
          r = o = 0;
        }
      if (f[0] & 5) throw f[1];
      return { value: f[0] ? f[1] : void 0, done: !0 };
    }
  },
  bh = function (n, e) {
    for (var t = 0, r = e.length, i = n.length; t < r; t++, i++) n[i] = e[t];
    return n;
  },
  PF = Object.defineProperty,
  IF = Object.defineProperties,
  LF = Object.getOwnPropertyDescriptors,
  rE = Object.getOwnPropertySymbols,
  kF = Object.prototype.hasOwnProperty,
  DF = Object.prototype.propertyIsEnumerable,
  iE = function (n, e, t) {
    return e in n
      ? PF(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t);
  },
  Fu = function (n, e) {
    for (var t in e || (e = {})) kF.call(e, t) && iE(n, t, e[t]);
    if (rE)
      for (var r = 0, i = rE(e); r < i.length; r++) {
        var t = i[r];
        DF.call(e, t) && iE(n, t, e[t]);
      }
    return n;
  },
  y_ = function (n, e) {
    return IF(n, LF(e));
  },
  NF = function (n, e, t) {
    return new Promise(function (r, i) {
      var o = function (u) {
          try {
            l(t.next(u));
          } catch (f) {
            i(f);
          }
        },
        s = function (u) {
          try {
            l(t.throw(u));
          } catch (f) {
            i(f);
          }
        },
        l = function (u) {
          return u.done ? r(u.value) : Promise.resolve(u.value).then(o, s);
        };
      l((t = t.apply(n, e)).next());
    });
  },
  OF =
    typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == "object"
              ? A0
              : A0.apply(null, arguments);
        };
function UF(n) {
  if (typeof n != "object" || n === null) return !1;
  var e = Object.getPrototypeOf(n);
  if (e === null) return !0;
  for (var t = e; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return e === t;
}
function Bu(n, e) {
  function t() {
    for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
    if (e) {
      var o = e.apply(void 0, r);
      if (!o) throw new Error("prepareAction did not return an object");
      return Fu(
        Fu({ type: n, payload: o.payload }, "meta" in o && { meta: o.meta }),
        "error" in o && { error: o.error }
      );
    }
    return { type: n, payload: r[0] };
  }
  return (
    (t.toString = function () {
      return "" + n;
    }),
    (t.type = n),
    (t.match = function (r) {
      return r.type === n;
    }),
    t
  );
}
var FF = (function (n) {
    W2(e, n);
    function e() {
      for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
      var i = n.apply(this, t) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return n.prototype.concat.apply(this, t);
      }),
      (e.prototype.prepend = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return t.length === 1 && Array.isArray(t[0])
          ? new (e.bind.apply(e, bh([void 0], t[0].concat(this))))()
          : new (e.bind.apply(e, bh([void 0], t.concat(this))))();
      }),
      e
    );
  })(Array),
  BF = (function (n) {
    W2(e, n);
    function e() {
      for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
      var i = n.apply(this, t) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return n.prototype.concat.apply(this, t);
      }),
      (e.prototype.prepend = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return t.length === 1 && Array.isArray(t[0])
          ? new (e.bind.apply(e, bh([void 0], t[0].concat(this))))()
          : new (e.bind.apply(e, bh([void 0], t.concat(this))))();
      }),
      e
    );
  })(Array);
function $1(n) {
  return kl(n) ? H2(n, function () {}) : n;
}
function zF(n) {
  return typeof n == "boolean";
}
function HF() {
  return function (e) {
    return VF(e);
  };
}
function VF(n) {
  n === void 0 && (n = {});
  var e = n.thunk,
    t = e === void 0 ? !0 : e;
  n.immutableCheck, n.serializableCheck, n.actionCreatorCheck;
  var r = new FF();
  return (
    t && (zF(t) ? r.push(j1) : r.push(j1.withExtraArgument(t.extraArgument))), r
  );
}
function GF(n) {
  var e = HF(),
    t = n || {},
    r = t.reducer,
    i = r === void 0 ? void 0 : r,
    o = t.middleware,
    s = o === void 0 ? e() : o,
    l = t.devTools,
    u = l === void 0 ? !0 : l,
    f = t.preloadedState,
    h = f === void 0 ? void 0 : f,
    m = t.enhancers,
    g = m === void 0 ? void 0 : m,
    y;
  if (typeof i == "function") y = i;
  else if (UF(i)) y = CF(i);
  else
    throw new Error(
      '"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'
    );
  var x = s;
  typeof x == "function" && (x = x(e));
  var S = AF.apply(void 0, x),
    _ = A0;
  u && (_ = OF(Fu({ trace: !1 }, typeof u == "object" && u)));
  var w = new BF(S),
    T = w;
  Array.isArray(g) ? (T = bh([S], g)) : typeof g == "function" && (T = g(w));
  var E = _.apply(void 0, T);
  return V2(y, h, E);
}
function j2(n) {
  var e = {},
    t = [],
    r,
    i = {
      addCase: function (o, s) {
        var l = typeof o == "string" ? o : o.type;
        if (!l)
          throw new Error(
            "`builder.addCase` cannot be called with an empty action type"
          );
        if (l in e)
          throw new Error(
            "`builder.addCase` cannot be called with two reducers for the same action type"
          );
        return (e[l] = s), i;
      },
      addMatcher: function (o, s) {
        return t.push({ matcher: o, reducer: s }), i;
      },
      addDefaultCase: function (o) {
        return (r = o), i;
      },
    };
  return n(i), [e, t, r];
}
function WF(n) {
  return typeof n == "function";
}
function jF(n, e, t, r) {
  t === void 0 && (t = []);
  var i = typeof e == "function" ? j2(e) : [e, t, r],
    o = i[0],
    s = i[1],
    l = i[2],
    u;
  if (WF(n))
    u = function () {
      return $1(n());
    };
  else {
    var f = $1(n);
    u = function () {
      return f;
    };
  }
  function h(m, g) {
    m === void 0 && (m = u());
    var y = bh(
      [o[g.type]],
      s
        .filter(function (x) {
          var S = x.matcher;
          return S(g);
        })
        .map(function (x) {
          var S = x.reducer;
          return S;
        })
    );
    return (
      y.filter(function (x) {
        return !!x;
      }).length === 0 && (y = [l]),
      y.reduce(function (x, S) {
        if (S)
          if (Gu(x)) {
            var _ = x,
              w = S(_, g);
            return w === void 0 ? x : w;
          } else {
            if (kl(x))
              return H2(x, function (T) {
                return S(T, g);
              });
            var w = S(x, g);
            if (w === void 0) {
              if (x === null) return x;
              throw Error(
                "A case reducer on a non-draftable value must not return undefined"
              );
            }
            return w;
          }
        return x;
      }, m)
    );
  }
  return (h.getInitialState = u), h;
}
function $F(n, e) {
  return n + "/" + e;
}
function XF(n) {
  var e = n.name,
    t =
      typeof n.initialState == "function" ? n.initialState : $1(n.initialState),
    r = n.reducers || {},
    i = Object.keys(r),
    o = {},
    s = {},
    l = {};
  i.forEach(function (h) {
    var m = r[h],
      g = $F(e, h),
      y,
      x;
    "reducer" in m ? ((y = m.reducer), (x = m.prepare)) : (y = m),
      (o[h] = y),
      (s[g] = y),
      (l[h] = x ? Bu(g, x) : Bu(g));
  });
  function u() {
    var h =
        typeof n.extraReducers == "function"
          ? j2(n.extraReducers)
          : [n.extraReducers],
      m = h[0],
      g = m === void 0 ? {} : m,
      y = h[1],
      x = y === void 0 ? [] : y,
      S = h[2],
      _ = S === void 0 ? void 0 : S,
      w = Fu(Fu({}, g), s);
    return jF(t, function (T) {
      for (var E in w) T.addCase(E, w[E]);
      for (var A = 0, R = x; A < R.length; A++) {
        var k = R[A];
        T.addMatcher(k.matcher, k.reducer);
      }
      _ && T.addDefaultCase(_);
    });
  }
  var f;
  return {
    name: e,
    reducer: function (h, m) {
      return f || (f = u()), f(h, m);
    },
    actions: l,
    caseReducers: o,
    getInitialState: function () {
      return f || (f = u()), f.getInitialState();
    },
  };
}
var YF = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  qF = function (n) {
    n === void 0 && (n = 21);
    for (var e = "", t = n; t--; ) e += YF[(Math.random() * 64) | 0];
    return e;
  },
  KF = ["name", "message", "stack", "code"],
  x_ = (function () {
    function n(e, t) {
      (this.payload = e), (this.meta = t);
    }
    return n;
  })(),
  oE = (function () {
    function n(e, t) {
      (this.payload = e), (this.meta = t);
    }
    return n;
  })(),
  ZF = function (n) {
    if (typeof n == "object" && n !== null) {
      for (var e = {}, t = 0, r = KF; t < r.length; t++) {
        var i = r[t];
        typeof n[i] == "string" && (e[i] = n[i]);
      }
      return e;
    }
    return { message: String(n) };
  };
(function () {
  function n(e, t, r) {
    var i = Bu(e + "/fulfilled", function (f, h, m, g) {
        return {
          payload: f,
          meta: y_(Fu({}, g || {}), {
            arg: m,
            requestId: h,
            requestStatus: "fulfilled",
          }),
        };
      }),
      o = Bu(e + "/pending", function (f, h, m) {
        return {
          payload: void 0,
          meta: y_(Fu({}, m || {}), {
            arg: h,
            requestId: f,
            requestStatus: "pending",
          }),
        };
      }),
      s = Bu(e + "/rejected", function (f, h, m, g, y) {
        return {
          payload: g,
          error: ((r && r.serializeError) || ZF)(f || "Rejected"),
          meta: y_(Fu({}, y || {}), {
            arg: m,
            requestId: h,
            rejectedWithValue: !!g,
            requestStatus: "rejected",
            aborted: (f == null ? void 0 : f.name) === "AbortError",
            condition: (f == null ? void 0 : f.name) === "ConditionError",
          }),
        };
      }),
      l =
        typeof AbortController < "u"
          ? AbortController
          : (function () {
              function f() {
                this.signal = {
                  aborted: !1,
                  addEventListener: function () {},
                  dispatchEvent: function () {
                    return !1;
                  },
                  onabort: function () {},
                  removeEventListener: function () {},
                  reason: void 0,
                  throwIfAborted: function () {},
                };
              }
              return (f.prototype.abort = function () {}), f;
            })();
    function u(f) {
      return function (h, m, g) {
        var y = r != null && r.idGenerator ? r.idGenerator(f) : qF(),
          x = new l(),
          S;
        function _(T) {
          (S = T), x.abort();
        }
        var w = (function () {
          return NF(this, null, function () {
            var T, E, A, R, k, P, U;
            return RF(this, function (N) {
              switch (N.label) {
                case 0:
                  return (
                    N.trys.push([0, 4, , 5]),
                    (R =
                      (T = r == null ? void 0 : r.condition) == null
                        ? void 0
                        : T.call(r, f, { getState: m, extra: g })),
                    QF(R) ? [4, R] : [3, 2]
                  );
                case 1:
                  (R = N.sent()), (N.label = 2);
                case 2:
                  if (R === !1 || x.signal.aborted)
                    throw {
                      name: "ConditionError",
                      message:
                        "Aborted due to condition callback returning false.",
                    };
                  return (
                    (k = new Promise(function (L, H) {
                      return x.signal.addEventListener("abort", function () {
                        return H({
                          name: "AbortError",
                          message: S || "Aborted",
                        });
                      });
                    })),
                    h(
                      o(
                        y,
                        f,
                        (E = r == null ? void 0 : r.getPendingMeta) == null
                          ? void 0
                          : E.call(
                              r,
                              { requestId: y, arg: f },
                              { getState: m, extra: g }
                            )
                      )
                    ),
                    [
                      4,
                      Promise.race([
                        k,
                        Promise.resolve(
                          t(f, {
                            dispatch: h,
                            getState: m,
                            extra: g,
                            requestId: y,
                            signal: x.signal,
                            abort: _,
                            rejectWithValue: function (L, H) {
                              return new x_(L, H);
                            },
                            fulfillWithValue: function (L, H) {
                              return new oE(L, H);
                            },
                          })
                        ).then(function (L) {
                          if (L instanceof x_) throw L;
                          return L instanceof oE
                            ? i(L.payload, y, f, L.meta)
                            : i(L, y, f);
                        }),
                      ]),
                    ]
                  );
                case 3:
                  return (A = N.sent()), [3, 5];
                case 4:
                  return (
                    (P = N.sent()),
                    (A =
                      P instanceof x_
                        ? s(null, y, f, P.payload, P.meta)
                        : s(P, y, f)),
                    [3, 5]
                  );
                case 5:
                  return (
                    (U =
                      r &&
                      !r.dispatchConditionRejection &&
                      s.match(A) &&
                      A.meta.condition),
                    U || h(A),
                    [2, A]
                  );
              }
            });
          });
        })();
        return Object.assign(w, {
          abort: _,
          requestId: y,
          arg: f,
          unwrap: function () {
            return w.then(JF);
          },
        });
      };
    }
    return Object.assign(u, {
      pending: o,
      rejected: s,
      fulfilled: i,
      typePrefix: e,
    });
  }
  return (
    (n.withTypes = function () {
      return n;
    }),
    n
  );
})();
function JF(n) {
  if (n.meta && n.meta.rejectedWithValue) throw n.payload;
  if (n.error) throw n.error;
  return n.payload;
}
function QF(n) {
  return n !== null && typeof n == "object" && typeof n.then == "function";
}
var ew = "listenerMiddleware";
Bu(ew + "/add");
Bu(ew + "/removeAll");
Bu(ew + "/remove");
var sE;
typeof queueMicrotask == "function" &&
  queueMicrotask.bind(
    typeof window < "u" ? window : typeof global < "u" ? global : globalThis
  );
xF();
const e4 = {
    sender: null,
    receiver: null,
    tnxData: null,
    encryptedData: null,
    validator: null,
    validatorName: "",
    phase: "idle",
    transactionProgress: 0,
    deploying: !1,
    contractAnimation: !1,
    contractHash: null,
    contractDeployed: !1,
    smartContract: !1,
    winner: !1,
    initialContract: `// SPDX-License-Identifier: MIT
  pragma solidity ^0.8.0;
  
  contract PredictionBet {
      struct Bet {
          address player1;
          address player2;
          string question;
          string answer1; // player1's choice
          string answer2; // player2's choice
          uint256 amount;
          bool completed;
          address winner;
      }
  
      Bet public currentBet;
  
      uint256 public constant BET_AMOUNT = 100 wei;
  
      function createBet(
          address _player2,
          string memory _question,
          string memory _answer1,
          string memory _answer2
      ) external {
          require(_player2 != msg.sender, "Players must be different");
  
          currentBet = Bet({
              player1: msg.sender,
              player2: _player2,
              question: _question,
              answer1: _answer1,
              answer2: _answer2,
              amount: BET_AMOUNT,
              completed: false,
              winner: address(0)
          });
      }
  
      function declareWinner(address _winner) external {
          require(!currentBet.completed, "Already completed");
          require(
              _winner == currentBet.player1 || _winner == currentBet.player2,
              "Winner must be one of the players"
          );
  
          currentBet.completed = true;
          currentBet.winner = _winner;
      }
  }
  `,
    contractCode: `// SPDX-License-Identifier: MIT
  pragma solidity ^0.8.0;
  
  contract PredictionBet {
      struct Bet {
          address player1;
          address player2;
          string question;
          string answer1; // player1's choice
          string answer2; // player2's choice
          uint256 amount;
          bool completed;
          address winner;
      }
  
      Bet public currentBet;
  
      uint256 public constant BET_AMOUNT = 100 wei;
  
      function createBet(
          address _player2,
          string memory _question,
          string memory _answer1,
          string memory _answer2
      ) external {
          require(_player2 != msg.sender, "Players must be different");
  
          currentBet = Bet({
              player1: msg.sender,
              player2: _player2,
              question: _question,
              answer1: _answer1,
              answer2: _answer2,
              amount: BET_AMOUNT,
              completed: false,
              winner: address(0)
          });
      }
  
      function declareWinner(address _winner) external {
          require(!currentBet.completed, "Already completed");
          require(
              _winner == currentBet.player1 || _winner == currentBet.player2,
              "Winner must be one of the players"
          );
  
          currentBet.completed = true;
          currentBet.winner = _winner;
      }
  }
  `,
    showNetwork: !1,
  },
  $2 = XF({
    name: "simulation",
    initialState: e4,
    reducers: {
      setSender: (n, e) => {
        (n.sender = e.payload), (n.validator = null);
      },
      setEncryptedData: (n, e) => {
        n.encryptedData = e.payload;
      },
      setReceiver: (n, e) => {
        (n.receiver = e.payload), (n.validator = null);
      },
      setTnxData: (n, e) => {
        n.tnxData = e.payload;
      },
      setValidator: (n, e) => {
        n.validator = e.payload;
      },
      startTransaction: (n) => {
        (n.phase = "transaction"), (n.transactionProgress = 0);
      },
      updateTransactionProgress: (n, e) => {
        n.transactionProgress = e.payload;
      },
      startValidation: (n) => {
        n.phase = "validation";
      },
      startBroadcast: (n) => {
        n.phase = "broadcast";
      },
      completeSimulation: (n) => {
        n.phase = "complete";
      },
      resetSimulation: (n) => {
        (n.sender = null),
          (n.receiver = null),
          (n.validator = null),
          (n.encryptedData = null),
          (n.tnxData = null),
          (n.phase = "idle"),
          (n.transactionProgress = 0);
      },
      startContractAnimation: (n, e) => {
        (n.contractAnimation = !0),
          (n.deploying = !0),
          (n.contractHash = e.payload);
      },
      endContractAnimation: (n) => {
        (n.contractAnimation = !1),
          (n.deploying = !1),
          (n.contractDeployed = !0);
      },
      showSmartContract: (n) => {
        n.smartContract = !0;
      },
      setBetGameWinner: (n, e) => {
        n.winner = e.payload;
      },
      setContractCode: (n, e) => {
        n.contractCode = e.payload;
      },
      showBlockchainNetwork: (n) => {
        n.showNetwork = !0;
      },
    },
  }),
  {
    showBlockchainNetwork: t4,
    startContractAnimation: n4,
    setBetGameWinner: aE,
    showSmartContract: r4,
    endContractAnimation: i4,
    setSender: __,
    setReceiver: S_,
    setValidator: X2,
    startTransaction: o4,
    updateTransactionProgress: w_,
    startValidation: s4,
    startBroadcast: a4,
    completeSimulation: l4,
  } = $2.actions,
  u4 = $2.reducer,
  Y2 = GF({ reducer: { simulation: u4 } });
Array.from({ length: 10 }, (n, e) => ({ id: e, name: `User ${e + 1}` }));
function c4() {
  const n = yS(),
    {
      sender: e,
      receiver: t,
      validator: r,
      phase: i,
      showNetwork: o,
      contractDeployed: s,
      contractHash: l,
      smartContract: u,
      winner: f,
      initialContract: h,
    } = $u((J) => J.simulation),
    [m, g] = K.useState(""),
    [y, x] = K.useState(""),
    [S, _] = K.useState(""),
    [w, T] = K.useState(""),
    [E, A] = K.useState(""),
    [R, k] = K.useState(""),
    [P, U] = K.useState(Boolean),
    [N, L] = K.useState(""),
    [H, G] = K.useState(""),
    [$, q] = K.useState(""),
    [Z, X] = K.useState(!1),
    [re, W] = K.useState(""),
    [te, F] = K.useState(h);
  K.useEffect(() => {
    console.log("DEPLOYING CONTRACT", s), console.log("CONTRACT hash ", l);
  }, [s, l]),
    K.useEffect(() => {
      s &&
        setTimeout(() => {
          X(!0);
        }, 800);
    }, [s]);
  const V = () => {
      e !== null && t !== null && r !== null && (n(o4()), n(X2(r)));
    },
    ne = () => {
      n(t4()),
        U(!0),
        setTimeout(() => {
          const oe = `0x${Math.random().toString(36).substring(2, 10)}`;
          n(n4(oe));
        }, 2e3),
        setTimeout(() => {
          n(i4()), U(!1);
        }, 9e3);
    },
    ae = () => {
      U(!0),
        setTimeout(() => {
          n(r4()), U(!1);
        }, 3e3);
    };
  return Q.jsxs(xn, {
    sx: {
      width: "100%",
      height: "100%",
      bgcolor: "#f5f5f5",
      p: { xs: 1.5, sm: 2 },
      pt: 4,
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: 3,
      overflowY: "auto",
      maxHeight: "100vh",
      ...(o === !1 && {
        justifyContent: "center",
        alignItems: "center",
        pt: 0,
      }),
    },
    children: [
      Q.jsx(xn, {
        sx: { width: "100%", maxWidth: "600px", mb: 2 },
        children: Q.jsxs(ef, {
          elevation: 3,
          sx: {
            p: 2.5,
            borderRadius: 2,
            bgcolor: "#e8f5e9",
            border: "1px solid #c8e6c9",
          },
          children: [
            Q.jsx(mr, {
              variant: "h6",
              sx: { fontWeight: "bold", mb: 1 },
              children: "Smart Contract Creation & Deployment Simulation",
            }),
            Q.jsxs(mr, {
              variant: "body2",
              color: "text.secondary",
              ntWeight: 600,
              sx: { lineHeight: 1.7, mb: 2 },
              children: [
                "1. Click ",
                Q.jsx("b", { children: "Create Smart Contract" }),
                Q.jsx("br", {}),
                Q.jsx(rm, {
                  disabled: u,
                  variant: "contained",
                  color: "secondary",
                  onClick: ae,
                  sx: {
                    borderRadius: "8px",
                    textTransform: "none",
                    fontWeight: 600,
                  },
                  children: P
                    ? "Creating Smart Contract..."
                    : "Create Smart Contract",
                }),
                Q.jsx("br", {}),
                u &&
                  Q.jsxs(Q.Fragment, {
                    children: [
                      "2. Click ",
                      Q.jsx("b", { children: "Deploy" }),
                      " to deploy the contract",
                      Q.jsx("br", {}),
                      Q.jsx(rm, {
                        disabled: te !== h || s,
                        variant: "contained",
                        color: "secondary",
                        onClick: ne,
                        sx: {
                          borderRadius: "8px",
                          textTransform: "none",
                          flex: 1,
                        },
                        children: P ? "Deploying" : "Deploy",
                      }),
                      Q.jsx("br", {}),
                    ],
                  }),
                r &&
                  Q.jsxs(Q.Fragment, {
                    children: [
                      "2. Click ",
                      Q.jsx("b", { children: " Initiate Transaction" }),
                      " to send the reward money to winner ",
                      Q.jsx(rm, {
                        disabled: !s,
                        variant: "contained",
                        onClick: V,
                        children: "Initiate Transaction",
                      }),
                    ],
                  }),
              ],
            }),
          ],
        }),
      }),
      Z &&
        Q.jsxs(xn, {
          sx: {
            p: 3,
            mb: 2,
            bgcolor: "#fff8e1",
            border: "1px solid #ffe0b2",
            borderRadius: 2,
            boxShadow: 1,
          },
          children: [
            Q.jsx(mr, {
              variant: "h5",
              sx: { fontWeight: 700, mb: 2, color: "#ff6f00" },
              children: "Introducing the Bet Game 🎲",
            }),
            Q.jsx(mr, {
              variant: "body1",
              sx: {
                lineHeight: 1.7,
                whiteSpace: "pre-line",
                fontFamily: "Roboto, monospace",
                color: "#4e342e",
                mb: 2,
              },
              children: `We introduce a bet game to showcase transactions under a deployed smart contract.

Two players pick a question and select unique answers. When the Play button is clicked, one answer is randomly chosen. The selected player wins, and the reward is automatically transferred from the loser to the winner according to the smart contract.`,
            }),
          ],
        }),
    ],
  });
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Py = "167",
  Kc = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Zc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  q2 = 0,
  X1 = 1,
  K2 = 2,
  f4 = 3,
  Z2 = 0,
  Iy = 1,
  sm = 2,
  ra = 3,
  Xa = 0,
  Qi = 1,
  Ts = 2,
  Il = 0,
  ff = 1,
  Y1 = 2,
  q1 = 3,
  K1 = 4,
  J2 = 5,
  Ou = 100,
  Q2 = 101,
  eA = 102,
  tA = 103,
  nA = 104,
  rA = 200,
  iA = 201,
  oA = 202,
  sA = 203,
  R0 = 204,
  P0 = 205,
  aA = 206,
  lA = 207,
  uA = 208,
  cA = 209,
  fA = 210,
  dA = 211,
  hA = 212,
  pA = 213,
  mA = 214,
  gA = 0,
  vA = 1,
  yA = 2,
  Tm = 3,
  xA = 4,
  _A = 5,
  SA = 6,
  wA = 7,
  Zm = 0,
  bA = 1,
  MA = 2,
  Ga = 0,
  EA = 1,
  TA = 2,
  CA = 3,
  tw = 4,
  AA = 5,
  RA = 6,
  PA = 7,
  Z1 = "attached",
  IA = "detached",
  Ly = 300,
  Dl = 301,
  Wu = 302,
  Cm = 303,
  Am = 304,
  Nh = 306,
  Rm = 1e3,
  As = 1001,
  Pm = 1002,
  _i = 1003,
  nw = 1004,
  d4 = 1004,
  ah = 1005,
  h4 = 1005,
  Cr = 1006,
  am = 1007,
  p4 = 1007,
  Ba = 1008,
  m4 = 1008,
  aa = 1009,
  rw = 1010,
  iw = 1011,
  Mh = 1012,
  ky = 1013,
  Nl = 1014,
  Oo = 1015,
  Oh = 1016,
  Dy = 1017,
  Ny = 1018,
  xf = 1020,
  ow = 35902,
  sw = 1021,
  aw = 1022,
  Ji = 1023,
  lw = 1024,
  uw = 1025,
  df = 1026,
  _f = 1027,
  Oy = 1028,
  Jm = 1029,
  cw = 1030,
  Uy = 1031,
  g4 = 1032,
  Fy = 1033,
  lm = 33776,
  um = 33777,
  cm = 33778,
  fm = 33779,
  I0 = 35840,
  L0 = 35841,
  k0 = 35842,
  D0 = 35843,
  N0 = 36196,
  O0 = 37492,
  U0 = 37496,
  F0 = 37808,
  B0 = 37809,
  z0 = 37810,
  H0 = 37811,
  V0 = 37812,
  G0 = 37813,
  W0 = 37814,
  j0 = 37815,
  $0 = 37816,
  X0 = 37817,
  Y0 = 37818,
  q0 = 37819,
  K0 = 37820,
  Z0 = 37821,
  dm = 36492,
  J0 = 36494,
  Q0 = 36495,
  fw = 36283,
  ey = 36284,
  ty = 36285,
  ny = 36286,
  LA = 2200,
  kA = 2201,
  DA = 2202,
  Im = 2300,
  ry = 2301,
  f0 = 2302,
  sf = 2400,
  af = 2401,
  Lm = 2402,
  By = 2500,
  dw = 2501,
  v4 = 0,
  y4 = 1,
  x4 = 2,
  NA = 3200,
  hw = 3201,
  _4 = 3202,
  S4 = 3203,
  Xu = 0,
  OA = 1,
  Cl = "",
  Ms = "srgb",
  Fl = "srgb-linear",
  zy = "display-p3",
  Qm = "display-p3-linear",
  km = "linear",
  Zn = "srgb",
  Dm = "rec709",
  Nm = "p3",
  w4 = 0,
  Jc = 7680,
  b4 = 7681,
  M4 = 7682,
  E4 = 7683,
  T4 = 34055,
  C4 = 34056,
  A4 = 5386,
  R4 = 512,
  P4 = 513,
  I4 = 514,
  L4 = 515,
  k4 = 516,
  D4 = 517,
  N4 = 518,
  J1 = 519,
  UA = 512,
  FA = 513,
  BA = 514,
  pw = 515,
  zA = 516,
  HA = 517,
  VA = 518,
  GA = 519,
  Om = 35044,
  O4 = 35048,
  U4 = 35040,
  F4 = 35045,
  B4 = 35049,
  z4 = 35041,
  H4 = 35046,
  V4 = 35050,
  G4 = 35042,
  W4 = "100",
  Q1 = "300 es",
  za = 2e3,
  Um = 2001;
let Bl = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
};
const $i = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let lE = 1234567;
const hf = Math.PI / 180,
  Eh = 180 / Math.PI;
function os() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    $i[n & 255] +
    $i[(n >> 8) & 255] +
    $i[(n >> 16) & 255] +
    $i[(n >> 24) & 255] +
    "-" +
    $i[e & 255] +
    $i[(e >> 8) & 255] +
    "-" +
    $i[((e >> 16) & 15) | 64] +
    $i[(e >> 24) & 255] +
    "-" +
    $i[(t & 63) | 128] +
    $i[(t >> 8) & 255] +
    "-" +
    $i[(t >> 16) & 255] +
    $i[(t >> 24) & 255] +
    $i[r & 255] +
    $i[(r >> 8) & 255] +
    $i[(r >> 16) & 255] +
    $i[(r >> 24) & 255]
  ).toLowerCase();
}
function Tr(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function mw(n, e) {
  return ((n % e) + e) % e;
}
function j4(n, e, t, r, i) {
  return r + ((n - e) * (i - r)) / (t - e);
}
function $4(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function hm(n, e, t) {
  return (1 - t) * n + t * e;
}
function X4(n, e, t, r) {
  return hm(n, e, 1 - Math.exp(-t * r));
}
function Y4(n, e = 1) {
  return e - Math.abs(mw(n, e * 2) - e);
}
function q4(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function K4(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function Z4(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function J4(n, e) {
  return n + Math.random() * (e - n);
}
function Q4(n) {
  return n * (0.5 - Math.random());
}
function eB(n) {
  n !== void 0 && (lE = n);
  let e = (lE += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function tB(n) {
  return n * hf;
}
function nB(n) {
  return n * Eh;
}
function rB(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function iB(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function oB(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function sB(n, e, t, r, i) {
  const o = Math.cos,
    s = Math.sin,
    l = o(t / 2),
    u = s(t / 2),
    f = o((e + r) / 2),
    h = s((e + r) / 2),
    m = o((e - r) / 2),
    g = s((e - r) / 2),
    y = o((r - e) / 2),
    x = s((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(l * h, u * m, u * g, l * f);
      break;
    case "YZY":
      n.set(u * g, l * h, u * m, l * f);
      break;
    case "ZXZ":
      n.set(u * m, u * g, l * h, l * f);
      break;
    case "XZX":
      n.set(l * h, u * x, u * y, l * f);
      break;
    case "YXY":
      n.set(u * y, l * h, u * x, l * f);
      break;
    case "ZYZ":
      n.set(u * x, u * y, l * h, l * f);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function go(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function sn(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const aB = {
  DEG2RAD: hf,
  RAD2DEG: Eh,
  generateUUID: os,
  clamp: Tr,
  euclideanModulo: mw,
  mapLinear: j4,
  inverseLerp: $4,
  lerp: hm,
  damp: X4,
  pingpong: Y4,
  smoothstep: q4,
  smootherstep: K4,
  randInt: Z4,
  randFloat: J4,
  randFloatSpread: Q4,
  seededRandom: eB,
  degToRad: tB,
  radToDeg: nB,
  isPowerOfTwo: rB,
  ceilPowerOfTwo: iB,
  floorPowerOfTwo: oB,
  setQuaternionFromProperEuler: sB,
  normalize: sn,
  denormalize: go,
};
class tt {
  constructor(e = 0, t = 0) {
    (tt.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * r + i[6]),
      (this.y = i[1] * t + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Tr(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      o = this.x - e.x,
      s = this.y - e.y;
    return (this.x = o * r - s * i + e.x), (this.y = o * i + s * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class tn {
  constructor(e, t, r, i, o, s, l, u, f) {
    (tn.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, o, s, l, u, f);
  }
  set(e, t, r, i, o, s, l, u, f) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = i),
      (h[2] = l),
      (h[3] = t),
      (h[4] = o),
      (h[5] = u),
      (h[6] = r),
      (h[7] = s),
      (h[8] = f),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      o = this.elements,
      s = r[0],
      l = r[3],
      u = r[6],
      f = r[1],
      h = r[4],
      m = r[7],
      g = r[2],
      y = r[5],
      x = r[8],
      S = i[0],
      _ = i[3],
      w = i[6],
      T = i[1],
      E = i[4],
      A = i[7],
      R = i[2],
      k = i[5],
      P = i[8];
    return (
      (o[0] = s * S + l * T + u * R),
      (o[3] = s * _ + l * E + u * k),
      (o[6] = s * w + l * A + u * P),
      (o[1] = f * S + h * T + m * R),
      (o[4] = f * _ + h * E + m * k),
      (o[7] = f * w + h * A + m * P),
      (o[2] = g * S + y * T + x * R),
      (o[5] = g * _ + y * E + x * k),
      (o[8] = g * w + y * A + x * P),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      l = e[5],
      u = e[6],
      f = e[7],
      h = e[8];
    return (
      t * s * h - t * l * f - r * o * h + r * l * u + i * o * f - i * s * u
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      l = e[5],
      u = e[6],
      f = e[7],
      h = e[8],
      m = h * s - l * f,
      g = l * u - h * o,
      y = f * o - s * u,
      x = t * m + r * g + i * y;
    if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / x;
    return (
      (e[0] = m * S),
      (e[1] = (i * f - h * r) * S),
      (e[2] = (l * r - i * s) * S),
      (e[3] = g * S),
      (e[4] = (h * t - i * u) * S),
      (e[5] = (i * o - l * t) * S),
      (e[6] = y * S),
      (e[7] = (r * u - f * t) * S),
      (e[8] = (s * t - r * o) * S),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, i, o, s, l) {
    const u = Math.cos(o),
      f = Math.sin(o);
    return (
      this.set(
        r * u,
        r * f,
        -r * (u * s + f * l) + s + e,
        -i * f,
        i * u,
        -i * (-f * s + u * l) + l + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(b_.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(b_.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(b_.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const b_ = new tn();
function WA(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const lB = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function lh(n, e) {
  return new lB[n](e);
}
function Fm(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function jA() {
  const n = Fm("canvas");
  return (n.style.display = "block"), n;
}
const uE = {};
function vh(n) {
  n in uE || ((uE[n] = !0), console.warn(n));
}
function uB(n, e, t) {
  return new Promise(function (r, i) {
    function o() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          i();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(o, t);
          break;
        default:
          r();
      }
    }
    setTimeout(o, t);
  });
}
const cE = new tn().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  fE = new tn().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  Lp = {
    [Fl]: {
      transfer: km,
      primaries: Dm,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (n) => n,
      fromReference: (n) => n,
    },
    [Ms]: {
      transfer: Zn,
      primaries: Dm,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (n) => n.convertSRGBToLinear(),
      fromReference: (n) => n.convertLinearToSRGB(),
    },
    [Qm]: {
      transfer: km,
      primaries: Nm,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (n) => n.applyMatrix3(fE),
      fromReference: (n) => n.applyMatrix3(cE),
    },
    [zy]: {
      transfer: Zn,
      primaries: Nm,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (n) => n.convertSRGBToLinear().applyMatrix3(fE),
      fromReference: (n) => n.applyMatrix3(cE).convertLinearToSRGB(),
    },
  },
  cB = new Set([Fl, Qm]),
  yn = {
    enabled: !0,
    _workingColorSpace: Fl,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(n) {
      if (!cB.has(n))
        throw new Error(`Unsupported working color space, "${n}".`);
      this._workingColorSpace = n;
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const r = Lp[e].toReference,
        i = Lp[t].fromReference;
      return i(r(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this._workingColorSpace);
    },
    getPrimaries: function (n) {
      return Lp[n].primaries;
    },
    getTransfer: function (n) {
      return n === Cl ? km : Lp[n].transfer;
    },
    getLuminanceCoefficients: function (n, e = this._workingColorSpace) {
      return n.fromArray(Lp[e].luminanceCoefficients);
    },
  };
function yh(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function M_(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let Id;
class $A {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Id === void 0 && (Id = Fm("canvas")),
        (Id.width = e.width),
        (Id.height = e.height);
      const r = Id.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (t = Id);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Fm("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        o = i.data;
      for (let s = 0; s < o.length; s++) o[s] = yh(o[s] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(yh(t[r] / 255) * 255))
          : (t[r] = yh(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let fB = 0;
class lf {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: fB++ }),
      (this.uuid = os()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let s = 0, l = i.length; s < l; s++)
          i[s].isDataTexture ? o.push(E_(i[s].image)) : o.push(E_(i[s]));
      } else o = E_(i);
      r.url = o;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function E_(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? $A.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let dB = 0;
class Qn extends Bl {
  constructor(
    e = Qn.DEFAULT_IMAGE,
    t = Qn.DEFAULT_MAPPING,
    r = As,
    i = As,
    o = Cr,
    s = Ba,
    l = Ji,
    u = aa,
    f = Qn.DEFAULT_ANISOTROPY,
    h = Cl
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: dB++ }),
      (this.uuid = os()),
      (this.name = ""),
      (this.source = new lf(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = o),
      (this.minFilter = s),
      (this.anisotropy = f),
      (this.format = l),
      (this.internalFormat = null),
      (this.type = u),
      (this.offset = new tt(0, 0)),
      (this.repeat = new tt(1, 1)),
      (this.center = new tt(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new tn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Ly) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Rm:
          e.x = e.x - Math.floor(e.x);
          break;
        case As:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Pm:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Rm:
          e.y = e.y - Math.floor(e.y);
          break;
        case As:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Pm:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Qn.DEFAULT_IMAGE = null;
Qn.DEFAULT_MAPPING = Ly;
Qn.DEFAULT_ANISOTROPY = 1;
class Tn {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (Tn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = this.w,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * r + s[8] * i + s[12] * o),
      (this.y = s[1] * t + s[5] * r + s[9] * i + s[13] * o),
      (this.z = s[2] * t + s[6] * r + s[10] * i + s[14] * o),
      (this.w = s[3] * t + s[7] * r + s[11] * i + s[15] * o),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, o;
    const u = e.elements,
      f = u[0],
      h = u[4],
      m = u[8],
      g = u[1],
      y = u[5],
      x = u[9],
      S = u[2],
      _ = u[6],
      w = u[10];
    if (
      Math.abs(h - g) < 0.01 &&
      Math.abs(m - S) < 0.01 &&
      Math.abs(x - _) < 0.01
    ) {
      if (
        Math.abs(h + g) < 0.1 &&
        Math.abs(m + S) < 0.1 &&
        Math.abs(x + _) < 0.1 &&
        Math.abs(f + y + w - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const E = (f + 1) / 2,
        A = (y + 1) / 2,
        R = (w + 1) / 2,
        k = (h + g) / 4,
        P = (m + S) / 4,
        U = (x + _) / 4;
      return (
        E > A && E > R
          ? E < 0.01
            ? ((r = 0), (i = 0.707106781), (o = 0.707106781))
            : ((r = Math.sqrt(E)), (i = k / r), (o = P / r))
          : A > R
          ? A < 0.01
            ? ((r = 0.707106781), (i = 0), (o = 0.707106781))
            : ((i = Math.sqrt(A)), (r = k / i), (o = U / i))
          : R < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (o = 0))
          : ((o = Math.sqrt(R)), (r = P / o), (i = U / o)),
        this.set(r, i, o, t),
        this
      );
    }
    let T = Math.sqrt(
      (_ - x) * (_ - x) + (m - S) * (m - S) + (g - h) * (g - h)
    );
    return (
      Math.abs(T) < 0.001 && (T = 1),
      (this.x = (_ - x) / T),
      (this.y = (m - S) / T),
      (this.z = (g - h) / T),
      (this.w = Math.acos((f + y + w - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class XA extends Bl {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Tn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Tn(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    r = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Cr,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      r
    );
    const o = new Qn(
      i,
      r.mapping,
      r.wrapS,
      r.wrapT,
      r.magFilter,
      r.minFilter,
      r.format,
      r.type,
      r.anisotropy,
      r.colorSpace
    );
    (o.flipY = !1),
      (o.generateMipmaps = r.generateMipmaps),
      (o.internalFormat = r.internalFormat),
      (this.textures = []);
    const s = r.count;
    for (let l = 0; l < s; l++)
      (this.textures[l] = o.clone()),
        (this.textures[l].isRenderTargetTexture = !0);
    (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.resolveDepthBuffer = r.resolveDepthBuffer),
      (this.resolveStencilBuffer = r.resolveStencilBuffer),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      (this.width = e), (this.height = t), (this.depth = r);
      for (let i = 0, o = this.textures.length; i < o; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let r = 0, i = e.textures.length; r < i; r++)
      (this.textures[r] = e.textures[r].clone()),
        (this.textures[r].isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new lf(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class la extends XA {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), (this.isWebGLRenderTarget = !0);
  }
}
class Hy extends Qn {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = _i),
      (this.minFilter = _i),
      (this.wrapR = As),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class hB extends la {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new Hy(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class gw extends Qn {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = _i),
      (this.minFilter = _i),
      (this.wrapR = As),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class pB extends la {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new gw(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class eo {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, t, r, i, o, s, l) {
    let u = r[i + 0],
      f = r[i + 1],
      h = r[i + 2],
      m = r[i + 3];
    const g = o[s + 0],
      y = o[s + 1],
      x = o[s + 2],
      S = o[s + 3];
    if (l === 0) {
      (e[t + 0] = u), (e[t + 1] = f), (e[t + 2] = h), (e[t + 3] = m);
      return;
    }
    if (l === 1) {
      (e[t + 0] = g), (e[t + 1] = y), (e[t + 2] = x), (e[t + 3] = S);
      return;
    }
    if (m !== S || u !== g || f !== y || h !== x) {
      let _ = 1 - l;
      const w = u * g + f * y + h * x + m * S,
        T = w >= 0 ? 1 : -1,
        E = 1 - w * w;
      if (E > Number.EPSILON) {
        const R = Math.sqrt(E),
          k = Math.atan2(R, w * T);
        (_ = Math.sin(_ * k) / R), (l = Math.sin(l * k) / R);
      }
      const A = l * T;
      if (
        ((u = u * _ + g * A),
        (f = f * _ + y * A),
        (h = h * _ + x * A),
        (m = m * _ + S * A),
        _ === 1 - l)
      ) {
        const R = 1 / Math.sqrt(u * u + f * f + h * h + m * m);
        (u *= R), (f *= R), (h *= R), (m *= R);
      }
    }
    (e[t] = u), (e[t + 1] = f), (e[t + 2] = h), (e[t + 3] = m);
  }
  static multiplyQuaternionsFlat(e, t, r, i, o, s) {
    const l = r[i],
      u = r[i + 1],
      f = r[i + 2],
      h = r[i + 3],
      m = o[s],
      g = o[s + 1],
      y = o[s + 2],
      x = o[s + 3];
    return (
      (e[t] = l * x + h * m + u * y - f * g),
      (e[t + 1] = u * x + h * g + f * m - l * y),
      (e[t + 2] = f * x + h * y + l * g - u * m),
      (e[t + 3] = h * x - l * m - u * g - f * y),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._order,
      l = Math.cos,
      u = Math.sin,
      f = l(r / 2),
      h = l(i / 2),
      m = l(o / 2),
      g = u(r / 2),
      y = u(i / 2),
      x = u(o / 2);
    switch (s) {
      case "XYZ":
        (this._x = g * h * m + f * y * x),
          (this._y = f * y * m - g * h * x),
          (this._z = f * h * x + g * y * m),
          (this._w = f * h * m - g * y * x);
        break;
      case "YXZ":
        (this._x = g * h * m + f * y * x),
          (this._y = f * y * m - g * h * x),
          (this._z = f * h * x - g * y * m),
          (this._w = f * h * m + g * y * x);
        break;
      case "ZXY":
        (this._x = g * h * m - f * y * x),
          (this._y = f * y * m + g * h * x),
          (this._z = f * h * x + g * y * m),
          (this._w = f * h * m - g * y * x);
        break;
      case "ZYX":
        (this._x = g * h * m - f * y * x),
          (this._y = f * y * m + g * h * x),
          (this._z = f * h * x - g * y * m),
          (this._w = f * h * m + g * y * x);
        break;
      case "YZX":
        (this._x = g * h * m + f * y * x),
          (this._y = f * y * m + g * h * x),
          (this._z = f * h * x - g * y * m),
          (this._w = f * h * m - g * y * x);
        break;
      case "XZY":
        (this._x = g * h * m - f * y * x),
          (this._y = f * y * m - g * h * x),
          (this._z = f * h * x + g * y * m),
          (this._w = f * h * m + g * y * x);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      i = t[4],
      o = t[8],
      s = t[1],
      l = t[5],
      u = t[9],
      f = t[2],
      h = t[6],
      m = t[10],
      g = r + l + m;
    if (g > 0) {
      const y = 0.5 / Math.sqrt(g + 1);
      (this._w = 0.25 / y),
        (this._x = (h - u) * y),
        (this._y = (o - f) * y),
        (this._z = (s - i) * y);
    } else if (r > l && r > m) {
      const y = 2 * Math.sqrt(1 + r - l - m);
      (this._w = (h - u) / y),
        (this._x = 0.25 * y),
        (this._y = (i + s) / y),
        (this._z = (o + f) / y);
    } else if (l > m) {
      const y = 2 * Math.sqrt(1 + l - r - m);
      (this._w = (o - f) / y),
        (this._x = (i + s) / y),
        (this._y = 0.25 * y),
        (this._z = (u + h) / y);
    } else {
      const y = 2 * Math.sqrt(1 + m - r - l);
      (this._w = (s - i) / y),
        (this._x = (o + f) / y),
        (this._y = (u + h) / y),
        (this._z = 0.25 * y);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Tr(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._w,
      l = t._x,
      u = t._y,
      f = t._z,
      h = t._w;
    return (
      (this._x = r * h + s * l + i * f - o * u),
      (this._y = i * h + s * u + o * l - r * f),
      (this._z = o * h + s * f + r * u - i * l),
      (this._w = s * h - r * l - i * u - o * f),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      o = this._z,
      s = this._w;
    let l = s * e._w + r * e._x + i * e._y + o * e._z;
    if (
      (l < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (l = -l))
        : this.copy(e),
      l >= 1)
    )
      return (this._w = s), (this._x = r), (this._y = i), (this._z = o), this;
    const u = 1 - l * l;
    if (u <= Number.EPSILON) {
      const y = 1 - t;
      return (
        (this._w = y * s + t * this._w),
        (this._x = y * r + t * this._x),
        (this._y = y * i + t * this._y),
        (this._z = y * o + t * this._z),
        this.normalize(),
        this
      );
    }
    const f = Math.sqrt(u),
      h = Math.atan2(f, l),
      m = Math.sin((1 - t) * h) / f,
      g = Math.sin(t * h) / f;
    return (
      (this._w = s * m + this._w * g),
      (this._x = r * m + this._x * g),
      (this._y = i * m + this._y * g),
      (this._z = o * m + this._z * g),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      r = Math.random(),
      i = Math.sqrt(1 - r),
      o = Math.sqrt(r);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      o * Math.sin(t),
      o * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class se {
  constructor(e = 0, t = 0, r = 0) {
    (se.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(dE.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(dE.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[3] * r + o[6] * i),
      (this.y = o[1] * t + o[4] * r + o[7] * i),
      (this.z = o[2] * t + o[5] * r + o[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements,
      s = 1 / (o[3] * t + o[7] * r + o[11] * i + o[15]);
    return (
      (this.x = (o[0] * t + o[4] * r + o[8] * i + o[12]) * s),
      (this.y = (o[1] * t + o[5] * r + o[9] * i + o[13]) * s),
      (this.z = (o[2] * t + o[6] * r + o[10] * i + o[14]) * s),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.x,
      s = e.y,
      l = e.z,
      u = e.w,
      f = 2 * (s * i - l * r),
      h = 2 * (l * t - o * i),
      m = 2 * (o * r - s * t);
    return (
      (this.x = t + u * f + s * m - l * h),
      (this.y = r + u * h + l * f - o * m),
      (this.z = i + u * m + o * h - s * f),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * r + o[8] * i),
      (this.y = o[1] * t + o[5] * r + o[9] * i),
      (this.z = o[2] * t + o[6] * r + o[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = t.x,
      l = t.y,
      u = t.z;
    return (
      (this.x = i * u - o * l),
      (this.y = o * s - r * u),
      (this.z = r * l - i * s),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return T_.copy(this).projectOnVector(e), this.sub(T_);
  }
  reflect(e) {
    return this.sub(T_.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Tr(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      r = Math.sqrt(1 - t * t);
    return (
      (this.x = r * Math.cos(e)), (this.y = t), (this.z = r * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const T_ = new se(),
  dE = new eo();
class to {
  constructor(
    e = new se(1 / 0, 1 / 0, 1 / 0),
    t = new se(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(ea.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(ea.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = ea.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const o = r.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let s = 0, l = o.count; s < l; s++)
          e.isMesh === !0
            ? e.getVertexPosition(s, ea)
            : ea.fromBufferAttribute(o, s),
            ea.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ea);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            uv.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            uv.copy(r.boundingBox)),
          uv.applyMatrix4(e.matrixWorld),
          this.union(uv);
    }
    const i = e.children;
    for (let o = 0, s = i.length; o < s; o++) this.expandByObject(i[o], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ea),
      ea.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(kp),
      cv.subVectors(this.max, kp),
      Ld.subVectors(e.a, kp),
      kd.subVectors(e.b, kp),
      Dd.subVectors(e.c, kp),
      Tu.subVectors(kd, Ld),
      Cu.subVectors(Dd, kd),
      Lc.subVectors(Ld, Dd);
    let t = [
      0,
      -Tu.z,
      Tu.y,
      0,
      -Cu.z,
      Cu.y,
      0,
      -Lc.z,
      Lc.y,
      Tu.z,
      0,
      -Tu.x,
      Cu.z,
      0,
      -Cu.x,
      Lc.z,
      0,
      -Lc.x,
      -Tu.y,
      Tu.x,
      0,
      -Cu.y,
      Cu.x,
      0,
      -Lc.y,
      Lc.x,
      0,
    ];
    return !C_(t, Ld, kd, Dd, cv) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !C_(t, Ld, kd, Dd, cv))
      ? !1
      : (fv.crossVectors(Tu, Cu),
        (t = [fv.x, fv.y, fv.z]),
        C_(t, Ld, kd, Dd, cv));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ea).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(ea).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (xl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        xl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        xl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        xl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        xl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        xl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        xl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        xl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(xl),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const xl = [
    new se(),
    new se(),
    new se(),
    new se(),
    new se(),
    new se(),
    new se(),
    new se(),
  ],
  ea = new se(),
  uv = new to(),
  Ld = new se(),
  kd = new se(),
  Dd = new se(),
  Tu = new se(),
  Cu = new se(),
  Lc = new se(),
  kp = new se(),
  cv = new se(),
  fv = new se(),
  kc = new se();
function C_(n, e, t, r, i) {
  for (let o = 0, s = n.length - 3; o <= s; o += 3) {
    kc.fromArray(n, o);
    const l =
        i.x * Math.abs(kc.x) + i.y * Math.abs(kc.y) + i.z * Math.abs(kc.z),
      u = e.dot(kc),
      f = t.dot(kc),
      h = r.dot(kc);
    if (Math.max(-Math.max(u, f, h), Math.min(u, f, h)) > l) return !1;
  }
  return !0;
}
const mB = new to(),
  Dp = new se(),
  A_ = new se();
class Ni {
  constructor(e = new se(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : mB.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let o = 0, s = e.length; o < s; o++)
      i = Math.max(i, r.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Dp.subVectors(e, this.center);
    const t = Dp.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(Dp, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (A_.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Dp.copy(e.center).add(A_)),
            this.expandByPoint(Dp.copy(e.center).sub(A_))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _l = new se(),
  R_ = new se(),
  dv = new se(),
  Au = new se(),
  P_ = new se(),
  hv = new se(),
  I_ = new se();
class Tf {
  constructor(e = new se(), t = new se(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _l)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = _l.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (_l.copy(this.origin).addScaledVector(this.direction, t),
        _l.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    R_.copy(e).add(t).multiplyScalar(0.5),
      dv.copy(t).sub(e).normalize(),
      Au.copy(this.origin).sub(R_);
    const o = e.distanceTo(t) * 0.5,
      s = -this.direction.dot(dv),
      l = Au.dot(this.direction),
      u = -Au.dot(dv),
      f = Au.lengthSq(),
      h = Math.abs(1 - s * s);
    let m, g, y, x;
    if (h > 0)
      if (((m = s * u - l), (g = s * l - u), (x = o * h), m >= 0))
        if (g >= -x)
          if (g <= x) {
            const S = 1 / h;
            (m *= S),
              (g *= S),
              (y = m * (m + s * g + 2 * l) + g * (s * m + g + 2 * u) + f);
          } else
            (g = o),
              (m = Math.max(0, -(s * g + l))),
              (y = -m * m + g * (g + 2 * u) + f);
        else
          (g = -o),
            (m = Math.max(0, -(s * g + l))),
            (y = -m * m + g * (g + 2 * u) + f);
      else
        g <= -x
          ? ((m = Math.max(0, -(-s * o + l))),
            (g = m > 0 ? -o : Math.min(Math.max(-o, -u), o)),
            (y = -m * m + g * (g + 2 * u) + f))
          : g <= x
          ? ((m = 0),
            (g = Math.min(Math.max(-o, -u), o)),
            (y = g * (g + 2 * u) + f))
          : ((m = Math.max(0, -(s * o + l))),
            (g = m > 0 ? o : Math.min(Math.max(-o, -u), o)),
            (y = -m * m + g * (g + 2 * u) + f));
    else
      (g = s > 0 ? -o : o),
        (m = Math.max(0, -(s * g + l))),
        (y = -m * m + g * (g + 2 * u) + f);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, m),
      i && i.copy(R_).addScaledVector(dv, g),
      y
    );
  }
  intersectSphere(e, t) {
    _l.subVectors(e.center, this.origin);
    const r = _l.dot(this.direction),
      i = _l.dot(_l) - r * r,
      o = e.radius * e.radius;
    if (i > o) return null;
    const s = Math.sqrt(o - i),
      l = r - s,
      u = r + s;
    return u < 0 ? null : l < 0 ? this.at(u, t) : this.at(l, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, o, s, l, u;
    const f = 1 / this.direction.x,
      h = 1 / this.direction.y,
      m = 1 / this.direction.z,
      g = this.origin;
    return (
      f >= 0
        ? ((r = (e.min.x - g.x) * f), (i = (e.max.x - g.x) * f))
        : ((r = (e.max.x - g.x) * f), (i = (e.min.x - g.x) * f)),
      h >= 0
        ? ((o = (e.min.y - g.y) * h), (s = (e.max.y - g.y) * h))
        : ((o = (e.max.y - g.y) * h), (s = (e.min.y - g.y) * h)),
      r > s ||
      o > i ||
      ((o > r || isNaN(r)) && (r = o),
      (s < i || isNaN(i)) && (i = s),
      m >= 0
        ? ((l = (e.min.z - g.z) * m), (u = (e.max.z - g.z) * m))
        : ((l = (e.max.z - g.z) * m), (u = (e.min.z - g.z) * m)),
      r > u || l > i) ||
      ((l > r || r !== r) && (r = l), (u < i || i !== i) && (i = u), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, _l) !== null;
  }
  intersectTriangle(e, t, r, i, o) {
    P_.subVectors(t, e), hv.subVectors(r, e), I_.crossVectors(P_, hv);
    let s = this.direction.dot(I_),
      l;
    if (s > 0) {
      if (i) return null;
      l = 1;
    } else if (s < 0) (l = -1), (s = -s);
    else return null;
    Au.subVectors(this.origin, e);
    const u = l * this.direction.dot(hv.crossVectors(Au, hv));
    if (u < 0) return null;
    const f = l * this.direction.dot(P_.cross(Au));
    if (f < 0 || u + f > s) return null;
    const h = -l * Au.dot(I_);
    return h < 0 ? null : this.at(h / s, o);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Wt {
  constructor(e, t, r, i, o, s, l, u, f, h, m, g, y, x, S, _) {
    (Wt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, o, s, l, u, f, h, m, g, y, x, S, _);
  }
  set(e, t, r, i, o, s, l, u, f, h, m, g, y, x, S, _) {
    const w = this.elements;
    return (
      (w[0] = e),
      (w[4] = t),
      (w[8] = r),
      (w[12] = i),
      (w[1] = o),
      (w[5] = s),
      (w[9] = l),
      (w[13] = u),
      (w[2] = f),
      (w[6] = h),
      (w[10] = m),
      (w[14] = g),
      (w[3] = y),
      (w[7] = x),
      (w[11] = S),
      (w[15] = _),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Wt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      i = 1 / Nd.setFromMatrixColumn(e, 0).length(),
      o = 1 / Nd.setFromMatrixColumn(e, 1).length(),
      s = 1 / Nd.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * i),
      (t[1] = r[1] * i),
      (t[2] = r[2] * i),
      (t[3] = 0),
      (t[4] = r[4] * o),
      (t[5] = r[5] * o),
      (t[6] = r[6] * o),
      (t[7] = 0),
      (t[8] = r[8] * s),
      (t[9] = r[9] * s),
      (t[10] = r[10] * s),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      o = e.z,
      s = Math.cos(r),
      l = Math.sin(r),
      u = Math.cos(i),
      f = Math.sin(i),
      h = Math.cos(o),
      m = Math.sin(o);
    if (e.order === "XYZ") {
      const g = s * h,
        y = s * m,
        x = l * h,
        S = l * m;
      (t[0] = u * h),
        (t[4] = -u * m),
        (t[8] = f),
        (t[1] = y + x * f),
        (t[5] = g - S * f),
        (t[9] = -l * u),
        (t[2] = S - g * f),
        (t[6] = x + y * f),
        (t[10] = s * u);
    } else if (e.order === "YXZ") {
      const g = u * h,
        y = u * m,
        x = f * h,
        S = f * m;
      (t[0] = g + S * l),
        (t[4] = x * l - y),
        (t[8] = s * f),
        (t[1] = s * m),
        (t[5] = s * h),
        (t[9] = -l),
        (t[2] = y * l - x),
        (t[6] = S + g * l),
        (t[10] = s * u);
    } else if (e.order === "ZXY") {
      const g = u * h,
        y = u * m,
        x = f * h,
        S = f * m;
      (t[0] = g - S * l),
        (t[4] = -s * m),
        (t[8] = x + y * l),
        (t[1] = y + x * l),
        (t[5] = s * h),
        (t[9] = S - g * l),
        (t[2] = -s * f),
        (t[6] = l),
        (t[10] = s * u);
    } else if (e.order === "ZYX") {
      const g = s * h,
        y = s * m,
        x = l * h,
        S = l * m;
      (t[0] = u * h),
        (t[4] = x * f - y),
        (t[8] = g * f + S),
        (t[1] = u * m),
        (t[5] = S * f + g),
        (t[9] = y * f - x),
        (t[2] = -f),
        (t[6] = l * u),
        (t[10] = s * u);
    } else if (e.order === "YZX") {
      const g = s * u,
        y = s * f,
        x = l * u,
        S = l * f;
      (t[0] = u * h),
        (t[4] = S - g * m),
        (t[8] = x * m + y),
        (t[1] = m),
        (t[5] = s * h),
        (t[9] = -l * h),
        (t[2] = -f * h),
        (t[6] = y * m + x),
        (t[10] = g - S * m);
    } else if (e.order === "XZY") {
      const g = s * u,
        y = s * f,
        x = l * u,
        S = l * f;
      (t[0] = u * h),
        (t[4] = -m),
        (t[8] = f * h),
        (t[1] = g * m + S),
        (t[5] = s * h),
        (t[9] = y * m - x),
        (t[2] = x * m - y),
        (t[6] = l * h),
        (t[10] = S * m + g);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(gB, e, vB);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return (
      es.subVectors(e, t),
      es.lengthSq() === 0 && (es.z = 1),
      es.normalize(),
      Ru.crossVectors(r, es),
      Ru.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (es.x += 1e-4) : (es.z += 1e-4),
        es.normalize(),
        Ru.crossVectors(r, es)),
      Ru.normalize(),
      pv.crossVectors(es, Ru),
      (i[0] = Ru.x),
      (i[4] = pv.x),
      (i[8] = es.x),
      (i[1] = Ru.y),
      (i[5] = pv.y),
      (i[9] = es.y),
      (i[2] = Ru.z),
      (i[6] = pv.z),
      (i[10] = es.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      o = this.elements,
      s = r[0],
      l = r[4],
      u = r[8],
      f = r[12],
      h = r[1],
      m = r[5],
      g = r[9],
      y = r[13],
      x = r[2],
      S = r[6],
      _ = r[10],
      w = r[14],
      T = r[3],
      E = r[7],
      A = r[11],
      R = r[15],
      k = i[0],
      P = i[4],
      U = i[8],
      N = i[12],
      L = i[1],
      H = i[5],
      G = i[9],
      $ = i[13],
      q = i[2],
      Z = i[6],
      X = i[10],
      re = i[14],
      W = i[3],
      te = i[7],
      F = i[11],
      V = i[15];
    return (
      (o[0] = s * k + l * L + u * q + f * W),
      (o[4] = s * P + l * H + u * Z + f * te),
      (o[8] = s * U + l * G + u * X + f * F),
      (o[12] = s * N + l * $ + u * re + f * V),
      (o[1] = h * k + m * L + g * q + y * W),
      (o[5] = h * P + m * H + g * Z + y * te),
      (o[9] = h * U + m * G + g * X + y * F),
      (o[13] = h * N + m * $ + g * re + y * V),
      (o[2] = x * k + S * L + _ * q + w * W),
      (o[6] = x * P + S * H + _ * Z + w * te),
      (o[10] = x * U + S * G + _ * X + w * F),
      (o[14] = x * N + S * $ + _ * re + w * V),
      (o[3] = T * k + E * L + A * q + R * W),
      (o[7] = T * P + E * H + A * Z + R * te),
      (o[11] = T * U + E * G + A * X + R * F),
      (o[15] = T * N + E * $ + A * re + R * V),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      i = e[8],
      o = e[12],
      s = e[1],
      l = e[5],
      u = e[9],
      f = e[13],
      h = e[2],
      m = e[6],
      g = e[10],
      y = e[14],
      x = e[3],
      S = e[7],
      _ = e[11],
      w = e[15];
    return (
      x *
        (+o * u * m -
          i * f * m -
          o * l * g +
          r * f * g +
          i * l * y -
          r * u * y) +
      S *
        (+t * u * y -
          t * f * g +
          o * s * g -
          i * s * y +
          i * f * h -
          o * u * h) +
      _ *
        (+t * f * m -
          t * l * y -
          o * s * m +
          r * s * y +
          o * l * h -
          r * f * h) +
      w *
        (-i * l * h - t * u * m + t * l * g + i * s * m - r * s * g + r * u * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      l = e[5],
      u = e[6],
      f = e[7],
      h = e[8],
      m = e[9],
      g = e[10],
      y = e[11],
      x = e[12],
      S = e[13],
      _ = e[14],
      w = e[15],
      T = m * _ * f - S * g * f + S * u * y - l * _ * y - m * u * w + l * g * w,
      E = x * g * f - h * _ * f - x * u * y + s * _ * y + h * u * w - s * g * w,
      A = h * S * f - x * m * f + x * l * y - s * S * y - h * l * w + s * m * w,
      R = x * m * u - h * S * u - x * l * g + s * S * g + h * l * _ - s * m * _,
      k = t * T + r * E + i * A + o * R;
    if (k === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / k;
    return (
      (e[0] = T * P),
      (e[1] =
        (S * g * o -
          m * _ * o -
          S * i * y +
          r * _ * y +
          m * i * w -
          r * g * w) *
        P),
      (e[2] =
        (l * _ * o -
          S * u * o +
          S * i * f -
          r * _ * f -
          l * i * w +
          r * u * w) *
        P),
      (e[3] =
        (m * u * o -
          l * g * o -
          m * i * f +
          r * g * f +
          l * i * y -
          r * u * y) *
        P),
      (e[4] = E * P),
      (e[5] =
        (h * _ * o -
          x * g * o +
          x * i * y -
          t * _ * y -
          h * i * w +
          t * g * w) *
        P),
      (e[6] =
        (x * u * o -
          s * _ * o -
          x * i * f +
          t * _ * f +
          s * i * w -
          t * u * w) *
        P),
      (e[7] =
        (s * g * o -
          h * u * o +
          h * i * f -
          t * g * f -
          s * i * y +
          t * u * y) *
        P),
      (e[8] = A * P),
      (e[9] =
        (x * m * o -
          h * S * o -
          x * r * y +
          t * S * y +
          h * r * w -
          t * m * w) *
        P),
      (e[10] =
        (s * S * o -
          x * l * o +
          x * r * f -
          t * S * f -
          s * r * w +
          t * l * w) *
        P),
      (e[11] =
        (h * l * o -
          s * m * o -
          h * r * f +
          t * m * f +
          s * r * y -
          t * l * y) *
        P),
      (e[12] = R * P),
      (e[13] =
        (h * S * i -
          x * m * i +
          x * r * g -
          t * S * g -
          h * r * _ +
          t * m * _) *
        P),
      (e[14] =
        (x * l * i -
          s * S * i -
          x * r * u +
          t * S * u +
          s * r * _ -
          t * l * _) *
        P),
      (e[15] =
        (s * m * i -
          h * l * i +
          h * r * u -
          t * m * u -
          s * r * g +
          t * l * g) *
        P),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      o = e.z;
    return (
      (t[0] *= r),
      (t[4] *= i),
      (t[8] *= o),
      (t[1] *= r),
      (t[5] *= i),
      (t[9] *= o),
      (t[2] *= r),
      (t[6] *= i),
      (t[10] *= o),
      (t[3] *= r),
      (t[7] *= i),
      (t[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      o = 1 - r,
      s = e.x,
      l = e.y,
      u = e.z,
      f = o * s,
      h = o * l;
    return (
      this.set(
        f * s + r,
        f * l - i * u,
        f * u + i * l,
        0,
        f * l + i * u,
        h * l + r,
        h * u - i * s,
        0,
        f * u - i * l,
        h * u + i * s,
        o * u * u + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, i, o, s) {
    return this.set(1, r, o, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const i = this.elements,
      o = t._x,
      s = t._y,
      l = t._z,
      u = t._w,
      f = o + o,
      h = s + s,
      m = l + l,
      g = o * f,
      y = o * h,
      x = o * m,
      S = s * h,
      _ = s * m,
      w = l * m,
      T = u * f,
      E = u * h,
      A = u * m,
      R = r.x,
      k = r.y,
      P = r.z;
    return (
      (i[0] = (1 - (S + w)) * R),
      (i[1] = (y + A) * R),
      (i[2] = (x - E) * R),
      (i[3] = 0),
      (i[4] = (y - A) * k),
      (i[5] = (1 - (g + w)) * k),
      (i[6] = (_ + T) * k),
      (i[7] = 0),
      (i[8] = (x + E) * P),
      (i[9] = (_ - T) * P),
      (i[10] = (1 - (g + S)) * P),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const i = this.elements;
    let o = Nd.set(i[0], i[1], i[2]).length();
    const s = Nd.set(i[4], i[5], i[6]).length(),
      l = Nd.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      ta.copy(this);
    const f = 1 / o,
      h = 1 / s,
      m = 1 / l;
    return (
      (ta.elements[0] *= f),
      (ta.elements[1] *= f),
      (ta.elements[2] *= f),
      (ta.elements[4] *= h),
      (ta.elements[5] *= h),
      (ta.elements[6] *= h),
      (ta.elements[8] *= m),
      (ta.elements[9] *= m),
      (ta.elements[10] *= m),
      t.setFromRotationMatrix(ta),
      (r.x = o),
      (r.y = s),
      (r.z = l),
      this
    );
  }
  makePerspective(e, t, r, i, o, s, l = za) {
    const u = this.elements,
      f = (2 * o) / (t - e),
      h = (2 * o) / (r - i),
      m = (t + e) / (t - e),
      g = (r + i) / (r - i);
    let y, x;
    if (l === za) (y = -(s + o) / (s - o)), (x = (-2 * s * o) / (s - o));
    else if (l === Um) (y = -s / (s - o)), (x = (-s * o) / (s - o));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l
      );
    return (
      (u[0] = f),
      (u[4] = 0),
      (u[8] = m),
      (u[12] = 0),
      (u[1] = 0),
      (u[5] = h),
      (u[9] = g),
      (u[13] = 0),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = y),
      (u[14] = x),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = -1),
      (u[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, i, o, s, l = za) {
    const u = this.elements,
      f = 1 / (t - e),
      h = 1 / (r - i),
      m = 1 / (s - o),
      g = (t + e) * f,
      y = (r + i) * h;
    let x, S;
    if (l === za) (x = (s + o) * m), (S = -2 * m);
    else if (l === Um) (x = o * m), (S = -1 * m);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l
      );
    return (
      (u[0] = 2 * f),
      (u[4] = 0),
      (u[8] = 0),
      (u[12] = -g),
      (u[1] = 0),
      (u[5] = 2 * h),
      (u[9] = 0),
      (u[13] = -y),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = S),
      (u[14] = -x),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = 0),
      (u[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const Nd = new se(),
  ta = new Wt(),
  gB = new se(0, 0, 0),
  vB = new se(1, 1, 1),
  Ru = new se(),
  pv = new se(),
  es = new se(),
  hE = new Wt(),
  pE = new eo();
class as {
  constructor(e = 0, t = 0, r = 0, i = as.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements,
      o = i[0],
      s = i[4],
      l = i[8],
      u = i[1],
      f = i[5],
      h = i[9],
      m = i[2],
      g = i[6],
      y = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Tr(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, y)), (this._z = Math.atan2(-s, o)))
            : ((this._x = Math.atan2(g, f)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Tr(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(l, y)), (this._z = Math.atan2(u, f)))
            : ((this._y = Math.atan2(-m, o)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Tr(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._y = Math.atan2(-m, y)), (this._z = Math.atan2(-s, f)))
            : ((this._y = 0), (this._z = Math.atan2(u, o)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Tr(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._x = Math.atan2(g, y)), (this._z = Math.atan2(u, o)))
            : ((this._x = 0), (this._z = Math.atan2(-s, f)));
        break;
      case "YZX":
        (this._z = Math.asin(Tr(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-h, f)), (this._y = Math.atan2(-m, o)))
            : ((this._x = 0), (this._y = Math.atan2(l, y)));
        break;
      case "XZY":
        (this._z = Math.asin(-Tr(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(g, f)), (this._y = Math.atan2(l, o)))
            : ((this._x = Math.atan2(-h, y)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      hE.makeRotationFromQuaternion(e), this.setFromRotationMatrix(hE, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return pE.setFromEuler(this), this.setFromQuaternion(pE, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
as.DEFAULT_ORDER = "XYZ";
class pf {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let yB = 0;
const mE = new se(),
  Od = new eo(),
  Sl = new Wt(),
  mv = new se(),
  Np = new se(),
  xB = new se(),
  _B = new eo(),
  gE = new se(1, 0, 0),
  vE = new se(0, 1, 0),
  yE = new se(0, 0, 1),
  xE = { type: "added" },
  SB = { type: "removed" },
  Ud = { type: "childadded", child: null },
  L_ = { type: "childremoved", child: null };
class _n extends Bl {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: yB++ }),
      (this.uuid = os()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = _n.DEFAULT_UP.clone());
    const e = new se(),
      t = new as(),
      r = new eo(),
      i = new se(1, 1, 1);
    function o() {
      r.setFromEuler(t, !1);
    }
    function s() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(o),
      r._onChange(s),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Wt() },
        normalMatrix: { value: new tn() },
      }),
      (this.matrix = new Wt()),
      (this.matrixWorld = new Wt()),
      (this.matrixAutoUpdate = _n.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = _n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new pf()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Od.setFromAxisAngle(e, t), this.quaternion.multiply(Od), this;
  }
  rotateOnWorldAxis(e, t) {
    return Od.setFromAxisAngle(e, t), this.quaternion.premultiply(Od), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(gE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(vE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(yE, e);
  }
  translateOnAxis(e, t) {
    return (
      mE.copy(e).applyQuaternion(this.quaternion),
      this.position.add(mE.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(gE, e);
  }
  translateY(e) {
    return this.translateOnAxis(vE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(yE, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Sl.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? mv.copy(e) : mv.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Np.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Sl.lookAt(Np, mv, this.up)
        : Sl.lookAt(mv, Np, this.up),
      this.quaternion.setFromRotationMatrix(Sl),
      i &&
        (Sl.extractRotation(i.matrixWorld),
        Od.setFromRotationMatrix(Sl),
        this.quaternion.premultiply(Od.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(xE),
            (Ud.child = e),
            this.dispatchEvent(Ud),
            (Ud.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(SB),
        (L_.child = e),
        this.dispatchEvent(L_),
        (L_.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Sl.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Sl.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Sl),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(xE),
      (Ud.child = e),
      this.dispatchEvent(Ud),
      (Ud.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const s = this.children[r].getObjectByProperty(e, t);
      if (s !== void 0) return s;
    }
  }
  getObjectsByProperty(e, t, r = []) {
    this[e] === t && r.push(this);
    const i = this.children;
    for (let o = 0, s = i.length; o < s; o++)
      i[o].getObjectsByProperty(e, t, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Np, e, xB), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Np, _B, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const i = this.children;
      for (let o = 0, s = i.length; o < s; o++) i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((l) => ({
          boxInitialized: l.boxInitialized,
          boxMin: l.box.min.toArray(),
          boxMax: l.box.max.toArray(),
          sphereInitialized: l.sphereInitialized,
          sphereRadius: l.sphere.radius,
          sphereCenter: l.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function o(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let f = 0, h = u.length; f < h; f++) {
            const m = u[f];
            o(e.shapes, m);
          }
        else o(e.shapes, u);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, f = this.material.length; u < f; u++)
          l.push(o(e.materials, this.material[u]));
        i.material = l;
      } else i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let l = 0; l < this.children.length; l++)
        i.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        i.animations.push(o(e.animations, u));
      }
    }
    if (t) {
      const l = s(e.geometries),
        u = s(e.materials),
        f = s(e.textures),
        h = s(e.images),
        m = s(e.shapes),
        g = s(e.skeletons),
        y = s(e.animations),
        x = s(e.nodes);
      l.length > 0 && (r.geometries = l),
        u.length > 0 && (r.materials = u),
        f.length > 0 && (r.textures = f),
        h.length > 0 && (r.images = h),
        m.length > 0 && (r.shapes = m),
        g.length > 0 && (r.skeletons = g),
        y.length > 0 && (r.animations = y),
        x.length > 0 && (r.nodes = x);
    }
    return (r.object = i), r;
    function s(l) {
      const u = [];
      for (const f in l) {
        const h = l[f];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
_n.DEFAULT_UP = new se(0, 1, 0);
_n.DEFAULT_MATRIX_AUTO_UPDATE = !0;
_n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const na = new se(),
  wl = new se(),
  k_ = new se(),
  bl = new se(),
  Fd = new se(),
  Bd = new se(),
  _E = new se(),
  D_ = new se(),
  N_ = new se(),
  O_ = new se();
class rs {
  constructor(e = new se(), t = new se(), r = new se()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), na.subVectors(e, t), i.cross(na);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, o) {
    na.subVectors(i, t), wl.subVectors(r, t), k_.subVectors(e, t);
    const s = na.dot(na),
      l = na.dot(wl),
      u = na.dot(k_),
      f = wl.dot(wl),
      h = wl.dot(k_),
      m = s * f - l * l;
    if (m === 0) return o.set(0, 0, 0), null;
    const g = 1 / m,
      y = (f * u - l * h) * g,
      x = (s * h - l * u) * g;
    return o.set(1 - y - x, x, y);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, bl) === null
      ? !1
      : bl.x >= 0 && bl.y >= 0 && bl.x + bl.y <= 1;
  }
  static getInterpolation(e, t, r, i, o, s, l, u) {
    return this.getBarycoord(e, t, r, i, bl) === null
      ? ((u.x = 0),
        (u.y = 0),
        "z" in u && (u.z = 0),
        "w" in u && (u.w = 0),
        null)
      : (u.setScalar(0),
        u.addScaledVector(o, bl.x),
        u.addScaledVector(s, bl.y),
        u.addScaledVector(l, bl.z),
        u);
  }
  static isFrontFacing(e, t, r, i) {
    return na.subVectors(r, t), wl.subVectors(e, t), na.cross(wl).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      na.subVectors(this.c, this.b),
      wl.subVectors(this.a, this.b),
      na.cross(wl).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return rs.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return rs.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, r, i, o) {
    return rs.getInterpolation(e, this.a, this.b, this.c, t, r, i, o);
  }
  containsPoint(e) {
    return rs.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return rs.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      i = this.b,
      o = this.c;
    let s, l;
    Fd.subVectors(i, r), Bd.subVectors(o, r), D_.subVectors(e, r);
    const u = Fd.dot(D_),
      f = Bd.dot(D_);
    if (u <= 0 && f <= 0) return t.copy(r);
    N_.subVectors(e, i);
    const h = Fd.dot(N_),
      m = Bd.dot(N_);
    if (h >= 0 && m <= h) return t.copy(i);
    const g = u * m - h * f;
    if (g <= 0 && u >= 0 && h <= 0)
      return (s = u / (u - h)), t.copy(r).addScaledVector(Fd, s);
    O_.subVectors(e, o);
    const y = Fd.dot(O_),
      x = Bd.dot(O_);
    if (x >= 0 && y <= x) return t.copy(o);
    const S = y * f - u * x;
    if (S <= 0 && f >= 0 && x <= 0)
      return (l = f / (f - x)), t.copy(r).addScaledVector(Bd, l);
    const _ = h * x - y * m;
    if (_ <= 0 && m - h >= 0 && y - x >= 0)
      return (
        _E.subVectors(o, i),
        (l = (m - h) / (m - h + (y - x))),
        t.copy(i).addScaledVector(_E, l)
      );
    const w = 1 / (_ + S + g);
    return (
      (s = S * w),
      (l = g * w),
      t.copy(r).addScaledVector(Fd, s).addScaledVector(Bd, l)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const YA = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Pu = { h: 0, s: 0, l: 0 },
  gv = { h: 0, s: 0, l: 0 };
function U_(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class St {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Ms) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      yn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, r, i = yn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      yn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, r, i = yn.workingColorSpace) {
    if (((e = mw(e, 1)), (t = Tr(t, 0, 1)), (r = Tr(r, 0, 1)), t === 0))
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        s = 2 * r - o;
      (this.r = U_(s, o, e + 1 / 3)),
        (this.g = U_(s, o, e)),
        (this.b = U_(s, o, e - 1 / 3));
    }
    return yn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Ms) {
    function r(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let o;
      const s = i[1],
        l = i[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (
            (o =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(255, parseInt(o[1], 10)) / 255,
                Math.min(255, parseInt(o[2], 10)) / 255,
                Math.min(255, parseInt(o[3], 10)) / 255,
                t
              )
            );
          if (
            (o =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(100, parseInt(o[1], 10)) / 100,
                Math.min(100, parseInt(o[2], 10)) / 100,
                Math.min(100, parseInt(o[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setHSL(
                parseFloat(o[1]) / 360,
                parseFloat(o[2]) / 100,
                parseFloat(o[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = i[1],
        s = o.length;
      if (s === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (s === 6) return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Ms) {
    const r = YA[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = yh(e.r)), (this.g = yh(e.g)), (this.b = yh(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = M_(e.r)), (this.g = M_(e.g)), (this.b = M_(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Ms) {
    return (
      yn.fromWorkingColorSpace(Xi.copy(this), e),
      Math.round(Tr(Xi.r * 255, 0, 255)) * 65536 +
        Math.round(Tr(Xi.g * 255, 0, 255)) * 256 +
        Math.round(Tr(Xi.b * 255, 0, 255))
    );
  }
  getHexString(e = Ms) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = yn.workingColorSpace) {
    yn.fromWorkingColorSpace(Xi.copy(this), t);
    const r = Xi.r,
      i = Xi.g,
      o = Xi.b,
      s = Math.max(r, i, o),
      l = Math.min(r, i, o);
    let u, f;
    const h = (l + s) / 2;
    if (l === s) (u = 0), (f = 0);
    else {
      const m = s - l;
      switch (((f = h <= 0.5 ? m / (s + l) : m / (2 - s - l)), s)) {
        case r:
          u = (i - o) / m + (i < o ? 6 : 0);
          break;
        case i:
          u = (o - r) / m + 2;
          break;
        case o:
          u = (r - i) / m + 4;
          break;
      }
      u /= 6;
    }
    return (e.h = u), (e.s = f), (e.l = h), e;
  }
  getRGB(e, t = yn.workingColorSpace) {
    return (
      yn.fromWorkingColorSpace(Xi.copy(this), t),
      (e.r = Xi.r),
      (e.g = Xi.g),
      (e.b = Xi.b),
      e
    );
  }
  getStyle(e = Ms) {
    yn.fromWorkingColorSpace(Xi.copy(this), e);
    const t = Xi.r,
      r = Xi.g,
      i = Xi.b;
    return e !== Ms
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(Pu), this.setHSL(Pu.h + e, Pu.s + t, Pu.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Pu), e.getHSL(gv);
    const r = hm(Pu.h, gv.h, t),
      i = hm(Pu.s, gv.s, t),
      o = hm(Pu.l, gv.l, t);
    return this.setHSL(r, i, o), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      i = this.b,
      o = e.elements;
    return (
      (this.r = o[0] * t + o[3] * r + o[6] * i),
      (this.g = o[1] * t + o[4] * r + o[7] * i),
      (this.b = o[2] * t + o[5] * r + o[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Xi = new St();
St.NAMES = YA;
let wB = 0;
class Oi extends Bl {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: wB++ }),
      (this.uuid = os()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = ff),
      (this.side = Xa),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = R0),
      (this.blendDst = P0),
      (this.blendEquation = Ou),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new St(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Tm),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = J1),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Jc),
      (this.stencilZFail = Jc),
      (this.stencilZPass = Jc),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (r.dispersion = this.dispersion),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (r.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== ff && (r.blending = this.blending),
      this.side !== Xa && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== R0 && (r.blendSrc = this.blendSrc),
      this.blendDst !== P0 && (r.blendDst = this.blendDst),
      this.blendEquation !== Ou && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== Tm && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== J1 && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Jc && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== Jc && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Jc && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(o) {
      const s = [];
      for (const l in o) {
        const u = o[l];
        delete u.metadata, s.push(u);
      }
      return s;
    }
    if (t) {
      const o = i(e.textures),
        s = i(e.images);
      o.length > 0 && (r.textures = o), s.length > 0 && (r.images = s);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let o = 0; o !== i; ++o) r[o] = t[o].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
  onBeforeRender() {
    console.warn("Material: onBeforeRender() has been removed.");
  }
}
class zl extends Oi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new as()),
      (this.combine = Zm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Al = bB();
function bB() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const f = u - 127;
    f < -27
      ? ((r[u] = 0), (r[u | 256] = 32768), (i[u] = 24), (i[u | 256] = 24))
      : f < -14
      ? ((r[u] = 1024 >> (-f - 14)),
        (r[u | 256] = (1024 >> (-f - 14)) | 32768),
        (i[u] = -f - 1),
        (i[u | 256] = -f - 1))
      : f <= 15
      ? ((r[u] = (f + 15) << 10),
        (r[u | 256] = ((f + 15) << 10) | 32768),
        (i[u] = 13),
        (i[u | 256] = 13))
      : f < 128
      ? ((r[u] = 31744), (r[u | 256] = 64512), (i[u] = 24), (i[u | 256] = 24))
      : ((r[u] = 31744), (r[u | 256] = 64512), (i[u] = 13), (i[u | 256] = 13));
  }
  const o = new Uint32Array(2048),
    s = new Uint32Array(64),
    l = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let f = u << 13,
      h = 0;
    for (; (f & 8388608) === 0; ) (f <<= 1), (h -= 8388608);
    (f &= -8388609), (h += 947912704), (o[u] = f | h);
  }
  for (let u = 1024; u < 2048; ++u) o[u] = 939524096 + ((u - 1024) << 13);
  for (let u = 1; u < 31; ++u) s[u] = u << 23;
  (s[31] = 1199570944), (s[32] = 2147483648);
  for (let u = 33; u < 63; ++u) s[u] = 2147483648 + ((u - 32) << 23);
  s[63] = 3347054592;
  for (let u = 1; u < 64; ++u) u !== 32 && (l[u] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: s,
    offsetTable: l,
  };
}
function No(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = Tr(n, -65504, 65504)),
    (Al.floatView[0] = n);
  const e = Al.uint32View[0],
    t = (e >> 23) & 511;
  return Al.baseTable[t] + ((e & 8388607) >> Al.shiftTable[t]);
}
function Jp(n) {
  const e = n >> 10;
  return (
    (Al.uint32View[0] =
      Al.mantissaTable[Al.offsetTable[e] + (n & 1023)] + Al.exponentTable[e]),
    Al.floatView[0]
  );
}
const MB = { toHalfFloat: No, fromHalfFloat: Jp },
  ei = new se(),
  vv = new tt();
class Gn {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = Om),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = Oo),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      vh(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        vv.fromBufferAttribute(this, t),
          vv.applyMatrix3(e),
          this.setXY(t, vv.x, vv.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        ei.fromBufferAttribute(this, t),
          ei.applyMatrix3(e),
          this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      ei.fromBufferAttribute(this, t),
        ei.applyMatrix4(e),
        this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      ei.fromBufferAttribute(this, t),
        ei.applyNormalMatrix(e),
        this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      ei.fromBufferAttribute(this, t),
        ei.transformDirection(e),
        this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = go(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = sn(r, this.array)),
      (this.array[e * this.itemSize + t] = r),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = go(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = go(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = go(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = go(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = sn(t, this.array)), (r = sn(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = sn(t, this.array)),
        (r = sn(r, this.array)),
        (i = sn(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = sn(t, this.array)),
        (r = sn(r, this.array)),
        (i = sn(i, this.array)),
        (o = sn(o, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Om && (e.usage = this.usage),
      e
    );
  }
}
class EB extends Gn {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class TB extends Gn {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class CB extends Gn {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class AB extends Gn {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class vw extends Gn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class RB extends Gn {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class yw extends Gn {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class PB extends Gn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Jp(this.array[e * this.itemSize]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize] = No(t)),
      this
    );
  }
  getY(e) {
    let t = Jp(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize + 1] = No(t)),
      this
    );
  }
  getZ(e) {
    let t = Jp(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize + 2] = No(t)),
      this
    );
  }
  getW(e) {
    let t = Jp(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.array[e * this.itemSize + 3] = No(t)),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = sn(t, this.array)), (r = sn(r, this.array))),
      (this.array[e + 0] = No(t)),
      (this.array[e + 1] = No(r)),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = sn(t, this.array)),
        (r = sn(r, this.array)),
        (i = sn(i, this.array))),
      (this.array[e + 0] = No(t)),
      (this.array[e + 1] = No(r)),
      (this.array[e + 2] = No(i)),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = sn(t, this.array)),
        (r = sn(r, this.array)),
        (i = sn(i, this.array)),
        (o = sn(o, this.array))),
      (this.array[e + 0] = No(t)),
      (this.array[e + 1] = No(r)),
      (this.array[e + 2] = No(i)),
      (this.array[e + 3] = No(o)),
      this
    );
  }
}
class kt extends Gn {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let IB = 0;
const ws = new Wt(),
  F_ = new _n(),
  zd = new se(),
  ts = new to(),
  Op = new to(),
  xi = new se();
class Jt extends Bl {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: IB++ }),
      (this.uuid = os()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (WA(e) ? yw : vw)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new tn().getNormalMatrix(e);
      r.applyNormalMatrix(o), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return ws.makeRotationFromQuaternion(e), this.applyMatrix4(ws), this;
  }
  rotateX(e) {
    return ws.makeRotationX(e), this.applyMatrix4(ws), this;
  }
  rotateY(e) {
    return ws.makeRotationY(e), this.applyMatrix4(ws), this;
  }
  rotateZ(e) {
    return ws.makeRotationZ(e), this.applyMatrix4(ws), this;
  }
  translate(e, t, r) {
    return ws.makeTranslation(e, t, r), this.applyMatrix4(ws), this;
  }
  scale(e, t, r) {
    return ws.makeScale(e, t, r), this.applyMatrix4(ws), this;
  }
  lookAt(e) {
    return F_.lookAt(e), F_.updateMatrix(), this.applyMatrix4(F_.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(zd).negate(),
      this.translate(zd.x, zd.y, zd.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const o = e[r];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new kt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new to());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new se(-1 / 0, -1 / 0, -1 / 0),
          new se(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, i = t.length; r < i; r++) {
          const o = t[r];
          ts.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (xi.addVectors(this.boundingBox.min, ts.min),
                this.boundingBox.expandByPoint(xi),
                xi.addVectors(this.boundingBox.max, ts.max),
                this.boundingBox.expandByPoint(xi))
              : (this.boundingBox.expandByPoint(ts.min),
                this.boundingBox.expandByPoint(ts.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ni());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new se(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((ts.setFromBufferAttribute(e), t))
        for (let o = 0, s = t.length; o < s; o++) {
          const l = t[o];
          Op.setFromBufferAttribute(l),
            this.morphTargetsRelative
              ? (xi.addVectors(ts.min, Op.min),
                ts.expandByPoint(xi),
                xi.addVectors(ts.max, Op.max),
                ts.expandByPoint(xi))
              : (ts.expandByPoint(Op.min), ts.expandByPoint(Op.max));
        }
      ts.getCenter(r);
      let i = 0;
      for (let o = 0, s = e.count; o < s; o++)
        xi.fromBufferAttribute(e, o),
          (i = Math.max(i, r.distanceToSquared(xi)));
      if (t)
        for (let o = 0, s = t.length; o < s; o++) {
          const l = t[o],
            u = this.morphTargetsRelative;
          for (let f = 0, h = l.count; f < h; f++)
            xi.fromBufferAttribute(l, f),
              u && (zd.fromBufferAttribute(e, f), xi.add(zd)),
              (i = Math.max(i, r.distanceToSquared(xi)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = t.position,
      i = t.normal,
      o = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Gn(new Float32Array(4 * r.count), 4));
    const s = this.getAttribute("tangent"),
      l = [],
      u = [];
    for (let U = 0; U < r.count; U++) (l[U] = new se()), (u[U] = new se());
    const f = new se(),
      h = new se(),
      m = new se(),
      g = new tt(),
      y = new tt(),
      x = new tt(),
      S = new se(),
      _ = new se();
    function w(U, N, L) {
      f.fromBufferAttribute(r, U),
        h.fromBufferAttribute(r, N),
        m.fromBufferAttribute(r, L),
        g.fromBufferAttribute(o, U),
        y.fromBufferAttribute(o, N),
        x.fromBufferAttribute(o, L),
        h.sub(f),
        m.sub(f),
        y.sub(g),
        x.sub(g);
      const H = 1 / (y.x * x.y - x.x * y.y);
      isFinite(H) &&
        (S.copy(h)
          .multiplyScalar(x.y)
          .addScaledVector(m, -y.y)
          .multiplyScalar(H),
        _.copy(m)
          .multiplyScalar(y.x)
          .addScaledVector(h, -x.x)
          .multiplyScalar(H),
        l[U].add(S),
        l[N].add(S),
        l[L].add(S),
        u[U].add(_),
        u[N].add(_),
        u[L].add(_));
    }
    let T = this.groups;
    T.length === 0 && (T = [{ start: 0, count: e.count }]);
    for (let U = 0, N = T.length; U < N; ++U) {
      const L = T[U],
        H = L.start,
        G = L.count;
      for (let $ = H, q = H + G; $ < q; $ += 3)
        w(e.getX($ + 0), e.getX($ + 1), e.getX($ + 2));
    }
    const E = new se(),
      A = new se(),
      R = new se(),
      k = new se();
    function P(U) {
      R.fromBufferAttribute(i, U), k.copy(R);
      const N = l[U];
      E.copy(N),
        E.sub(R.multiplyScalar(R.dot(N))).normalize(),
        A.crossVectors(k, N);
      const H = A.dot(u[U]) < 0 ? -1 : 1;
      s.setXYZW(U, E.x, E.y, E.z, H);
    }
    for (let U = 0, N = T.length; U < N; ++U) {
      const L = T[U],
        H = L.start,
        G = L.count;
      for (let $ = H, q = H + G; $ < q; $ += 3)
        P(e.getX($ + 0)), P(e.getX($ + 1)), P(e.getX($ + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new Gn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let g = 0, y = r.count; g < y; g++) r.setXYZ(g, 0, 0, 0);
      const i = new se(),
        o = new se(),
        s = new se(),
        l = new se(),
        u = new se(),
        f = new se(),
        h = new se(),
        m = new se();
      if (e)
        for (let g = 0, y = e.count; g < y; g += 3) {
          const x = e.getX(g + 0),
            S = e.getX(g + 1),
            _ = e.getX(g + 2);
          i.fromBufferAttribute(t, x),
            o.fromBufferAttribute(t, S),
            s.fromBufferAttribute(t, _),
            h.subVectors(s, o),
            m.subVectors(i, o),
            h.cross(m),
            l.fromBufferAttribute(r, x),
            u.fromBufferAttribute(r, S),
            f.fromBufferAttribute(r, _),
            l.add(h),
            u.add(h),
            f.add(h),
            r.setXYZ(x, l.x, l.y, l.z),
            r.setXYZ(S, u.x, u.y, u.z),
            r.setXYZ(_, f.x, f.y, f.z);
        }
      else
        for (let g = 0, y = t.count; g < y; g += 3)
          i.fromBufferAttribute(t, g + 0),
            o.fromBufferAttribute(t, g + 1),
            s.fromBufferAttribute(t, g + 2),
            h.subVectors(s, o),
            m.subVectors(i, o),
            h.cross(m),
            r.setXYZ(g + 0, h.x, h.y, h.z),
            r.setXYZ(g + 1, h.x, h.y, h.z),
            r.setXYZ(g + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      xi.fromBufferAttribute(e, t),
        xi.normalize(),
        e.setXYZ(t, xi.x, xi.y, xi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const f = l.array,
        h = l.itemSize,
        m = l.normalized,
        g = new f.constructor(u.length * h);
      let y = 0,
        x = 0;
      for (let S = 0, _ = u.length; S < _; S++) {
        l.isInterleavedBufferAttribute
          ? (y = u[S] * l.data.stride + l.offset)
          : (y = u[S] * h);
        for (let w = 0; w < h; w++) g[x++] = f[y++];
      }
      return new Gn(g, h, m);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new Jt(),
      r = this.index.array,
      i = this.attributes;
    for (const l in i) {
      const u = i[l],
        f = e(u, r);
      t.setAttribute(l, f);
    }
    const o = this.morphAttributes;
    for (const l in o) {
      const u = [],
        f = o[l];
      for (let h = 0, m = f.length; h < m; h++) {
        const g = f[h],
          y = e(g, r);
        u.push(y);
      }
      t.morphAttributes[l] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let l = 0, u = s.length; l < u; l++) {
      const f = s[l];
      t.addGroup(f.start, f.count, f.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const u = this.parameters;
      for (const f in u) u[f] !== void 0 && (e[f] = u[f]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const u in r) {
      const f = r[u];
      e.data.attributes[u] = f.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const u in this.morphAttributes) {
      const f = this.morphAttributes[u],
        h = [];
      for (let m = 0, g = f.length; m < g; m++) {
        const y = f[m];
        h.push(y.toJSON(e.data));
      }
      h.length > 0 && ((i[u] = h), (o = !0));
    }
    o &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    const l = this.boundingSphere;
    return (
      l !== null &&
        (e.data.boundingSphere = {
          center: l.center.toArray(),
          radius: l.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const f in i) {
      const h = i[f];
      this.setAttribute(f, h.clone(t));
    }
    const o = e.morphAttributes;
    for (const f in o) {
      const h = [],
        m = o[f];
      for (let g = 0, y = m.length; g < y; g++) h.push(m[g].clone(t));
      this.morphAttributes[f] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const s = e.groups;
    for (let f = 0, h = s.length; f < h; f++) {
      const m = s[f];
      this.addGroup(m.start, m.count, m.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const SE = new Wt(),
  Dc = new Tf(),
  yv = new Ni(),
  wE = new se(),
  Hd = new se(),
  Vd = new se(),
  Gd = new se(),
  B_ = new se(),
  xv = new se(),
  _v = new tt(),
  Sv = new tt(),
  wv = new tt(),
  bE = new se(),
  ME = new se(),
  EE = new se(),
  bv = new se(),
  Mv = new se();
class vr extends _n {
  constructor(e = new Jt(), t = new zl()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const l = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      i = r.attributes.position,
      o = r.morphAttributes.position,
      s = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const l = this.morphTargetInfluences;
    if (o && l) {
      xv.set(0, 0, 0);
      for (let u = 0, f = o.length; u < f; u++) {
        const h = l[u],
          m = o[u];
        h !== 0 &&
          (B_.fromBufferAttribute(m, e),
          s ? xv.addScaledVector(B_, h) : xv.addScaledVector(B_.sub(t), h));
      }
      t.add(xv);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.material,
      o = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      yv.copy(r.boundingSphere),
      yv.applyMatrix4(o),
      Dc.copy(e.ray).recast(e.near),
      !(
        yv.containsPoint(Dc.origin) === !1 &&
        (Dc.intersectSphere(yv, wE) === null ||
          Dc.origin.distanceToSquared(wE) > (e.far - e.near) ** 2)
      ) &&
        (SE.copy(o).invert(),
        Dc.copy(e.ray).applyMatrix4(SE),
        !(r.boundingBox !== null && Dc.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, t, Dc)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const o = this.geometry,
      s = this.material,
      l = o.index,
      u = o.attributes.position,
      f = o.attributes.uv,
      h = o.attributes.uv1,
      m = o.attributes.normal,
      g = o.groups,
      y = o.drawRange;
    if (l !== null)
      if (Array.isArray(s))
        for (let x = 0, S = g.length; x < S; x++) {
          const _ = g[x],
            w = s[_.materialIndex],
            T = Math.max(_.start, y.start),
            E = Math.min(
              l.count,
              Math.min(_.start + _.count, y.start + y.count)
            );
          for (let A = T, R = E; A < R; A += 3) {
            const k = l.getX(A),
              P = l.getX(A + 1),
              U = l.getX(A + 2);
            (i = Ev(this, w, e, r, f, h, m, k, P, U)),
              i &&
                ((i.faceIndex = Math.floor(A / 3)),
                (i.face.materialIndex = _.materialIndex),
                t.push(i));
          }
        }
      else {
        const x = Math.max(0, y.start),
          S = Math.min(l.count, y.start + y.count);
        for (let _ = x, w = S; _ < w; _ += 3) {
          const T = l.getX(_),
            E = l.getX(_ + 1),
            A = l.getX(_ + 2);
          (i = Ev(this, s, e, r, f, h, m, T, E, A)),
            i && ((i.faceIndex = Math.floor(_ / 3)), t.push(i));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(s))
        for (let x = 0, S = g.length; x < S; x++) {
          const _ = g[x],
            w = s[_.materialIndex],
            T = Math.max(_.start, y.start),
            E = Math.min(
              u.count,
              Math.min(_.start + _.count, y.start + y.count)
            );
          for (let A = T, R = E; A < R; A += 3) {
            const k = A,
              P = A + 1,
              U = A + 2;
            (i = Ev(this, w, e, r, f, h, m, k, P, U)),
              i &&
                ((i.faceIndex = Math.floor(A / 3)),
                (i.face.materialIndex = _.materialIndex),
                t.push(i));
          }
        }
      else {
        const x = Math.max(0, y.start),
          S = Math.min(u.count, y.start + y.count);
        for (let _ = x, w = S; _ < w; _ += 3) {
          const T = _,
            E = _ + 1,
            A = _ + 2;
          (i = Ev(this, s, e, r, f, h, m, T, E, A)),
            i && ((i.faceIndex = Math.floor(_ / 3)), t.push(i));
        }
      }
  }
}
function LB(n, e, t, r, i, o, s, l) {
  let u;
  if (
    (e.side === Qi
      ? (u = r.intersectTriangle(s, o, i, !0, l))
      : (u = r.intersectTriangle(i, o, s, e.side === Xa, l)),
    u === null)
  )
    return null;
  Mv.copy(l), Mv.applyMatrix4(n.matrixWorld);
  const f = t.ray.origin.distanceTo(Mv);
  return f < t.near || f > t.far
    ? null
    : { distance: f, point: Mv.clone(), object: n };
}
function Ev(n, e, t, r, i, o, s, l, u, f) {
  n.getVertexPosition(l, Hd),
    n.getVertexPosition(u, Vd),
    n.getVertexPosition(f, Gd);
  const h = LB(n, e, t, r, Hd, Vd, Gd, bv);
  if (h) {
    i &&
      (_v.fromBufferAttribute(i, l),
      Sv.fromBufferAttribute(i, u),
      wv.fromBufferAttribute(i, f),
      (h.uv = rs.getInterpolation(bv, Hd, Vd, Gd, _v, Sv, wv, new tt()))),
      o &&
        (_v.fromBufferAttribute(o, l),
        Sv.fromBufferAttribute(o, u),
        wv.fromBufferAttribute(o, f),
        (h.uv1 = rs.getInterpolation(bv, Hd, Vd, Gd, _v, Sv, wv, new tt()))),
      s &&
        (bE.fromBufferAttribute(s, l),
        ME.fromBufferAttribute(s, u),
        EE.fromBufferAttribute(s, f),
        (h.normal = rs.getInterpolation(bv, Hd, Vd, Gd, bE, ME, EE, new se())),
        h.normal.dot(r.direction) > 0 && h.normal.multiplyScalar(-1));
    const m = { a: l, b: u, c: f, normal: new se(), materialIndex: 0 };
    rs.getNormal(Hd, Vd, Gd, m.normal), (h.face = m);
  }
  return h;
}
class Cf extends Jt {
  constructor(e = 1, t = 1, r = 1, i = 1, o = 1, s = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: o,
        depthSegments: s,
      });
    const l = this;
    (i = Math.floor(i)), (o = Math.floor(o)), (s = Math.floor(s));
    const u = [],
      f = [],
      h = [],
      m = [];
    let g = 0,
      y = 0;
    x("z", "y", "x", -1, -1, r, t, e, s, o, 0),
      x("z", "y", "x", 1, -1, r, t, -e, s, o, 1),
      x("x", "z", "y", 1, 1, e, r, t, i, s, 2),
      x("x", "z", "y", 1, -1, e, r, -t, i, s, 3),
      x("x", "y", "z", 1, -1, e, t, r, i, o, 4),
      x("x", "y", "z", -1, -1, e, t, -r, i, o, 5),
      this.setIndex(u),
      this.setAttribute("position", new kt(f, 3)),
      this.setAttribute("normal", new kt(h, 3)),
      this.setAttribute("uv", new kt(m, 2));
    function x(S, _, w, T, E, A, R, k, P, U, N) {
      const L = A / P,
        H = R / U,
        G = A / 2,
        $ = R / 2,
        q = k / 2,
        Z = P + 1,
        X = U + 1;
      let re = 0,
        W = 0;
      const te = new se();
      for (let F = 0; F < X; F++) {
        const V = F * H - $;
        for (let ne = 0; ne < Z; ne++) {
          const ae = ne * L - G;
          (te[S] = ae * T),
            (te[_] = V * E),
            (te[w] = q),
            f.push(te.x, te.y, te.z),
            (te[S] = 0),
            (te[_] = 0),
            (te[w] = k > 0 ? 1 : -1),
            h.push(te.x, te.y, te.z),
            m.push(ne / P),
            m.push(1 - F / U),
            (re += 1);
        }
      }
      for (let F = 0; F < U; F++)
        for (let V = 0; V < P; V++) {
          const ne = g + V + Z * F,
            ae = g + V + Z * (F + 1),
            J = g + (V + 1) + Z * (F + 1),
            oe = g + (V + 1) + Z * F;
          u.push(ne, ae, oe), u.push(ae, J, oe), (W += 6);
        }
      l.addGroup(y, W, N), (y += W), (g += re);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Cf(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Th(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = i.clone())
        : Array.isArray(i)
        ? (e[t][r] = i.slice())
        : (e[t][r] = i);
    }
  }
  return e;
}
function mo(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = Th(n[t]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function kB(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function qA(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : yn.workingColorSpace;
}
const xw = { clone: Th, merge: mo };
var DB = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  NB = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ua extends Oi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = DB),
      (this.fragmentShader = NB),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Th(e.uniforms)),
      (this.uniformsGroups = kB(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const s = this.uniforms[i].value;
      s && s.isTexture
        ? (t.uniforms[i] = { type: "t", value: s.toJSON(e).uuid })
        : s && s.isColor
        ? (t.uniforms[i] = { type: "c", value: s.getHex() })
        : s && s.isVector2
        ? (t.uniforms[i] = { type: "v2", value: s.toArray() })
        : s && s.isVector3
        ? (t.uniforms[i] = { type: "v3", value: s.toArray() })
        : s && s.isVector4
        ? (t.uniforms[i] = { type: "v4", value: s.toArray() })
        : s && s.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: s.toArray() })
        : s && s.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: s.toArray() })
        : (t.uniforms[i] = { value: s });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class eg extends _n {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Wt()),
      (this.projectionMatrix = new Wt()),
      (this.projectionMatrixInverse = new Wt()),
      (this.coordinateSystem = za);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Iu = new se(),
  TE = new tt(),
  CE = new tt();
class Or extends eg {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Eh * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(hf * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Eh * 2 * Math.atan(Math.tan(hf * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, r) {
    Iu.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Iu.x, Iu.y).multiplyScalar(-e / Iu.z),
      Iu.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      r.set(Iu.x, Iu.y).multiplyScalar(-e / Iu.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, TE, CE), t.subVectors(CE, TE);
  }
  setViewOffset(e, t, r, i, o, s) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(hf * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      i = this.aspect * r,
      o = -0.5 * i;
    const s = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = s.fullWidth,
        f = s.fullHeight;
      (o += (s.offsetX * i) / u),
        (t -= (s.offsetY * r) / f),
        (i *= s.width / u),
        (r *= s.height / f);
    }
    const l = this.filmOffset;
    l !== 0 && (o += (e * l) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        o,
        o + i,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Wd = -90,
  jd = 1;
class KA extends _n {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Or(Wd, jd, e, t);
    (i.layers = this.layers), this.add(i);
    const o = new Or(Wd, jd, e, t);
    (o.layers = this.layers), this.add(o);
    const s = new Or(Wd, jd, e, t);
    (s.layers = this.layers), this.add(s);
    const l = new Or(Wd, jd, e, t);
    (l.layers = this.layers), this.add(l);
    const u = new Or(Wd, jd, e, t);
    (u.layers = this.layers), this.add(u);
    const f = new Or(Wd, jd, e, t);
    (f.layers = this.layers), this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, i, o, s, l, u] = t;
    for (const f of t) this.remove(f);
    if (e === za)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, -1, 0),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, -1);
    else if (e === Um)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, -1, 0),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, 1),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const f of t) this.add(f), f.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [o, s, l, u, f, h] = this.children,
      m = e.getRenderTarget(),
      g = e.getActiveCubeFace(),
      y = e.getActiveMipmapLevel(),
      x = e.xr.enabled;
    e.xr.enabled = !1;
    const S = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(t, o),
      e.setRenderTarget(r, 1, i),
      e.render(t, s),
      e.setRenderTarget(r, 2, i),
      e.render(t, l),
      e.setRenderTarget(r, 3, i),
      e.render(t, u),
      e.setRenderTarget(r, 4, i),
      e.render(t, f),
      (r.texture.generateMipmaps = S),
      e.setRenderTarget(r, 5, i),
      e.render(t, h),
      e.setRenderTarget(m, g, y),
      (e.xr.enabled = x),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class tg extends Qn {
  constructor(e, t, r, i, o, s, l, u, f, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Dl),
      super(e, t, r, i, o, s, l, u, f, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class ZA extends la {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    (this.texture = new tg(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Cr);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Cf(5, 5, 5),
      o = new ua({
        name: "CubemapFromEquirect",
        uniforms: Th(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: Qi,
        blending: Il,
      });
    o.uniforms.tEquirect.value = t;
    const s = new vr(i, o),
      l = t.minFilter;
    return (
      t.minFilter === Ba && (t.minFilter = Cr),
      new KA(1, 10, this).update(e, s),
      (t.minFilter = l),
      s.geometry.dispose(),
      s.material.dispose(),
      this
    );
  }
  clear(e, t, r, i) {
    const o = e.getRenderTarget();
    for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, r, i);
    e.setRenderTarget(o);
  }
}
const z_ = new se(),
  OB = new se(),
  UB = new tn();
class El {
  constructor(e = new se(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = z_.subVectors(r, t).cross(OB.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(z_),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(r, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || UB.getNormalMatrix(e),
      i = this.coplanarPoint(z_).applyMatrix4(e),
      o = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Nc = new Ni(),
  Tv = new se();
class ng {
  constructor(
    e = new El(),
    t = new El(),
    r = new El(),
    i = new El(),
    o = new El(),
    s = new El()
  ) {
    this.planes = [e, t, r, i, o, s];
  }
  set(e, t, r, i, o, s) {
    const l = this.planes;
    return (
      l[0].copy(e),
      l[1].copy(t),
      l[2].copy(r),
      l[3].copy(i),
      l[4].copy(o),
      l[5].copy(s),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = za) {
    const r = this.planes,
      i = e.elements,
      o = i[0],
      s = i[1],
      l = i[2],
      u = i[3],
      f = i[4],
      h = i[5],
      m = i[6],
      g = i[7],
      y = i[8],
      x = i[9],
      S = i[10],
      _ = i[11],
      w = i[12],
      T = i[13],
      E = i[14],
      A = i[15];
    if (
      (r[0].setComponents(u - o, g - f, _ - y, A - w).normalize(),
      r[1].setComponents(u + o, g + f, _ + y, A + w).normalize(),
      r[2].setComponents(u + s, g + h, _ + x, A + T).normalize(),
      r[3].setComponents(u - s, g - h, _ - x, A - T).normalize(),
      r[4].setComponents(u - l, g - m, _ - S, A - E).normalize(),
      t === za)
    )
      r[5].setComponents(u + l, g + m, _ + S, A + E).normalize();
    else if (t === Um) r[5].setComponents(l, m, S, E).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Nc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Nc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Nc);
  }
  intersectsSprite(e) {
    return (
      Nc.center.set(0, 0, 0),
      (Nc.radius = 0.7071067811865476),
      Nc.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Nc)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      i = -e.radius;
    for (let o = 0; o < 6; o++) if (t[o].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (
        ((Tv.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Tv.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Tv.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Tv) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function JA() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function i(o, s) {
    t(o, s), (r = n.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (o) {
      t = o;
    },
    setContext: function (o) {
      n = o;
    },
  };
}
function FB(n) {
  const e = new WeakMap();
  function t(l, u) {
    const f = l.array,
      h = l.usage,
      m = f.byteLength,
      g = n.createBuffer();
    n.bindBuffer(u, g), n.bufferData(u, f, h), l.onUploadCallback();
    let y;
    if (f instanceof Float32Array) y = n.FLOAT;
    else if (f instanceof Uint16Array)
      l.isFloat16BufferAttribute ? (y = n.HALF_FLOAT) : (y = n.UNSIGNED_SHORT);
    else if (f instanceof Int16Array) y = n.SHORT;
    else if (f instanceof Uint32Array) y = n.UNSIGNED_INT;
    else if (f instanceof Int32Array) y = n.INT;
    else if (f instanceof Int8Array) y = n.BYTE;
    else if (f instanceof Uint8Array) y = n.UNSIGNED_BYTE;
    else if (f instanceof Uint8ClampedArray) y = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + f
      );
    return {
      buffer: g,
      type: y,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: l.version,
      size: m,
    };
  }
  function r(l, u, f) {
    const h = u.array,
      m = u._updateRange,
      g = u.updateRanges;
    if (
      (n.bindBuffer(f, l),
      m.count === -1 && g.length === 0 && n.bufferSubData(f, 0, h),
      g.length !== 0)
    ) {
      for (let y = 0, x = g.length; y < x; y++) {
        const S = g[y];
        n.bufferSubData(f, S.start * h.BYTES_PER_ELEMENT, h, S.start, S.count);
      }
      u.clearUpdateRanges();
    }
    m.count !== -1 &&
      (n.bufferSubData(f, m.offset * h.BYTES_PER_ELEMENT, h, m.offset, m.count),
      (m.count = -1)),
      u.onUploadCallback();
  }
  function i(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = e.get(l);
    u && (n.deleteBuffer(u.buffer), e.delete(l));
  }
  function s(l, u) {
    if (
      (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute)
    ) {
      const h = e.get(l);
      (!h || h.version < l.version) &&
        e.set(l, {
          buffer: l.buffer,
          type: l.type,
          bytesPerElement: l.elementSize,
          version: l.version,
        });
      return;
    }
    const f = e.get(l);
    if (f === void 0) e.set(l, t(l, u));
    else if (f.version < l.version) {
      if (f.size !== l.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      r(f.buffer, l, u), (f.version = l.version);
    }
  }
  return { get: i, remove: o, update: s };
}
class Hl extends Jt {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: i,
      });
    const o = e / 2,
      s = t / 2,
      l = Math.floor(r),
      u = Math.floor(i),
      f = l + 1,
      h = u + 1,
      m = e / l,
      g = t / u,
      y = [],
      x = [],
      S = [],
      _ = [];
    for (let w = 0; w < h; w++) {
      const T = w * g - s;
      for (let E = 0; E < f; E++) {
        const A = E * m - o;
        x.push(A, -T, 0), S.push(0, 0, 1), _.push(E / l), _.push(1 - w / u);
      }
    }
    for (let w = 0; w < u; w++)
      for (let T = 0; T < l; T++) {
        const E = T + f * w,
          A = T + f * (w + 1),
          R = T + 1 + f * (w + 1),
          k = T + 1 + f * w;
        y.push(E, A, k), y.push(A, R, k);
      }
    this.setIndex(y),
      this.setAttribute("position", new kt(x, 3)),
      this.setAttribute("normal", new kt(S, 3)),
      this.setAttribute("uv", new kt(_, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Hl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var BB = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  zB = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  HB = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  VB = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  GB = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  WB = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  jB = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  $B = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  XB = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  YB = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  qB = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  KB = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  ZB = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  JB = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  QB = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  ez = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  tz = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  nz = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  rz = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  iz = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  oz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  sz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  az = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  lz = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  uz = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  cz = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  fz = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  dz = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  hz = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  pz = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  mz = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  gz = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  vz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  yz = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  xz = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  _z = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  Sz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  wz = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  bz = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  Mz = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  Ez = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  Tz = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  Cz = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Az = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  Rz = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  Pz = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Iz = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  Lz = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  kz = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  Dz = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  Nz = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Oz = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  Uz = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Fz = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Bz = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  zz = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  Hz = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Vz = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Gz = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Wz = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  jz = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  $z = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Xz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Yz = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  qz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Kz = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Zz = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  Jz = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Qz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  e5 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  t5 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  n5 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  r5 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  i5 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  o5 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  s5 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  a5 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  l5 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  u5 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  c5 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  f5 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  d5 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  h5 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  p5 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  m5 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  g5 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  v5 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  y5 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  x5 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  _5 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  S5 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  w5 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  b5 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  M5 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  E5 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  T5 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  C5 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  A5 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  R5 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  P5 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  I5 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  L5 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  k5 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  D5 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  N5 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  O5 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  U5 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const F5 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  B5 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  z5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  H5 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  V5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  G5 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  W5 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  j5 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  $5 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  X5 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  Y5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  q5 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  K5 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Z5 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  J5 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Q5 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  e6 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  t6 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  n6 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  r6 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  i6 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  o6 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  s6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  a6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  l6 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  u6 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  c6 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  f6 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  d6 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  h6 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  p6 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  m6 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  g6 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  v6 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  on = {
    alphahash_fragment: BB,
    alphahash_pars_fragment: zB,
    alphamap_fragment: HB,
    alphamap_pars_fragment: VB,
    alphatest_fragment: GB,
    alphatest_pars_fragment: WB,
    aomap_fragment: jB,
    aomap_pars_fragment: $B,
    batching_pars_vertex: XB,
    batching_vertex: YB,
    begin_vertex: qB,
    beginnormal_vertex: KB,
    bsdfs: ZB,
    iridescence_fragment: JB,
    bumpmap_pars_fragment: QB,
    clipping_planes_fragment: ez,
    clipping_planes_pars_fragment: tz,
    clipping_planes_pars_vertex: nz,
    clipping_planes_vertex: rz,
    color_fragment: iz,
    color_pars_fragment: oz,
    color_pars_vertex: sz,
    color_vertex: az,
    common: lz,
    cube_uv_reflection_fragment: uz,
    defaultnormal_vertex: cz,
    displacementmap_pars_vertex: fz,
    displacementmap_vertex: dz,
    emissivemap_fragment: hz,
    emissivemap_pars_fragment: pz,
    colorspace_fragment: mz,
    colorspace_pars_fragment: gz,
    envmap_fragment: vz,
    envmap_common_pars_fragment: yz,
    envmap_pars_fragment: xz,
    envmap_pars_vertex: _z,
    envmap_physical_pars_fragment: Iz,
    envmap_vertex: Sz,
    fog_vertex: wz,
    fog_pars_vertex: bz,
    fog_fragment: Mz,
    fog_pars_fragment: Ez,
    gradientmap_pars_fragment: Tz,
    lightmap_pars_fragment: Cz,
    lights_lambert_fragment: Az,
    lights_lambert_pars_fragment: Rz,
    lights_pars_begin: Pz,
    lights_toon_fragment: Lz,
    lights_toon_pars_fragment: kz,
    lights_phong_fragment: Dz,
    lights_phong_pars_fragment: Nz,
    lights_physical_fragment: Oz,
    lights_physical_pars_fragment: Uz,
    lights_fragment_begin: Fz,
    lights_fragment_maps: Bz,
    lights_fragment_end: zz,
    logdepthbuf_fragment: Hz,
    logdepthbuf_pars_fragment: Vz,
    logdepthbuf_pars_vertex: Gz,
    logdepthbuf_vertex: Wz,
    map_fragment: jz,
    map_pars_fragment: $z,
    map_particle_fragment: Xz,
    map_particle_pars_fragment: Yz,
    metalnessmap_fragment: qz,
    metalnessmap_pars_fragment: Kz,
    morphinstance_vertex: Zz,
    morphcolor_vertex: Jz,
    morphnormal_vertex: Qz,
    morphtarget_pars_vertex: e5,
    morphtarget_vertex: t5,
    normal_fragment_begin: n5,
    normal_fragment_maps: r5,
    normal_pars_fragment: i5,
    normal_pars_vertex: o5,
    normal_vertex: s5,
    normalmap_pars_fragment: a5,
    clearcoat_normal_fragment_begin: l5,
    clearcoat_normal_fragment_maps: u5,
    clearcoat_pars_fragment: c5,
    iridescence_pars_fragment: f5,
    opaque_fragment: d5,
    packing: h5,
    premultiplied_alpha_fragment: p5,
    project_vertex: m5,
    dithering_fragment: g5,
    dithering_pars_fragment: v5,
    roughnessmap_fragment: y5,
    roughnessmap_pars_fragment: x5,
    shadowmap_pars_fragment: _5,
    shadowmap_pars_vertex: S5,
    shadowmap_vertex: w5,
    shadowmask_pars_fragment: b5,
    skinbase_vertex: M5,
    skinning_pars_vertex: E5,
    skinning_vertex: T5,
    skinnormal_vertex: C5,
    specularmap_fragment: A5,
    specularmap_pars_fragment: R5,
    tonemapping_fragment: P5,
    tonemapping_pars_fragment: I5,
    transmission_fragment: L5,
    transmission_pars_fragment: k5,
    uv_pars_fragment: D5,
    uv_pars_vertex: N5,
    uv_vertex: O5,
    worldpos_vertex: U5,
    background_vert: F5,
    background_frag: B5,
    backgroundCube_vert: z5,
    backgroundCube_frag: H5,
    cube_vert: V5,
    cube_frag: G5,
    depth_vert: W5,
    depth_frag: j5,
    distanceRGBA_vert: $5,
    distanceRGBA_frag: X5,
    equirect_vert: Y5,
    equirect_frag: q5,
    linedashed_vert: K5,
    linedashed_frag: Z5,
    meshbasic_vert: J5,
    meshbasic_frag: Q5,
    meshlambert_vert: e6,
    meshlambert_frag: t6,
    meshmatcap_vert: n6,
    meshmatcap_frag: r6,
    meshnormal_vert: i6,
    meshnormal_frag: o6,
    meshphong_vert: s6,
    meshphong_frag: a6,
    meshphysical_vert: l6,
    meshphysical_frag: u6,
    meshtoon_vert: c6,
    meshtoon_frag: f6,
    points_vert: d6,
    points_frag: h6,
    shadow_vert: p6,
    shadow_frag: m6,
    sprite_vert: g6,
    sprite_frag: v6,
  },
  xt = {
    common: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new tn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new tn() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new tn() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new tn() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new tn() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new tn() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new tn() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new tn() },
      normalScale: { value: new tt(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new tn() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new tn() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new tn() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new tn() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new St(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new tn() },
      alphaTest: { value: 0 },
      uvTransform: { value: new tn() },
    },
    sprite: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      center: { value: new tt(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new tn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new tn() },
      alphaTest: { value: 0 },
    },
  },
  ia = {
    basic: {
      uniforms: mo([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.fog,
      ]),
      vertexShader: on.meshbasic_vert,
      fragmentShader: on.meshbasic_frag,
    },
    lambert: {
      uniforms: mo([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new St(0) } },
      ]),
      vertexShader: on.meshlambert_vert,
      fragmentShader: on.meshlambert_frag,
    },
    phong: {
      uniforms: mo([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new St(0) },
          specular: { value: new St(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: on.meshphong_vert,
      fragmentShader: on.meshphong_frag,
    },
    standard: {
      uniforms: mo([
        xt.common,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.roughnessmap,
        xt.metalnessmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new St(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: on.meshphysical_vert,
      fragmentShader: on.meshphysical_frag,
    },
    toon: {
      uniforms: mo([
        xt.common,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.gradientmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new St(0) } },
      ]),
      vertexShader: on.meshtoon_vert,
      fragmentShader: on.meshtoon_frag,
    },
    matcap: {
      uniforms: mo([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: on.meshmatcap_vert,
      fragmentShader: on.meshmatcap_frag,
    },
    points: {
      uniforms: mo([xt.points, xt.fog]),
      vertexShader: on.points_vert,
      fragmentShader: on.points_frag,
    },
    dashed: {
      uniforms: mo([
        xt.common,
        xt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: on.linedashed_vert,
      fragmentShader: on.linedashed_frag,
    },
    depth: {
      uniforms: mo([xt.common, xt.displacementmap]),
      vertexShader: on.depth_vert,
      fragmentShader: on.depth_frag,
    },
    normal: {
      uniforms: mo([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: on.meshnormal_vert,
      fragmentShader: on.meshnormal_frag,
    },
    sprite: {
      uniforms: mo([xt.sprite, xt.fog]),
      vertexShader: on.sprite_vert,
      fragmentShader: on.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new tn() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: on.background_vert,
      fragmentShader: on.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new tn() },
      },
      vertexShader: on.backgroundCube_vert,
      fragmentShader: on.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: on.cube_vert,
      fragmentShader: on.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: on.equirect_vert,
      fragmentShader: on.equirect_frag,
    },
    distanceRGBA: {
      uniforms: mo([
        xt.common,
        xt.displacementmap,
        {
          referencePosition: { value: new se() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: on.distanceRGBA_vert,
      fragmentShader: on.distanceRGBA_frag,
    },
    shadow: {
      uniforms: mo([
        xt.lights,
        xt.fog,
        { color: { value: new St(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: on.shadow_vert,
      fragmentShader: on.shadow_frag,
    },
  };
ia.physical = {
  uniforms: mo([
    ia.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new tn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new tn() },
      clearcoatNormalScale: { value: new tt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new tn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new tn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new tn() },
      sheen: { value: 0 },
      sheenColor: { value: new St(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new tn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new tn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new tn() },
      transmissionSamplerSize: { value: new tt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new tn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new St(0) },
      specularColor: { value: new St(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new tn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new tn() },
      anisotropyVector: { value: new tt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new tn() },
    },
  ]),
  vertexShader: on.meshphysical_vert,
  fragmentShader: on.meshphysical_frag,
};
const Cv = { r: 0, b: 0, g: 0 },
  Oc = new as(),
  y6 = new Wt();
function x6(n, e, t, r, i, o, s) {
  const l = new St(0);
  let u = o === !0 ? 0 : 1,
    f,
    h,
    m = null,
    g = 0,
    y = null;
  function x(T) {
    let E = T.isScene === !0 ? T.background : null;
    return (
      E && E.isTexture && (E = (T.backgroundBlurriness > 0 ? t : e).get(E)), E
    );
  }
  function S(T) {
    let E = !1;
    const A = x(T);
    A === null ? w(l, u) : A && A.isColor && (w(A, 1), (E = !0));
    const R = n.xr.getEnvironmentBlendMode();
    R === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, s)
      : R === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, s),
      (n.autoClear || E) &&
        (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  function _(T, E) {
    const A = x(E);
    A && (A.isCubeTexture || A.mapping === Nh)
      ? (h === void 0 &&
          ((h = new vr(
            new Cf(1, 1, 1),
            new ua({
              name: "BackgroundCubeMaterial",
              uniforms: Th(ia.backgroundCube.uniforms),
              vertexShader: ia.backgroundCube.vertexShader,
              fragmentShader: ia.backgroundCube.fragmentShader,
              side: Qi,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          h.geometry.deleteAttribute("normal"),
          h.geometry.deleteAttribute("uv"),
          (h.onBeforeRender = function (R, k, P) {
            this.matrixWorld.copyPosition(P.matrixWorld);
          }),
          Object.defineProperty(h.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(h)),
        Oc.copy(E.backgroundRotation),
        (Oc.x *= -1),
        (Oc.y *= -1),
        (Oc.z *= -1),
        A.isCubeTexture &&
          A.isRenderTargetTexture === !1 &&
          ((Oc.y *= -1), (Oc.z *= -1)),
        (h.material.uniforms.envMap.value = A),
        (h.material.uniforms.flipEnvMap.value =
          A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1),
        (h.material.uniforms.backgroundBlurriness.value =
          E.backgroundBlurriness),
        (h.material.uniforms.backgroundIntensity.value = E.backgroundIntensity),
        h.material.uniforms.backgroundRotation.value.setFromMatrix4(
          y6.makeRotationFromEuler(Oc)
        ),
        (h.material.toneMapped = yn.getTransfer(A.colorSpace) !== Zn),
        (m !== A || g !== A.version || y !== n.toneMapping) &&
          ((h.material.needsUpdate = !0),
          (m = A),
          (g = A.version),
          (y = n.toneMapping)),
        h.layers.enableAll(),
        T.unshift(h, h.geometry, h.material, 0, 0, null))
      : A &&
        A.isTexture &&
        (f === void 0 &&
          ((f = new vr(
            new Hl(2, 2),
            new ua({
              name: "BackgroundMaterial",
              uniforms: Th(ia.background.uniforms),
              vertexShader: ia.background.vertexShader,
              fragmentShader: ia.background.fragmentShader,
              side: Xa,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          f.geometry.deleteAttribute("normal"),
          Object.defineProperty(f.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(f)),
        (f.material.uniforms.t2D.value = A),
        (f.material.uniforms.backgroundIntensity.value = E.backgroundIntensity),
        (f.material.toneMapped = yn.getTransfer(A.colorSpace) !== Zn),
        A.matrixAutoUpdate === !0 && A.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(A.matrix),
        (m !== A || g !== A.version || y !== n.toneMapping) &&
          ((f.material.needsUpdate = !0),
          (m = A),
          (g = A.version),
          (y = n.toneMapping)),
        f.layers.enableAll(),
        T.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function w(T, E) {
    T.getRGB(Cv, qA(n)), r.buffers.color.setClear(Cv.r, Cv.g, Cv.b, E, s);
  }
  return {
    getClearColor: function () {
      return l;
    },
    setClearColor: function (T, E = 1) {
      l.set(T), (u = E), w(l, u);
    },
    getClearAlpha: function () {
      return u;
    },
    setClearAlpha: function (T) {
      (u = T), w(l, u);
    },
    render: S,
    addToRenderList: _,
  };
}
function _6(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    r = {},
    i = g(null);
  let o = i,
    s = !1;
  function l(L, H, G, $, q) {
    let Z = !1;
    const X = m($, G, H);
    o !== X && ((o = X), f(o.object)),
      (Z = y(L, $, G, q)),
      Z && x(L, $, G, q),
      q !== null && e.update(q, n.ELEMENT_ARRAY_BUFFER),
      (Z || s) &&
        ((s = !1),
        A(L, H, G, $),
        q !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(q).buffer));
  }
  function u() {
    return n.createVertexArray();
  }
  function f(L) {
    return n.bindVertexArray(L);
  }
  function h(L) {
    return n.deleteVertexArray(L);
  }
  function m(L, H, G) {
    const $ = G.wireframe === !0;
    let q = r[L.id];
    q === void 0 && ((q = {}), (r[L.id] = q));
    let Z = q[H.id];
    Z === void 0 && ((Z = {}), (q[H.id] = Z));
    let X = Z[$];
    return X === void 0 && ((X = g(u())), (Z[$] = X)), X;
  }
  function g(L) {
    const H = [],
      G = [],
      $ = [];
    for (let q = 0; q < t; q++) (H[q] = 0), (G[q] = 0), ($[q] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: H,
      enabledAttributes: G,
      attributeDivisors: $,
      object: L,
      attributes: {},
      index: null,
    };
  }
  function y(L, H, G, $) {
    const q = o.attributes,
      Z = H.attributes;
    let X = 0;
    const re = G.getAttributes();
    for (const W in re)
      if (re[W].location >= 0) {
        const F = q[W];
        let V = Z[W];
        if (
          (V === void 0 &&
            (W === "instanceMatrix" &&
              L.instanceMatrix &&
              (V = L.instanceMatrix),
            W === "instanceColor" && L.instanceColor && (V = L.instanceColor)),
          F === void 0 || F.attribute !== V || (V && F.data !== V.data))
        )
          return !0;
        X++;
      }
    return o.attributesNum !== X || o.index !== $;
  }
  function x(L, H, G, $) {
    const q = {},
      Z = H.attributes;
    let X = 0;
    const re = G.getAttributes();
    for (const W in re)
      if (re[W].location >= 0) {
        let F = Z[W];
        F === void 0 &&
          (W === "instanceMatrix" && L.instanceMatrix && (F = L.instanceMatrix),
          W === "instanceColor" && L.instanceColor && (F = L.instanceColor));
        const V = {};
        (V.attribute = F), F && F.data && (V.data = F.data), (q[W] = V), X++;
      }
    (o.attributes = q), (o.attributesNum = X), (o.index = $);
  }
  function S() {
    const L = o.newAttributes;
    for (let H = 0, G = L.length; H < G; H++) L[H] = 0;
  }
  function _(L) {
    w(L, 0);
  }
  function w(L, H) {
    const G = o.newAttributes,
      $ = o.enabledAttributes,
      q = o.attributeDivisors;
    (G[L] = 1),
      $[L] === 0 && (n.enableVertexAttribArray(L), ($[L] = 1)),
      q[L] !== H && (n.vertexAttribDivisor(L, H), (q[L] = H));
  }
  function T() {
    const L = o.newAttributes,
      H = o.enabledAttributes;
    for (let G = 0, $ = H.length; G < $; G++)
      H[G] !== L[G] && (n.disableVertexAttribArray(G), (H[G] = 0));
  }
  function E(L, H, G, $, q, Z, X) {
    X === !0
      ? n.vertexAttribIPointer(L, H, G, q, Z)
      : n.vertexAttribPointer(L, H, G, $, q, Z);
  }
  function A(L, H, G, $) {
    S();
    const q = $.attributes,
      Z = G.getAttributes(),
      X = H.defaultAttributeValues;
    for (const re in Z) {
      const W = Z[re];
      if (W.location >= 0) {
        let te = q[re];
        if (
          (te === void 0 &&
            (re === "instanceMatrix" &&
              L.instanceMatrix &&
              (te = L.instanceMatrix),
            re === "instanceColor" &&
              L.instanceColor &&
              (te = L.instanceColor)),
          te !== void 0)
        ) {
          const F = te.normalized,
            V = te.itemSize,
            ne = e.get(te);
          if (ne === void 0) continue;
          const ae = ne.buffer,
            J = ne.type,
            oe = ne.bytesPerElement,
            de = J === n.INT || J === n.UNSIGNED_INT || te.gpuType === ky;
          if (te.isInterleavedBufferAttribute) {
            const le = te.data,
              fe = le.stride,
              Ee = te.offset;
            if (le.isInstancedInterleavedBuffer) {
              for (let ge = 0; ge < W.locationSize; ge++)
                w(W.location + ge, le.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = le.meshPerAttribute * le.count);
            } else
              for (let ge = 0; ge < W.locationSize; ge++) _(W.location + ge);
            n.bindBuffer(n.ARRAY_BUFFER, ae);
            for (let ge = 0; ge < W.locationSize; ge++)
              E(
                W.location + ge,
                V / W.locationSize,
                J,
                F,
                fe * oe,
                (Ee + (V / W.locationSize) * ge) * oe,
                de
              );
          } else {
            if (te.isInstancedBufferAttribute) {
              for (let le = 0; le < W.locationSize; le++)
                w(W.location + le, te.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = te.meshPerAttribute * te.count);
            } else
              for (let le = 0; le < W.locationSize; le++) _(W.location + le);
            n.bindBuffer(n.ARRAY_BUFFER, ae);
            for (let le = 0; le < W.locationSize; le++)
              E(
                W.location + le,
                V / W.locationSize,
                J,
                F,
                V * oe,
                (V / W.locationSize) * le * oe,
                de
              );
          }
        } else if (X !== void 0) {
          const F = X[re];
          if (F !== void 0)
            switch (F.length) {
              case 2:
                n.vertexAttrib2fv(W.location, F);
                break;
              case 3:
                n.vertexAttrib3fv(W.location, F);
                break;
              case 4:
                n.vertexAttrib4fv(W.location, F);
                break;
              default:
                n.vertexAttrib1fv(W.location, F);
            }
        }
      }
    }
    T();
  }
  function R() {
    U();
    for (const L in r) {
      const H = r[L];
      for (const G in H) {
        const $ = H[G];
        for (const q in $) h($[q].object), delete $[q];
        delete H[G];
      }
      delete r[L];
    }
  }
  function k(L) {
    if (r[L.id] === void 0) return;
    const H = r[L.id];
    for (const G in H) {
      const $ = H[G];
      for (const q in $) h($[q].object), delete $[q];
      delete H[G];
    }
    delete r[L.id];
  }
  function P(L) {
    for (const H in r) {
      const G = r[H];
      if (G[L.id] === void 0) continue;
      const $ = G[L.id];
      for (const q in $) h($[q].object), delete $[q];
      delete G[L.id];
    }
  }
  function U() {
    N(), (s = !0), o !== i && ((o = i), f(o.object));
  }
  function N() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: l,
    reset: U,
    resetDefaultState: N,
    dispose: R,
    releaseStatesOfGeometry: k,
    releaseStatesOfProgram: P,
    initAttributes: S,
    enableAttribute: _,
    disableUnusedAttributes: T,
  };
}
function S6(n, e, t) {
  let r;
  function i(f) {
    r = f;
  }
  function o(f, h) {
    n.drawArrays(r, f, h), t.update(h, r, 1);
  }
  function s(f, h, m) {
    m !== 0 && (n.drawArraysInstanced(r, f, h, m), t.update(h, r, m));
  }
  function l(f, h, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, f, 0, h, 0, m);
    let y = 0;
    for (let x = 0; x < m; x++) y += h[x];
    t.update(y, r, 1);
  }
  function u(f, h, m, g) {
    if (m === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null) for (let x = 0; x < f.length; x++) s(f[x], h[x], g[x]);
    else {
      y.multiDrawArraysInstancedWEBGL(r, f, 0, h, 0, g, 0, m);
      let x = 0;
      for (let S = 0; S < m; S++) x += h[S];
      for (let S = 0; S < g.length; S++) t.update(x, r, g[S]);
    }
  }
  (this.setMode = i),
    (this.render = o),
    (this.renderInstances = s),
    (this.renderMultiDraw = l),
    (this.renderMultiDrawInstances = u);
}
function w6(n, e, t, r) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const k = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(k) {
    return !(
      k !== Ji &&
      r.convert(k) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function l(k) {
    const P =
      k === Oh &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      k !== aa &&
      r.convert(k) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      k !== Oo &&
      !P
    );
  }
  function u(k) {
    if (k === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      k = "mediump";
    }
    return k === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let f = t.precision !== void 0 ? t.precision : "highp";
  const h = u(f);
  h !== f &&
    (console.warn(
      "THREE.WebGLRenderer:",
      f,
      "not supported, using",
      h,
      "instead."
    ),
    (f = h));
  const m = t.logarithmicDepthBuffer === !0,
    g = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    y = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    x = n.getParameter(n.MAX_TEXTURE_SIZE),
    S = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    _ = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    w = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    T = n.getParameter(n.MAX_VARYING_VECTORS),
    E = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    A = y > 0,
    R = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: o,
    getMaxPrecision: u,
    textureFormatReadable: s,
    textureTypeReadable: l,
    precision: f,
    logarithmicDepthBuffer: m,
    maxTextures: g,
    maxVertexTextures: y,
    maxTextureSize: x,
    maxCubemapSize: S,
    maxAttributes: _,
    maxVertexUniforms: w,
    maxVaryings: T,
    maxFragmentUniforms: E,
    vertexTextures: A,
    maxSamples: R,
  };
}
function b6(n) {
  const e = this;
  let t = null,
    r = 0,
    i = !1,
    o = !1;
  const s = new El(),
    l = new tn(),
    u = { value: null, needsUpdate: !1 };
  (this.uniform = u),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (m, g) {
      const y = m.length !== 0 || g || r !== 0 || i;
      return (i = g), (r = m.length), y;
    }),
    (this.beginShadows = function () {
      (o = !0), h(null);
    }),
    (this.endShadows = function () {
      o = !1;
    }),
    (this.setGlobalState = function (m, g) {
      t = h(m, g, 0);
    }),
    (this.setState = function (m, g, y) {
      const x = m.clippingPlanes,
        S = m.clipIntersection,
        _ = m.clipShadows,
        w = n.get(m);
      if (!i || x === null || x.length === 0 || (o && !_)) o ? h(null) : f();
      else {
        const T = o ? 0 : r,
          E = T * 4;
        let A = w.clippingState || null;
        (u.value = A), (A = h(x, g, E, y));
        for (let R = 0; R !== E; ++R) A[R] = t[R];
        (w.clippingState = A),
          (this.numIntersection = S ? this.numPlanes : 0),
          (this.numPlanes += T);
      }
    });
  function f() {
    u.value !== t && ((u.value = t), (u.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function h(m, g, y, x) {
    const S = m !== null ? m.length : 0;
    let _ = null;
    if (S !== 0) {
      if (((_ = u.value), x !== !0 || _ === null)) {
        const w = y + S * 4,
          T = g.matrixWorldInverse;
        l.getNormalMatrix(T),
          (_ === null || _.length < w) && (_ = new Float32Array(w));
        for (let E = 0, A = y; E !== S; ++E, A += 4)
          s.copy(m[E]).applyMatrix4(T, l),
            s.normal.toArray(_, A),
            (_[A + 3] = s.constant);
      }
      (u.value = _), (u.needsUpdate = !0);
    }
    return (e.numPlanes = S), (e.numIntersection = 0), _;
  }
}
function M6(n) {
  let e = new WeakMap();
  function t(s, l) {
    return l === Cm ? (s.mapping = Dl) : l === Am && (s.mapping = Wu), s;
  }
  function r(s) {
    if (s && s.isTexture) {
      const l = s.mapping;
      if (l === Cm || l === Am)
        if (e.has(s)) {
          const u = e.get(s).texture;
          return t(u, s.mapping);
        } else {
          const u = s.image;
          if (u && u.height > 0) {
            const f = new ZA(u.height);
            return (
              f.fromEquirectangularTexture(n, s),
              e.set(s, f),
              s.addEventListener("dispose", i),
              t(f.texture, s.mapping)
            );
          } else return null;
        }
    }
    return s;
  }
  function i(s) {
    const l = s.target;
    l.removeEventListener("dispose", i);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: r, dispose: o };
}
class zu extends eg {
  constructor(e = -1, t = 1, r = 1, i = -1, o = 0.1, s = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = i),
      (this.near = o),
      (this.far = s),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, i, o, s) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let o = r - e,
      s = r + e,
      l = i + t,
      u = i - t;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += f * this.view.offsetX),
        (s = o + f * this.view.width),
        (l -= h * this.view.offsetY),
        (u = l - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      o,
      s,
      l,
      u,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const uh = 4,
  AE = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  nf = 20,
  H_ = new zu(),
  RE = new St();
let V_ = null,
  G_ = 0,
  W_ = 0,
  j_ = !1;
const Qc = (1 + Math.sqrt(5)) / 2,
  $d = 1 / Qc,
  PE = [
    new se(-Qc, $d, 0),
    new se(Qc, $d, 0),
    new se(-$d, 0, Qc),
    new se($d, 0, Qc),
    new se(0, Qc, -$d),
    new se(0, Qc, $d),
    new se(-1, 1, -1),
    new se(1, 1, -1),
    new se(-1, 1, 1),
    new se(1, 1, 1),
  ];
class eS {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    (V_ = this._renderer.getRenderTarget()),
      (G_ = this._renderer.getActiveCubeFace()),
      (W_ = this._renderer.getActiveMipmapLevel()),
      (j_ = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const o = this._allocateTargets();
    return (
      (o.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, o),
      t > 0 && this._blur(o, 0, 0, t),
      this._applyPMREM(o),
      this._cleanup(o),
      o
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = kE()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = LE()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(V_, G_, W_),
      (this._renderer.xr.enabled = j_),
      (e.scissorTest = !1),
      Av(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Dl || e.mapping === Wu
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (V_ = this._renderer.getRenderTarget()),
      (G_ = this._renderer.getActiveCubeFace()),
      (W_ = this._renderer.getActiveMipmapLevel()),
      (j_ = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: Cr,
        minFilter: Cr,
        generateMipmaps: !1,
        type: Oh,
        format: Ji,
        colorSpace: Fl,
        depthBuffer: !1,
      },
      i = IE(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = IE(e, t, r));
      const { _lodMax: o } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = E6(o)),
        (this._blurMaterial = T6(o, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new vr(this._lodPlanes[0], e);
    this._renderer.compile(t, H_);
  }
  _sceneToCubeUV(e, t, r, i) {
    const l = new Or(90, 1, t, r),
      u = [1, -1, 1, 1, 1, 1],
      f = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      m = h.autoClear,
      g = h.toneMapping;
    h.getClearColor(RE), (h.toneMapping = Ga), (h.autoClear = !1);
    const y = new zl({
        name: "PMREM.Background",
        side: Qi,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new vr(new Cf(), y);
    let S = !1;
    const _ = e.background;
    _
      ? _.isColor && (y.color.copy(_), (e.background = null), (S = !0))
      : (y.color.copy(RE), (S = !0));
    for (let w = 0; w < 6; w++) {
      const T = w % 3;
      T === 0
        ? (l.up.set(0, u[w], 0), l.lookAt(f[w], 0, 0))
        : T === 1
        ? (l.up.set(0, 0, u[w]), l.lookAt(0, f[w], 0))
        : (l.up.set(0, u[w], 0), l.lookAt(0, 0, f[w]));
      const E = this._cubeSize;
      Av(i, T * E, w > 2 ? E : 0, E, E),
        h.setRenderTarget(i),
        S && h.render(x, l),
        h.render(e, l);
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (h.toneMapping = g),
      (h.autoClear = m),
      (e.background = _);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      i = e.mapping === Dl || e.mapping === Wu;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = kE()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = LE());
    const o = i ? this._cubemapMaterial : this._equirectMaterial,
      s = new vr(this._lodPlanes[0], o),
      l = o.uniforms;
    l.envMap.value = e;
    const u = this._cubeSize;
    Av(t, 0, 0, 3 * u, 2 * u), r.setRenderTarget(t), r.render(s, H_);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const s = Math.sqrt(
          this._sigmas[o] * this._sigmas[o] -
            this._sigmas[o - 1] * this._sigmas[o - 1]
        ),
        l = PE[(i - o - 1) % PE.length];
      this._blur(e, o - 1, o, s, l);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, o) {
    const s = this._pingPongRenderTarget;
    this._halfBlur(e, s, t, r, i, "latitudinal", o),
      this._halfBlur(s, e, r, r, i, "longitudinal", o);
  }
  _halfBlur(e, t, r, i, o, s, l) {
    const u = this._renderer,
      f = this._blurMaterial;
    s !== "latitudinal" &&
      s !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      m = new vr(this._lodPlanes[i], f),
      g = f.uniforms,
      y = this._sizeLods[r] - 1,
      x = isFinite(o) ? Math.PI / (2 * y) : (2 * Math.PI) / (2 * nf - 1),
      S = o / x,
      _ = isFinite(o) ? 1 + Math.floor(h * S) : nf;
    _ > nf &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${nf}`
      );
    const w = [];
    let T = 0;
    for (let P = 0; P < nf; ++P) {
      const U = P / S,
        N = Math.exp((-U * U) / 2);
      w.push(N), P === 0 ? (T += N) : P < _ && (T += 2 * N);
    }
    for (let P = 0; P < w.length; P++) w[P] = w[P] / T;
    (g.envMap.value = e.texture),
      (g.samples.value = _),
      (g.weights.value = w),
      (g.latitudinal.value = s === "latitudinal"),
      l && (g.poleAxis.value = l);
    const { _lodMax: E } = this;
    (g.dTheta.value = x), (g.mipInt.value = E - r);
    const A = this._sizeLods[i],
      R = 3 * A * (i > E - uh ? i - E + uh : 0),
      k = 4 * (this._cubeSize - A);
    Av(t, R, k, 3 * A, 2 * A), u.setRenderTarget(t), u.render(m, H_);
  }
}
function E6(n) {
  const e = [],
    t = [],
    r = [];
  let i = n;
  const o = n - uh + 1 + AE.length;
  for (let s = 0; s < o; s++) {
    const l = Math.pow(2, i);
    t.push(l);
    let u = 1 / l;
    s > n - uh ? (u = AE[s - n + uh - 1]) : s === 0 && (u = 0), r.push(u);
    const f = 1 / (l - 2),
      h = -f,
      m = 1 + f,
      g = [h, h, m, h, m, m, h, h, m, m, h, m],
      y = 6,
      x = 6,
      S = 3,
      _ = 2,
      w = 1,
      T = new Float32Array(S * x * y),
      E = new Float32Array(_ * x * y),
      A = new Float32Array(w * x * y);
    for (let k = 0; k < y; k++) {
      const P = ((k % 3) * 2) / 3 - 1,
        U = k > 2 ? 0 : -1,
        N = [
          P,
          U,
          0,
          P + 2 / 3,
          U,
          0,
          P + 2 / 3,
          U + 1,
          0,
          P,
          U,
          0,
          P + 2 / 3,
          U + 1,
          0,
          P,
          U + 1,
          0,
        ];
      T.set(N, S * x * k), E.set(g, _ * x * k);
      const L = [k, k, k, k, k, k];
      A.set(L, w * x * k);
    }
    const R = new Jt();
    R.setAttribute("position", new Gn(T, S)),
      R.setAttribute("uv", new Gn(E, _)),
      R.setAttribute("faceIndex", new Gn(A, w)),
      e.push(R),
      i > uh && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function IE(n, e, t) {
  const r = new la(n, e, t);
  return (
    (r.texture.mapping = Nh),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function Av(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function T6(n, e, t) {
  const r = new Float32Array(nf),
    i = new se(0, 1, 0);
  return new ua({
    name: "SphericalGaussianBlur",
    defines: {
      n: nf,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: _w(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Il,
    depthTest: !1,
    depthWrite: !1,
  });
}
function LE() {
  return new ua({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: _w(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Il,
    depthTest: !1,
    depthWrite: !1,
  });
}
function kE() {
  return new ua({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: _w(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Il,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _w() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function C6(n) {
  let e = new WeakMap(),
    t = null;
  function r(l) {
    if (l && l.isTexture) {
      const u = l.mapping,
        f = u === Cm || u === Am,
        h = u === Dl || u === Wu;
      if (f || h) {
        let m = e.get(l);
        const g = m !== void 0 ? m.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== g)
          return (
            t === null && (t = new eS(n)),
            (m = f ? t.fromEquirectangular(l, m) : t.fromCubemap(l, m)),
            (m.texture.pmremVersion = l.pmremVersion),
            e.set(l, m),
            m.texture
          );
        if (m !== void 0) return m.texture;
        {
          const y = l.image;
          return (f && y && y.height > 0) || (h && y && i(y))
            ? (t === null && (t = new eS(n)),
              (m = f ? t.fromEquirectangular(l) : t.fromCubemap(l)),
              (m.texture.pmremVersion = l.pmremVersion),
              e.set(l, m),
              l.addEventListener("dispose", o),
              m.texture)
            : null;
        }
      }
    }
    return l;
  }
  function i(l) {
    let u = 0;
    const f = 6;
    for (let h = 0; h < f; h++) l[h] !== void 0 && u++;
    return u === f;
  }
  function o(l) {
    const u = l.target;
    u.removeEventListener("dispose", o);
    const f = e.get(u);
    f !== void 0 && (e.delete(u), f.dispose());
  }
  function s() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: s };
}
function A6(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (r) {
      const i = t(r);
      return (
        i === null &&
          vh("THREE.WebGLRenderer: " + r + " extension not supported."),
        i
      );
    },
  };
}
function R6(n, e, t, r) {
  const i = {},
    o = new WeakMap();
  function s(m) {
    const g = m.target;
    g.index !== null && e.remove(g.index);
    for (const x in g.attributes) e.remove(g.attributes[x]);
    for (const x in g.morphAttributes) {
      const S = g.morphAttributes[x];
      for (let _ = 0, w = S.length; _ < w; _++) e.remove(S[_]);
    }
    g.removeEventListener("dispose", s), delete i[g.id];
    const y = o.get(g);
    y && (e.remove(y), o.delete(g)),
      r.releaseStatesOfGeometry(g),
      g.isInstancedBufferGeometry === !0 && delete g._maxInstanceCount,
      t.memory.geometries--;
  }
  function l(m, g) {
    return (
      i[g.id] === !0 ||
        (g.addEventListener("dispose", s),
        (i[g.id] = !0),
        t.memory.geometries++),
      g
    );
  }
  function u(m) {
    const g = m.attributes;
    for (const x in g) e.update(g[x], n.ARRAY_BUFFER);
    const y = m.morphAttributes;
    for (const x in y) {
      const S = y[x];
      for (let _ = 0, w = S.length; _ < w; _++) e.update(S[_], n.ARRAY_BUFFER);
    }
  }
  function f(m) {
    const g = [],
      y = m.index,
      x = m.attributes.position;
    let S = 0;
    if (y !== null) {
      const T = y.array;
      S = y.version;
      for (let E = 0, A = T.length; E < A; E += 3) {
        const R = T[E + 0],
          k = T[E + 1],
          P = T[E + 2];
        g.push(R, k, k, P, P, R);
      }
    } else if (x !== void 0) {
      const T = x.array;
      S = x.version;
      for (let E = 0, A = T.length / 3 - 1; E < A; E += 3) {
        const R = E + 0,
          k = E + 1,
          P = E + 2;
        g.push(R, k, k, P, P, R);
      }
    } else return;
    const _ = new (WA(g) ? yw : vw)(g, 1);
    _.version = S;
    const w = o.get(m);
    w && e.remove(w), o.set(m, _);
  }
  function h(m) {
    const g = o.get(m);
    if (g) {
      const y = m.index;
      y !== null && g.version < y.version && f(m);
    } else f(m);
    return o.get(m);
  }
  return { get: l, update: u, getWireframeAttribute: h };
}
function P6(n, e, t) {
  let r;
  function i(g) {
    r = g;
  }
  let o, s;
  function l(g) {
    (o = g.type), (s = g.bytesPerElement);
  }
  function u(g, y) {
    n.drawElements(r, y, o, g * s), t.update(y, r, 1);
  }
  function f(g, y, x) {
    x !== 0 && (n.drawElementsInstanced(r, y, o, g * s, x), t.update(y, r, x));
  }
  function h(g, y, x) {
    if (x === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, y, 0, o, g, 0, x);
    let _ = 0;
    for (let w = 0; w < x; w++) _ += y[w];
    t.update(_, r, 1);
  }
  function m(g, y, x, S) {
    if (x === 0) return;
    const _ = e.get("WEBGL_multi_draw");
    if (_ === null) for (let w = 0; w < g.length; w++) f(g[w] / s, y[w], S[w]);
    else {
      _.multiDrawElementsInstancedWEBGL(r, y, 0, o, g, 0, S, 0, x);
      let w = 0;
      for (let T = 0; T < x; T++) w += y[T];
      for (let T = 0; T < S.length; T++) t.update(w, r, S[T]);
    }
  }
  (this.setMode = i),
    (this.setIndex = l),
    (this.render = u),
    (this.renderInstances = f),
    (this.renderMultiDraw = h),
    (this.renderMultiDrawInstances = m);
}
function I6(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(o, s, l) {
    switch ((t.calls++, s)) {
      case n.TRIANGLES:
        t.triangles += l * (o / 3);
        break;
      case n.LINES:
        t.lines += l * (o / 2);
        break;
      case n.LINE_STRIP:
        t.lines += l * (o - 1);
        break;
      case n.LINE_LOOP:
        t.lines += l * o;
        break;
      case n.POINTS:
        t.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function L6(n, e, t) {
  const r = new WeakMap(),
    i = new Tn();
  function o(s, l, u) {
    const f = s.morphTargetInfluences,
      h =
        l.morphAttributes.position ||
        l.morphAttributes.normal ||
        l.morphAttributes.color,
      m = h !== void 0 ? h.length : 0;
    let g = r.get(l);
    if (g === void 0 || g.count !== m) {
      let L = function () {
        U.dispose(), r.delete(l), l.removeEventListener("dispose", L);
      };
      var y = L;
      g !== void 0 && g.texture.dispose();
      const x = l.morphAttributes.position !== void 0,
        S = l.morphAttributes.normal !== void 0,
        _ = l.morphAttributes.color !== void 0,
        w = l.morphAttributes.position || [],
        T = l.morphAttributes.normal || [],
        E = l.morphAttributes.color || [];
      let A = 0;
      x === !0 && (A = 1), S === !0 && (A = 2), _ === !0 && (A = 3);
      let R = l.attributes.position.count * A,
        k = 1;
      R > e.maxTextureSize &&
        ((k = Math.ceil(R / e.maxTextureSize)), (R = e.maxTextureSize));
      const P = new Float32Array(R * k * 4 * m),
        U = new Hy(P, R, k, m);
      (U.type = Oo), (U.needsUpdate = !0);
      const N = A * 4;
      for (let H = 0; H < m; H++) {
        const G = w[H],
          $ = T[H],
          q = E[H],
          Z = R * k * 4 * H;
        for (let X = 0; X < G.count; X++) {
          const re = X * N;
          x === !0 &&
            (i.fromBufferAttribute(G, X),
            (P[Z + re + 0] = i.x),
            (P[Z + re + 1] = i.y),
            (P[Z + re + 2] = i.z),
            (P[Z + re + 3] = 0)),
            S === !0 &&
              (i.fromBufferAttribute($, X),
              (P[Z + re + 4] = i.x),
              (P[Z + re + 5] = i.y),
              (P[Z + re + 6] = i.z),
              (P[Z + re + 7] = 0)),
            _ === !0 &&
              (i.fromBufferAttribute(q, X),
              (P[Z + re + 8] = i.x),
              (P[Z + re + 9] = i.y),
              (P[Z + re + 10] = i.z),
              (P[Z + re + 11] = q.itemSize === 4 ? i.w : 1));
        }
      }
      (g = { count: m, texture: U, size: new tt(R, k) }),
        r.set(l, g),
        l.addEventListener("dispose", L);
    }
    if (s.isInstancedMesh === !0 && s.morphTexture !== null)
      u.getUniforms().setValue(n, "morphTexture", s.morphTexture, t);
    else {
      let x = 0;
      for (let _ = 0; _ < f.length; _++) x += f[_];
      const S = l.morphTargetsRelative ? 1 : 1 - x;
      u.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
        u.getUniforms().setValue(n, "morphTargetInfluences", f);
    }
    u.getUniforms().setValue(n, "morphTargetsTexture", g.texture, t),
      u.getUniforms().setValue(n, "morphTargetsTextureSize", g.size);
  }
  return { update: o };
}
function k6(n, e, t, r) {
  let i = new WeakMap();
  function o(u) {
    const f = r.render.frame,
      h = u.geometry,
      m = e.get(u, h);
    if (
      (i.get(m) !== f && (e.update(m), i.set(m, f)),
      u.isInstancedMesh &&
        (u.hasEventListener("dispose", l) === !1 &&
          u.addEventListener("dispose", l),
        i.get(u) !== f &&
          (t.update(u.instanceMatrix, n.ARRAY_BUFFER),
          u.instanceColor !== null && t.update(u.instanceColor, n.ARRAY_BUFFER),
          i.set(u, f))),
      u.isSkinnedMesh)
    ) {
      const g = u.skeleton;
      i.get(g) !== f && (g.update(), i.set(g, f));
    }
    return m;
  }
  function s() {
    i = new WeakMap();
  }
  function l(u) {
    const f = u.target;
    f.removeEventListener("dispose", l),
      t.remove(f.instanceMatrix),
      f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return { update: o, dispose: s };
}
class Sw extends Qn {
  constructor(e, t, r, i, o, s, l, u, f, h = df) {
    if (h !== df && h !== _f)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && h === df && (r = Nl),
      r === void 0 && h === _f && (r = xf),
      super(null, i, o, s, l, u, h, r, f),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = l !== void 0 ? l : _i),
      (this.minFilter = u !== void 0 ? u : _i),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const QA = new Qn(),
  DE = new Sw(1, 1),
  eR = new Hy(),
  tR = new gw(),
  nR = new tg(),
  NE = [],
  OE = [],
  UE = new Float32Array(16),
  FE = new Float32Array(9),
  BE = new Float32Array(4);
function Uh(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let o = NE[i];
  if ((o === void 0 && ((o = new Float32Array(i)), (NE[i] = o)), e !== 0)) {
    r.toArray(o, 0);
    for (let s = 1, l = 0; s !== e; ++s) (l += t), n[s].toArray(o, l);
  }
  return o;
}
function ci(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function fi(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function Vy(n, e) {
  let t = OE[e];
  t === void 0 && ((t = new Int32Array(e)), (OE[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function D6(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function N6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ci(t, e)) return;
    n.uniform2fv(this.addr, e), fi(t, e);
  }
}
function O6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (ci(t, e)) return;
    n.uniform3fv(this.addr, e), fi(t, e);
  }
}
function U6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ci(t, e)) return;
    n.uniform4fv(this.addr, e), fi(t, e);
  }
}
function F6(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (ci(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), fi(t, e);
  } else {
    if (ci(t, r)) return;
    BE.set(r), n.uniformMatrix2fv(this.addr, !1, BE), fi(t, r);
  }
}
function B6(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (ci(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), fi(t, e);
  } else {
    if (ci(t, r)) return;
    FE.set(r), n.uniformMatrix3fv(this.addr, !1, FE), fi(t, r);
  }
}
function z6(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (ci(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), fi(t, e);
  } else {
    if (ci(t, r)) return;
    UE.set(r), n.uniformMatrix4fv(this.addr, !1, UE), fi(t, r);
  }
}
function H6(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function V6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ci(t, e)) return;
    n.uniform2iv(this.addr, e), fi(t, e);
  }
}
function G6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (ci(t, e)) return;
    n.uniform3iv(this.addr, e), fi(t, e);
  }
}
function W6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ci(t, e)) return;
    n.uniform4iv(this.addr, e), fi(t, e);
  }
}
function j6(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function $6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ci(t, e)) return;
    n.uniform2uiv(this.addr, e), fi(t, e);
  }
}
function X6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (ci(t, e)) return;
    n.uniform3uiv(this.addr, e), fi(t, e);
  }
}
function Y6(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ci(t, e)) return;
    n.uniform4uiv(this.addr, e), fi(t, e);
  }
}
function q6(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i));
  let o;
  this.type === n.SAMPLER_2D_SHADOW
    ? ((DE.compareFunction = pw), (o = DE))
    : (o = QA),
    t.setTexture2D(e || o, i);
}
function K6(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture3D(e || tR, i);
}
function Z6(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTextureCube(e || nR, i);
}
function J6(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2DArray(e || eR, i);
}
function Q6(n) {
  switch (n) {
    case 5126:
      return D6;
    case 35664:
      return N6;
    case 35665:
      return O6;
    case 35666:
      return U6;
    case 35674:
      return F6;
    case 35675:
      return B6;
    case 35676:
      return z6;
    case 5124:
    case 35670:
      return H6;
    case 35667:
    case 35671:
      return V6;
    case 35668:
    case 35672:
      return G6;
    case 35669:
    case 35673:
      return W6;
    case 5125:
      return j6;
    case 36294:
      return $6;
    case 36295:
      return X6;
    case 36296:
      return Y6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return q6;
    case 35679:
    case 36299:
    case 36307:
      return K6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Z6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return J6;
  }
}
function eH(n, e) {
  n.uniform1fv(this.addr, e);
}
function tH(n, e) {
  const t = Uh(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function nH(n, e) {
  const t = Uh(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function rH(n, e) {
  const t = Uh(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function iH(n, e) {
  const t = Uh(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function oH(n, e) {
  const t = Uh(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function sH(n, e) {
  const t = Uh(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function aH(n, e) {
  n.uniform1iv(this.addr, e);
}
function lH(n, e) {
  n.uniform2iv(this.addr, e);
}
function uH(n, e) {
  n.uniform3iv(this.addr, e);
}
function cH(n, e) {
  n.uniform4iv(this.addr, e);
}
function fH(n, e) {
  n.uniform1uiv(this.addr, e);
}
function dH(n, e) {
  n.uniform2uiv(this.addr, e);
}
function hH(n, e) {
  n.uniform3uiv(this.addr, e);
}
function pH(n, e) {
  n.uniform4uiv(this.addr, e);
}
function mH(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = Vy(t, i);
  ci(r, o) || (n.uniform1iv(this.addr, o), fi(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture2D(e[s] || QA, o[s]);
}
function gH(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = Vy(t, i);
  ci(r, o) || (n.uniform1iv(this.addr, o), fi(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture3D(e[s] || tR, o[s]);
}
function vH(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = Vy(t, i);
  ci(r, o) || (n.uniform1iv(this.addr, o), fi(r, o));
  for (let s = 0; s !== i; ++s) t.setTextureCube(e[s] || nR, o[s]);
}
function yH(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = Vy(t, i);
  ci(r, o) || (n.uniform1iv(this.addr, o), fi(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture2DArray(e[s] || eR, o[s]);
}
function xH(n) {
  switch (n) {
    case 5126:
      return eH;
    case 35664:
      return tH;
    case 35665:
      return nH;
    case 35666:
      return rH;
    case 35674:
      return iH;
    case 35675:
      return oH;
    case 35676:
      return sH;
    case 5124:
    case 35670:
      return aH;
    case 35667:
    case 35671:
      return lH;
    case 35668:
    case 35672:
      return uH;
    case 35669:
    case 35673:
      return cH;
    case 5125:
      return fH;
    case 36294:
      return dH;
    case 36295:
      return hH;
    case 36296:
      return pH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return mH;
    case 35679:
    case 36299:
    case 36307:
      return gH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return vH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return yH;
  }
}
class _H {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = Q6(t.type));
  }
}
class SH {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = xH(t.type));
  }
}
class wH {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let o = 0, s = i.length; o !== s; ++o) {
      const l = i[o];
      l.setValue(e, t[l.id], r);
    }
  }
}
const $_ = /(\w+)(\])?(\[|\.)?/g;
function zE(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function bH(n, e, t) {
  const r = n.name,
    i = r.length;
  for ($_.lastIndex = 0; ; ) {
    const o = $_.exec(r),
      s = $_.lastIndex;
    let l = o[1];
    const u = o[2] === "]",
      f = o[3];
    if ((u && (l = l | 0), f === void 0 || (f === "[" && s + 2 === i))) {
      zE(t, f === void 0 ? new _H(l, n, e) : new SH(l, n, e));
      break;
    } else {
      let m = t.map[l];
      m === void 0 && ((m = new wH(l)), zE(t, m)), (t = m);
    }
  }
}
class d0 {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const o = e.getActiveUniform(t, i),
        s = e.getUniformLocation(t, o.name);
      bH(o, s, this);
    }
  }
  setValue(e, t, r, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let o = 0, s = t.length; o !== s; ++o) {
      const l = t[o],
        u = r[l.id];
      u.needsUpdate !== !1 && l.setValue(e, u.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const s = e[i];
      s.id in t && r.push(s);
    }
    return r;
  }
}
function HE(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
const MH = 37297;
let EH = 0;
function TH(n, e) {
  const t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    o = Math.min(e + 6, t.length);
  for (let s = i; s < o; s++) {
    const l = s + 1;
    r.push(`${l === e ? ">" : " "} ${l}: ${t[s]}`);
  }
  return r.join(`
`);
}
function CH(n) {
  const e = yn.getPrimaries(yn.workingColorSpace),
    t = yn.getPrimaries(n);
  let r;
  switch (
    (e === t
      ? (r = "")
      : e === Nm && t === Dm
      ? (r = "LinearDisplayP3ToLinearSRGB")
      : e === Dm && t === Nm && (r = "LinearSRGBToLinearDisplayP3"),
    n)
  ) {
    case Fl:
    case Qm:
      return [r, "LinearTransferOETF"];
    case Ms:
    case zy:
      return [r, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [r, "LinearTransferOETF"]
      );
  }
}
function VE(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const s = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      TH(n.getShaderSource(e), s)
    );
  } else return i;
}
function AH(n, e) {
  const t = CH(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function RH(n, e) {
  let t;
  switch (e) {
    case EA:
      t = "Linear";
      break;
    case TA:
      t = "Reinhard";
      break;
    case CA:
      t = "OptimizedCineon";
      break;
    case tw:
      t = "ACESFilmic";
      break;
    case RA:
      t = "AgX";
      break;
    case PA:
      t = "Neutral";
      break;
    case AA:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const Rv = new se();
function PH() {
  yn.getLuminanceCoefficients(Rv);
  const n = Rv.x.toFixed(4),
    e = Rv.y.toFixed(4),
    t = Rv.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function IH(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Qp).join(`
`);
}
function LH(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function kH(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const o = n.getActiveAttrib(e, i),
      s = o.name;
    let l = 1;
    o.type === n.FLOAT_MAT2 && (l = 2),
      o.type === n.FLOAT_MAT3 && (l = 3),
      o.type === n.FLOAT_MAT4 && (l = 4),
      (t[s] = {
        type: o.type,
        location: n.getAttribLocation(e, s),
        locationSize: l,
      });
  }
  return t;
}
function Qp(n) {
  return n !== "";
}
function GE(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function WE(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const DH = /^[ \t]*#include +<([\w\d./]+)>/gm;
function tS(n) {
  return n.replace(DH, OH);
}
const NH = new Map();
function OH(n, e) {
  let t = on[e];
  if (t === void 0) {
    const r = NH.get(e);
    if (r !== void 0)
      (t = on[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return tS(t);
}
const UH =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function jE(n) {
  return n.replace(UH, FH);
}
function FH(n, e, t, r) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function $E(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function BH(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Iy
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === sm
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === ra && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function zH(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Dl:
      case Wu:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Nh:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function HH(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Wu:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function VH(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case Zm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case bA:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case MA:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function GH(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function WH(n, e, t, r) {
  const i = n.getContext(),
    o = t.defines;
  let s = t.vertexShader,
    l = t.fragmentShader;
  const u = BH(t),
    f = zH(t),
    h = HH(t),
    m = VH(t),
    g = GH(t),
    y = IH(t),
    x = LH(o),
    S = i.createProgram();
  let _,
    w,
    T = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((_ = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
      ].filter(Qp).join(`
`)),
      _.length > 0 &&
        (_ += `
`),
      (w = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
      ].filter(Qp).join(`
`)),
      w.length > 0 &&
        (w += `
`))
    : ((_ = [
        $E(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Qp).join(`
`)),
      (w = [
        $E(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + f : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + m : "",
        g ? "#define CUBEUV_TEXEL_WIDTH " + g.texelWidth : "",
        g ? "#define CUBEUV_TEXEL_HEIGHT " + g.texelHeight : "",
        g ? "#define CUBEUV_MAX_MIP " + g.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Ga ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Ga ? on.tonemapping_pars_fragment : "",
        t.toneMapping !== Ga ? RH("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        on.colorspace_pars_fragment,
        AH("linearToOutputTexel", t.outputColorSpace),
        PH(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Qp).join(`
`))),
    (s = tS(s)),
    (s = GE(s, t)),
    (s = WE(s, t)),
    (l = tS(l)),
    (l = GE(l, t)),
    (l = WE(l, t)),
    (s = jE(s)),
    (l = jE(l)),
    t.isRawShaderMaterial !== !0 &&
      ((T = `#version 300 es
`),
      (_ =
        [
          y,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        _),
      (w =
        [
          "#define varying in",
          t.glslVersion === Q1
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === Q1 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        w));
  const E = T + _ + s,
    A = T + w + l,
    R = HE(i, i.VERTEX_SHADER, E),
    k = HE(i, i.FRAGMENT_SHADER, A);
  i.attachShader(S, R),
    i.attachShader(S, k),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(S, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(S, 0, "position"),
    i.linkProgram(S);
  function P(H) {
    if (n.debug.checkShaderErrors) {
      const G = i.getProgramInfoLog(S).trim(),
        $ = i.getShaderInfoLog(R).trim(),
        q = i.getShaderInfoLog(k).trim();
      let Z = !0,
        X = !0;
      if (i.getProgramParameter(S, i.LINK_STATUS) === !1)
        if (((Z = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(i, S, R, k);
        else {
          const re = VE(i, R, "vertex"),
            W = VE(i, k, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(S, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              H.name +
              `
Material Type: ` +
              H.type +
              `

Program Info Log: ` +
              G +
              `
` +
              re +
              `
` +
              W
          );
        }
      else
        G !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", G)
          : ($ === "" || q === "") && (X = !1);
      X &&
        (H.diagnostics = {
          runnable: Z,
          programLog: G,
          vertexShader: { log: $, prefix: _ },
          fragmentShader: { log: q, prefix: w },
        });
    }
    i.deleteShader(R), i.deleteShader(k), (U = new d0(i, S)), (N = kH(i, S));
  }
  let U;
  this.getUniforms = function () {
    return U === void 0 && P(this), U;
  };
  let N;
  this.getAttributes = function () {
    return N === void 0 && P(this), N;
  };
  let L = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return L === !1 && (L = i.getProgramParameter(S, MH)), L;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(S),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = EH++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = S),
    (this.vertexShader = R),
    (this.fragmentShader = k),
    this
  );
}
let jH = 0;
class $H {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(t),
      o = this._getShaderStage(r),
      s = this._getShaderCacheForMaterial(e);
    return (
      s.has(i) === !1 && (s.add(i), i.usedTimes++),
      s.has(o) === !1 && (s.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new XH(e)), t.set(e, r)), r;
  }
}
class XH {
  constructor(e) {
    (this.id = jH++), (this.code = e), (this.usedTimes = 0);
  }
}
function YH(n, e, t, r, i, o, s) {
  const l = new pf(),
    u = new $H(),
    f = new Set(),
    h = [],
    m = i.logarithmicDepthBuffer,
    g = i.vertexTextures;
  let y = i.precision;
  const x = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function S(N) {
    return f.add(N), N === 0 ? "uv" : `uv${N}`;
  }
  function _(N, L, H, G, $) {
    const q = G.fog,
      Z = $.geometry,
      X = N.isMeshStandardMaterial ? G.environment : null,
      re = (N.isMeshStandardMaterial ? t : e).get(N.envMap || X),
      W = re && re.mapping === Nh ? re.image.height : null,
      te = x[N.type];
    N.precision !== null &&
      ((y = i.getMaxPrecision(N.precision)),
      y !== N.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          N.precision,
          "not supported, using",
          y,
          "instead."
        ));
    const F =
        Z.morphAttributes.position ||
        Z.morphAttributes.normal ||
        Z.morphAttributes.color,
      V = F !== void 0 ? F.length : 0;
    let ne = 0;
    Z.morphAttributes.position !== void 0 && (ne = 1),
      Z.morphAttributes.normal !== void 0 && (ne = 2),
      Z.morphAttributes.color !== void 0 && (ne = 3);
    let ae, J, oe, de;
    if (te) {
      const ht = ia[te];
      (ae = ht.vertexShader), (J = ht.fragmentShader);
    } else
      (ae = N.vertexShader),
        (J = N.fragmentShader),
        u.update(N),
        (oe = u.getVertexShaderID(N)),
        (de = u.getFragmentShaderID(N));
    const le = n.getRenderTarget(),
      fe = $.isInstancedMesh === !0,
      Ee = $.isBatchedMesh === !0,
      ge = !!N.map,
      xe = !!N.matcap,
      j = !!re,
      we = !!N.aoMap,
      Ae = !!N.lightMap,
      Ne = !!N.bumpMap,
      Ie = !!N.normalMap,
      rt = !!N.displacementMap,
      ke = !!N.emissiveMap,
      Xe = !!N.metalnessMap,
      ee = !!N.roughnessMap,
      B = N.anisotropy > 0,
      ve = N.clearcoat > 0,
      Se = N.dispersion > 0,
      _e = N.iridescence > 0,
      Te = N.sheen > 0,
      at = N.transmission > 0,
      Fe = B && !!N.anisotropyMap,
      Be = ve && !!N.clearcoatMap,
      We = ve && !!N.clearcoatNormalMap,
      Ye = ve && !!N.clearcoatRoughnessMap,
      nt = _e && !!N.iridescenceMap,
      yt = _e && !!N.iridescenceThicknessMap,
      $e = Te && !!N.sheenColorMap,
      qe = Te && !!N.sheenRoughnessMap,
      et = !!N.specularMap,
      he = !!N.specularColorMap,
      Je = !!N.specularIntensityMap,
      me = at && !!N.transmissionMap,
      Ve = at && !!N.thicknessMap,
      Re = !!N.gradientMap,
      Ue = !!N.alphaMap,
      it = N.alphaTest > 0,
      mt = !!N.alphaHash,
      gt = !!N.extensions;
    let Ot = Ga;
    N.toneMapped &&
      (le === null || le.isXRRenderTarget === !0) &&
      (Ot = n.toneMapping);
    const Ut = {
      shaderID: te,
      shaderType: N.type,
      shaderName: N.name,
      vertexShader: ae,
      fragmentShader: J,
      defines: N.defines,
      customVertexShaderID: oe,
      customFragmentShaderID: de,
      isRawShaderMaterial: N.isRawShaderMaterial === !0,
      glslVersion: N.glslVersion,
      precision: y,
      batching: Ee,
      batchingColor: Ee && $._colorsTexture !== null,
      instancing: fe,
      instancingColor: fe && $.instanceColor !== null,
      instancingMorph: fe && $.morphTexture !== null,
      supportsVertexTextures: g,
      outputColorSpace:
        le === null
          ? n.outputColorSpace
          : le.isXRRenderTarget === !0
          ? le.texture.colorSpace
          : Fl,
      alphaToCoverage: !!N.alphaToCoverage,
      map: ge,
      matcap: xe,
      envMap: j,
      envMapMode: j && re.mapping,
      envMapCubeUVHeight: W,
      aoMap: we,
      lightMap: Ae,
      bumpMap: Ne,
      normalMap: Ie,
      displacementMap: g && rt,
      emissiveMap: ke,
      normalMapObjectSpace: Ie && N.normalMapType === OA,
      normalMapTangentSpace: Ie && N.normalMapType === Xu,
      metalnessMap: Xe,
      roughnessMap: ee,
      anisotropy: B,
      anisotropyMap: Fe,
      clearcoat: ve,
      clearcoatMap: Be,
      clearcoatNormalMap: We,
      clearcoatRoughnessMap: Ye,
      dispersion: Se,
      iridescence: _e,
      iridescenceMap: nt,
      iridescenceThicknessMap: yt,
      sheen: Te,
      sheenColorMap: $e,
      sheenRoughnessMap: qe,
      specularMap: et,
      specularColorMap: he,
      specularIntensityMap: Je,
      transmission: at,
      transmissionMap: me,
      thicknessMap: Ve,
      gradientMap: Re,
      opaque:
        N.transparent === !1 && N.blending === ff && N.alphaToCoverage === !1,
      alphaMap: Ue,
      alphaTest: it,
      alphaHash: mt,
      combine: N.combine,
      mapUv: ge && S(N.map.channel),
      aoMapUv: we && S(N.aoMap.channel),
      lightMapUv: Ae && S(N.lightMap.channel),
      bumpMapUv: Ne && S(N.bumpMap.channel),
      normalMapUv: Ie && S(N.normalMap.channel),
      displacementMapUv: rt && S(N.displacementMap.channel),
      emissiveMapUv: ke && S(N.emissiveMap.channel),
      metalnessMapUv: Xe && S(N.metalnessMap.channel),
      roughnessMapUv: ee && S(N.roughnessMap.channel),
      anisotropyMapUv: Fe && S(N.anisotropyMap.channel),
      clearcoatMapUv: Be && S(N.clearcoatMap.channel),
      clearcoatNormalMapUv: We && S(N.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ye && S(N.clearcoatRoughnessMap.channel),
      iridescenceMapUv: nt && S(N.iridescenceMap.channel),
      iridescenceThicknessMapUv: yt && S(N.iridescenceThicknessMap.channel),
      sheenColorMapUv: $e && S(N.sheenColorMap.channel),
      sheenRoughnessMapUv: qe && S(N.sheenRoughnessMap.channel),
      specularMapUv: et && S(N.specularMap.channel),
      specularColorMapUv: he && S(N.specularColorMap.channel),
      specularIntensityMapUv: Je && S(N.specularIntensityMap.channel),
      transmissionMapUv: me && S(N.transmissionMap.channel),
      thicknessMapUv: Ve && S(N.thicknessMap.channel),
      alphaMapUv: Ue && S(N.alphaMap.channel),
      vertexTangents: !!Z.attributes.tangent && (Ie || B),
      vertexColors: N.vertexColors,
      vertexAlphas:
        N.vertexColors === !0 &&
        !!Z.attributes.color &&
        Z.attributes.color.itemSize === 4,
      pointsUvs: $.isPoints === !0 && !!Z.attributes.uv && (ge || Ue),
      fog: !!q,
      useFog: N.fog === !0,
      fogExp2: !!q && q.isFogExp2,
      flatShading: N.flatShading === !0,
      sizeAttenuation: N.sizeAttenuation === !0,
      logarithmicDepthBuffer: m,
      skinning: $.isSkinnedMesh === !0,
      morphTargets: Z.morphAttributes.position !== void 0,
      morphNormals: Z.morphAttributes.normal !== void 0,
      morphColors: Z.morphAttributes.color !== void 0,
      morphTargetsCount: V,
      morphTextureStride: ne,
      numDirLights: L.directional.length,
      numPointLights: L.point.length,
      numSpotLights: L.spot.length,
      numSpotLightMaps: L.spotLightMap.length,
      numRectAreaLights: L.rectArea.length,
      numHemiLights: L.hemi.length,
      numDirLightShadows: L.directionalShadowMap.length,
      numPointLightShadows: L.pointShadowMap.length,
      numSpotLightShadows: L.spotShadowMap.length,
      numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
      numLightProbes: L.numLightProbes,
      numClippingPlanes: s.numPlanes,
      numClipIntersection: s.numIntersection,
      dithering: N.dithering,
      shadowMapEnabled: n.shadowMap.enabled && H.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: Ot,
      decodeVideoTexture:
        ge &&
        N.map.isVideoTexture === !0 &&
        yn.getTransfer(N.map.colorSpace) === Zn,
      premultipliedAlpha: N.premultipliedAlpha,
      doubleSided: N.side === Ts,
      flipSided: N.side === Qi,
      useDepthPacking: N.depthPacking >= 0,
      depthPacking: N.depthPacking || 0,
      index0AttributeName: N.index0AttributeName,
      extensionClipCullDistance:
        gt &&
        N.extensions.clipCullDistance === !0 &&
        r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((gt && N.extensions.multiDraw === !0) || Ee) &&
        r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: N.customProgramCacheKey(),
    };
    return (
      (Ut.vertexUv1s = f.has(1)),
      (Ut.vertexUv2s = f.has(2)),
      (Ut.vertexUv3s = f.has(3)),
      f.clear(),
      Ut
    );
  }
  function w(N) {
    const L = [];
    if (
      (N.shaderID
        ? L.push(N.shaderID)
        : (L.push(N.customVertexShaderID), L.push(N.customFragmentShaderID)),
      N.defines !== void 0)
    )
      for (const H in N.defines) L.push(H), L.push(N.defines[H]);
    return (
      N.isRawShaderMaterial === !1 &&
        (T(L, N), E(L, N), L.push(n.outputColorSpace)),
      L.push(N.customProgramCacheKey),
      L.join()
    );
  }
  function T(N, L) {
    N.push(L.precision),
      N.push(L.outputColorSpace),
      N.push(L.envMapMode),
      N.push(L.envMapCubeUVHeight),
      N.push(L.mapUv),
      N.push(L.alphaMapUv),
      N.push(L.lightMapUv),
      N.push(L.aoMapUv),
      N.push(L.bumpMapUv),
      N.push(L.normalMapUv),
      N.push(L.displacementMapUv),
      N.push(L.emissiveMapUv),
      N.push(L.metalnessMapUv),
      N.push(L.roughnessMapUv),
      N.push(L.anisotropyMapUv),
      N.push(L.clearcoatMapUv),
      N.push(L.clearcoatNormalMapUv),
      N.push(L.clearcoatRoughnessMapUv),
      N.push(L.iridescenceMapUv),
      N.push(L.iridescenceThicknessMapUv),
      N.push(L.sheenColorMapUv),
      N.push(L.sheenRoughnessMapUv),
      N.push(L.specularMapUv),
      N.push(L.specularColorMapUv),
      N.push(L.specularIntensityMapUv),
      N.push(L.transmissionMapUv),
      N.push(L.thicknessMapUv),
      N.push(L.combine),
      N.push(L.fogExp2),
      N.push(L.sizeAttenuation),
      N.push(L.morphTargetsCount),
      N.push(L.morphAttributeCount),
      N.push(L.numDirLights),
      N.push(L.numPointLights),
      N.push(L.numSpotLights),
      N.push(L.numSpotLightMaps),
      N.push(L.numHemiLights),
      N.push(L.numRectAreaLights),
      N.push(L.numDirLightShadows),
      N.push(L.numPointLightShadows),
      N.push(L.numSpotLightShadows),
      N.push(L.numSpotLightShadowsWithMaps),
      N.push(L.numLightProbes),
      N.push(L.shadowMapType),
      N.push(L.toneMapping),
      N.push(L.numClippingPlanes),
      N.push(L.numClipIntersection),
      N.push(L.depthPacking);
  }
  function E(N, L) {
    l.disableAll(),
      L.supportsVertexTextures && l.enable(0),
      L.instancing && l.enable(1),
      L.instancingColor && l.enable(2),
      L.instancingMorph && l.enable(3),
      L.matcap && l.enable(4),
      L.envMap && l.enable(5),
      L.normalMapObjectSpace && l.enable(6),
      L.normalMapTangentSpace && l.enable(7),
      L.clearcoat && l.enable(8),
      L.iridescence && l.enable(9),
      L.alphaTest && l.enable(10),
      L.vertexColors && l.enable(11),
      L.vertexAlphas && l.enable(12),
      L.vertexUv1s && l.enable(13),
      L.vertexUv2s && l.enable(14),
      L.vertexUv3s && l.enable(15),
      L.vertexTangents && l.enable(16),
      L.anisotropy && l.enable(17),
      L.alphaHash && l.enable(18),
      L.batching && l.enable(19),
      L.dispersion && l.enable(20),
      L.batchingColor && l.enable(21),
      N.push(l.mask),
      l.disableAll(),
      L.fog && l.enable(0),
      L.useFog && l.enable(1),
      L.flatShading && l.enable(2),
      L.logarithmicDepthBuffer && l.enable(3),
      L.skinning && l.enable(4),
      L.morphTargets && l.enable(5),
      L.morphNormals && l.enable(6),
      L.morphColors && l.enable(7),
      L.premultipliedAlpha && l.enable(8),
      L.shadowMapEnabled && l.enable(9),
      L.doubleSided && l.enable(10),
      L.flipSided && l.enable(11),
      L.useDepthPacking && l.enable(12),
      L.dithering && l.enable(13),
      L.transmission && l.enable(14),
      L.sheen && l.enable(15),
      L.opaque && l.enable(16),
      L.pointsUvs && l.enable(17),
      L.decodeVideoTexture && l.enable(18),
      L.alphaToCoverage && l.enable(19),
      N.push(l.mask);
  }
  function A(N) {
    const L = x[N.type];
    let H;
    if (L) {
      const G = ia[L];
      H = xw.clone(G.uniforms);
    } else H = N.uniforms;
    return H;
  }
  function R(N, L) {
    let H;
    for (let G = 0, $ = h.length; G < $; G++) {
      const q = h[G];
      if (q.cacheKey === L) {
        (H = q), ++H.usedTimes;
        break;
      }
    }
    return H === void 0 && ((H = new WH(n, L, N, o)), h.push(H)), H;
  }
  function k(N) {
    if (--N.usedTimes === 0) {
      const L = h.indexOf(N);
      (h[L] = h[h.length - 1]), h.pop(), N.destroy();
    }
  }
  function P(N) {
    u.remove(N);
  }
  function U() {
    u.dispose();
  }
  return {
    getParameters: _,
    getProgramCacheKey: w,
    getUniforms: A,
    acquireProgram: R,
    releaseProgram: k,
    releaseShaderCache: P,
    programs: h,
    dispose: U,
  };
}
function qH() {
  let n = new WeakMap();
  function e(o) {
    let s = n.get(o);
    return s === void 0 && ((s = {}), n.set(o, s)), s;
  }
  function t(o) {
    n.delete(o);
  }
  function r(o, s, l) {
    n.get(o)[s] = l;
  }
  function i() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: r, dispose: i };
}
function KH(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function XE(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function YE() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    i = [];
  function o() {
    (e = 0), (t.length = 0), (r.length = 0), (i.length = 0);
  }
  function s(m, g, y, x, S, _) {
    let w = n[e];
    return (
      w === void 0
        ? ((w = {
            id: m.id,
            object: m,
            geometry: g,
            material: y,
            groupOrder: x,
            renderOrder: m.renderOrder,
            z: S,
            group: _,
          }),
          (n[e] = w))
        : ((w.id = m.id),
          (w.object = m),
          (w.geometry = g),
          (w.material = y),
          (w.groupOrder = x),
          (w.renderOrder = m.renderOrder),
          (w.z = S),
          (w.group = _)),
      e++,
      w
    );
  }
  function l(m, g, y, x, S, _) {
    const w = s(m, g, y, x, S, _);
    y.transmission > 0
      ? r.push(w)
      : y.transparent === !0
      ? i.push(w)
      : t.push(w);
  }
  function u(m, g, y, x, S, _) {
    const w = s(m, g, y, x, S, _);
    y.transmission > 0
      ? r.unshift(w)
      : y.transparent === !0
      ? i.unshift(w)
      : t.unshift(w);
  }
  function f(m, g) {
    t.length > 1 && t.sort(m || KH),
      r.length > 1 && r.sort(g || XE),
      i.length > 1 && i.sort(g || XE);
  }
  function h() {
    for (let m = e, g = n.length; m < g; m++) {
      const y = n[m];
      if (y.id === null) break;
      (y.id = null),
        (y.object = null),
        (y.geometry = null),
        (y.material = null),
        (y.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: o,
    push: l,
    unshift: u,
    finish: h,
    sort: f,
  };
}
function ZH() {
  let n = new WeakMap();
  function e(r, i) {
    const o = n.get(r);
    let s;
    return (
      o === void 0
        ? ((s = new YE()), n.set(r, [s]))
        : i >= o.length
        ? ((s = new YE()), o.push(s))
        : (s = o[i]),
      s
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function JH() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new se(), color: new St() };
          break;
        case "SpotLight":
          t = {
            position: new se(),
            direction: new se(),
            color: new St(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new se(), color: new St(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = {
            direction: new se(),
            skyColor: new St(),
            groundColor: new St(),
          };
          break;
        case "RectAreaLight":
          t = {
            color: new St(),
            position: new se(),
            halfWidth: new se(),
            halfHeight: new se(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function QH() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let eV = 0;
function tV(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function nV(n) {
  const e = new JH(),
    t = QH(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let f = 0; f < 9; f++) r.probe.push(new se());
  const i = new se(),
    o = new Wt(),
    s = new Wt();
  function l(f) {
    let h = 0,
      m = 0,
      g = 0;
    for (let N = 0; N < 9; N++) r.probe[N].set(0, 0, 0);
    let y = 0,
      x = 0,
      S = 0,
      _ = 0,
      w = 0,
      T = 0,
      E = 0,
      A = 0,
      R = 0,
      k = 0,
      P = 0;
    f.sort(tV);
    for (let N = 0, L = f.length; N < L; N++) {
      const H = f[N],
        G = H.color,
        $ = H.intensity,
        q = H.distance,
        Z = H.shadow && H.shadow.map ? H.shadow.map.texture : null;
      if (H.isAmbientLight) (h += G.r * $), (m += G.g * $), (g += G.b * $);
      else if (H.isLightProbe) {
        for (let X = 0; X < 9; X++)
          r.probe[X].addScaledVector(H.sh.coefficients[X], $);
        P++;
      } else if (H.isDirectionalLight) {
        const X = e.get(H);
        if ((X.color.copy(H.color).multiplyScalar(H.intensity), H.castShadow)) {
          const re = H.shadow,
            W = t.get(H);
          (W.shadowIntensity = re.intensity),
            (W.shadowBias = re.bias),
            (W.shadowNormalBias = re.normalBias),
            (W.shadowRadius = re.radius),
            (W.shadowMapSize = re.mapSize),
            (r.directionalShadow[y] = W),
            (r.directionalShadowMap[y] = Z),
            (r.directionalShadowMatrix[y] = H.shadow.matrix),
            T++;
        }
        (r.directional[y] = X), y++;
      } else if (H.isSpotLight) {
        const X = e.get(H);
        X.position.setFromMatrixPosition(H.matrixWorld),
          X.color.copy(G).multiplyScalar($),
          (X.distance = q),
          (X.coneCos = Math.cos(H.angle)),
          (X.penumbraCos = Math.cos(H.angle * (1 - H.penumbra))),
          (X.decay = H.decay),
          (r.spot[S] = X);
        const re = H.shadow;
        if (
          (H.map &&
            ((r.spotLightMap[R] = H.map),
            R++,
            re.updateMatrices(H),
            H.castShadow && k++),
          (r.spotLightMatrix[S] = re.matrix),
          H.castShadow)
        ) {
          const W = t.get(H);
          (W.shadowIntensity = re.intensity),
            (W.shadowBias = re.bias),
            (W.shadowNormalBias = re.normalBias),
            (W.shadowRadius = re.radius),
            (W.shadowMapSize = re.mapSize),
            (r.spotShadow[S] = W),
            (r.spotShadowMap[S] = Z),
            A++;
        }
        S++;
      } else if (H.isRectAreaLight) {
        const X = e.get(H);
        X.color.copy(G).multiplyScalar($),
          X.halfWidth.set(H.width * 0.5, 0, 0),
          X.halfHeight.set(0, H.height * 0.5, 0),
          (r.rectArea[_] = X),
          _++;
      } else if (H.isPointLight) {
        const X = e.get(H);
        if (
          (X.color.copy(H.color).multiplyScalar(H.intensity),
          (X.distance = H.distance),
          (X.decay = H.decay),
          H.castShadow)
        ) {
          const re = H.shadow,
            W = t.get(H);
          (W.shadowIntensity = re.intensity),
            (W.shadowBias = re.bias),
            (W.shadowNormalBias = re.normalBias),
            (W.shadowRadius = re.radius),
            (W.shadowMapSize = re.mapSize),
            (W.shadowCameraNear = re.camera.near),
            (W.shadowCameraFar = re.camera.far),
            (r.pointShadow[x] = W),
            (r.pointShadowMap[x] = Z),
            (r.pointShadowMatrix[x] = H.shadow.matrix),
            E++;
        }
        (r.point[x] = X), x++;
      } else if (H.isHemisphereLight) {
        const X = e.get(H);
        X.skyColor.copy(H.color).multiplyScalar($),
          X.groundColor.copy(H.groundColor).multiplyScalar($),
          (r.hemi[w] = X),
          w++;
      }
    }
    _ > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = xt.LTC_FLOAT_1), (r.rectAreaLTC2 = xt.LTC_FLOAT_2))
        : ((r.rectAreaLTC1 = xt.LTC_HALF_1), (r.rectAreaLTC2 = xt.LTC_HALF_2))),
      (r.ambient[0] = h),
      (r.ambient[1] = m),
      (r.ambient[2] = g);
    const U = r.hash;
    (U.directionalLength !== y ||
      U.pointLength !== x ||
      U.spotLength !== S ||
      U.rectAreaLength !== _ ||
      U.hemiLength !== w ||
      U.numDirectionalShadows !== T ||
      U.numPointShadows !== E ||
      U.numSpotShadows !== A ||
      U.numSpotMaps !== R ||
      U.numLightProbes !== P) &&
      ((r.directional.length = y),
      (r.spot.length = S),
      (r.rectArea.length = _),
      (r.point.length = x),
      (r.hemi.length = w),
      (r.directionalShadow.length = T),
      (r.directionalShadowMap.length = T),
      (r.pointShadow.length = E),
      (r.pointShadowMap.length = E),
      (r.spotShadow.length = A),
      (r.spotShadowMap.length = A),
      (r.directionalShadowMatrix.length = T),
      (r.pointShadowMatrix.length = E),
      (r.spotLightMatrix.length = A + R - k),
      (r.spotLightMap.length = R),
      (r.numSpotLightShadowsWithMaps = k),
      (r.numLightProbes = P),
      (U.directionalLength = y),
      (U.pointLength = x),
      (U.spotLength = S),
      (U.rectAreaLength = _),
      (U.hemiLength = w),
      (U.numDirectionalShadows = T),
      (U.numPointShadows = E),
      (U.numSpotShadows = A),
      (U.numSpotMaps = R),
      (U.numLightProbes = P),
      (r.version = eV++));
  }
  function u(f, h) {
    let m = 0,
      g = 0,
      y = 0,
      x = 0,
      S = 0;
    const _ = h.matrixWorldInverse;
    for (let w = 0, T = f.length; w < T; w++) {
      const E = f[w];
      if (E.isDirectionalLight) {
        const A = r.directional[m];
        A.direction.setFromMatrixPosition(E.matrixWorld),
          i.setFromMatrixPosition(E.target.matrixWorld),
          A.direction.sub(i),
          A.direction.transformDirection(_),
          m++;
      } else if (E.isSpotLight) {
        const A = r.spot[y];
        A.position.setFromMatrixPosition(E.matrixWorld),
          A.position.applyMatrix4(_),
          A.direction.setFromMatrixPosition(E.matrixWorld),
          i.setFromMatrixPosition(E.target.matrixWorld),
          A.direction.sub(i),
          A.direction.transformDirection(_),
          y++;
      } else if (E.isRectAreaLight) {
        const A = r.rectArea[x];
        A.position.setFromMatrixPosition(E.matrixWorld),
          A.position.applyMatrix4(_),
          s.identity(),
          o.copy(E.matrixWorld),
          o.premultiply(_),
          s.extractRotation(o),
          A.halfWidth.set(E.width * 0.5, 0, 0),
          A.halfHeight.set(0, E.height * 0.5, 0),
          A.halfWidth.applyMatrix4(s),
          A.halfHeight.applyMatrix4(s),
          x++;
      } else if (E.isPointLight) {
        const A = r.point[g];
        A.position.setFromMatrixPosition(E.matrixWorld),
          A.position.applyMatrix4(_),
          g++;
      } else if (E.isHemisphereLight) {
        const A = r.hemi[S];
        A.direction.setFromMatrixPosition(E.matrixWorld),
          A.direction.transformDirection(_),
          S++;
      }
    }
  }
  return { setup: l, setupView: u, state: r };
}
function qE(n) {
  const e = new nV(n),
    t = [],
    r = [];
  function i(h) {
    (f.camera = h), (t.length = 0), (r.length = 0);
  }
  function o(h) {
    t.push(h);
  }
  function s(h) {
    r.push(h);
  }
  function l() {
    e.setup(t);
  }
  function u(h) {
    e.setupView(t, h);
  }
  const f = {
    lightsArray: t,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: f,
    setupLights: l,
    setupLightsView: u,
    pushLight: o,
    pushShadow: s,
  };
}
function rV(n) {
  let e = new WeakMap();
  function t(i, o = 0) {
    const s = e.get(i);
    let l;
    return (
      s === void 0
        ? ((l = new qE(n)), e.set(i, [l]))
        : o >= s.length
        ? ((l = new qE(n)), s.push(l))
        : (l = s[o]),
      l
    );
  }
  function r() {
    e = new WeakMap();
  }
  return { get: t, dispose: r };
}
class Gy extends Oi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = NA),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Wy extends Oi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const iV = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  oV = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function sV(n, e, t) {
  let r = new ng();
  const i = new tt(),
    o = new tt(),
    s = new Tn(),
    l = new Gy({ depthPacking: hw }),
    u = new Wy(),
    f = {},
    h = t.maxTextureSize,
    m = { [Xa]: Qi, [Qi]: Xa, [Ts]: Ts },
    g = new ua({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new tt() },
        radius: { value: 4 },
      },
      vertexShader: iV,
      fragmentShader: oV,
    }),
    y = g.clone();
  y.defines.HORIZONTAL_PASS = 1;
  const x = new Jt();
  x.setAttribute(
    "position",
    new Gn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const S = new vr(x, g),
    _ = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Iy);
  let w = this.type;
  this.render = function (k, P, U) {
    if (
      _.enabled === !1 ||
      (_.autoUpdate === !1 && _.needsUpdate === !1) ||
      k.length === 0
    )
      return;
    const N = n.getRenderTarget(),
      L = n.getActiveCubeFace(),
      H = n.getActiveMipmapLevel(),
      G = n.state;
    G.setBlending(Il),
      G.buffers.color.setClear(1, 1, 1, 1),
      G.buffers.depth.setTest(!0),
      G.setScissorTest(!1);
    const $ = w !== ra && this.type === ra,
      q = w === ra && this.type !== ra;
    for (let Z = 0, X = k.length; Z < X; Z++) {
      const re = k[Z],
        W = re.shadow;
      if (W === void 0) {
        console.warn("THREE.WebGLShadowMap:", re, "has no shadow.");
        continue;
      }
      if (W.autoUpdate === !1 && W.needsUpdate === !1) continue;
      i.copy(W.mapSize);
      const te = W.getFrameExtents();
      if (
        (i.multiply(te),
        o.copy(W.mapSize),
        (i.x > h || i.y > h) &&
          (i.x > h &&
            ((o.x = Math.floor(h / te.x)),
            (i.x = o.x * te.x),
            (W.mapSize.x = o.x)),
          i.y > h &&
            ((o.y = Math.floor(h / te.y)),
            (i.y = o.y * te.y),
            (W.mapSize.y = o.y))),
        W.map === null || $ === !0 || q === !0)
      ) {
        const V = this.type !== ra ? { minFilter: _i, magFilter: _i } : {};
        W.map !== null && W.map.dispose(),
          (W.map = new la(i.x, i.y, V)),
          (W.map.texture.name = re.name + ".shadowMap"),
          W.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(W.map), n.clear();
      const F = W.getViewportCount();
      for (let V = 0; V < F; V++) {
        const ne = W.getViewport(V);
        s.set(o.x * ne.x, o.y * ne.y, o.x * ne.z, o.y * ne.w),
          G.viewport(s),
          W.updateMatrices(re, V),
          (r = W.getFrustum()),
          A(P, U, W.camera, re, this.type);
      }
      W.isPointLightShadow !== !0 && this.type === ra && T(W, U),
        (W.needsUpdate = !1);
    }
    (w = this.type), (_.needsUpdate = !1), n.setRenderTarget(N, L, H);
  };
  function T(k, P) {
    const U = e.update(S);
    g.defines.VSM_SAMPLES !== k.blurSamples &&
      ((g.defines.VSM_SAMPLES = k.blurSamples),
      (y.defines.VSM_SAMPLES = k.blurSamples),
      (g.needsUpdate = !0),
      (y.needsUpdate = !0)),
      k.mapPass === null && (k.mapPass = new la(i.x, i.y)),
      (g.uniforms.shadow_pass.value = k.map.texture),
      (g.uniforms.resolution.value = k.mapSize),
      (g.uniforms.radius.value = k.radius),
      n.setRenderTarget(k.mapPass),
      n.clear(),
      n.renderBufferDirect(P, null, U, g, S, null),
      (y.uniforms.shadow_pass.value = k.mapPass.texture),
      (y.uniforms.resolution.value = k.mapSize),
      (y.uniforms.radius.value = k.radius),
      n.setRenderTarget(k.map),
      n.clear(),
      n.renderBufferDirect(P, null, U, y, S, null);
  }
  function E(k, P, U, N) {
    let L = null;
    const H =
      U.isPointLight === !0 ? k.customDistanceMaterial : k.customDepthMaterial;
    if (H !== void 0) L = H;
    else if (
      ((L = U.isPointLight === !0 ? u : l),
      (n.localClippingEnabled &&
        P.clipShadows === !0 &&
        Array.isArray(P.clippingPlanes) &&
        P.clippingPlanes.length !== 0) ||
        (P.displacementMap && P.displacementScale !== 0) ||
        (P.alphaMap && P.alphaTest > 0) ||
        (P.map && P.alphaTest > 0))
    ) {
      const G = L.uuid,
        $ = P.uuid;
      let q = f[G];
      q === void 0 && ((q = {}), (f[G] = q));
      let Z = q[$];
      Z === void 0 &&
        ((Z = L.clone()), (q[$] = Z), P.addEventListener("dispose", R)),
        (L = Z);
    }
    if (
      ((L.visible = P.visible),
      (L.wireframe = P.wireframe),
      N === ra
        ? (L.side = P.shadowSide !== null ? P.shadowSide : P.side)
        : (L.side = P.shadowSide !== null ? P.shadowSide : m[P.side]),
      (L.alphaMap = P.alphaMap),
      (L.alphaTest = P.alphaTest),
      (L.map = P.map),
      (L.clipShadows = P.clipShadows),
      (L.clippingPlanes = P.clippingPlanes),
      (L.clipIntersection = P.clipIntersection),
      (L.displacementMap = P.displacementMap),
      (L.displacementScale = P.displacementScale),
      (L.displacementBias = P.displacementBias),
      (L.wireframeLinewidth = P.wireframeLinewidth),
      (L.linewidth = P.linewidth),
      U.isPointLight === !0 && L.isMeshDistanceMaterial === !0)
    ) {
      const G = n.properties.get(L);
      G.light = U;
    }
    return L;
  }
  function A(k, P, U, N, L) {
    if (k.visible === !1) return;
    if (
      k.layers.test(P.layers) &&
      (k.isMesh || k.isLine || k.isPoints) &&
      (k.castShadow || (k.receiveShadow && L === ra)) &&
      (!k.frustumCulled || r.intersectsObject(k))
    ) {
      k.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, k.matrixWorld);
      const $ = e.update(k),
        q = k.material;
      if (Array.isArray(q)) {
        const Z = $.groups;
        for (let X = 0, re = Z.length; X < re; X++) {
          const W = Z[X],
            te = q[W.materialIndex];
          if (te && te.visible) {
            const F = E(k, te, N, L);
            k.onBeforeShadow(n, k, P, U, $, F, W),
              n.renderBufferDirect(U, null, $, F, k, W),
              k.onAfterShadow(n, k, P, U, $, F, W);
          }
        }
      } else if (q.visible) {
        const Z = E(k, q, N, L);
        k.onBeforeShadow(n, k, P, U, $, Z, null),
          n.renderBufferDirect(U, null, $, Z, k, null),
          k.onAfterShadow(n, k, P, U, $, Z, null);
      }
    }
    const G = k.children;
    for (let $ = 0, q = G.length; $ < q; $++) A(G[$], P, U, N, L);
  }
  function R(k) {
    k.target.removeEventListener("dispose", R);
    for (const U in f) {
      const N = f[U],
        L = k.target.uuid;
      L in N && (N[L].dispose(), delete N[L]);
    }
  }
}
function aV(n) {
  function e() {
    let me = !1;
    const Ve = new Tn();
    let Re = null;
    const Ue = new Tn(0, 0, 0, 0);
    return {
      setMask: function (it) {
        Re !== it && !me && (n.colorMask(it, it, it, it), (Re = it));
      },
      setLocked: function (it) {
        me = it;
      },
      setClear: function (it, mt, gt, Ot, Ut) {
        Ut === !0 && ((it *= Ot), (mt *= Ot), (gt *= Ot)),
          Ve.set(it, mt, gt, Ot),
          Ue.equals(Ve) === !1 && (n.clearColor(it, mt, gt, Ot), Ue.copy(Ve));
      },
      reset: function () {
        (me = !1), (Re = null), Ue.set(-1, 0, 0, 0);
      },
    };
  }
  function t() {
    let me = !1,
      Ve = null,
      Re = null,
      Ue = null;
    return {
      setTest: function (it) {
        it ? de(n.DEPTH_TEST) : le(n.DEPTH_TEST);
      },
      setMask: function (it) {
        Ve !== it && !me && (n.depthMask(it), (Ve = it));
      },
      setFunc: function (it) {
        if (Re !== it) {
          switch (it) {
            case gA:
              n.depthFunc(n.NEVER);
              break;
            case vA:
              n.depthFunc(n.ALWAYS);
              break;
            case yA:
              n.depthFunc(n.LESS);
              break;
            case Tm:
              n.depthFunc(n.LEQUAL);
              break;
            case xA:
              n.depthFunc(n.EQUAL);
              break;
            case _A:
              n.depthFunc(n.GEQUAL);
              break;
            case SA:
              n.depthFunc(n.GREATER);
              break;
            case wA:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Re = it;
        }
      },
      setLocked: function (it) {
        me = it;
      },
      setClear: function (it) {
        Ue !== it && (n.clearDepth(it), (Ue = it));
      },
      reset: function () {
        (me = !1), (Ve = null), (Re = null), (Ue = null);
      },
    };
  }
  function r() {
    let me = !1,
      Ve = null,
      Re = null,
      Ue = null,
      it = null,
      mt = null,
      gt = null,
      Ot = null,
      Ut = null;
    return {
      setTest: function (ht) {
        me || (ht ? de(n.STENCIL_TEST) : le(n.STENCIL_TEST));
      },
      setMask: function (ht) {
        Ve !== ht && !me && (n.stencilMask(ht), (Ve = ht));
      },
      setFunc: function (ht, $t, un) {
        (Re !== ht || Ue !== $t || it !== un) &&
          (n.stencilFunc(ht, $t, un), (Re = ht), (Ue = $t), (it = un));
      },
      setOp: function (ht, $t, un) {
        (mt !== ht || gt !== $t || Ot !== un) &&
          (n.stencilOp(ht, $t, un), (mt = ht), (gt = $t), (Ot = un));
      },
      setLocked: function (ht) {
        me = ht;
      },
      setClear: function (ht) {
        Ut !== ht && (n.clearStencil(ht), (Ut = ht));
      },
      reset: function () {
        (me = !1),
          (Ve = null),
          (Re = null),
          (Ue = null),
          (it = null),
          (mt = null),
          (gt = null),
          (Ot = null),
          (Ut = null);
      },
    };
  }
  const i = new e(),
    o = new t(),
    s = new r(),
    l = new WeakMap(),
    u = new WeakMap();
  let f = {},
    h = {},
    m = new WeakMap(),
    g = [],
    y = null,
    x = !1,
    S = null,
    _ = null,
    w = null,
    T = null,
    E = null,
    A = null,
    R = null,
    k = new St(0, 0, 0),
    P = 0,
    U = !1,
    N = null,
    L = null,
    H = null,
    G = null,
    $ = null;
  const q = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Z = !1,
    X = 0;
  const re = n.getParameter(n.VERSION);
  re.indexOf("WebGL") !== -1
    ? ((X = parseFloat(/^WebGL (\d)/.exec(re)[1])), (Z = X >= 1))
    : re.indexOf("OpenGL ES") !== -1 &&
      ((X = parseFloat(/^OpenGL ES (\d)/.exec(re)[1])), (Z = X >= 2));
  let W = null,
    te = {};
  const F = n.getParameter(n.SCISSOR_BOX),
    V = n.getParameter(n.VIEWPORT),
    ne = new Tn().fromArray(F),
    ae = new Tn().fromArray(V);
  function J(me, Ve, Re, Ue) {
    const it = new Uint8Array(4),
      mt = n.createTexture();
    n.bindTexture(me, mt),
      n.texParameteri(me, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(me, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let gt = 0; gt < Re; gt++)
      me === n.TEXTURE_3D || me === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(Ve, 0, n.RGBA, 1, 1, Ue, 0, n.RGBA, n.UNSIGNED_BYTE, it)
        : n.texImage2D(
            Ve + gt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            it
          );
    return mt;
  }
  const oe = {};
  (oe[n.TEXTURE_2D] = J(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (oe[n.TEXTURE_CUBE_MAP] = J(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (oe[n.TEXTURE_2D_ARRAY] = J(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (oe[n.TEXTURE_3D] = J(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    i.setClear(0, 0, 0, 1),
    o.setClear(1),
    s.setClear(0),
    de(n.DEPTH_TEST),
    o.setFunc(Tm),
    Ne(!1),
    Ie(X1),
    de(n.CULL_FACE),
    we(Il);
  function de(me) {
    f[me] !== !0 && (n.enable(me), (f[me] = !0));
  }
  function le(me) {
    f[me] !== !1 && (n.disable(me), (f[me] = !1));
  }
  function fe(me, Ve) {
    return h[me] !== Ve
      ? (n.bindFramebuffer(me, Ve),
        (h[me] = Ve),
        me === n.DRAW_FRAMEBUFFER && (h[n.FRAMEBUFFER] = Ve),
        me === n.FRAMEBUFFER && (h[n.DRAW_FRAMEBUFFER] = Ve),
        !0)
      : !1;
  }
  function Ee(me, Ve) {
    let Re = g,
      Ue = !1;
    if (me) {
      (Re = m.get(Ve)), Re === void 0 && ((Re = []), m.set(Ve, Re));
      const it = me.textures;
      if (Re.length !== it.length || Re[0] !== n.COLOR_ATTACHMENT0) {
        for (let mt = 0, gt = it.length; mt < gt; mt++)
          Re[mt] = n.COLOR_ATTACHMENT0 + mt;
        (Re.length = it.length), (Ue = !0);
      }
    } else Re[0] !== n.BACK && ((Re[0] = n.BACK), (Ue = !0));
    Ue && n.drawBuffers(Re);
  }
  function ge(me) {
    return y !== me ? (n.useProgram(me), (y = me), !0) : !1;
  }
  const xe = {
    [Ou]: n.FUNC_ADD,
    [Q2]: n.FUNC_SUBTRACT,
    [eA]: n.FUNC_REVERSE_SUBTRACT,
  };
  (xe[tA] = n.MIN), (xe[nA] = n.MAX);
  const j = {
    [rA]: n.ZERO,
    [iA]: n.ONE,
    [oA]: n.SRC_COLOR,
    [R0]: n.SRC_ALPHA,
    [fA]: n.SRC_ALPHA_SATURATE,
    [uA]: n.DST_COLOR,
    [aA]: n.DST_ALPHA,
    [sA]: n.ONE_MINUS_SRC_COLOR,
    [P0]: n.ONE_MINUS_SRC_ALPHA,
    [cA]: n.ONE_MINUS_DST_COLOR,
    [lA]: n.ONE_MINUS_DST_ALPHA,
    [dA]: n.CONSTANT_COLOR,
    [hA]: n.ONE_MINUS_CONSTANT_COLOR,
    [pA]: n.CONSTANT_ALPHA,
    [mA]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function we(me, Ve, Re, Ue, it, mt, gt, Ot, Ut, ht) {
    if (me === Il) {
      x === !0 && (le(n.BLEND), (x = !1));
      return;
    }
    if ((x === !1 && (de(n.BLEND), (x = !0)), me !== J2)) {
      if (me !== S || ht !== U) {
        if (
          ((_ !== Ou || E !== Ou) &&
            (n.blendEquation(n.FUNC_ADD), (_ = Ou), (E = Ou)),
          ht)
        )
          switch (me) {
            case ff:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Y1:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case q1:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case K1:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", me);
              break;
          }
        else
          switch (me) {
            case ff:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Y1:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case q1:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case K1:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", me);
              break;
          }
        (w = null),
          (T = null),
          (A = null),
          (R = null),
          k.set(0, 0, 0),
          (P = 0),
          (S = me),
          (U = ht);
      }
      return;
    }
    (it = it || Ve),
      (mt = mt || Re),
      (gt = gt || Ue),
      (Ve !== _ || it !== E) &&
        (n.blendEquationSeparate(xe[Ve], xe[it]), (_ = Ve), (E = it)),
      (Re !== w || Ue !== T || mt !== A || gt !== R) &&
        (n.blendFuncSeparate(j[Re], j[Ue], j[mt], j[gt]),
        (w = Re),
        (T = Ue),
        (A = mt),
        (R = gt)),
      (Ot.equals(k) === !1 || Ut !== P) &&
        (n.blendColor(Ot.r, Ot.g, Ot.b, Ut), k.copy(Ot), (P = Ut)),
      (S = me),
      (U = !1);
  }
  function Ae(me, Ve) {
    me.side === Ts ? le(n.CULL_FACE) : de(n.CULL_FACE);
    let Re = me.side === Qi;
    Ve && (Re = !Re),
      Ne(Re),
      me.blending === ff && me.transparent === !1
        ? we(Il)
        : we(
            me.blending,
            me.blendEquation,
            me.blendSrc,
            me.blendDst,
            me.blendEquationAlpha,
            me.blendSrcAlpha,
            me.blendDstAlpha,
            me.blendColor,
            me.blendAlpha,
            me.premultipliedAlpha
          ),
      o.setFunc(me.depthFunc),
      o.setTest(me.depthTest),
      o.setMask(me.depthWrite),
      i.setMask(me.colorWrite);
    const Ue = me.stencilWrite;
    s.setTest(Ue),
      Ue &&
        (s.setMask(me.stencilWriteMask),
        s.setFunc(me.stencilFunc, me.stencilRef, me.stencilFuncMask),
        s.setOp(me.stencilFail, me.stencilZFail, me.stencilZPass)),
      ke(me.polygonOffset, me.polygonOffsetFactor, me.polygonOffsetUnits),
      me.alphaToCoverage === !0
        ? de(n.SAMPLE_ALPHA_TO_COVERAGE)
        : le(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ne(me) {
    N !== me && (me ? n.frontFace(n.CW) : n.frontFace(n.CCW), (N = me));
  }
  function Ie(me) {
    me !== q2
      ? (de(n.CULL_FACE),
        me !== L &&
          (me === X1
            ? n.cullFace(n.BACK)
            : me === K2
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : le(n.CULL_FACE),
      (L = me);
  }
  function rt(me) {
    me !== H && (Z && n.lineWidth(me), (H = me));
  }
  function ke(me, Ve, Re) {
    me
      ? (de(n.POLYGON_OFFSET_FILL),
        (G !== Ve || $ !== Re) && (n.polygonOffset(Ve, Re), (G = Ve), ($ = Re)))
      : le(n.POLYGON_OFFSET_FILL);
  }
  function Xe(me) {
    me ? de(n.SCISSOR_TEST) : le(n.SCISSOR_TEST);
  }
  function ee(me) {
    me === void 0 && (me = n.TEXTURE0 + q - 1),
      W !== me && (n.activeTexture(me), (W = me));
  }
  function B(me, Ve, Re) {
    Re === void 0 && (W === null ? (Re = n.TEXTURE0 + q - 1) : (Re = W));
    let Ue = te[Re];
    Ue === void 0 && ((Ue = { type: void 0, texture: void 0 }), (te[Re] = Ue)),
      (Ue.type !== me || Ue.texture !== Ve) &&
        (W !== Re && (n.activeTexture(Re), (W = Re)),
        n.bindTexture(me, Ve || oe[me]),
        (Ue.type = me),
        (Ue.texture = Ve));
  }
  function ve() {
    const me = te[W];
    me !== void 0 &&
      me.type !== void 0 &&
      (n.bindTexture(me.type, null), (me.type = void 0), (me.texture = void 0));
  }
  function Se() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function _e() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Te() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function at() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Fe() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Be() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function We() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Ye() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function nt() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function yt() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function $e(me) {
    ne.equals(me) === !1 && (n.scissor(me.x, me.y, me.z, me.w), ne.copy(me));
  }
  function qe(me) {
    ae.equals(me) === !1 && (n.viewport(me.x, me.y, me.z, me.w), ae.copy(me));
  }
  function et(me, Ve) {
    let Re = u.get(Ve);
    Re === void 0 && ((Re = new WeakMap()), u.set(Ve, Re));
    let Ue = Re.get(me);
    Ue === void 0 &&
      ((Ue = n.getUniformBlockIndex(Ve, me.name)), Re.set(me, Ue));
  }
  function he(me, Ve) {
    const Ue = u.get(Ve).get(me);
    l.get(Ve) !== Ue &&
      (n.uniformBlockBinding(Ve, Ue, me.__bindingPointIndex), l.set(Ve, Ue));
  }
  function Je() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (f = {}),
      (W = null),
      (te = {}),
      (h = {}),
      (m = new WeakMap()),
      (g = []),
      (y = null),
      (x = !1),
      (S = null),
      (_ = null),
      (w = null),
      (T = null),
      (E = null),
      (A = null),
      (R = null),
      (k = new St(0, 0, 0)),
      (P = 0),
      (U = !1),
      (N = null),
      (L = null),
      (H = null),
      (G = null),
      ($ = null),
      ne.set(0, 0, n.canvas.width, n.canvas.height),
      ae.set(0, 0, n.canvas.width, n.canvas.height),
      i.reset(),
      o.reset(),
      s.reset();
  }
  return {
    buffers: { color: i, depth: o, stencil: s },
    enable: de,
    disable: le,
    bindFramebuffer: fe,
    drawBuffers: Ee,
    useProgram: ge,
    setBlending: we,
    setMaterial: Ae,
    setFlipSided: Ne,
    setCullFace: Ie,
    setLineWidth: rt,
    setPolygonOffset: ke,
    setScissorTest: Xe,
    activeTexture: ee,
    bindTexture: B,
    unbindTexture: ve,
    compressedTexImage2D: Se,
    compressedTexImage3D: _e,
    texImage2D: nt,
    texImage3D: yt,
    updateUBOMapping: et,
    uniformBlockBinding: he,
    texStorage2D: We,
    texStorage3D: Ye,
    texSubImage2D: Te,
    texSubImage3D: at,
    compressedTexSubImage2D: Fe,
    compressedTexSubImage3D: Be,
    scissor: $e,
    viewport: qe,
    reset: Je,
  };
}
function lV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  );
}
function uV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  );
}
function cV(n) {
  return (
    (n.repeat.x = 1), (n.repeat.y = 1), (n.offset.x = 0), (n.offset.y = 0), n
  );
}
function nS(n, e, t, r) {
  const i = fV(r);
  switch (t) {
    case sw:
      return n * e;
    case lw:
      return n * e;
    case uw:
      return n * e * 2;
    case Oy:
      return ((n * e) / i.components) * i.byteLength;
    case Jm:
      return ((n * e) / i.components) * i.byteLength;
    case cw:
      return ((n * e * 2) / i.components) * i.byteLength;
    case Uy:
      return ((n * e * 2) / i.components) * i.byteLength;
    case aw:
      return ((n * e * 3) / i.components) * i.byteLength;
    case Ji:
      return ((n * e * 4) / i.components) * i.byteLength;
    case Fy:
      return ((n * e * 4) / i.components) * i.byteLength;
    case lm:
    case um:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case cm:
    case fm:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case L0:
    case D0:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case I0:
    case k0:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case N0:
    case O0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case U0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case F0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case B0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case z0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case H0:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case V0:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case G0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case W0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case j0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case $0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case X0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Y0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case q0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case K0:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Z0:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case dm:
    case J0:
    case Q0:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case fw:
    case ey:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case ty:
    case ny:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function fV(n) {
  switch (n) {
    case aa:
    case rw:
      return { byteLength: 1, components: 1 };
    case Mh:
    case iw:
    case Oh:
      return { byteLength: 2, components: 1 };
    case Dy:
    case Ny:
      return { byteLength: 2, components: 4 };
    case Nl:
    case ky:
    case Oo:
      return { byteLength: 4, components: 1 };
    case ow:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
const dV = { contain: lV, cover: uV, fill: cV, getByteLength: nS };
function hV(n, e, t, r, i, o, s) {
  const l = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    u =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    f = new tt(),
    h = new WeakMap();
  let m;
  const g = new WeakMap();
  let y = !1;
  try {
    y =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(ee, B) {
    return y ? new OffscreenCanvas(ee, B) : Fm("canvas");
  }
  function S(ee, B, ve) {
    let Se = 1;
    const _e = Xe(ee);
    if (
      ((_e.width > ve || _e.height > ve) &&
        (Se = ve / Math.max(_e.width, _e.height)),
      Se < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && ee instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && ee instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && ee instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && ee instanceof VideoFrame)
      ) {
        const Te = Math.floor(Se * _e.width),
          at = Math.floor(Se * _e.height);
        m === void 0 && (m = x(Te, at));
        const Fe = B ? x(Te, at) : m;
        return (
          (Fe.width = Te),
          (Fe.height = at),
          Fe.getContext("2d").drawImage(ee, 0, 0, Te, at),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              _e.width +
              "x" +
              _e.height +
              ") to (" +
              Te +
              "x" +
              at +
              ")."
          ),
          Fe
        );
      } else
        return (
          "data" in ee &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                _e.width +
                "x" +
                _e.height +
                ")."
            ),
          ee
        );
    return ee;
  }
  function _(ee) {
    return ee.generateMipmaps && ee.minFilter !== _i && ee.minFilter !== Cr;
  }
  function w(ee) {
    n.generateMipmap(ee);
  }
  function T(ee, B, ve, Se, _e = !1) {
    if (ee !== null) {
      if (n[ee] !== void 0) return n[ee];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          ee +
          "'"
      );
    }
    let Te = B;
    if (
      (B === n.RED &&
        (ve === n.FLOAT && (Te = n.R32F),
        ve === n.HALF_FLOAT && (Te = n.R16F),
        ve === n.UNSIGNED_BYTE && (Te = n.R8)),
      B === n.RED_INTEGER &&
        (ve === n.UNSIGNED_BYTE && (Te = n.R8UI),
        ve === n.UNSIGNED_SHORT && (Te = n.R16UI),
        ve === n.UNSIGNED_INT && (Te = n.R32UI),
        ve === n.BYTE && (Te = n.R8I),
        ve === n.SHORT && (Te = n.R16I),
        ve === n.INT && (Te = n.R32I)),
      B === n.RG &&
        (ve === n.FLOAT && (Te = n.RG32F),
        ve === n.HALF_FLOAT && (Te = n.RG16F),
        ve === n.UNSIGNED_BYTE && (Te = n.RG8)),
      B === n.RG_INTEGER &&
        (ve === n.UNSIGNED_BYTE && (Te = n.RG8UI),
        ve === n.UNSIGNED_SHORT && (Te = n.RG16UI),
        ve === n.UNSIGNED_INT && (Te = n.RG32UI),
        ve === n.BYTE && (Te = n.RG8I),
        ve === n.SHORT && (Te = n.RG16I),
        ve === n.INT && (Te = n.RG32I)),
      B === n.RGB && ve === n.UNSIGNED_INT_5_9_9_9_REV && (Te = n.RGB9_E5),
      B === n.RGBA)
    ) {
      const at = _e ? km : yn.getTransfer(Se);
      ve === n.FLOAT && (Te = n.RGBA32F),
        ve === n.HALF_FLOAT && (Te = n.RGBA16F),
        ve === n.UNSIGNED_BYTE && (Te = at === Zn ? n.SRGB8_ALPHA8 : n.RGBA8),
        ve === n.UNSIGNED_SHORT_4_4_4_4 && (Te = n.RGBA4),
        ve === n.UNSIGNED_SHORT_5_5_5_1 && (Te = n.RGB5_A1);
    }
    return (
      (Te === n.R16F ||
        Te === n.R32F ||
        Te === n.RG16F ||
        Te === n.RG32F ||
        Te === n.RGBA16F ||
        Te === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Te
    );
  }
  function E(ee, B) {
    let ve;
    return (
      ee
        ? B === null || B === Nl || B === xf
          ? (ve = n.DEPTH24_STENCIL8)
          : B === Oo
          ? (ve = n.DEPTH32F_STENCIL8)
          : B === Mh &&
            ((ve = n.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : B === null || B === Nl || B === xf
        ? (ve = n.DEPTH_COMPONENT24)
        : B === Oo
        ? (ve = n.DEPTH_COMPONENT32F)
        : B === Mh && (ve = n.DEPTH_COMPONENT16),
      ve
    );
  }
  function A(ee, B) {
    return _(ee) === !0 ||
      (ee.isFramebufferTexture && ee.minFilter !== _i && ee.minFilter !== Cr)
      ? Math.log2(Math.max(B.width, B.height)) + 1
      : ee.mipmaps !== void 0 && ee.mipmaps.length > 0
      ? ee.mipmaps.length
      : ee.isCompressedTexture && Array.isArray(ee.image)
      ? B.mipmaps.length
      : 1;
  }
  function R(ee) {
    const B = ee.target;
    B.removeEventListener("dispose", R), P(B), B.isVideoTexture && h.delete(B);
  }
  function k(ee) {
    const B = ee.target;
    B.removeEventListener("dispose", k), N(B);
  }
  function P(ee) {
    const B = r.get(ee);
    if (B.__webglInit === void 0) return;
    const ve = ee.source,
      Se = g.get(ve);
    if (Se) {
      const _e = Se[B.__cacheKey];
      _e.usedTimes--,
        _e.usedTimes === 0 && U(ee),
        Object.keys(Se).length === 0 && g.delete(ve);
    }
    r.remove(ee);
  }
  function U(ee) {
    const B = r.get(ee);
    n.deleteTexture(B.__webglTexture);
    const ve = ee.source,
      Se = g.get(ve);
    delete Se[B.__cacheKey], s.memory.textures--;
  }
  function N(ee) {
    const B = r.get(ee);
    if (
      (ee.depthTexture && ee.depthTexture.dispose(), ee.isWebGLCubeRenderTarget)
    )
      for (let Se = 0; Se < 6; Se++) {
        if (Array.isArray(B.__webglFramebuffer[Se]))
          for (let _e = 0; _e < B.__webglFramebuffer[Se].length; _e++)
            n.deleteFramebuffer(B.__webglFramebuffer[Se][_e]);
        else n.deleteFramebuffer(B.__webglFramebuffer[Se]);
        B.__webglDepthbuffer && n.deleteRenderbuffer(B.__webglDepthbuffer[Se]);
      }
    else {
      if (Array.isArray(B.__webglFramebuffer))
        for (let Se = 0; Se < B.__webglFramebuffer.length; Se++)
          n.deleteFramebuffer(B.__webglFramebuffer[Se]);
      else n.deleteFramebuffer(B.__webglFramebuffer);
      if (
        (B.__webglDepthbuffer && n.deleteRenderbuffer(B.__webglDepthbuffer),
        B.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(B.__webglMultisampledFramebuffer),
        B.__webglColorRenderbuffer)
      )
        for (let Se = 0; Se < B.__webglColorRenderbuffer.length; Se++)
          B.__webglColorRenderbuffer[Se] &&
            n.deleteRenderbuffer(B.__webglColorRenderbuffer[Se]);
      B.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(B.__webglDepthRenderbuffer);
    }
    const ve = ee.textures;
    for (let Se = 0, _e = ve.length; Se < _e; Se++) {
      const Te = r.get(ve[Se]);
      Te.__webglTexture &&
        (n.deleteTexture(Te.__webglTexture), s.memory.textures--),
        r.remove(ve[Se]);
    }
    r.remove(ee);
  }
  let L = 0;
  function H() {
    L = 0;
  }
  function G() {
    const ee = L;
    return (
      ee >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            ee +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (L += 1),
      ee
    );
  }
  function $(ee) {
    const B = [];
    return (
      B.push(ee.wrapS),
      B.push(ee.wrapT),
      B.push(ee.wrapR || 0),
      B.push(ee.magFilter),
      B.push(ee.minFilter),
      B.push(ee.anisotropy),
      B.push(ee.internalFormat),
      B.push(ee.format),
      B.push(ee.type),
      B.push(ee.generateMipmaps),
      B.push(ee.premultiplyAlpha),
      B.push(ee.flipY),
      B.push(ee.unpackAlignment),
      B.push(ee.colorSpace),
      B.join()
    );
  }
  function q(ee, B) {
    const ve = r.get(ee);
    if (
      (ee.isVideoTexture && rt(ee),
      ee.isRenderTargetTexture === !1 &&
        ee.version > 0 &&
        ve.__version !== ee.version)
    ) {
      const Se = ee.image;
      if (Se === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Se.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        ae(ve, ee, B);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, ve.__webglTexture, n.TEXTURE0 + B);
  }
  function Z(ee, B) {
    const ve = r.get(ee);
    if (ee.version > 0 && ve.__version !== ee.version) {
      ae(ve, ee, B);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, ve.__webglTexture, n.TEXTURE0 + B);
  }
  function X(ee, B) {
    const ve = r.get(ee);
    if (ee.version > 0 && ve.__version !== ee.version) {
      ae(ve, ee, B);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, ve.__webglTexture, n.TEXTURE0 + B);
  }
  function re(ee, B) {
    const ve = r.get(ee);
    if (ee.version > 0 && ve.__version !== ee.version) {
      J(ve, ee, B);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, ve.__webglTexture, n.TEXTURE0 + B);
  }
  const W = { [Rm]: n.REPEAT, [As]: n.CLAMP_TO_EDGE, [Pm]: n.MIRRORED_REPEAT },
    te = {
      [_i]: n.NEAREST,
      [nw]: n.NEAREST_MIPMAP_NEAREST,
      [ah]: n.NEAREST_MIPMAP_LINEAR,
      [Cr]: n.LINEAR,
      [am]: n.LINEAR_MIPMAP_NEAREST,
      [Ba]: n.LINEAR_MIPMAP_LINEAR,
    },
    F = {
      [UA]: n.NEVER,
      [GA]: n.ALWAYS,
      [FA]: n.LESS,
      [pw]: n.LEQUAL,
      [BA]: n.EQUAL,
      [VA]: n.GEQUAL,
      [zA]: n.GREATER,
      [HA]: n.NOTEQUAL,
    };
  function V(ee, B) {
    if (
      (B.type === Oo &&
        e.has("OES_texture_float_linear") === !1 &&
        (B.magFilter === Cr ||
          B.magFilter === am ||
          B.magFilter === ah ||
          B.magFilter === Ba ||
          B.minFilter === Cr ||
          B.minFilter === am ||
          B.minFilter === ah ||
          B.minFilter === Ba) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      n.texParameteri(ee, n.TEXTURE_WRAP_S, W[B.wrapS]),
      n.texParameteri(ee, n.TEXTURE_WRAP_T, W[B.wrapT]),
      (ee === n.TEXTURE_3D || ee === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(ee, n.TEXTURE_WRAP_R, W[B.wrapR]),
      n.texParameteri(ee, n.TEXTURE_MAG_FILTER, te[B.magFilter]),
      n.texParameteri(ee, n.TEXTURE_MIN_FILTER, te[B.minFilter]),
      B.compareFunction &&
        (n.texParameteri(ee, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(ee, n.TEXTURE_COMPARE_FUNC, F[B.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        B.magFilter === _i ||
        (B.minFilter !== ah && B.minFilter !== Ba) ||
        (B.type === Oo && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (B.anisotropy > 1 || r.get(B).__currentAnisotropy) {
        const ve = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(
          ee,
          ve.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(B.anisotropy, i.getMaxAnisotropy())
        ),
          (r.get(B).__currentAnisotropy = B.anisotropy);
      }
    }
  }
  function ne(ee, B) {
    let ve = !1;
    ee.__webglInit === void 0 &&
      ((ee.__webglInit = !0), B.addEventListener("dispose", R));
    const Se = B.source;
    let _e = g.get(Se);
    _e === void 0 && ((_e = {}), g.set(Se, _e));
    const Te = $(B);
    if (Te !== ee.__cacheKey) {
      _e[Te] === void 0 &&
        ((_e[Te] = { texture: n.createTexture(), usedTimes: 0 }),
        s.memory.textures++,
        (ve = !0)),
        _e[Te].usedTimes++;
      const at = _e[ee.__cacheKey];
      at !== void 0 &&
        (_e[ee.__cacheKey].usedTimes--, at.usedTimes === 0 && U(B)),
        (ee.__cacheKey = Te),
        (ee.__webglTexture = _e[Te].texture);
    }
    return ve;
  }
  function ae(ee, B, ve) {
    let Se = n.TEXTURE_2D;
    (B.isDataArrayTexture || B.isCompressedArrayTexture) &&
      (Se = n.TEXTURE_2D_ARRAY),
      B.isData3DTexture && (Se = n.TEXTURE_3D);
    const _e = ne(ee, B),
      Te = B.source;
    t.bindTexture(Se, ee.__webglTexture, n.TEXTURE0 + ve);
    const at = r.get(Te);
    if (Te.version !== at.__version || _e === !0) {
      t.activeTexture(n.TEXTURE0 + ve);
      const Fe = yn.getPrimaries(yn.workingColorSpace),
        Be = B.colorSpace === Cl ? null : yn.getPrimaries(B.colorSpace),
        We =
          B.colorSpace === Cl || Fe === Be ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, B.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, B.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, We);
      let Ye = S(B.image, !1, i.maxTextureSize);
      Ye = ke(B, Ye);
      const nt = o.convert(B.format, B.colorSpace),
        yt = o.convert(B.type);
      let $e = T(B.internalFormat, nt, yt, B.colorSpace, B.isVideoTexture);
      V(Se, B);
      let qe;
      const et = B.mipmaps,
        he = B.isVideoTexture !== !0,
        Je = at.__version === void 0 || _e === !0,
        me = Te.dataReady,
        Ve = A(B, Ye);
      if (B.isDepthTexture)
        ($e = E(B.format === _f, B.type)),
          Je &&
            (he
              ? t.texStorage2D(n.TEXTURE_2D, 1, $e, Ye.width, Ye.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  $e,
                  Ye.width,
                  Ye.height,
                  0,
                  nt,
                  yt,
                  null
                ));
      else if (B.isDataTexture)
        if (et.length > 0) {
          he &&
            Je &&
            t.texStorage2D(n.TEXTURE_2D, Ve, $e, et[0].width, et[0].height);
          for (let Re = 0, Ue = et.length; Re < Ue; Re++)
            (qe = et[Re]),
              he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    nt,
                    yt,
                    qe.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    0,
                    nt,
                    yt,
                    qe.data
                  );
          B.generateMipmaps = !1;
        } else
          he
            ? (Je && t.texStorage2D(n.TEXTURE_2D, Ve, $e, Ye.width, Ye.height),
              me &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Ye.width,
                  Ye.height,
                  nt,
                  yt,
                  Ye.data
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                $e,
                Ye.width,
                Ye.height,
                0,
                nt,
                yt,
                Ye.data
              );
      else if (B.isCompressedTexture)
        if (B.isCompressedArrayTexture) {
          he &&
            Je &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Ve,
              $e,
              et[0].width,
              et[0].height,
              Ye.depth
            );
          for (let Re = 0, Ue = et.length; Re < Ue; Re++)
            if (((qe = et[Re]), B.format !== Ji))
              if (nt !== null)
                if (he) {
                  if (me)
                    if (B.layerUpdates.size > 0) {
                      const it = nS(qe.width, qe.height, B.format, B.type);
                      for (const mt of B.layerUpdates) {
                        const gt = qe.data.subarray(
                          (mt * it) / qe.data.BYTES_PER_ELEMENT,
                          ((mt + 1) * it) / qe.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Re,
                          0,
                          0,
                          mt,
                          qe.width,
                          qe.height,
                          1,
                          nt,
                          gt,
                          0,
                          0
                        );
                      }
                      B.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Re,
                        0,
                        0,
                        0,
                        qe.width,
                        qe.height,
                        Ye.depth,
                        nt,
                        qe.data,
                        0,
                        0
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    0,
                    qe.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              he
                ? me &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    0,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    nt,
                    yt,
                    qe.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    0,
                    nt,
                    yt,
                    qe.data
                  );
        } else {
          he &&
            Je &&
            t.texStorage2D(n.TEXTURE_2D, Ve, $e, et[0].width, et[0].height);
          for (let Re = 0, Ue = et.length; Re < Ue; Re++)
            (qe = et[Re]),
              B.format !== Ji
                ? nt !== null
                  ? he
                    ? me &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Re,
                        0,
                        0,
                        qe.width,
                        qe.height,
                        nt,
                        qe.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Re,
                        $e,
                        qe.width,
                        qe.height,
                        0,
                        qe.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    nt,
                    yt,
                    qe.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    0,
                    nt,
                    yt,
                    qe.data
                  );
        }
      else if (B.isDataArrayTexture)
        if (he) {
          if (
            (Je &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Ve,
                $e,
                Ye.width,
                Ye.height,
                Ye.depth
              ),
            me)
          )
            if (B.layerUpdates.size > 0) {
              const Re = nS(Ye.width, Ye.height, B.format, B.type);
              for (const Ue of B.layerUpdates) {
                const it = Ye.data.subarray(
                  (Ue * Re) / Ye.data.BYTES_PER_ELEMENT,
                  ((Ue + 1) * Re) / Ye.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Ue,
                  Ye.width,
                  Ye.height,
                  1,
                  nt,
                  yt,
                  it
                );
              }
              B.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ye.width,
                Ye.height,
                Ye.depth,
                nt,
                yt,
                Ye.data
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            $e,
            Ye.width,
            Ye.height,
            Ye.depth,
            0,
            nt,
            yt,
            Ye.data
          );
      else if (B.isData3DTexture)
        he
          ? (Je &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Ve,
                $e,
                Ye.width,
                Ye.height,
                Ye.depth
              ),
            me &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ye.width,
                Ye.height,
                Ye.depth,
                nt,
                yt,
                Ye.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              $e,
              Ye.width,
              Ye.height,
              Ye.depth,
              0,
              nt,
              yt,
              Ye.data
            );
      else if (B.isFramebufferTexture) {
        if (Je)
          if (he) t.texStorage2D(n.TEXTURE_2D, Ve, $e, Ye.width, Ye.height);
          else {
            let Re = Ye.width,
              Ue = Ye.height;
            for (let it = 0; it < Ve; it++)
              t.texImage2D(n.TEXTURE_2D, it, $e, Re, Ue, 0, nt, yt, null),
                (Re >>= 1),
                (Ue >>= 1);
          }
      } else if (et.length > 0) {
        if (he && Je) {
          const Re = Xe(et[0]);
          t.texStorage2D(n.TEXTURE_2D, Ve, $e, Re.width, Re.height);
        }
        for (let Re = 0, Ue = et.length; Re < Ue; Re++)
          (qe = et[Re]),
            he
              ? me && t.texSubImage2D(n.TEXTURE_2D, Re, 0, 0, nt, yt, qe)
              : t.texImage2D(n.TEXTURE_2D, Re, $e, nt, yt, qe);
        B.generateMipmaps = !1;
      } else if (he) {
        if (Je) {
          const Re = Xe(Ye);
          t.texStorage2D(n.TEXTURE_2D, Ve, $e, Re.width, Re.height);
        }
        me && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, nt, yt, Ye);
      } else t.texImage2D(n.TEXTURE_2D, 0, $e, nt, yt, Ye);
      _(B) && w(Se), (at.__version = Te.version), B.onUpdate && B.onUpdate(B);
    }
    ee.__version = B.version;
  }
  function J(ee, B, ve) {
    if (B.image.length !== 6) return;
    const Se = ne(ee, B),
      _e = B.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, ee.__webglTexture, n.TEXTURE0 + ve);
    const Te = r.get(_e);
    if (_e.version !== Te.__version || Se === !0) {
      t.activeTexture(n.TEXTURE0 + ve);
      const at = yn.getPrimaries(yn.workingColorSpace),
        Fe = B.colorSpace === Cl ? null : yn.getPrimaries(B.colorSpace),
        Be =
          B.colorSpace === Cl || at === Fe ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, B.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, B.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Be);
      const We = B.isCompressedTexture || B.image[0].isCompressedTexture,
        Ye = B.image[0] && B.image[0].isDataTexture,
        nt = [];
      for (let Ue = 0; Ue < 6; Ue++)
        !We && !Ye
          ? (nt[Ue] = S(B.image[Ue], !0, i.maxCubemapSize))
          : (nt[Ue] = Ye ? B.image[Ue].image : B.image[Ue]),
          (nt[Ue] = ke(B, nt[Ue]));
      const yt = nt[0],
        $e = o.convert(B.format, B.colorSpace),
        qe = o.convert(B.type),
        et = T(B.internalFormat, $e, qe, B.colorSpace),
        he = B.isVideoTexture !== !0,
        Je = Te.__version === void 0 || Se === !0,
        me = _e.dataReady;
      let Ve = A(B, yt);
      V(n.TEXTURE_CUBE_MAP, B);
      let Re;
      if (We) {
        he &&
          Je &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ve, et, yt.width, yt.height);
        for (let Ue = 0; Ue < 6; Ue++) {
          Re = nt[Ue].mipmaps;
          for (let it = 0; it < Re.length; it++) {
            const mt = Re[it];
            B.format !== Ji
              ? $e !== null
                ? he
                  ? me &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                      it,
                      0,
                      0,
                      mt.width,
                      mt.height,
                      $e,
                      mt.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                      it,
                      et,
                      mt.width,
                      mt.height,
                      0,
                      mt.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : he
              ? me &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  it,
                  0,
                  0,
                  mt.width,
                  mt.height,
                  $e,
                  qe,
                  mt.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  it,
                  et,
                  mt.width,
                  mt.height,
                  0,
                  $e,
                  qe,
                  mt.data
                );
          }
        }
      } else {
        if (((Re = B.mipmaps), he && Je)) {
          Re.length > 0 && Ve++;
          const Ue = Xe(nt[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ve, et, Ue.width, Ue.height);
        }
        for (let Ue = 0; Ue < 6; Ue++)
          if (Ye) {
            he
              ? me &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  0,
                  0,
                  nt[Ue].width,
                  nt[Ue].height,
                  $e,
                  qe,
                  nt[Ue].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  et,
                  nt[Ue].width,
                  nt[Ue].height,
                  0,
                  $e,
                  qe,
                  nt[Ue].data
                );
            for (let it = 0; it < Re.length; it++) {
              const gt = Re[it].image[Ue].image;
              he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    0,
                    0,
                    gt.width,
                    gt.height,
                    $e,
                    qe,
                    gt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    et,
                    gt.width,
                    gt.height,
                    0,
                    $e,
                    qe,
                    gt.data
                  );
            }
          } else {
            he
              ? me &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  0,
                  0,
                  $e,
                  qe,
                  nt[Ue]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  et,
                  $e,
                  qe,
                  nt[Ue]
                );
            for (let it = 0; it < Re.length; it++) {
              const mt = Re[it];
              he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    0,
                    0,
                    $e,
                    qe,
                    mt.image[Ue]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    et,
                    $e,
                    qe,
                    mt.image[Ue]
                  );
            }
          }
      }
      _(B) && w(n.TEXTURE_CUBE_MAP),
        (Te.__version = _e.version),
        B.onUpdate && B.onUpdate(B);
    }
    ee.__version = B.version;
  }
  function oe(ee, B, ve, Se, _e, Te) {
    const at = o.convert(ve.format, ve.colorSpace),
      Fe = o.convert(ve.type),
      Be = T(ve.internalFormat, at, Fe, ve.colorSpace);
    if (!r.get(B).__hasExternalTextures) {
      const Ye = Math.max(1, B.width >> Te),
        nt = Math.max(1, B.height >> Te);
      _e === n.TEXTURE_3D || _e === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(_e, Te, Be, Ye, nt, B.depth, 0, at, Fe, null)
        : t.texImage2D(_e, Te, Be, Ye, nt, 0, at, Fe, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, ee),
      Ie(B)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            Se,
            _e,
            r.get(ve).__webglTexture,
            0,
            Ne(B)
          )
        : (_e === n.TEXTURE_2D ||
            (_e >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              _e <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            Se,
            _e,
            r.get(ve).__webglTexture,
            Te
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function de(ee, B, ve) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, ee), B.depthBuffer)) {
      const Se = B.depthTexture,
        _e = Se && Se.isDepthTexture ? Se.type : null,
        Te = E(B.stencilBuffer, _e),
        at = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Fe = Ne(B);
      Ie(B)
        ? l.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Fe,
            Te,
            B.width,
            B.height
          )
        : ve
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Fe,
            Te,
            B.width,
            B.height
          )
        : n.renderbufferStorage(n.RENDERBUFFER, Te, B.width, B.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, at, n.RENDERBUFFER, ee);
    } else {
      const Se = B.textures;
      for (let _e = 0; _e < Se.length; _e++) {
        const Te = Se[_e],
          at = o.convert(Te.format, Te.colorSpace),
          Fe = o.convert(Te.type),
          Be = T(Te.internalFormat, at, Fe, Te.colorSpace),
          We = Ne(B);
        ve && Ie(B) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              We,
              Be,
              B.width,
              B.height
            )
          : Ie(B)
          ? l.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              We,
              Be,
              B.width,
              B.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, Be, B.width, B.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function le(ee, B) {
    if (B && B.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, ee),
      !(B.depthTexture && B.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(B.depthTexture).__webglTexture ||
      B.depthTexture.image.width !== B.width ||
      B.depthTexture.image.height !== B.height) &&
      ((B.depthTexture.image.width = B.width),
      (B.depthTexture.image.height = B.height),
      (B.depthTexture.needsUpdate = !0)),
      q(B.depthTexture, 0);
    const Se = r.get(B.depthTexture).__webglTexture,
      _e = Ne(B);
    if (B.depthTexture.format === df)
      Ie(B)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0,
            _e
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0
          );
    else if (B.depthTexture.format === _f)
      Ie(B)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0,
            _e
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function fe(ee) {
    const B = r.get(ee),
      ve = ee.isWebGLCubeRenderTarget === !0;
    if (ee.depthTexture && !B.__autoAllocateDepthBuffer) {
      if (ve)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      le(B.__webglFramebuffer, ee);
    } else if (ve) {
      B.__webglDepthbuffer = [];
      for (let Se = 0; Se < 6; Se++)
        t.bindFramebuffer(n.FRAMEBUFFER, B.__webglFramebuffer[Se]),
          (B.__webglDepthbuffer[Se] = n.createRenderbuffer()),
          de(B.__webglDepthbuffer[Se], ee, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, B.__webglFramebuffer),
        (B.__webglDepthbuffer = n.createRenderbuffer()),
        de(B.__webglDepthbuffer, ee, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ee(ee, B, ve) {
    const Se = r.get(ee);
    B !== void 0 &&
      oe(
        Se.__webglFramebuffer,
        ee,
        ee.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      ve !== void 0 && fe(ee);
  }
  function ge(ee) {
    const B = ee.texture,
      ve = r.get(ee),
      Se = r.get(B);
    ee.addEventListener("dispose", k);
    const _e = ee.textures,
      Te = ee.isWebGLCubeRenderTarget === !0,
      at = _e.length > 1;
    if (
      (at ||
        (Se.__webglTexture === void 0 &&
          (Se.__webglTexture = n.createTexture()),
        (Se.__version = B.version),
        s.memory.textures++),
      Te)
    ) {
      ve.__webglFramebuffer = [];
      for (let Fe = 0; Fe < 6; Fe++)
        if (B.mipmaps && B.mipmaps.length > 0) {
          ve.__webglFramebuffer[Fe] = [];
          for (let Be = 0; Be < B.mipmaps.length; Be++)
            ve.__webglFramebuffer[Fe][Be] = n.createFramebuffer();
        } else ve.__webglFramebuffer[Fe] = n.createFramebuffer();
    } else {
      if (B.mipmaps && B.mipmaps.length > 0) {
        ve.__webglFramebuffer = [];
        for (let Fe = 0; Fe < B.mipmaps.length; Fe++)
          ve.__webglFramebuffer[Fe] = n.createFramebuffer();
      } else ve.__webglFramebuffer = n.createFramebuffer();
      if (at)
        for (let Fe = 0, Be = _e.length; Fe < Be; Fe++) {
          const We = r.get(_e[Fe]);
          We.__webglTexture === void 0 &&
            ((We.__webglTexture = n.createTexture()), s.memory.textures++);
        }
      if (ee.samples > 0 && Ie(ee) === !1) {
        (ve.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (ve.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, ve.__webglMultisampledFramebuffer);
        for (let Fe = 0; Fe < _e.length; Fe++) {
          const Be = _e[Fe];
          (ve.__webglColorRenderbuffer[Fe] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, ve.__webglColorRenderbuffer[Fe]);
          const We = o.convert(Be.format, Be.colorSpace),
            Ye = o.convert(Be.type),
            nt = T(
              Be.internalFormat,
              We,
              Ye,
              Be.colorSpace,
              ee.isXRRenderTarget === !0
            ),
            yt = Ne(ee);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            yt,
            nt,
            ee.width,
            ee.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Fe,
              n.RENDERBUFFER,
              ve.__webglColorRenderbuffer[Fe]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          ee.depthBuffer &&
            ((ve.__webglDepthRenderbuffer = n.createRenderbuffer()),
            de(ve.__webglDepthRenderbuffer, ee, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (Te) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, Se.__webglTexture),
        V(n.TEXTURE_CUBE_MAP, B);
      for (let Fe = 0; Fe < 6; Fe++)
        if (B.mipmaps && B.mipmaps.length > 0)
          for (let Be = 0; Be < B.mipmaps.length; Be++)
            oe(
              ve.__webglFramebuffer[Fe][Be],
              ee,
              B,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe,
              Be
            );
        else
          oe(
            ve.__webglFramebuffer[Fe],
            ee,
            B,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe,
            0
          );
      _(B) && w(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (at) {
      for (let Fe = 0, Be = _e.length; Fe < Be; Fe++) {
        const We = _e[Fe],
          Ye = r.get(We);
        t.bindTexture(n.TEXTURE_2D, Ye.__webglTexture),
          V(n.TEXTURE_2D, We),
          oe(
            ve.__webglFramebuffer,
            ee,
            We,
            n.COLOR_ATTACHMENT0 + Fe,
            n.TEXTURE_2D,
            0
          ),
          _(We) && w(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Fe = n.TEXTURE_2D;
      if (
        ((ee.isWebGL3DRenderTarget || ee.isWebGLArrayRenderTarget) &&
          (Fe = ee.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Fe, Se.__webglTexture),
        V(Fe, B),
        B.mipmaps && B.mipmaps.length > 0)
      )
        for (let Be = 0; Be < B.mipmaps.length; Be++)
          oe(ve.__webglFramebuffer[Be], ee, B, n.COLOR_ATTACHMENT0, Fe, Be);
      else oe(ve.__webglFramebuffer, ee, B, n.COLOR_ATTACHMENT0, Fe, 0);
      _(B) && w(Fe), t.unbindTexture();
    }
    ee.depthBuffer && fe(ee);
  }
  function xe(ee) {
    const B = ee.textures;
    for (let ve = 0, Se = B.length; ve < Se; ve++) {
      const _e = B[ve];
      if (_(_e)) {
        const Te = ee.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          at = r.get(_e).__webglTexture;
        t.bindTexture(Te, at), w(Te), t.unbindTexture();
      }
    }
  }
  const j = [],
    we = [];
  function Ae(ee) {
    if (ee.samples > 0) {
      if (Ie(ee) === !1) {
        const B = ee.textures,
          ve = ee.width,
          Se = ee.height;
        let _e = n.COLOR_BUFFER_BIT;
        const Te = ee.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          at = r.get(ee),
          Fe = B.length > 1;
        if (Fe)
          for (let Be = 0; Be < B.length; Be++)
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          at.__webglMultisampledFramebuffer
        ),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, at.__webglFramebuffer);
        for (let Be = 0; Be < B.length; Be++) {
          if (
            (ee.resolveDepthBuffer &&
              (ee.depthBuffer && (_e |= n.DEPTH_BUFFER_BIT),
              ee.stencilBuffer &&
                ee.resolveStencilBuffer &&
                (_e |= n.STENCIL_BUFFER_BIT)),
            Fe)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              at.__webglColorRenderbuffer[Be]
            );
            const We = r.get(B[Be]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              We,
              0
            );
          }
          n.blitFramebuffer(0, 0, ve, Se, 0, 0, ve, Se, _e, n.NEAREST),
            u === !0 &&
              ((j.length = 0),
              (we.length = 0),
              j.push(n.COLOR_ATTACHMENT0 + Be),
              ee.depthBuffer &&
                ee.resolveDepthBuffer === !1 &&
                (j.push(Te),
                we.push(Te),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, we)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, j));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Fe)
        )
          for (let Be = 0; Be < B.length; Be++) {
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.RENDERBUFFER,
                at.__webglColorRenderbuffer[Be]
              );
            const We = r.get(B[Be]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.TEXTURE_2D,
                We,
                0
              );
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          at.__webglMultisampledFramebuffer
        );
      } else if (ee.depthBuffer && ee.resolveDepthBuffer === !1 && u) {
        const B = ee.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [B]);
      }
    }
  }
  function Ne(ee) {
    return Math.min(i.maxSamples, ee.samples);
  }
  function Ie(ee) {
    const B = r.get(ee);
    return (
      ee.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      B.__useRenderToTexture !== !1
    );
  }
  function rt(ee) {
    const B = s.render.frame;
    h.get(ee) !== B && (h.set(ee, B), ee.update());
  }
  function ke(ee, B) {
    const ve = ee.colorSpace,
      Se = ee.format,
      _e = ee.type;
    return (
      ee.isCompressedTexture === !0 ||
        ee.isVideoTexture === !0 ||
        (ve !== Fl &&
          ve !== Cl &&
          (yn.getTransfer(ve) === Zn
            ? (Se !== Ji || _e !== aa) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ve
              ))),
      B
    );
  }
  function Xe(ee) {
    return (
      typeof HTMLImageElement < "u" && ee instanceof HTMLImageElement
        ? ((f.width = ee.naturalWidth || ee.width),
          (f.height = ee.naturalHeight || ee.height))
        : typeof VideoFrame < "u" && ee instanceof VideoFrame
        ? ((f.width = ee.displayWidth), (f.height = ee.displayHeight))
        : ((f.width = ee.width), (f.height = ee.height)),
      f
    );
  }
  (this.allocateTextureUnit = G),
    (this.resetTextureUnits = H),
    (this.setTexture2D = q),
    (this.setTexture2DArray = Z),
    (this.setTexture3D = X),
    (this.setTextureCube = re),
    (this.rebindTextures = Ee),
    (this.setupRenderTarget = ge),
    (this.updateRenderTargetMipmap = xe),
    (this.updateMultisampleRenderTarget = Ae),
    (this.setupDepthRenderbuffer = fe),
    (this.setupFrameBufferTexture = oe),
    (this.useMultisampledRTT = Ie);
}
function rR(n, e) {
  function t(r, i = Cl) {
    let o;
    const s = yn.getTransfer(i);
    if (r === aa) return n.UNSIGNED_BYTE;
    if (r === Dy) return n.UNSIGNED_SHORT_4_4_4_4;
    if (r === Ny) return n.UNSIGNED_SHORT_5_5_5_1;
    if (r === ow) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (r === rw) return n.BYTE;
    if (r === iw) return n.SHORT;
    if (r === Mh) return n.UNSIGNED_SHORT;
    if (r === ky) return n.INT;
    if (r === Nl) return n.UNSIGNED_INT;
    if (r === Oo) return n.FLOAT;
    if (r === Oh) return n.HALF_FLOAT;
    if (r === sw) return n.ALPHA;
    if (r === aw) return n.RGB;
    if (r === Ji) return n.RGBA;
    if (r === lw) return n.LUMINANCE;
    if (r === uw) return n.LUMINANCE_ALPHA;
    if (r === df) return n.DEPTH_COMPONENT;
    if (r === _f) return n.DEPTH_STENCIL;
    if (r === Oy) return n.RED;
    if (r === Jm) return n.RED_INTEGER;
    if (r === cw) return n.RG;
    if (r === Uy) return n.RG_INTEGER;
    if (r === Fy) return n.RGBA_INTEGER;
    if (r === lm || r === um || r === cm || r === fm)
      if (s === Zn)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (r === lm) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === um) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === cm) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === fm) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (r === lm) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === um) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === cm) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === fm) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === I0 || r === L0 || r === k0 || r === D0)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (r === I0) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === L0) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === k0) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === D0) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === N0 || r === O0 || r === U0)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (r === N0 || r === O0)
          return s === Zn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === U0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === F0 ||
      r === B0 ||
      r === z0 ||
      r === H0 ||
      r === V0 ||
      r === G0 ||
      r === W0 ||
      r === j0 ||
      r === $0 ||
      r === X0 ||
      r === Y0 ||
      r === q0 ||
      r === K0 ||
      r === Z0
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (r === F0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === B0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === z0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === H0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === V0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === G0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === W0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === j0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === $0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === X0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === Y0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === q0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === K0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === Z0)
          return s === Zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === dm || r === J0 || r === Q0)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (r === dm)
          return s === Zn
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === J0) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === Q0) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (r === fw || r === ey || r === ty || r === ny)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (r === dm) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === ey) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === ty) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === ny) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === xf ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null;
  }
  return { convert: t };
}
class iR extends Or {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ch extends _n {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const pV = { type: "move" };
class X_ {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new ch()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new ch()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new se()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new se())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new ch()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new se()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new se())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let i = null,
      o = null,
      s = null;
    const l = this._targetRay,
      u = this._grip,
      f = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        s = !0;
        for (const S of e.hand.values()) {
          const _ = t.getJointPose(S, r),
            w = this._getHandJoint(f, S);
          _ !== null &&
            (w.matrix.fromArray(_.transform.matrix),
            w.matrix.decompose(w.position, w.rotation, w.scale),
            (w.matrixWorldNeedsUpdate = !0),
            (w.jointRadius = _.radius)),
            (w.visible = _ !== null);
        }
        const h = f.joints["index-finger-tip"],
          m = f.joints["thumb-tip"],
          g = h.position.distanceTo(m.position),
          y = 0.02,
          x = 0.005;
        f.inputState.pinching && g > y + x
          ? ((f.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !f.inputState.pinching &&
            g <= y - x &&
            ((f.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        u !== null &&
          e.gripSpace &&
          ((o = t.getPose(e.gripSpace, r)),
          o !== null &&
            (u.matrix.fromArray(o.transform.matrix),
            u.matrix.decompose(u.position, u.rotation, u.scale),
            (u.matrixWorldNeedsUpdate = !0),
            o.linearVelocity
              ? ((u.hasLinearVelocity = !0),
                u.linearVelocity.copy(o.linearVelocity))
              : (u.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((u.hasAngularVelocity = !0),
                u.angularVelocity.copy(o.angularVelocity))
              : (u.hasAngularVelocity = !1)));
      l !== null &&
        ((i = t.getPose(e.targetRaySpace, r)),
        i === null && o !== null && (i = o),
        i !== null &&
          (l.matrix.fromArray(i.transform.matrix),
          l.matrix.decompose(l.position, l.rotation, l.scale),
          (l.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((l.hasLinearVelocity = !0),
              l.linearVelocity.copy(i.linearVelocity))
            : (l.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((l.hasAngularVelocity = !0),
              l.angularVelocity.copy(i.angularVelocity))
            : (l.hasAngularVelocity = !1),
          this.dispatchEvent(pV)));
    }
    return (
      l !== null && (l.visible = i !== null),
      u !== null && (u.visible = o !== null),
      f !== null && (f.visible = s !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new ch();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
const mV = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  gV = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class vV {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, r) {
    if (this.texture === null) {
      const i = new Qn(),
        o = e.properties.get(i);
      (o.__webglTexture = t.texture),
        (t.depthNear != r.depthNear || t.depthFar != r.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        r = new ua({
          vertexShader: mV,
          fragmentShader: gV,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new vr(new Hl(20, 20), r);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class yV extends Bl {
  constructor(e, t) {
    super();
    const r = this;
    let i = null,
      o = 1,
      s = null,
      l = "local-floor",
      u = 1,
      f = null,
      h = null,
      m = null,
      g = null,
      y = null,
      x = null;
    const S = new vV(),
      _ = t.getContextAttributes();
    let w = null,
      T = null;
    const E = [],
      A = [],
      R = new tt();
    let k = null;
    const P = new Or();
    P.layers.enable(1), (P.viewport = new Tn());
    const U = new Or();
    U.layers.enable(2), (U.viewport = new Tn());
    const N = [P, U],
      L = new iR();
    L.layers.enable(1), L.layers.enable(2);
    let H = null,
      G = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (J) {
        let oe = E[J];
        return (
          oe === void 0 && ((oe = new X_()), (E[J] = oe)),
          oe.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (J) {
        let oe = E[J];
        return (
          oe === void 0 && ((oe = new X_()), (E[J] = oe)), oe.getGripSpace()
        );
      }),
      (this.getHand = function (J) {
        let oe = E[J];
        return (
          oe === void 0 && ((oe = new X_()), (E[J] = oe)), oe.getHandSpace()
        );
      });
    function $(J) {
      const oe = A.indexOf(J.inputSource);
      if (oe === -1) return;
      const de = E[oe];
      de !== void 0 &&
        (de.update(J.inputSource, J.frame, f || s),
        de.dispatchEvent({ type: J.type, data: J.inputSource }));
    }
    function q() {
      i.removeEventListener("select", $),
        i.removeEventListener("selectstart", $),
        i.removeEventListener("selectend", $),
        i.removeEventListener("squeeze", $),
        i.removeEventListener("squeezestart", $),
        i.removeEventListener("squeezeend", $),
        i.removeEventListener("end", q),
        i.removeEventListener("inputsourceschange", Z);
      for (let J = 0; J < E.length; J++) {
        const oe = A[J];
        oe !== null && ((A[J] = null), E[J].disconnect(oe));
      }
      (H = null),
        (G = null),
        S.reset(),
        e.setRenderTarget(w),
        (y = null),
        (g = null),
        (m = null),
        (i = null),
        (T = null),
        ae.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(k),
        e.setSize(R.width, R.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (J) {
      (o = J),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (J) {
        (l = J),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return f || s;
      }),
      (this.setReferenceSpace = function (J) {
        f = J;
      }),
      (this.getBaseLayer = function () {
        return g !== null ? g : y;
      }),
      (this.getBinding = function () {
        return m;
      }),
      (this.getFrame = function () {
        return x;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (J) {
        if (((i = J), i !== null)) {
          if (
            ((w = e.getRenderTarget()),
            i.addEventListener("select", $),
            i.addEventListener("selectstart", $),
            i.addEventListener("selectend", $),
            i.addEventListener("squeeze", $),
            i.addEventListener("squeezestart", $),
            i.addEventListener("squeezeend", $),
            i.addEventListener("end", q),
            i.addEventListener("inputsourceschange", Z),
            _.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (k = e.getPixelRatio()),
            e.getSize(R),
            i.renderState.layers === void 0)
          ) {
            const oe = {
              antialias: _.antialias,
              alpha: !0,
              depth: _.depth,
              stencil: _.stencil,
              framebufferScaleFactor: o,
            };
            (y = new XRWebGLLayer(i, t, oe)),
              i.updateRenderState({ baseLayer: y }),
              e.setPixelRatio(1),
              e.setSize(y.framebufferWidth, y.framebufferHeight, !1),
              (T = new la(y.framebufferWidth, y.framebufferHeight, {
                format: Ji,
                type: aa,
                colorSpace: e.outputColorSpace,
                stencilBuffer: _.stencil,
              }));
          } else {
            let oe = null,
              de = null,
              le = null;
            _.depth &&
              ((le = _.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (oe = _.stencil ? _f : df),
              (de = _.stencil ? xf : Nl));
            const fe = {
              colorFormat: t.RGBA8,
              depthFormat: le,
              scaleFactor: o,
            };
            (m = new XRWebGLBinding(i, t)),
              (g = m.createProjectionLayer(fe)),
              i.updateRenderState({ layers: [g] }),
              e.setPixelRatio(1),
              e.setSize(g.textureWidth, g.textureHeight, !1),
              (T = new la(g.textureWidth, g.textureHeight, {
                format: Ji,
                type: aa,
                depthTexture: new Sw(
                  g.textureWidth,
                  g.textureHeight,
                  de,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  oe
                ),
                stencilBuffer: _.stencil,
                colorSpace: e.outputColorSpace,
                samples: _.antialias ? 4 : 0,
                resolveDepthBuffer: g.ignoreDepthValues === !1,
              }));
          }
          (T.isXRRenderTarget = !0),
            this.setFoveation(u),
            (f = null),
            (s = await i.requestReferenceSpace(l)),
            ae.setContext(i),
            ae.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return S.getDepthTexture();
      });
    function Z(J) {
      for (let oe = 0; oe < J.removed.length; oe++) {
        const de = J.removed[oe],
          le = A.indexOf(de);
        le >= 0 && ((A[le] = null), E[le].disconnect(de));
      }
      for (let oe = 0; oe < J.added.length; oe++) {
        const de = J.added[oe];
        let le = A.indexOf(de);
        if (le === -1) {
          for (let Ee = 0; Ee < E.length; Ee++)
            if (Ee >= A.length) {
              A.push(de), (le = Ee);
              break;
            } else if (A[Ee] === null) {
              (A[Ee] = de), (le = Ee);
              break;
            }
          if (le === -1) break;
        }
        const fe = E[le];
        fe && fe.connect(de);
      }
    }
    const X = new se(),
      re = new se();
    function W(J, oe, de) {
      X.setFromMatrixPosition(oe.matrixWorld),
        re.setFromMatrixPosition(de.matrixWorld);
      const le = X.distanceTo(re),
        fe = oe.projectionMatrix.elements,
        Ee = de.projectionMatrix.elements,
        ge = fe[14] / (fe[10] - 1),
        xe = fe[14] / (fe[10] + 1),
        j = (fe[9] + 1) / fe[5],
        we = (fe[9] - 1) / fe[5],
        Ae = (fe[8] - 1) / fe[0],
        Ne = (Ee[8] + 1) / Ee[0],
        Ie = ge * Ae,
        rt = ge * Ne,
        ke = le / (-Ae + Ne),
        Xe = ke * -Ae;
      oe.matrixWorld.decompose(J.position, J.quaternion, J.scale),
        J.translateX(Xe),
        J.translateZ(ke),
        J.matrixWorld.compose(J.position, J.quaternion, J.scale),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
      const ee = ge + ke,
        B = xe + ke,
        ve = Ie - Xe,
        Se = rt + (le - Xe),
        _e = ((j * xe) / B) * ee,
        Te = ((we * xe) / B) * ee;
      J.projectionMatrix.makePerspective(ve, Se, _e, Te, ee, B),
        J.projectionMatrixInverse.copy(J.projectionMatrix).invert();
    }
    function te(J, oe) {
      oe === null
        ? J.matrixWorld.copy(J.matrix)
        : J.matrixWorld.multiplyMatrices(oe.matrixWorld, J.matrix),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
    }
    this.updateCamera = function (J) {
      if (i === null) return;
      S.texture !== null && ((J.near = S.depthNear), (J.far = S.depthFar)),
        (L.near = U.near = P.near = J.near),
        (L.far = U.far = P.far = J.far),
        (H !== L.near || G !== L.far) &&
          (i.updateRenderState({ depthNear: L.near, depthFar: L.far }),
          (H = L.near),
          (G = L.far),
          (P.near = H),
          (P.far = G),
          (U.near = H),
          (U.far = G),
          P.updateProjectionMatrix(),
          U.updateProjectionMatrix(),
          J.updateProjectionMatrix());
      const oe = J.parent,
        de = L.cameras;
      te(L, oe);
      for (let le = 0; le < de.length; le++) te(de[le], oe);
      de.length === 2
        ? W(L, P, U)
        : L.projectionMatrix.copy(P.projectionMatrix),
        F(J, L, oe);
    };
    function F(J, oe, de) {
      de === null
        ? J.matrix.copy(oe.matrixWorld)
        : (J.matrix.copy(de.matrixWorld),
          J.matrix.invert(),
          J.matrix.multiply(oe.matrixWorld)),
        J.matrix.decompose(J.position, J.quaternion, J.scale),
        J.updateMatrixWorld(!0),
        J.projectionMatrix.copy(oe.projectionMatrix),
        J.projectionMatrixInverse.copy(oe.projectionMatrixInverse),
        J.isPerspectiveCamera &&
          ((J.fov = Eh * 2 * Math.atan(1 / J.projectionMatrix.elements[5])),
          (J.zoom = 1));
    }
    (this.getCamera = function () {
      return L;
    }),
      (this.getFoveation = function () {
        if (!(g === null && y === null)) return u;
      }),
      (this.setFoveation = function (J) {
        (u = J),
          g !== null && (g.fixedFoveation = J),
          y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = J);
      }),
      (this.hasDepthSensing = function () {
        return S.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return S.getMesh(L);
      });
    let V = null;
    function ne(J, oe) {
      if (((h = oe.getViewerPose(f || s)), (x = oe), h !== null)) {
        const de = h.views;
        y !== null &&
          (e.setRenderTargetFramebuffer(T, y.framebuffer),
          e.setRenderTarget(T));
        let le = !1;
        de.length !== L.cameras.length && ((L.cameras.length = 0), (le = !0));
        for (let Ee = 0; Ee < de.length; Ee++) {
          const ge = de[Ee];
          let xe = null;
          if (y !== null) xe = y.getViewport(ge);
          else {
            const we = m.getViewSubImage(g, ge);
            (xe = we.viewport),
              Ee === 0 &&
                (e.setRenderTargetTextures(
                  T,
                  we.colorTexture,
                  g.ignoreDepthValues ? void 0 : we.depthStencilTexture
                ),
                e.setRenderTarget(T));
          }
          let j = N[Ee];
          j === void 0 &&
            ((j = new Or()),
            j.layers.enable(Ee),
            (j.viewport = new Tn()),
            (N[Ee] = j)),
            j.matrix.fromArray(ge.transform.matrix),
            j.matrix.decompose(j.position, j.quaternion, j.scale),
            j.projectionMatrix.fromArray(ge.projectionMatrix),
            j.projectionMatrixInverse.copy(j.projectionMatrix).invert(),
            j.viewport.set(xe.x, xe.y, xe.width, xe.height),
            Ee === 0 &&
              (L.matrix.copy(j.matrix),
              L.matrix.decompose(L.position, L.quaternion, L.scale)),
            le === !0 && L.cameras.push(j);
        }
        const fe = i.enabledFeatures;
        if (fe && fe.includes("depth-sensing")) {
          const Ee = m.getDepthInformation(de[0]);
          Ee && Ee.isValid && Ee.texture && S.init(e, Ee, i.renderState);
        }
      }
      for (let de = 0; de < E.length; de++) {
        const le = A[de],
          fe = E[de];
        le !== null && fe !== void 0 && fe.update(le, oe, f || s);
      }
      V && V(J, oe),
        oe.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: oe }),
        (x = null);
    }
    const ae = new JA();
    ae.setAnimationLoop(ne),
      (this.setAnimationLoop = function (J) {
        V = J;
      }),
      (this.dispose = function () {});
  }
}
const Uc = new as(),
  xV = new Wt();
function _V(n, e) {
  function t(_, w) {
    _.matrixAutoUpdate === !0 && _.updateMatrix(), w.value.copy(_.matrix);
  }
  function r(_, w) {
    w.color.getRGB(_.fogColor.value, qA(n)),
      w.isFog
        ? ((_.fogNear.value = w.near), (_.fogFar.value = w.far))
        : w.isFogExp2 && (_.fogDensity.value = w.density);
  }
  function i(_, w, T, E, A) {
    w.isMeshBasicMaterial || w.isMeshLambertMaterial
      ? o(_, w)
      : w.isMeshToonMaterial
      ? (o(_, w), m(_, w))
      : w.isMeshPhongMaterial
      ? (o(_, w), h(_, w))
      : w.isMeshStandardMaterial
      ? (o(_, w), g(_, w), w.isMeshPhysicalMaterial && y(_, w, A))
      : w.isMeshMatcapMaterial
      ? (o(_, w), x(_, w))
      : w.isMeshDepthMaterial
      ? o(_, w)
      : w.isMeshDistanceMaterial
      ? (o(_, w), S(_, w))
      : w.isMeshNormalMaterial
      ? o(_, w)
      : w.isLineBasicMaterial
      ? (s(_, w), w.isLineDashedMaterial && l(_, w))
      : w.isPointsMaterial
      ? u(_, w, T, E)
      : w.isSpriteMaterial
      ? f(_, w)
      : w.isShadowMaterial
      ? (_.color.value.copy(w.color), (_.opacity.value = w.opacity))
      : w.isShaderMaterial && (w.uniformsNeedUpdate = !1);
  }
  function o(_, w) {
    (_.opacity.value = w.opacity),
      w.color && _.diffuse.value.copy(w.color),
      w.emissive &&
        _.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity),
      w.map && ((_.map.value = w.map), t(w.map, _.mapTransform)),
      w.alphaMap &&
        ((_.alphaMap.value = w.alphaMap), t(w.alphaMap, _.alphaMapTransform)),
      w.bumpMap &&
        ((_.bumpMap.value = w.bumpMap),
        t(w.bumpMap, _.bumpMapTransform),
        (_.bumpScale.value = w.bumpScale),
        w.side === Qi && (_.bumpScale.value *= -1)),
      w.normalMap &&
        ((_.normalMap.value = w.normalMap),
        t(w.normalMap, _.normalMapTransform),
        _.normalScale.value.copy(w.normalScale),
        w.side === Qi && _.normalScale.value.negate()),
      w.displacementMap &&
        ((_.displacementMap.value = w.displacementMap),
        t(w.displacementMap, _.displacementMapTransform),
        (_.displacementScale.value = w.displacementScale),
        (_.displacementBias.value = w.displacementBias)),
      w.emissiveMap &&
        ((_.emissiveMap.value = w.emissiveMap),
        t(w.emissiveMap, _.emissiveMapTransform)),
      w.specularMap &&
        ((_.specularMap.value = w.specularMap),
        t(w.specularMap, _.specularMapTransform)),
      w.alphaTest > 0 && (_.alphaTest.value = w.alphaTest);
    const T = e.get(w),
      E = T.envMap,
      A = T.envMapRotation;
    E &&
      ((_.envMap.value = E),
      Uc.copy(A),
      (Uc.x *= -1),
      (Uc.y *= -1),
      (Uc.z *= -1),
      E.isCubeTexture &&
        E.isRenderTargetTexture === !1 &&
        ((Uc.y *= -1), (Uc.z *= -1)),
      _.envMapRotation.value.setFromMatrix4(xV.makeRotationFromEuler(Uc)),
      (_.flipEnvMap.value =
        E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1),
      (_.reflectivity.value = w.reflectivity),
      (_.ior.value = w.ior),
      (_.refractionRatio.value = w.refractionRatio)),
      w.lightMap &&
        ((_.lightMap.value = w.lightMap),
        (_.lightMapIntensity.value = w.lightMapIntensity),
        t(w.lightMap, _.lightMapTransform)),
      w.aoMap &&
        ((_.aoMap.value = w.aoMap),
        (_.aoMapIntensity.value = w.aoMapIntensity),
        t(w.aoMap, _.aoMapTransform));
  }
  function s(_, w) {
    _.diffuse.value.copy(w.color),
      (_.opacity.value = w.opacity),
      w.map && ((_.map.value = w.map), t(w.map, _.mapTransform));
  }
  function l(_, w) {
    (_.dashSize.value = w.dashSize),
      (_.totalSize.value = w.dashSize + w.gapSize),
      (_.scale.value = w.scale);
  }
  function u(_, w, T, E) {
    _.diffuse.value.copy(w.color),
      (_.opacity.value = w.opacity),
      (_.size.value = w.size * T),
      (_.scale.value = E * 0.5),
      w.map && ((_.map.value = w.map), t(w.map, _.uvTransform)),
      w.alphaMap &&
        ((_.alphaMap.value = w.alphaMap), t(w.alphaMap, _.alphaMapTransform)),
      w.alphaTest > 0 && (_.alphaTest.value = w.alphaTest);
  }
  function f(_, w) {
    _.diffuse.value.copy(w.color),
      (_.opacity.value = w.opacity),
      (_.rotation.value = w.rotation),
      w.map && ((_.map.value = w.map), t(w.map, _.mapTransform)),
      w.alphaMap &&
        ((_.alphaMap.value = w.alphaMap), t(w.alphaMap, _.alphaMapTransform)),
      w.alphaTest > 0 && (_.alphaTest.value = w.alphaTest);
  }
  function h(_, w) {
    _.specular.value.copy(w.specular),
      (_.shininess.value = Math.max(w.shininess, 1e-4));
  }
  function m(_, w) {
    w.gradientMap && (_.gradientMap.value = w.gradientMap);
  }
  function g(_, w) {
    (_.metalness.value = w.metalness),
      w.metalnessMap &&
        ((_.metalnessMap.value = w.metalnessMap),
        t(w.metalnessMap, _.metalnessMapTransform)),
      (_.roughness.value = w.roughness),
      w.roughnessMap &&
        ((_.roughnessMap.value = w.roughnessMap),
        t(w.roughnessMap, _.roughnessMapTransform)),
      w.envMap && (_.envMapIntensity.value = w.envMapIntensity);
  }
  function y(_, w, T) {
    (_.ior.value = w.ior),
      w.sheen > 0 &&
        (_.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen),
        (_.sheenRoughness.value = w.sheenRoughness),
        w.sheenColorMap &&
          ((_.sheenColorMap.value = w.sheenColorMap),
          t(w.sheenColorMap, _.sheenColorMapTransform)),
        w.sheenRoughnessMap &&
          ((_.sheenRoughnessMap.value = w.sheenRoughnessMap),
          t(w.sheenRoughnessMap, _.sheenRoughnessMapTransform))),
      w.clearcoat > 0 &&
        ((_.clearcoat.value = w.clearcoat),
        (_.clearcoatRoughness.value = w.clearcoatRoughness),
        w.clearcoatMap &&
          ((_.clearcoatMap.value = w.clearcoatMap),
          t(w.clearcoatMap, _.clearcoatMapTransform)),
        w.clearcoatRoughnessMap &&
          ((_.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap),
          t(w.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)),
        w.clearcoatNormalMap &&
          ((_.clearcoatNormalMap.value = w.clearcoatNormalMap),
          t(w.clearcoatNormalMap, _.clearcoatNormalMapTransform),
          _.clearcoatNormalScale.value.copy(w.clearcoatNormalScale),
          w.side === Qi && _.clearcoatNormalScale.value.negate())),
      w.dispersion > 0 && (_.dispersion.value = w.dispersion),
      w.iridescence > 0 &&
        ((_.iridescence.value = w.iridescence),
        (_.iridescenceIOR.value = w.iridescenceIOR),
        (_.iridescenceThicknessMinimum.value = w.iridescenceThicknessRange[0]),
        (_.iridescenceThicknessMaximum.value = w.iridescenceThicknessRange[1]),
        w.iridescenceMap &&
          ((_.iridescenceMap.value = w.iridescenceMap),
          t(w.iridescenceMap, _.iridescenceMapTransform)),
        w.iridescenceThicknessMap &&
          ((_.iridescenceThicknessMap.value = w.iridescenceThicknessMap),
          t(w.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))),
      w.transmission > 0 &&
        ((_.transmission.value = w.transmission),
        (_.transmissionSamplerMap.value = T.texture),
        _.transmissionSamplerSize.value.set(T.width, T.height),
        w.transmissionMap &&
          ((_.transmissionMap.value = w.transmissionMap),
          t(w.transmissionMap, _.transmissionMapTransform)),
        (_.thickness.value = w.thickness),
        w.thicknessMap &&
          ((_.thicknessMap.value = w.thicknessMap),
          t(w.thicknessMap, _.thicknessMapTransform)),
        (_.attenuationDistance.value = w.attenuationDistance),
        _.attenuationColor.value.copy(w.attenuationColor)),
      w.anisotropy > 0 &&
        (_.anisotropyVector.value.set(
          w.anisotropy * Math.cos(w.anisotropyRotation),
          w.anisotropy * Math.sin(w.anisotropyRotation)
        ),
        w.anisotropyMap &&
          ((_.anisotropyMap.value = w.anisotropyMap),
          t(w.anisotropyMap, _.anisotropyMapTransform))),
      (_.specularIntensity.value = w.specularIntensity),
      _.specularColor.value.copy(w.specularColor),
      w.specularColorMap &&
        ((_.specularColorMap.value = w.specularColorMap),
        t(w.specularColorMap, _.specularColorMapTransform)),
      w.specularIntensityMap &&
        ((_.specularIntensityMap.value = w.specularIntensityMap),
        t(w.specularIntensityMap, _.specularIntensityMapTransform));
  }
  function x(_, w) {
    w.matcap && (_.matcap.value = w.matcap);
  }
  function S(_, w) {
    const T = e.get(w).light;
    _.referencePosition.value.setFromMatrixPosition(T.matrixWorld),
      (_.nearDistance.value = T.shadow.camera.near),
      (_.farDistance.value = T.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function SV(n, e, t, r) {
  let i = {},
    o = {},
    s = [];
  const l = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(T, E) {
    const A = E.program;
    r.uniformBlockBinding(T, A);
  }
  function f(T, E) {
    let A = i[T.id];
    A === void 0 &&
      (x(T), (A = h(T)), (i[T.id] = A), T.addEventListener("dispose", _));
    const R = E.program;
    r.updateUBOMapping(T, R);
    const k = e.render.frame;
    o[T.id] !== k && (g(T), (o[T.id] = k));
  }
  function h(T) {
    const E = m();
    T.__bindingPointIndex = E;
    const A = n.createBuffer(),
      R = T.__size,
      k = T.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, A),
      n.bufferData(n.UNIFORM_BUFFER, R, k),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, E, A),
      A
    );
  }
  function m() {
    for (let T = 0; T < l; T++) if (s.indexOf(T) === -1) return s.push(T), T;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function g(T) {
    const E = i[T.id],
      A = T.uniforms,
      R = T.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, E);
    for (let k = 0, P = A.length; k < P; k++) {
      const U = Array.isArray(A[k]) ? A[k] : [A[k]];
      for (let N = 0, L = U.length; N < L; N++) {
        const H = U[N];
        if (y(H, k, N, R) === !0) {
          const G = H.__offset,
            $ = Array.isArray(H.value) ? H.value : [H.value];
          let q = 0;
          for (let Z = 0; Z < $.length; Z++) {
            const X = $[Z],
              re = S(X);
            typeof X == "number" || typeof X == "boolean"
              ? ((H.__data[0] = X),
                n.bufferSubData(n.UNIFORM_BUFFER, G + q, H.__data))
              : X.isMatrix3
              ? ((H.__data[0] = X.elements[0]),
                (H.__data[1] = X.elements[1]),
                (H.__data[2] = X.elements[2]),
                (H.__data[3] = 0),
                (H.__data[4] = X.elements[3]),
                (H.__data[5] = X.elements[4]),
                (H.__data[6] = X.elements[5]),
                (H.__data[7] = 0),
                (H.__data[8] = X.elements[6]),
                (H.__data[9] = X.elements[7]),
                (H.__data[10] = X.elements[8]),
                (H.__data[11] = 0))
              : (X.toArray(H.__data, q),
                (q += re.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, G, H.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function y(T, E, A, R) {
    const k = T.value,
      P = E + "_" + A;
    if (R[P] === void 0)
      return (
        typeof k == "number" || typeof k == "boolean"
          ? (R[P] = k)
          : (R[P] = k.clone()),
        !0
      );
    {
      const U = R[P];
      if (typeof k == "number" || typeof k == "boolean") {
        if (U !== k) return (R[P] = k), !0;
      } else if (U.equals(k) === !1) return U.copy(k), !0;
    }
    return !1;
  }
  function x(T) {
    const E = T.uniforms;
    let A = 0;
    const R = 16;
    for (let P = 0, U = E.length; P < U; P++) {
      const N = Array.isArray(E[P]) ? E[P] : [E[P]];
      for (let L = 0, H = N.length; L < H; L++) {
        const G = N[L],
          $ = Array.isArray(G.value) ? G.value : [G.value];
        for (let q = 0, Z = $.length; q < Z; q++) {
          const X = $[q],
            re = S(X),
            W = A % R,
            te = W % re.boundary,
            F = W + te;
          (A += te),
            F !== 0 && R - F < re.storage && (A += R - F),
            (G.__data = new Float32Array(
              re.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (G.__offset = A),
            (A += re.storage);
        }
      }
    }
    const k = A % R;
    return k > 0 && (A += R - k), (T.__size = A), (T.__cache = {}), this;
  }
  function S(T) {
    const E = { boundary: 0, storage: 0 };
    return (
      typeof T == "number" || typeof T == "boolean"
        ? ((E.boundary = 4), (E.storage = 4))
        : T.isVector2
        ? ((E.boundary = 8), (E.storage = 8))
        : T.isVector3 || T.isColor
        ? ((E.boundary = 16), (E.storage = 12))
        : T.isVector4
        ? ((E.boundary = 16), (E.storage = 16))
        : T.isMatrix3
        ? ((E.boundary = 48), (E.storage = 48))
        : T.isMatrix4
        ? ((E.boundary = 64), (E.storage = 64))
        : T.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            T
          ),
      E
    );
  }
  function _(T) {
    const E = T.target;
    E.removeEventListener("dispose", _);
    const A = s.indexOf(E.__bindingPointIndex);
    s.splice(A, 1), n.deleteBuffer(i[E.id]), delete i[E.id], delete o[E.id];
  }
  function w() {
    for (const T in i) n.deleteBuffer(i[T]);
    (s = []), (i = {}), (o = {});
  }
  return { bind: u, update: f, dispose: w };
}
class oR {
  constructor(e = {}) {
    const {
      canvas: t = jA(),
      context: r = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: s = !1,
      antialias: l = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: f = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: m = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let g;
    if (r !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        r instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      g = r.getContextAttributes().alpha;
    } else g = s;
    const y = new Uint32Array(4),
      x = new Int32Array(4);
    let S = null,
      _ = null;
    const w = [],
      T = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Ms),
      (this.toneMapping = Ga),
      (this.toneMappingExposure = 1);
    const E = this;
    let A = !1,
      R = 0,
      k = 0,
      P = null,
      U = -1,
      N = null;
    const L = new Tn(),
      H = new Tn();
    let G = null;
    const $ = new St(0);
    let q = 0,
      Z = t.width,
      X = t.height,
      re = 1,
      W = null,
      te = null;
    const F = new Tn(0, 0, Z, X),
      V = new Tn(0, 0, Z, X);
    let ne = !1;
    const ae = new ng();
    let J = !1,
      oe = !1;
    const de = new Wt(),
      le = new se(),
      fe = new Tn(),
      Ee = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let ge = !1;
    function xe() {
      return P === null ? re : 1;
    }
    let j = r;
    function we(ie, Ce) {
      return t.getContext(ie, Ce);
    }
    try {
      const ie = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: l,
        premultipliedAlpha: u,
        preserveDrawingBuffer: f,
        powerPreference: h,
        failIfMajorPerformanceCaveat: m,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Py}`),
        t.addEventListener("webglcontextlost", Re, !1),
        t.addEventListener("webglcontextrestored", Ue, !1),
        t.addEventListener("webglcontextcreationerror", it, !1),
        j === null)
      ) {
        const Ce = "webgl2";
        if (((j = we(Ce, ie)), j === null))
          throw we(Ce)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (ie) {
      throw (console.error("THREE.WebGLRenderer: " + ie.message), ie);
    }
    let Ae,
      Ne,
      Ie,
      rt,
      ke,
      Xe,
      ee,
      B,
      ve,
      Se,
      _e,
      Te,
      at,
      Fe,
      Be,
      We,
      Ye,
      nt,
      yt,
      $e,
      qe,
      et,
      he,
      Je;
    function me() {
      (Ae = new A6(j)),
        Ae.init(),
        (et = new rR(j, Ae)),
        (Ne = new w6(j, Ae, e, et)),
        (Ie = new aV(j)),
        (rt = new I6(j)),
        (ke = new qH()),
        (Xe = new hV(j, Ae, Ie, ke, Ne, et, rt)),
        (ee = new M6(E)),
        (B = new C6(E)),
        (ve = new FB(j)),
        (he = new _6(j, ve)),
        (Se = new R6(j, ve, rt, he)),
        (_e = new k6(j, Se, ve, rt)),
        (yt = new L6(j, Ne, Xe)),
        (We = new b6(ke)),
        (Te = new YH(E, ee, B, Ae, Ne, he, We)),
        (at = new _V(E, ke)),
        (Fe = new ZH()),
        (Be = new rV(Ae)),
        (nt = new x6(E, ee, B, Ie, _e, g, u)),
        (Ye = new sV(E, _e, Ne)),
        (Je = new SV(j, rt, Ne, Ie)),
        ($e = new S6(j, Ae, rt)),
        (qe = new P6(j, Ae, rt)),
        (rt.programs = Te.programs),
        (E.capabilities = Ne),
        (E.extensions = Ae),
        (E.properties = ke),
        (E.renderLists = Fe),
        (E.shadowMap = Ye),
        (E.state = Ie),
        (E.info = rt);
    }
    me();
    const Ve = new yV(E, j);
    (this.xr = Ve),
      (this.getContext = function () {
        return j;
      }),
      (this.getContextAttributes = function () {
        return j.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const ie = Ae.get("WEBGL_lose_context");
        ie && ie.loseContext();
      }),
      (this.forceContextRestore = function () {
        const ie = Ae.get("WEBGL_lose_context");
        ie && ie.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return re;
      }),
      (this.setPixelRatio = function (ie) {
        ie !== void 0 && ((re = ie), this.setSize(Z, X, !1));
      }),
      (this.getSize = function (ie) {
        return ie.set(Z, X);
      }),
      (this.setSize = function (ie, Ce, ze = !0) {
        if (Ve.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Z = ie),
          (X = Ce),
          (t.width = Math.floor(ie * re)),
          (t.height = Math.floor(Ce * re)),
          ze === !0 &&
            ((t.style.width = ie + "px"), (t.style.height = Ce + "px")),
          this.setViewport(0, 0, ie, Ce);
      }),
      (this.getDrawingBufferSize = function (ie) {
        return ie.set(Z * re, X * re).floor();
      }),
      (this.setDrawingBufferSize = function (ie, Ce, ze) {
        (Z = ie),
          (X = Ce),
          (re = ze),
          (t.width = Math.floor(ie * ze)),
          (t.height = Math.floor(Ce * ze)),
          this.setViewport(0, 0, ie, Ce);
      }),
      (this.getCurrentViewport = function (ie) {
        return ie.copy(L);
      }),
      (this.getViewport = function (ie) {
        return ie.copy(F);
      }),
      (this.setViewport = function (ie, Ce, ze, Ge) {
        ie.isVector4 ? F.set(ie.x, ie.y, ie.z, ie.w) : F.set(ie, Ce, ze, Ge),
          Ie.viewport(L.copy(F).multiplyScalar(re).round());
      }),
      (this.getScissor = function (ie) {
        return ie.copy(V);
      }),
      (this.setScissor = function (ie, Ce, ze, Ge) {
        ie.isVector4 ? V.set(ie.x, ie.y, ie.z, ie.w) : V.set(ie, Ce, ze, Ge),
          Ie.scissor(H.copy(V).multiplyScalar(re).round());
      }),
      (this.getScissorTest = function () {
        return ne;
      }),
      (this.setScissorTest = function (ie) {
        Ie.setScissorTest((ne = ie));
      }),
      (this.setOpaqueSort = function (ie) {
        W = ie;
      }),
      (this.setTransparentSort = function (ie) {
        te = ie;
      }),
      (this.getClearColor = function (ie) {
        return ie.copy(nt.getClearColor());
      }),
      (this.setClearColor = function () {
        nt.setClearColor.apply(nt, arguments);
      }),
      (this.getClearAlpha = function () {
        return nt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        nt.setClearAlpha.apply(nt, arguments);
      }),
      (this.clear = function (ie = !0, Ce = !0, ze = !0) {
        let Ge = 0;
        if (ie) {
          let Le = !1;
          if (P !== null) {
            const ut = P.texture.format;
            Le = ut === Fy || ut === Uy || ut === Jm;
          }
          if (Le) {
            const ut = P.texture.type,
              vt =
                ut === aa ||
                ut === Nl ||
                ut === Mh ||
                ut === xf ||
                ut === Dy ||
                ut === Ny,
              Et = nt.getClearColor(),
              Ke = nt.getClearAlpha(),
              Dt = Et.r,
              Ft = Et.g,
              At = Et.b;
            vt
              ? ((y[0] = Dt),
                (y[1] = Ft),
                (y[2] = At),
                (y[3] = Ke),
                j.clearBufferuiv(j.COLOR, 0, y))
              : ((x[0] = Dt),
                (x[1] = Ft),
                (x[2] = At),
                (x[3] = Ke),
                j.clearBufferiv(j.COLOR, 0, x));
          } else Ge |= j.COLOR_BUFFER_BIT;
        }
        Ce && (Ge |= j.DEPTH_BUFFER_BIT),
          ze &&
            ((Ge |= j.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          j.clear(Ge);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Re, !1),
          t.removeEventListener("webglcontextrestored", Ue, !1),
          t.removeEventListener("webglcontextcreationerror", it, !1),
          Fe.dispose(),
          Be.dispose(),
          ke.dispose(),
          ee.dispose(),
          B.dispose(),
          _e.dispose(),
          he.dispose(),
          Je.dispose(),
          Te.dispose(),
          Ve.dispose(),
          Ve.removeEventListener("sessionstart", un),
          Ve.removeEventListener("sessionend", Sn),
          mn.stop();
      });
    function Re(ie) {
      ie.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (A = !0);
    }
    function Ue() {
      console.log("THREE.WebGLRenderer: Context Restored."), (A = !1);
      const ie = rt.autoReset,
        Ce = Ye.enabled,
        ze = Ye.autoUpdate,
        Ge = Ye.needsUpdate,
        Le = Ye.type;
      me(),
        (rt.autoReset = ie),
        (Ye.enabled = Ce),
        (Ye.autoUpdate = ze),
        (Ye.needsUpdate = Ge),
        (Ye.type = Le);
    }
    function it(ie) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        ie.statusMessage
      );
    }
    function mt(ie) {
      const Ce = ie.target;
      Ce.removeEventListener("dispose", mt), gt(Ce);
    }
    function gt(ie) {
      Ot(ie), ke.remove(ie);
    }
    function Ot(ie) {
      const Ce = ke.get(ie).programs;
      Ce !== void 0 &&
        (Ce.forEach(function (ze) {
          Te.releaseProgram(ze);
        }),
        ie.isShaderMaterial && Te.releaseShaderCache(ie));
    }
    this.renderBufferDirect = function (ie, Ce, ze, Ge, Le, ut) {
      Ce === null && (Ce = Ee);
      const vt = Le.isMesh && Le.matrixWorld.determinant() < 0,
        Et = Vl(ie, Ce, ze, Ge, Le);
      Ie.setMaterial(Ge, vt);
      let Ke = ze.index,
        Dt = 1;
      if (Ge.wireframe === !0) {
        if (((Ke = Se.getWireframeAttribute(ze)), Ke === void 0)) return;
        Dt = 2;
      }
      const Ft = ze.drawRange,
        At = ze.attributes.position;
      let nn = Ft.start * Dt,
        Cn = (Ft.start + Ft.count) * Dt;
      ut !== null &&
        ((nn = Math.max(nn, ut.start * Dt)),
        (Cn = Math.min(Cn, (ut.start + ut.count) * Dt))),
        Ke !== null
          ? ((nn = Math.max(nn, 0)), (Cn = Math.min(Cn, Ke.count)))
          : At != null &&
            ((nn = Math.max(nn, 0)), (Cn = Math.min(Cn, At.count)));
      const dn = Cn - nn;
      if (dn < 0 || dn === 1 / 0) return;
      he.setup(Le, Ge, Et, ze, Ke);
      let wn,
        wt = $e;
      if (
        (Ke !== null && ((wn = ve.get(Ke)), (wt = qe), wt.setIndex(wn)),
        Le.isMesh)
      )
        Ge.wireframe === !0
          ? (Ie.setLineWidth(Ge.wireframeLinewidth * xe()), wt.setMode(j.LINES))
          : wt.setMode(j.TRIANGLES);
      else if (Le.isLine) {
        let dt = Ge.linewidth;
        dt === void 0 && (dt = 1),
          Ie.setLineWidth(dt * xe()),
          Le.isLineSegments
            ? wt.setMode(j.LINES)
            : Le.isLineLoop
            ? wt.setMode(j.LINE_LOOP)
            : wt.setMode(j.LINE_STRIP);
      } else
        Le.isPoints
          ? wt.setMode(j.POINTS)
          : Le.isSprite && wt.setMode(j.TRIANGLES);
      if (Le.isBatchedMesh)
        if (Le._multiDrawInstances !== null)
          wt.renderMultiDrawInstances(
            Le._multiDrawStarts,
            Le._multiDrawCounts,
            Le._multiDrawCount,
            Le._multiDrawInstances
          );
        else if (Ae.get("WEBGL_multi_draw"))
          wt.renderMultiDraw(
            Le._multiDrawStarts,
            Le._multiDrawCounts,
            Le._multiDrawCount
          );
        else {
          const dt = Le._multiDrawStarts,
            Qt = Le._multiDrawCounts,
            zt = Le._multiDrawCount,
            bn = Ke ? ve.get(Ke).bytesPerElement : 1,
            ii = ke.get(Ge).currentProgram.getUniforms();
          for (let An = 0; An < zt; An++)
            ii.setValue(j, "_gl_DrawID", An), wt.render(dt[An] / bn, Qt[An]);
        }
      else if (Le.isInstancedMesh) wt.renderInstances(nn, dn, Le.count);
      else if (ze.isInstancedBufferGeometry) {
        const dt =
            ze._maxInstanceCount !== void 0 ? ze._maxInstanceCount : 1 / 0,
          Qt = Math.min(ze.instanceCount, dt);
        wt.renderInstances(nn, dn, Qt);
      } else wt.render(nn, dn);
    };
    function Ut(ie, Ce, ze) {
      ie.transparent === !0 && ie.side === Ts && ie.forceSinglePass === !1
        ? ((ie.side = Qi),
          (ie.needsUpdate = !0),
          Br(ie, Ce, ze),
          (ie.side = Xa),
          (ie.needsUpdate = !0),
          Br(ie, Ce, ze),
          (ie.side = Ts))
        : Br(ie, Ce, ze);
    }
    (this.compile = function (ie, Ce, ze = null) {
      ze === null && (ze = ie),
        (_ = Be.get(ze)),
        _.init(Ce),
        T.push(_),
        ze.traverseVisible(function (Le) {
          Le.isLight &&
            Le.layers.test(Ce.layers) &&
            (_.pushLight(Le), Le.castShadow && _.pushShadow(Le));
        }),
        ie !== ze &&
          ie.traverseVisible(function (Le) {
            Le.isLight &&
              Le.layers.test(Ce.layers) &&
              (_.pushLight(Le), Le.castShadow && _.pushShadow(Le));
          }),
        _.setupLights();
      const Ge = new Set();
      return (
        ie.traverse(function (Le) {
          const ut = Le.material;
          if (ut)
            if (Array.isArray(ut))
              for (let vt = 0; vt < ut.length; vt++) {
                const Et = ut[vt];
                Ut(Et, ze, Le), Ge.add(Et);
              }
            else Ut(ut, ze, Le), Ge.add(ut);
        }),
        T.pop(),
        (_ = null),
        Ge
      );
    }),
      (this.compileAsync = function (ie, Ce, ze = null) {
        const Ge = this.compile(ie, Ce, ze);
        return new Promise((Le) => {
          function ut() {
            if (
              (Ge.forEach(function (vt) {
                ke.get(vt).currentProgram.isReady() && Ge.delete(vt);
              }),
              Ge.size === 0)
            ) {
              Le(ie);
              return;
            }
            setTimeout(ut, 10);
          }
          Ae.get("KHR_parallel_shader_compile") !== null
            ? ut()
            : setTimeout(ut, 10);
        });
      });
    let ht = null;
    function $t(ie) {
      ht && ht(ie);
    }
    function un() {
      mn.stop();
    }
    function Sn() {
      mn.start();
    }
    const mn = new JA();
    mn.setAnimationLoop($t),
      typeof self < "u" && mn.setContext(self),
      (this.setAnimationLoop = function (ie) {
        (ht = ie),
          Ve.setAnimationLoop(ie),
          ie === null ? mn.stop() : mn.start();
      }),
      Ve.addEventListener("sessionstart", un),
      Ve.addEventListener("sessionend", Sn),
      (this.render = function (ie, Ce) {
        if (Ce !== void 0 && Ce.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (A === !0) return;
        if (
          (ie.matrixWorldAutoUpdate === !0 && ie.updateMatrixWorld(),
          Ce.parent === null &&
            Ce.matrixWorldAutoUpdate === !0 &&
            Ce.updateMatrixWorld(),
          Ve.enabled === !0 &&
            Ve.isPresenting === !0 &&
            (Ve.cameraAutoUpdate === !0 && Ve.updateCamera(Ce),
            (Ce = Ve.getCamera())),
          ie.isScene === !0 && ie.onBeforeRender(E, ie, Ce, P),
          (_ = Be.get(ie, T.length)),
          _.init(Ce),
          T.push(_),
          de.multiplyMatrices(Ce.projectionMatrix, Ce.matrixWorldInverse),
          ae.setFromProjectionMatrix(de),
          (oe = this.localClippingEnabled),
          (J = We.init(this.clippingPlanes, oe)),
          (S = Fe.get(ie, w.length)),
          S.init(),
          w.push(S),
          Ve.enabled === !0 && Ve.isPresenting === !0)
        ) {
          const ut = E.xr.getDepthSensingMesh();
          ut !== null && lr(ut, Ce, -1 / 0, E.sortObjects);
        }
        lr(ie, Ce, 0, E.sortObjects),
          S.finish(),
          E.sortObjects === !0 && S.sort(W, te),
          (ge =
            Ve.enabled === !1 ||
            Ve.isPresenting === !1 ||
            Ve.hasDepthSensing() === !1),
          ge && nt.addToRenderList(S, ie),
          this.info.render.frame++,
          J === !0 && We.beginShadows();
        const ze = _.state.shadowsArray;
        Ye.render(ze, ie, Ce),
          J === !0 && We.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Ge = S.opaque,
          Le = S.transmissive;
        if ((_.setupLights(), Ce.isArrayCamera)) {
          const ut = Ce.cameras;
          if (Le.length > 0)
            for (let vt = 0, Et = ut.length; vt < Et; vt++) {
              const Ke = ut[vt];
              yr(Ge, Le, ie, Ke);
            }
          ge && nt.render(ie);
          for (let vt = 0, Et = ut.length; vt < Et; vt++) {
            const Ke = ut[vt];
            Ui(S, ie, Ke, Ke.viewport);
          }
        } else
          Le.length > 0 && yr(Ge, Le, ie, Ce),
            ge && nt.render(ie),
            Ui(S, ie, Ce);
        P !== null &&
          (Xe.updateMultisampleRenderTarget(P), Xe.updateRenderTargetMipmap(P)),
          ie.isScene === !0 && ie.onAfterRender(E, ie, Ce),
          he.resetDefaultState(),
          (U = -1),
          (N = null),
          T.pop(),
          T.length > 0
            ? ((_ = T[T.length - 1]),
              J === !0 && We.setGlobalState(E.clippingPlanes, _.state.camera))
            : (_ = null),
          w.pop(),
          w.length > 0 ? (S = w[w.length - 1]) : (S = null);
      });
    function lr(ie, Ce, ze, Ge) {
      if (ie.visible === !1) return;
      if (ie.layers.test(Ce.layers)) {
        if (ie.isGroup) ze = ie.renderOrder;
        else if (ie.isLOD) ie.autoUpdate === !0 && ie.update(Ce);
        else if (ie.isLight) _.pushLight(ie), ie.castShadow && _.pushShadow(ie);
        else if (ie.isSprite) {
          if (!ie.frustumCulled || ae.intersectsSprite(ie)) {
            Ge && fe.setFromMatrixPosition(ie.matrixWorld).applyMatrix4(de);
            const vt = _e.update(ie),
              Et = ie.material;
            Et.visible && S.push(ie, vt, Et, ze, fe.z, null);
          }
        } else if (
          (ie.isMesh || ie.isLine || ie.isPoints) &&
          (!ie.frustumCulled || ae.intersectsObject(ie))
        ) {
          const vt = _e.update(ie),
            Et = ie.material;
          if (
            (Ge &&
              (ie.boundingSphere !== void 0
                ? (ie.boundingSphere === null && ie.computeBoundingSphere(),
                  fe.copy(ie.boundingSphere.center))
                : (vt.boundingSphere === null && vt.computeBoundingSphere(),
                  fe.copy(vt.boundingSphere.center)),
              fe.applyMatrix4(ie.matrixWorld).applyMatrix4(de)),
            Array.isArray(Et))
          ) {
            const Ke = vt.groups;
            for (let Dt = 0, Ft = Ke.length; Dt < Ft; Dt++) {
              const At = Ke[Dt],
                nn = Et[At.materialIndex];
              nn && nn.visible && S.push(ie, vt, nn, ze, fe.z, At);
            }
          } else Et.visible && S.push(ie, vt, Et, ze, fe.z, null);
        }
      }
      const ut = ie.children;
      for (let vt = 0, Et = ut.length; vt < Et; vt++) lr(ut[vt], Ce, ze, Ge);
    }
    function Ui(ie, Ce, ze, Ge) {
      const Le = ie.opaque,
        ut = ie.transmissive,
        vt = ie.transparent;
      _.setupLightsView(ze),
        J === !0 && We.setGlobalState(E.clippingPlanes, ze),
        Ge && Ie.viewport(L.copy(Ge)),
        Le.length > 0 && Fr(Le, Ce, ze),
        ut.length > 0 && Fr(ut, Ce, ze),
        vt.length > 0 && Fr(vt, Ce, ze),
        Ie.buffers.depth.setTest(!0),
        Ie.buffers.depth.setMask(!0),
        Ie.buffers.color.setMask(!0),
        Ie.setPolygonOffset(!1);
    }
    function yr(ie, Ce, ze, Ge) {
      if ((ze.isScene === !0 ? ze.overrideMaterial : null) !== null) return;
      _.state.transmissionRenderTarget[Ge.id] === void 0 &&
        (_.state.transmissionRenderTarget[Ge.id] = new la(1, 1, {
          generateMipmaps: !0,
          type:
            Ae.has("EXT_color_buffer_half_float") ||
            Ae.has("EXT_color_buffer_float")
              ? Oh
              : aa,
          minFilter: Ba,
          samples: 4,
          stencilBuffer: o,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: yn.workingColorSpace,
        }));
      const ut = _.state.transmissionRenderTarget[Ge.id],
        vt = Ge.viewport || L;
      ut.setSize(vt.z, vt.w);
      const Et = E.getRenderTarget();
      E.setRenderTarget(ut),
        E.getClearColor($),
        (q = E.getClearAlpha()),
        q < 1 && E.setClearColor(16777215, 0.5),
        E.clear(),
        ge && nt.render(ze);
      const Ke = E.toneMapping;
      E.toneMapping = Ga;
      const Dt = Ge.viewport;
      if (
        (Ge.viewport !== void 0 && (Ge.viewport = void 0),
        _.setupLightsView(Ge),
        J === !0 && We.setGlobalState(E.clippingPlanes, Ge),
        Fr(ie, ze, Ge),
        Xe.updateMultisampleRenderTarget(ut),
        Xe.updateRenderTargetMipmap(ut),
        Ae.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let Ft = !1;
        for (let At = 0, nn = Ce.length; At < nn; At++) {
          const Cn = Ce[At],
            dn = Cn.object,
            wn = Cn.geometry,
            wt = Cn.material,
            dt = Cn.group;
          if (wt.side === Ts && dn.layers.test(Ge.layers)) {
            const Qt = wt.side;
            (wt.side = Qi),
              (wt.needsUpdate = !0),
              Ar(dn, ze, Ge, wn, wt, dt),
              (wt.side = Qt),
              (wt.needsUpdate = !0),
              (Ft = !0);
          }
        }
        Ft === !0 &&
          (Xe.updateMultisampleRenderTarget(ut),
          Xe.updateRenderTargetMipmap(ut));
      }
      E.setRenderTarget(Et),
        E.setClearColor($, q),
        Dt !== void 0 && (Ge.viewport = Dt),
        (E.toneMapping = Ke);
    }
    function Fr(ie, Ce, ze) {
      const Ge = Ce.isScene === !0 ? Ce.overrideMaterial : null;
      for (let Le = 0, ut = ie.length; Le < ut; Le++) {
        const vt = ie[Le],
          Et = vt.object,
          Ke = vt.geometry,
          Dt = Ge === null ? vt.material : Ge,
          Ft = vt.group;
        Et.layers.test(ze.layers) && Ar(Et, Ce, ze, Ke, Dt, Ft);
      }
    }
    function Ar(ie, Ce, ze, Ge, Le, ut) {
      ie.onBeforeRender(E, Ce, ze, Ge, Le, ut),
        ie.modelViewMatrix.multiplyMatrices(
          ze.matrixWorldInverse,
          ie.matrixWorld
        ),
        ie.normalMatrix.getNormalMatrix(ie.modelViewMatrix),
        Le.transparent === !0 && Le.side === Ts && Le.forceSinglePass === !1
          ? ((Le.side = Qi),
            (Le.needsUpdate = !0),
            E.renderBufferDirect(ze, Ce, Ge, Le, ie, ut),
            (Le.side = Xa),
            (Le.needsUpdate = !0),
            E.renderBufferDirect(ze, Ce, Ge, Le, ie, ut),
            (Le.side = Ts))
          : E.renderBufferDirect(ze, Ce, Ge, Le, ie, ut),
        ie.onAfterRender(E, Ce, ze, Ge, Le, ut);
    }
    function Br(ie, Ce, ze) {
      Ce.isScene !== !0 && (Ce = Ee);
      const Ge = ke.get(ie),
        Le = _.state.lights,
        ut = _.state.shadowsArray,
        vt = Le.state.version,
        Et = Te.getParameters(ie, Le.state, ut, Ce, ze),
        Ke = Te.getProgramCacheKey(Et);
      let Dt = Ge.programs;
      (Ge.environment = ie.isMeshStandardMaterial ? Ce.environment : null),
        (Ge.fog = Ce.fog),
        (Ge.envMap = (ie.isMeshStandardMaterial ? B : ee).get(
          ie.envMap || Ge.environment
        )),
        (Ge.envMapRotation =
          Ge.environment !== null && ie.envMap === null
            ? Ce.environmentRotation
            : ie.envMapRotation),
        Dt === void 0 &&
          (ie.addEventListener("dispose", mt),
          (Dt = new Map()),
          (Ge.programs = Dt));
      let Ft = Dt.get(Ke);
      if (Ft !== void 0) {
        if (Ge.currentProgram === Ft && Ge.lightsStateVersion === vt)
          return yo(ie, Et), Ft;
      } else
        (Et.uniforms = Te.getUniforms(ie)),
          ie.onBeforeCompile(Et, E),
          (Ft = Te.acquireProgram(Et, Ke)),
          Dt.set(Ke, Ft),
          (Ge.uniforms = Et.uniforms);
      const At = Ge.uniforms;
      return (
        ((!ie.isShaderMaterial && !ie.isRawShaderMaterial) ||
          ie.clipping === !0) &&
          (At.clippingPlanes = We.uniform),
        yo(ie, Et),
        (Ge.needsLights = Gl(ie)),
        (Ge.lightsStateVersion = vt),
        Ge.needsLights &&
          ((At.ambientLightColor.value = Le.state.ambient),
          (At.lightProbe.value = Le.state.probe),
          (At.directionalLights.value = Le.state.directional),
          (At.directionalLightShadows.value = Le.state.directionalShadow),
          (At.spotLights.value = Le.state.spot),
          (At.spotLightShadows.value = Le.state.spotShadow),
          (At.rectAreaLights.value = Le.state.rectArea),
          (At.ltc_1.value = Le.state.rectAreaLTC1),
          (At.ltc_2.value = Le.state.rectAreaLTC2),
          (At.pointLights.value = Le.state.point),
          (At.pointLightShadows.value = Le.state.pointShadow),
          (At.hemisphereLights.value = Le.state.hemi),
          (At.directionalShadowMap.value = Le.state.directionalShadowMap),
          (At.directionalShadowMatrix.value = Le.state.directionalShadowMatrix),
          (At.spotShadowMap.value = Le.state.spotShadowMap),
          (At.spotLightMatrix.value = Le.state.spotLightMatrix),
          (At.spotLightMap.value = Le.state.spotLightMap),
          (At.pointShadowMap.value = Le.state.pointShadowMap),
          (At.pointShadowMatrix.value = Le.state.pointShadowMatrix)),
        (Ge.currentProgram = Ft),
        (Ge.uniformsList = null),
        Ft
      );
    }
    function xr(ie) {
      if (ie.uniformsList === null) {
        const Ce = ie.currentProgram.getUniforms();
        ie.uniformsList = d0.seqWithValue(Ce.seq, ie.uniforms);
      }
      return ie.uniformsList;
    }
    function yo(ie, Ce) {
      const ze = ke.get(ie);
      (ze.outputColorSpace = Ce.outputColorSpace),
        (ze.batching = Ce.batching),
        (ze.batchingColor = Ce.batchingColor),
        (ze.instancing = Ce.instancing),
        (ze.instancingColor = Ce.instancingColor),
        (ze.instancingMorph = Ce.instancingMorph),
        (ze.skinning = Ce.skinning),
        (ze.morphTargets = Ce.morphTargets),
        (ze.morphNormals = Ce.morphNormals),
        (ze.morphColors = Ce.morphColors),
        (ze.morphTargetsCount = Ce.morphTargetsCount),
        (ze.numClippingPlanes = Ce.numClippingPlanes),
        (ze.numIntersection = Ce.numClipIntersection),
        (ze.vertexAlphas = Ce.vertexAlphas),
        (ze.vertexTangents = Ce.vertexTangents),
        (ze.toneMapping = Ce.toneMapping);
    }
    function Vl(ie, Ce, ze, Ge, Le) {
      Ce.isScene !== !0 && (Ce = Ee), Xe.resetTextureUnits();
      const ut = Ce.fog,
        vt = Ge.isMeshStandardMaterial ? Ce.environment : null,
        Et =
          P === null
            ? E.outputColorSpace
            : P.isXRRenderTarget === !0
            ? P.texture.colorSpace
            : Fl,
        Ke = (Ge.isMeshStandardMaterial ? B : ee).get(Ge.envMap || vt),
        Dt =
          Ge.vertexColors === !0 &&
          !!ze.attributes.color &&
          ze.attributes.color.itemSize === 4,
        Ft = !!ze.attributes.tangent && (!!Ge.normalMap || Ge.anisotropy > 0),
        At = !!ze.morphAttributes.position,
        nn = !!ze.morphAttributes.normal,
        Cn = !!ze.morphAttributes.color;
      let dn = Ga;
      Ge.toneMapped &&
        (P === null || P.isXRRenderTarget === !0) &&
        (dn = E.toneMapping);
      const wn =
          ze.morphAttributes.position ||
          ze.morphAttributes.normal ||
          ze.morphAttributes.color,
        wt = wn !== void 0 ? wn.length : 0,
        dt = ke.get(Ge),
        Qt = _.state.lights;
      if (J === !0 && (oe === !0 || ie !== N)) {
        const ur = ie === N && Ge.id === U;
        We.setState(Ge, ie, ur);
      }
      let zt = !1;
      Ge.version === dt.__version
        ? ((dt.needsLights && dt.lightsStateVersion !== Qt.state.version) ||
            dt.outputColorSpace !== Et ||
            (Le.isBatchedMesh && dt.batching === !1) ||
            (!Le.isBatchedMesh && dt.batching === !0) ||
            (Le.isBatchedMesh &&
              dt.batchingColor === !0 &&
              Le.colorTexture === null) ||
            (Le.isBatchedMesh &&
              dt.batchingColor === !1 &&
              Le.colorTexture !== null) ||
            (Le.isInstancedMesh && dt.instancing === !1) ||
            (!Le.isInstancedMesh && dt.instancing === !0) ||
            (Le.isSkinnedMesh && dt.skinning === !1) ||
            (!Le.isSkinnedMesh && dt.skinning === !0) ||
            (Le.isInstancedMesh &&
              dt.instancingColor === !0 &&
              Le.instanceColor === null) ||
            (Le.isInstancedMesh &&
              dt.instancingColor === !1 &&
              Le.instanceColor !== null) ||
            (Le.isInstancedMesh &&
              dt.instancingMorph === !0 &&
              Le.morphTexture === null) ||
            (Le.isInstancedMesh &&
              dt.instancingMorph === !1 &&
              Le.morphTexture !== null) ||
            dt.envMap !== Ke ||
            (Ge.fog === !0 && dt.fog !== ut) ||
            (dt.numClippingPlanes !== void 0 &&
              (dt.numClippingPlanes !== We.numPlanes ||
                dt.numIntersection !== We.numIntersection)) ||
            dt.vertexAlphas !== Dt ||
            dt.vertexTangents !== Ft ||
            dt.morphTargets !== At ||
            dt.morphNormals !== nn ||
            dt.morphColors !== Cn ||
            dt.toneMapping !== dn ||
            dt.morphTargetsCount !== wt) &&
          (zt = !0)
        : ((zt = !0), (dt.__version = Ge.version));
      let bn = dt.currentProgram;
      zt === !0 && (bn = Br(Ge, Ce, Le));
      let ii = !1,
        An = !1,
        Wn = !1;
      const cn = bn.getUniforms(),
        zr = dt.uniforms;
      if (
        (Ie.useProgram(bn.program) && ((ii = !0), (An = !0), (Wn = !0)),
        Ge.id !== U && ((U = Ge.id), (An = !0)),
        ii || N !== ie)
      ) {
        cn.setValue(j, "projectionMatrix", ie.projectionMatrix),
          cn.setValue(j, "viewMatrix", ie.matrixWorldInverse);
        const ur = cn.map.cameraPosition;
        ur !== void 0 &&
          ur.setValue(j, le.setFromMatrixPosition(ie.matrixWorld)),
          Ne.logarithmicDepthBuffer &&
            cn.setValue(
              j,
              "logDepthBufFC",
              2 / (Math.log(ie.far + 1) / Math.LN2)
            ),
          (Ge.isMeshPhongMaterial ||
            Ge.isMeshToonMaterial ||
            Ge.isMeshLambertMaterial ||
            Ge.isMeshBasicMaterial ||
            Ge.isMeshStandardMaterial ||
            Ge.isShaderMaterial) &&
            cn.setValue(j, "isOrthographic", ie.isOrthographicCamera === !0),
          N !== ie && ((N = ie), (An = !0), (Wn = !0));
      }
      if (Le.isSkinnedMesh) {
        cn.setOptional(j, Le, "bindMatrix"),
          cn.setOptional(j, Le, "bindMatrixInverse");
        const ur = Le.skeleton;
        ur &&
          (ur.boneTexture === null && ur.computeBoneTexture(),
          cn.setValue(j, "boneTexture", ur.boneTexture, Xe));
      }
      Le.isBatchedMesh &&
        (cn.setOptional(j, Le, "batchingTexture"),
        cn.setValue(j, "batchingTexture", Le._matricesTexture, Xe),
        cn.setOptional(j, Le, "batchingIdTexture"),
        cn.setValue(j, "batchingIdTexture", Le._indirectTexture, Xe),
        cn.setOptional(j, Le, "batchingColorTexture"),
        Le._colorsTexture !== null &&
          cn.setValue(j, "batchingColorTexture", Le._colorsTexture, Xe));
      const ls = ze.morphAttributes;
      if (
        ((ls.position !== void 0 ||
          ls.normal !== void 0 ||
          ls.color !== void 0) &&
          yt.update(Le, ze, bn),
        (An || dt.receiveShadow !== Le.receiveShadow) &&
          ((dt.receiveShadow = Le.receiveShadow),
          cn.setValue(j, "receiveShadow", Le.receiveShadow)),
        Ge.isMeshGouraudMaterial &&
          Ge.envMap !== null &&
          ((zr.envMap.value = Ke),
          (zr.flipEnvMap.value =
            Ke.isCubeTexture && Ke.isRenderTargetTexture === !1 ? -1 : 1)),
        Ge.isMeshStandardMaterial &&
          Ge.envMap === null &&
          Ce.environment !== null &&
          (zr.envMapIntensity.value = Ce.environmentIntensity),
        An &&
          (cn.setValue(j, "toneMappingExposure", E.toneMappingExposure),
          dt.needsLights && no(zr, Wn),
          ut && Ge.fog === !0 && at.refreshFogUniforms(zr, ut),
          at.refreshMaterialUniforms(
            zr,
            Ge,
            re,
            X,
            _.state.transmissionRenderTarget[ie.id]
          ),
          d0.upload(j, xr(dt), zr, Xe)),
        Ge.isShaderMaterial &&
          Ge.uniformsNeedUpdate === !0 &&
          (d0.upload(j, xr(dt), zr, Xe), (Ge.uniformsNeedUpdate = !1)),
        Ge.isSpriteMaterial && cn.setValue(j, "center", Le.center),
        cn.setValue(j, "modelViewMatrix", Le.modelViewMatrix),
        cn.setValue(j, "normalMatrix", Le.normalMatrix),
        cn.setValue(j, "modelMatrix", Le.matrixWorld),
        Ge.isShaderMaterial || Ge.isRawShaderMaterial)
      ) {
        const ur = Ge.uniformsGroups;
        for (let Rr = 0, di = ur.length; Rr < di; Rr++) {
          const zo = ur[Rr];
          Je.update(zo, bn), Je.bind(zo, bn);
        }
      }
      return bn;
    }
    function no(ie, Ce) {
      (ie.ambientLightColor.needsUpdate = Ce),
        (ie.lightProbe.needsUpdate = Ce),
        (ie.directionalLights.needsUpdate = Ce),
        (ie.directionalLightShadows.needsUpdate = Ce),
        (ie.pointLights.needsUpdate = Ce),
        (ie.pointLightShadows.needsUpdate = Ce),
        (ie.spotLights.needsUpdate = Ce),
        (ie.spotLightShadows.needsUpdate = Ce),
        (ie.rectAreaLights.needsUpdate = Ce),
        (ie.hemisphereLights.needsUpdate = Ce);
    }
    function Gl(ie) {
      return (
        ie.isMeshLambertMaterial ||
        ie.isMeshToonMaterial ||
        ie.isMeshPhongMaterial ||
        ie.isMeshStandardMaterial ||
        ie.isShadowMaterial ||
        (ie.isShaderMaterial && ie.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return R;
    }),
      (this.getActiveMipmapLevel = function () {
        return k;
      }),
      (this.getRenderTarget = function () {
        return P;
      }),
      (this.setRenderTargetTextures = function (ie, Ce, ze) {
        (ke.get(ie.texture).__webglTexture = Ce),
          (ke.get(ie.depthTexture).__webglTexture = ze);
        const Ge = ke.get(ie);
        (Ge.__hasExternalTextures = !0),
          (Ge.__autoAllocateDepthBuffer = ze === void 0),
          Ge.__autoAllocateDepthBuffer ||
            (Ae.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (Ge.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (ie, Ce) {
        const ze = ke.get(ie);
        (ze.__webglFramebuffer = Ce),
          (ze.__useDefaultFramebuffer = Ce === void 0);
      }),
      (this.setRenderTarget = function (ie, Ce = 0, ze = 0) {
        (P = ie), (R = Ce), (k = ze);
        let Ge = !0,
          Le = null,
          ut = !1,
          vt = !1;
        if (ie) {
          const Ke = ke.get(ie);
          Ke.__useDefaultFramebuffer !== void 0
            ? (Ie.bindFramebuffer(j.FRAMEBUFFER, null), (Ge = !1))
            : Ke.__webglFramebuffer === void 0
            ? Xe.setupRenderTarget(ie)
            : Ke.__hasExternalTextures &&
              Xe.rebindTextures(
                ie,
                ke.get(ie.texture).__webglTexture,
                ke.get(ie.depthTexture).__webglTexture
              );
          const Dt = ie.texture;
          (Dt.isData3DTexture ||
            Dt.isDataArrayTexture ||
            Dt.isCompressedArrayTexture) &&
            (vt = !0);
          const Ft = ke.get(ie).__webglFramebuffer;
          ie.isWebGLCubeRenderTarget
            ? (Array.isArray(Ft[Ce]) ? (Le = Ft[Ce][ze]) : (Le = Ft[Ce]),
              (ut = !0))
            : ie.samples > 0 && Xe.useMultisampledRTT(ie) === !1
            ? (Le = ke.get(ie).__webglMultisampledFramebuffer)
            : Array.isArray(Ft)
            ? (Le = Ft[ze])
            : (Le = Ft),
            L.copy(ie.viewport),
            H.copy(ie.scissor),
            (G = ie.scissorTest);
        } else
          L.copy(F).multiplyScalar(re).floor(),
            H.copy(V).multiplyScalar(re).floor(),
            (G = ne);
        if (
          (Ie.bindFramebuffer(j.FRAMEBUFFER, Le) &&
            Ge &&
            Ie.drawBuffers(ie, Le),
          Ie.viewport(L),
          Ie.scissor(H),
          Ie.setScissorTest(G),
          ut)
        ) {
          const Ke = ke.get(ie.texture);
          j.framebufferTexture2D(
            j.FRAMEBUFFER,
            j.COLOR_ATTACHMENT0,
            j.TEXTURE_CUBE_MAP_POSITIVE_X + Ce,
            Ke.__webglTexture,
            ze
          );
        } else if (vt) {
          const Ke = ke.get(ie.texture),
            Dt = Ce || 0;
          j.framebufferTextureLayer(
            j.FRAMEBUFFER,
            j.COLOR_ATTACHMENT0,
            Ke.__webglTexture,
            ze || 0,
            Dt
          );
        }
        U = -1;
      }),
      (this.readRenderTargetPixels = function (ie, Ce, ze, Ge, Le, ut, vt) {
        if (!(ie && ie.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Et = ke.get(ie).__webglFramebuffer;
        if (
          (ie.isWebGLCubeRenderTarget && vt !== void 0 && (Et = Et[vt]), Et)
        ) {
          Ie.bindFramebuffer(j.FRAMEBUFFER, Et);
          try {
            const Ke = ie.texture,
              Dt = Ke.format,
              Ft = Ke.type;
            if (!Ne.textureFormatReadable(Dt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!Ne.textureTypeReadable(Ft)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            Ce >= 0 &&
              Ce <= ie.width - Ge &&
              ze >= 0 &&
              ze <= ie.height - Le &&
              j.readPixels(Ce, ze, Ge, Le, et.convert(Dt), et.convert(Ft), ut);
          } finally {
            const Ke = P !== null ? ke.get(P).__webglFramebuffer : null;
            Ie.bindFramebuffer(j.FRAMEBUFFER, Ke);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        ie,
        Ce,
        ze,
        Ge,
        Le,
        ut,
        vt
      ) {
        if (!(ie && ie.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let Et = ke.get(ie).__webglFramebuffer;
        if (
          (ie.isWebGLCubeRenderTarget && vt !== void 0 && (Et = Et[vt]), Et)
        ) {
          Ie.bindFramebuffer(j.FRAMEBUFFER, Et);
          try {
            const Ke = ie.texture,
              Dt = Ke.format,
              Ft = Ke.type;
            if (!Ne.textureFormatReadable(Dt))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!Ne.textureTypeReadable(Ft))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            if (
              Ce >= 0 &&
              Ce <= ie.width - Ge &&
              ze >= 0 &&
              ze <= ie.height - Le
            ) {
              const At = j.createBuffer();
              j.bindBuffer(j.PIXEL_PACK_BUFFER, At),
                j.bufferData(j.PIXEL_PACK_BUFFER, ut.byteLength, j.STREAM_READ),
                j.readPixels(Ce, ze, Ge, Le, et.convert(Dt), et.convert(Ft), 0),
                j.flush();
              const nn = j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE, 0);
              await uB(j, nn, 4);
              try {
                j.bindBuffer(j.PIXEL_PACK_BUFFER, At),
                  j.getBufferSubData(j.PIXEL_PACK_BUFFER, 0, ut);
              } finally {
                j.deleteBuffer(At), j.deleteSync(nn);
              }
              return ut;
            }
          } finally {
            const Ke = P !== null ? ke.get(P).__webglFramebuffer : null;
            Ie.bindFramebuffer(j.FRAMEBUFFER, Ke);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (ie, Ce = null, ze = 0) {
        ie.isTexture !== !0 &&
          (vh(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          (Ce = arguments[0] || null),
          (ie = arguments[1]));
        const Ge = Math.pow(2, -ze),
          Le = Math.floor(ie.image.width * Ge),
          ut = Math.floor(ie.image.height * Ge),
          vt = Ce !== null ? Ce.x : 0,
          Et = Ce !== null ? Ce.y : 0;
        Xe.setTexture2D(ie, 0),
          j.copyTexSubImage2D(j.TEXTURE_2D, ze, 0, 0, vt, Et, Le, ut),
          Ie.unbindTexture();
      }),
      (this.copyTextureToTexture = function (
        ie,
        Ce,
        ze = null,
        Ge = null,
        Le = 0
      ) {
        ie.isTexture !== !0 &&
          (vh(
            "WebGLRenderer: copyTextureToTexture function signature has changed."
          ),
          (Ge = arguments[0] || null),
          (ie = arguments[1]),
          (Ce = arguments[2]),
          (Le = arguments[3] || 0),
          (ze = null));
        let ut, vt, Et, Ke, Dt, Ft;
        ze !== null
          ? ((ut = ze.max.x - ze.min.x),
            (vt = ze.max.y - ze.min.y),
            (Et = ze.min.x),
            (Ke = ze.min.y))
          : ((ut = ie.image.width), (vt = ie.image.height), (Et = 0), (Ke = 0)),
          Ge !== null ? ((Dt = Ge.x), (Ft = Ge.y)) : ((Dt = 0), (Ft = 0));
        const At = et.convert(Ce.format),
          nn = et.convert(Ce.type);
        Xe.setTexture2D(Ce, 0),
          j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, Ce.flipY),
          j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ce.premultiplyAlpha),
          j.pixelStorei(j.UNPACK_ALIGNMENT, Ce.unpackAlignment);
        const Cn = j.getParameter(j.UNPACK_ROW_LENGTH),
          dn = j.getParameter(j.UNPACK_IMAGE_HEIGHT),
          wn = j.getParameter(j.UNPACK_SKIP_PIXELS),
          wt = j.getParameter(j.UNPACK_SKIP_ROWS),
          dt = j.getParameter(j.UNPACK_SKIP_IMAGES),
          Qt = ie.isCompressedTexture ? ie.mipmaps[Le] : ie.image;
        j.pixelStorei(j.UNPACK_ROW_LENGTH, Qt.width),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, Qt.height),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, Et),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, Ke),
          ie.isDataTexture
            ? j.texSubImage2D(j.TEXTURE_2D, Le, Dt, Ft, ut, vt, At, nn, Qt.data)
            : ie.isCompressedTexture
            ? j.compressedTexSubImage2D(
                j.TEXTURE_2D,
                Le,
                Dt,
                Ft,
                Qt.width,
                Qt.height,
                At,
                Qt.data
              )
            : j.texSubImage2D(j.TEXTURE_2D, Le, Dt, Ft, ut, vt, At, nn, Qt),
          j.pixelStorei(j.UNPACK_ROW_LENGTH, Cn),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, dn),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, wn),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, wt),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, dt),
          Le === 0 && Ce.generateMipmaps && j.generateMipmap(j.TEXTURE_2D),
          Ie.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (
        ie,
        Ce,
        ze = null,
        Ge = null,
        Le = 0
      ) {
        ie.isTexture !== !0 &&
          (vh(
            "WebGLRenderer: copyTextureToTexture3D function signature has changed."
          ),
          (ze = arguments[0] || null),
          (Ge = arguments[1] || null),
          (ie = arguments[2]),
          (Ce = arguments[3]),
          (Le = arguments[4] || 0));
        let ut, vt, Et, Ke, Dt, Ft, At, nn, Cn;
        const dn = ie.isCompressedTexture ? ie.mipmaps[Le] : ie.image;
        ze !== null
          ? ((ut = ze.max.x - ze.min.x),
            (vt = ze.max.y - ze.min.y),
            (Et = ze.max.z - ze.min.z),
            (Ke = ze.min.x),
            (Dt = ze.min.y),
            (Ft = ze.min.z))
          : ((ut = dn.width),
            (vt = dn.height),
            (Et = dn.depth),
            (Ke = 0),
            (Dt = 0),
            (Ft = 0)),
          Ge !== null
            ? ((At = Ge.x), (nn = Ge.y), (Cn = Ge.z))
            : ((At = 0), (nn = 0), (Cn = 0));
        const wn = et.convert(Ce.format),
          wt = et.convert(Ce.type);
        let dt;
        if (Ce.isData3DTexture) Xe.setTexture3D(Ce, 0), (dt = j.TEXTURE_3D);
        else if (Ce.isDataArrayTexture || Ce.isCompressedArrayTexture)
          Xe.setTexture2DArray(Ce, 0), (dt = j.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, Ce.flipY),
          j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ce.premultiplyAlpha),
          j.pixelStorei(j.UNPACK_ALIGNMENT, Ce.unpackAlignment);
        const Qt = j.getParameter(j.UNPACK_ROW_LENGTH),
          zt = j.getParameter(j.UNPACK_IMAGE_HEIGHT),
          bn = j.getParameter(j.UNPACK_SKIP_PIXELS),
          ii = j.getParameter(j.UNPACK_SKIP_ROWS),
          An = j.getParameter(j.UNPACK_SKIP_IMAGES);
        j.pixelStorei(j.UNPACK_ROW_LENGTH, dn.width),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, dn.height),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, Ke),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, Dt),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, Ft),
          ie.isDataTexture || ie.isData3DTexture
            ? j.texSubImage3D(dt, Le, At, nn, Cn, ut, vt, Et, wn, wt, dn.data)
            : Ce.isCompressedArrayTexture
            ? j.compressedTexSubImage3D(
                dt,
                Le,
                At,
                nn,
                Cn,
                ut,
                vt,
                Et,
                wn,
                dn.data
              )
            : j.texSubImage3D(dt, Le, At, nn, Cn, ut, vt, Et, wn, wt, dn),
          j.pixelStorei(j.UNPACK_ROW_LENGTH, Qt),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, zt),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, bn),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, ii),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, An),
          Le === 0 && Ce.generateMipmaps && j.generateMipmap(dt),
          Ie.unbindTexture();
      }),
      (this.initRenderTarget = function (ie) {
        ke.get(ie).__webglFramebuffer === void 0 && Xe.setupRenderTarget(ie);
      }),
      (this.initTexture = function (ie) {
        ie.isCubeTexture
          ? Xe.setTextureCube(ie, 0)
          : ie.isData3DTexture
          ? Xe.setTexture3D(ie, 0)
          : ie.isDataArrayTexture || ie.isCompressedArrayTexture
          ? Xe.setTexture2DArray(ie, 0)
          : Xe.setTexture2D(ie, 0),
          Ie.unbindTexture();
      }),
      (this.resetState = function () {
        (R = 0), (k = 0), (P = null), Ie.reset(), he.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return za;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = e === zy ? "display-p3" : "srgb"),
      (t.unpackColorSpace =
        yn.workingColorSpace === Qm ? "display-p3" : "srgb");
  }
}
class jy {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new St(e)),
      (this.density = t);
  }
  clone() {
    return new jy(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class $y {
  constructor(e, t = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new St(e)),
      (this.near = t),
      (this.far = r);
  }
  clone() {
    return new $y(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
let iy = class extends _n {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new as()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new as()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
};
class Xy {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Om),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = os());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      vh(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.stride), (r *= t.stride);
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = os()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = os()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const po = new se();
class Sf {
  constructor(e, t, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      po.fromBufferAttribute(this, t),
        po.applyMatrix4(e),
        this.setXYZ(t, po.x, po.y, po.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      po.fromBufferAttribute(this, t),
        po.applyNormalMatrix(e),
        this.setXYZ(t, po.x, po.y, po.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      po.fromBufferAttribute(this, t),
        po.transformDirection(e),
        this.setXYZ(t, po.x, po.y, po.z);
    return this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (r = go(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = sn(r, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = r),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = sn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = go(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = go(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = go(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = go(t, this.array)), t;
  }
  setXY(e, t, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = sn(t, this.array)), (r = sn(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = sn(t, this.array)),
        (r = sn(r, this.array)),
        (i = sn(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = sn(t, this.array)),
        (r = sn(r, this.array)),
        (i = sn(i, this.array)),
        (o = sn(o, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return new Gn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Sf(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class ww extends Oi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Xd;
const Up = new se(),
  Yd = new se(),
  qd = new se(),
  Kd = new tt(),
  Fp = new tt(),
  sR = new Wt(),
  Pv = new se(),
  Bp = new se(),
  Iv = new se(),
  KE = new tt(),
  Y_ = new tt(),
  ZE = new tt();
class aR extends _n {
  constructor(e = new ww()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Xd === void 0)
    ) {
      Xd = new Jt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new Xy(t, 5);
      Xd.setIndex([0, 1, 2, 0, 2, 3]),
        Xd.setAttribute("position", new Sf(r, 3, 0, !1)),
        Xd.setAttribute("uv", new Sf(r, 2, 3, !1));
    }
    (this.geometry = Xd), (this.material = e), (this.center = new tt(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Yd.setFromMatrixScale(this.matrixWorld),
      sR.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      qd.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Yd.multiplyScalar(-qd.z);
    const r = this.material.rotation;
    let i, o;
    r !== 0 && ((o = Math.cos(r)), (i = Math.sin(r)));
    const s = this.center;
    Lv(Pv.set(-0.5, -0.5, 0), qd, s, Yd, i, o),
      Lv(Bp.set(0.5, -0.5, 0), qd, s, Yd, i, o),
      Lv(Iv.set(0.5, 0.5, 0), qd, s, Yd, i, o),
      KE.set(0, 0),
      Y_.set(1, 0),
      ZE.set(1, 1);
    let l = e.ray.intersectTriangle(Pv, Bp, Iv, !1, Up);
    if (
      l === null &&
      (Lv(Bp.set(-0.5, 0.5, 0), qd, s, Yd, i, o),
      Y_.set(0, 1),
      (l = e.ray.intersectTriangle(Pv, Iv, Bp, !1, Up)),
      l === null)
    )
      return;
    const u = e.ray.origin.distanceTo(Up);
    u < e.near ||
      u > e.far ||
      t.push({
        distance: u,
        point: Up.clone(),
        uv: rs.getInterpolation(Up, Pv, Bp, Iv, KE, Y_, ZE, new tt()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Lv(n, e, t, r, i, o) {
  Kd.subVectors(n, t).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((Fp.x = o * Kd.x - i * Kd.y), (Fp.y = i * Kd.x + o * Kd.y))
      : Fp.copy(Kd),
    n.copy(e),
    (n.x += Fp.x),
    (n.y += Fp.y),
    n.applyMatrix4(sR);
}
const kv = new se(),
  JE = new se();
class lR extends _n {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(t < i[o].distance); o++);
    return (
      i.splice(o, 0, { distance: t, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), e < o)) break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      kv.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(kv);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      kv.setFromMatrixPosition(e.matrixWorld),
        JE.setFromMatrixPosition(this.matrixWorld);
      const r = kv.distanceTo(JE) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), r >= s))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < o; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const r = this.levels;
    for (let i = 0, o = r.length; i < o; i++) {
      const s = r[i];
      t.object.levels.push({
        object: s.object.uuid,
        distance: s.distance,
        hysteresis: s.hysteresis,
      });
    }
    return t;
  }
}
const QE = new se(),
  eT = new Tn(),
  tT = new Tn(),
  wV = new se(),
  nT = new Wt(),
  Dv = new se(),
  q_ = new Ni(),
  rT = new Wt(),
  K_ = new Tf();
class uR extends vr {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = Z1),
      (this.bindMatrix = new Wt()),
      (this.bindMatrixInverse = new Wt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new to()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, Dv), this.boundingBox.expandByPoint(Dv);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Ni()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, Dv), this.boundingSphere.expandByPoint(Dv);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      q_.copy(this.boundingSphere),
      q_.applyMatrix4(i),
      e.ray.intersectsSphere(q_) !== !1 &&
        (rT.copy(i).invert(),
        K_.copy(e.ray).applyMatrix4(rT),
        !(
          this.boundingBox !== null && K_.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, K_)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Tn(),
      t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0),
        t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === Z1
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === IA
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton,
      i = this.geometry;
    eT.fromBufferAttribute(i.attributes.skinIndex, e),
      tT.fromBufferAttribute(i.attributes.skinWeight, e),
      QE.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const s = tT.getComponent(o);
      if (s !== 0) {
        const l = eT.getComponent(o);
        nT.multiplyMatrices(r.bones[l].matrixWorld, r.boneInverses[l]),
          t.addScaledVector(wV.copy(QE).applyMatrix4(nT), s);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class bw extends _n {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Wa extends Qn {
  constructor(e = null, t = 1, r = 1, i, o, s, l, u, f = _i, h = _i, m, g) {
    super(null, s, l, u, f, h, i, o, m, g),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const iT = new Wt(),
  bV = new Wt();
class Yy {
  constructor(e = [], t = []) {
    (this.uuid = os()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new Wt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Wt();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let o = 0, s = e.length; o < s; o++) {
      const l = e[o] ? e[o].matrixWorld : bV;
      iT.multiplyMatrices(l, t[o]), iT.toArray(r, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Yy(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new Wa(t, e, e, Ji, Oo);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const o = e.bones[r];
      let s = t[o];
      s === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", o),
        (s = new bw())),
        this.bones.push(s),
        this.boneInverses.push(new Wt().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      r = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const s = t[i];
      e.bones.push(s.uuid);
      const l = r[i];
      e.boneInverses.push(l.toArray());
    }
    return e;
  }
}
class wf extends Gn {
  constructor(e, t, r, i = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Zd = new Wt(),
  oT = new Wt(),
  Nv = [],
  sT = new to(),
  MV = new Wt(),
  zp = new vr(),
  Hp = new Ni();
class cR extends vr {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new wf(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, MV);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new to()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Zd),
        sT.copy(e.boundingBox).applyMatrix4(Zd),
        this.boundingBox.union(sT);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Ni()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Zd),
        Hp.copy(e.boundingSphere).applyMatrix4(Zd),
        this.boundingSphere.union(Hp);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      o = r.length + 1,
      s = e * o + 1;
    for (let l = 0; l < r.length; l++) r[l] = i[s + l];
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((zp.geometry = this.geometry),
      (zp.material = this.material),
      zp.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Hp.copy(this.boundingSphere),
        Hp.applyMatrix4(r),
        e.ray.intersectsSphere(Hp) !== !1))
    )
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, Zd),
          oT.multiplyMatrices(r, Zd),
          (zp.matrixWorld = oT),
          zp.raycast(e, Nv);
        for (let s = 0, l = Nv.length; s < l; s++) {
          const u = Nv[s];
          (u.instanceId = o), (u.object = this), t.push(u);
        }
        Nv.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new wf(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = r.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Wa(
        new Float32Array(i * this.count),
        i,
        this.count,
        Oy,
        Oo
      ));
    const o = this.morphTexture.source.data.data;
    let s = 0;
    for (let f = 0; f < r.length; f++) s += r[f];
    const l = this.geometry.morphTargetsRelative ? 1 : 1 - s,
      u = i * e;
    (o[u] = l), o.set(r, u + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
function EV(n, e) {
  return n.z - e.z;
}
function TV(n, e) {
  return e.z - n.z;
}
class CV {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, r) {
    const i = this.pool,
      o = this.list;
    this.index >= i.length &&
      i.push({ start: -1, count: -1, z: -1, index: -1 });
    const s = i[this.index];
    o.push(s),
      this.index++,
      (s.start = e.start),
      (s.count = e.count),
      (s.z = t),
      (s.index = r);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Lu = new Wt(),
  Z_ = new Wt(),
  AV = new Wt(),
  RV = new St(1, 1, 1),
  aT = new Wt(),
  J_ = new ng(),
  Ov = new to(),
  Fc = new Ni(),
  Vp = new se(),
  lT = new se(),
  PV = new se(),
  Q_ = new CV(),
  Yi = new vr(),
  Uv = [];
function IV(n, e, t = 0) {
  const r = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const i = n.count;
    for (let o = 0; o < i; o++)
      for (let s = 0; s < r; s++)
        e.setComponent(o + t, s, n.getComponent(o, s));
  } else e.array.set(n.array, t * r);
  e.needsUpdate = !0;
}
class fR extends vr {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  constructor(e, t, r = t * 2, i) {
    super(new Jt(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawInfo = []),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._bounds = []),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = r),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      r = new Wa(t, e, e, Ji, Oo);
    this._matricesTexture = r;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      r = new Wa(t, e, e, Jm, Nl);
    this._indirectTexture = r;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxIndexCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      r = new Wa(t, e, e, Ji, Oo);
    (r.colorSpace = yn.workingColorSpace), (this._colorsTexture = r);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      r = this._maxVertexCount,
      i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const s = e.getAttribute(o),
          { array: l, itemSize: u, normalized: f } = s,
          h = new l.constructor(r * u),
          m = new Gn(h, u, f);
        t.setAttribute(o, m);
      }
      if (e.getIndex() !== null) {
        const o = r > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new Gn(o, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in t.attributes) {
      if (!e.hasAttribute(r))
        throw new Error(
          `BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        o = t.getAttribute(r);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new to());
    const e = this._geometryCount,
      t = this.boundingBox,
      r = this._drawInfo;
    t.makeEmpty();
    for (let i = 0; i < e; i++) {
      if (r[i].active === !1) continue;
      const o = r[i].geometryIndex;
      this.getMatrixAt(i, Lu),
        this.getBoundingBoxAt(o, Ov).applyMatrix4(Lu),
        t.union(Ov);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ni());
    const e = this.boundingSphere,
      t = this._drawInfo;
    e.makeEmpty();
    for (let r = 0, i = t.length; r < i; r++) {
      if (t[r].active === !1) continue;
      const o = t[r].geometryIndex;
      this.getMatrixAt(r, Lu),
        this.getBoundingSphereAt(o, Fc).applyMatrix4(Lu),
        e.union(Fc);
    }
  }
  addInstance(e) {
    if (this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    this._drawInfo.push({ visible: !0, active: !0, geometryIndex: e });
    const t = this._drawInfo.length - 1,
      r = this._matricesTexture,
      i = r.image.data;
    AV.toArray(i, t * 16), (r.needsUpdate = !0);
    const o = this._colorsTexture;
    return o && (RV.toArray(o.image.data, t * 4), (o.needsUpdate = !0)), t;
  }
  addGeometry(e, t = -1, r = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._drawInfo.length >= this._maxInstanceCount)
    )
      throw new Error("BatchedMesh: Maximum item count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let o = null;
    const s = this._reservedRanges,
      l = this._drawRanges,
      u = this._bounds;
    this._geometryCount !== 0 && (o = s[s.length - 1]),
      t === -1
        ? (i.vertexCount = e.getAttribute("position").count)
        : (i.vertexCount = t),
      o === null
        ? (i.vertexStart = 0)
        : (i.vertexStart = o.vertexStart + o.vertexCount);
    const f = e.getIndex(),
      h = f !== null;
    if (
      (h &&
        (r === -1 ? (i.indexCount = f.count) : (i.indexCount = r),
        o === null
          ? (i.indexStart = 0)
          : (i.indexStart = o.indexStart + o.indexCount)),
      (i.indexStart !== -1 &&
        i.indexStart + i.indexCount > this._maxIndexCount) ||
        i.vertexStart + i.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const m = this._geometryCount;
    return (
      this._geometryCount++,
      s.push(i),
      l.push({ start: h ? i.indexStart : i.vertexStart, count: -1 }),
      u.push({
        boxInitialized: !1,
        box: new to(),
        sphereInitialized: !1,
        sphere: new Ni(),
      }),
      this.setGeometryAt(m, e),
      m
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const r = this.geometry,
      i = r.getIndex() !== null,
      o = r.getIndex(),
      s = t.getIndex(),
      l = this._reservedRanges[e];
    if (
      (i && s.count > l.indexCount) ||
      t.attributes.position.count > l.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const u = l.vertexStart,
      f = l.vertexCount;
    for (const y in r.attributes) {
      const x = t.getAttribute(y),
        S = r.getAttribute(y);
      IV(x, S, u);
      const _ = x.itemSize;
      for (let w = x.count, T = f; w < T; w++) {
        const E = u + w;
        for (let A = 0; A < _; A++) S.setComponent(E, A, 0);
      }
      (S.needsUpdate = !0), S.addUpdateRange(u * _, f * _);
    }
    if (i) {
      const y = l.indexStart;
      for (let x = 0; x < s.count; x++) o.setX(y + x, u + s.getX(x));
      for (let x = s.count, S = l.indexCount; x < S; x++) o.setX(y + x, u);
      (o.needsUpdate = !0), o.addUpdateRange(y, l.indexCount);
    }
    const h = this._bounds[e];
    t.boundingBox !== null
      ? (h.box.copy(t.boundingBox), (h.boxInitialized = !0))
      : (h.boxInitialized = !1),
      t.boundingSphere !== null
        ? (h.sphere.copy(t.boundingSphere), (h.sphereInitialized = !0))
        : (h.sphereInitialized = !1);
    const m = this._drawRanges[e],
      g = t.getAttribute("position");
    return (m.count = i ? s.count : g.count), (this._visibilityChanged = !0), e;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this._bounds[e],
      i = r.box,
      o = this.geometry;
    if (r.boxInitialized === !1) {
      i.makeEmpty();
      const s = o.index,
        l = o.attributes.position,
        u = this._drawRanges[e];
      for (let f = u.start, h = u.start + u.count; f < h; f++) {
        let m = f;
        s && (m = s.getX(m)), i.expandByPoint(Vp.fromBufferAttribute(l, m));
      }
      r.boxInitialized = !0;
    }
    return t.copy(i), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this._bounds[e],
      i = r.sphere,
      o = this.geometry;
    if (r.sphereInitialized === !1) {
      i.makeEmpty(), this.getBoundingBoxAt(e, Ov), Ov.getCenter(i.center);
      const s = o.index,
        l = o.attributes.position,
        u = this._drawRanges[e];
      let f = 0;
      for (let h = u.start, m = u.start + u.count; h < m; h++) {
        let g = h;
        s && (g = s.getX(g)),
          Vp.fromBufferAttribute(l, g),
          (f = Math.max(f, i.center.distanceToSquared(Vp)));
      }
      (i.radius = Math.sqrt(f)), (r.sphereInitialized = !0);
    }
    return t.copy(i), t;
  }
  setMatrixAt(e, t) {
    const r = this._drawInfo,
      i = this._matricesTexture,
      o = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1
      ? this
      : (t.toArray(o, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    const r = this._drawInfo,
      i = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1 ? null : t.fromArray(i, e * 16);
  }
  setColorAt(e, t) {
    this._colorsTexture === null && this._initColorsTexture();
    const r = this._colorsTexture,
      i = this._colorsTexture.image.data,
      o = this._drawInfo;
    return e >= o.length || o[e].active === !1
      ? this
      : (t.toArray(i, e * 4), (r.needsUpdate = !0), this);
  }
  getColorAt(e, t) {
    const r = this._colorsTexture.image.data,
      i = this._drawInfo;
    return e >= i.length || i[e].active === !1 ? null : t.fromArray(r, e * 4);
  }
  setVisibleAt(e, t) {
    const r = this._drawInfo;
    return e >= r.length || r[e].active === !1 || r[e].visible === t
      ? this
      : ((r[e].visible = t), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const t = this._drawInfo;
    return e >= t.length || t[e].active === !1 ? !1 : t[e].visible;
  }
  raycast(e, t) {
    const r = this._drawInfo,
      i = this._drawRanges,
      o = this.matrixWorld,
      s = this.geometry;
    (Yi.material = this.material),
      (Yi.geometry.index = s.index),
      (Yi.geometry.attributes = s.attributes),
      Yi.geometry.boundingBox === null && (Yi.geometry.boundingBox = new to()),
      Yi.geometry.boundingSphere === null &&
        (Yi.geometry.boundingSphere = new Ni());
    for (let l = 0, u = r.length; l < u; l++) {
      if (!r[l].visible || !r[l].active) continue;
      const f = r[l].geometryIndex,
        h = i[f];
      Yi.geometry.setDrawRange(h.start, h.count),
        this.getMatrixAt(l, Yi.matrixWorld).premultiply(o),
        this.getBoundingBoxAt(f, Yi.geometry.boundingBox),
        this.getBoundingSphereAt(f, Yi.geometry.boundingSphere),
        Yi.raycast(e, Uv);
      for (let m = 0, g = Uv.length; m < g; m++) {
        const y = Uv[m];
        (y.object = this), (y.batchId = l), t.push(y);
      }
      Uv.length = 0;
    }
    (Yi.material = null),
      (Yi.geometry.index = null),
      (Yi.geometry.attributes = {}),
      Yi.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
      (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
      (this._drawInfo = e._drawInfo.map((t) => ({ ...t }))),
      (this._bounds = e._bounds.map((t) => ({
        boxInitialized: t.boxInitialized,
        box: t.box.clone(),
        sphereInitialized: t.sphereInitialized,
        sphere: t.sphere.clone(),
      }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, t, r, i, o) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const s = i.getIndex(),
      l = s === null ? 1 : s.array.BYTES_PER_ELEMENT,
      u = this._drawInfo,
      f = this._multiDrawStarts,
      h = this._multiDrawCounts,
      m = this._drawRanges,
      g = this.perObjectFrustumCulled,
      y = this._indirectTexture,
      x = y.image.data;
    g &&
      (aT
        .multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse)
        .multiply(this.matrixWorld),
      J_.setFromProjectionMatrix(aT, e.coordinateSystem));
    let S = 0;
    if (this.sortObjects) {
      Z_.copy(this.matrixWorld).invert(),
        Vp.setFromMatrixPosition(r.matrixWorld).applyMatrix4(Z_),
        lT
          .set(0, 0, -1)
          .transformDirection(r.matrixWorld)
          .transformDirection(Z_);
      for (let T = 0, E = u.length; T < E; T++)
        if (u[T].visible && u[T].active) {
          const A = u[T].geometryIndex;
          this.getMatrixAt(T, Lu),
            this.getBoundingSphereAt(A, Fc).applyMatrix4(Lu);
          let R = !1;
          if ((g && (R = !J_.intersectsSphere(Fc)), !R)) {
            const k = PV.subVectors(Fc.center, Vp).dot(lT);
            Q_.push(m[A], k, T);
          }
        }
      const _ = Q_.list,
        w = this.customSort;
      w === null ? _.sort(o.transparent ? TV : EV) : w.call(this, _, r);
      for (let T = 0, E = _.length; T < E; T++) {
        const A = _[T];
        (f[S] = A.start * l), (h[S] = A.count), (x[S] = A.index), S++;
      }
      Q_.reset();
    } else
      for (let _ = 0, w = u.length; _ < w; _++)
        if (u[_].visible && u[_].active) {
          const T = u[_].geometryIndex;
          let E = !1;
          if (
            (g &&
              (this.getMatrixAt(_, Lu),
              this.getBoundingSphereAt(T, Fc).applyMatrix4(Lu),
              (E = !J_.intersectsSphere(Fc))),
            !E)
          ) {
            const A = m[T];
            (f[S] = A.start * l), (h[S] = A.count), (x[S] = _), S++;
          }
        }
    (y.needsUpdate = !0),
      (this._multiDrawCount = S),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, r, i, o, s) {
    this.onBeforeRender(e, null, i, o, s);
  }
}
class vo extends Oi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const oy = new se(),
  sy = new se(),
  uT = new Wt(),
  Gp = new Tf(),
  Fv = new Ni(),
  e1 = new se(),
  cT = new se();
let ju = class extends _n {
  constructor(e = new Jt(), t = new vo()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let i = 1, o = t.count; i < o; i++)
        oy.fromBufferAttribute(t, i - 1),
          sy.fromBufferAttribute(t, i),
          (r[i] = r[i - 1]),
          (r[i] += oy.distanceTo(sy));
      e.setAttribute("lineDistance", new kt(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Line.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Fv.copy(r.boundingSphere),
      Fv.applyMatrix4(i),
      (Fv.radius += o),
      e.ray.intersectsSphere(Fv) === !1)
    )
      return;
    uT.copy(i).invert(), Gp.copy(e.ray).applyMatrix4(uT);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = l * l,
      f = this.isLineSegments ? 2 : 1,
      h = r.index,
      g = r.attributes.position;
    if (h !== null) {
      const y = Math.max(0, s.start),
        x = Math.min(h.count, s.start + s.count);
      for (let S = y, _ = x - 1; S < _; S += f) {
        const w = h.getX(S),
          T = h.getX(S + 1),
          E = Bv(this, e, Gp, u, w, T);
        E && t.push(E);
      }
      if (this.isLineLoop) {
        const S = h.getX(x - 1),
          _ = h.getX(y),
          w = Bv(this, e, Gp, u, S, _);
        w && t.push(w);
      }
    } else {
      const y = Math.max(0, s.start),
        x = Math.min(g.count, s.start + s.count);
      for (let S = y, _ = x - 1; S < _; S += f) {
        const w = Bv(this, e, Gp, u, S, S + 1);
        w && t.push(w);
      }
      if (this.isLineLoop) {
        const S = Bv(this, e, Gp, u, x - 1, y);
        S && t.push(S);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const l = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
};
function Bv(n, e, t, r, i, o) {
  const s = n.geometry.attributes.position;
  if (
    (oy.fromBufferAttribute(s, i),
    sy.fromBufferAttribute(s, o),
    t.distanceSqToSegment(oy, sy, e1, cT) > r)
  )
    return;
  e1.applyMatrix4(n.matrixWorld);
  const u = e.ray.origin.distanceTo(e1);
  if (!(u < e.near || u > e.far))
    return {
      distance: u,
      point: cT.clone().applyMatrix4(n.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: n,
    };
}
const fT = new se(),
  dT = new se();
class qa extends ju {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        fT.fromBufferAttribute(t, i),
          dT.fromBufferAttribute(t, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + fT.distanceTo(dT));
      e.setAttribute("lineDistance", new kt(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class dR extends ju {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Mw extends Oi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const hT = new Wt(),
  rS = new Tf(),
  zv = new Ni(),
  Hv = new se();
class hR extends _n {
  constructor(e = new Jt(), t = new Mw()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Points.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      zv.copy(r.boundingSphere),
      zv.applyMatrix4(i),
      (zv.radius += o),
      e.ray.intersectsSphere(zv) === !1)
    )
      return;
    hT.copy(i).invert(), rS.copy(e.ray).applyMatrix4(hT);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = l * l,
      f = r.index,
      m = r.attributes.position;
    if (f !== null) {
      const g = Math.max(0, s.start),
        y = Math.min(f.count, s.start + s.count);
      for (let x = g, S = y; x < S; x++) {
        const _ = f.getX(x);
        Hv.fromBufferAttribute(m, _), pT(Hv, _, u, i, e, t, this);
      }
    } else {
      const g = Math.max(0, s.start),
        y = Math.min(m.count, s.start + s.count);
      for (let x = g, S = y; x < S; x++)
        Hv.fromBufferAttribute(m, x), pT(Hv, x, u, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const l = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
}
function pT(n, e, t, r, i, o, s) {
  const l = rS.distanceSqToPoint(n);
  if (l < t) {
    const u = new se();
    rS.closestPointToPoint(n, u), u.applyMatrix4(r);
    const f = i.ray.origin.distanceTo(u);
    if (f < i.near || f > i.far) return;
    o.push({
      distance: f,
      distanceToRay: Math.sqrt(l),
      point: u,
      index: e,
      face: null,
      object: s,
    });
  }
}
class LV extends Qn {
  constructor(e, t, r, i, o, s, l, u, f) {
    super(e, t, r, i, o, s, l, u, f),
      (this.isVideoTexture = !0),
      (this.minFilter = s !== void 0 ? s : Cr),
      (this.magFilter = o !== void 0 ? o : Cr),
      (this.generateMipmaps = !1);
    const h = this;
    function m() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(m);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(m);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class kV extends Qn {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = _i),
      (this.minFilter = _i),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class qy extends Qn {
  constructor(e, t, r, i, o, s, l, u, f, h, m, g) {
    super(null, s, l, u, f, h, i, o, m, g),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class DV extends qy {
  constructor(e, t, r, i, o, s) {
    super(e, t, r, o, s),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = As),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class NV extends qy {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, Dl),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class OV extends Qn {
  constructor(e, t, r, i, o, s, l, u, f) {
    super(e, t, r, i, o, s, l, u, f),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class ca {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      i = this.getPoint(0),
      o = 0;
    t.push(0);
    for (let s = 1; s <= e; s++)
      (r = this.getPoint(s / e)), (o += r.distanceTo(i)), t.push(o), (i = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const o = r.length;
    let s;
    t ? (s = t) : (s = e * r[o - 1]);
    let l = 0,
      u = o - 1,
      f;
    for (; l <= u; )
      if (((i = Math.floor(l + (u - l) / 2)), (f = r[i] - s), f < 0)) l = i + 1;
      else if (f > 0) u = i - 1;
      else {
        u = i;
        break;
      }
    if (((i = u), r[i] === s)) return i / (o - 1);
    const h = r[i],
      g = r[i + 1] - h,
      y = (s - h) / g;
    return (i + y) / (o - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const s = this.getPoint(i),
      l = this.getPoint(o),
      u = t || (s.isVector2 ? new tt() : new se());
    return u.copy(l).sub(s).normalize(), u;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new se(),
      i = [],
      o = [],
      s = [],
      l = new se(),
      u = new Wt();
    for (let y = 0; y <= e; y++) {
      const x = y / e;
      i[y] = this.getTangentAt(x, new se());
    }
    (o[0] = new se()), (s[0] = new se());
    let f = Number.MAX_VALUE;
    const h = Math.abs(i[0].x),
      m = Math.abs(i[0].y),
      g = Math.abs(i[0].z);
    h <= f && ((f = h), r.set(1, 0, 0)),
      m <= f && ((f = m), r.set(0, 1, 0)),
      g <= f && r.set(0, 0, 1),
      l.crossVectors(i[0], r).normalize(),
      o[0].crossVectors(i[0], l),
      s[0].crossVectors(i[0], o[0]);
    for (let y = 1; y <= e; y++) {
      if (
        ((o[y] = o[y - 1].clone()),
        (s[y] = s[y - 1].clone()),
        l.crossVectors(i[y - 1], i[y]),
        l.length() > Number.EPSILON)
      ) {
        l.normalize();
        const x = Math.acos(Tr(i[y - 1].dot(i[y]), -1, 1));
        o[y].applyMatrix4(u.makeRotationAxis(l, x));
      }
      s[y].crossVectors(i[y], o[y]);
    }
    if (t === !0) {
      let y = Math.acos(Tr(o[0].dot(o[e]), -1, 1));
      (y /= e), i[0].dot(l.crossVectors(o[0], o[e])) > 0 && (y = -y);
      for (let x = 1; x <= e; x++)
        o[x].applyMatrix4(u.makeRotationAxis(i[x], y * x)),
          s[x].crossVectors(i[x], o[x]);
    }
    return { tangents: i, normals: o, binormals: s };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Ky extends ca {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    i = 1,
    o = 0,
    s = Math.PI * 2,
    l = !1,
    u = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = o),
      (this.aEndAngle = s),
      (this.aClockwise = l),
      (this.aRotation = u);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const s = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (s ? (o = 0) : (o = i)),
      this.aClockwise === !0 && !s && (o === i ? (o = -i) : (o = o - i));
    const l = this.aStartAngle + e * o;
    let u = this.aX + this.xRadius * Math.cos(l),
      f = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        m = Math.sin(this.aRotation),
        g = u - this.aX,
        y = f - this.aY;
      (u = g * h - y * m + this.aX), (f = g * m + y * h + this.aY);
    }
    return r.set(u, f);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class pR extends Ky {
  constructor(e, t, r, i, o, s) {
    super(e, t, r, r, i, o, s),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function Ew() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function i(o, s, l, u) {
    (n = o),
      (e = l),
      (t = -3 * o + 3 * s - 2 * l - u),
      (r = 2 * o - 2 * s + l + u);
  }
  return {
    initCatmullRom: function (o, s, l, u, f) {
      i(s, l, f * (l - o), f * (u - s));
    },
    initNonuniformCatmullRom: function (o, s, l, u, f, h, m) {
      let g = (s - o) / f - (l - o) / (f + h) + (l - s) / h,
        y = (l - s) / h - (u - s) / (h + m) + (u - l) / m;
      (g *= h), (y *= h), i(s, l, g, y);
    },
    calc: function (o) {
      const s = o * o,
        l = s * o;
      return n + e * o + t * s + r * l;
    },
  };
}
const Vv = new se(),
  t1 = new Ew(),
  n1 = new Ew(),
  r1 = new Ew();
class mR extends ca {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, t = new se()) {
    const r = t,
      i = this.points,
      o = i.length,
      s = (o - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(s),
      u = s - l;
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o)
      : u === 0 && l === o - 1 && ((l = o - 2), (u = 1));
    let f, h;
    this.closed || l > 0
      ? (f = i[(l - 1) % o])
      : (Vv.subVectors(i[0], i[1]).add(i[0]), (f = Vv));
    const m = i[l % o],
      g = i[(l + 1) % o];
    if (
      (this.closed || l + 2 < o
        ? (h = i[(l + 2) % o])
        : (Vv.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), (h = Vv)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const y = this.curveType === "chordal" ? 0.5 : 0.25;
      let x = Math.pow(f.distanceToSquared(m), y),
        S = Math.pow(m.distanceToSquared(g), y),
        _ = Math.pow(g.distanceToSquared(h), y);
      S < 1e-4 && (S = 1),
        x < 1e-4 && (x = S),
        _ < 1e-4 && (_ = S),
        t1.initNonuniformCatmullRom(f.x, m.x, g.x, h.x, x, S, _),
        n1.initNonuniformCatmullRom(f.y, m.y, g.y, h.y, x, S, _),
        r1.initNonuniformCatmullRom(f.z, m.z, g.z, h.z, x, S, _);
    } else
      this.curveType === "catmullrom" &&
        (t1.initCatmullRom(f.x, m.x, g.x, h.x, this.tension),
        n1.initCatmullRom(f.y, m.y, g.y, h.y, this.tension),
        r1.initCatmullRom(f.z, m.z, g.z, h.z, this.tension));
    return r.set(t1.calc(u), n1.calc(u), r1.calc(u)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new se().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function mT(n, e, t, r, i) {
  const o = (r - e) * 0.5,
    s = (i - t) * 0.5,
    l = n * n,
    u = n * l;
  return (
    (2 * t - 2 * r + o + s) * u + (-3 * t + 3 * r - 2 * o - s) * l + o * n + t
  );
}
function UV(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function FV(n, e) {
  return 2 * (1 - n) * n * e;
}
function BV(n, e) {
  return n * n * e;
}
function pm(n, e, t, r) {
  return UV(n, e) + FV(n, t) + BV(n, r);
}
function zV(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function HV(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function VV(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function GV(n, e) {
  return n * n * n * e;
}
function mm(n, e, t, r, i) {
  return zV(n, e) + HV(n, t) + VV(n, r) + GV(n, i);
}
class Tw extends ca {
  constructor(e = new tt(), t = new tt(), r = new tt(), i = new tt()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      l = this.v3;
    return r.set(mm(e, i.x, o.x, s.x, l.x), mm(e, i.y, o.y, s.y, l.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class gR extends ca {
  constructor(e = new se(), t = new se(), r = new se(), i = new se()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new se()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      l = this.v3;
    return (
      r.set(
        mm(e, i.x, o.x, s.x, l.x),
        mm(e, i.y, o.y, s.y, l.y),
        mm(e, i.z, o.z, s.z, l.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Cw extends ca {
  constructor(e = new tt(), t = new tt()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new tt()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new tt()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class vR extends ca {
  constructor(e = new se(), t = new se()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new se()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new se()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class Aw extends ca {
  constructor(e = new tt(), t = new tt(), r = new tt()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return r.set(pm(e, i.x, o.x, s.x), pm(e, i.y, o.y, s.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class Rw extends ca {
  constructor(e = new se(), t = new se(), r = new se()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new se()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return (
      r.set(pm(e, i.x, o.x, s.x), pm(e, i.y, o.y, s.y), pm(e, i.z, o.z, s.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class Pw extends ca {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.points,
      o = (i.length - 1) * e,
      s = Math.floor(o),
      l = o - s,
      u = i[s === 0 ? s : s - 1],
      f = i[s],
      h = i[s > i.length - 2 ? i.length - 1 : s + 1],
      m = i[s > i.length - 3 ? i.length - 1 : s + 2];
    return r.set(mT(l, u.x, f.x, h.x, m.x), mT(l, u.y, f.y, h.y, m.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new tt().fromArray(i));
    }
    return this;
  }
}
var ay = Object.freeze({
  __proto__: null,
  ArcCurve: pR,
  CatmullRomCurve3: mR,
  CubicBezierCurve: Tw,
  CubicBezierCurve3: gR,
  EllipseCurve: Ky,
  LineCurve: Cw,
  LineCurve3: vR,
  QuadraticBezierCurve: Aw,
  QuadraticBezierCurve3: Rw,
  SplineCurve: Pw,
});
class yR extends ca {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new ay[r](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= r) {
        const s = i[o] - r,
          l = this.curves[o],
          u = l.getLength(),
          f = u === 0 ? 0 : 1 - s / u;
        return l.getPointAt(f, t);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const s = o[i],
        l = s.isEllipseCurve
          ? e * 2
          : s.isLineCurve || s.isLineCurve3
          ? 1
          : s.isSplineCurve
          ? e * s.points.length
          : e,
        u = s.getPoints(l);
      for (let f = 0; f < u.length; f++) {
        const h = u[f];
        (r && r.equals(h)) || (t.push(h), (r = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new ay[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Bm extends yR {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new tt()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new Cw(this.currentPoint.clone(), new tt(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const o = new Aw(this.currentPoint.clone(), new tt(e, t), new tt(r, i));
    return this.curves.push(o), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, s) {
    const l = new Tw(
      this.currentPoint.clone(),
      new tt(e, t),
      new tt(r, i),
      new tt(o, s)
    );
    return this.curves.push(l), this.currentPoint.set(o, s), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new Pw(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, o, s) {
    const l = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absarc(e + l, t + u, r, i, o, s), this;
  }
  absarc(e, t, r, i, o, s) {
    return this.absellipse(e, t, r, r, i, o, s), this;
  }
  ellipse(e, t, r, i, o, s, l, u) {
    const f = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + f, t + h, r, i, o, s, l, u), this;
  }
  absellipse(e, t, r, i, o, s, l, u) {
    const f = new Ky(e, t, r, i, o, s, l, u);
    if (this.curves.length > 0) {
      const m = f.getPoint(0);
      m.equals(this.currentPoint) || this.lineTo(m.x, m.y);
    }
    this.curves.push(f);
    const h = f.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class rg extends Jt {
  constructor(
    e = [new tt(0, -0.5), new tt(0.5, 0), new tt(0, 0.5)],
    t = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }),
      (t = Math.floor(t)),
      (i = Tr(i, 0, Math.PI * 2));
    const o = [],
      s = [],
      l = [],
      u = [],
      f = [],
      h = 1 / t,
      m = new se(),
      g = new tt(),
      y = new se(),
      x = new se(),
      S = new se();
    let _ = 0,
      w = 0;
    for (let T = 0; T <= e.length - 1; T++)
      switch (T) {
        case 0:
          (_ = e[T + 1].x - e[T].x),
            (w = e[T + 1].y - e[T].y),
            (y.x = w * 1),
            (y.y = -_),
            (y.z = w * 0),
            S.copy(y),
            y.normalize(),
            u.push(y.x, y.y, y.z);
          break;
        case e.length - 1:
          u.push(S.x, S.y, S.z);
          break;
        default:
          (_ = e[T + 1].x - e[T].x),
            (w = e[T + 1].y - e[T].y),
            (y.x = w * 1),
            (y.y = -_),
            (y.z = w * 0),
            x.copy(y),
            (y.x += S.x),
            (y.y += S.y),
            (y.z += S.z),
            y.normalize(),
            u.push(y.x, y.y, y.z),
            S.copy(x);
      }
    for (let T = 0; T <= t; T++) {
      const E = r + T * h * i,
        A = Math.sin(E),
        R = Math.cos(E);
      for (let k = 0; k <= e.length - 1; k++) {
        (m.x = e[k].x * A),
          (m.y = e[k].y),
          (m.z = e[k].x * R),
          s.push(m.x, m.y, m.z),
          (g.x = T / t),
          (g.y = k / (e.length - 1)),
          l.push(g.x, g.y);
        const P = u[3 * k + 0] * A,
          U = u[3 * k + 1],
          N = u[3 * k + 0] * R;
        f.push(P, U, N);
      }
    }
    for (let T = 0; T < t; T++)
      for (let E = 0; E < e.length - 1; E++) {
        const A = E + T * e.length,
          R = A,
          k = A + e.length,
          P = A + e.length + 1,
          U = A + 1;
        o.push(R, k, U), o.push(P, U, k);
      }
    this.setIndex(o),
      this.setAttribute("position", new kt(s, 3)),
      this.setAttribute("uv", new kt(l, 2)),
      this.setAttribute("normal", new kt(f, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new rg(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Zy extends rg {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const o = new Bm();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      o.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(o.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new Zy(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Jy extends Jt {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: r,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const o = [],
      s = [],
      l = [],
      u = [],
      f = new se(),
      h = new tt();
    s.push(0, 0, 0), l.push(0, 0, 1), u.push(0.5, 0.5);
    for (let m = 0, g = 3; m <= t; m++, g += 3) {
      const y = r + (m / t) * i;
      (f.x = e * Math.cos(y)),
        (f.y = e * Math.sin(y)),
        s.push(f.x, f.y, f.z),
        l.push(0, 0, 1),
        (h.x = (s[g] / e + 1) / 2),
        (h.y = (s[g + 1] / e + 1) / 2),
        u.push(h.x, h.y);
    }
    for (let m = 1; m <= t; m++) o.push(m, m + 1, 0);
    this.setIndex(o),
      this.setAttribute("position", new kt(s, 3)),
      this.setAttribute("normal", new kt(l, 3)),
      this.setAttribute("uv", new kt(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Jy(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Fh extends Jt {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    i = 32,
    o = 1,
    s = !1,
    l = 0,
    u = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: i,
        heightSegments: o,
        openEnded: s,
        thetaStart: l,
        thetaLength: u,
      });
    const f = this;
    (i = Math.floor(i)), (o = Math.floor(o));
    const h = [],
      m = [],
      g = [],
      y = [];
    let x = 0;
    const S = [],
      _ = r / 2;
    let w = 0;
    T(),
      s === !1 && (e > 0 && E(!0), t > 0 && E(!1)),
      this.setIndex(h),
      this.setAttribute("position", new kt(m, 3)),
      this.setAttribute("normal", new kt(g, 3)),
      this.setAttribute("uv", new kt(y, 2));
    function T() {
      const A = new se(),
        R = new se();
      let k = 0;
      const P = (t - e) / r;
      for (let U = 0; U <= o; U++) {
        const N = [],
          L = U / o,
          H = L * (t - e) + e;
        for (let G = 0; G <= i; G++) {
          const $ = G / i,
            q = $ * u + l,
            Z = Math.sin(q),
            X = Math.cos(q);
          (R.x = H * Z),
            (R.y = -L * r + _),
            (R.z = H * X),
            m.push(R.x, R.y, R.z),
            A.set(Z, P, X).normalize(),
            g.push(A.x, A.y, A.z),
            y.push($, 1 - L),
            N.push(x++);
        }
        S.push(N);
      }
      for (let U = 0; U < i; U++)
        for (let N = 0; N < o; N++) {
          const L = S[N][U],
            H = S[N + 1][U],
            G = S[N + 1][U + 1],
            $ = S[N][U + 1];
          h.push(L, H, $), h.push(H, G, $), (k += 6);
        }
      f.addGroup(w, k, 0), (w += k);
    }
    function E(A) {
      const R = x,
        k = new tt(),
        P = new se();
      let U = 0;
      const N = A === !0 ? e : t,
        L = A === !0 ? 1 : -1;
      for (let G = 1; G <= i; G++)
        m.push(0, _ * L, 0), g.push(0, L, 0), y.push(0.5, 0.5), x++;
      const H = x;
      for (let G = 0; G <= i; G++) {
        const q = (G / i) * u + l,
          Z = Math.cos(q),
          X = Math.sin(q);
        (P.x = N * X),
          (P.y = _ * L),
          (P.z = N * Z),
          m.push(P.x, P.y, P.z),
          g.push(0, L, 0),
          (k.x = Z * 0.5 + 0.5),
          (k.y = X * 0.5 * L + 0.5),
          y.push(k.x, k.y),
          x++;
      }
      for (let G = 0; G < i; G++) {
        const $ = R + G,
          q = H + G;
        A === !0 ? h.push(q, q + 1, $) : h.push(q + 1, q, $), (U += 3);
      }
      f.addGroup(w, U, A === !0 ? 1 : 2), (w += U);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Fh(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Qy extends Fh {
  constructor(e = 1, t = 1, r = 32, i = 1, o = !1, s = 0, l = Math.PI * 2) {
    super(0, e, t, r, i, o, s, l),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: i,
        openEnded: o,
        thetaStart: s,
        thetaLength: l,
      });
  }
  static fromJSON(e) {
    return new Qy(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Yu extends Jt {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: i });
    const o = [],
      s = [];
    l(i),
      f(r),
      h(),
      this.setAttribute("position", new kt(o, 3)),
      this.setAttribute("normal", new kt(o.slice(), 3)),
      this.setAttribute("uv", new kt(s, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(T) {
      const E = new se(),
        A = new se(),
        R = new se();
      for (let k = 0; k < t.length; k += 3)
        y(t[k + 0], E), y(t[k + 1], A), y(t[k + 2], R), u(E, A, R, T);
    }
    function u(T, E, A, R) {
      const k = R + 1,
        P = [];
      for (let U = 0; U <= k; U++) {
        P[U] = [];
        const N = T.clone().lerp(A, U / k),
          L = E.clone().lerp(A, U / k),
          H = k - U;
        for (let G = 0; G <= H; G++)
          G === 0 && U === k
            ? (P[U][G] = N)
            : (P[U][G] = N.clone().lerp(L, G / H));
      }
      for (let U = 0; U < k; U++)
        for (let N = 0; N < 2 * (k - U) - 1; N++) {
          const L = Math.floor(N / 2);
          N % 2 === 0
            ? (g(P[U][L + 1]), g(P[U + 1][L]), g(P[U][L]))
            : (g(P[U][L + 1]), g(P[U + 1][L + 1]), g(P[U + 1][L]));
        }
    }
    function f(T) {
      const E = new se();
      for (let A = 0; A < o.length; A += 3)
        (E.x = o[A + 0]),
          (E.y = o[A + 1]),
          (E.z = o[A + 2]),
          E.normalize().multiplyScalar(T),
          (o[A + 0] = E.x),
          (o[A + 1] = E.y),
          (o[A + 2] = E.z);
    }
    function h() {
      const T = new se();
      for (let E = 0; E < o.length; E += 3) {
        (T.x = o[E + 0]), (T.y = o[E + 1]), (T.z = o[E + 2]);
        const A = _(T) / 2 / Math.PI + 0.5,
          R = w(T) / Math.PI + 0.5;
        s.push(A, 1 - R);
      }
      x(), m();
    }
    function m() {
      for (let T = 0; T < s.length; T += 6) {
        const E = s[T + 0],
          A = s[T + 2],
          R = s[T + 4],
          k = Math.max(E, A, R),
          P = Math.min(E, A, R);
        k > 0.9 &&
          P < 0.1 &&
          (E < 0.2 && (s[T + 0] += 1),
          A < 0.2 && (s[T + 2] += 1),
          R < 0.2 && (s[T + 4] += 1));
      }
    }
    function g(T) {
      o.push(T.x, T.y, T.z);
    }
    function y(T, E) {
      const A = T * 3;
      (E.x = e[A + 0]), (E.y = e[A + 1]), (E.z = e[A + 2]);
    }
    function x() {
      const T = new se(),
        E = new se(),
        A = new se(),
        R = new se(),
        k = new tt(),
        P = new tt(),
        U = new tt();
      for (let N = 0, L = 0; N < o.length; N += 9, L += 6) {
        T.set(o[N + 0], o[N + 1], o[N + 2]),
          E.set(o[N + 3], o[N + 4], o[N + 5]),
          A.set(o[N + 6], o[N + 7], o[N + 8]),
          k.set(s[L + 0], s[L + 1]),
          P.set(s[L + 2], s[L + 3]),
          U.set(s[L + 4], s[L + 5]),
          R.copy(T).add(E).add(A).divideScalar(3);
        const H = _(R);
        S(k, L + 0, T, H), S(P, L + 2, E, H), S(U, L + 4, A, H);
      }
    }
    function S(T, E, A, R) {
      R < 0 && T.x === 1 && (s[E] = T.x - 1),
        A.x === 0 && A.z === 0 && (s[E] = R / 2 / Math.PI + 0.5);
    }
    function _(T) {
      return Math.atan2(T.z, -T.x);
    }
    function w(T) {
      return Math.atan2(-T.y, Math.sqrt(T.x * T.x + T.z * T.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yu(e.vertices, e.indices, e.radius, e.details);
  }
}
class ex extends Yu {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      o = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      s = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(o, s, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new ex(e.radius, e.detail);
  }
}
const Gv = new se(),
  Wv = new se(),
  i1 = new se(),
  jv = new rs();
class xR extends Jt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        o = Math.cos(hf * t),
        s = e.getIndex(),
        l = e.getAttribute("position"),
        u = s ? s.count : l.count,
        f = [0, 0, 0],
        h = ["a", "b", "c"],
        m = new Array(3),
        g = {},
        y = [];
      for (let x = 0; x < u; x += 3) {
        s
          ? ((f[0] = s.getX(x)), (f[1] = s.getX(x + 1)), (f[2] = s.getX(x + 2)))
          : ((f[0] = x), (f[1] = x + 1), (f[2] = x + 2));
        const { a: S, b: _, c: w } = jv;
        if (
          (S.fromBufferAttribute(l, f[0]),
          _.fromBufferAttribute(l, f[1]),
          w.fromBufferAttribute(l, f[2]),
          jv.getNormal(i1),
          (m[0] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${Math.round(
            S.z * i
          )}`),
          (m[1] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(
            _.z * i
          )}`),
          (m[2] = `${Math.round(w.x * i)},${Math.round(w.y * i)},${Math.round(
            w.z * i
          )}`),
          !(m[0] === m[1] || m[1] === m[2] || m[2] === m[0]))
        )
          for (let T = 0; T < 3; T++) {
            const E = (T + 1) % 3,
              A = m[T],
              R = m[E],
              k = jv[h[T]],
              P = jv[h[E]],
              U = `${A}_${R}`,
              N = `${R}_${A}`;
            N in g && g[N]
              ? (i1.dot(g[N].normal) <= o &&
                  (y.push(k.x, k.y, k.z), y.push(P.x, P.y, P.z)),
                (g[N] = null))
              : U in g ||
                (g[U] = { index0: f[T], index1: f[E], normal: i1.clone() });
          }
      }
      for (const x in g)
        if (g[x]) {
          const { index0: S, index1: _ } = g[x];
          Gv.fromBufferAttribute(l, S),
            Wv.fromBufferAttribute(l, _),
            y.push(Gv.x, Gv.y, Gv.z),
            y.push(Wv.x, Wv.y, Wv.z);
        }
      this.setAttribute("position", new kt(y, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class mf extends Bm {
  constructor(e) {
    super(e), (this.uuid = os()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new Bm().fromJSON(i));
    }
    return this;
  }
}
const WV = {
  triangulate: function (n, e, t = 2) {
    const r = e && e.length,
      i = r ? e[0] * t : n.length;
    let o = _R(n, 0, i, t, !0);
    const s = [];
    if (!o || o.next === o.prev) return s;
    let l, u, f, h, m, g, y;
    if ((r && (o = qV(n, e, o, t)), n.length > 80 * t)) {
      (l = f = n[0]), (u = h = n[1]);
      for (let x = t; x < i; x += t)
        (m = n[x]),
          (g = n[x + 1]),
          m < l && (l = m),
          g < u && (u = g),
          m > f && (f = m),
          g > h && (h = g);
      (y = Math.max(f - l, h - u)), (y = y !== 0 ? 32767 / y : 0);
    }
    return zm(o, s, t, l, u, y, 0), s;
  },
};
function _R(n, e, t, r, i) {
  let o, s;
  if (i === s8(n, e, t, r) > 0)
    for (o = e; o < t; o += r) s = gT(o, n[o], n[o + 1], s);
  else for (o = t - r; o >= e; o -= r) s = gT(o, n[o], n[o + 1], s);
  return s && tx(s, s.next) && (Vm(s), (s = s.next)), s;
}
function bf(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1), !t.steiner && (tx(t, t.next) || gr(t.prev, t, t.next) === 0))
    ) {
      if ((Vm(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function zm(n, e, t, r, i, o, s) {
  if (!n) return;
  !s && o && e8(n, r, i, o);
  let l = n,
    u,
    f;
  for (; n.prev !== n.next; ) {
    if (((u = n.prev), (f = n.next), o ? $V(n, r, i, o) : jV(n))) {
      e.push((u.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((f.i / t) | 0),
        Vm(n),
        (n = f.next),
        (l = f.next);
      continue;
    }
    if (((n = f), n === l)) {
      s
        ? s === 1
          ? ((n = XV(bf(n), e, t)), zm(n, e, t, r, i, o, 2))
          : s === 2 && YV(n, e, t, r, i, o)
        : zm(bf(n), e, t, r, i, o, 1);
      break;
    }
  }
}
function jV(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (gr(e, t, r) >= 0) return !1;
  const i = e.x,
    o = t.x,
    s = r.x,
    l = e.y,
    u = t.y,
    f = r.y,
    h = i < o ? (i < s ? i : s) : o < s ? o : s,
    m = l < u ? (l < f ? l : f) : u < f ? u : f,
    g = i > o ? (i > s ? i : s) : o > s ? o : s,
    y = l > u ? (l > f ? l : f) : u > f ? u : f;
  let x = r.next;
  for (; x !== e; ) {
    if (
      x.x >= h &&
      x.x <= g &&
      x.y >= m &&
      x.y <= y &&
      fh(i, l, o, u, s, f, x.x, x.y) &&
      gr(x.prev, x, x.next) >= 0
    )
      return !1;
    x = x.next;
  }
  return !0;
}
function $V(n, e, t, r) {
  const i = n.prev,
    o = n,
    s = n.next;
  if (gr(i, o, s) >= 0) return !1;
  const l = i.x,
    u = o.x,
    f = s.x,
    h = i.y,
    m = o.y,
    g = s.y,
    y = l < u ? (l < f ? l : f) : u < f ? u : f,
    x = h < m ? (h < g ? h : g) : m < g ? m : g,
    S = l > u ? (l > f ? l : f) : u > f ? u : f,
    _ = h > m ? (h > g ? h : g) : m > g ? m : g,
    w = iS(y, x, e, t, r),
    T = iS(S, _, e, t, r);
  let E = n.prevZ,
    A = n.nextZ;
  for (; E && E.z >= w && A && A.z <= T; ) {
    if (
      (E.x >= y &&
        E.x <= S &&
        E.y >= x &&
        E.y <= _ &&
        E !== i &&
        E !== s &&
        fh(l, h, u, m, f, g, E.x, E.y) &&
        gr(E.prev, E, E.next) >= 0) ||
      ((E = E.prevZ),
      A.x >= y &&
        A.x <= S &&
        A.y >= x &&
        A.y <= _ &&
        A !== i &&
        A !== s &&
        fh(l, h, u, m, f, g, A.x, A.y) &&
        gr(A.prev, A, A.next) >= 0)
    )
      return !1;
    A = A.nextZ;
  }
  for (; E && E.z >= w; ) {
    if (
      E.x >= y &&
      E.x <= S &&
      E.y >= x &&
      E.y <= _ &&
      E !== i &&
      E !== s &&
      fh(l, h, u, m, f, g, E.x, E.y) &&
      gr(E.prev, E, E.next) >= 0
    )
      return !1;
    E = E.prevZ;
  }
  for (; A && A.z <= T; ) {
    if (
      A.x >= y &&
      A.x <= S &&
      A.y >= x &&
      A.y <= _ &&
      A !== i &&
      A !== s &&
      fh(l, h, u, m, f, g, A.x, A.y) &&
      gr(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.nextZ;
  }
  return !0;
}
function XV(n, e, t) {
  let r = n;
  do {
    const i = r.prev,
      o = r.next.next;
    !tx(i, o) &&
      SR(i, r, r.next, o) &&
      Hm(i, o) &&
      Hm(o, i) &&
      (e.push((i.i / t) | 0),
      e.push((r.i / t) | 0),
      e.push((o.i / t) | 0),
      Vm(r),
      Vm(r.next),
      (r = n = o)),
      (r = r.next);
  } while (r !== n);
  return bf(r);
}
function YV(n, e, t, r, i, o) {
  let s = n;
  do {
    let l = s.next.next;
    for (; l !== s.prev; ) {
      if (s.i !== l.i && r8(s, l)) {
        let u = wR(s, l);
        (s = bf(s, s.next)),
          (u = bf(u, u.next)),
          zm(s, e, t, r, i, o, 0),
          zm(u, e, t, r, i, o, 0);
        return;
      }
      l = l.next;
    }
    s = s.next;
  } while (s !== n);
}
function qV(n, e, t, r) {
  const i = [];
  let o, s, l, u, f;
  for (o = 0, s = e.length; o < s; o++)
    (l = e[o] * r),
      (u = o < s - 1 ? e[o + 1] * r : n.length),
      (f = _R(n, l, u, r, !1)),
      f === f.next && (f.steiner = !0),
      i.push(n8(f));
  for (i.sort(KV), o = 0; o < i.length; o++) t = ZV(i[o], t);
  return t;
}
function KV(n, e) {
  return n.x - e.x;
}
function ZV(n, e) {
  const t = JV(n, e);
  if (!t) return e;
  const r = wR(t, n);
  return bf(r, r.next), bf(t, t.next);
}
function JV(n, e) {
  let t = e,
    r = -1 / 0,
    i;
  const o = n.x,
    s = n.y;
  do {
    if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
      const g = t.x + ((s - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        g <= o &&
        g > r &&
        ((r = g), (i = t.x < t.next.x ? t : t.next), g === o)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const l = i,
    u = i.x,
    f = i.y;
  let h = 1 / 0,
    m;
  t = i;
  do
    o >= t.x &&
      t.x >= u &&
      o !== t.x &&
      fh(s < f ? o : r, s, u, f, s < f ? r : o, s, t.x, t.y) &&
      ((m = Math.abs(s - t.y) / (o - t.x)),
      Hm(t, n) &&
        (m < h || (m === h && (t.x > i.x || (t.x === i.x && QV(i, t))))) &&
        ((i = t), (h = m))),
      (t = t.next);
  while (t !== l);
  return i;
}
function QV(n, e) {
  return gr(n.prev, n, e.prev) < 0 && gr(e.next, n, n.next) < 0;
}
function e8(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = iS(i.x, i.y, e, t, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== n);
  (i.prevZ.nextZ = null), (i.prevZ = null), t8(i);
}
function t8(n) {
  let e,
    t,
    r,
    i,
    o,
    s,
    l,
    u,
    f = 1;
  do {
    for (t = n, n = null, o = null, s = 0; t; ) {
      for (s++, r = t, l = 0, e = 0; e < f && (l++, (r = r.nextZ), !!r); e++);
      for (u = f; l > 0 || (u > 0 && r); )
        l !== 0 && (u === 0 || !r || t.z <= r.z)
          ? ((i = t), (t = t.nextZ), l--)
          : ((i = r), (r = r.nextZ), u--),
          o ? (o.nextZ = i) : (n = i),
          (i.prevZ = o),
          (o = i);
      t = r;
    }
    (o.nextZ = null), (f *= 2);
  } while (s > 1);
  return n;
}
function iS(n, e, t, r, i) {
  return (
    (n = ((n - t) * i) | 0),
    (e = ((e - r) * i) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function n8(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function fh(n, e, t, r, i, o, s, l) {
  return (
    (i - s) * (e - l) >= (n - s) * (o - l) &&
    (n - s) * (r - l) >= (t - s) * (e - l) &&
    (t - s) * (o - l) >= (i - s) * (r - l)
  );
}
function r8(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !i8(n, e) &&
    ((Hm(n, e) &&
      Hm(e, n) &&
      o8(n, e) &&
      (gr(n.prev, n, e.prev) || gr(n, e.prev, e))) ||
      (tx(n, e) && gr(n.prev, n, n.next) > 0 && gr(e.prev, e, e.next) > 0))
  );
}
function gr(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function tx(n, e) {
  return n.x === e.x && n.y === e.y;
}
function SR(n, e, t, r) {
  const i = Xv(gr(n, e, t)),
    o = Xv(gr(n, e, r)),
    s = Xv(gr(t, r, n)),
    l = Xv(gr(t, r, e));
  return !!(
    (i !== o && s !== l) ||
    (i === 0 && $v(n, t, e)) ||
    (o === 0 && $v(n, r, e)) ||
    (s === 0 && $v(t, n, r)) ||
    (l === 0 && $v(t, e, r))
  );
}
function $v(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function Xv(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function i8(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      SR(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function Hm(n, e) {
  return gr(n.prev, n, n.next) < 0
    ? gr(n, e, n.next) >= 0 && gr(n, n.prev, e) >= 0
    : gr(n, e, n.prev) < 0 || gr(n, n.next, e) < 0;
}
function o8(n, e) {
  let t = n,
    r = !1;
  const i = (n.x + e.x) / 2,
    o = (n.y + e.y) / 2;
  do
    t.y > o != t.next.y > o &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (o - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function wR(n, e) {
  const t = new oS(n.i, n.x, n.y),
    r = new oS(e.i, e.x, e.y),
    i = n.next,
    o = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = i),
    (i.prev = t),
    (r.next = t),
    (t.prev = r),
    (o.next = r),
    (r.prev = o),
    r
  );
}
function gT(n, e, t, r) {
  const i = new oS(n, e, t);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Vm(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function oS(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function s8(n, e, t, r) {
  let i = 0;
  for (let o = e, s = t - r; o < t; o += r)
    (i += (n[s] - n[o]) * (n[o + 1] + n[s + 1])), (s = o);
  return i;
}
class ja {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, o = 0; o < t; i = o++)
      r += e[i].x * e[o].y - e[o].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return ja.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      i = [],
      o = [];
    vT(e), yT(r, e);
    let s = e.length;
    t.forEach(vT);
    for (let u = 0; u < t.length; u++)
      i.push(s), (s += t[u].length), yT(r, t[u]);
    const l = WV.triangulate(r, i);
    for (let u = 0; u < l.length; u += 3) o.push(l.slice(u, u + 3));
    return o;
  }
}
function vT(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function yT(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class nx extends Jt {
  constructor(
    e = new mf([
      new tt(0.5, 0.5),
      new tt(-0.5, 0.5),
      new tt(-0.5, -0.5),
      new tt(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      o = [];
    for (let l = 0, u = e.length; l < u; l++) {
      const f = e[l];
      s(f);
    }
    this.setAttribute("position", new kt(i, 3)),
      this.setAttribute("uv", new kt(o, 2)),
      this.computeVertexNormals();
    function s(l) {
      const u = [],
        f = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        m = t.depth !== void 0 ? t.depth : 1;
      let g = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        y = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        x = t.bevelSize !== void 0 ? t.bevelSize : y - 0.1,
        S = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        _ = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const w = t.extrudePath,
        T = t.UVGenerator !== void 0 ? t.UVGenerator : a8;
      let E,
        A = !1,
        R,
        k,
        P,
        U;
      w &&
        ((E = w.getSpacedPoints(h)),
        (A = !0),
        (g = !1),
        (R = w.computeFrenetFrames(h, !1)),
        (k = new se()),
        (P = new se()),
        (U = new se())),
        g || ((_ = 0), (y = 0), (x = 0), (S = 0));
      const N = l.extractPoints(f);
      let L = N.shape;
      const H = N.holes;
      if (!ja.isClockWise(L)) {
        L = L.reverse();
        for (let j = 0, we = H.length; j < we; j++) {
          const Ae = H[j];
          ja.isClockWise(Ae) && (H[j] = Ae.reverse());
        }
      }
      const $ = ja.triangulateShape(L, H),
        q = L;
      for (let j = 0, we = H.length; j < we; j++) {
        const Ae = H[j];
        L = L.concat(Ae);
      }
      function Z(j, we, Ae) {
        return (
          we || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          j.clone().addScaledVector(we, Ae)
        );
      }
      const X = L.length,
        re = $.length;
      function W(j, we, Ae) {
        let Ne, Ie, rt;
        const ke = j.x - we.x,
          Xe = j.y - we.y,
          ee = Ae.x - j.x,
          B = Ae.y - j.y,
          ve = ke * ke + Xe * Xe,
          Se = ke * B - Xe * ee;
        if (Math.abs(Se) > Number.EPSILON) {
          const _e = Math.sqrt(ve),
            Te = Math.sqrt(ee * ee + B * B),
            at = we.x - Xe / _e,
            Fe = we.y + ke / _e,
            Be = Ae.x - B / Te,
            We = Ae.y + ee / Te,
            Ye = ((Be - at) * B - (We - Fe) * ee) / (ke * B - Xe * ee);
          (Ne = at + ke * Ye - j.x), (Ie = Fe + Xe * Ye - j.y);
          const nt = Ne * Ne + Ie * Ie;
          if (nt <= 2) return new tt(Ne, Ie);
          rt = Math.sqrt(nt / 2);
        } else {
          let _e = !1;
          ke > Number.EPSILON
            ? ee > Number.EPSILON && (_e = !0)
            : ke < -Number.EPSILON
            ? ee < -Number.EPSILON && (_e = !0)
            : Math.sign(Xe) === Math.sign(B) && (_e = !0),
            _e
              ? ((Ne = -Xe), (Ie = ke), (rt = Math.sqrt(ve)))
              : ((Ne = ke), (Ie = Xe), (rt = Math.sqrt(ve / 2)));
        }
        return new tt(Ne / rt, Ie / rt);
      }
      const te = [];
      for (
        let j = 0, we = q.length, Ae = we - 1, Ne = j + 1;
        j < we;
        j++, Ae++, Ne++
      )
        Ae === we && (Ae = 0),
          Ne === we && (Ne = 0),
          (te[j] = W(q[j], q[Ae], q[Ne]));
      const F = [];
      let V,
        ne = te.concat();
      for (let j = 0, we = H.length; j < we; j++) {
        const Ae = H[j];
        V = [];
        for (
          let Ne = 0, Ie = Ae.length, rt = Ie - 1, ke = Ne + 1;
          Ne < Ie;
          Ne++, rt++, ke++
        )
          rt === Ie && (rt = 0),
            ke === Ie && (ke = 0),
            (V[Ne] = W(Ae[Ne], Ae[rt], Ae[ke]));
        F.push(V), (ne = ne.concat(V));
      }
      for (let j = 0; j < _; j++) {
        const we = j / _,
          Ae = y * Math.cos((we * Math.PI) / 2),
          Ne = x * Math.sin((we * Math.PI) / 2) + S;
        for (let Ie = 0, rt = q.length; Ie < rt; Ie++) {
          const ke = Z(q[Ie], te[Ie], Ne);
          le(ke.x, ke.y, -Ae);
        }
        for (let Ie = 0, rt = H.length; Ie < rt; Ie++) {
          const ke = H[Ie];
          V = F[Ie];
          for (let Xe = 0, ee = ke.length; Xe < ee; Xe++) {
            const B = Z(ke[Xe], V[Xe], Ne);
            le(B.x, B.y, -Ae);
          }
        }
      }
      const ae = x + S;
      for (let j = 0; j < X; j++) {
        const we = g ? Z(L[j], ne[j], ae) : L[j];
        A
          ? (P.copy(R.normals[0]).multiplyScalar(we.x),
            k.copy(R.binormals[0]).multiplyScalar(we.y),
            U.copy(E[0]).add(P).add(k),
            le(U.x, U.y, U.z))
          : le(we.x, we.y, 0);
      }
      for (let j = 1; j <= h; j++)
        for (let we = 0; we < X; we++) {
          const Ae = g ? Z(L[we], ne[we], ae) : L[we];
          A
            ? (P.copy(R.normals[j]).multiplyScalar(Ae.x),
              k.copy(R.binormals[j]).multiplyScalar(Ae.y),
              U.copy(E[j]).add(P).add(k),
              le(U.x, U.y, U.z))
            : le(Ae.x, Ae.y, (m / h) * j);
        }
      for (let j = _ - 1; j >= 0; j--) {
        const we = j / _,
          Ae = y * Math.cos((we * Math.PI) / 2),
          Ne = x * Math.sin((we * Math.PI) / 2) + S;
        for (let Ie = 0, rt = q.length; Ie < rt; Ie++) {
          const ke = Z(q[Ie], te[Ie], Ne);
          le(ke.x, ke.y, m + Ae);
        }
        for (let Ie = 0, rt = H.length; Ie < rt; Ie++) {
          const ke = H[Ie];
          V = F[Ie];
          for (let Xe = 0, ee = ke.length; Xe < ee; Xe++) {
            const B = Z(ke[Xe], V[Xe], Ne);
            A
              ? le(B.x, B.y + E[h - 1].y, E[h - 1].x + Ae)
              : le(B.x, B.y, m + Ae);
          }
        }
      }
      J(), oe();
      function J() {
        const j = i.length / 3;
        if (g) {
          let we = 0,
            Ae = X * we;
          for (let Ne = 0; Ne < re; Ne++) {
            const Ie = $[Ne];
            fe(Ie[2] + Ae, Ie[1] + Ae, Ie[0] + Ae);
          }
          (we = h + _ * 2), (Ae = X * we);
          for (let Ne = 0; Ne < re; Ne++) {
            const Ie = $[Ne];
            fe(Ie[0] + Ae, Ie[1] + Ae, Ie[2] + Ae);
          }
        } else {
          for (let we = 0; we < re; we++) {
            const Ae = $[we];
            fe(Ae[2], Ae[1], Ae[0]);
          }
          for (let we = 0; we < re; we++) {
            const Ae = $[we];
            fe(Ae[0] + X * h, Ae[1] + X * h, Ae[2] + X * h);
          }
        }
        r.addGroup(j, i.length / 3 - j, 0);
      }
      function oe() {
        const j = i.length / 3;
        let we = 0;
        de(q, we), (we += q.length);
        for (let Ae = 0, Ne = H.length; Ae < Ne; Ae++) {
          const Ie = H[Ae];
          de(Ie, we), (we += Ie.length);
        }
        r.addGroup(j, i.length / 3 - j, 1);
      }
      function de(j, we) {
        let Ae = j.length;
        for (; --Ae >= 0; ) {
          const Ne = Ae;
          let Ie = Ae - 1;
          Ie < 0 && (Ie = j.length - 1);
          for (let rt = 0, ke = h + _ * 2; rt < ke; rt++) {
            const Xe = X * rt,
              ee = X * (rt + 1),
              B = we + Ne + Xe,
              ve = we + Ie + Xe,
              Se = we + Ie + ee,
              _e = we + Ne + ee;
            Ee(B, ve, Se, _e);
          }
        }
      }
      function le(j, we, Ae) {
        u.push(j), u.push(we), u.push(Ae);
      }
      function fe(j, we, Ae) {
        ge(j), ge(we), ge(Ae);
        const Ne = i.length / 3,
          Ie = T.generateTopUV(r, i, Ne - 3, Ne - 2, Ne - 1);
        xe(Ie[0]), xe(Ie[1]), xe(Ie[2]);
      }
      function Ee(j, we, Ae, Ne) {
        ge(j), ge(we), ge(Ne), ge(we), ge(Ae), ge(Ne);
        const Ie = i.length / 3,
          rt = T.generateSideWallUV(r, i, Ie - 6, Ie - 3, Ie - 2, Ie - 1);
        xe(rt[0]), xe(rt[1]), xe(rt[3]), xe(rt[1]), xe(rt[2]), xe(rt[3]);
      }
      function ge(j) {
        i.push(u[j * 3 + 0]), i.push(u[j * 3 + 1]), i.push(u[j * 3 + 2]);
      }
      function xe(j) {
        o.push(j.x), o.push(j.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return l8(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let o = 0, s = e.shapes.length; o < s; o++) {
      const l = t[e.shapes[o]];
      r.push(l);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new ay[i.type]().fromJSON(i)),
      new nx(r, e.options)
    );
  }
}
const a8 = {
  generateTopUV: function (n, e, t, r, i) {
    const o = e[t * 3],
      s = e[t * 3 + 1],
      l = e[r * 3],
      u = e[r * 3 + 1],
      f = e[i * 3],
      h = e[i * 3 + 1];
    return [new tt(o, s), new tt(l, u), new tt(f, h)];
  },
  generateSideWallUV: function (n, e, t, r, i, o) {
    const s = e[t * 3],
      l = e[t * 3 + 1],
      u = e[t * 3 + 2],
      f = e[r * 3],
      h = e[r * 3 + 1],
      m = e[r * 3 + 2],
      g = e[i * 3],
      y = e[i * 3 + 1],
      x = e[i * 3 + 2],
      S = e[o * 3],
      _ = e[o * 3 + 1],
      w = e[o * 3 + 2];
    return Math.abs(l - h) < Math.abs(s - f)
      ? [new tt(s, 1 - u), new tt(f, 1 - m), new tt(g, 1 - x), new tt(S, 1 - w)]
      : [
          new tt(l, 1 - u),
          new tt(h, 1 - m),
          new tt(y, 1 - x),
          new tt(_, 1 - w),
        ];
  },
};
function l8(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      t.shapes.push(o.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class rx extends Yu {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      o = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, o, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new rx(e.radius, e.detail);
  }
}
class ig extends Yu {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new ig(e.radius, e.detail);
  }
}
class ix extends Jt {
  constructor(e = 0.5, t = 1, r = 32, i = 1, o = 0, s = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: o,
        thetaLength: s,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const l = [],
      u = [],
      f = [],
      h = [];
    let m = e;
    const g = (t - e) / i,
      y = new se(),
      x = new tt();
    for (let S = 0; S <= i; S++) {
      for (let _ = 0; _ <= r; _++) {
        const w = o + (_ / r) * s;
        (y.x = m * Math.cos(w)),
          (y.y = m * Math.sin(w)),
          u.push(y.x, y.y, y.z),
          f.push(0, 0, 1),
          (x.x = (y.x / t + 1) / 2),
          (x.y = (y.y / t + 1) / 2),
          h.push(x.x, x.y);
      }
      m += g;
    }
    for (let S = 0; S < i; S++) {
      const _ = S * (r + 1);
      for (let w = 0; w < r; w++) {
        const T = w + _,
          E = T,
          A = T + r + 1,
          R = T + r + 2,
          k = T + 1;
        l.push(E, A, k), l.push(A, R, k);
      }
    }
    this.setIndex(l),
      this.setAttribute("position", new kt(u, 3)),
      this.setAttribute("normal", new kt(f, 3)),
      this.setAttribute("uv", new kt(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ix(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ox extends Jt {
  constructor(
    e = new mf([new tt(0, 0.5), new tt(-0.5, -0.5), new tt(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const r = [],
      i = [],
      o = [],
      s = [];
    let l = 0,
      u = 0;
    if (Array.isArray(e) === !1) f(e);
    else
      for (let h = 0; h < e.length; h++)
        f(e[h]), this.addGroup(l, u, h), (l += u), (u = 0);
    this.setIndex(r),
      this.setAttribute("position", new kt(i, 3)),
      this.setAttribute("normal", new kt(o, 3)),
      this.setAttribute("uv", new kt(s, 2));
    function f(h) {
      const m = i.length / 3,
        g = h.extractPoints(t);
      let y = g.shape;
      const x = g.holes;
      ja.isClockWise(y) === !1 && (y = y.reverse());
      for (let _ = 0, w = x.length; _ < w; _++) {
        const T = x[_];
        ja.isClockWise(T) === !0 && (x[_] = T.reverse());
      }
      const S = ja.triangulateShape(y, x);
      for (let _ = 0, w = x.length; _ < w; _++) {
        const T = x[_];
        y = y.concat(T);
      }
      for (let _ = 0, w = y.length; _ < w; _++) {
        const T = y[_];
        i.push(T.x, T.y, 0), o.push(0, 0, 1), s.push(T.x, T.y);
      }
      for (let _ = 0, w = S.length; _ < w; _++) {
        const T = S[_],
          E = T[0] + m,
          A = T[1] + m,
          R = T[2] + m;
        r.push(E, A, R), (u += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return u8(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const s = t[e.shapes[i]];
      r.push(s);
    }
    return new ox(r, e.curveSegments);
  }
}
function u8(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class og extends Jt {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    i = 0,
    o = Math.PI * 2,
    s = 0,
    l = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: i,
        phiLength: o,
        thetaStart: s,
        thetaLength: l,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const u = Math.min(s + l, Math.PI);
    let f = 0;
    const h = [],
      m = new se(),
      g = new se(),
      y = [],
      x = [],
      S = [],
      _ = [];
    for (let w = 0; w <= r; w++) {
      const T = [],
        E = w / r;
      let A = 0;
      w === 0 && s === 0
        ? (A = 0.5 / t)
        : w === r && u === Math.PI && (A = -0.5 / t);
      for (let R = 0; R <= t; R++) {
        const k = R / t;
        (m.x = -e * Math.cos(i + k * o) * Math.sin(s + E * l)),
          (m.y = e * Math.cos(s + E * l)),
          (m.z = e * Math.sin(i + k * o) * Math.sin(s + E * l)),
          x.push(m.x, m.y, m.z),
          g.copy(m).normalize(),
          S.push(g.x, g.y, g.z),
          _.push(k + A, 1 - E),
          T.push(f++);
      }
      h.push(T);
    }
    for (let w = 0; w < r; w++)
      for (let T = 0; T < t; T++) {
        const E = h[w][T + 1],
          A = h[w][T],
          R = h[w + 1][T],
          k = h[w + 1][T + 1];
        (w !== 0 || s > 0) && y.push(E, A, k),
          (w !== r - 1 || u < Math.PI) && y.push(A, R, k);
      }
    this.setIndex(y),
      this.setAttribute("position", new kt(x, 3)),
      this.setAttribute("normal", new kt(S, 3)),
      this.setAttribute("uv", new kt(_, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new og(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class sx extends Yu {
  constructor(e = 1, t = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new sx(e.radius, e.detail);
  }
}
class ax extends Jt {
  constructor(e = 1, t = 0.4, r = 12, i = 48, o = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: i,
        arc: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const s = [],
      l = [],
      u = [],
      f = [],
      h = new se(),
      m = new se(),
      g = new se();
    for (let y = 0; y <= r; y++)
      for (let x = 0; x <= i; x++) {
        const S = (x / i) * o,
          _ = (y / r) * Math.PI * 2;
        (m.x = (e + t * Math.cos(_)) * Math.cos(S)),
          (m.y = (e + t * Math.cos(_)) * Math.sin(S)),
          (m.z = t * Math.sin(_)),
          l.push(m.x, m.y, m.z),
          (h.x = e * Math.cos(S)),
          (h.y = e * Math.sin(S)),
          g.subVectors(m, h).normalize(),
          u.push(g.x, g.y, g.z),
          f.push(x / i),
          f.push(y / r);
      }
    for (let y = 1; y <= r; y++)
      for (let x = 1; x <= i; x++) {
        const S = (i + 1) * y + x - 1,
          _ = (i + 1) * (y - 1) + x - 1,
          w = (i + 1) * (y - 1) + x,
          T = (i + 1) * y + x;
        s.push(S, _, T), s.push(_, w, T);
      }
    this.setIndex(s),
      this.setAttribute("position", new kt(l, 3)),
      this.setAttribute("normal", new kt(u, 3)),
      this.setAttribute("uv", new kt(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ax(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class lx extends Jt {
  constructor(e = 1, t = 0.4, r = 64, i = 8, o = 2, s = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: r,
        radialSegments: i,
        p: o,
        q: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const l = [],
      u = [],
      f = [],
      h = [],
      m = new se(),
      g = new se(),
      y = new se(),
      x = new se(),
      S = new se(),
      _ = new se(),
      w = new se();
    for (let E = 0; E <= r; ++E) {
      const A = (E / r) * o * Math.PI * 2;
      T(A, o, s, e, y),
        T(A + 0.01, o, s, e, x),
        _.subVectors(x, y),
        w.addVectors(x, y),
        S.crossVectors(_, w),
        w.crossVectors(S, _),
        S.normalize(),
        w.normalize();
      for (let R = 0; R <= i; ++R) {
        const k = (R / i) * Math.PI * 2,
          P = -t * Math.cos(k),
          U = t * Math.sin(k);
        (m.x = y.x + (P * w.x + U * S.x)),
          (m.y = y.y + (P * w.y + U * S.y)),
          (m.z = y.z + (P * w.z + U * S.z)),
          u.push(m.x, m.y, m.z),
          g.subVectors(m, y).normalize(),
          f.push(g.x, g.y, g.z),
          h.push(E / r),
          h.push(R / i);
      }
    }
    for (let E = 1; E <= r; E++)
      for (let A = 1; A <= i; A++) {
        const R = (i + 1) * (E - 1) + (A - 1),
          k = (i + 1) * E + (A - 1),
          P = (i + 1) * E + A,
          U = (i + 1) * (E - 1) + A;
        l.push(R, k, U), l.push(k, P, U);
      }
    this.setIndex(l),
      this.setAttribute("position", new kt(u, 3)),
      this.setAttribute("normal", new kt(f, 3)),
      this.setAttribute("uv", new kt(h, 2));
    function T(E, A, R, k, P) {
      const U = Math.cos(E),
        N = Math.sin(E),
        L = (R / A) * E,
        H = Math.cos(L);
      (P.x = k * (2 + H) * 0.5 * U),
        (P.y = k * (2 + H) * N * 0.5),
        (P.z = k * Math.sin(L) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new lx(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class ux extends Jt {
  constructor(
    e = new Rw(new se(-1, -1, 0), new se(-1, 1, 0), new se(1, 1, 0)),
    t = 64,
    r = 1,
    i = 8,
    o = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: i,
        closed: o,
      });
    const s = e.computeFrenetFrames(t, o);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals);
    const l = new se(),
      u = new se(),
      f = new tt();
    let h = new se();
    const m = [],
      g = [],
      y = [],
      x = [];
    S(),
      this.setIndex(x),
      this.setAttribute("position", new kt(m, 3)),
      this.setAttribute("normal", new kt(g, 3)),
      this.setAttribute("uv", new kt(y, 2));
    function S() {
      for (let E = 0; E < t; E++) _(E);
      _(o === !1 ? t : 0), T(), w();
    }
    function _(E) {
      h = e.getPointAt(E / t, h);
      const A = s.normals[E],
        R = s.binormals[E];
      for (let k = 0; k <= i; k++) {
        const P = (k / i) * Math.PI * 2,
          U = Math.sin(P),
          N = -Math.cos(P);
        (u.x = N * A.x + U * R.x),
          (u.y = N * A.y + U * R.y),
          (u.z = N * A.z + U * R.z),
          u.normalize(),
          g.push(u.x, u.y, u.z),
          (l.x = h.x + r * u.x),
          (l.y = h.y + r * u.y),
          (l.z = h.z + r * u.z),
          m.push(l.x, l.y, l.z);
      }
    }
    function w() {
      for (let E = 1; E <= t; E++)
        for (let A = 1; A <= i; A++) {
          const R = (i + 1) * (E - 1) + (A - 1),
            k = (i + 1) * E + (A - 1),
            P = (i + 1) * E + A,
            U = (i + 1) * (E - 1) + A;
          x.push(R, k, U), x.push(k, P, U);
        }
    }
    function T() {
      for (let E = 0; E <= t; E++)
        for (let A = 0; A <= i; A++)
          (f.x = E / t), (f.y = A / i), y.push(f.x, f.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new ux(
      new ay[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class bR extends Jt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        r = new Set(),
        i = new se(),
        o = new se();
      if (e.index !== null) {
        const s = e.attributes.position,
          l = e.index;
        let u = e.groups;
        u.length === 0 &&
          (u = [{ start: 0, count: l.count, materialIndex: 0 }]);
        for (let f = 0, h = u.length; f < h; ++f) {
          const m = u[f],
            g = m.start,
            y = m.count;
          for (let x = g, S = g + y; x < S; x += 3)
            for (let _ = 0; _ < 3; _++) {
              const w = l.getX(x + _),
                T = l.getX(x + ((_ + 1) % 3));
              i.fromBufferAttribute(s, w),
                o.fromBufferAttribute(s, T),
                xT(i, o, r) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const s = e.attributes.position;
        for (let l = 0, u = s.count / 3; l < u; l++)
          for (let f = 0; f < 3; f++) {
            const h = 3 * l + f,
              m = 3 * l + ((f + 1) % 3);
            i.fromBufferAttribute(s, h),
              o.fromBufferAttribute(s, m),
              xT(i, o, r) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new kt(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function xT(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var _T = Object.freeze({
  __proto__: null,
  BoxGeometry: Cf,
  CapsuleGeometry: Zy,
  CircleGeometry: Jy,
  ConeGeometry: Qy,
  CylinderGeometry: Fh,
  DodecahedronGeometry: ex,
  EdgesGeometry: xR,
  ExtrudeGeometry: nx,
  IcosahedronGeometry: rx,
  LatheGeometry: rg,
  OctahedronGeometry: ig,
  PlaneGeometry: Hl,
  PolyhedronGeometry: Yu,
  RingGeometry: ix,
  ShapeGeometry: ox,
  SphereGeometry: og,
  TetrahedronGeometry: sx,
  TorusGeometry: ax,
  TorusKnotGeometry: lx,
  TubeGeometry: ux,
  WireframeGeometry: bR,
});
class MR extends Oi {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new St(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class ER extends ua {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class Iw extends Oi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new St(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new as()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class TR extends Iw {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new tt(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Tr((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new St(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new St(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new St(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class CR extends Oi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new St(16777215)),
      (this.specular = new St(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new as()),
      (this.combine = Zm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class AR extends Oi {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class RR extends Oi {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class PR extends Oi {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new as()),
      (this.combine = Zm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class IR extends Oi {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new St(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xu),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class LR extends vo {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function uf(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function kR(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function DR(n) {
  function e(i, o) {
    return n[i] - n[o];
  }
  const t = n.length,
    r = new Array(t);
  for (let i = 0; i !== t; ++i) r[i] = i;
  return r.sort(e), r;
}
function sS(n, e, t) {
  const r = n.length,
    i = new n.constructor(r);
  for (let o = 0, s = 0; s !== r; ++o) {
    const l = t[o] * e;
    for (let u = 0; u !== e; ++u) i[s++] = n[l + u];
  }
  return i;
}
function Lw(n, e, t, r) {
  let i = 1,
    o = n[0];
  for (; o !== void 0 && o[r] === void 0; ) o = n[i++];
  if (o === void 0) return;
  let s = o[r];
  if (s !== void 0)
    if (Array.isArray(s))
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), t.push.apply(t, s)),
          (o = n[i++]);
      while (o !== void 0);
    else if (s.toArray !== void 0)
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), s.toArray(t, t.length)),
          (o = n[i++]);
      while (o !== void 0);
    else
      do (s = o[r]), s !== void 0 && (e.push(o.time), t.push(s)), (o = n[i++]);
      while (o !== void 0);
}
function c8(n, e, t, r, i = 30) {
  const o = n.clone();
  o.name = e;
  const s = [];
  for (let u = 0; u < o.tracks.length; ++u) {
    const f = o.tracks[u],
      h = f.getValueSize(),
      m = [],
      g = [];
    for (let y = 0; y < f.times.length; ++y) {
      const x = f.times[y] * i;
      if (!(x < t || x >= r)) {
        m.push(f.times[y]);
        for (let S = 0; S < h; ++S) g.push(f.values[y * h + S]);
      }
    }
    m.length !== 0 &&
      ((f.times = uf(m, f.times.constructor)),
      (f.values = uf(g, f.values.constructor)),
      s.push(f));
  }
  o.tracks = s;
  let l = 1 / 0;
  for (let u = 0; u < o.tracks.length; ++u)
    l > o.tracks[u].times[0] && (l = o.tracks[u].times[0]);
  for (let u = 0; u < o.tracks.length; ++u) o.tracks[u].shift(-1 * l);
  return o.resetDuration(), o;
}
function f8(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length,
    o = e / r;
  for (let s = 0; s < i; ++s) {
    const l = t.tracks[s],
      u = l.ValueTypeName;
    if (u === "bool" || u === "string") continue;
    const f = n.tracks.find(function (w) {
      return w.name === l.name && w.ValueTypeName === u;
    });
    if (f === void 0) continue;
    let h = 0;
    const m = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = m / 3);
    let g = 0;
    const y = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (g = y / 3);
    const x = l.times.length - 1;
    let S;
    if (o <= l.times[0]) {
      const w = h,
        T = m - h;
      S = l.values.slice(w, T);
    } else if (o >= l.times[x]) {
      const w = x * m + h,
        T = w + m - h;
      S = l.values.slice(w, T);
    } else {
      const w = l.createInterpolant(),
        T = h,
        E = m - h;
      w.evaluate(o), (S = w.resultBuffer.slice(T, E));
    }
    u === "quaternion" &&
      new eo().fromArray(S).normalize().conjugate().toArray(S);
    const _ = f.times.length;
    for (let w = 0; w < _; ++w) {
      const T = w * y + g;
      if (u === "quaternion")
        eo.multiplyQuaternionsFlat(f.values, T, S, 0, f.values, T);
      else {
        const E = y - g * 2;
        for (let A = 0; A < E; ++A) f.values[T + A] -= S[A];
      }
    }
  }
  return (n.blendMode = dw), n;
}
const d8 = {
  convertArray: uf,
  isTypedArray: kR,
  getKeyframeOrder: DR,
  sortedArray: sS,
  flattenJSON: Lw,
  subclip: c8,
  makeClipAdditive: f8,
};
class sg {
  constructor(e, t, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(r)),
      (this.sampleValues = t),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex,
      i = t[r],
      o = t[r - 1];
    e: {
      t: {
        let s;
        n: {
          r: if (!(e < i)) {
            for (let l = r + 2; ; ) {
              if (i === void 0) {
                if (e < o) break r;
                return (
                  (r = t.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === l) break;
              if (((o = i), (i = t[++r]), e < i)) break t;
            }
            s = t.length;
            break n;
          }
          if (!(e >= o)) {
            const l = t[1];
            e < l && ((r = 2), (o = l));
            for (let u = r - 2; ; ) {
              if (o === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === u) break;
              if (((i = o), (o = t[--r - 1]), e >= o)) break t;
            }
            (s = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < s; ) {
          const l = (r + s) >>> 1;
          e < t[l] ? (s = l) : (r = l + 1);
        }
        if (((i = t[r]), (o = t[r - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = t.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, o, i);
    }
    return this.interpolate_(r, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      o = e * i;
    for (let s = 0; s !== i; ++s) t[s] = r[o + s];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class NR extends sg {
  constructor(e, t, r, i) {
    super(e, t, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: sf, endingEnd: sf });
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let o = e - 2,
      s = e + 1,
      l = i[o],
      u = i[s];
    if (l === void 0)
      switch (this.getSettings_().endingStart) {
        case af:
          (o = e), (l = 2 * t - r);
          break;
        case Lm:
          (o = i.length - 2), (l = t + i[o] - i[o + 1]);
          break;
        default:
          (o = e), (l = r);
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case af:
          (s = e), (u = 2 * r - t);
          break;
        case Lm:
          (s = 1), (u = r + i[1] - i[0]);
          break;
        default:
          (s = e - 1), (u = t);
      }
    const f = (r - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = f / (t - l)),
      (this._weightNext = f / (u - r)),
      (this._offsetPrev = o * h),
      (this._offsetNext = s * h);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      l = this.valueSize,
      u = e * l,
      f = u - l,
      h = this._offsetPrev,
      m = this._offsetNext,
      g = this._weightPrev,
      y = this._weightNext,
      x = (r - t) / (i - t),
      S = x * x,
      _ = S * x,
      w = -g * _ + 2 * g * S - g * x,
      T = (1 + g) * _ + (-1.5 - 2 * g) * S + (-0.5 + g) * x + 1,
      E = (-1 - y) * _ + (1.5 + y) * S + 0.5 * x,
      A = y * _ - y * S;
    for (let R = 0; R !== l; ++R)
      o[R] = w * s[h + R] + T * s[f + R] + E * s[u + R] + A * s[m + R];
    return o;
  }
}
class kw extends sg {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      l = this.valueSize,
      u = e * l,
      f = u - l,
      h = (r - t) / (i - t),
      m = 1 - h;
    for (let g = 0; g !== l; ++g) o[g] = s[f + g] * m + s[u + g] * h;
    return o;
  }
}
class OR extends sg {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class fa {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = uf(t, this.TimeBufferType)),
      (this.values = uf(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON) r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: uf(e.times, Array),
        values: uf(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new OR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new kw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new NR(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Im:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ry:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case f0:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Im;
      case this.InterpolantFactoryMethodLinear:
        return ry;
      case this.InterpolantFactoryMethodSmooth:
        return f0;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times,
      i = r.length;
    let o = 0,
      s = i - 1;
    for (; o !== i && r[o] < e; ) ++o;
    for (; s !== -1 && r[s] > t; ) --s;
    if ((++s, o !== 0 || s !== i)) {
      o >= s && ((s = Math.max(s, 1)), (o = s - 1));
      const l = this.getValueSize();
      (this.times = r.slice(o, s)),
        (this.values = this.values.slice(o * l, s * l));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      o = r.length;
    o === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let s = null;
    for (let l = 0; l !== o; l++) {
      const u = r[l];
      if (typeof u == "number" && isNaN(u)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          l,
          u
        ),
          (e = !1);
        break;
      }
      if (s !== null && s > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, l, u, s),
          (e = !1);
        break;
      }
      s = u;
    }
    if (i !== void 0 && kR(i))
      for (let l = 0, u = i.length; l !== u; ++l) {
        const f = i[l];
        if (isNaN(f)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            l,
            f
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === f0,
      o = e.length - 1;
    let s = 1;
    for (let l = 1; l < o; ++l) {
      let u = !1;
      const f = e[l],
        h = e[l + 1];
      if (f !== h && (l !== 1 || f !== e[0]))
        if (i) u = !0;
        else {
          const m = l * r,
            g = m - r,
            y = m + r;
          for (let x = 0; x !== r; ++x) {
            const S = t[m + x];
            if (S !== t[g + x] || S !== t[y + x]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (l !== s) {
          e[s] = e[l];
          const m = l * r,
            g = s * r;
          for (let y = 0; y !== r; ++y) t[g + y] = t[m + y];
        }
        ++s;
      }
    }
    if (o > 0) {
      e[s] = e[o];
      for (let l = o * r, u = s * r, f = 0; f !== r; ++f) t[u + f] = t[l + f];
      ++s;
    }
    return (
      s !== e.length
        ? ((this.times = e.slice(0, s)), (this.values = t.slice(0, s * r)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
fa.prototype.TimeBufferType = Float32Array;
fa.prototype.ValueBufferType = Float32Array;
fa.prototype.DefaultInterpolation = ry;
class Af extends fa {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
Af.prototype.ValueTypeName = "bool";
Af.prototype.ValueBufferType = Array;
Af.prototype.DefaultInterpolation = Im;
Af.prototype.InterpolantFactoryMethodLinear = void 0;
Af.prototype.InterpolantFactoryMethodSmooth = void 0;
class Dw extends fa {}
Dw.prototype.ValueTypeName = "color";
class Gm extends fa {}
Gm.prototype.ValueTypeName = "number";
class UR extends sg {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      l = this.valueSize,
      u = (r - t) / (i - t);
    let f = e * l;
    for (let h = f + l; f !== h; f += 4) eo.slerpFlat(o, 0, s, f - l, s, f, u);
    return o;
  }
}
class ag extends fa {
  InterpolantFactoryMethodLinear(e) {
    return new UR(this.times, this.values, this.getValueSize(), e);
  }
}
ag.prototype.ValueTypeName = "quaternion";
ag.prototype.InterpolantFactoryMethodSmooth = void 0;
class Rf extends fa {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
Rf.prototype.ValueTypeName = "string";
Rf.prototype.ValueBufferType = Array;
Rf.prototype.DefaultInterpolation = Im;
Rf.prototype.InterpolantFactoryMethodLinear = void 0;
Rf.prototype.InterpolantFactoryMethodSmooth = void 0;
class Wm extends fa {}
Wm.prototype.ValueTypeName = "vector";
class jm {
  constructor(e = "", t = -1, r = [], i = By) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = os()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let s = 0, l = r.length; s !== l; ++s) t.push(p8(r[s]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const t = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let o = 0, s = r.length; o !== s; ++o) t.push(fa.toJSON(r[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const o = t.length,
      s = [];
    for (let l = 0; l < o; l++) {
      let u = [],
        f = [];
      u.push((l + o - 1) % o, l, (l + 1) % o), f.push(0, 1, 0);
      const h = DR(u);
      (u = sS(u, 1, h)),
        (f = sS(f, 1, h)),
        !i && u[0] === 0 && (u.push(o), f.push(f[0])),
        s.push(
          new Gm(".morphTargetInfluences[" + t[l].name + "]", u, f).scale(1 / r)
        );
    }
    return new this(e, -1, s);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let l = 0, u = e.length; l < u; l++) {
      const f = e[l],
        h = f.name.match(o);
      if (h && h.length > 1) {
        const m = h[1];
        let g = i[m];
        g || (i[m] = g = []), g.push(f);
      }
    }
    const s = [];
    for (const l in i)
      s.push(this.CreateFromMorphTargetSequence(l, i[l], t, r));
    return s;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (m, g, y, x, S) {
        if (y.length !== 0) {
          const _ = [],
            w = [];
          Lw(y, _, w, x), _.length !== 0 && S.push(new m(g, _, w));
        }
      },
      i = [],
      o = e.name || "default",
      s = e.fps || 30,
      l = e.blendMode;
    let u = e.length || -1;
    const f = e.hierarchy || [];
    for (let m = 0; m < f.length; m++) {
      const g = f[m].keys;
      if (!(!g || g.length === 0))
        if (g[0].morphTargets) {
          const y = {};
          let x;
          for (x = 0; x < g.length; x++)
            if (g[x].morphTargets)
              for (let S = 0; S < g[x].morphTargets.length; S++)
                y[g[x].morphTargets[S]] = -1;
          for (const S in y) {
            const _ = [],
              w = [];
            for (let T = 0; T !== g[x].morphTargets.length; ++T) {
              const E = g[x];
              _.push(E.time), w.push(E.morphTarget === S ? 1 : 0);
            }
            i.push(new Gm(".morphTargetInfluence[" + S + "]", _, w));
          }
          u = y.length * s;
        } else {
          const y = ".bones[" + t[m].name + "]";
          r(Wm, y + ".position", g, "pos", i),
            r(ag, y + ".quaternion", g, "rot", i),
            r(Wm, y + ".scale", g, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(o, u, i, l);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const o = this.tracks[r];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function h8(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Gm;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Wm;
    case "color":
      return Dw;
    case "quaternion":
      return ag;
    case "bool":
    case "boolean":
      return Af;
    case "string":
      return Rf;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function p8(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = h8(n.type);
  if (n.times === void 0) {
    const t = [],
      r = [];
    Lw(n.keys, t, r, "value"), (n.times = t), (n.values = r);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Rl = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class Nw {
  constructor(e, t, r) {
    const i = this;
    let o = !1,
      s = 0,
      l = 0,
      u;
    const f = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (h) {
        l++, o === !1 && i.onStart !== void 0 && i.onStart(h, s, l), (o = !0);
      }),
      (this.itemEnd = function (h) {
        s++,
          i.onProgress !== void 0 && i.onProgress(h, s, l),
          s === l && ((o = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (h) {
        i.onError !== void 0 && i.onError(h);
      }),
      (this.resolveURL = function (h) {
        return u ? u(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (u = h), this;
      }),
      (this.addHandler = function (h, m) {
        return f.push(h, m), this;
      }),
      (this.removeHandler = function (h) {
        const m = f.indexOf(h);
        return m !== -1 && f.splice(m, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let m = 0, g = f.length; m < g; m += 2) {
          const y = f[m],
            x = f[m + 1];
          if ((y.global && (y.lastIndex = 0), y.test(h))) return x;
        }
        return null;
      });
  }
}
const FR = new Nw();
class Bo {
  constructor(e) {
    (this.manager = e !== void 0 ? e : FR),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, o) {
      r.load(e, i, t, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
Bo.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ml = {};
class m8 extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Ol extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = Rl.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (Ml[e] !== void 0) {
      Ml[e].push({ onLoad: t, onProgress: r, onError: i });
      return;
    }
    (Ml[e] = []), Ml[e].push({ onLoad: t, onProgress: r, onError: i });
    const s = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      l = this.mimeType,
      u = this.responseType;
    fetch(s)
      .then((f) => {
        if (f.status === 200 || f.status === 0) {
          if (
            (f.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              f.body === void 0 ||
              f.body.getReader === void 0)
          )
            return f;
          const h = Ml[e],
            m = f.body.getReader(),
            g = f.headers.get("X-File-Size") || f.headers.get("Content-Length"),
            y = g ? parseInt(g) : 0,
            x = y !== 0;
          let S = 0;
          const _ = new ReadableStream({
            start(w) {
              T();
              function T() {
                m.read().then(
                  ({ done: E, value: A }) => {
                    if (E) w.close();
                    else {
                      S += A.byteLength;
                      const R = new ProgressEvent("progress", {
                        lengthComputable: x,
                        loaded: S,
                        total: y,
                      });
                      for (let k = 0, P = h.length; k < P; k++) {
                        const U = h[k];
                        U.onProgress && U.onProgress(R);
                      }
                      w.enqueue(A), T();
                    }
                  },
                  (E) => {
                    w.error(E);
                  }
                );
              }
            },
          });
          return new Response(_);
        } else
          throw new m8(
            `fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,
            f
          );
      })
      .then((f) => {
        switch (u) {
          case "arraybuffer":
            return f.arrayBuffer();
          case "blob":
            return f.blob();
          case "document":
            return f.text().then((h) => new DOMParser().parseFromString(h, l));
          case "json":
            return f.json();
          default:
            if (l === void 0) return f.text();
            {
              const m = /charset="?([^;"\s]*)"?/i.exec(l),
                g = m && m[1] ? m[1].toLowerCase() : void 0,
                y = new TextDecoder(g);
              return f.arrayBuffer().then((x) => y.decode(x));
            }
        }
      })
      .then((f) => {
        Rl.add(e, f);
        const h = Ml[e];
        delete Ml[e];
        for (let m = 0, g = h.length; m < g; m++) {
          const y = h[m];
          y.onLoad && y.onLoad(f);
        }
      })
      .catch((f) => {
        const h = Ml[e];
        if (h === void 0) throw (this.manager.itemError(e), f);
        delete Ml[e];
        for (let m = 0, g = h.length; m < g; m++) {
          const y = h[m];
          y.onError && y.onError(f);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class g8 extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Ol(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = jm.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class v8 extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = [],
      l = new qy(),
      u = new Ol(this.manager);
    u.setPath(this.path),
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(o.withCredentials);
    let f = 0;
    function h(m) {
      u.load(
        e[m],
        function (g) {
          const y = o.parse(g, !0);
          (s[m] = {
            width: y.width,
            height: y.height,
            format: y.format,
            mipmaps: y.mipmaps,
          }),
            (f += 1),
            f === 6 &&
              (y.mipmapCount === 1 && (l.minFilter = Cr),
              (l.image = s),
              (l.format = y.format),
              (l.needsUpdate = !0),
              t && t(l));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let m = 0, g = e.length; m < g; ++m) h(m);
    else
      u.load(
        e,
        function (m) {
          const g = o.parse(m, !0);
          if (g.isCubemap) {
            const y = g.mipmaps.length / g.mipmapCount;
            for (let x = 0; x < y; x++) {
              s[x] = { mipmaps: [] };
              for (let S = 0; S < g.mipmapCount; S++)
                s[x].mipmaps.push(g.mipmaps[x * g.mipmapCount + S]),
                  (s[x].format = g.format),
                  (s[x].width = g.width),
                  (s[x].height = g.height);
            }
            l.image = s;
          } else
            (l.image.width = g.width),
              (l.image.height = g.height),
              (l.mipmaps = g.mipmaps);
          g.mipmapCount === 1 && (l.minFilter = Cr),
            (l.format = g.format),
            (l.needsUpdate = !0),
            t && t(l);
        },
        r,
        i
      );
    return l;
  }
}
class $m extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Rl.get(e);
    if (s !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    const l = Fm("img");
    function u() {
      h(), Rl.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function f(m) {
      h(), i && i(m), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", u, !1),
        l.removeEventListener("error", f, !1);
    }
    return (
      l.addEventListener("load", u, !1),
      l.addEventListener("error", f, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (l.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (l.src = e),
      l
    );
  }
}
class y8 extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new tg();
    o.colorSpace = Ms;
    const s = new $m(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let l = 0;
    function u(f) {
      s.load(
        e[f],
        function (h) {
          (o.images[f] = h), l++, l === 6 && ((o.needsUpdate = !0), t && t(o));
        },
        void 0,
        i
      );
    }
    for (let f = 0; f < e.length; ++f) u(f);
    return o;
  }
}
class x8 extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Wa(),
      l = new Ol(this.manager);
    return (
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setPath(this.path),
      l.setWithCredentials(o.withCredentials),
      l.load(
        e,
        function (u) {
          let f;
          try {
            f = o.parse(u);
          } catch (h) {
            if (i !== void 0) i(h);
            else {
              console.error(h);
              return;
            }
          }
          f.image !== void 0
            ? (s.image = f.image)
            : f.data !== void 0 &&
              ((s.image.width = f.width),
              (s.image.height = f.height),
              (s.image.data = f.data)),
            (s.wrapS = f.wrapS !== void 0 ? f.wrapS : As),
            (s.wrapT = f.wrapT !== void 0 ? f.wrapT : As),
            (s.magFilter = f.magFilter !== void 0 ? f.magFilter : Cr),
            (s.minFilter = f.minFilter !== void 0 ? f.minFilter : Cr),
            (s.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1),
            f.colorSpace !== void 0 && (s.colorSpace = f.colorSpace),
            f.flipY !== void 0 && (s.flipY = f.flipY),
            f.format !== void 0 && (s.format = f.format),
            f.type !== void 0 && (s.type = f.type),
            f.mipmaps !== void 0 &&
              ((s.mipmaps = f.mipmaps), (s.minFilter = Ba)),
            f.mipmapCount === 1 && (s.minFilter = Cr),
            f.generateMipmaps !== void 0 &&
              (s.generateMipmaps = f.generateMipmaps),
            (s.needsUpdate = !0),
            t && t(s, f);
        },
        r,
        i
      ),
      s
    );
  }
}
class cx extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new Qn(),
      s = new $m(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (l) {
          (o.image = l), (o.needsUpdate = !0), t !== void 0 && t(o);
        },
        r,
        i
      ),
      o
    );
  }
}
class qu extends _n {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new St(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class BR extends qu {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(_n.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new St(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const o1 = new Wt(),
  ST = new se(),
  wT = new se();
class Ow {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new tt(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Wt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new ng()),
      (this._frameExtents = new tt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Tn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    ST.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(ST),
      wT.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(wT),
      t.updateMatrixWorld(),
      o1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(o1),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(o1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class _8 extends Ow {
  constructor() {
    super(new Or(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      r = Eh * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      o = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || o !== t.far) &&
      ((t.fov = r), (t.aspect = i), (t.far = o), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class zR extends qu {
  constructor(e, t, r = 0, i = Math.PI / 3, o = 0, s = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(_n.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new _n()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = o),
      (this.decay = s),
      (this.map = null),
      (this.shadow = new _8());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const bT = new Wt(),
  Wp = new se(),
  s1 = new se();
class S8 extends Ow {
  constructor() {
    super(new Or(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new tt(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Tn(2, 1, 1, 1),
        new Tn(0, 1, 1, 1),
        new Tn(3, 1, 1, 1),
        new Tn(1, 1, 1, 1),
        new Tn(3, 0, 1, 1),
        new Tn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new se(1, 0, 0),
        new se(-1, 0, 0),
        new se(0, 0, 1),
        new se(0, 0, -1),
        new se(0, 1, 0),
        new se(0, -1, 0),
      ]),
      (this._cubeUps = [
        new se(0, 1, 0),
        new se(0, 1, 0),
        new se(0, 1, 0),
        new se(0, 1, 0),
        new se(0, 0, 1),
        new se(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      i = this.matrix,
      o = e.distance || r.far;
    o !== r.far && ((r.far = o), r.updateProjectionMatrix()),
      Wp.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(Wp),
      s1.copy(r.position),
      s1.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(s1),
      r.updateMatrixWorld(),
      i.makeTranslation(-Wp.x, -Wp.y, -Wp.z),
      bT.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(bT);
  }
}
class HR extends qu {
  constructor(e, t, r = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new S8());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class w8 extends Ow {
  constructor() {
    super(new zu(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class VR extends qu {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(_n.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new _n()),
      (this.shadow = new w8());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class GR extends qu {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class WR extends qu {
  constructor(e, t, r = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class jR {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new se());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      t.copy(s[0]).multiplyScalar(0.282095),
      t.addScaledVector(s[1], 0.488603 * i),
      t.addScaledVector(s[2], 0.488603 * o),
      t.addScaledVector(s[3], 0.488603 * r),
      t.addScaledVector(s[4], 1.092548 * (r * i)),
      t.addScaledVector(s[5], 1.092548 * (i * o)),
      t.addScaledVector(s[6], 0.315392 * (3 * o * o - 1)),
      t.addScaledVector(s[7], 1.092548 * (r * o)),
      t.addScaledVector(s[8], 0.546274 * (r * r - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      t.copy(s[0]).multiplyScalar(0.886227),
      t.addScaledVector(s[1], 2 * 0.511664 * i),
      t.addScaledVector(s[2], 2 * 0.511664 * o),
      t.addScaledVector(s[3], 2 * 0.511664 * r),
      t.addScaledVector(s[4], 2 * 0.429043 * r * i),
      t.addScaledVector(s[5], 2 * 0.429043 * i * o),
      t.addScaledVector(s[6], 0.743125 * o * o - 0.247708),
      t.addScaledVector(s[7], 2 * 0.429043 * r * o),
      t.addScaledVector(s[8], 0.429043 * (r * r - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * o),
      (t[3] = 0.488603 * r),
      (t[4] = 1.092548 * r * i),
      (t[5] = 1.092548 * i * o),
      (t[6] = 0.315392 * (3 * o * o - 1)),
      (t[7] = 1.092548 * r * o),
      (t[8] = 0.546274 * (r * r - i * i));
  }
}
class $R extends qu {
  constructor(e = new jR(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class fx extends Bo {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, r, i) {
    const o = this,
      s = new Ol(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function r(o) {
      return (
        t[o] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", o),
        t[o]
      );
    }
    const i = fx.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new St().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const o in e.uniforms) {
        const s = e.uniforms[o];
        switch (((i.uniforms[o] = {}), s.type)) {
          case "t":
            i.uniforms[o].value = r(s.value);
            break;
          case "c":
            i.uniforms[o].value = new St().setHex(s.value);
            break;
          case "v2":
            i.uniforms[o].value = new tt().fromArray(s.value);
            break;
          case "v3":
            i.uniforms[o].value = new se().fromArray(s.value);
            break;
          case "v4":
            i.uniforms[o].value = new Tn().fromArray(s.value);
            break;
          case "m3":
            i.uniforms[o].value = new tn().fromArray(s.value);
            break;
          case "m4":
            i.uniforms[o].value = new Wt().fromArray(s.value);
            break;
          default:
            i.uniforms[o].value = s.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const o in e.extensions) i.extensions[o] = e.extensions[o];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]),
        (i.normalScale = new tt().fromArray(o));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new tt().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: MR,
      SpriteMaterial: ww,
      RawShaderMaterial: ER,
      ShaderMaterial: ua,
      PointsMaterial: Mw,
      MeshPhysicalMaterial: TR,
      MeshStandardMaterial: Iw,
      MeshPhongMaterial: CR,
      MeshToonMaterial: AR,
      MeshNormalMaterial: RR,
      MeshLambertMaterial: PR,
      MeshDepthMaterial: Gy,
      MeshDistanceMaterial: Wy,
      MeshBasicMaterial: zl,
      MeshMatcapMaterial: IR,
      LineDashedMaterial: LR,
      LineBasicMaterial: vo,
      Material: Oi,
    };
    return new t[e]();
  }
}
class aS {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class Uw extends Jt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class XR extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Ol(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = {},
      r = {};
    function i(y, x) {
      if (t[x] !== void 0) return t[x];
      const _ = y.interleavedBuffers[x],
        w = o(y, _.buffer),
        T = lh(_.type, w),
        E = new Xy(T, _.stride);
      return (E.uuid = _.uuid), (t[x] = E), E;
    }
    function o(y, x) {
      if (r[x] !== void 0) return r[x];
      const _ = y.arrayBuffers[x],
        w = new Uint32Array(_).buffer;
      return (r[x] = w), w;
    }
    const s = e.isInstancedBufferGeometry ? new Uw() : new Jt(),
      l = e.data.index;
    if (l !== void 0) {
      const y = lh(l.type, l.array);
      s.setIndex(new Gn(y, 1));
    }
    const u = e.data.attributes;
    for (const y in u) {
      const x = u[y];
      let S;
      if (x.isInterleavedBufferAttribute) {
        const _ = i(e.data, x.data);
        S = new Sf(_, x.itemSize, x.offset, x.normalized);
      } else {
        const _ = lh(x.type, x.array),
          w = x.isInstancedBufferAttribute ? wf : Gn;
        S = new w(_, x.itemSize, x.normalized);
      }
      x.name !== void 0 && (S.name = x.name),
        x.usage !== void 0 && S.setUsage(x.usage),
        s.setAttribute(y, S);
    }
    const f = e.data.morphAttributes;
    if (f)
      for (const y in f) {
        const x = f[y],
          S = [];
        for (let _ = 0, w = x.length; _ < w; _++) {
          const T = x[_];
          let E;
          if (T.isInterleavedBufferAttribute) {
            const A = i(e.data, T.data);
            E = new Sf(A, T.itemSize, T.offset, T.normalized);
          } else {
            const A = lh(T.type, T.array);
            E = new Gn(A, T.itemSize, T.normalized);
          }
          T.name !== void 0 && (E.name = T.name), S.push(E);
        }
        s.morphAttributes[y] = S;
      }
    e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const m = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (m !== void 0)
      for (let y = 0, x = m.length; y !== x; ++y) {
        const S = m[y];
        s.addGroup(S.start, S.count, S.materialIndex);
      }
    const g = e.data.boundingSphere;
    if (g !== void 0) {
      const y = new se();
      g.center !== void 0 && y.fromArray(g.center),
        (s.boundingSphere = new Ni(y, g.radius));
    }
    return (
      e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s
    );
  }
}
class b8 extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = this.path === "" ? aS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || s;
    const l = new Ol(this.manager);
    l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (u) {
          let f = null;
          try {
            f = JSON.parse(u);
          } catch (m) {
            i !== void 0 && i(m),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                m.message
              );
            return;
          }
          const h = f.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          o.parse(f, t);
        },
        r,
        i
      );
  }
  async loadAsync(e, t) {
    const r = this,
      i = this.path === "" ? aS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new Ol(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials);
    const s = await o.loadAsync(e, t),
      l = JSON.parse(s),
      u = l.metadata;
    if (
      u === void 0 ||
      u.type === void 0 ||
      u.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(l);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      o = this.parseGeometries(e.geometries, i),
      s = this.parseImages(e.images, function () {
        t !== void 0 && t(f);
      }),
      l = this.parseTextures(e.textures, s),
      u = this.parseMaterials(e.materials, l),
      f = this.parseObject(e.object, o, u, l, r),
      h = this.parseSkeletons(e.skeletons, f);
    if ((this.bindSkeletons(f, h), this.bindLightTargets(f), t !== void 0)) {
      let m = !1;
      for (const g in s)
        if (s[g].data instanceof HTMLImageElement) {
          m = !0;
          break;
        }
      m === !1 && t(f);
    }
    return f;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      o = await this.parseImagesAsync(e.images),
      s = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, s),
      u = this.parseObject(e.object, i, l, s, t),
      f = this.parseSkeletons(e.skeletons, u);
    return this.bindSkeletons(u, f), this.bindLightTargets(u), u;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const o = new mf().fromJSON(e[r]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {},
      i = {};
    if (
      (t.traverse(function (o) {
        o.isBone && (i[o.uuid] = o);
      }),
      e !== void 0)
    )
      for (let o = 0, s = e.length; o < s; o++) {
        const l = new Yy().fromJSON(e[o], i);
        r[l.uuid] = l;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new XR();
      for (let o = 0, s = e.length; o < s; o++) {
        let l;
        const u = e[o];
        switch (u.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            l = i.parse(u);
            break;
          default:
            u.type in _T
              ? (l = _T[u.type].fromJSON(u, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${u.type}"`
                );
        }
        (l.uuid = u.uuid),
          u.name !== void 0 && (l.name = u.name),
          u.userData !== void 0 && (l.userData = u.userData),
          (r[u.uuid] = l);
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const o = new fx();
      o.setTextures(t);
      for (let s = 0, l = e.length; s < l; s++) {
        const u = e[s];
        r[u.uuid] === void 0 && (r[u.uuid] = o.parse(u)),
          (i[u.uuid] = r[u.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          o = jm.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this,
      i = {};
    let o;
    function s(u) {
      return (
        r.manager.itemStart(u),
        o.load(
          u,
          function () {
            r.manager.itemEnd(u);
          },
          void 0,
          function () {
            r.manager.itemError(u), r.manager.itemEnd(u);
          }
        )
      );
    }
    function l(u) {
      if (typeof u == "string") {
        const f = u,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : r.resourcePath + f;
        return s(h);
      } else
        return u.data
          ? { data: lh(u.type, u.data), width: u.width, height: u.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const u = new Nw(t);
      (o = new $m(u)), o.setCrossOrigin(this.crossOrigin);
      for (let f = 0, h = e.length; f < h; f++) {
        const m = e[f],
          g = m.url;
        if (Array.isArray(g)) {
          const y = [];
          for (let x = 0, S = g.length; x < S; x++) {
            const _ = g[x],
              w = l(_);
            w !== null &&
              (w instanceof HTMLImageElement
                ? y.push(w)
                : y.push(new Wa(w.data, w.width, w.height)));
          }
          i[m.uuid] = new lf(y);
        } else {
          const y = l(m.url);
          i[m.uuid] = new lf(y);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      r = {};
    let i;
    async function o(s) {
      if (typeof s == "string") {
        const l = s,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
        return await i.loadAsync(u);
      } else
        return s.data
          ? { data: lh(s.type, s.data), width: s.width, height: s.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new $m(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let s = 0, l = e.length; s < l; s++) {
        const u = e[s],
          f = u.url;
        if (Array.isArray(f)) {
          const h = [];
          for (let m = 0, g = f.length; m < g; m++) {
            const y = f[m],
              x = await o(y);
            x !== null &&
              (x instanceof HTMLImageElement
                ? h.push(x)
                : h.push(new Wa(x.data, x.width, x.height)));
          }
          r[u.uuid] = new lf(h);
        } else {
          const h = await o(u.url);
          r[u.uuid] = new lf(h);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(o, s) {
      return typeof o == "number"
        ? o
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            o
          ),
          s[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, s = e.length; o < s; o++) {
        const l = e[o];
        l.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
          t[l.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", l.image);
        const u = t[l.image],
          f = u.data;
        let h;
        Array.isArray(f)
          ? ((h = new tg()), f.length === 6 && (h.needsUpdate = !0))
          : (f && f.data ? (h = new Wa()) : (h = new Qn()),
            f && (h.needsUpdate = !0)),
          (h.source = u),
          (h.uuid = l.uuid),
          l.name !== void 0 && (h.name = l.name),
          l.mapping !== void 0 && (h.mapping = r(l.mapping, M8)),
          l.channel !== void 0 && (h.channel = l.channel),
          l.offset !== void 0 && h.offset.fromArray(l.offset),
          l.repeat !== void 0 && h.repeat.fromArray(l.repeat),
          l.center !== void 0 && h.center.fromArray(l.center),
          l.rotation !== void 0 && (h.rotation = l.rotation),
          l.wrap !== void 0 &&
            ((h.wrapS = r(l.wrap[0], MT)), (h.wrapT = r(l.wrap[1], MT))),
          l.format !== void 0 && (h.format = l.format),
          l.internalFormat !== void 0 && (h.internalFormat = l.internalFormat),
          l.type !== void 0 && (h.type = l.type),
          l.colorSpace !== void 0 && (h.colorSpace = l.colorSpace),
          l.minFilter !== void 0 && (h.minFilter = r(l.minFilter, ET)),
          l.magFilter !== void 0 && (h.magFilter = r(l.magFilter, ET)),
          l.anisotropy !== void 0 && (h.anisotropy = l.anisotropy),
          l.flipY !== void 0 && (h.flipY = l.flipY),
          l.generateMipmaps !== void 0 &&
            (h.generateMipmaps = l.generateMipmaps),
          l.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = l.premultiplyAlpha),
          l.unpackAlignment !== void 0 &&
            (h.unpackAlignment = l.unpackAlignment),
          l.compareFunction !== void 0 &&
            (h.compareFunction = l.compareFunction),
          l.userData !== void 0 && (h.userData = l.userData),
          (i[l.uuid] = h);
      }
    return i;
  }
  parseObject(e, t, r, i, o) {
    let s;
    function l(g) {
      return (
        t[g] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", g),
        t[g]
      );
    }
    function u(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const y = [];
          for (let x = 0, S = g.length; x < S; x++) {
            const _ = g[x];
            r[_] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", _),
              y.push(r[_]);
          }
          return y;
        }
        return (
          r[g] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", g),
          r[g]
        );
      }
    }
    function f(g) {
      return (
        i[g] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", g),
        i[g]
      );
    }
    let h, m;
    switch (e.type) {
      case "Scene":
        (s = new iy()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (s.background = new St(e.background))
              : (s.background = f(e.background))),
          e.environment !== void 0 && (s.environment = f(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (s.fog = new $y(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (s.fog = new jy(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (s.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (s.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (s.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            s.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (s.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            s.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (s = new Or(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (s.focus = e.focus),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (s = new zu(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        s = new GR(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (s = new VR(e.color, e.intensity)), (s.target = e.target || "");
        break;
      case "PointLight":
        s = new HR(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        s = new WR(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (s = new zR(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (s.target = e.target || "");
        break;
      case "HemisphereLight":
        s = new BR(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        s = new $R().fromJSON(e);
        break;
      case "SkinnedMesh":
        (h = l(e.geometry)),
          (m = u(e.material)),
          (s = new uR(h, m)),
          e.bindMode !== void 0 && (s.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (s.skeleton = e.skeleton);
        break;
      case "Mesh":
        (h = l(e.geometry)), (m = u(e.material)), (s = new vr(h, m));
        break;
      case "InstancedMesh":
        (h = l(e.geometry)), (m = u(e.material));
        const g = e.count,
          y = e.instanceMatrix,
          x = e.instanceColor;
        (s = new cR(h, m, g)),
          (s.instanceMatrix = new wf(new Float32Array(y.array), 16)),
          x !== void 0 &&
            (s.instanceColor = new wf(new Float32Array(x.array), x.itemSize));
        break;
      case "BatchedMesh":
        (h = l(e.geometry)),
          (m = u(e.material)),
          (s = new fR(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            m
          )),
          (s.geometry = h),
          (s.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (s.sortObjects = e.sortObjects),
          (s._drawRanges = e.drawRanges),
          (s._reservedRanges = e.reservedRanges),
          (s._visibility = e.visibility),
          (s._active = e.active),
          (s._bounds = e.bounds.map((S) => {
            const _ = new to();
            _.min.fromArray(S.boxMin), _.max.fromArray(S.boxMax);
            const w = new Ni();
            return (
              (w.radius = S.sphereRadius),
              w.center.fromArray(S.sphereCenter),
              {
                boxInitialized: S.boxInitialized,
                box: _,
                sphereInitialized: S.sphereInitialized,
                sphere: w,
              }
            );
          })),
          (s._maxInstanceCount = e.maxInstanceCount),
          (s._maxVertexCount = e.maxVertexCount),
          (s._maxIndexCount = e.maxIndexCount),
          (s._geometryInitialized = e.geometryInitialized),
          (s._geometryCount = e.geometryCount),
          (s._matricesTexture = f(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (s._colorsTexture = f(e.colorsTexture.uuid));
        break;
      case "LOD":
        s = new lR();
        break;
      case "Line":
        s = new ju(l(e.geometry), u(e.material));
        break;
      case "LineLoop":
        s = new dR(l(e.geometry), u(e.material));
        break;
      case "LineSegments":
        s = new qa(l(e.geometry), u(e.material));
        break;
      case "PointCloud":
      case "Points":
        s = new hR(l(e.geometry), u(e.material));
        break;
      case "Sprite":
        s = new aR(u(e.material));
        break;
      case "Group":
        s = new ch();
        break;
      case "Bone":
        s = new bw();
        break;
      default:
        s = new _n();
    }
    if (
      ((s.uuid = e.uuid),
      e.name !== void 0 && (s.name = e.name),
      e.matrix !== void 0
        ? (s.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (s.matrixAutoUpdate = e.matrixAutoUpdate),
          s.matrixAutoUpdate &&
            s.matrix.decompose(s.position, s.quaternion, s.scale))
        : (e.position !== void 0 && s.position.fromArray(e.position),
          e.rotation !== void 0 && s.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && s.scale.fromArray(e.scale)),
      e.up !== void 0 && s.up.fromArray(e.up),
      e.castShadow !== void 0 && (s.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (s.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (s.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          s.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (s.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (s.visible = e.visible),
      e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder),
      e.userData !== void 0 && (s.userData = e.userData),
      e.layers !== void 0 && (s.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const g = e.children;
      for (let y = 0; y < g.length; y++)
        s.add(this.parseObject(g[y], t, r, i, o));
    }
    if (e.animations !== void 0) {
      const g = e.animations;
      for (let y = 0; y < g.length; y++) {
        const x = g[y];
        s.animations.push(o[x]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate);
      const g = e.levels;
      for (let y = 0; y < g.length; y++) {
        const x = g[y],
          S = s.getObjectByProperty("uuid", x.object);
        S !== void 0 && s.addLevel(S, x.distance, x.hysteresis);
      }
    }
    return s;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = t[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const r = t.target,
          i = e.getObjectByProperty("uuid", r);
        i !== void 0 ? (t.target = i) : (t.target = new _n());
      }
    });
  }
}
const M8 = {
    UVMapping: Ly,
    CubeReflectionMapping: Dl,
    CubeRefractionMapping: Wu,
    EquirectangularReflectionMapping: Cm,
    EquirectangularRefractionMapping: Am,
    CubeUVReflectionMapping: Nh,
  },
  MT = {
    RepeatWrapping: Rm,
    ClampToEdgeWrapping: As,
    MirroredRepeatWrapping: Pm,
  },
  ET = {
    NearestFilter: _i,
    NearestMipmapNearestFilter: nw,
    NearestMipmapLinearFilter: ah,
    LinearFilter: Cr,
    LinearMipmapNearestFilter: am,
    LinearMipmapLinearFilter: Ba,
  };
class E8 extends Bo {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Rl.get(e);
    if (s !== void 0) {
      if ((o.manager.itemStart(e), s.then)) {
        s.then((f) => {
          t && t(f), o.manager.itemEnd(e);
        }).catch((f) => {
          i && i(f);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    }
    const l = {};
    (l.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (l.headers = this.requestHeader);
    const u = fetch(e, l)
      .then(function (f) {
        return f.blob();
      })
      .then(function (f) {
        return createImageBitmap(
          f,
          Object.assign(o.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (f) {
        return Rl.add(e, f), t && t(f), o.manager.itemEnd(e), f;
      })
      .catch(function (f) {
        i && i(f), Rl.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
      });
    Rl.add(e, u), o.manager.itemStart(e);
  }
}
let Yv;
class Fw {
  static getContext() {
    return (
      Yv === void 0 &&
        (Yv = new (window.AudioContext || window.webkitAudioContext)()),
      Yv
    );
  }
  static setContext(e) {
    Yv = e;
  }
}
class T8 extends Bo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Ol(this.manager);
    s.setResponseType("arraybuffer"),
      s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (u) {
          try {
            const f = u.slice(0);
            Fw.getContext()
              .decodeAudioData(f, function (m) {
                t(m);
              })
              .catch(l);
          } catch (f) {
            l(f);
          }
        },
        r,
        i
      );
    function l(u) {
      i ? i(u) : console.error(u), o.manager.itemError(e);
    }
  }
}
const TT = new Wt(),
  CT = new Wt(),
  Bc = new Wt();
class C8 {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Or()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Or()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Bc.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        o = (i * t.near) / t.focus,
        s = (t.near * Math.tan(hf * t.fov * 0.5)) / t.zoom;
      let l, u;
      (CT.elements[12] = -i),
        (TT.elements[12] = i),
        (l = -s * t.aspect + o),
        (u = s * t.aspect + o),
        (Bc.elements[0] = (2 * t.near) / (u - l)),
        (Bc.elements[8] = (u + l) / (u - l)),
        this.cameraL.projectionMatrix.copy(Bc),
        (l = -s * t.aspect - o),
        (u = s * t.aspect - o),
        (Bc.elements[0] = (2 * t.near) / (u - l)),
        (Bc.elements[8] = (u + l) / (u - l)),
        this.cameraR.projectionMatrix.copy(Bc);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(CT),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(TT);
  }
}
class Bw {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = AT()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = AT();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function AT() {
  return (typeof performance > "u" ? Date : performance).now();
}
const zc = new se(),
  RT = new eo(),
  A8 = new se(),
  Hc = new se();
class R8 extends _n {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = Fw.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Bw());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(zc, RT, A8),
      Hc.set(0, 0, -1).applyQuaternion(RT),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(zc.x, i),
        t.positionY.linearRampToValueAtTime(zc.y, i),
        t.positionZ.linearRampToValueAtTime(zc.z, i),
        t.forwardX.linearRampToValueAtTime(Hc.x, i),
        t.forwardY.linearRampToValueAtTime(Hc.y, i),
        t.forwardZ.linearRampToValueAtTime(Hc.z, i),
        t.upX.linearRampToValueAtTime(r.x, i),
        t.upY.linearRampToValueAtTime(r.y, i),
        t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(zc.x, zc.y, zc.z),
        t.setOrientation(Hc.x, Hc.y, Hc.z, r.x, r.y, r.z);
  }
}
class YR extends _n {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const Vc = new se(),
  PT = new eo(),
  P8 = new se(),
  Gc = new se();
class I8 extends YR {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Vc, PT, P8), Gc.set(0, 0, 1).applyQuaternion(PT);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Vc.x, r),
        t.positionY.linearRampToValueAtTime(Vc.y, r),
        t.positionZ.linearRampToValueAtTime(Vc.z, r),
        t.orientationX.linearRampToValueAtTime(Gc.x, r),
        t.orientationY.linearRampToValueAtTime(Gc.y, r),
        t.orientationZ.linearRampToValueAtTime(Gc.z, r);
    } else t.setPosition(Vc.x, Vc.y, Vc.z), t.setOrientation(Gc.x, Gc.y, Gc.z);
  }
}
class L8 {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++) e += t[r];
    return e / t.length;
  }
}
class qR {
  constructor(e, t, r) {
    (this.binding = e), (this.valueSize = r);
    let i, o, s;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (o = this._slerpAdditive),
          (s = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (o = this._select),
          (s = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (o = this._lerpAdditive),
          (s = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = o),
      (this._setIdentity = s),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const r = this.buffer,
      i = this.valueSize,
      o = e * i + i;
    let s = this.cumulativeWeight;
    if (s === 0) {
      for (let l = 0; l !== i; ++l) r[o + l] = r[l];
      s = t;
    } else {
      s += t;
      const l = t / s;
      this._mixBufferRegion(r, o, 0, l, i);
    }
    this.cumulativeWeight = s;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      r = this.buffer,
      i = e * t + t,
      o = this.cumulativeWeight,
      s = this.cumulativeWeightAdditive,
      l = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), o < 1)
    ) {
      const u = t * this._origIndex;
      this._mixBufferRegion(r, i, u, 1 - o, t);
    }
    s > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let u = t, f = t + t; u !== f; ++u)
      if (r[u] !== r[u + t]) {
        l.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(t, i);
    for (let o = r, s = i; o !== s; ++o) t[o] = t[i + (o % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let r = e; r < t; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, o) {
    if (i >= 0.5) for (let s = 0; s !== o; ++s) e[t + s] = e[r + s];
  }
  _slerp(e, t, r, i) {
    eo.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, o) {
    const s = this._workIndex * o;
    eo.multiplyQuaternionsFlat(e, s, e, t, e, r),
      eo.slerpFlat(e, t, e, t, e, s, i);
  }
  _lerp(e, t, r, i, o) {
    const s = 1 - i;
    for (let l = 0; l !== o; ++l) {
      const u = t + l;
      e[u] = e[u] * s + e[r + l] * i;
    }
  }
  _lerpAdditive(e, t, r, i, o) {
    for (let s = 0; s !== o; ++s) {
      const l = t + s;
      e[l] = e[l] + e[r + s] * i;
    }
  }
}
const zw = "\\[\\]\\.:\\/",
  k8 = new RegExp("[" + zw + "]", "g"),
  Hw = "[^" + zw + "]",
  D8 = "[^" + zw.replace("\\.", "") + "]",
  N8 = /((?:WC+[\/:])*)/.source.replace("WC", Hw),
  O8 = /(WCOD+)?/.source.replace("WCOD", D8),
  U8 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hw),
  F8 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hw),
  B8 = new RegExp("^" + N8 + O8 + U8 + F8 + "$"),
  z8 = ["material", "materials", "bones", "map"];
class H8 {
  constructor(e, t, r) {
    const i = r || vn.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class vn {
  constructor(e, t, r) {
    (this.path = t),
      (this.parsedPath = r || vn.parseTrackName(t)),
      (this.node = vn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup
      ? new vn.Composite(e, t, r)
      : new vn(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(k8, "");
  }
  static parseTrackName(e) {
    const t = B8.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = r.nodeName.substring(i + 1);
      z8.indexOf(o) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = o));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (o) {
          for (let s = 0; s < o.length; s++) {
            const l = o[s];
            if (l.name === t || l.uuid === t) return l;
            const u = r(l.children);
            if (u) return u;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      r = t.objectName,
      i = t.propertyName;
    let o = t.propertyIndex;
    if (
      (e || ((e = vn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let f = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === f) {
              f = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[f];
      }
    }
    const s = e[i];
    if (s === void 0) {
      const f = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          f +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let l = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (l = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (l = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 &&
          (o = e.morphTargetDictionary[o]);
      }
      (u = this.BindingType.ArrayElement),
        (this.resolvedProperty = s),
        (this.propertyIndex = o);
    } else
      s.fromArray !== void 0 && s.toArray !== void 0
        ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
        : Array.isArray(s)
        ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = s))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[u]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[u][l]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
vn.Composite = H8;
vn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
vn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
vn.prototype.GetterByBindingType = [
  vn.prototype._getValue_direct,
  vn.prototype._getValue_array,
  vn.prototype._getValue_arrayElement,
  vn.prototype._getValue_toArray,
];
vn.prototype.SetterByBindingTypeAndVersioning = [
  [
    vn.prototype._setValue_direct,
    vn.prototype._setValue_direct_setNeedsUpdate,
    vn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    vn.prototype._setValue_array,
    vn.prototype._setValue_array_setNeedsUpdate,
    vn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    vn.prototype._setValue_arrayElement,
    vn.prototype._setValue_arrayElement_setNeedsUpdate,
    vn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    vn.prototype._setValue_fromArray,
    vn.prototype._setValue_fromArray_setNeedsUpdate,
    vn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class V8 {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = os()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      o = this._bindings,
      s = o.length;
    let l,
      u = e.length,
      f = this.nCachedObjects_;
    for (let h = 0, m = arguments.length; h !== m; ++h) {
      const g = arguments[h],
        y = g.uuid;
      let x = t[y];
      if (x === void 0) {
        (x = u++), (t[y] = x), e.push(g);
        for (let S = 0, _ = s; S !== _; ++S) o[S].push(new vn(g, r[S], i[S]));
      } else if (x < f) {
        l = e[x];
        const S = --f,
          _ = e[S];
        (t[_.uuid] = x), (e[x] = _), (t[y] = S), (e[S] = g);
        for (let w = 0, T = s; w !== T; ++w) {
          const E = o[w],
            A = E[S];
          let R = E[x];
          (E[x] = A), R === void 0 && (R = new vn(g, r[w], i[w])), (E[S] = R);
        }
      } else
        e[x] !== l &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_;
    for (let s = 0, l = arguments.length; s !== l; ++s) {
      const u = arguments[s],
        f = u.uuid,
        h = t[f];
      if (h !== void 0 && h >= o) {
        const m = o++,
          g = e[m];
        (t[g.uuid] = h), (e[h] = g), (t[f] = m), (e[m] = u);
        for (let y = 0, x = i; y !== x; ++y) {
          const S = r[y],
            _ = S[m],
            w = S[h];
          (S[h] = _), (S[m] = w);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_,
      s = e.length;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const f = arguments[l],
        h = f.uuid,
        m = t[h];
      if (m !== void 0)
        if ((delete t[h], m < o)) {
          const g = --o,
            y = e[g],
            x = --s,
            S = e[x];
          (t[y.uuid] = m), (e[m] = y), (t[S.uuid] = g), (e[g] = S), e.pop();
          for (let _ = 0, w = i; _ !== w; ++_) {
            const T = r[_],
              E = T[g],
              A = T[x];
            (T[m] = E), (T[g] = A), T.pop();
          }
        } else {
          const g = --s,
            y = e[g];
          g > 0 && (t[y.uuid] = m), (e[m] = y), e.pop();
          for (let x = 0, S = i; x !== S; ++x) {
            const _ = r[x];
            (_[m] = _[g]), _.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const s = this._paths,
      l = this._parsedPaths,
      u = this._objects,
      f = u.length,
      h = this.nCachedObjects_,
      m = new Array(f);
    (i = o.length), (r[e] = i), s.push(e), l.push(t), o.push(m);
    for (let g = h, y = u.length; g !== y; ++g) {
      const x = u[g];
      m[g] = new vn(x, e, t);
    }
    return m;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      r = t[e];
    if (r !== void 0) {
      const i = this._paths,
        o = this._parsedPaths,
        s = this._bindings,
        l = s.length - 1,
        u = s[l],
        f = e[l];
      (t[f] = r),
        (s[r] = u),
        s.pop(),
        (o[r] = o[l]),
        o.pop(),
        (i[r] = i[l]),
        i.pop();
    }
  }
}
class KR {
  constructor(e, t, r = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = r),
      (this.blendMode = i);
    const o = t.tracks,
      s = o.length,
      l = new Array(s),
      u = { endingStart: sf, endingEnd: sf };
    for (let f = 0; f !== s; ++f) {
      const h = o[f].createInterpolant(null);
      (l[f] = h), (h.settings = u);
    }
    (this._interpolantSettings = u),
      (this._interpolants = l),
      (this._propertyBindings = new Array(s)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = kA),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if ((e.fadeOut(t), this.fadeIn(t), r)) {
      const i = this._clip.duration,
        o = e._clip.duration,
        s = o / i,
        l = i / o;
      e.warp(1, s, t), this.warp(l, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer,
      o = i.time,
      s = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null &&
      ((l = i._lendControlInterpolant()), (this._timeScaleInterpolant = l));
    const u = l.parameterPositions,
      f = l.sampleValues;
    return (u[0] = o), (u[1] = o + r), (f[0] = e / s), (f[1] = t / s), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const u = (e - o) * r;
      u < 0 || r === 0 ? (t = 0) : ((this._startTime = null), (t = r * u));
    }
    t *= this._updateTimeScale(e);
    const s = this._updateTime(t),
      l = this._updateWeight(e);
    if (l > 0) {
      const u = this._interpolants,
        f = this._propertyBindings;
      switch (this.blendMode) {
        case dw:
          for (let h = 0, m = u.length; h !== m; ++h)
            u[h].evaluate(s), f[h].accumulateAdditive(l);
          break;
        case By:
        default:
          for (let h = 0, m = u.length; h !== m; ++h)
            u[h].evaluate(s), f[h].accumulate(i, l);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      o = this._loopCount;
    const s = r === DA;
    if (e === 0) return o === -1 ? i : s && (o & 1) === 1 ? t - i : i;
    if (r === LA) {
      o === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (o === -1 &&
          (e >= 0
            ? ((o = 0), this._setEndings(!0, this.repetitions === 0, s))
            : this._setEndings(this.repetitions === 0, !0, s)),
        i >= t || i < 0)
      ) {
        const l = Math.floor(i / t);
        (i -= t * l), (o += Math.abs(l));
        const u = this.repetitions - o;
        if (u <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (u === 1) {
            const f = e < 0;
            this._setEndings(f, !f, s);
          } else this._setEndings(!1, !1, s);
          (this._loopCount = o),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: l,
            });
        }
      } else this.time = i;
      if (s && (o & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = af), (i.endingEnd = af))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? af : sf)
          : (i.endingStart = Lm),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? af : sf) : (i.endingEnd = Lm));
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer,
      o = i.time;
    let s = this._weightInterpolant;
    s === null &&
      ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
    const l = s.parameterPositions,
      u = s.sampleValues;
    return (l[0] = o), (u[0] = t), (l[1] = o + e), (u[1] = r), this;
  }
}
const G8 = new Float32Array(1);
class W8 extends Bl {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      o = i.length,
      s = e._propertyBindings,
      l = e._interpolants,
      u = r.uuid,
      f = this._bindingsByRootAndName;
    let h = f[u];
    h === void 0 && ((h = {}), (f[u] = h));
    for (let m = 0; m !== o; ++m) {
      const g = i[m],
        y = g.name;
      let x = h[y];
      if (x !== void 0) ++x.referenceCount, (s[m] = x);
      else {
        if (((x = s[m]), x !== void 0)) {
          x._cacheIndex === null &&
            (++x.referenceCount, this._addInactiveBinding(x, u, y));
          continue;
        }
        const S = t && t._propertyBindings[m].binding.parsedPath;
        (x = new qR(vn.create(r, y, S), g.ValueTypeName, g.getValueSize())),
          ++x.referenceCount,
          this._addInactiveBinding(x, u, y),
          (s[m] = x);
      }
      l[m].resultBuffer = x.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          o = this._actionsByClip[i];
        this._bindAction(e, o && o.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        --o.useCount === 0 &&
          (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions,
      o = this._actionsByClip;
    let s = o[t];
    if (s === void 0)
      (s = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (o[t] = s);
    else {
      const l = s.knownActions;
      (e._byClipCacheIndex = l.length), l.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      r = t[t.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (t[i] = r), t.pop(), (e._cacheIndex = null);
    const o = e._clip.uuid,
      s = this._actionsByClip,
      l = s[o],
      u = l.knownActions,
      f = u[u.length - 1],
      h = e._byClipCacheIndex;
    (f._byClipCacheIndex = h),
      (u[h] = f),
      u.pop(),
      (e._byClipCacheIndex = null);
    const m = l.actionByRoot,
      g = (e._localRoot || this._root).uuid;
    delete m[g],
      u.length === 0 && delete s[o],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const o = t[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName,
      o = this._bindings;
    let s = i[t];
    s === void 0 && ((s = {}), (i[t] = s)),
      (s[r] = e),
      (e._cacheIndex = o.length),
      o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      o = r.path,
      s = this._bindingsByRootAndName,
      l = s[i],
      u = t[t.length - 1],
      f = e._cacheIndex;
    (u._cacheIndex = f),
      (t[f] = u),
      t.pop(),
      delete l[o],
      Object.keys(l).length === 0 && delete s[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let r = e[t];
    return (
      r === void 0 &&
        ((r = new kw(new Float32Array(2), new Float32Array(2), 1, G8)),
        (r.__cacheIndex = t),
        (e[t] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      o = t[i];
    (e.__cacheIndex = i), (t[i] = e), (o.__cacheIndex = r), (t[r] = o);
  }
  clipAction(e, t, r) {
    const i = t || this._root,
      o = i.uuid;
    let s = typeof e == "string" ? jm.findByName(i, e) : e;
    const l = s !== null ? s.uuid : e,
      u = this._actionsByClip[l];
    let f = null;
    if (
      (r === void 0 && (s !== null ? (r = s.blendMode) : (r = By)),
      u !== void 0)
    ) {
      const m = u.actionByRoot[o];
      if (m !== void 0 && m.blendMode === r) return m;
      (f = u.knownActions[0]), s === null && (s = f._clip);
    }
    if (s === null) return null;
    const h = new KR(this, s, t, r);
    return this._bindAction(h, f), this._addInactiveAction(h, l, o), h;
  }
  existingAction(e, t) {
    const r = t || this._root,
      i = r.uuid,
      o = typeof e == "string" ? jm.findByName(r, e) : e,
      s = o ? o.uuid : e,
      l = this._actionsByClip[s];
    return (l !== void 0 && l.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      o = Math.sign(e),
      s = (this._accuIndex ^= 1);
    for (let f = 0; f !== r; ++f) t[f]._update(i, e, o, s);
    const l = this._bindings,
      u = this._nActiveBindings;
    for (let f = 0; f !== u; ++f) l[f].apply(s);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      o = i[r];
    if (o !== void 0) {
      const s = o.knownActions;
      for (let l = 0, u = s.length; l !== u; ++l) {
        const f = s[l];
        this._deactivateAction(f);
        const h = f._cacheIndex,
          m = t[t.length - 1];
        (f._cacheIndex = null),
          (f._byClipCacheIndex = null),
          (m._cacheIndex = h),
          (t[h] = m),
          t.pop(),
          this._removeInactiveBindingsForAction(f);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      r = this._actionsByClip;
    for (const s in r) {
      const l = r[s].actionByRoot,
        u = l[t];
      u !== void 0 &&
        (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const i = this._bindingsByRootAndName,
      o = i[t];
    if (o !== void 0)
      for (const s in o) {
        const l = o[s];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class Vw {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new Vw(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let j8 = 0;
class $8 extends Bl {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: j8++ }),
      (this.name = ""),
      (this.usage = Om),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = Array.isArray(t[r]) ? t[r] : [t[r]];
      for (let s = 0; s < o.length; s++) this.uniforms.push(o[s].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class X8 extends Xy {
  constructor(e, t, r = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class Y8 {
  constructor(e, t, r, i, o) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const IT = new Wt();
class ZR {
  constructor(e, t, r = 0, i = 1 / 0) {
    (this.ray = new Tf(e, t)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new pf()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      IT.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(IT),
      this
    );
  }
  intersectObject(e, t = !0, r = []) {
    return lS(e, this, r, t), r.sort(LT), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, o = e.length; i < o; i++) lS(e[i], this, r, t);
    return r.sort(LT), r;
  }
}
function LT(n, e) {
  return n.distance - e.distance;
}
function lS(n, e, t, r) {
  let i = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (i = !1),
    i === !0 && r === !0)
  ) {
    const o = n.children;
    for (let s = 0, l = o.length; s < l; s++) lS(o[s], e, t, !0);
  }
}
class uS {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(Tr(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class q8 {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Gw {
  constructor(e, t, r, i) {
    (Gw.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 4; r++) this.elements[r] = e[r + t];
    return this;
  }
  set(e, t, r, i) {
    const o = this.elements;
    return (o[0] = e), (o[2] = t), (o[1] = r), (o[3] = i), this;
  }
}
const kT = new tt();
class K8 {
  constructor(e = new tt(1 / 0, 1 / 0), t = new tt(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = kT.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, kT).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const DT = new se(),
  qv = new se();
class Z8 {
  constructor(e = new se(), t = new se()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    DT.subVectors(e, this.start), qv.subVectors(this.end, this.start);
    const r = qv.dot(qv);
    let o = qv.dot(DT) / r;
    return t && (o = Tr(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const NT = new se();
class J8 extends _n {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const r = new Jt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let s = 0, l = 1, u = 32; s < u; s++, l++) {
      const f = (s / u) * Math.PI * 2,
        h = (l / u) * Math.PI * 2;
      i.push(Math.cos(f), Math.sin(f), 1, Math.cos(h), Math.sin(h), 1);
    }
    r.setAttribute("position", new kt(i, 3));
    const o = new vo({ fog: !1, toneMapped: !1 });
    (this.cone = new qa(r, o)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      NT.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(NT),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const ku = new se(),
  Kv = new Wt(),
  a1 = new Wt();
class Q8 extends qa {
  constructor(e) {
    const t = JR(e),
      r = new Jt(),
      i = [],
      o = [],
      s = new St(0, 0, 1),
      l = new St(0, 1, 0);
    for (let f = 0; f < t.length; f++) {
      const h = t[f];
      h.parent &&
        h.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        o.push(s.r, s.g, s.b),
        o.push(l.r, l.g, l.b));
    }
    r.setAttribute("position", new kt(i, 3)),
      r.setAttribute("color", new kt(o, 3));
    const u = new vo({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, u),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    a1.copy(this.root.matrixWorld).invert();
    for (let o = 0, s = 0; o < t.length; o++) {
      const l = t[o];
      l.parent &&
        l.parent.isBone &&
        (Kv.multiplyMatrices(a1, l.matrixWorld),
        ku.setFromMatrixPosition(Kv),
        i.setXYZ(s, ku.x, ku.y, ku.z),
        Kv.multiplyMatrices(a1, l.parent.matrixWorld),
        ku.setFromMatrixPosition(Kv),
        i.setXYZ(s + 1, ku.x, ku.y, ku.z),
        (s += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function JR(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, JR(n.children[t]));
  return e;
}
class eG extends vr {
  constructor(e, t, r) {
    const i = new og(t, 4, 2),
      o = new zl({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const tG = new se(),
  OT = new St(),
  UT = new St();
class nG extends _n {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new ig(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new zl({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"),
      s = new Float32Array(o.count * 3);
    i.setAttribute("color", new Gn(s, 3)),
      this.add(new vr(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      OT.copy(this.light.color), UT.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const o = r < i / 2 ? OT : UT;
        t.setXYZ(r, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(tG.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class rG extends qa {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    (r = new St(r)), (i = new St(i));
    const o = t / 2,
      s = e / t,
      l = e / 2,
      u = [],
      f = [];
    for (let g = 0, y = 0, x = -l; g <= t; g++, x += s) {
      u.push(-l, 0, x, l, 0, x), u.push(x, 0, -l, x, 0, l);
      const S = g === o ? r : i;
      S.toArray(f, y),
        (y += 3),
        S.toArray(f, y),
        (y += 3),
        S.toArray(f, y),
        (y += 3),
        S.toArray(f, y),
        (y += 3);
    }
    const h = new Jt();
    h.setAttribute("position", new kt(u, 3)),
      h.setAttribute("color", new kt(f, 3));
    const m = new vo({ vertexColors: !0, toneMapped: !1 });
    super(h, m), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class iG extends qa {
  constructor(e = 10, t = 16, r = 8, i = 64, o = 4473924, s = 8947848) {
    (o = new St(o)), (s = new St(s));
    const l = [],
      u = [];
    if (t > 1)
      for (let m = 0; m < t; m++) {
        const g = (m / t) * (Math.PI * 2),
          y = Math.sin(g) * e,
          x = Math.cos(g) * e;
        l.push(0, 0, 0), l.push(y, 0, x);
        const S = m & 1 ? o : s;
        u.push(S.r, S.g, S.b), u.push(S.r, S.g, S.b);
      }
    for (let m = 0; m < r; m++) {
      const g = m & 1 ? o : s,
        y = e - (e / r) * m;
      for (let x = 0; x < i; x++) {
        let S = (x / i) * (Math.PI * 2),
          _ = Math.sin(S) * y,
          w = Math.cos(S) * y;
        l.push(_, 0, w),
          u.push(g.r, g.g, g.b),
          (S = ((x + 1) / i) * (Math.PI * 2)),
          (_ = Math.sin(S) * y),
          (w = Math.cos(S) * y),
          l.push(_, 0, w),
          u.push(g.r, g.g, g.b);
      }
    }
    const f = new Jt();
    f.setAttribute("position", new kt(l, 3)),
      f.setAttribute("color", new kt(u, 3));
    const h = new vo({ vertexColors: !0, toneMapped: !1 });
    super(f, h), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const FT = new se(),
  Zv = new se(),
  BT = new se();
class oG extends _n {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new Jt();
    i.setAttribute(
      "position",
      new kt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const o = new vo({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new ju(i, o)),
      this.add(this.lightPlane),
      (i = new Jt()),
      i.setAttribute("position", new kt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new ju(i, o)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      FT.setFromMatrixPosition(this.light.matrixWorld),
      Zv.setFromMatrixPosition(this.light.target.matrixWorld),
      BT.subVectors(Zv, FT),
      this.lightPlane.lookAt(Zv),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Zv),
      (this.targetLine.scale.z = BT.length());
  }
}
const Jv = new se(),
  br = new eg();
class sG extends qa {
  constructor(e) {
    const t = new Jt(),
      r = new vo({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      o = [],
      s = {};
    l("n1", "n2"),
      l("n2", "n4"),
      l("n4", "n3"),
      l("n3", "n1"),
      l("f1", "f2"),
      l("f2", "f4"),
      l("f4", "f3"),
      l("f3", "f1"),
      l("n1", "f1"),
      l("n2", "f2"),
      l("n3", "f3"),
      l("n4", "f4"),
      l("p", "n1"),
      l("p", "n2"),
      l("p", "n3"),
      l("p", "n4"),
      l("u1", "u2"),
      l("u2", "u3"),
      l("u3", "u1"),
      l("c", "t"),
      l("p", "c"),
      l("cn1", "cn2"),
      l("cn3", "cn4"),
      l("cf1", "cf2"),
      l("cf3", "cf4");
    function l(x, S) {
      u(x), u(S);
    }
    function u(x) {
      i.push(0, 0, 0),
        o.push(0, 0, 0),
        s[x] === void 0 && (s[x] = []),
        s[x].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new kt(i, 3)),
      t.setAttribute("color", new kt(o, 3)),
      super(t, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = s),
      this.update();
    const f = new St(16755200),
      h = new St(16711680),
      m = new St(43775),
      g = new St(16777215),
      y = new St(3355443);
    this.setColors(f, h, m, g, y);
  }
  setColors(e, t, r, i, o) {
    const l = this.geometry.getAttribute("color");
    l.setXYZ(0, e.r, e.g, e.b),
      l.setXYZ(1, e.r, e.g, e.b),
      l.setXYZ(2, e.r, e.g, e.b),
      l.setXYZ(3, e.r, e.g, e.b),
      l.setXYZ(4, e.r, e.g, e.b),
      l.setXYZ(5, e.r, e.g, e.b),
      l.setXYZ(6, e.r, e.g, e.b),
      l.setXYZ(7, e.r, e.g, e.b),
      l.setXYZ(8, e.r, e.g, e.b),
      l.setXYZ(9, e.r, e.g, e.b),
      l.setXYZ(10, e.r, e.g, e.b),
      l.setXYZ(11, e.r, e.g, e.b),
      l.setXYZ(12, e.r, e.g, e.b),
      l.setXYZ(13, e.r, e.g, e.b),
      l.setXYZ(14, e.r, e.g, e.b),
      l.setXYZ(15, e.r, e.g, e.b),
      l.setXYZ(16, e.r, e.g, e.b),
      l.setXYZ(17, e.r, e.g, e.b),
      l.setXYZ(18, e.r, e.g, e.b),
      l.setXYZ(19, e.r, e.g, e.b),
      l.setXYZ(20, e.r, e.g, e.b),
      l.setXYZ(21, e.r, e.g, e.b),
      l.setXYZ(22, e.r, e.g, e.b),
      l.setXYZ(23, e.r, e.g, e.b),
      l.setXYZ(24, t.r, t.g, t.b),
      l.setXYZ(25, t.r, t.g, t.b),
      l.setXYZ(26, t.r, t.g, t.b),
      l.setXYZ(27, t.r, t.g, t.b),
      l.setXYZ(28, t.r, t.g, t.b),
      l.setXYZ(29, t.r, t.g, t.b),
      l.setXYZ(30, t.r, t.g, t.b),
      l.setXYZ(31, t.r, t.g, t.b),
      l.setXYZ(32, r.r, r.g, r.b),
      l.setXYZ(33, r.r, r.g, r.b),
      l.setXYZ(34, r.r, r.g, r.b),
      l.setXYZ(35, r.r, r.g, r.b),
      l.setXYZ(36, r.r, r.g, r.b),
      l.setXYZ(37, r.r, r.g, r.b),
      l.setXYZ(38, i.r, i.g, i.b),
      l.setXYZ(39, i.r, i.g, i.b),
      l.setXYZ(40, o.r, o.g, o.b),
      l.setXYZ(41, o.r, o.g, o.b),
      l.setXYZ(42, o.r, o.g, o.b),
      l.setXYZ(43, o.r, o.g, o.b),
      l.setXYZ(44, o.r, o.g, o.b),
      l.setXYZ(45, o.r, o.g, o.b),
      l.setXYZ(46, o.r, o.g, o.b),
      l.setXYZ(47, o.r, o.g, o.b),
      l.setXYZ(48, o.r, o.g, o.b),
      l.setXYZ(49, o.r, o.g, o.b),
      (l.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      r = 1,
      i = 1;
    br.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Nr("c", t, e, br, 0, 0, -1),
      Nr("t", t, e, br, 0, 0, 1),
      Nr("n1", t, e, br, -1, -1, -1),
      Nr("n2", t, e, br, r, -1, -1),
      Nr("n3", t, e, br, -1, i, -1),
      Nr("n4", t, e, br, r, i, -1),
      Nr("f1", t, e, br, -1, -1, 1),
      Nr("f2", t, e, br, r, -1, 1),
      Nr("f3", t, e, br, -1, i, 1),
      Nr("f4", t, e, br, r, i, 1),
      Nr("u1", t, e, br, r * 0.7, i * 1.1, -1),
      Nr("u2", t, e, br, -1 * 0.7, i * 1.1, -1),
      Nr("u3", t, e, br, 0, i * 2, -1),
      Nr("cf1", t, e, br, -1, 0, 1),
      Nr("cf2", t, e, br, r, 0, 1),
      Nr("cf3", t, e, br, 0, -1, 1),
      Nr("cf4", t, e, br, 0, i, 1),
      Nr("cn1", t, e, br, -1, 0, -1),
      Nr("cn2", t, e, br, r, 0, -1),
      Nr("cn3", t, e, br, 0, -1, -1),
      Nr("cn4", t, e, br, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Nr(n, e, t, r, i, o, s) {
  Jv.set(i, o, s).unproject(r);
  const l = e[n];
  if (l !== void 0) {
    const u = t.getAttribute("position");
    for (let f = 0, h = l.length; f < h; f++) u.setXYZ(l[f], Jv.x, Jv.y, Jv.z);
  }
}
const Qv = new to();
class aG extends qa {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      o = new Jt();
    o.setIndex(new Gn(r, 1)),
      o.setAttribute("position", new Gn(i, 3)),
      super(o, new vo({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Qv.setFromObject(this.object),
      Qv.isEmpty())
    )
      return;
    const t = Qv.min,
      r = Qv.max,
      i = this.geometry.attributes.position,
      o = i.array;
    (o[0] = r.x),
      (o[1] = r.y),
      (o[2] = r.z),
      (o[3] = t.x),
      (o[4] = r.y),
      (o[5] = r.z),
      (o[6] = t.x),
      (o[7] = t.y),
      (o[8] = r.z),
      (o[9] = r.x),
      (o[10] = t.y),
      (o[11] = r.z),
      (o[12] = r.x),
      (o[13] = r.y),
      (o[14] = t.z),
      (o[15] = t.x),
      (o[16] = r.y),
      (o[17] = t.z),
      (o[18] = t.x),
      (o[19] = t.y),
      (o[20] = t.z),
      (o[21] = r.x),
      (o[22] = t.y),
      (o[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class lG extends qa {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      o = new Jt();
    o.setIndex(new Gn(r, 1)),
      o.setAttribute("position", new kt(i, 3)),
      super(o, new vo({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class uG extends ju {
  constructor(e, t = 1, r = 16776960) {
    const i = r,
      o = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      s = new Jt();
    s.setAttribute("position", new kt(o, 3)),
      s.computeBoundingSphere(),
      super(s, new vo({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      u = new Jt();
    u.setAttribute("position", new kt(l, 3)),
      u.computeBoundingSphere(),
      this.add(
        new vr(
          u,
          new zl({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const zT = new se();
let e0, l1;
class cG extends _n {
  constructor(
    e = new se(0, 0, 1),
    t = new se(0, 0, 0),
    r = 1,
    i = 16776960,
    o = r * 0.2,
    s = o * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      e0 === void 0 &&
        ((e0 = new Jt()),
        e0.setAttribute("position", new kt([0, 0, 0, 0, 1, 0], 3)),
        (l1 = new Fh(0, 0.5, 1, 5, 1)),
        l1.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new ju(e0, new vo({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new vr(l1, new zl({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, o, s);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      zT.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(zT, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, t, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class fG extends qa {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new Jt();
    i.setAttribute("position", new kt(t, 3)),
      i.setAttribute("color", new kt(r, 3));
    const o = new vo({ vertexColors: !0, toneMapped: !1 });
    super(i, o), (this.type = "AxesHelper");
  }
  setColors(e, t, r) {
    const i = new St(),
      o = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(o, 0),
      i.toArray(o, 3),
      i.set(t),
      i.toArray(o, 6),
      i.toArray(o, 9),
      i.set(r),
      i.toArray(o, 12),
      i.toArray(o, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class dG {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new St()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Bm()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, s) {
    return this.currentPath.bezierCurveTo(e, t, r, i, o, s), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(w) {
      const T = [];
      for (let E = 0, A = w.length; E < A; E++) {
        const R = w[E],
          k = new mf();
        (k.curves = R.curves), T.push(k);
      }
      return T;
    }
    function r(w, T) {
      const E = T.length;
      let A = !1;
      for (let R = E - 1, k = 0; k < E; R = k++) {
        let P = T[R],
          U = T[k],
          N = U.x - P.x,
          L = U.y - P.y;
        if (Math.abs(L) > Number.EPSILON) {
          if (
            (L < 0 && ((P = T[k]), (N = -N), (U = T[R]), (L = -L)),
            w.y < P.y || w.y > U.y)
          )
            continue;
          if (w.y === P.y) {
            if (w.x === P.x) return !0;
          } else {
            const H = L * (w.x - P.x) - N * (w.y - P.y);
            if (H === 0) return !0;
            if (H < 0) continue;
            A = !A;
          }
        } else {
          if (w.y !== P.y) continue;
          if ((U.x <= w.x && w.x <= P.x) || (P.x <= w.x && w.x <= U.x))
            return !0;
        }
      }
      return A;
    }
    const i = ja.isClockWise,
      o = this.subPaths;
    if (o.length === 0) return [];
    let s, l, u;
    const f = [];
    if (o.length === 1)
      return (l = o[0]), (u = new mf()), (u.curves = l.curves), f.push(u), f;
    let h = !i(o[0].getPoints());
    h = e ? !h : h;
    const m = [],
      g = [];
    let y = [],
      x = 0,
      S;
    (g[x] = void 0), (y[x] = []);
    for (let w = 0, T = o.length; w < T; w++)
      (l = o[w]),
        (S = l.getPoints()),
        (s = i(S)),
        (s = e ? !s : s),
        s
          ? (!h && g[x] && x++,
            (g[x] = { s: new mf(), p: S }),
            (g[x].s.curves = l.curves),
            h && x++,
            (y[x] = []))
          : y[x].push({ h: l, p: S[0] });
    if (!g[0]) return t(o);
    if (g.length > 1) {
      let w = !1,
        T = 0;
      for (let E = 0, A = g.length; E < A; E++) m[E] = [];
      for (let E = 0, A = g.length; E < A; E++) {
        const R = y[E];
        for (let k = 0; k < R.length; k++) {
          const P = R[k];
          let U = !0;
          for (let N = 0; N < g.length; N++)
            r(P.p, g[N].p) &&
              (E !== N && T++, U ? ((U = !1), m[N].push(P)) : (w = !0));
          U && m[E].push(P);
        }
      }
      T > 0 && w === !1 && (y = m);
    }
    let _;
    for (let w = 0, T = g.length; w < T; w++) {
      (u = g[w].s), f.push(u), (_ = y[w]);
      for (let E = 0, A = _.length; E < A; E++) u.holes.push(_[E].h);
    }
    return f;
  }
}
class hG extends la {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
    ),
      super(e, t, { ...i, count: r }),
      (this.isWebGLMultipleRenderTargets = !0);
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Py } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Py));
const pG = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: tw,
      AddEquation: Ou,
      AddOperation: MA,
      AdditiveAnimationBlendMode: dw,
      AdditiveBlending: Y1,
      AgXToneMapping: RA,
      AlphaFormat: sw,
      AlwaysCompare: GA,
      AlwaysDepth: vA,
      AlwaysStencilFunc: J1,
      AmbientLight: GR,
      AnimationAction: KR,
      AnimationClip: jm,
      AnimationLoader: g8,
      AnimationMixer: W8,
      AnimationObjectGroup: V8,
      AnimationUtils: d8,
      ArcCurve: pR,
      ArrayCamera: iR,
      ArrowHelper: cG,
      AttachedBindMode: Z1,
      Audio: YR,
      AudioAnalyser: L8,
      AudioContext: Fw,
      AudioListener: R8,
      AudioLoader: T8,
      AxesHelper: fG,
      BackSide: Qi,
      BasicDepthPacking: NA,
      BasicShadowMap: Z2,
      BatchedMesh: fR,
      Bone: bw,
      BooleanKeyframeTrack: Af,
      Box2: K8,
      Box3: to,
      Box3Helper: lG,
      BoxGeometry: Cf,
      BoxHelper: aG,
      BufferAttribute: Gn,
      BufferGeometry: Jt,
      BufferGeometryLoader: XR,
      ByteType: rw,
      Cache: Rl,
      Camera: eg,
      CameraHelper: sG,
      CanvasTexture: OV,
      CapsuleGeometry: Zy,
      CatmullRomCurve3: mR,
      CineonToneMapping: CA,
      CircleGeometry: Jy,
      ClampToEdgeWrapping: As,
      Clock: Bw,
      Color: St,
      ColorKeyframeTrack: Dw,
      ColorManagement: yn,
      CompressedArrayTexture: DV,
      CompressedCubeTexture: NV,
      CompressedTexture: qy,
      CompressedTextureLoader: v8,
      ConeGeometry: Qy,
      ConstantAlphaFactor: pA,
      ConstantColorFactor: dA,
      CubeCamera: KA,
      CubeReflectionMapping: Dl,
      CubeRefractionMapping: Wu,
      CubeTexture: tg,
      CubeTextureLoader: y8,
      CubeUVReflectionMapping: Nh,
      CubicBezierCurve: Tw,
      CubicBezierCurve3: gR,
      CubicInterpolant: NR,
      CullFaceBack: X1,
      CullFaceFront: K2,
      CullFaceFrontBack: f4,
      CullFaceNone: q2,
      Curve: ca,
      CurvePath: yR,
      CustomBlending: J2,
      CustomToneMapping: AA,
      CylinderGeometry: Fh,
      Cylindrical: q8,
      Data3DTexture: gw,
      DataArrayTexture: Hy,
      DataTexture: Wa,
      DataTextureLoader: x8,
      DataUtils: MB,
      DecrementStencilOp: E4,
      DecrementWrapStencilOp: C4,
      DefaultLoadingManager: FR,
      DepthFormat: df,
      DepthStencilFormat: _f,
      DepthTexture: Sw,
      DetachedBindMode: IA,
      DirectionalLight: VR,
      DirectionalLightHelper: oG,
      DiscreteInterpolant: OR,
      DisplayP3ColorSpace: zy,
      DodecahedronGeometry: ex,
      DoubleSide: Ts,
      DstAlphaFactor: aA,
      DstColorFactor: uA,
      DynamicCopyUsage: V4,
      DynamicDrawUsage: O4,
      DynamicReadUsage: B4,
      EdgesGeometry: xR,
      EllipseCurve: Ky,
      EqualCompare: BA,
      EqualDepth: xA,
      EqualStencilFunc: I4,
      EquirectangularReflectionMapping: Cm,
      EquirectangularRefractionMapping: Am,
      Euler: as,
      EventDispatcher: Bl,
      ExtrudeGeometry: nx,
      FileLoader: Ol,
      Float16BufferAttribute: PB,
      Float32BufferAttribute: kt,
      FloatType: Oo,
      Fog: $y,
      FogExp2: jy,
      FramebufferTexture: kV,
      FrontSide: Xa,
      Frustum: ng,
      GLBufferAttribute: Y8,
      GLSL1: W4,
      GLSL3: Q1,
      GreaterCompare: zA,
      GreaterDepth: SA,
      GreaterEqualCompare: VA,
      GreaterEqualDepth: _A,
      GreaterEqualStencilFunc: N4,
      GreaterStencilFunc: k4,
      GridHelper: rG,
      Group: ch,
      HalfFloatType: Oh,
      HemisphereLight: BR,
      HemisphereLightHelper: nG,
      IcosahedronGeometry: rx,
      ImageBitmapLoader: E8,
      ImageLoader: $m,
      ImageUtils: $A,
      IncrementStencilOp: M4,
      IncrementWrapStencilOp: T4,
      InstancedBufferAttribute: wf,
      InstancedBufferGeometry: Uw,
      InstancedInterleavedBuffer: X8,
      InstancedMesh: cR,
      Int16BufferAttribute: AB,
      Int32BufferAttribute: RB,
      Int8BufferAttribute: EB,
      IntType: ky,
      InterleavedBuffer: Xy,
      InterleavedBufferAttribute: Sf,
      Interpolant: sg,
      InterpolateDiscrete: Im,
      InterpolateLinear: ry,
      InterpolateSmooth: f0,
      InvertStencilOp: A4,
      KeepStencilOp: Jc,
      KeyframeTrack: fa,
      LOD: lR,
      LatheGeometry: rg,
      Layers: pf,
      LessCompare: FA,
      LessDepth: yA,
      LessEqualCompare: pw,
      LessEqualDepth: Tm,
      LessEqualStencilFunc: L4,
      LessStencilFunc: P4,
      Light: qu,
      LightProbe: $R,
      Line: ju,
      Line3: Z8,
      LineBasicMaterial: vo,
      LineCurve: Cw,
      LineCurve3: vR,
      LineDashedMaterial: LR,
      LineLoop: dR,
      LineSegments: qa,
      LinearDisplayP3ColorSpace: Qm,
      LinearFilter: Cr,
      LinearInterpolant: kw,
      LinearMipMapLinearFilter: m4,
      LinearMipMapNearestFilter: p4,
      LinearMipmapLinearFilter: Ba,
      LinearMipmapNearestFilter: am,
      LinearSRGBColorSpace: Fl,
      LinearToneMapping: EA,
      LinearTransfer: km,
      Loader: Bo,
      LoaderUtils: aS,
      LoadingManager: Nw,
      LoopOnce: LA,
      LoopPingPong: DA,
      LoopRepeat: kA,
      LuminanceAlphaFormat: uw,
      LuminanceFormat: lw,
      MOUSE: Kc,
      Material: Oi,
      MaterialLoader: fx,
      MathUtils: aB,
      Matrix2: Gw,
      Matrix3: tn,
      Matrix4: Wt,
      MaxEquation: nA,
      Mesh: vr,
      MeshBasicMaterial: zl,
      MeshDepthMaterial: Gy,
      MeshDistanceMaterial: Wy,
      MeshLambertMaterial: PR,
      MeshMatcapMaterial: IR,
      MeshNormalMaterial: RR,
      MeshPhongMaterial: CR,
      MeshPhysicalMaterial: TR,
      MeshStandardMaterial: Iw,
      MeshToonMaterial: AR,
      MinEquation: tA,
      MirroredRepeatWrapping: Pm,
      MixOperation: bA,
      MultiplyBlending: K1,
      MultiplyOperation: Zm,
      NearestFilter: _i,
      NearestMipMapLinearFilter: h4,
      NearestMipMapNearestFilter: d4,
      NearestMipmapLinearFilter: ah,
      NearestMipmapNearestFilter: nw,
      NeutralToneMapping: PA,
      NeverCompare: UA,
      NeverDepth: gA,
      NeverStencilFunc: R4,
      NoBlending: Il,
      NoColorSpace: Cl,
      NoToneMapping: Ga,
      NormalAnimationBlendMode: By,
      NormalBlending: ff,
      NotEqualCompare: HA,
      NotEqualDepth: wA,
      NotEqualStencilFunc: D4,
      NumberKeyframeTrack: Gm,
      Object3D: _n,
      ObjectLoader: b8,
      ObjectSpaceNormalMap: OA,
      OctahedronGeometry: ig,
      OneFactor: iA,
      OneMinusConstantAlphaFactor: mA,
      OneMinusConstantColorFactor: hA,
      OneMinusDstAlphaFactor: lA,
      OneMinusDstColorFactor: cA,
      OneMinusSrcAlphaFactor: P0,
      OneMinusSrcColorFactor: sA,
      OrthographicCamera: zu,
      P3Primaries: Nm,
      PCFShadowMap: Iy,
      PCFSoftShadowMap: sm,
      PMREMGenerator: eS,
      Path: Bm,
      PerspectiveCamera: Or,
      Plane: El,
      PlaneGeometry: Hl,
      PlaneHelper: uG,
      PointLight: HR,
      PointLightHelper: eG,
      Points: hR,
      PointsMaterial: Mw,
      PolarGridHelper: iG,
      PolyhedronGeometry: Yu,
      PositionalAudio: I8,
      PropertyBinding: vn,
      PropertyMixer: qR,
      QuadraticBezierCurve: Aw,
      QuadraticBezierCurve3: Rw,
      Quaternion: eo,
      QuaternionKeyframeTrack: ag,
      QuaternionLinearInterpolant: UR,
      RED_GREEN_RGTC2_Format: ty,
      RED_RGTC1_Format: fw,
      REVISION: Py,
      RGBADepthPacking: hw,
      RGBAFormat: Ji,
      RGBAIntegerFormat: Fy,
      RGBA_ASTC_10x10_Format: q0,
      RGBA_ASTC_10x5_Format: $0,
      RGBA_ASTC_10x6_Format: X0,
      RGBA_ASTC_10x8_Format: Y0,
      RGBA_ASTC_12x10_Format: K0,
      RGBA_ASTC_12x12_Format: Z0,
      RGBA_ASTC_4x4_Format: F0,
      RGBA_ASTC_5x4_Format: B0,
      RGBA_ASTC_5x5_Format: z0,
      RGBA_ASTC_6x5_Format: H0,
      RGBA_ASTC_6x6_Format: V0,
      RGBA_ASTC_8x5_Format: G0,
      RGBA_ASTC_8x6_Format: W0,
      RGBA_ASTC_8x8_Format: j0,
      RGBA_BPTC_Format: dm,
      RGBA_ETC2_EAC_Format: U0,
      RGBA_PVRTC_2BPPV1_Format: D0,
      RGBA_PVRTC_4BPPV1_Format: k0,
      RGBA_S3TC_DXT1_Format: um,
      RGBA_S3TC_DXT3_Format: cm,
      RGBA_S3TC_DXT5_Format: fm,
      RGBDepthPacking: _4,
      RGBFormat: aw,
      RGBIntegerFormat: g4,
      RGB_BPTC_SIGNED_Format: J0,
      RGB_BPTC_UNSIGNED_Format: Q0,
      RGB_ETC1_Format: N0,
      RGB_ETC2_Format: O0,
      RGB_PVRTC_2BPPV1_Format: L0,
      RGB_PVRTC_4BPPV1_Format: I0,
      RGB_S3TC_DXT1_Format: lm,
      RGDepthPacking: S4,
      RGFormat: cw,
      RGIntegerFormat: Uy,
      RawShaderMaterial: ER,
      Ray: Tf,
      Raycaster: ZR,
      Rec709Primaries: Dm,
      RectAreaLight: WR,
      RedFormat: Oy,
      RedIntegerFormat: Jm,
      ReinhardToneMapping: TA,
      RenderTarget: XA,
      RepeatWrapping: Rm,
      ReplaceStencilOp: b4,
      ReverseSubtractEquation: eA,
      RingGeometry: ix,
      SIGNED_RED_GREEN_RGTC2_Format: ny,
      SIGNED_RED_RGTC1_Format: ey,
      SRGBColorSpace: Ms,
      SRGBTransfer: Zn,
      Scene: iy,
      ShaderChunk: on,
      ShaderLib: ia,
      ShaderMaterial: ua,
      ShadowMaterial: MR,
      Shape: mf,
      ShapeGeometry: ox,
      ShapePath: dG,
      ShapeUtils: ja,
      ShortType: iw,
      Skeleton: Yy,
      SkeletonHelper: Q8,
      SkinnedMesh: uR,
      Source: lf,
      Sphere: Ni,
      SphereGeometry: og,
      Spherical: uS,
      SphericalHarmonics3: jR,
      SplineCurve: Pw,
      SpotLight: zR,
      SpotLightHelper: J8,
      Sprite: aR,
      SpriteMaterial: ww,
      SrcAlphaFactor: R0,
      SrcAlphaSaturateFactor: fA,
      SrcColorFactor: oA,
      StaticCopyUsage: H4,
      StaticDrawUsage: Om,
      StaticReadUsage: F4,
      StereoCamera: C8,
      StreamCopyUsage: G4,
      StreamDrawUsage: U4,
      StreamReadUsage: z4,
      StringKeyframeTrack: Rf,
      SubtractEquation: Q2,
      SubtractiveBlending: q1,
      TOUCH: Zc,
      TangentSpaceNormalMap: Xu,
      TetrahedronGeometry: sx,
      Texture: Qn,
      TextureLoader: cx,
      TextureUtils: dV,
      TorusGeometry: ax,
      TorusKnotGeometry: lx,
      Triangle: rs,
      TriangleFanDrawMode: x4,
      TriangleStripDrawMode: y4,
      TrianglesDrawMode: v4,
      TubeGeometry: ux,
      UVMapping: Ly,
      Uint16BufferAttribute: vw,
      Uint32BufferAttribute: yw,
      Uint8BufferAttribute: TB,
      Uint8ClampedBufferAttribute: CB,
      Uniform: Vw,
      UniformsGroup: $8,
      UniformsLib: xt,
      UniformsUtils: xw,
      UnsignedByteType: aa,
      UnsignedInt248Type: xf,
      UnsignedInt5999Type: ow,
      UnsignedIntType: Nl,
      UnsignedShort4444Type: Dy,
      UnsignedShort5551Type: Ny,
      UnsignedShortType: Mh,
      VSMShadowMap: ra,
      Vector2: tt,
      Vector3: se,
      Vector4: Tn,
      VectorKeyframeTrack: Wm,
      VideoTexture: LV,
      WebGL3DRenderTarget: pB,
      WebGLArrayRenderTarget: hB,
      WebGLCoordinateSystem: za,
      WebGLCubeRenderTarget: ZA,
      WebGLMultipleRenderTargets: hG,
      WebGLRenderTarget: la,
      WebGLRenderer: oR,
      WebGLUtils: rR,
      WebGPUCoordinateSystem: Um,
      WireframeGeometry: bR,
      WrapAroundEnding: Lm,
      ZeroCurvatureEnding: sf,
      ZeroFactor: rA,
      ZeroSlopeEnding: af,
      ZeroStencilOp: w4,
      createCanvasElement: jA,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var u1 = { exports: {} },
  Du = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var HT;
function mG() {
  return (
    HT ||
      ((HT = 1),
      (Du.ConcurrentRoot = 1),
      (Du.ContinuousEventPriority = 4),
      (Du.DefaultEventPriority = 16),
      (Du.DiscreteEventPriority = 1),
      (Du.IdleEventPriority = 536870912),
      (Du.LegacyRoot = 0)),
    Du
  );
}
var VT;
function gG() {
  return VT || ((VT = 1), (u1.exports = mG())), u1.exports;
}
var dh = gG();
function vG(n) {
  let e;
  const t = new Set(),
    r = (f, h) => {
      const m = typeof f == "function" ? f(e) : f;
      if (m !== e) {
        const g = e;
        (e = h ? m : Object.assign({}, e, m)), t.forEach((y) => y(e, g));
      }
    },
    i = () => e,
    o = (f, h = i, m = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let g = h(e);
      function y() {
        const x = h(e);
        if (!m(g, x)) {
          const S = g;
          f((g = x), S);
        }
      }
      return t.add(y), () => t.delete(y);
    },
    u = {
      setState: r,
      getState: i,
      subscribe: (f, h, m) =>
        h || m ? o(f, h, m) : (t.add(f), () => t.delete(f)),
      destroy: () => t.clear(),
    };
  return (e = n(r, i, u)), u;
}
const yG =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  GT = yG ? K.useEffect : K.useLayoutEffect;
function xG(n) {
  const e = typeof n == "function" ? vG(n) : n,
    t = (r = e.getState, i = Object.is) => {
      const [, o] = K.useReducer((_) => _ + 1, 0),
        s = e.getState(),
        l = K.useRef(s),
        u = K.useRef(r),
        f = K.useRef(i),
        h = K.useRef(!1),
        m = K.useRef();
      m.current === void 0 && (m.current = r(s));
      let g,
        y = !1;
      (l.current !== s || u.current !== r || f.current !== i || h.current) &&
        ((g = r(s)), (y = !i(m.current, g))),
        GT(() => {
          y && (m.current = g),
            (l.current = s),
            (u.current = r),
            (f.current = i),
            (h.current = !1);
        });
      const x = K.useRef(s);
      GT(() => {
        const _ = () => {
            try {
              const T = e.getState(),
                E = u.current(T);
              f.current(m.current, E) ||
                ((l.current = T), (m.current = E), o());
            } catch {
              (h.current = !0), o();
            }
          },
          w = e.subscribe(_);
        return e.getState() !== x.current && _(), w;
      }, []);
      const S = y ? g : m.current;
      return K.useDebugValue(S), S;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [t, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    t
  );
}
var c1 = { exports: {} },
  f1 = { exports: {} },
  d1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var WT;
function _G() {
  return (
    WT ||
      ((WT = 1),
      (function (n) {
        function e(W, te) {
          var F = W.length;
          W.push(te);
          e: for (; 0 < F; ) {
            var V = (F - 1) >>> 1,
              ne = W[V];
            if (0 < i(ne, te)) (W[V] = te), (W[F] = ne), (F = V);
            else break e;
          }
        }
        function t(W) {
          return W.length === 0 ? null : W[0];
        }
        function r(W) {
          if (W.length === 0) return null;
          var te = W[0],
            F = W.pop();
          if (F !== te) {
            W[0] = F;
            e: for (var V = 0, ne = W.length, ae = ne >>> 1; V < ae; ) {
              var J = 2 * (V + 1) - 1,
                oe = W[J],
                de = J + 1,
                le = W[de];
              if (0 > i(oe, F))
                de < ne && 0 > i(le, oe)
                  ? ((W[V] = le), (W[de] = F), (V = de))
                  : ((W[V] = oe), (W[J] = F), (V = J));
              else if (de < ne && 0 > i(le, F))
                (W[V] = le), (W[de] = F), (V = de);
              else break e;
            }
          }
          return te;
        }
        function i(W, te) {
          var F = W.sortIndex - te.sortIndex;
          return F !== 0 ? F : W.id - te.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var s = Date,
            l = s.now();
          n.unstable_now = function () {
            return s.now() - l;
          };
        }
        var u = [],
          f = [],
          h = 1,
          m = null,
          g = 3,
          y = !1,
          x = !1,
          S = !1,
          _ = typeof setTimeout == "function" ? setTimeout : null,
          w = typeof clearTimeout == "function" ? clearTimeout : null,
          T = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function E(W) {
          for (var te = t(f); te !== null; ) {
            if (te.callback === null) r(f);
            else if (te.startTime <= W)
              r(f), (te.sortIndex = te.expirationTime), e(u, te);
            else break;
            te = t(f);
          }
        }
        function A(W) {
          if (((S = !1), E(W), !x))
            if (t(u) !== null) (x = !0), X(R);
            else {
              var te = t(f);
              te !== null && re(A, te.startTime - W);
            }
        }
        function R(W, te) {
          (x = !1), S && ((S = !1), w(U), (U = -1)), (y = !0);
          var F = g;
          try {
            for (
              E(te), m = t(u);
              m !== null && (!(m.expirationTime > te) || (W && !H()));

            ) {
              var V = m.callback;
              if (typeof V == "function") {
                (m.callback = null), (g = m.priorityLevel);
                var ne = V(m.expirationTime <= te);
                (te = n.unstable_now()),
                  typeof ne == "function"
                    ? (m.callback = ne)
                    : m === t(u) && r(u),
                  E(te);
              } else r(u);
              m = t(u);
            }
            if (m !== null) var ae = !0;
            else {
              var J = t(f);
              J !== null && re(A, J.startTime - te), (ae = !1);
            }
            return ae;
          } finally {
            (m = null), (g = F), (y = !1);
          }
        }
        var k = !1,
          P = null,
          U = -1,
          N = 5,
          L = -1;
        function H() {
          return !(n.unstable_now() - L < N);
        }
        function G() {
          if (P !== null) {
            var W = n.unstable_now();
            L = W;
            var te = !0;
            try {
              te = P(!0, W);
            } finally {
              te ? $() : ((k = !1), (P = null));
            }
          } else k = !1;
        }
        var $;
        if (typeof T == "function")
          $ = function () {
            T(G);
          };
        else if (typeof MessageChannel < "u") {
          var q = new MessageChannel(),
            Z = q.port2;
          (q.port1.onmessage = G),
            ($ = function () {
              Z.postMessage(null);
            });
        } else
          $ = function () {
            _(G, 0);
          };
        function X(W) {
          (P = W), k || ((k = !0), $());
        }
        function re(W, te) {
          U = _(function () {
            W(n.unstable_now());
          }, te);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (W) {
            W.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            x || y || ((x = !0), X(R));
          }),
          (n.unstable_forceFrameRate = function (W) {
            0 > W || 125 < W
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (N = 0 < W ? Math.floor(1e3 / W) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(u);
          }),
          (n.unstable_next = function (W) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var te = 3;
                break;
              default:
                te = g;
            }
            var F = g;
            g = te;
            try {
              return W();
            } finally {
              g = F;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (W, te) {
            switch (W) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                W = 3;
            }
            var F = g;
            g = W;
            try {
              return te();
            } finally {
              g = F;
            }
          }),
          (n.unstable_scheduleCallback = function (W, te, F) {
            var V = n.unstable_now();
            switch (
              (typeof F == "object" && F !== null
                ? ((F = F.delay),
                  (F = typeof F == "number" && 0 < F ? V + F : V))
                : (F = V),
              W)
            ) {
              case 1:
                var ne = -1;
                break;
              case 2:
                ne = 250;
                break;
              case 5:
                ne = 1073741823;
                break;
              case 4:
                ne = 1e4;
                break;
              default:
                ne = 5e3;
            }
            return (
              (ne = F + ne),
              (W = {
                id: h++,
                callback: te,
                priorityLevel: W,
                startTime: F,
                expirationTime: ne,
                sortIndex: -1,
              }),
              F > V
                ? ((W.sortIndex = F),
                  e(f, W),
                  t(u) === null &&
                    W === t(f) &&
                    (S ? (w(U), (U = -1)) : (S = !0), re(A, F - V)))
                : ((W.sortIndex = ne), e(u, W), x || y || ((x = !0), X(R))),
              W
            );
          }),
          (n.unstable_shouldYield = H),
          (n.unstable_wrapCallback = function (W) {
            var te = g;
            return function () {
              var F = g;
              g = te;
              try {
                return W.apply(this, arguments);
              } finally {
                g = F;
              }
            };
          });
      })(d1)),
    d1
  );
}
var jT;
function QR() {
  return jT || ((jT = 1), (f1.exports = _G())), f1.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var h1, $T;
function SG() {
  return (
    $T ||
      (($T = 1),
      (h1 = function (e) {
        var t = {},
          r = Rh(),
          i = QR(),
          o = Object.assign;
        function s(d) {
          for (
            var p =
                "https://reactjs.org/docs/error-decoder.html?invariant=" + d,
              b = 1;
            b < arguments.length;
            b++
          )
            p += "&args[]=" + encodeURIComponent(arguments[b]);
          return (
            "Minified React error #" +
            d +
            "; visit " +
            p +
            " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
          );
        }
        var l = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          u = Symbol.for("react.element"),
          f = Symbol.for("react.portal"),
          h = Symbol.for("react.fragment"),
          m = Symbol.for("react.strict_mode"),
          g = Symbol.for("react.profiler"),
          y = Symbol.for("react.provider"),
          x = Symbol.for("react.context"),
          S = Symbol.for("react.forward_ref"),
          _ = Symbol.for("react.suspense"),
          w = Symbol.for("react.suspense_list"),
          T = Symbol.for("react.memo"),
          E = Symbol.for("react.lazy"),
          A = Symbol.for("react.offscreen"),
          R = Symbol.iterator;
        function k(d) {
          return d === null || typeof d != "object"
            ? null
            : ((d = (R && d[R]) || d["@@iterator"]),
              typeof d == "function" ? d : null);
        }
        function P(d) {
          if (d == null) return null;
          if (typeof d == "function") return d.displayName || d.name || null;
          if (typeof d == "string") return d;
          switch (d) {
            case h:
              return "Fragment";
            case f:
              return "Portal";
            case g:
              return "Profiler";
            case m:
              return "StrictMode";
            case _:
              return "Suspense";
            case w:
              return "SuspenseList";
          }
          if (typeof d == "object")
            switch (d.$$typeof) {
              case x:
                return (d.displayName || "Context") + ".Consumer";
              case y:
                return (d._context.displayName || "Context") + ".Provider";
              case S:
                var p = d.render;
                return (
                  (d = d.displayName),
                  d ||
                    ((d = p.displayName || p.name || ""),
                    (d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")),
                  d
                );
              case T:
                return (
                  (p = d.displayName || null),
                  p !== null ? p : P(d.type) || "Memo"
                );
              case E:
                (p = d._payload), (d = d._init);
                try {
                  return P(d(p));
                } catch {}
            }
          return null;
        }
        function U(d) {
          var p = d.type;
          switch (d.tag) {
            case 24:
              return "Cache";
            case 9:
              return (p.displayName || "Context") + ".Consumer";
            case 10:
              return (p._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return (
                (d = p.render),
                (d = d.displayName || d.name || ""),
                p.displayName ||
                  (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")
              );
            case 7:
              return "Fragment";
            case 5:
              return p;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return P(p);
            case 8:
              return p === m ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if (typeof p == "function")
                return p.displayName || p.name || null;
              if (typeof p == "string") return p;
          }
          return null;
        }
        function N(d) {
          var p = d,
            b = d;
          if (d.alternate) for (; p.return; ) p = p.return;
          else {
            d = p;
            do
              (p = d), (p.flags & 4098) !== 0 && (b = p.return), (d = p.return);
            while (d);
          }
          return p.tag === 3 ? b : null;
        }
        function L(d) {
          if (N(d) !== d) throw Error(s(188));
        }
        function H(d) {
          var p = d.alternate;
          if (!p) {
            if (((p = N(d)), p === null)) throw Error(s(188));
            return p !== d ? null : d;
          }
          for (var b = d, C = p; ; ) {
            var D = b.return;
            if (D === null) break;
            var z = D.alternate;
            if (z === null) {
              if (((C = D.return), C !== null)) {
                b = C;
                continue;
              }
              break;
            }
            if (D.child === z.child) {
              for (z = D.child; z; ) {
                if (z === b) return L(D), d;
                if (z === C) return L(D), p;
                z = z.sibling;
              }
              throw Error(s(188));
            }
            if (b.return !== C.return) (b = D), (C = z);
            else {
              for (var ce = !1, Me = D.child; Me; ) {
                if (Me === b) {
                  (ce = !0), (b = D), (C = z);
                  break;
                }
                if (Me === C) {
                  (ce = !0), (C = D), (b = z);
                  break;
                }
                Me = Me.sibling;
              }
              if (!ce) {
                for (Me = z.child; Me; ) {
                  if (Me === b) {
                    (ce = !0), (b = z), (C = D);
                    break;
                  }
                  if (Me === C) {
                    (ce = !0), (C = z), (b = D);
                    break;
                  }
                  Me = Me.sibling;
                }
                if (!ce) throw Error(s(189));
              }
            }
            if (b.alternate !== C) throw Error(s(190));
          }
          if (b.tag !== 3) throw Error(s(188));
          return b.stateNode.current === b ? d : p;
        }
        function G(d) {
          return (d = H(d)), d !== null ? $(d) : null;
        }
        function $(d) {
          if (d.tag === 5 || d.tag === 6) return d;
          for (d = d.child; d !== null; ) {
            var p = $(d);
            if (p !== null) return p;
            d = d.sibling;
          }
          return null;
        }
        function q(d) {
          if (d.tag === 5 || d.tag === 6) return d;
          for (d = d.child; d !== null; ) {
            if (d.tag !== 4) {
              var p = q(d);
              if (p !== null) return p;
            }
            d = d.sibling;
          }
          return null;
        }
        var Z = Array.isArray,
          X = e.getPublicInstance,
          re = e.getRootHostContext,
          W = e.getChildHostContext,
          te = e.prepareForCommit,
          F = e.resetAfterCommit,
          V = e.createInstance,
          ne = e.appendInitialChild,
          ae = e.finalizeInitialChildren,
          J = e.prepareUpdate,
          oe = e.shouldSetTextContent,
          de = e.createTextInstance,
          le = e.scheduleTimeout,
          fe = e.cancelTimeout,
          Ee = e.noTimeout,
          ge = e.isPrimaryRenderer,
          xe = e.supportsMutation,
          j = e.supportsPersistence,
          we = e.supportsHydration,
          Ae = e.getInstanceFromNode,
          Ne = e.preparePortalMount,
          Ie = e.getCurrentEventPriority,
          rt = e.detachDeletedInstance,
          ke = e.supportsMicrotasks,
          Xe = e.scheduleMicrotask,
          ee = e.supportsTestSelectors,
          B = e.findFiberRoot,
          ve = e.getBoundingRect,
          Se = e.getTextContent,
          _e = e.isHiddenSubtree,
          Te = e.matchAccessibilityRole,
          at = e.setFocusIfFocusable,
          Fe = e.setupIntersectionObserver,
          Be = e.appendChild,
          We = e.appendChildToContainer,
          Ye = e.commitTextUpdate,
          nt = e.commitMount,
          yt = e.commitUpdate,
          $e = e.insertBefore,
          qe = e.insertInContainerBefore,
          et = e.removeChild,
          he = e.removeChildFromContainer,
          Je = e.resetTextContent,
          me = e.hideInstance,
          Ve = e.hideTextInstance,
          Re = e.unhideInstance,
          Ue = e.unhideTextInstance,
          it = e.clearContainer,
          mt = e.cloneInstance,
          gt = e.createContainerChildSet,
          Ot = e.appendChildToContainerChildSet,
          Ut = e.finalizeContainerChildren,
          ht = e.replaceContainerChildren,
          $t = e.cloneHiddenInstance,
          un = e.cloneHiddenTextInstance,
          Sn = e.canHydrateInstance,
          mn = e.canHydrateTextInstance,
          lr = e.canHydrateSuspenseInstance,
          Ui = e.isSuspenseInstancePending,
          yr = e.isSuspenseInstanceFallback,
          Fr = e.registerSuspenseInstanceRetry,
          Ar = e.getNextHydratableSibling,
          Br = e.getFirstHydratableChild,
          xr = e.getFirstHydratableChildWithinContainer,
          yo = e.getFirstHydratableChildWithinSuspenseInstance,
          Vl = e.hydrateInstance,
          no = e.hydrateTextInstance,
          Gl = e.hydrateSuspenseInstance,
          ie = e.getNextHydratableInstanceAfterSuspenseInstance,
          Ce = e.commitHydratedContainer,
          ze = e.commitHydratedSuspenseInstance,
          Ge = e.clearSuspenseBoundary,
          Le = e.clearSuspenseBoundaryFromContainer,
          ut = e.shouldDeleteUnhydratedTailInstances,
          vt = e.didNotMatchHydratedContainerTextInstance,
          Et = e.didNotMatchHydratedTextInstance,
          Ke;
        function Dt(d) {
          if (Ke === void 0)
            try {
              throw Error();
            } catch (b) {
              var p = b.stack.trim().match(/\n( *(at )?)/);
              Ke = (p && p[1]) || "";
            }
          return (
            `
` +
            Ke +
            d
          );
        }
        var Ft = !1;
        function At(d, p) {
          if (!d || Ft) return "";
          Ft = !0;
          var b = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (p)
              if (
                ((p = function () {
                  throw Error();
                }),
                Object.defineProperty(p.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(p, []);
                } catch (ct) {
                  var C = ct;
                }
                Reflect.construct(d, [], p);
              } else {
                try {
                  p.call();
                } catch (ct) {
                  C = ct;
                }
                d.call(p.prototype);
              }
            else {
              try {
                throw Error();
              } catch (ct) {
                C = ct;
              }
              d();
            }
          } catch (ct) {
            if (ct && C && typeof ct.stack == "string") {
              for (
                var D = ct.stack.split(`
`),
                  z = C.stack.split(`
`),
                  ce = D.length - 1,
                  Me = z.length - 1;
                1 <= ce && 0 <= Me && D[ce] !== z[Me];

              )
                Me--;
              for (; 1 <= ce && 0 <= Me; ce--, Me--)
                if (D[ce] !== z[Me]) {
                  if (ce !== 1 || Me !== 1)
                    do
                      if ((ce--, Me--, 0 > Me || D[ce] !== z[Me])) {
                        var Qe =
                          `
` + D[ce].replace(" at new ", " at ");
                        return (
                          d.displayName &&
                            Qe.includes("<anonymous>") &&
                            (Qe = Qe.replace("<anonymous>", d.displayName)),
                          Qe
                        );
                      }
                    while (1 <= ce && 0 <= Me);
                  break;
                }
            }
          } finally {
            (Ft = !1), (Error.prepareStackTrace = b);
          }
          return (d = d ? d.displayName || d.name : "") ? Dt(d) : "";
        }
        var nn = Object.prototype.hasOwnProperty,
          Cn = [],
          dn = -1;
        function wn(d) {
          return { current: d };
        }
        function wt(d) {
          0 > dn || ((d.current = Cn[dn]), (Cn[dn] = null), dn--);
        }
        function dt(d, p) {
          dn++, (Cn[dn] = d.current), (d.current = p);
        }
        var Qt = {},
          zt = wn(Qt),
          bn = wn(!1),
          ii = Qt;
        function An(d, p) {
          var b = d.type.contextTypes;
          if (!b) return Qt;
          var C = d.stateNode;
          if (C && C.__reactInternalMemoizedUnmaskedChildContext === p)
            return C.__reactInternalMemoizedMaskedChildContext;
          var D = {},
            z;
          for (z in b) D[z] = p[z];
          return (
            C &&
              ((d = d.stateNode),
              (d.__reactInternalMemoizedUnmaskedChildContext = p),
              (d.__reactInternalMemoizedMaskedChildContext = D)),
            D
          );
        }
        function Wn(d) {
          return (d = d.childContextTypes), d != null;
        }
        function cn() {
          wt(bn), wt(zt);
        }
        function zr(d, p, b) {
          if (zt.current !== Qt) throw Error(s(168));
          dt(zt, p), dt(bn, b);
        }
        function ls(d, p, b) {
          var C = d.stateNode;
          if (
            ((p = p.childContextTypes), typeof C.getChildContext != "function")
          )
            return b;
          C = C.getChildContext();
          for (var D in C)
            if (!(D in p)) throw Error(s(108, U(d) || "Unknown", D));
          return o({}, b, C);
        }
        function ur(d) {
          return (
            (d =
              ((d = d.stateNode) &&
                d.__reactInternalMemoizedMergedChildContext) ||
              Qt),
            (ii = zt.current),
            dt(zt, d),
            dt(bn, bn.current),
            !0
          );
        }
        function Rr(d, p, b) {
          var C = d.stateNode;
          if (!C) throw Error(s(169));
          b
            ? ((d = ls(d, p, ii)),
              (C.__reactInternalMemoizedMergedChildContext = d),
              wt(bn),
              wt(zt),
              dt(zt, d))
            : wt(bn),
            dt(bn, b);
        }
        var di = Math.clz32 ? Math.clz32 : Pf,
          zo = Math.log,
          Ho = Math.LN2;
        function Pf(d) {
          return (d >>>= 0), d === 0 ? 32 : (31 - ((zo(d) / Ho) | 0)) | 0;
        }
        var Vo = 64,
          ln = 4194304;
        function us(d) {
          switch (d & -d) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return d & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return d & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return d;
          }
        }
        function da(d, p) {
          var b = d.pendingLanes;
          if (b === 0) return 0;
          var C = 0,
            D = d.suspendedLanes,
            z = d.pingedLanes,
            ce = b & 268435455;
          if (ce !== 0) {
            var Me = ce & ~D;
            Me !== 0 ? (C = us(Me)) : ((z &= ce), z !== 0 && (C = us(z)));
          } else
            (ce = b & ~D), ce !== 0 ? (C = us(ce)) : z !== 0 && (C = us(z));
          if (C === 0) return 0;
          if (
            p !== 0 &&
            p !== C &&
            (p & D) === 0 &&
            ((D = C & -C),
            (z = p & -p),
            D >= z || (D === 16 && (z & 4194240) !== 0))
          )
            return p;
          if (((C & 4) !== 0 && (C |= b & 16), (p = d.entangledLanes), p !== 0))
            for (d = d.entanglements, p &= C; 0 < p; )
              (b = 31 - di(p)), (D = 1 << b), (C |= d[b]), (p &= ~D);
          return C;
        }
        function Wl(d, p) {
          switch (d) {
            case 1:
            case 2:
            case 4:
              return p + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return p + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function jl(d, p) {
          for (
            var b = d.suspendedLanes,
              C = d.pingedLanes,
              D = d.expirationTimes,
              z = d.pendingLanes;
            0 < z;

          ) {
            var ce = 31 - di(z),
              Me = 1 << ce,
              Qe = D[ce];
            Qe === -1
              ? ((Me & b) === 0 || (Me & C) !== 0) && (D[ce] = Wl(Me, p))
              : Qe <= p && (d.expiredLanes |= Me),
              (z &= ~Me);
          }
        }
        function cs(d) {
          return (
            (d = d.pendingLanes & -1073741825),
            d !== 0 ? d : d & 1073741824 ? 1073741824 : 0
          );
        }
        function Ka(d) {
          for (var p = [], b = 0; 31 > b; b++) p.push(d);
          return p;
        }
        function xo(d, p, b) {
          (d.pendingLanes |= p),
            p !== 536870912 && ((d.suspendedLanes = 0), (d.pingedLanes = 0)),
            (d = d.eventTimes),
            (p = 31 - di(p)),
            (d[p] = b);
        }
        function Go(d, p) {
          var b = d.pendingLanes & ~p;
          (d.pendingLanes = p),
            (d.suspendedLanes = 0),
            (d.pingedLanes = 0),
            (d.expiredLanes &= p),
            (d.mutableReadLanes &= p),
            (d.entangledLanes &= p),
            (p = d.entanglements);
          var C = d.eventTimes;
          for (d = d.expirationTimes; 0 < b; ) {
            var D = 31 - di(b),
              z = 1 << D;
            (p[D] = 0), (C[D] = -1), (d[D] = -1), (b &= ~z);
          }
        }
        function oi(d, p) {
          var b = (d.entangledLanes |= p);
          for (d = d.entanglements; b; ) {
            var C = 31 - di(b),
              D = 1 << C;
            (D & p) | (d[C] & p) && (d[C] |= p), (b &= ~D);
          }
        }
        var Xt = 0;
        function _o(d) {
          return (
            (d &= -d),
            1 < d ? (4 < d ? ((d & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
          );
        }
        var ro = i.unstable_scheduleCallback,
          fs = i.unstable_cancelCallback,
          So = i.unstable_shouldYield,
          If = i.unstable_requestPaint,
          Yn = i.unstable_now,
          Wo = i.unstable_ImmediatePriority,
          Lf = i.unstable_UserBlockingPriority,
          hi = i.unstable_NormalPriority,
          ha = i.unstable_IdlePriority,
          pa = null,
          io = null;
        function Is(d) {
          if (io && typeof io.onCommitFiberRoot == "function")
            try {
              io.onCommitFiberRoot(
                pa,
                d,
                void 0,
                (d.current.flags & 128) === 128
              );
            } catch {}
        }
        function ma(d, p) {
          return (
            (d === p && (d !== 0 || 1 / d === 1 / p)) || (d !== d && p !== p)
          );
        }
        var Hr = typeof Object.is == "function" ? Object.is : ma,
          Vr = null,
          ds = !1,
          wo = !1;
        function Za(d) {
          Vr === null ? (Vr = [d]) : Vr.push(d);
        }
        function ga(d) {
          (ds = !0), Za(d);
        }
        function pi() {
          if (!wo && Vr !== null) {
            wo = !0;
            var d = 0,
              p = Xt;
            try {
              var b = Vr;
              for (Xt = 1; d < b.length; d++) {
                var C = b[d];
                do C = C(!0);
                while (C !== null);
              }
              (Vr = null), (ds = !1);
            } catch (D) {
              throw (Vr !== null && (Vr = Vr.slice(d + 1)), ro(Wo, pi), D);
            } finally {
              (Xt = p), (wo = !1);
            }
          }
          return null;
        }
        var va = l.ReactCurrentBatchConfig;
        function Fi(d, p) {
          if (Hr(d, p)) return !0;
          if (
            typeof d != "object" ||
            d === null ||
            typeof p != "object" ||
            p === null
          )
            return !1;
          var b = Object.keys(d),
            C = Object.keys(p);
          if (b.length !== C.length) return !1;
          for (C = 0; C < b.length; C++) {
            var D = b[C];
            if (!nn.call(p, D) || !Hr(d[D], p[D])) return !1;
          }
          return !0;
        }
        function Ls(d) {
          switch (d.tag) {
            case 5:
              return Dt(d.type);
            case 16:
              return Dt("Lazy");
            case 13:
              return Dt("Suspense");
            case 19:
              return Dt("SuspenseList");
            case 0:
            case 2:
            case 15:
              return (d = At(d.type, !1)), d;
            case 11:
              return (d = At(d.type.render, !1)), d;
            case 1:
              return (d = At(d.type, !0)), d;
            default:
              return "";
          }
        }
        function Gr(d, p) {
          if (d && d.defaultProps) {
            (p = o({}, p)), (d = d.defaultProps);
            for (var b in d) p[b] === void 0 && (p[b] = d[b]);
            return p;
          }
          return p;
        }
        var Pr = wn(null),
          ks = null,
          Bi = null,
          Ds = null;
        function Wr() {
          Ds = Bi = ks = null;
        }
        function Ns(d, p, b) {
          ge
            ? (dt(Pr, p._currentValue), (p._currentValue = b))
            : (dt(Pr, p._currentValue2), (p._currentValue2 = b));
        }
        function _r(d) {
          var p = Pr.current;
          wt(Pr), ge ? (d._currentValue = p) : (d._currentValue2 = p);
        }
        function Ir(d, p, b) {
          for (; d !== null; ) {
            var C = d.alternate;
            if (
              ((d.childLanes & p) !== p
                ? ((d.childLanes |= p), C !== null && (C.childLanes |= p))
                : C !== null && (C.childLanes & p) !== p && (C.childLanes |= p),
              d === b)
            )
              break;
            d = d.return;
          }
        }
        function cr(d, p) {
          (ks = d),
            (Ds = Bi = null),
            (d = d.dependencies),
            d !== null &&
              d.firstContext !== null &&
              ((d.lanes & p) !== 0 && (Yr = !0), (d.firstContext = null));
        }
        function er(d) {
          var p = ge ? d._currentValue : d._currentValue2;
          if (Ds !== d)
            if (
              ((d = { context: d, memoizedValue: p, next: null }), Bi === null)
            ) {
              if (ks === null) throw Error(s(308));
              (Bi = d), (ks.dependencies = { lanes: 0, firstContext: d });
            } else Bi = Bi.next = d;
          return p;
        }
        var Si = null,
          bo = !1;
        function $l(d) {
          d.updateQueue = {
            baseState: d.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function zh(d, p) {
          (d = d.updateQueue),
            p.updateQueue === d &&
              (p.updateQueue = {
                baseState: d.baseState,
                firstBaseUpdate: d.firstBaseUpdate,
                lastBaseUpdate: d.lastBaseUpdate,
                shared: d.shared,
                effects: d.effects,
              });
        }
        function Os(d, p) {
          return {
            eventTime: d,
            lane: p,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function ya(d, p) {
          var b = d.updateQueue;
          b !== null &&
            ((b = b.shared),
            rr !== null && (d.mode & 1) !== 0 && (rn & 2) === 0
              ? ((d = b.interleaved),
                d === null
                  ? ((p.next = p), Si === null ? (Si = [b]) : Si.push(b))
                  : ((p.next = d.next), (d.next = p)),
                (b.interleaved = p))
              : ((d = b.pending),
                d === null ? (p.next = p) : ((p.next = d.next), (d.next = p)),
                (b.pending = p)));
        }
        function kf(d, p, b) {
          if (
            ((p = p.updateQueue),
            p !== null && ((p = p.shared), (b & 4194240) !== 0))
          ) {
            var C = p.lanes;
            (C &= d.pendingLanes), (b |= C), (p.lanes = b), oi(d, b);
          }
        }
        function Df(d, p) {
          var b = d.updateQueue,
            C = d.alternate;
          if (C !== null && ((C = C.updateQueue), b === C)) {
            var D = null,
              z = null;
            if (((b = b.firstBaseUpdate), b !== null)) {
              do {
                var ce = {
                  eventTime: b.eventTime,
                  lane: b.lane,
                  tag: b.tag,
                  payload: b.payload,
                  callback: b.callback,
                  next: null,
                };
                z === null ? (D = z = ce) : (z = z.next = ce), (b = b.next);
              } while (b !== null);
              z === null ? (D = z = p) : (z = z.next = p);
            } else D = z = p;
            (b = {
              baseState: C.baseState,
              firstBaseUpdate: D,
              lastBaseUpdate: z,
              shared: C.shared,
              effects: C.effects,
            }),
              (d.updateQueue = b);
            return;
          }
          (d = b.lastBaseUpdate),
            d === null ? (b.firstBaseUpdate = p) : (d.next = p),
            (b.lastBaseUpdate = p);
        }
        function Nf(d, p, b, C) {
          var D = d.updateQueue;
          bo = !1;
          var z = D.firstBaseUpdate,
            ce = D.lastBaseUpdate,
            Me = D.shared.pending;
          if (Me !== null) {
            D.shared.pending = null;
            var Qe = Me,
              ct = Qe.next;
            (Qe.next = null),
              ce === null ? (z = ct) : (ce.next = ct),
              (ce = Qe);
            var Tt = d.alternate;
            Tt !== null &&
              ((Tt = Tt.updateQueue),
              (Me = Tt.lastBaseUpdate),
              Me !== ce &&
                (Me === null ? (Tt.firstBaseUpdate = ct) : (Me.next = ct),
                (Tt.lastBaseUpdate = Qe)));
          }
          if (z !== null) {
            var Kt = D.baseState;
            (ce = 0), (Tt = ct = Qe = null), (Me = z);
            do {
              var Bt = Me.lane,
                On = Me.eventTime;
              if ((C & Bt) === Bt) {
                Tt !== null &&
                  (Tt = Tt.next =
                    {
                      eventTime: On,
                      lane: 0,
                      tag: Me.tag,
                      payload: Me.payload,
                      callback: Me.callback,
                      next: null,
                    });
                e: {
                  var bt = d,
                    Mn = Me;
                  switch (((Bt = p), (On = b), Mn.tag)) {
                    case 1:
                      if (((bt = Mn.payload), typeof bt == "function")) {
                        Kt = bt.call(On, Kt, Bt);
                        break e;
                      }
                      Kt = bt;
                      break e;
                    case 3:
                      bt.flags = (bt.flags & -65537) | 128;
                    case 0:
                      if (
                        ((bt = Mn.payload),
                        (Bt =
                          typeof bt == "function" ? bt.call(On, Kt, Bt) : bt),
                        Bt == null)
                      )
                        break e;
                      Kt = o({}, Kt, Bt);
                      break e;
                    case 2:
                      bo = !0;
                  }
                }
                Me.callback !== null &&
                  Me.lane !== 0 &&
                  ((d.flags |= 64),
                  (Bt = D.effects),
                  Bt === null ? (D.effects = [Me]) : Bt.push(Me));
              } else
                (On = {
                  eventTime: On,
                  lane: Bt,
                  tag: Me.tag,
                  payload: Me.payload,
                  callback: Me.callback,
                  next: null,
                }),
                  Tt === null
                    ? ((ct = Tt = On), (Qe = Kt))
                    : (Tt = Tt.next = On),
                  (ce |= Bt);
              if (((Me = Me.next), Me === null)) {
                if (((Me = D.shared.pending), Me === null)) break;
                (Bt = Me),
                  (Me = Bt.next),
                  (Bt.next = null),
                  (D.lastBaseUpdate = Bt),
                  (D.shared.pending = null);
              }
            } while (!0);
            if (
              (Tt === null && (Qe = Kt),
              (D.baseState = Qe),
              (D.firstBaseUpdate = ct),
              (D.lastBaseUpdate = Tt),
              (p = D.shared.interleaved),
              p !== null)
            ) {
              D = p;
              do (ce |= D.lane), (D = D.next);
              while (D !== p);
            } else z === null && (D.shared.lanes = 0);
            (hl |= ce), (d.lanes = ce), (d.memoizedState = Kt);
          }
        }
        function fg(d, p, b) {
          if (((d = p.effects), (p.effects = null), d !== null))
            for (p = 0; p < d.length; p++) {
              var C = d[p],
                D = C.callback;
              if (D !== null) {
                if (((C.callback = null), (C = b), typeof D != "function"))
                  throw Error(s(191, D));
                D.call(C);
              }
            }
        }
        var dg = new r.Component().refs;
        function Hh(d, p, b, C) {
          (p = d.memoizedState),
            (b = b(C, p)),
            (b = b == null ? p : o({}, p, b)),
            (d.memoizedState = b),
            d.lanes === 0 && (d.updateQueue.baseState = b);
        }
        var Of = {
          isMounted: function (d) {
            return (d = d._reactInternals) ? N(d) === d : !1;
          },
          enqueueSetState: function (d, p, b) {
            d = d._reactInternals;
            var C = Zr(),
              D = ys(d),
              z = Os(C, D);
            (z.payload = p),
              b != null && (z.callback = b),
              ya(d, z),
              (p = Gi(d, D, C)),
              p !== null && kf(p, d, D);
          },
          enqueueReplaceState: function (d, p, b) {
            d = d._reactInternals;
            var C = Zr(),
              D = ys(d),
              z = Os(C, D);
            (z.tag = 1),
              (z.payload = p),
              b != null && (z.callback = b),
              ya(d, z),
              (p = Gi(d, D, C)),
              p !== null && kf(p, d, D);
          },
          enqueueForceUpdate: function (d, p) {
            d = d._reactInternals;
            var b = Zr(),
              C = ys(d),
              D = Os(b, C);
            (D.tag = 2),
              p != null && (D.callback = p),
              ya(d, D),
              (p = Gi(d, C, b)),
              p !== null && kf(p, d, C);
          },
        };
        function Vh(d, p, b, C, D, z, ce) {
          return (
            (d = d.stateNode),
            typeof d.shouldComponentUpdate == "function"
              ? d.shouldComponentUpdate(C, z, ce)
              : p.prototype && p.prototype.isPureReactComponent
              ? !Fi(b, C) || !Fi(D, z)
              : !0
          );
        }
        function hg(d, p, b) {
          var C = !1,
            D = Qt,
            z = p.contextType;
          return (
            typeof z == "object" && z !== null
              ? (z = er(z))
              : ((D = Wn(p) ? ii : zt.current),
                (C = p.contextTypes),
                (z = (C = C != null) ? An(d, D) : Qt)),
            (p = new p(b, z)),
            (d.memoizedState =
              p.state !== null && p.state !== void 0 ? p.state : null),
            (p.updater = Of),
            (d.stateNode = p),
            (p._reactInternals = d),
            C &&
              ((d = d.stateNode),
              (d.__reactInternalMemoizedUnmaskedChildContext = D),
              (d.__reactInternalMemoizedMaskedChildContext = z)),
            p
          );
        }
        function pg(d, p, b, C) {
          (d = p.state),
            typeof p.componentWillReceiveProps == "function" &&
              p.componentWillReceiveProps(b, C),
            typeof p.UNSAFE_componentWillReceiveProps == "function" &&
              p.UNSAFE_componentWillReceiveProps(b, C),
            p.state !== d && Of.enqueueReplaceState(p, p.state, null);
        }
        function Gh(d, p, b, C) {
          var D = d.stateNode;
          (D.props = b), (D.state = d.memoizedState), (D.refs = dg), $l(d);
          var z = p.contextType;
          typeof z == "object" && z !== null
            ? (D.context = er(z))
            : ((z = Wn(p) ? ii : zt.current), (D.context = An(d, z))),
            (D.state = d.memoizedState),
            (z = p.getDerivedStateFromProps),
            typeof z == "function" &&
              (Hh(d, p, z, b), (D.state = d.memoizedState)),
            typeof p.getDerivedStateFromProps == "function" ||
              typeof D.getSnapshotBeforeUpdate == "function" ||
              (typeof D.UNSAFE_componentWillMount != "function" &&
                typeof D.componentWillMount != "function") ||
              ((p = D.state),
              typeof D.componentWillMount == "function" &&
                D.componentWillMount(),
              typeof D.UNSAFE_componentWillMount == "function" &&
                D.UNSAFE_componentWillMount(),
              p !== D.state && Of.enqueueReplaceState(D, D.state, null),
              Nf(d, b, D, C),
              (D.state = d.memoizedState)),
            typeof D.componentDidMount == "function" && (d.flags |= 4194308);
        }
        var Xl = [],
          xa = 0,
          Uf = null,
          Ff = 0,
          Mo = [],
          oo = 0,
          Ja = null,
          Us = 1,
          Fs = "";
        function Qa(d, p) {
          (Xl[xa++] = Ff), (Xl[xa++] = Uf), (Uf = d), (Ff = p);
        }
        function mg(d, p, b) {
          (Mo[oo++] = Us), (Mo[oo++] = Fs), (Mo[oo++] = Ja), (Ja = d);
          var C = Us;
          d = Fs;
          var D = 32 - di(C) - 1;
          (C &= ~(1 << D)), (b += 1);
          var z = 32 - di(p) + D;
          if (30 < z) {
            var ce = D - (D % 5);
            (z = (C & ((1 << ce) - 1)).toString(32)),
              (C >>= ce),
              (D -= ce),
              (Us = (1 << (32 - di(p) + D)) | (b << D) | C),
              (Fs = z + d);
          } else (Us = (1 << z) | (b << D) | C), (Fs = d);
        }
        function Wh(d) {
          d.return !== null && (Qa(d, 1), mg(d, 1, 0));
        }
        function jh(d) {
          for (; d === Uf; )
            (Uf = Xl[--xa]), (Xl[xa] = null), (Ff = Xl[--xa]), (Xl[xa] = null);
          for (; d === Ja; )
            (Ja = Mo[--oo]),
              (Mo[oo] = null),
              (Fs = Mo[--oo]),
              (Mo[oo] = null),
              (Us = Mo[--oo]),
              (Mo[oo] = null);
        }
        var wi = null,
          si = null,
          qn = !1,
          Yl = !1,
          Eo = null;
        function $h(d, p) {
          var b = co(5, null, null, 0);
          (b.elementType = "DELETED"),
            (b.stateNode = p),
            (b.return = d),
            (p = d.deletions),
            p === null ? ((d.deletions = [b]), (d.flags |= 16)) : p.push(b);
        }
        function Xh(d, p) {
          switch (d.tag) {
            case 5:
              return (
                (p = Sn(p, d.type, d.pendingProps)),
                p !== null
                  ? ((d.stateNode = p), (wi = d), (si = Br(p)), !0)
                  : !1
              );
            case 6:
              return (
                (p = mn(p, d.pendingProps)),
                p !== null ? ((d.stateNode = p), (wi = d), (si = null), !0) : !1
              );
            case 13:
              if (((p = lr(p)), p !== null)) {
                var b = Ja !== null ? { id: Us, overflow: Fs } : null;
                return (
                  (d.memoizedState = {
                    dehydrated: p,
                    treeContext: b,
                    retryLane: 1073741824,
                  }),
                  (b = co(18, null, null, 0)),
                  (b.stateNode = p),
                  (b.return = d),
                  (d.child = b),
                  (wi = d),
                  (si = null),
                  !0
                );
              }
              return !1;
            default:
              return !1;
          }
        }
        function Bf(d) {
          return (d.mode & 1) !== 0 && (d.flags & 128) === 0;
        }
        function _a(d) {
          if (qn) {
            var p = si;
            if (p) {
              var b = p;
              if (!Xh(d, p)) {
                if (Bf(d)) throw Error(s(418));
                p = Ar(b);
                var C = wi;
                p && Xh(d, p)
                  ? $h(C, b)
                  : ((d.flags = (d.flags & -4097) | 2), (qn = !1), (wi = d));
              }
            } else {
              if (Bf(d)) throw Error(s(418));
              (d.flags = (d.flags & -4097) | 2), (qn = !1), (wi = d);
            }
          }
        }
        function gg(d) {
          for (
            d = d.return;
            d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13;

          )
            d = d.return;
          wi = d;
        }
        function Zu(d) {
          if (!we || d !== wi) return !1;
          if (!qn) return gg(d), (qn = !0), !1;
          if (
            d.tag !== 3 &&
            (d.tag !== 5 || (ut(d.type) && !oe(d.type, d.memoizedProps)))
          ) {
            var p = si;
            if (p) {
              if (Bf(d)) {
                for (d = si; d; ) d = Ar(d);
                throw Error(s(418));
              }
              for (; p; ) $h(d, p), (p = Ar(p));
            }
          }
          if ((gg(d), d.tag === 13)) {
            if (!we) throw Error(s(316));
            if (
              ((d = d.memoizedState),
              (d = d !== null ? d.dehydrated : null),
              !d)
            )
              throw Error(s(317));
            si = ie(d);
          } else si = wi ? Ar(d.stateNode) : null;
          return !0;
        }
        function ql() {
          we && ((si = wi = null), (Yl = qn = !1));
        }
        function zf(d) {
          Eo === null ? (Eo = [d]) : Eo.push(d);
        }
        function Kl(d, p, b) {
          if (
            ((d = b.ref),
            d !== null && typeof d != "function" && typeof d != "object")
          ) {
            if (b._owner) {
              if (((b = b._owner), b)) {
                if (b.tag !== 1) throw Error(s(309));
                var C = b.stateNode;
              }
              if (!C) throw Error(s(147, d));
              var D = C,
                z = "" + d;
              return p !== null &&
                p.ref !== null &&
                typeof p.ref == "function" &&
                p.ref._stringRef === z
                ? p.ref
                : ((p = function (ce) {
                    var Me = D.refs;
                    Me === dg && (Me = D.refs = {}),
                      ce === null ? delete Me[z] : (Me[z] = ce);
                  }),
                  (p._stringRef = z),
                  p);
            }
            if (typeof d != "string") throw Error(s(284));
            if (!b._owner) throw Error(s(290, d));
          }
          return d;
        }
        function Sa(d, p) {
          throw (
            ((d = Object.prototype.toString.call(p)),
            Error(
              s(
                31,
                d === "[object Object]"
                  ? "object with keys {" + Object.keys(p).join(", ") + "}"
                  : d
              )
            ))
          );
        }
        function Zl(d) {
          var p = d._init;
          return p(d._payload);
        }
        function vg(d) {
          function p(He, Pe) {
            if (d) {
              var Ze = He.deletions;
              Ze === null
                ? ((He.deletions = [Pe]), (He.flags |= 16))
                : Ze.push(Pe);
            }
          }
          function b(He, Pe) {
            if (!d) return null;
            for (; Pe !== null; ) p(He, Pe), (Pe = Pe.sibling);
            return null;
          }
          function C(He, Pe) {
            for (He = new Map(); Pe !== null; )
              Pe.key !== null ? He.set(Pe.key, Pe) : He.set(Pe.index, Pe),
                (Pe = Pe.sibling);
            return He;
          }
          function D(He, Pe) {
            return (He = Ks(He, Pe)), (He.index = 0), (He.sibling = null), He;
          }
          function z(He, Pe, Ze) {
            return (
              (He.index = Ze),
              d
                ? ((Ze = He.alternate),
                  Ze !== null
                    ? ((Ze = Ze.index), Ze < Pe ? ((He.flags |= 2), Pe) : Ze)
                    : ((He.flags |= 2), Pe))
                : ((He.flags |= 1048576), Pe)
            );
          }
          function ce(He) {
            return d && He.alternate === null && (He.flags |= 2), He;
          }
          function Me(He, Pe, Ze, _t) {
            return Pe === null || Pe.tag !== 6
              ? ((Pe = yd(Ze, He.mode, _t)), (Pe.return = He), Pe)
              : ((Pe = D(Pe, Ze)), (Pe.return = He), Pe);
          }
          function Qe(He, Pe, Ze, _t) {
            var It = Ze.type;
            return It === h
              ? Tt(He, Pe, Ze.props.children, _t, Ze.key)
              : Pe !== null &&
                (Pe.elementType === It ||
                  (typeof It == "object" &&
                    It !== null &&
                    It.$$typeof === E &&
                    Zl(It) === Pe.type))
              ? ((_t = D(Pe, Ze.props)),
                (_t.ref = Kl(He, Pe, Ze)),
                (_t.return = He),
                _t)
              : ((_t = _c(Ze.type, Ze.key, Ze.props, null, He.mode, _t)),
                (_t.ref = Kl(He, Pe, Ze)),
                (_t.return = He),
                _t);
          }
          function ct(He, Pe, Ze, _t) {
            return Pe === null ||
              Pe.tag !== 4 ||
              Pe.stateNode.containerInfo !== Ze.containerInfo ||
              Pe.stateNode.implementation !== Ze.implementation
              ? ((Pe = xd(Ze, He.mode, _t)), (Pe.return = He), Pe)
              : ((Pe = D(Pe, Ze.children || [])), (Pe.return = He), Pe);
          }
          function Tt(He, Pe, Ze, _t, It) {
            return Pe === null || Pe.tag !== 7
              ? ((Pe = ka(Ze, He.mode, _t, It)), (Pe.return = He), Pe)
              : ((Pe = D(Pe, Ze)), (Pe.return = He), Pe);
          }
          function Kt(He, Pe, Ze) {
            if ((typeof Pe == "string" && Pe !== "") || typeof Pe == "number")
              return (Pe = yd("" + Pe, He.mode, Ze)), (Pe.return = He), Pe;
            if (typeof Pe == "object" && Pe !== null) {
              switch (Pe.$$typeof) {
                case u:
                  return (
                    (Ze = _c(Pe.type, Pe.key, Pe.props, null, He.mode, Ze)),
                    (Ze.ref = Kl(He, null, Pe)),
                    (Ze.return = He),
                    Ze
                  );
                case f:
                  return (Pe = xd(Pe, He.mode, Ze)), (Pe.return = He), Pe;
                case E:
                  var _t = Pe._init;
                  return Kt(He, _t(Pe._payload), Ze);
              }
              if (Z(Pe) || k(Pe))
                return (Pe = ka(Pe, He.mode, Ze, null)), (Pe.return = He), Pe;
              Sa(He, Pe);
            }
            return null;
          }
          function Bt(He, Pe, Ze, _t) {
            var It = Pe !== null ? Pe.key : null;
            if ((typeof Ze == "string" && Ze !== "") || typeof Ze == "number")
              return It !== null ? null : Me(He, Pe, "" + Ze, _t);
            if (typeof Ze == "object" && Ze !== null) {
              switch (Ze.$$typeof) {
                case u:
                  return Ze.key === It ? Qe(He, Pe, Ze, _t) : null;
                case f:
                  return Ze.key === It ? ct(He, Pe, Ze, _t) : null;
                case E:
                  return (It = Ze._init), Bt(He, Pe, It(Ze._payload), _t);
              }
              if (Z(Ze) || k(Ze))
                return It !== null ? null : Tt(He, Pe, Ze, _t, null);
              Sa(He, Ze);
            }
            return null;
          }
          function On(He, Pe, Ze, _t, It) {
            if ((typeof _t == "string" && _t !== "") || typeof _t == "number")
              return (He = He.get(Ze) || null), Me(Pe, He, "" + _t, It);
            if (typeof _t == "object" && _t !== null) {
              switch (_t.$$typeof) {
                case u:
                  return (
                    (He = He.get(_t.key === null ? Ze : _t.key) || null),
                    Qe(Pe, He, _t, It)
                  );
                case f:
                  return (
                    (He = He.get(_t.key === null ? Ze : _t.key) || null),
                    ct(Pe, He, _t, It)
                  );
                case E:
                  var en = _t._init;
                  return On(He, Pe, Ze, en(_t._payload), It);
              }
              if (Z(_t) || k(_t))
                return (He = He.get(Ze) || null), Tt(Pe, He, _t, It, null);
              Sa(Pe, _t);
            }
            return null;
          }
          function bt(He, Pe, Ze, _t) {
            for (
              var It = null, en = null, Yt = Pe, pn = (Pe = 0), kr = null;
              Yt !== null && pn < Ze.length;
              pn++
            ) {
              Yt.index > pn ? ((kr = Yt), (Yt = null)) : (kr = Yt.sibling);
              var hn = Bt(He, Yt, Ze[pn], _t);
              if (hn === null) {
                Yt === null && (Yt = kr);
                break;
              }
              d && Yt && hn.alternate === null && p(He, Yt),
                (Pe = z(hn, Pe, pn)),
                en === null ? (It = hn) : (en.sibling = hn),
                (en = hn),
                (Yt = kr);
            }
            if (pn === Ze.length) return b(He, Yt), qn && Qa(He, pn), It;
            if (Yt === null) {
              for (; pn < Ze.length; pn++)
                (Yt = Kt(He, Ze[pn], _t)),
                  Yt !== null &&
                    ((Pe = z(Yt, Pe, pn)),
                    en === null ? (It = Yt) : (en.sibling = Yt),
                    (en = Yt));
              return qn && Qa(He, pn), It;
            }
            for (Yt = C(He, Yt); pn < Ze.length; pn++)
              (kr = On(Yt, He, pn, Ze[pn], _t)),
                kr !== null &&
                  (d &&
                    kr.alternate !== null &&
                    Yt.delete(kr.key === null ? pn : kr.key),
                  (Pe = z(kr, Pe, pn)),
                  en === null ? (It = kr) : (en.sibling = kr),
                  (en = kr));
            return (
              d &&
                Yt.forEach(function (xs) {
                  return p(He, xs);
                }),
              qn && Qa(He, pn),
              It
            );
          }
          function Mn(He, Pe, Ze, _t) {
            var It = k(Ze);
            if (typeof It != "function") throw Error(s(150));
            if (((Ze = It.call(Ze)), Ze == null)) throw Error(s(151));
            for (
              var en = (It = null),
                Yt = Pe,
                pn = (Pe = 0),
                kr = null,
                hn = Ze.next();
              Yt !== null && !hn.done;
              pn++, hn = Ze.next()
            ) {
              Yt.index > pn ? ((kr = Yt), (Yt = null)) : (kr = Yt.sibling);
              var xs = Bt(He, Yt, hn.value, _t);
              if (xs === null) {
                Yt === null && (Yt = kr);
                break;
              }
              d && Yt && xs.alternate === null && p(He, Yt),
                (Pe = z(xs, Pe, pn)),
                en === null ? (It = xs) : (en.sibling = xs),
                (en = xs),
                (Yt = kr);
            }
            if (hn.done) return b(He, Yt), qn && Qa(He, pn), It;
            if (Yt === null) {
              for (; !hn.done; pn++, hn = Ze.next())
                (hn = Kt(He, hn.value, _t)),
                  hn !== null &&
                    ((Pe = z(hn, Pe, pn)),
                    en === null ? (It = hn) : (en.sibling = hn),
                    (en = hn));
              return qn && Qa(He, pn), It;
            }
            for (Yt = C(He, Yt); !hn.done; pn++, hn = Ze.next())
              (hn = On(Yt, He, pn, hn.value, _t)),
                hn !== null &&
                  (d &&
                    hn.alternate !== null &&
                    Yt.delete(hn.key === null ? pn : hn.key),
                  (Pe = z(hn, Pe, pn)),
                  en === null ? (It = hn) : (en.sibling = hn),
                  (en = hn));
            return (
              d &&
                Yt.forEach(function (Og) {
                  return p(He, Og);
                }),
              qn && Qa(He, pn),
              It
            );
          }
          function fo(He, Pe, Ze, _t) {
            if (
              (typeof Ze == "object" &&
                Ze !== null &&
                Ze.type === h &&
                Ze.key === null &&
                (Ze = Ze.props.children),
              typeof Ze == "object" && Ze !== null)
            ) {
              switch (Ze.$$typeof) {
                case u:
                  e: {
                    for (var It = Ze.key, en = Pe; en !== null; ) {
                      if (en.key === It) {
                        if (((It = Ze.type), It === h)) {
                          if (en.tag === 7) {
                            b(He, en.sibling),
                              (Pe = D(en, Ze.props.children)),
                              (Pe.return = He),
                              (He = Pe);
                            break e;
                          }
                        } else if (
                          en.elementType === It ||
                          (typeof It == "object" &&
                            It !== null &&
                            It.$$typeof === E &&
                            Zl(It) === en.type)
                        ) {
                          b(He, en.sibling),
                            (Pe = D(en, Ze.props)),
                            (Pe.ref = Kl(He, en, Ze)),
                            (Pe.return = He),
                            (He = Pe);
                          break e;
                        }
                        b(He, en);
                        break;
                      } else p(He, en);
                      en = en.sibling;
                    }
                    Ze.type === h
                      ? ((Pe = ka(Ze.props.children, He.mode, _t, Ze.key)),
                        (Pe.return = He),
                        (He = Pe))
                      : ((_t = _c(
                          Ze.type,
                          Ze.key,
                          Ze.props,
                          null,
                          He.mode,
                          _t
                        )),
                        (_t.ref = Kl(He, Pe, Ze)),
                        (_t.return = He),
                        (He = _t));
                  }
                  return ce(He);
                case f:
                  e: {
                    for (en = Ze.key; Pe !== null; ) {
                      if (Pe.key === en)
                        if (
                          Pe.tag === 4 &&
                          Pe.stateNode.containerInfo === Ze.containerInfo &&
                          Pe.stateNode.implementation === Ze.implementation
                        ) {
                          b(He, Pe.sibling),
                            (Pe = D(Pe, Ze.children || [])),
                            (Pe.return = He),
                            (He = Pe);
                          break e;
                        } else {
                          b(He, Pe);
                          break;
                        }
                      else p(He, Pe);
                      Pe = Pe.sibling;
                    }
                    (Pe = xd(Ze, He.mode, _t)), (Pe.return = He), (He = Pe);
                  }
                  return ce(He);
                case E:
                  return (en = Ze._init), fo(He, Pe, en(Ze._payload), _t);
              }
              if (Z(Ze)) return bt(He, Pe, Ze, _t);
              if (k(Ze)) return Mn(He, Pe, Ze, _t);
              Sa(He, Ze);
            }
            return (typeof Ze == "string" && Ze !== "") || typeof Ze == "number"
              ? ((Ze = "" + Ze),
                Pe !== null && Pe.tag === 6
                  ? (b(He, Pe.sibling),
                    (Pe = D(Pe, Ze)),
                    (Pe.return = He),
                    (He = Pe))
                  : (b(He, Pe),
                    (Pe = yd(Ze, He.mode, _t)),
                    (Pe.return = He),
                    (He = Pe)),
                ce(He))
              : b(He, Pe);
          }
          return fo;
        }
        var Bs = vg(!0),
          yg = vg(!1),
          Jl = {},
          zi = wn(Jl),
          el = wn(Jl),
          tl = wn(Jl);
        function jo(d) {
          if (d === Jl) throw Error(s(174));
          return d;
        }
        function Hf(d, p) {
          dt(tl, p), dt(el, d), dt(zi, Jl), (d = re(p)), wt(zi), dt(zi, d);
        }
        function Ql() {
          wt(zi), wt(el), wt(tl);
        }
        function xg(d) {
          var p = jo(tl.current),
            b = jo(zi.current);
          (p = W(b, d.type, p)), b !== p && (dt(el, d), dt(zi, p));
        }
        function Yh(d) {
          el.current === d && (wt(zi), wt(el));
        }
        var tr = wn(0);
        function Vf(d) {
          for (var p = d; p !== null; ) {
            if (p.tag === 13) {
              var b = p.memoizedState;
              if (
                b !== null &&
                ((b = b.dehydrated), b === null || Ui(b) || yr(b))
              )
                return p;
            } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
              if ((p.flags & 128) !== 0) return p;
            } else if (p.child !== null) {
              (p.child.return = p), (p = p.child);
              continue;
            }
            if (p === d) break;
            for (; p.sibling === null; ) {
              if (p.return === null || p.return === d) return null;
              p = p.return;
            }
            (p.sibling.return = p.return), (p = p.sibling);
          }
          return null;
        }
        var so = [];
        function nl() {
          for (var d = 0; d < so.length; d++) {
            var p = so[d];
            ge
              ? (p._workInProgressVersionPrimary = null)
              : (p._workInProgressVersionSecondary = null);
          }
          so.length = 0;
        }
        var Ju = l.ReactCurrentDispatcher,
          ao = l.ReactCurrentBatchConfig,
          rl = 0,
          nr = null,
          jr = null,
          $r = null,
          Gf = !1,
          hs = !1,
          il = 0,
          Qu = 0;
        function Xr() {
          throw Error(s(321));
        }
        function Wf(d, p) {
          if (p === null) return !1;
          for (var b = 0; b < p.length && b < d.length; b++)
            if (!Hr(d[b], p[b])) return !1;
          return !0;
        }
        function eu(d, p, b, C, D, z) {
          if (
            ((rl = z),
            (nr = p),
            (p.memoizedState = null),
            (p.updateQueue = null),
            (p.lanes = 0),
            (Ju.current = d === null || d.memoizedState === null ? ep : tp),
            (d = b(C, D)),
            hs)
          ) {
            z = 0;
            do {
              if (((hs = !1), (il = 0), 25 <= z)) throw Error(s(301));
              (z += 1),
                ($r = jr = null),
                (p.updateQueue = null),
                (Ju.current = np),
                (d = b(C, D));
            } while (hs);
          }
          if (
            ((Ju.current = iu),
            (p = jr !== null && jr.next !== null),
            (rl = 0),
            ($r = jr = nr = null),
            (Gf = !1),
            p)
          )
            throw Error(s(300));
          return d;
        }
        function wa() {
          var d = il !== 0;
          return (il = 0), d;
        }
        function $o() {
          var d = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return (
            $r === null ? (nr.memoizedState = $r = d) : ($r = $r.next = d), $r
          );
        }
        function Xo() {
          if (jr === null) {
            var d = nr.alternate;
            d = d !== null ? d.memoizedState : null;
          } else d = jr.next;
          var p = $r === null ? nr.memoizedState : $r.next;
          if (p !== null) ($r = p), (jr = d);
          else {
            if (d === null) throw Error(s(310));
            (jr = d),
              (d = {
                memoizedState: jr.memoizedState,
                baseState: jr.baseState,
                baseQueue: jr.baseQueue,
                queue: jr.queue,
                next: null,
              }),
              $r === null ? (nr.memoizedState = $r = d) : ($r = $r.next = d);
          }
          return $r;
        }
        function ps(d, p) {
          return typeof p == "function" ? p(d) : p;
        }
        function ec(d) {
          var p = Xo(),
            b = p.queue;
          if (b === null) throw Error(s(311));
          b.lastRenderedReducer = d;
          var C = jr,
            D = C.baseQueue,
            z = b.pending;
          if (z !== null) {
            if (D !== null) {
              var ce = D.next;
              (D.next = z.next), (z.next = ce);
            }
            (C.baseQueue = D = z), (b.pending = null);
          }
          if (D !== null) {
            (z = D.next), (C = C.baseState);
            var Me = (ce = null),
              Qe = null,
              ct = z;
            do {
              var Tt = ct.lane;
              if ((rl & Tt) === Tt)
                Qe !== null &&
                  (Qe = Qe.next =
                    {
                      lane: 0,
                      action: ct.action,
                      hasEagerState: ct.hasEagerState,
                      eagerState: ct.eagerState,
                      next: null,
                    }),
                  (C = ct.hasEagerState ? ct.eagerState : d(C, ct.action));
              else {
                var Kt = {
                  lane: Tt,
                  action: ct.action,
                  hasEagerState: ct.hasEagerState,
                  eagerState: ct.eagerState,
                  next: null,
                };
                Qe === null ? ((Me = Qe = Kt), (ce = C)) : (Qe = Qe.next = Kt),
                  (nr.lanes |= Tt),
                  (hl |= Tt);
              }
              ct = ct.next;
            } while (ct !== null && ct !== z);
            Qe === null ? (ce = C) : (Qe.next = Me),
              Hr(C, p.memoizedState) || (Yr = !0),
              (p.memoizedState = C),
              (p.baseState = ce),
              (p.baseQueue = Qe),
              (b.lastRenderedState = C);
          }
          if (((d = b.interleaved), d !== null)) {
            D = d;
            do (z = D.lane), (nr.lanes |= z), (hl |= z), (D = D.next);
            while (D !== d);
          } else D === null && (b.lanes = 0);
          return [p.memoizedState, b.dispatch];
        }
        function tc(d) {
          var p = Xo(),
            b = p.queue;
          if (b === null) throw Error(s(311));
          b.lastRenderedReducer = d;
          var C = b.dispatch,
            D = b.pending,
            z = p.memoizedState;
          if (D !== null) {
            b.pending = null;
            var ce = (D = D.next);
            do (z = d(z, ce.action)), (ce = ce.next);
            while (ce !== D);
            Hr(z, p.memoizedState) || (Yr = !0),
              (p.memoizedState = z),
              p.baseQueue === null && (p.baseState = z),
              (b.lastRenderedState = z);
          }
          return [z, C];
        }
        function qh() {}
        function Kh(d, p) {
          var b = nr,
            C = Xo(),
            D = p(),
            z = !Hr(C.memoizedState, D);
          if (
            (z && ((C.memoizedState = D), (Yr = !0)),
            (C = C.queue),
            tu(zs.bind(null, b, C, d), [d]),
            C.getSnapshot !== p ||
              z ||
              ($r !== null && $r.memoizedState.tag & 1))
          ) {
            if (
              ((b.flags |= 2048),
              rc(9, Jh.bind(null, b, C, D, p), void 0, null),
              rr === null)
            )
              throw Error(s(349));
            (rl & 30) !== 0 || Zh(b, p, D);
          }
          return D;
        }
        function Zh(d, p, b) {
          (d.flags |= 16384),
            (d = { getSnapshot: p, value: b }),
            (p = nr.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (nr.updateQueue = p),
                (p.stores = [d]))
              : ((b = p.stores), b === null ? (p.stores = [d]) : b.push(d));
        }
        function Jh(d, p, b, C) {
          (p.value = b), (p.getSnapshot = C), jf(p) && Gi(d, 1, -1);
        }
        function zs(d, p, b) {
          return b(function () {
            jf(p) && Gi(d, 1, -1);
          });
        }
        function jf(d) {
          var p = d.getSnapshot;
          d = d.value;
          try {
            var b = p();
            return !Hr(d, b);
          } catch {
            return !0;
          }
        }
        function nc(d) {
          var p = $o();
          return (
            typeof d == "function" && (d = d()),
            (p.memoizedState = p.baseState = d),
            (d = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: ps,
              lastRenderedState: d,
            }),
            (p.queue = d),
            (d = d.dispatch = hx.bind(null, nr, d)),
            [p.memoizedState, d]
          );
        }
        function rc(d, p, b, C) {
          return (
            (d = { tag: d, create: p, destroy: b, deps: C, next: null }),
            (p = nr.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (nr.updateQueue = p),
                (p.lastEffect = d.next = d))
              : ((b = p.lastEffect),
                b === null
                  ? (p.lastEffect = d.next = d)
                  : ((C = b.next),
                    (b.next = d),
                    (d.next = C),
                    (p.lastEffect = d))),
            d
          );
        }
        function _g() {
          return Xo().memoizedState;
        }
        function ba(d, p, b, C) {
          var D = $o();
          (nr.flags |= d),
            (D.memoizedState = rc(1 | p, b, void 0, C === void 0 ? null : C));
        }
        function $f(d, p, b, C) {
          var D = Xo();
          C = C === void 0 ? null : C;
          var z = void 0;
          if (jr !== null) {
            var ce = jr.memoizedState;
            if (((z = ce.destroy), C !== null && Wf(C, ce.deps))) {
              D.memoizedState = rc(p, b, z, C);
              return;
            }
          }
          (nr.flags |= d), (D.memoizedState = rc(1 | p, b, z, C));
        }
        function Xf(d, p) {
          return ba(8390656, 8, d, p);
        }
        function tu(d, p) {
          return $f(2048, 8, d, p);
        }
        function Bn(d, p) {
          return $f(4, 2, d, p);
        }
        function Yf(d, p) {
          return $f(4, 4, d, p);
        }
        function ic(d, p) {
          if (typeof p == "function")
            return (
              (d = d()),
              p(d),
              function () {
                p(null);
              }
            );
          if (p != null)
            return (
              (d = d()),
              (p.current = d),
              function () {
                p.current = null;
              }
            );
        }
        function nu(d, p, b) {
          return (
            (b = b != null ? b.concat([d]) : null),
            $f(4, 4, ic.bind(null, p, d), b)
          );
        }
        function qf() {}
        function Kf(d, p) {
          var b = Xo();
          p = p === void 0 ? null : p;
          var C = b.memoizedState;
          return C !== null && p !== null && Wf(p, C[1])
            ? C[0]
            : ((b.memoizedState = [d, p]), d);
        }
        function ru(d, p) {
          var b = Xo();
          p = p === void 0 ? null : p;
          var C = b.memoizedState;
          return C !== null && p !== null && Wf(p, C[1])
            ? C[0]
            : ((d = d()), (b.memoizedState = [d, p]), d);
        }
        function Zf(d, p) {
          var b = Xt;
          (Xt = b !== 0 && 4 > b ? b : 4), d(!0);
          var C = ao.transition;
          ao.transition = {};
          try {
            d(!1), p();
          } finally {
            (Xt = b), (ao.transition = C);
          }
        }
        function ol() {
          return Xo().memoizedState;
        }
        function Sg(d, p, b) {
          var C = ys(d);
          (b = {
            lane: C,
            action: b,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          }),
            wg(d)
              ? Qh(p, b)
              : (oc(d, p, b),
                (b = Zr()),
                (d = Gi(d, C, b)),
                d !== null && sc(d, p, C));
        }
        function hx(d, p, b) {
          var C = ys(d),
            D = {
              lane: C,
              action: b,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
          if (wg(d)) Qh(p, D);
          else {
            oc(d, p, D);
            var z = d.alternate;
            if (
              d.lanes === 0 &&
              (z === null || z.lanes === 0) &&
              ((z = p.lastRenderedReducer), z !== null)
            )
              try {
                var ce = p.lastRenderedState,
                  Me = z(ce, b);
                if (((D.hasEagerState = !0), (D.eagerState = Me), Hr(Me, ce)))
                  return;
              } catch {
              } finally {
              }
            (b = Zr()), (d = Gi(d, C, b)), d !== null && sc(d, p, C);
          }
        }
        function wg(d) {
          var p = d.alternate;
          return d === nr || (p !== null && p === nr);
        }
        function Qh(d, p) {
          hs = Gf = !0;
          var b = d.pending;
          b === null ? (p.next = p) : ((p.next = b.next), (b.next = p)),
            (d.pending = p);
        }
        function oc(d, p, b) {
          rr !== null && (d.mode & 1) !== 0 && (rn & 2) === 0
            ? ((d = p.interleaved),
              d === null
                ? ((b.next = b), Si === null ? (Si = [p]) : Si.push(p))
                : ((b.next = d.next), (d.next = b)),
              (p.interleaved = b))
            : ((d = p.pending),
              d === null ? (b.next = b) : ((b.next = d.next), (d.next = b)),
              (p.pending = b));
        }
        function sc(d, p, b) {
          if ((b & 4194240) !== 0) {
            var C = p.lanes;
            (C &= d.pendingLanes), (b |= C), (p.lanes = b), oi(d, b);
          }
        }
        var iu = {
            readContext: er,
            useCallback: Xr,
            useContext: Xr,
            useEffect: Xr,
            useImperativeHandle: Xr,
            useInsertionEffect: Xr,
            useLayoutEffect: Xr,
            useMemo: Xr,
            useReducer: Xr,
            useRef: Xr,
            useState: Xr,
            useDebugValue: Xr,
            useDeferredValue: Xr,
            useTransition: Xr,
            useMutableSource: Xr,
            useSyncExternalStore: Xr,
            useId: Xr,
            unstable_isNewReconciler: !1,
          },
          ep = {
            readContext: er,
            useCallback: function (d, p) {
              return ($o().memoizedState = [d, p === void 0 ? null : p]), d;
            },
            useContext: er,
            useEffect: Xf,
            useImperativeHandle: function (d, p, b) {
              return (
                (b = b != null ? b.concat([d]) : null),
                ba(4194308, 4, ic.bind(null, p, d), b)
              );
            },
            useLayoutEffect: function (d, p) {
              return ba(4194308, 4, d, p);
            },
            useInsertionEffect: function (d, p) {
              return ba(4, 2, d, p);
            },
            useMemo: function (d, p) {
              var b = $o();
              return (
                (p = p === void 0 ? null : p),
                (d = d()),
                (b.memoizedState = [d, p]),
                d
              );
            },
            useReducer: function (d, p, b) {
              var C = $o();
              return (
                (p = b !== void 0 ? b(p) : p),
                (C.memoizedState = C.baseState = p),
                (d = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: d,
                  lastRenderedState: p,
                }),
                (C.queue = d),
                (d = d.dispatch = Sg.bind(null, nr, d)),
                [C.memoizedState, d]
              );
            },
            useRef: function (d) {
              var p = $o();
              return (d = { current: d }), (p.memoizedState = d);
            },
            useState: nc,
            useDebugValue: qf,
            useDeferredValue: function (d) {
              var p = nc(d),
                b = p[0],
                C = p[1];
              return (
                Xf(
                  function () {
                    var D = ao.transition;
                    ao.transition = {};
                    try {
                      C(d);
                    } finally {
                      ao.transition = D;
                    }
                  },
                  [d]
                ),
                b
              );
            },
            useTransition: function () {
              var d = nc(!1),
                p = d[0];
              return (
                (d = Zf.bind(null, d[1])), ($o().memoizedState = d), [p, d]
              );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (d, p, b) {
              var C = nr,
                D = $o();
              if (qn) {
                if (b === void 0) throw Error(s(407));
                b = b();
              } else {
                if (((b = p()), rr === null)) throw Error(s(349));
                (rl & 30) !== 0 || Zh(C, p, b);
              }
              D.memoizedState = b;
              var z = { value: b, getSnapshot: p };
              return (
                (D.queue = z),
                Xf(zs.bind(null, C, z, d), [d]),
                (C.flags |= 2048),
                rc(9, Jh.bind(null, C, z, b, p), void 0, null),
                b
              );
            },
            useId: function () {
              var d = $o(),
                p = rr.identifierPrefix;
              if (qn) {
                var b = Fs,
                  C = Us;
                (b = (C & ~(1 << (32 - di(C) - 1))).toString(32) + b),
                  (p = ":" + p + "R" + b),
                  (b = il++),
                  0 < b && (p += "H" + b.toString(32)),
                  (p += ":");
              } else (b = Qu++), (p = ":" + p + "r" + b.toString(32) + ":");
              return (d.memoizedState = p);
            },
            unstable_isNewReconciler: !1,
          },
          tp = {
            readContext: er,
            useCallback: Kf,
            useContext: er,
            useEffect: tu,
            useImperativeHandle: nu,
            useInsertionEffect: Bn,
            useLayoutEffect: Yf,
            useMemo: ru,
            useReducer: ec,
            useRef: _g,
            useState: function () {
              return ec(ps);
            },
            useDebugValue: qf,
            useDeferredValue: function (d) {
              var p = ec(ps),
                b = p[0],
                C = p[1];
              return (
                tu(
                  function () {
                    var D = ao.transition;
                    ao.transition = {};
                    try {
                      C(d);
                    } finally {
                      ao.transition = D;
                    }
                  },
                  [d]
                ),
                b
              );
            },
            useTransition: function () {
              var d = ec(ps)[0],
                p = Xo().memoizedState;
              return [d, p];
            },
            useMutableSource: qh,
            useSyncExternalStore: Kh,
            useId: ol,
            unstable_isNewReconciler: !1,
          },
          np = {
            readContext: er,
            useCallback: Kf,
            useContext: er,
            useEffect: tu,
            useImperativeHandle: nu,
            useInsertionEffect: Bn,
            useLayoutEffect: Yf,
            useMemo: ru,
            useReducer: tc,
            useRef: _g,
            useState: function () {
              return tc(ps);
            },
            useDebugValue: qf,
            useDeferredValue: function (d) {
              var p = tc(ps),
                b = p[0],
                C = p[1];
              return (
                tu(
                  function () {
                    var D = ao.transition;
                    ao.transition = {};
                    try {
                      C(d);
                    } finally {
                      ao.transition = D;
                    }
                  },
                  [d]
                ),
                b
              );
            },
            useTransition: function () {
              var d = tc(ps)[0],
                p = Xo().memoizedState;
              return [d, p];
            },
            useMutableSource: qh,
            useSyncExternalStore: Kh,
            useId: ol,
            unstable_isNewReconciler: !1,
          };
        function rp(d, p) {
          try {
            var b = "",
              C = p;
            do (b += Ls(C)), (C = C.return);
            while (C);
            var D = b;
          } catch (z) {
            D =
              `
Error generating stack: ` +
              z.message +
              `
` +
              z.stack;
          }
          return { value: d, source: p, stack: D };
        }
        function Jf(d, p) {
          try {
            console.error(p.value);
          } catch (b) {
            setTimeout(function () {
              throw b;
            });
          }
        }
        var px = typeof WeakMap == "function" ? WeakMap : Map;
        function bg(d, p, b) {
          (b = Os(-1, b)), (b.tag = 3), (b.payload = { element: null });
          var C = p.value;
          return (
            (b.callback = function () {
              Aa || ((Aa = !0), (Ro = C)), Jf(d, p);
            }),
            b
          );
        }
        function Qf(d, p, b) {
          (b = Os(-1, b)), (b.tag = 3);
          var C = d.type.getDerivedStateFromError;
          if (typeof C == "function") {
            var D = p.value;
            (b.payload = function () {
              return C(D);
            }),
              (b.callback = function () {
                Jf(d, p);
              });
          }
          var z = d.stateNode;
          return (
            z !== null &&
              typeof z.componentDidCatch == "function" &&
              (b.callback = function () {
                Jf(d, p),
                  typeof C != "function" &&
                    (Po === null ? (Po = new Set([this])) : Po.add(this));
                var ce = p.stack;
                this.componentDidCatch(p.value, {
                  componentStack: ce !== null ? ce : "",
                });
              }),
            b
          );
        }
        function Hs(d, p, b) {
          var C = d.pingCache;
          if (C === null) {
            C = d.pingCache = new px();
            var D = new Set();
            C.set(p, D);
          } else (D = C.get(p)), D === void 0 && ((D = new Set()), C.set(p, D));
          D.has(b) || (D.add(b), (d = Cg.bind(null, d, p, b)), p.then(d, d));
        }
        function ip(d) {
          do {
            var p;
            if (
              ((p = d.tag === 13) &&
                ((p = d.memoizedState),
                (p = p !== null ? p.dehydrated !== null : !0)),
              p)
            )
              return d;
            d = d.return;
          } while (d !== null);
          return null;
        }
        function sl(d, p, b, C, D) {
          return (d.mode & 1) === 0
            ? (d === p
                ? (d.flags |= 65536)
                : ((d.flags |= 128),
                  (b.flags |= 131072),
                  (b.flags &= -52805),
                  b.tag === 1 &&
                    (b.alternate === null
                      ? (b.tag = 17)
                      : ((p = Os(-1, 1)), (p.tag = 2), ya(b, p))),
                  (b.lanes |= 1)),
              d)
            : ((d.flags |= 65536), (d.lanes = D), d);
        }
        function Lr(d) {
          d.flags |= 4;
        }
        function ou(d, p) {
          if (d !== null && d.child === p.child) return !0;
          if ((p.flags & 16) !== 0) return !1;
          for (d = p.child; d !== null; ) {
            if ((d.flags & 12854) !== 0 || (d.subtreeFlags & 12854) !== 0)
              return !1;
            d = d.sibling;
          }
          return !0;
        }
        var lo, al, ed, td;
        if (xe)
          (lo = function (d, p) {
            for (var b = p.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6) ne(d, b.stateNode);
              else if (b.tag !== 4 && b.child !== null) {
                (b.child.return = b), (b = b.child);
                continue;
              }
              if (b === p) break;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === p) return;
                b = b.return;
              }
              (b.sibling.return = b.return), (b = b.sibling);
            }
          }),
            (al = function () {}),
            (ed = function (d, p, b, C, D) {
              if (((d = d.memoizedProps), d !== C)) {
                var z = p.stateNode,
                  ce = jo(zi.current);
                (b = J(z, b, d, C, D, ce)), (p.updateQueue = b) && Lr(p);
              }
            }),
            (td = function (d, p, b, C) {
              b !== C && Lr(p);
            });
        else if (j) {
          lo = function (d, p, b, C) {
            for (var D = p.child; D !== null; ) {
              if (D.tag === 5) {
                var z = D.stateNode;
                b && C && (z = $t(z, D.type, D.memoizedProps, D)), ne(d, z);
              } else if (D.tag === 6)
                (z = D.stateNode),
                  b && C && (z = un(z, D.memoizedProps, D)),
                  ne(d, z);
              else if (D.tag !== 4) {
                if (D.tag === 22 && D.memoizedState !== null)
                  (z = D.child), z !== null && (z.return = D), lo(d, D, !0, !0);
                else if (D.child !== null) {
                  (D.child.return = D), (D = D.child);
                  continue;
                }
              }
              if (D === p) break;
              for (; D.sibling === null; ) {
                if (D.return === null || D.return === p) return;
                D = D.return;
              }
              (D.sibling.return = D.return), (D = D.sibling);
            }
          };
          var Ma = function (d, p, b, C) {
            for (var D = p.child; D !== null; ) {
              if (D.tag === 5) {
                var z = D.stateNode;
                b && C && (z = $t(z, D.type, D.memoizedProps, D)), Ot(d, z);
              } else if (D.tag === 6)
                (z = D.stateNode),
                  b && C && (z = un(z, D.memoizedProps, D)),
                  Ot(d, z);
              else if (D.tag !== 4) {
                if (D.tag === 22 && D.memoizedState !== null)
                  (z = D.child), z !== null && (z.return = D), Ma(d, D, !0, !0);
                else if (D.child !== null) {
                  (D.child.return = D), (D = D.child);
                  continue;
                }
              }
              if (D === p) break;
              for (; D.sibling === null; ) {
                if (D.return === null || D.return === p) return;
                D = D.return;
              }
              (D.sibling.return = D.return), (D = D.sibling);
            }
          };
          (al = function (d, p) {
            var b = p.stateNode;
            if (!ou(d, p)) {
              d = b.containerInfo;
              var C = gt(d);
              Ma(C, p, !1, !1), (b.pendingChildren = C), Lr(p), Ut(d, C);
            }
          }),
            (ed = function (d, p, b, C, D) {
              var z = d.stateNode,
                ce = d.memoizedProps;
              if ((d = ou(d, p)) && ce === C) p.stateNode = z;
              else {
                var Me = p.stateNode,
                  Qe = jo(zi.current),
                  ct = null;
                ce !== C && (ct = J(Me, b, ce, C, D, Qe)),
                  d && ct === null
                    ? (p.stateNode = z)
                    : ((z = mt(z, ct, b, ce, C, p, d, Me)),
                      ae(z, b, C, D, Qe) && Lr(p),
                      (p.stateNode = z),
                      d ? Lr(p) : lo(z, p, !1, !1));
              }
            }),
            (td = function (d, p, b, C) {
              b !== C
                ? ((d = jo(tl.current)),
                  (b = jo(zi.current)),
                  (p.stateNode = de(C, d, b, p)),
                  Lr(p))
                : (p.stateNode = d.stateNode);
            });
        } else
          (al = function () {}), (ed = function () {}), (td = function () {});
        function Vs(d, p) {
          if (!qn)
            switch (d.tailMode) {
              case "hidden":
                p = d.tail;
                for (var b = null; p !== null; )
                  p.alternate !== null && (b = p), (p = p.sibling);
                b === null ? (d.tail = null) : (b.sibling = null);
                break;
              case "collapsed":
                b = d.tail;
                for (var C = null; b !== null; )
                  b.alternate !== null && (C = b), (b = b.sibling);
                C === null
                  ? p || d.tail === null
                    ? (d.tail = null)
                    : (d.tail.sibling = null)
                  : (C.sibling = null);
            }
        }
        function fr(d) {
          var p = d.alternate !== null && d.alternate.child === d.child,
            b = 0,
            C = 0;
          if (p)
            for (var D = d.child; D !== null; )
              (b |= D.lanes | D.childLanes),
                (C |= D.subtreeFlags & 14680064),
                (C |= D.flags & 14680064),
                (D.return = d),
                (D = D.sibling);
          else
            for (D = d.child; D !== null; )
              (b |= D.lanes | D.childLanes),
                (C |= D.subtreeFlags),
                (C |= D.flags),
                (D.return = d),
                (D = D.sibling);
          return (d.subtreeFlags |= C), (d.childLanes = b), p;
        }
        function nd(d, p, b) {
          var C = p.pendingProps;
          switch ((jh(p), p.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return fr(p), null;
            case 1:
              return Wn(p.type) && cn(), fr(p), null;
            case 3:
              return (
                (C = p.stateNode),
                Ql(),
                wt(bn),
                wt(zt),
                nl(),
                C.pendingContext &&
                  ((C.context = C.pendingContext), (C.pendingContext = null)),
                (d === null || d.child === null) &&
                  (Zu(p)
                    ? Lr(p)
                    : d === null ||
                      (d.memoizedState.isDehydrated && (p.flags & 256) === 0) ||
                      ((p.flags |= 1024),
                      Eo !== null && (hr(Eo), (Eo = null)))),
                al(d, p),
                fr(p),
                null
              );
            case 5:
              Yh(p), (b = jo(tl.current));
              var D = p.type;
              if (d !== null && p.stateNode != null)
                ed(d, p, D, C, b),
                  d.ref !== p.ref && ((p.flags |= 512), (p.flags |= 2097152));
              else {
                if (!C) {
                  if (p.stateNode === null) throw Error(s(166));
                  return fr(p), null;
                }
                if (((d = jo(zi.current)), Zu(p))) {
                  if (!we) throw Error(s(175));
                  (d = Vl(p.stateNode, p.type, p.memoizedProps, b, d, p, !Yl)),
                    (p.updateQueue = d),
                    d !== null && Lr(p);
                } else {
                  var z = V(D, C, b, d, p);
                  lo(z, p, !1, !1),
                    (p.stateNode = z),
                    ae(z, D, C, b, d) && Lr(p);
                }
                p.ref !== null && ((p.flags |= 512), (p.flags |= 2097152));
              }
              return fr(p), null;
            case 6:
              if (d && p.stateNode != null) td(d, p, d.memoizedProps, C);
              else {
                if (typeof C != "string" && p.stateNode === null)
                  throw Error(s(166));
                if (((d = jo(tl.current)), (b = jo(zi.current)), Zu(p))) {
                  if (!we) throw Error(s(176));
                  if (
                    ((d = p.stateNode),
                    (C = p.memoizedProps),
                    (b = no(d, C, p, !Yl)) && ((D = wi), D !== null))
                  )
                    switch (((z = (D.mode & 1) !== 0), D.tag)) {
                      case 3:
                        vt(D.stateNode.containerInfo, d, C, z);
                        break;
                      case 5:
                        Et(D.type, D.memoizedProps, D.stateNode, d, C, z);
                    }
                  b && Lr(p);
                } else p.stateNode = de(C, d, b, p);
              }
              return fr(p), null;
            case 13:
              if (
                (wt(tr),
                (C = p.memoizedState),
                qn &&
                  si !== null &&
                  (p.mode & 1) !== 0 &&
                  (p.flags & 128) === 0)
              ) {
                for (d = si; d; ) d = Ar(d);
                return ql(), (p.flags |= 98560), p;
              }
              if (C !== null && C.dehydrated !== null) {
                if (((C = Zu(p)), d === null)) {
                  if (!C) throw Error(s(318));
                  if (!we) throw Error(s(344));
                  if (
                    ((d = p.memoizedState),
                    (d = d !== null ? d.dehydrated : null),
                    !d)
                  )
                    throw Error(s(317));
                  Gl(d, p);
                } else
                  ql(),
                    (p.flags & 128) === 0 && (p.memoizedState = null),
                    (p.flags |= 4);
                return fr(p), null;
              }
              return (
                Eo !== null && (hr(Eo), (Eo = null)),
                (p.flags & 128) !== 0
                  ? ((p.lanes = b), p)
                  : ((C = C !== null),
                    (b = !1),
                    d === null ? Zu(p) : (b = d.memoizedState !== null),
                    C &&
                      !b &&
                      ((p.child.flags |= 8192),
                      (p.mode & 1) !== 0 &&
                        (d === null || (tr.current & 1) !== 0
                          ? Sr === 0 && (Sr = 3)
                          : mc())),
                    p.updateQueue !== null && (p.flags |= 4),
                    fr(p),
                    null)
              );
            case 4:
              return (
                Ql(),
                al(d, p),
                d === null && Ne(p.stateNode.containerInfo),
                fr(p),
                null
              );
            case 10:
              return _r(p.type._context), fr(p), null;
            case 17:
              return Wn(p.type) && cn(), fr(p), null;
            case 19:
              if ((wt(tr), (D = p.memoizedState), D === null))
                return fr(p), null;
              if (((C = (p.flags & 128) !== 0), (z = D.rendering), z === null))
                if (C) Vs(D, !1);
                else {
                  if (Sr !== 0 || (d !== null && (d.flags & 128) !== 0))
                    for (d = p.child; d !== null; ) {
                      if (((z = Vf(d)), z !== null)) {
                        for (
                          p.flags |= 128,
                            Vs(D, !1),
                            d = z.updateQueue,
                            d !== null && ((p.updateQueue = d), (p.flags |= 4)),
                            p.subtreeFlags = 0,
                            d = b,
                            C = p.child;
                          C !== null;

                        )
                          (b = C),
                            (D = d),
                            (b.flags &= 14680066),
                            (z = b.alternate),
                            z === null
                              ? ((b.childLanes = 0),
                                (b.lanes = D),
                                (b.child = null),
                                (b.subtreeFlags = 0),
                                (b.memoizedProps = null),
                                (b.memoizedState = null),
                                (b.updateQueue = null),
                                (b.dependencies = null),
                                (b.stateNode = null))
                              : ((b.childLanes = z.childLanes),
                                (b.lanes = z.lanes),
                                (b.child = z.child),
                                (b.subtreeFlags = 0),
                                (b.deletions = null),
                                (b.memoizedProps = z.memoizedProps),
                                (b.memoizedState = z.memoizedState),
                                (b.updateQueue = z.updateQueue),
                                (b.type = z.type),
                                (D = z.dependencies),
                                (b.dependencies =
                                  D === null
                                    ? null
                                    : {
                                        lanes: D.lanes,
                                        firstContext: D.firstContext,
                                      })),
                            (C = C.sibling);
                        return dt(tr, (tr.current & 1) | 2), p.child;
                      }
                      d = d.sibling;
                    }
                  D.tail !== null &&
                    Yn() > Ca &&
                    ((p.flags |= 128),
                    (C = !0),
                    Vs(D, !1),
                    (p.lanes = 4194304));
                }
              else {
                if (!C)
                  if (((d = Vf(z)), d !== null)) {
                    if (
                      ((p.flags |= 128),
                      (C = !0),
                      (d = d.updateQueue),
                      d !== null && ((p.updateQueue = d), (p.flags |= 4)),
                      Vs(D, !0),
                      D.tail === null &&
                        D.tailMode === "hidden" &&
                        !z.alternate &&
                        !qn)
                    )
                      return fr(p), null;
                  } else
                    2 * Yn() - D.renderingStartTime > Ca &&
                      b !== 1073741824 &&
                      ((p.flags |= 128),
                      (C = !0),
                      Vs(D, !1),
                      (p.lanes = 4194304));
                D.isBackwards
                  ? ((z.sibling = p.child), (p.child = z))
                  : ((d = D.last),
                    d !== null ? (d.sibling = z) : (p.child = z),
                    (D.last = z));
              }
              return D.tail !== null
                ? ((p = D.tail),
                  (D.rendering = p),
                  (D.tail = p.sibling),
                  (D.renderingStartTime = Yn()),
                  (p.sibling = null),
                  (d = tr.current),
                  dt(tr, C ? (d & 1) | 2 : d & 1),
                  p)
                : (fr(p), null);
            case 22:
            case 23:
              return (
                hp(),
                (C = p.memoizedState !== null),
                d !== null &&
                  (d.memoizedState !== null) !== C &&
                  (p.flags |= 8192),
                C && (p.mode & 1) !== 0
                  ? (Ci & 1073741824) !== 0 &&
                    (fr(p), xe && p.subtreeFlags & 6 && (p.flags |= 8192))
                  : fr(p),
                null
              );
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(s(156, p.tag));
        }
        var op = l.ReactCurrentOwner,
          Yr = !1;
        function ir(d, p, b, C) {
          p.child = d === null ? yg(p, null, b, C) : Bs(p, d.child, b, C);
        }
        function zn(d, p, b, C, D) {
          b = b.render;
          var z = p.ref;
          return (
            cr(p, D),
            (C = eu(d, p, b, C, z, D)),
            (b = wa()),
            d !== null && !Yr
              ? ((p.updateQueue = d.updateQueue),
                (p.flags &= -2053),
                (d.lanes &= ~D),
                Hi(d, p, D))
              : (qn && b && Wh(p), (p.flags |= 1), ir(d, p, C, D), p.child)
          );
        }
        function Nn(d, p, b, C, D) {
          if (d === null) {
            var z = b.type;
            return typeof z == "function" &&
              !xc(z) &&
              z.defaultProps === void 0 &&
              b.compare === null &&
              b.defaultProps === void 0
              ? ((p.tag = 15), (p.type = z), Gs(d, p, z, C, D))
              : ((d = _c(b.type, null, C, p, p.mode, D)),
                (d.ref = p.ref),
                (d.return = p),
                (p.child = d));
          }
          if (((z = d.child), (d.lanes & D) === 0)) {
            var ce = z.memoizedProps;
            if (
              ((b = b.compare),
              (b = b !== null ? b : Fi),
              b(ce, C) && d.ref === p.ref)
            )
              return Hi(d, p, D);
          }
          return (
            (p.flags |= 1),
            (d = Ks(z, C)),
            (d.ref = p.ref),
            (d.return = p),
            (p.child = d)
          );
        }
        function Gs(d, p, b, C, D) {
          if (d !== null && Fi(d.memoizedProps, C) && d.ref === p.ref)
            if (((Yr = !1), (d.lanes & D) !== 0))
              (d.flags & 131072) !== 0 && (Yr = !0);
            else return (p.lanes = d.lanes), Hi(d, p, D);
          return Ws(d, p, b, C, D);
        }
        function ai(d, p, b) {
          var C = p.pendingProps,
            D = C.children,
            z = d !== null ? d.memoizedState : null;
          if (C.mode === "hidden")
            if ((p.mode & 1) === 0)
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                dt(qs, Ci),
                (Ci |= b);
            else if ((b & 1073741824) !== 0)
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                (C = z !== null ? z.baseLanes : b),
                dt(qs, Ci),
                (Ci |= C);
            else
              return (
                (d = z !== null ? z.baseLanes | b : b),
                (p.lanes = p.childLanes = 1073741824),
                (p.memoizedState = { baseLanes: d, cachePool: null }),
                (p.updateQueue = null),
                dt(qs, Ci),
                (Ci |= d),
                null
              );
          else
            z !== null
              ? ((C = z.baseLanes | b), (p.memoizedState = null))
              : (C = b),
              dt(qs, Ci),
              (Ci |= C);
          return ir(d, p, D, b), p.child;
        }
        function bi(d, p) {
          var b = p.ref;
          ((d === null && b !== null) || (d !== null && d.ref !== b)) &&
            ((p.flags |= 512), (p.flags |= 2097152));
        }
        function Ws(d, p, b, C, D) {
          var z = Wn(b) ? ii : zt.current;
          return (
            (z = An(p, z)),
            cr(p, D),
            (b = eu(d, p, b, C, z, D)),
            (C = wa()),
            d !== null && !Yr
              ? ((p.updateQueue = d.updateQueue),
                (p.flags &= -2053),
                (d.lanes &= ~D),
                Hi(d, p, D))
              : (qn && C && Wh(p), (p.flags |= 1), ir(d, p, b, D), p.child)
          );
        }
        function ll(d, p, b, C, D) {
          if (Wn(b)) {
            var z = !0;
            ur(p);
          } else z = !1;
          if ((cr(p, D), p.stateNode === null))
            d !== null &&
              ((d.alternate = null), (p.alternate = null), (p.flags |= 2)),
              hg(p, b, C),
              Gh(p, b, C, D),
              (C = !0);
          else if (d === null) {
            var ce = p.stateNode,
              Me = p.memoizedProps;
            ce.props = Me;
            var Qe = ce.context,
              ct = b.contextType;
            typeof ct == "object" && ct !== null
              ? (ct = er(ct))
              : ((ct = Wn(b) ? ii : zt.current), (ct = An(p, ct)));
            var Tt = b.getDerivedStateFromProps,
              Kt =
                typeof Tt == "function" ||
                typeof ce.getSnapshotBeforeUpdate == "function";
            Kt ||
              (typeof ce.UNSAFE_componentWillReceiveProps != "function" &&
                typeof ce.componentWillReceiveProps != "function") ||
              ((Me !== C || Qe !== ct) && pg(p, ce, C, ct)),
              (bo = !1);
            var Bt = p.memoizedState;
            (ce.state = Bt),
              Nf(p, C, ce, D),
              (Qe = p.memoizedState),
              Me !== C || Bt !== Qe || bn.current || bo
                ? (typeof Tt == "function" &&
                    (Hh(p, b, Tt, C), (Qe = p.memoizedState)),
                  (Me = bo || Vh(p, b, Me, C, Bt, Qe, ct))
                    ? (Kt ||
                        (typeof ce.UNSAFE_componentWillMount != "function" &&
                          typeof ce.componentWillMount != "function") ||
                        (typeof ce.componentWillMount == "function" &&
                          ce.componentWillMount(),
                        typeof ce.UNSAFE_componentWillMount == "function" &&
                          ce.UNSAFE_componentWillMount()),
                      typeof ce.componentDidMount == "function" &&
                        (p.flags |= 4194308))
                    : (typeof ce.componentDidMount == "function" &&
                        (p.flags |= 4194308),
                      (p.memoizedProps = C),
                      (p.memoizedState = Qe)),
                  (ce.props = C),
                  (ce.state = Qe),
                  (ce.context = ct),
                  (C = Me))
                : (typeof ce.componentDidMount == "function" &&
                    (p.flags |= 4194308),
                  (C = !1));
          } else {
            (ce = p.stateNode),
              zh(d, p),
              (Me = p.memoizedProps),
              (ct = p.type === p.elementType ? Me : Gr(p.type, Me)),
              (ce.props = ct),
              (Kt = p.pendingProps),
              (Bt = ce.context),
              (Qe = b.contextType),
              typeof Qe == "object" && Qe !== null
                ? (Qe = er(Qe))
                : ((Qe = Wn(b) ? ii : zt.current), (Qe = An(p, Qe)));
            var On = b.getDerivedStateFromProps;
            (Tt =
              typeof On == "function" ||
              typeof ce.getSnapshotBeforeUpdate == "function") ||
              (typeof ce.UNSAFE_componentWillReceiveProps != "function" &&
                typeof ce.componentWillReceiveProps != "function") ||
              ((Me !== Kt || Bt !== Qe) && pg(p, ce, C, Qe)),
              (bo = !1),
              (Bt = p.memoizedState),
              (ce.state = Bt),
              Nf(p, C, ce, D);
            var bt = p.memoizedState;
            Me !== Kt || Bt !== bt || bn.current || bo
              ? (typeof On == "function" &&
                  (Hh(p, b, On, C), (bt = p.memoizedState)),
                (ct = bo || Vh(p, b, ct, C, Bt, bt, Qe) || !1)
                  ? (Tt ||
                      (typeof ce.UNSAFE_componentWillUpdate != "function" &&
                        typeof ce.componentWillUpdate != "function") ||
                      (typeof ce.componentWillUpdate == "function" &&
                        ce.componentWillUpdate(C, bt, Qe),
                      typeof ce.UNSAFE_componentWillUpdate == "function" &&
                        ce.UNSAFE_componentWillUpdate(C, bt, Qe)),
                    typeof ce.componentDidUpdate == "function" &&
                      (p.flags |= 4),
                    typeof ce.getSnapshotBeforeUpdate == "function" &&
                      (p.flags |= 1024))
                  : (typeof ce.componentDidUpdate != "function" ||
                      (Me === d.memoizedProps && Bt === d.memoizedState) ||
                      (p.flags |= 4),
                    typeof ce.getSnapshotBeforeUpdate != "function" ||
                      (Me === d.memoizedProps && Bt === d.memoizedState) ||
                      (p.flags |= 1024),
                    (p.memoizedProps = C),
                    (p.memoizedState = bt)),
                (ce.props = C),
                (ce.state = bt),
                (ce.context = Qe),
                (C = ct))
              : (typeof ce.componentDidUpdate != "function" ||
                  (Me === d.memoizedProps && Bt === d.memoizedState) ||
                  (p.flags |= 4),
                typeof ce.getSnapshotBeforeUpdate != "function" ||
                  (Me === d.memoizedProps && Bt === d.memoizedState) ||
                  (p.flags |= 1024),
                (C = !1));
          }
          return mi(d, p, b, C, z, D);
        }
        function mi(d, p, b, C, D, z) {
          bi(d, p);
          var ce = (p.flags & 128) !== 0;
          if (!C && !ce) return D && Rr(p, b, !1), Hi(d, p, z);
          (C = p.stateNode), (op.current = p);
          var Me =
            ce && typeof b.getDerivedStateFromError != "function"
              ? null
              : C.render();
          return (
            (p.flags |= 1),
            d !== null && ce
              ? ((p.child = Bs(p, d.child, null, z)),
                (p.child = Bs(p, null, Me, z)))
              : ir(d, p, Me, z),
            (p.memoizedState = C.state),
            D && Rr(p, b, !0),
            p.child
          );
        }
        function ac(d) {
          var p = d.stateNode;
          p.pendingContext
            ? zr(d, p.pendingContext, p.pendingContext !== p.context)
            : p.context && zr(d, p.context, !1),
            Hf(d, p.containerInfo);
        }
        function sp(d, p, b, C, D) {
          return ql(), zf(D), (p.flags |= 256), ir(d, p, b, C), p.child;
        }
        var lc = { dehydrated: null, treeContext: null, retryLane: 0 };
        function ul(d) {
          return { baseLanes: d, cachePool: null };
        }
        function ap(d, p, b) {
          var C = p.pendingProps,
            D = tr.current,
            z = !1,
            ce = (p.flags & 128) !== 0,
            Me;
          if (
            ((Me = ce) ||
              (Me =
                d !== null && d.memoizedState === null ? !1 : (D & 2) !== 0),
            Me
              ? ((z = !0), (p.flags &= -129))
              : (d === null || d.memoizedState !== null) && (D |= 1),
            dt(tr, D & 1),
            d === null)
          )
            return (
              _a(p),
              (d = p.memoizedState),
              d !== null && ((d = d.dehydrated), d !== null)
                ? ((p.mode & 1) === 0
                    ? (p.lanes = 1)
                    : yr(d)
                    ? (p.lanes = 8)
                    : (p.lanes = 1073741824),
                  null)
                : ((D = C.children),
                  (d = C.fallback),
                  z
                    ? ((C = p.mode),
                      (z = p.child),
                      (D = { mode: "hidden", children: D }),
                      (C & 1) === 0 && z !== null
                        ? ((z.childLanes = 0), (z.pendingProps = D))
                        : (z = vu(D, C, 0, null)),
                      (d = ka(d, C, b, null)),
                      (z.return = p),
                      (d.return = p),
                      (z.sibling = d),
                      (p.child = z),
                      (p.child.memoizedState = ul(b)),
                      (p.memoizedState = lc),
                      d)
                    : Yo(p, D))
            );
          if (((D = d.memoizedState), D !== null)) {
            if (((Me = D.dehydrated), Me !== null)) {
              if (ce)
                return p.flags & 256
                  ? ((p.flags &= -257), cc(d, p, b, Error(s(422))))
                  : p.memoizedState !== null
                  ? ((p.child = d.child), (p.flags |= 128), null)
                  : ((z = C.fallback),
                    (D = p.mode),
                    (C = vu(
                      { mode: "visible", children: C.children },
                      D,
                      0,
                      null
                    )),
                    (z = ka(z, D, b, null)),
                    (z.flags |= 2),
                    (C.return = p),
                    (z.return = p),
                    (C.sibling = z),
                    (p.child = C),
                    (p.mode & 1) !== 0 && Bs(p, d.child, null, b),
                    (p.child.memoizedState = ul(b)),
                    (p.memoizedState = lc),
                    z);
              if ((p.mode & 1) === 0) p = cc(d, p, b, null);
              else if (yr(Me)) p = cc(d, p, b, Error(s(419)));
              else if (((C = (b & d.childLanes) !== 0), Yr || C)) {
                if (((C = rr), C !== null)) {
                  switch (b & -b) {
                    case 4:
                      z = 2;
                      break;
                    case 16:
                      z = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      z = 32;
                      break;
                    case 536870912:
                      z = 268435456;
                      break;
                    default:
                      z = 0;
                  }
                  (C = (z & (C.suspendedLanes | b)) !== 0 ? 0 : z),
                    C !== 0 &&
                      C !== D.retryLane &&
                      ((D.retryLane = C), Gi(d, C, -1));
                }
                mc(), (p = cc(d, p, b, Error(s(421))));
              } else
                Ui(Me)
                  ? ((p.flags |= 128),
                    (p.child = d.child),
                    (p = Ag.bind(null, d)),
                    Fr(Me, p),
                    (p = null))
                  : ((b = D.treeContext),
                    we &&
                      ((si = yo(Me)),
                      (wi = p),
                      (qn = !0),
                      (Eo = null),
                      (Yl = !1),
                      b !== null &&
                        ((Mo[oo++] = Us),
                        (Mo[oo++] = Fs),
                        (Mo[oo++] = Ja),
                        (Us = b.id),
                        (Fs = b.overflow),
                        (Ja = p))),
                    (p = Yo(p, p.pendingProps.children)),
                    (p.flags |= 4096));
              return p;
            }
            return z
              ? ((C = rd(d, p, C.children, C.fallback, b)),
                (z = p.child),
                (D = d.child.memoizedState),
                (z.memoizedState =
                  D === null
                    ? ul(b)
                    : { baseLanes: D.baseLanes | b, cachePool: null }),
                (z.childLanes = d.childLanes & ~b),
                (p.memoizedState = lc),
                C)
              : ((b = uc(d, p, C.children, b)), (p.memoizedState = null), b);
          }
          return z
            ? ((C = rd(d, p, C.children, C.fallback, b)),
              (z = p.child),
              (D = d.child.memoizedState),
              (z.memoizedState =
                D === null
                  ? ul(b)
                  : { baseLanes: D.baseLanes | b, cachePool: null }),
              (z.childLanes = d.childLanes & ~b),
              (p.memoizedState = lc),
              C)
            : ((b = uc(d, p, C.children, b)), (p.memoizedState = null), b);
        }
        function Yo(d, p) {
          return (
            (p = vu({ mode: "visible", children: p }, d.mode, 0, null)),
            (p.return = d),
            (d.child = p)
          );
        }
        function uc(d, p, b, C) {
          var D = d.child;
          return (
            (d = D.sibling),
            (b = Ks(D, { mode: "visible", children: b })),
            (p.mode & 1) === 0 && (b.lanes = C),
            (b.return = p),
            (b.sibling = null),
            d !== null &&
              ((C = p.deletions),
              C === null ? ((p.deletions = [d]), (p.flags |= 16)) : C.push(d)),
            (p.child = b)
          );
        }
        function rd(d, p, b, C, D) {
          var z = p.mode;
          d = d.child;
          var ce = d.sibling,
            Me = { mode: "hidden", children: b };
          return (
            (z & 1) === 0 && p.child !== d
              ? ((b = p.child),
                (b.childLanes = 0),
                (b.pendingProps = Me),
                (p.deletions = null))
              : ((b = Ks(d, Me)), (b.subtreeFlags = d.subtreeFlags & 14680064)),
            ce !== null
              ? (C = Ks(ce, C))
              : ((C = ka(C, z, D, null)), (C.flags |= 2)),
            (C.return = p),
            (b.return = p),
            (b.sibling = C),
            (p.child = b),
            C
          );
        }
        function cc(d, p, b, C) {
          return (
            C !== null && zf(C),
            Bs(p, d.child, null, b),
            (d = Yo(p, p.pendingProps.children)),
            (d.flags |= 2),
            (p.memoizedState = null),
            d
          );
        }
        function Mg(d, p, b) {
          d.lanes |= p;
          var C = d.alternate;
          C !== null && (C.lanes |= p), Ir(d.return, p, b);
        }
        function ms(d, p, b, C, D) {
          var z = d.memoizedState;
          z === null
            ? (d.memoizedState = {
                isBackwards: p,
                rendering: null,
                renderingStartTime: 0,
                last: C,
                tail: b,
                tailMode: D,
              })
            : ((z.isBackwards = p),
              (z.rendering = null),
              (z.renderingStartTime = 0),
              (z.last = C),
              (z.tail = b),
              (z.tailMode = D));
        }
        function cl(d, p, b) {
          var C = p.pendingProps,
            D = C.revealOrder,
            z = C.tail;
          if ((ir(d, p, C.children, b), (C = tr.current), (C & 2) !== 0))
            (C = (C & 1) | 2), (p.flags |= 128);
          else {
            if (d !== null && (d.flags & 128) !== 0)
              e: for (d = p.child; d !== null; ) {
                if (d.tag === 13) d.memoizedState !== null && Mg(d, b, p);
                else if (d.tag === 19) Mg(d, b, p);
                else if (d.child !== null) {
                  (d.child.return = d), (d = d.child);
                  continue;
                }
                if (d === p) break e;
                for (; d.sibling === null; ) {
                  if (d.return === null || d.return === p) break e;
                  d = d.return;
                }
                (d.sibling.return = d.return), (d = d.sibling);
              }
            C &= 1;
          }
          if ((dt(tr, C), (p.mode & 1) === 0)) p.memoizedState = null;
          else
            switch (D) {
              case "forwards":
                for (b = p.child, D = null; b !== null; )
                  (d = b.alternate),
                    d !== null && Vf(d) === null && (D = b),
                    (b = b.sibling);
                (b = D),
                  b === null
                    ? ((D = p.child), (p.child = null))
                    : ((D = b.sibling), (b.sibling = null)),
                  ms(p, !1, D, b, z);
                break;
              case "backwards":
                for (b = null, D = p.child, p.child = null; D !== null; ) {
                  if (((d = D.alternate), d !== null && Vf(d) === null)) {
                    p.child = D;
                    break;
                  }
                  (d = D.sibling), (D.sibling = b), (b = D), (D = d);
                }
                ms(p, !0, b, null, z);
                break;
              case "together":
                ms(p, !1, null, null, void 0);
                break;
              default:
                p.memoizedState = null;
            }
          return p.child;
        }
        function Hi(d, p, b) {
          if (
            (d !== null && (p.dependencies = d.dependencies),
            (hl |= p.lanes),
            (b & p.childLanes) === 0)
          )
            return null;
          if (d !== null && p.child !== d.child) throw Error(s(153));
          if (p.child !== null) {
            for (
              d = p.child, b = Ks(d, d.pendingProps), p.child = b, b.return = p;
              d.sibling !== null;

            )
              (d = d.sibling),
                (b = b.sibling = Ks(d, d.pendingProps)),
                (b.return = p);
            b.sibling = null;
          }
          return p.child;
        }
        function id(d, p, b) {
          switch (p.tag) {
            case 3:
              ac(p), ql();
              break;
            case 5:
              xg(p);
              break;
            case 1:
              Wn(p.type) && ur(p);
              break;
            case 4:
              Hf(p, p.stateNode.containerInfo);
              break;
            case 10:
              Ns(p, p.type._context, p.memoizedProps.value);
              break;
            case 13:
              var C = p.memoizedState;
              if (C !== null)
                return C.dehydrated !== null
                  ? (dt(tr, tr.current & 1), (p.flags |= 128), null)
                  : (b & p.child.childLanes) !== 0
                  ? ap(d, p, b)
                  : (dt(tr, tr.current & 1),
                    (d = Hi(d, p, b)),
                    d !== null ? d.sibling : null);
              dt(tr, tr.current & 1);
              break;
            case 19:
              if (((C = (b & p.childLanes) !== 0), (d.flags & 128) !== 0)) {
                if (C) return cl(d, p, b);
                p.flags |= 128;
              }
              var D = p.memoizedState;
              if (
                (D !== null &&
                  ((D.rendering = null),
                  (D.tail = null),
                  (D.lastEffect = null)),
                dt(tr, tr.current),
                C)
              )
                break;
              return null;
            case 22:
            case 23:
              return (p.lanes = 0), ai(d, p, b);
          }
          return Hi(d, p, b);
        }
        function od(d, p) {
          switch ((jh(p), p.tag)) {
            case 1:
              return (
                Wn(p.type) && cn(),
                (d = p.flags),
                d & 65536 ? ((p.flags = (d & -65537) | 128), p) : null
              );
            case 3:
              return (
                Ql(),
                wt(bn),
                wt(zt),
                nl(),
                (d = p.flags),
                (d & 65536) !== 0 && (d & 128) === 0
                  ? ((p.flags = (d & -65537) | 128), p)
                  : null
              );
            case 5:
              return Yh(p), null;
            case 13:
              if (
                (wt(tr),
                (d = p.memoizedState),
                d !== null && d.dehydrated !== null)
              ) {
                if (p.alternate === null) throw Error(s(340));
                ql();
              }
              return (
                (d = p.flags),
                d & 65536 ? ((p.flags = (d & -65537) | 128), p) : null
              );
            case 19:
              return wt(tr), null;
            case 4:
              return Ql(), null;
            case 10:
              return _r(p.type._context), null;
            case 22:
            case 23:
              return hp(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Mi = !1,
          qr = !1,
          fl = typeof WeakSet == "function" ? WeakSet : Set,
          pt = null;
        function To(d, p) {
          var b = d.ref;
          if (b !== null)
            if (typeof b == "function")
              try {
                b(null);
              } catch (C) {
                Ri(d, p, C);
              }
            else b.current = null;
        }
        function js(d, p, b) {
          try {
            b();
          } catch (C) {
            Ri(d, p, C);
          }
        }
        var lp = !1;
        function up(d, p) {
          for (te(d.containerInfo), pt = p; pt !== null; )
            if (
              ((d = pt),
              (p = d.child),
              (d.subtreeFlags & 1028) !== 0 && p !== null)
            )
              (p.return = d), (pt = p);
            else
              for (; pt !== null; ) {
                d = pt;
                try {
                  var b = d.alternate;
                  if ((d.flags & 1024) !== 0)
                    switch (d.tag) {
                      case 0:
                      case 11:
                      case 15:
                        break;
                      case 1:
                        if (b !== null) {
                          var C = b.memoizedProps,
                            D = b.memoizedState,
                            z = d.stateNode,
                            ce = z.getSnapshotBeforeUpdate(
                              d.elementType === d.type ? C : Gr(d.type, C),
                              D
                            );
                          z.__reactInternalSnapshotBeforeUpdate = ce;
                        }
                        break;
                      case 3:
                        xe && it(d.stateNode.containerInfo);
                        break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                        break;
                      default:
                        throw Error(s(163));
                    }
                } catch (Me) {
                  Ri(d, d.return, Me);
                }
                if (((p = d.sibling), p !== null)) {
                  (p.return = d.return), (pt = p);
                  break;
                }
                pt = d.return;
              }
          return (b = lp), (lp = !1), b;
        }
        function $s(d, p, b) {
          var C = p.updateQueue;
          if (((C = C !== null ? C.lastEffect : null), C !== null)) {
            var D = (C = C.next);
            do {
              if ((D.tag & d) === d) {
                var z = D.destroy;
                (D.destroy = void 0), z !== void 0 && js(p, b, z);
              }
              D = D.next;
            } while (D !== C);
          }
        }
        function li(d, p) {
          if (
            ((p = p.updateQueue),
            (p = p !== null ? p.lastEffect : null),
            p !== null)
          ) {
            var b = (p = p.next);
            do {
              if ((b.tag & d) === d) {
                var C = b.create;
                b.destroy = C();
              }
              b = b.next;
            } while (b !== p);
          }
        }
        function Ei(d) {
          var p = d.ref;
          if (p !== null) {
            var b = d.stateNode;
            switch (d.tag) {
              case 5:
                d = X(b);
                break;
              default:
                d = b;
            }
            typeof p == "function" ? p(d) : (p.current = d);
          }
        }
        function jn(d, p, b) {
          if (io && typeof io.onCommitFiberUnmount == "function")
            try {
              io.onCommitFiberUnmount(pa, p);
            } catch {}
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                ((d = p.updateQueue),
                d !== null && ((d = d.lastEffect), d !== null))
              ) {
                var C = (d = d.next);
                do {
                  var D = C,
                    z = D.destroy;
                  (D = D.tag),
                    z !== void 0 &&
                      ((D & 2) !== 0 || (D & 4) !== 0) &&
                      js(p, b, z),
                    (C = C.next);
                } while (C !== d);
              }
              break;
            case 1:
              if (
                (To(p, b),
                (d = p.stateNode),
                typeof d.componentWillUnmount == "function")
              )
                try {
                  (d.props = p.memoizedProps),
                    (d.state = p.memoizedState),
                    d.componentWillUnmount();
                } catch (ce) {
                  Ri(p, b, ce);
                }
              break;
            case 5:
              To(p, b);
              break;
            case 4:
              xe
                ? dp(d, p, b)
                : j &&
                  j &&
                  ((p = p.stateNode.containerInfo), (b = gt(p)), ht(p, b));
          }
        }
        function Co(d, p, b) {
          for (var C = p; ; )
            if ((jn(d, C, b), C.child === null || (xe && C.tag === 4))) {
              if (C === p) break;
              for (; C.sibling === null; ) {
                if (C.return === null || C.return === p) return;
                C = C.return;
              }
              (C.sibling.return = C.return), (C = C.sibling);
            } else (C.child.return = C), (C = C.child);
        }
        function cp(d) {
          var p = d.alternate;
          p !== null && ((d.alternate = null), cp(p)),
            (d.child = null),
            (d.deletions = null),
            (d.sibling = null),
            d.tag === 5 && ((p = d.stateNode), p !== null && rt(p)),
            (d.stateNode = null),
            (d.return = null),
            (d.dependencies = null),
            (d.memoizedProps = null),
            (d.memoizedState = null),
            (d.pendingProps = null),
            (d.stateNode = null),
            (d.updateQueue = null);
        }
        function fp(d) {
          return d.tag === 5 || d.tag === 3 || d.tag === 4;
        }
        function sd(d) {
          e: for (;;) {
            for (; d.sibling === null; ) {
              if (d.return === null || fp(d.return)) return null;
              d = d.return;
            }
            for (
              d.sibling.return = d.return, d = d.sibling;
              d.tag !== 5 && d.tag !== 6 && d.tag !== 18;

            ) {
              if (d.flags & 2 || d.child === null || d.tag === 4) continue e;
              (d.child.return = d), (d = d.child);
            }
            if (!(d.flags & 2)) return d.stateNode;
          }
        }
        function ad(d) {
          if (xe) {
            e: {
              for (var p = d.return; p !== null; ) {
                if (fp(p)) break e;
                p = p.return;
              }
              throw Error(s(160));
            }
            var b = p;
            switch (b.tag) {
              case 5:
                (p = b.stateNode),
                  b.flags & 32 && (Je(p), (b.flags &= -33)),
                  (b = sd(d)),
                  su(d, b, p);
                break;
              case 3:
              case 4:
                (p = b.stateNode.containerInfo), (b = sd(d)), ld(d, b, p);
                break;
              default:
                throw Error(s(161));
            }
          }
        }
        function ld(d, p, b) {
          var C = d.tag;
          if (C === 5 || C === 6) (d = d.stateNode), p ? qe(b, d, p) : We(b, d);
          else if (C !== 4 && ((d = d.child), d !== null))
            for (ld(d, p, b), d = d.sibling; d !== null; )
              ld(d, p, b), (d = d.sibling);
        }
        function su(d, p, b) {
          var C = d.tag;
          if (C === 5 || C === 6) (d = d.stateNode), p ? $e(b, d, p) : Be(b, d);
          else if (C !== 4 && ((d = d.child), d !== null))
            for (su(d, p, b), d = d.sibling; d !== null; )
              su(d, p, b), (d = d.sibling);
        }
        function dp(d, p, b) {
          for (var C = p, D = !1, z, ce; ; ) {
            if (!D) {
              D = C.return;
              e: for (;;) {
                if (D === null) throw Error(s(160));
                switch (((z = D.stateNode), D.tag)) {
                  case 5:
                    ce = !1;
                    break e;
                  case 3:
                    (z = z.containerInfo), (ce = !0);
                    break e;
                  case 4:
                    (z = z.containerInfo), (ce = !0);
                    break e;
                }
                D = D.return;
              }
              D = !0;
            }
            if (C.tag === 5 || C.tag === 6)
              Co(d, C, b), ce ? he(z, C.stateNode) : et(z, C.stateNode);
            else if (C.tag === 18) ce ? Le(z, C.stateNode) : Ge(z, C.stateNode);
            else if (C.tag === 4) {
              if (C.child !== null) {
                (z = C.stateNode.containerInfo),
                  (ce = !0),
                  (C.child.return = C),
                  (C = C.child);
                continue;
              }
            } else if ((jn(d, C, b), C.child !== null)) {
              (C.child.return = C), (C = C.child);
              continue;
            }
            if (C === p) break;
            for (; C.sibling === null; ) {
              if (C.return === null || C.return === p) return;
              (C = C.return), C.tag === 4 && (D = !1);
            }
            (C.sibling.return = C.return), (C = C.sibling);
          }
        }
        function Ea(d, p) {
          if (xe) {
            switch (p.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                $s(3, p, p.return), li(3, p), $s(5, p, p.return);
                return;
              case 1:
                return;
              case 5:
                var b = p.stateNode;
                if (b != null) {
                  var C = p.memoizedProps;
                  d = d !== null ? d.memoizedProps : C;
                  var D = p.type,
                    z = p.updateQueue;
                  (p.updateQueue = null), z !== null && yt(b, z, D, d, C, p);
                }
                return;
              case 6:
                if (p.stateNode === null) throw Error(s(162));
                (b = p.memoizedProps),
                  Ye(p.stateNode, d !== null ? d.memoizedProps : b, b);
                return;
              case 3:
                we &&
                  d !== null &&
                  d.memoizedState.isDehydrated &&
                  Ce(p.stateNode.containerInfo);
                return;
              case 12:
                return;
              case 13:
                au(p);
                return;
              case 19:
                au(p);
                return;
              case 17:
                return;
            }
            throw Error(s(163));
          }
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              $s(3, p, p.return), li(3, p), $s(5, p, p.return);
              return;
            case 12:
              return;
            case 13:
              au(p);
              return;
            case 19:
              au(p);
              return;
            case 3:
              we &&
                d !== null &&
                d.memoizedState.isDehydrated &&
                Ce(p.stateNode.containerInfo);
              break;
            case 22:
            case 23:
              return;
          }
          e: if (j) {
            switch (p.tag) {
              case 1:
              case 5:
              case 6:
                break e;
              case 3:
              case 4:
                (p = p.stateNode), ht(p.containerInfo, p.pendingChildren);
                break e;
            }
            throw Error(s(163));
          }
        }
        function au(d) {
          var p = d.updateQueue;
          if (p !== null) {
            d.updateQueue = null;
            var b = d.stateNode;
            b === null && (b = d.stateNode = new fl()),
              p.forEach(function (C) {
                var D = vc.bind(null, d, C);
                b.has(C) || (b.add(C), C.then(D, D));
              });
          }
        }
        function mx(d, p) {
          for (pt = p; pt !== null; ) {
            p = pt;
            var b = p.deletions;
            if (b !== null)
              for (var C = 0; C < b.length; C++) {
                var D = b[C];
                try {
                  var z = d;
                  xe ? dp(z, D, p) : Co(z, D, p);
                  var ce = D.alternate;
                  ce !== null && (ce.return = null), (D.return = null);
                } catch (It) {
                  Ri(D, p, It);
                }
              }
            if (((b = p.child), (p.subtreeFlags & 12854) !== 0 && b !== null))
              (b.return = p), (pt = b);
            else
              for (; pt !== null; ) {
                p = pt;
                try {
                  var Me = p.flags;
                  if ((Me & 32 && xe && Je(p.stateNode), Me & 512)) {
                    var Qe = p.alternate;
                    if (Qe !== null) {
                      var ct = Qe.ref;
                      ct !== null &&
                        (typeof ct == "function"
                          ? ct(null)
                          : (ct.current = null));
                    }
                  }
                  if (Me & 8192)
                    switch (p.tag) {
                      case 13:
                        if (p.memoizedState !== null) {
                          var Tt = p.alternate;
                          (Tt === null || Tt.memoizedState === null) &&
                            (fd = Yn());
                        }
                        break;
                      case 22:
                        var Kt = p.memoizedState !== null,
                          Bt = p.alternate,
                          On = Bt !== null && Bt.memoizedState !== null;
                        if (((b = p), xe)) {
                          e: if (((C = b), (D = Kt), (z = null), xe))
                            for (var bt = C; ; ) {
                              if (bt.tag === 5) {
                                if (z === null) {
                                  z = bt;
                                  var Mn = bt.stateNode;
                                  D
                                    ? me(Mn)
                                    : Re(bt.stateNode, bt.memoizedProps);
                                }
                              } else if (bt.tag === 6) {
                                if (z === null) {
                                  var fo = bt.stateNode;
                                  D ? Ve(fo) : Ue(fo, bt.memoizedProps);
                                }
                              } else if (
                                ((bt.tag !== 22 && bt.tag !== 23) ||
                                  bt.memoizedState === null ||
                                  bt === C) &&
                                bt.child !== null
                              ) {
                                (bt.child.return = bt), (bt = bt.child);
                                continue;
                              }
                              if (bt === C) break;
                              for (; bt.sibling === null; ) {
                                if (bt.return === null || bt.return === C)
                                  break e;
                                z === bt && (z = null), (bt = bt.return);
                              }
                              z === bt && (z = null),
                                (bt.sibling.return = bt.return),
                                (bt = bt.sibling);
                            }
                        }
                        if (Kt && !On && (b.mode & 1) !== 0) {
                          pt = b;
                          for (var He = b.child; He !== null; ) {
                            for (b = pt = He; pt !== null; ) {
                              C = pt;
                              var Pe = C.child;
                              switch (C.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                  $s(4, C, C.return);
                                  break;
                                case 1:
                                  To(C, C.return);
                                  var Ze = C.stateNode;
                                  if (
                                    typeof Ze.componentWillUnmount == "function"
                                  ) {
                                    var _t = C.return;
                                    try {
                                      (Ze.props = C.memoizedProps),
                                        (Ze.state = C.memoizedState),
                                        Ze.componentWillUnmount();
                                    } catch (It) {
                                      Ri(C, _t, It);
                                    }
                                  }
                                  break;
                                case 5:
                                  To(C, C.return);
                                  break;
                                case 22:
                                  if (C.memoizedState !== null) {
                                    dl(b);
                                    continue;
                                  }
                              }
                              Pe !== null
                                ? ((Pe.return = C), (pt = Pe))
                                : dl(b);
                            }
                            He = He.sibling;
                          }
                        }
                    }
                  switch (Me & 4102) {
                    case 2:
                      ad(p), (p.flags &= -3);
                      break;
                    case 6:
                      ad(p), (p.flags &= -3), Ea(p.alternate, p);
                      break;
                    case 4096:
                      p.flags &= -4097;
                      break;
                    case 4100:
                      (p.flags &= -4097), Ea(p.alternate, p);
                      break;
                    case 4:
                      Ea(p.alternate, p);
                  }
                } catch (It) {
                  Ri(p, p.return, It);
                }
                if (((b = p.sibling), b !== null)) {
                  (b.return = p.return), (pt = b);
                  break;
                }
                pt = p.return;
              }
          }
        }
        function qo(d, p, b) {
          (pt = d), fc(d);
        }
        function fc(d, p, b) {
          for (var C = (d.mode & 1) !== 0; pt !== null; ) {
            var D = pt,
              z = D.child;
            if (D.tag === 22 && C) {
              var ce = D.memoizedState !== null || Mi;
              if (!ce) {
                var Me = D.alternate,
                  Qe = (Me !== null && Me.memoizedState !== null) || qr;
                Me = Mi;
                var ct = qr;
                if (((Mi = ce), (qr = Qe) && !ct))
                  for (pt = D; pt !== null; )
                    (ce = pt),
                      (Qe = ce.child),
                      ce.tag === 22 && ce.memoizedState !== null
                        ? ud(D)
                        : Qe !== null
                        ? ((Qe.return = ce), (pt = Qe))
                        : ud(D);
                for (; z !== null; ) (pt = z), fc(z), (z = z.sibling);
                (pt = D), (Mi = Me), (qr = ct);
              }
              dc(d);
            } else
              (D.subtreeFlags & 8772) !== 0 && z !== null
                ? ((z.return = D), (pt = z))
                : dc(d);
          }
        }
        function dc(d) {
          for (; pt !== null; ) {
            var p = pt;
            if ((p.flags & 8772) !== 0) {
              var b = p.alternate;
              try {
                if ((p.flags & 8772) !== 0)
                  switch (p.tag) {
                    case 0:
                    case 11:
                    case 15:
                      qr || li(5, p);
                      break;
                    case 1:
                      var C = p.stateNode;
                      if (p.flags & 4 && !qr)
                        if (b === null) C.componentDidMount();
                        else {
                          var D =
                            p.elementType === p.type
                              ? b.memoizedProps
                              : Gr(p.type, b.memoizedProps);
                          C.componentDidUpdate(
                            D,
                            b.memoizedState,
                            C.__reactInternalSnapshotBeforeUpdate
                          );
                        }
                      var z = p.updateQueue;
                      z !== null && fg(p, z, C);
                      break;
                    case 3:
                      var ce = p.updateQueue;
                      if (ce !== null) {
                        if (((b = null), p.child !== null))
                          switch (p.child.tag) {
                            case 5:
                              b = X(p.child.stateNode);
                              break;
                            case 1:
                              b = p.child.stateNode;
                          }
                        fg(p, ce, b);
                      }
                      break;
                    case 5:
                      var Me = p.stateNode;
                      b === null &&
                        p.flags & 4 &&
                        nt(Me, p.type, p.memoizedProps, p);
                      break;
                    case 6:
                      break;
                    case 4:
                      break;
                    case 12:
                      break;
                    case 13:
                      if (we && p.memoizedState === null) {
                        var Qe = p.alternate;
                        if (Qe !== null) {
                          var ct = Qe.memoizedState;
                          if (ct !== null) {
                            var Tt = ct.dehydrated;
                            Tt !== null && ze(Tt);
                          }
                        }
                      }
                      break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                      break;
                    default:
                      throw Error(s(163));
                  }
                qr || (p.flags & 512 && Ei(p));
              } catch (Kt) {
                Ri(p, p.return, Kt);
              }
            }
            if (p === d) {
              pt = null;
              break;
            }
            if (((b = p.sibling), b !== null)) {
              (b.return = p.return), (pt = b);
              break;
            }
            pt = p.return;
          }
        }
        function dl(d) {
          for (; pt !== null; ) {
            var p = pt;
            if (p === d) {
              pt = null;
              break;
            }
            var b = p.sibling;
            if (b !== null) {
              (b.return = p.return), (pt = b);
              break;
            }
            pt = p.return;
          }
        }
        function ud(d) {
          for (; pt !== null; ) {
            var p = pt;
            try {
              switch (p.tag) {
                case 0:
                case 11:
                case 15:
                  var b = p.return;
                  try {
                    li(4, p);
                  } catch (Qe) {
                    Ri(p, b, Qe);
                  }
                  break;
                case 1:
                  var C = p.stateNode;
                  if (typeof C.componentDidMount == "function") {
                    var D = p.return;
                    try {
                      C.componentDidMount();
                    } catch (Qe) {
                      Ri(p, D, Qe);
                    }
                  }
                  var z = p.return;
                  try {
                    Ei(p);
                  } catch (Qe) {
                    Ri(p, z, Qe);
                  }
                  break;
                case 5:
                  var ce = p.return;
                  try {
                    Ei(p);
                  } catch (Qe) {
                    Ri(p, ce, Qe);
                  }
              }
            } catch (Qe) {
              Ri(p, p.return, Qe);
            }
            if (p === d) {
              pt = null;
              break;
            }
            var Me = p.sibling;
            if (Me !== null) {
              (Me.return = p.return), (pt = Me);
              break;
            }
            pt = p.return;
          }
        }
        var lu = 0,
          uu = 1,
          cu = 2,
          Xs = 3,
          Ti = 4;
        if (typeof Symbol == "function" && Symbol.for) {
          var Ko = Symbol.for;
          (lu = Ko("selector.component")),
            (uu = Ko("selector.has_pseudo_class")),
            (cu = Ko("selector.role")),
            (Xs = Ko("selector.test_id")),
            (Ti = Ko("selector.text"));
        }
        function hc(d) {
          var p = Ae(d);
          if (p != null) {
            if (typeof p.memoizedProps["data-testname"] != "string")
              throw Error(s(364));
            return p;
          }
          if (((d = B(d)), d === null)) throw Error(s(362));
          return d.stateNode.current;
        }
        function cd(d, p) {
          switch (p.$$typeof) {
            case lu:
              if (d.type === p.value) return !0;
              break;
            case uu:
              e: {
                (p = p.value), (d = [d, 0]);
                for (var b = 0; b < d.length; ) {
                  var C = d[b++],
                    D = d[b++],
                    z = p[D];
                  if (C.tag !== 5 || !_e(C)) {
                    for (; z != null && cd(C, z); ) D++, (z = p[D]);
                    if (D === p.length) {
                      p = !0;
                      break e;
                    } else
                      for (C = C.child; C !== null; )
                        d.push(C, D), (C = C.sibling);
                  }
                }
                p = !1;
              }
              return p;
            case cu:
              if (d.tag === 5 && Te(d.stateNode, p.value)) return !0;
              break;
            case Ti:
              if (
                (d.tag === 5 || d.tag === 6) &&
                ((d = Se(d)), d !== null && 0 <= d.indexOf(p.value))
              )
                return !0;
              break;
            case Xs:
              if (
                d.tag === 5 &&
                ((d = d.memoizedProps["data-testname"]),
                typeof d == "string" &&
                  d.toLowerCase() === p.value.toLowerCase())
              )
                return !0;
              break;
            default:
              throw Error(s(365));
          }
          return !1;
        }
        function Zo(d) {
          switch (d.$$typeof) {
            case lu:
              return "<" + (P(d.value) || "Unknown") + ">";
            case uu:
              return ":has(" + (Zo(d) || "") + ")";
            case cu:
              return '[role="' + d.value + '"]';
            case Ti:
              return '"' + d.value + '"';
            case Xs:
              return '[data-testname="' + d.value + '"]';
            default:
              throw Error(s(365));
          }
        }
        function Ys(d, p) {
          var b = [];
          d = [d, 0];
          for (var C = 0; C < d.length; ) {
            var D = d[C++],
              z = d[C++],
              ce = p[z];
            if (D.tag !== 5 || !_e(D)) {
              for (; ce != null && cd(D, ce); ) z++, (ce = p[z]);
              if (z === p.length) b.push(D);
              else
                for (D = D.child; D !== null; ) d.push(D, z), (D = D.sibling);
            }
          }
          return b;
        }
        function pc(d, p) {
          if (!ee) throw Error(s(363));
          (d = hc(d)), (d = Ys(d, p)), (p = []), (d = Array.from(d));
          for (var b = 0; b < d.length; ) {
            var C = d[b++];
            if (C.tag === 5) _e(C) || p.push(C.stateNode);
            else for (C = C.child; C !== null; ) d.push(C), (C = C.sibling);
          }
          return p;
        }
        var Eg = Math.ceil,
          Ao = l.ReactCurrentDispatcher,
          gs = l.ReactCurrentOwner,
          Kn = l.ReactCurrentBatchConfig,
          rn = 0,
          rr = null,
          dr = null,
          Kr = 0,
          Ci = 0,
          qs = wn(0),
          Sr = 0,
          fu = null,
          hl = 0,
          du = 0,
          pl = 0,
          Ta = null,
          Ai = null,
          fd = 0,
          Ca = 1 / 0;
        function ml() {
          Ca = Yn() + 500;
        }
        var Aa = !1,
          Ro = null,
          Po = null,
          Ra = !1,
          Vi = null,
          hu = 0,
          vs = 0,
          dd = null,
          pu = -1,
          Hn = 0;
        function Zr() {
          return (rn & 6) !== 0 ? Yn() : pu !== -1 ? pu : (pu = Yn());
        }
        function ys(d) {
          return (d.mode & 1) === 0
            ? 1
            : (rn & 2) !== 0 && Kr !== 0
            ? Kr & -Kr
            : va.transition !== null
            ? (Hn === 0 &&
                ((d = Vo),
                (Vo <<= 1),
                (Vo & 4194240) === 0 && (Vo = 64),
                (Hn = d)),
              Hn)
            : ((d = Xt), d !== 0 ? d : Ie());
        }
        function Gi(d, p, b) {
          if (50 < vs) throw ((vs = 0), (dd = null), Error(s(185)));
          var C = gl(d, p);
          return C === null
            ? null
            : (xo(C, p, b),
              ((rn & 2) === 0 || C !== rr) &&
                (C === rr &&
                  ((rn & 2) === 0 && (du |= p), Sr === 4 && Jo(C, Kr)),
                gi(C, b),
                p === 1 &&
                  rn === 0 &&
                  (d.mode & 1) === 0 &&
                  (ml(), ds && pi())),
              C);
        }
        function gl(d, p) {
          d.lanes |= p;
          var b = d.alternate;
          for (b !== null && (b.lanes |= p), b = d, d = d.return; d !== null; )
            (d.childLanes |= p),
              (b = d.alternate),
              b !== null && (b.childLanes |= p),
              (b = d),
              (d = d.return);
          return b.tag === 3 ? b.stateNode : null;
        }
        function gi(d, p) {
          var b = d.callbackNode;
          jl(d, p);
          var C = da(d, d === rr ? Kr : 0);
          if (C === 0)
            b !== null && fs(b),
              (d.callbackNode = null),
              (d.callbackPriority = 0);
          else if (((p = C & -C), d.callbackPriority !== p)) {
            if ((b != null && fs(b), p === 1))
              d.tag === 0 ? ga(mu.bind(null, d)) : Za(mu.bind(null, d)),
                ke
                  ? Xe(function () {
                      rn === 0 && pi();
                    })
                  : ro(Wo, pi),
                (b = null);
            else {
              switch (_o(C)) {
                case 1:
                  b = Wo;
                  break;
                case 4:
                  b = Lf;
                  break;
                case 16:
                  b = hi;
                  break;
                case 536870912:
                  b = ha;
                  break;
                default:
                  b = hi;
              }
              b = yc(b, Pa.bind(null, d));
            }
            (d.callbackPriority = p), (d.callbackNode = b);
          }
        }
        function Pa(d, p) {
          if (((pu = -1), (Hn = 0), (rn & 6) !== 0)) throw Error(s(327));
          var b = d.callbackNode;
          if (La() && d.callbackNode !== b) return null;
          var C = da(d, d === rr ? Kr : 0);
          if (C === 0) return null;
          if ((C & 30) !== 0 || (C & d.expiredLanes) !== 0 || p) p = uo(d, C);
          else {
            p = C;
            var D = rn;
            rn |= 2;
            var z = pd();
            (rr !== d || Kr !== p) && (ml(), or(d, p));
            do
              try {
                gc();
                break;
              } catch (Me) {
                hd(d, Me);
              }
            while (!0);
            Wr(),
              (Ao.current = z),
              (rn = D),
              dr !== null ? (p = 0) : ((rr = null), (Kr = 0), (p = Sr));
          }
          if (p !== 0) {
            if (
              (p === 2 && ((D = cs(d)), D !== 0 && ((C = D), (p = $n(d, D)))),
              p === 1)
            )
              throw ((b = fu), or(d, 0), Jo(d, C), gi(d, Yn()), b);
            if (p === 6) Jo(d, C);
            else {
              if (
                ((D = d.current.alternate),
                (C & 30) === 0 &&
                  !Jr(D) &&
                  ((p = uo(d, C)),
                  p === 2 &&
                    ((z = cs(d)), z !== 0 && ((C = z), (p = $n(d, z)))),
                  p === 1))
              )
                throw ((b = fu), or(d, 0), Jo(d, C), gi(d, Yn()), b);
              switch (((d.finishedWork = D), (d.finishedLanes = C), p)) {
                case 0:
                case 1:
                  throw Error(s(345));
                case 2:
                  Ia(d, Ai);
                  break;
                case 3:
                  if (
                    (Jo(d, C),
                    (C & 130023424) === C && ((p = fd + 500 - Yn()), 10 < p))
                  ) {
                    if (da(d, 0) !== 0) break;
                    if (((D = d.suspendedLanes), (D & C) !== C)) {
                      Zr(), (d.pingedLanes |= d.suspendedLanes & D);
                      break;
                    }
                    d.timeoutHandle = le(Ia.bind(null, d, Ai), p);
                    break;
                  }
                  Ia(d, Ai);
                  break;
                case 4:
                  if ((Jo(d, C), (C & 4194240) === C)) break;
                  for (p = d.eventTimes, D = -1; 0 < C; ) {
                    var ce = 31 - di(C);
                    (z = 1 << ce), (ce = p[ce]), ce > D && (D = ce), (C &= ~z);
                  }
                  if (
                    ((C = D),
                    (C = Yn() - C),
                    (C =
                      (120 > C
                        ? 120
                        : 480 > C
                        ? 480
                        : 1080 > C
                        ? 1080
                        : 1920 > C
                        ? 1920
                        : 3e3 > C
                        ? 3e3
                        : 4320 > C
                        ? 4320
                        : 1960 * Eg(C / 1960)) - C),
                    10 < C)
                  ) {
                    d.timeoutHandle = le(Ia.bind(null, d, Ai), C);
                    break;
                  }
                  Ia(d, Ai);
                  break;
                case 5:
                  Ia(d, Ai);
                  break;
                default:
                  throw Error(s(329));
              }
            }
          }
          return gi(d, Yn()), d.callbackNode === b ? Pa.bind(null, d) : null;
        }
        function $n(d, p) {
          var b = Ta;
          return (
            d.current.memoizedState.isDehydrated && (or(d, p).flags |= 256),
            (d = uo(d, p)),
            d !== 2 && ((p = Ai), (Ai = b), p !== null && hr(p)),
            d
          );
        }
        function hr(d) {
          Ai === null ? (Ai = d) : Ai.push.apply(Ai, d);
        }
        function Jr(d) {
          for (var p = d; ; ) {
            if (p.flags & 16384) {
              var b = p.updateQueue;
              if (b !== null && ((b = b.stores), b !== null))
                for (var C = 0; C < b.length; C++) {
                  var D = b[C],
                    z = D.getSnapshot;
                  D = D.value;
                  try {
                    if (!Hr(z(), D)) return !1;
                  } catch {
                    return !1;
                  }
                }
            }
            if (((b = p.child), p.subtreeFlags & 16384 && b !== null))
              (b.return = p), (p = b);
            else {
              if (p === d) break;
              for (; p.sibling === null; ) {
                if (p.return === null || p.return === d) return !0;
                p = p.return;
              }
              (p.sibling.return = p.return), (p = p.sibling);
            }
          }
          return !0;
        }
        function Jo(d, p) {
          for (
            p &= ~pl,
              p &= ~du,
              d.suspendedLanes |= p,
              d.pingedLanes &= ~p,
              d = d.expirationTimes;
            0 < p;

          ) {
            var b = 31 - di(p),
              C = 1 << b;
            (d[b] = -1), (p &= ~C);
          }
        }
        function mu(d) {
          if ((rn & 6) !== 0) throw Error(s(327));
          La();
          var p = da(d, 0);
          if ((p & 1) === 0) return gi(d, Yn()), null;
          var b = uo(d, p);
          if (d.tag !== 0 && b === 2) {
            var C = cs(d);
            C !== 0 && ((p = C), (b = $n(d, C)));
          }
          if (b === 1) throw ((b = fu), or(d, 0), Jo(d, p), gi(d, Yn()), b);
          if (b === 6) throw Error(s(345));
          return (
            (d.finishedWork = d.current.alternate),
            (d.finishedLanes = p),
            Ia(d, Ai),
            gi(d, Yn()),
            null
          );
        }
        function gu(d) {
          Vi !== null && Vi.tag === 0 && (rn & 6) === 0 && La();
          var p = rn;
          rn |= 1;
          var b = Kn.transition,
            C = Xt;
          try {
            if (((Kn.transition = null), (Xt = 1), d)) return d();
          } finally {
            (Xt = C), (Kn.transition = b), (rn = p), (rn & 6) === 0 && pi();
          }
        }
        function hp() {
          (Ci = qs.current), wt(qs);
        }
        function or(d, p) {
          (d.finishedWork = null), (d.finishedLanes = 0);
          var b = d.timeoutHandle;
          if ((b !== Ee && ((d.timeoutHandle = Ee), fe(b)), dr !== null))
            for (b = dr.return; b !== null; ) {
              var C = b;
              switch ((jh(C), C.tag)) {
                case 1:
                  (C = C.type.childContextTypes), C != null && cn();
                  break;
                case 3:
                  Ql(), wt(bn), wt(zt), nl();
                  break;
                case 5:
                  Yh(C);
                  break;
                case 4:
                  Ql();
                  break;
                case 13:
                  wt(tr);
                  break;
                case 19:
                  wt(tr);
                  break;
                case 10:
                  _r(C.type._context);
                  break;
                case 22:
                case 23:
                  hp();
              }
              b = b.return;
            }
          if (
            ((rr = d),
            (dr = d = Ks(d.current, null)),
            (Kr = Ci = p),
            (Sr = 0),
            (fu = null),
            (pl = du = hl = 0),
            (Ai = Ta = null),
            Si !== null)
          ) {
            for (p = 0; p < Si.length; p++)
              if (((b = Si[p]), (C = b.interleaved), C !== null)) {
                b.interleaved = null;
                var D = C.next,
                  z = b.pending;
                if (z !== null) {
                  var ce = z.next;
                  (z.next = D), (C.next = ce);
                }
                b.pending = C;
              }
            Si = null;
          }
          return d;
        }
        function hd(d, p) {
          do {
            var b = dr;
            try {
              if ((Wr(), (Ju.current = iu), Gf)) {
                for (var C = nr.memoizedState; C !== null; ) {
                  var D = C.queue;
                  D !== null && (D.pending = null), (C = C.next);
                }
                Gf = !1;
              }
              if (
                ((rl = 0),
                ($r = jr = nr = null),
                (hs = !1),
                (il = 0),
                (gs.current = null),
                b === null || b.return === null)
              ) {
                (Sr = 1), (fu = p), (dr = null);
                break;
              }
              e: {
                var z = d,
                  ce = b.return,
                  Me = b,
                  Qe = p;
                if (
                  ((p = Kr),
                  (Me.flags |= 32768),
                  Qe !== null &&
                    typeof Qe == "object" &&
                    typeof Qe.then == "function")
                ) {
                  var ct = Qe,
                    Tt = Me,
                    Kt = Tt.tag;
                  if (
                    (Tt.mode & 1) === 0 &&
                    (Kt === 0 || Kt === 11 || Kt === 15)
                  ) {
                    var Bt = Tt.alternate;
                    Bt
                      ? ((Tt.updateQueue = Bt.updateQueue),
                        (Tt.memoizedState = Bt.memoizedState),
                        (Tt.lanes = Bt.lanes))
                      : ((Tt.updateQueue = null), (Tt.memoizedState = null));
                  }
                  var On = ip(ce);
                  if (On !== null) {
                    (On.flags &= -257),
                      sl(On, ce, Me, z, p),
                      On.mode & 1 && Hs(z, ct, p),
                      (p = On),
                      (Qe = ct);
                    var bt = p.updateQueue;
                    if (bt === null) {
                      var Mn = new Set();
                      Mn.add(Qe), (p.updateQueue = Mn);
                    } else bt.add(Qe);
                    break e;
                  } else {
                    if ((p & 1) === 0) {
                      Hs(z, ct, p), mc();
                      break e;
                    }
                    Qe = Error(s(426));
                  }
                } else if (qn && Me.mode & 1) {
                  var fo = ip(ce);
                  if (fo !== null) {
                    (fo.flags & 65536) === 0 && (fo.flags |= 256),
                      sl(fo, ce, Me, z, p),
                      zf(Qe);
                    break e;
                  }
                }
                (z = Qe),
                  Sr !== 4 && (Sr = 2),
                  Ta === null ? (Ta = [z]) : Ta.push(z),
                  (Qe = rp(Qe, Me)),
                  (Me = ce);
                do {
                  switch (Me.tag) {
                    case 3:
                      (Me.flags |= 65536), (p &= -p), (Me.lanes |= p);
                      var He = bg(Me, Qe, p);
                      Df(Me, He);
                      break e;
                    case 1:
                      z = Qe;
                      var Pe = Me.type,
                        Ze = Me.stateNode;
                      if (
                        (Me.flags & 128) === 0 &&
                        (typeof Pe.getDerivedStateFromError == "function" ||
                          (Ze !== null &&
                            typeof Ze.componentDidCatch == "function" &&
                            (Po === null || !Po.has(Ze))))
                      ) {
                        (Me.flags |= 65536), (p &= -p), (Me.lanes |= p);
                        var _t = Qf(Me, z, p);
                        Df(Me, _t);
                        break e;
                      }
                  }
                  Me = Me.return;
                } while (Me !== null);
              }
              gd(b);
            } catch (It) {
              (p = It), dr === b && b !== null && (dr = b = b.return);
              continue;
            }
            break;
          } while (!0);
        }
        function pd() {
          var d = Ao.current;
          return (Ao.current = iu), d === null ? iu : d;
        }
        function mc() {
          (Sr === 0 || Sr === 3 || Sr === 2) && (Sr = 4),
            rr === null ||
              ((hl & 268435455) === 0 && (du & 268435455) === 0) ||
              Jo(rr, Kr);
        }
        function uo(d, p) {
          var b = rn;
          rn |= 2;
          var C = pd();
          (rr === d && Kr === p) || or(d, p);
          do
            try {
              Io();
              break;
            } catch (D) {
              hd(d, D);
            }
          while (!0);
          if ((Wr(), (rn = b), (Ao.current = C), dr !== null))
            throw Error(s(261));
          return (rr = null), (Kr = 0), Sr;
        }
        function Io() {
          for (; dr !== null; ) md(dr);
        }
        function gc() {
          for (; dr !== null && !So(); ) md(dr);
        }
        function md(d) {
          var p = gp(d.alternate, d, Ci);
          (d.memoizedProps = d.pendingProps),
            p === null ? gd(d) : (dr = p),
            (gs.current = null);
        }
        function gd(d) {
          var p = d;
          do {
            var b = p.alternate;
            if (((d = p.return), (p.flags & 32768) === 0)) {
              if (((b = nd(b, p, Ci)), b !== null)) {
                dr = b;
                return;
              }
            } else {
              if (((b = od(b, p)), b !== null)) {
                (b.flags &= 32767), (dr = b);
                return;
              }
              if (d !== null)
                (d.flags |= 32768), (d.subtreeFlags = 0), (d.deletions = null);
              else {
                (Sr = 6), (dr = null);
                return;
              }
            }
            if (((p = p.sibling), p !== null)) {
              dr = p;
              return;
            }
            dr = p = d;
          } while (p !== null);
          Sr === 0 && (Sr = 5);
        }
        function Ia(d, p) {
          var b = Xt,
            C = Kn.transition;
          try {
            (Kn.transition = null), (Xt = 1), Tg(d, p, b);
          } finally {
            (Kn.transition = C), (Xt = b);
          }
          return null;
        }
        function Tg(d, p, b) {
          do La();
          while (Vi !== null);
          if ((rn & 6) !== 0) throw Error(s(327));
          var C = d.finishedWork,
            D = d.finishedLanes;
          if (C === null) return null;
          if (((d.finishedWork = null), (d.finishedLanes = 0), C === d.current))
            throw Error(s(177));
          (d.callbackNode = null), (d.callbackPriority = 0);
          var z = C.lanes | C.childLanes;
          if (
            (Go(d, z),
            d === rr && ((dr = rr = null), (Kr = 0)),
            ((C.subtreeFlags & 2064) === 0 && (C.flags & 2064) === 0) ||
              Ra ||
              ((Ra = !0),
              yc(hi, function () {
                return La(), null;
              })),
            (z = (C.flags & 15990) !== 0),
            (C.subtreeFlags & 15990) !== 0 || z)
          ) {
            (z = Kn.transition), (Kn.transition = null);
            var ce = Xt;
            Xt = 1;
            var Me = rn;
            (rn |= 4),
              (gs.current = null),
              up(d, C),
              mx(d, C),
              F(d.containerInfo),
              (d.current = C),
              qo(C),
              If(),
              (rn = Me),
              (Xt = ce),
              (Kn.transition = z);
          } else d.current = C;
          if (
            (Ra && ((Ra = !1), (Vi = d), (hu = D)),
            (z = d.pendingLanes),
            z === 0 && (Po = null),
            Is(C.stateNode),
            gi(d, Yn()),
            p !== null)
          )
            for (b = d.onRecoverableError, C = 0; C < p.length; C++) b(p[C]);
          if (Aa) throw ((Aa = !1), (d = Ro), (Ro = null), d);
          return (
            (hu & 1) !== 0 && d.tag !== 0 && La(),
            (z = d.pendingLanes),
            (z & 1) !== 0 ? (d === dd ? vs++ : ((vs = 0), (dd = d))) : (vs = 0),
            pi(),
            null
          );
        }
        function La() {
          if (Vi !== null) {
            var d = _o(hu),
              p = Kn.transition,
              b = Xt;
            try {
              if (((Kn.transition = null), (Xt = 16 > d ? 16 : d), Vi === null))
                var C = !1;
              else {
                if (((d = Vi), (Vi = null), (hu = 0), (rn & 6) !== 0))
                  throw Error(s(331));
                var D = rn;
                for (rn |= 4, pt = d.current; pt !== null; ) {
                  var z = pt,
                    ce = z.child;
                  if ((pt.flags & 16) !== 0) {
                    var Me = z.deletions;
                    if (Me !== null) {
                      for (var Qe = 0; Qe < Me.length; Qe++) {
                        var ct = Me[Qe];
                        for (pt = ct; pt !== null; ) {
                          var Tt = pt;
                          switch (Tt.tag) {
                            case 0:
                            case 11:
                            case 15:
                              $s(8, Tt, z);
                          }
                          var Kt = Tt.child;
                          if (Kt !== null) (Kt.return = Tt), (pt = Kt);
                          else
                            for (; pt !== null; ) {
                              Tt = pt;
                              var Bt = Tt.sibling,
                                On = Tt.return;
                              if ((cp(Tt), Tt === ct)) {
                                pt = null;
                                break;
                              }
                              if (Bt !== null) {
                                (Bt.return = On), (pt = Bt);
                                break;
                              }
                              pt = On;
                            }
                        }
                      }
                      var bt = z.alternate;
                      if (bt !== null) {
                        var Mn = bt.child;
                        if (Mn !== null) {
                          bt.child = null;
                          do {
                            var fo = Mn.sibling;
                            (Mn.sibling = null), (Mn = fo);
                          } while (Mn !== null);
                        }
                      }
                      pt = z;
                    }
                  }
                  if ((z.subtreeFlags & 2064) !== 0 && ce !== null)
                    (ce.return = z), (pt = ce);
                  else
                    e: for (; pt !== null; ) {
                      if (((z = pt), (z.flags & 2048) !== 0))
                        switch (z.tag) {
                          case 0:
                          case 11:
                          case 15:
                            $s(9, z, z.return);
                        }
                      var He = z.sibling;
                      if (He !== null) {
                        (He.return = z.return), (pt = He);
                        break e;
                      }
                      pt = z.return;
                    }
                }
                var Pe = d.current;
                for (pt = Pe; pt !== null; ) {
                  ce = pt;
                  var Ze = ce.child;
                  if ((ce.subtreeFlags & 2064) !== 0 && Ze !== null)
                    (Ze.return = ce), (pt = Ze);
                  else
                    e: for (ce = Pe; pt !== null; ) {
                      if (((Me = pt), (Me.flags & 2048) !== 0))
                        try {
                          switch (Me.tag) {
                            case 0:
                            case 11:
                            case 15:
                              li(9, Me);
                          }
                        } catch (It) {
                          Ri(Me, Me.return, It);
                        }
                      if (Me === ce) {
                        pt = null;
                        break e;
                      }
                      var _t = Me.sibling;
                      if (_t !== null) {
                        (_t.return = Me.return), (pt = _t);
                        break e;
                      }
                      pt = Me.return;
                    }
                }
                if (
                  ((rn = D),
                  pi(),
                  io && typeof io.onPostCommitFiberRoot == "function")
                )
                  try {
                    io.onPostCommitFiberRoot(pa, d);
                  } catch {}
                C = !0;
              }
              return C;
            } finally {
              (Xt = b), (Kn.transition = p);
            }
          }
          return !1;
        }
        function pp(d, p, b) {
          (p = rp(b, p)),
            (p = bg(d, p, 1)),
            ya(d, p),
            (p = Zr()),
            (d = gl(d, 1)),
            d !== null && (xo(d, 1, p), gi(d, p));
        }
        function Ri(d, p, b) {
          if (d.tag === 3) pp(d, d, b);
          else
            for (; p !== null; ) {
              if (p.tag === 3) {
                pp(p, d, b);
                break;
              } else if (p.tag === 1) {
                var C = p.stateNode;
                if (
                  typeof p.type.getDerivedStateFromError == "function" ||
                  (typeof C.componentDidCatch == "function" &&
                    (Po === null || !Po.has(C)))
                ) {
                  (d = rp(b, d)),
                    (d = Qf(p, d, 1)),
                    ya(p, d),
                    (d = Zr()),
                    (p = gl(p, 1)),
                    p !== null && (xo(p, 1, d), gi(p, d));
                  break;
                }
              }
              p = p.return;
            }
        }
        function Cg(d, p, b) {
          var C = d.pingCache;
          C !== null && C.delete(p),
            (p = Zr()),
            (d.pingedLanes |= d.suspendedLanes & b),
            rr === d &&
              (Kr & b) === b &&
              (Sr === 4 ||
              (Sr === 3 && (Kr & 130023424) === Kr && 500 > Yn() - fd)
                ? or(d, 0)
                : (pl |= b)),
            gi(d, p);
        }
        function mp(d, p) {
          p === 0 &&
            ((d.mode & 1) === 0
              ? (p = 1)
              : ((p = ln),
                (ln <<= 1),
                (ln & 130023424) === 0 && (ln = 4194304)));
          var b = Zr();
          (d = gl(d, p)), d !== null && (xo(d, p, b), gi(d, b));
        }
        function Ag(d) {
          var p = d.memoizedState,
            b = 0;
          p !== null && (b = p.retryLane), mp(d, b);
        }
        function vc(d, p) {
          var b = 0;
          switch (d.tag) {
            case 13:
              var C = d.stateNode,
                D = d.memoizedState;
              D !== null && (b = D.retryLane);
              break;
            case 19:
              C = d.stateNode;
              break;
            default:
              throw Error(s(314));
          }
          C !== null && C.delete(p), mp(d, b);
        }
        var gp;
        gp = function (d, p, b) {
          if (d !== null)
            if (d.memoizedProps !== p.pendingProps || bn.current) Yr = !0;
            else {
              if ((d.lanes & b) === 0 && (p.flags & 128) === 0)
                return (Yr = !1), id(d, p, b);
              Yr = (d.flags & 131072) !== 0;
            }
          else (Yr = !1), qn && (p.flags & 1048576) !== 0 && mg(p, Ff, p.index);
          switch (((p.lanes = 0), p.tag)) {
            case 2:
              var C = p.type;
              d !== null &&
                ((d.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (d = p.pendingProps);
              var D = An(p, zt.current);
              cr(p, b), (D = eu(null, p, C, d, D, b));
              var z = wa();
              return (
                (p.flags |= 1),
                typeof D == "object" &&
                D !== null &&
                typeof D.render == "function" &&
                D.$$typeof === void 0
                  ? ((p.tag = 1),
                    (p.memoizedState = null),
                    (p.updateQueue = null),
                    Wn(C) ? ((z = !0), ur(p)) : (z = !1),
                    (p.memoizedState =
                      D.state !== null && D.state !== void 0 ? D.state : null),
                    $l(p),
                    (D.updater = Of),
                    (p.stateNode = D),
                    (D._reactInternals = p),
                    Gh(p, C, d, b),
                    (p = mi(null, p, C, !0, z, b)))
                  : ((p.tag = 0),
                    qn && z && Wh(p),
                    ir(null, p, D, b),
                    (p = p.child)),
                p
              );
            case 16:
              C = p.elementType;
              e: {
                switch (
                  (d !== null &&
                    ((d.alternate = null),
                    (p.alternate = null),
                    (p.flags |= 2)),
                  (d = p.pendingProps),
                  (D = C._init),
                  (C = D(C._payload)),
                  (p.type = C),
                  (D = p.tag = Rg(C)),
                  (d = Gr(C, d)),
                  D)
                ) {
                  case 0:
                    p = Ws(null, p, C, d, b);
                    break e;
                  case 1:
                    p = ll(null, p, C, d, b);
                    break e;
                  case 11:
                    p = zn(null, p, C, d, b);
                    break e;
                  case 14:
                    p = Nn(null, p, C, Gr(C.type, d), b);
                    break e;
                }
                throw Error(s(306, C, ""));
              }
              return p;
            case 0:
              return (
                (C = p.type),
                (D = p.pendingProps),
                (D = p.elementType === C ? D : Gr(C, D)),
                Ws(d, p, C, D, b)
              );
            case 1:
              return (
                (C = p.type),
                (D = p.pendingProps),
                (D = p.elementType === C ? D : Gr(C, D)),
                ll(d, p, C, D, b)
              );
            case 3:
              e: {
                if ((ac(p), d === null)) throw Error(s(387));
                (C = p.pendingProps),
                  (z = p.memoizedState),
                  (D = z.element),
                  zh(d, p),
                  Nf(p, C, null, b);
                var ce = p.memoizedState;
                if (((C = ce.element), we && z.isDehydrated))
                  if (
                    ((z = {
                      element: C,
                      isDehydrated: !1,
                      cache: ce.cache,
                      transitions: ce.transitions,
                    }),
                    (p.updateQueue.baseState = z),
                    (p.memoizedState = z),
                    p.flags & 256)
                  ) {
                    (D = Error(s(423))), (p = sp(d, p, C, b, D));
                    break e;
                  } else if (C !== D) {
                    (D = Error(s(424))), (p = sp(d, p, C, b, D));
                    break e;
                  } else
                    for (
                      we &&
                        ((si = xr(p.stateNode.containerInfo)),
                        (wi = p),
                        (qn = !0),
                        (Eo = null),
                        (Yl = !1)),
                        b = yg(p, null, C, b),
                        p.child = b;
                      b;

                    )
                      (b.flags = (b.flags & -3) | 4096), (b = b.sibling);
                else {
                  if ((ql(), C === D)) {
                    p = Hi(d, p, b);
                    break e;
                  }
                  ir(d, p, C, b);
                }
                p = p.child;
              }
              return p;
            case 5:
              return (
                xg(p),
                d === null && _a(p),
                (C = p.type),
                (D = p.pendingProps),
                (z = d !== null ? d.memoizedProps : null),
                (ce = D.children),
                oe(C, D)
                  ? (ce = null)
                  : z !== null && oe(C, z) && (p.flags |= 32),
                bi(d, p),
                ir(d, p, ce, b),
                p.child
              );
            case 6:
              return d === null && _a(p), null;
            case 13:
              return ap(d, p, b);
            case 4:
              return (
                Hf(p, p.stateNode.containerInfo),
                (C = p.pendingProps),
                d === null ? (p.child = Bs(p, null, C, b)) : ir(d, p, C, b),
                p.child
              );
            case 11:
              return (
                (C = p.type),
                (D = p.pendingProps),
                (D = p.elementType === C ? D : Gr(C, D)),
                zn(d, p, C, D, b)
              );
            case 7:
              return ir(d, p, p.pendingProps, b), p.child;
            case 8:
              return ir(d, p, p.pendingProps.children, b), p.child;
            case 12:
              return ir(d, p, p.pendingProps.children, b), p.child;
            case 10:
              e: {
                if (
                  ((C = p.type._context),
                  (D = p.pendingProps),
                  (z = p.memoizedProps),
                  (ce = D.value),
                  Ns(p, C, ce),
                  z !== null)
                )
                  if (Hr(z.value, ce)) {
                    if (z.children === D.children && !bn.current) {
                      p = Hi(d, p, b);
                      break e;
                    }
                  } else
                    for (
                      z = p.child, z !== null && (z.return = p);
                      z !== null;

                    ) {
                      var Me = z.dependencies;
                      if (Me !== null) {
                        ce = z.child;
                        for (var Qe = Me.firstContext; Qe !== null; ) {
                          if (Qe.context === C) {
                            if (z.tag === 1) {
                              (Qe = Os(-1, b & -b)), (Qe.tag = 2);
                              var ct = z.updateQueue;
                              if (ct !== null) {
                                ct = ct.shared;
                                var Tt = ct.pending;
                                Tt === null
                                  ? (Qe.next = Qe)
                                  : ((Qe.next = Tt.next), (Tt.next = Qe)),
                                  (ct.pending = Qe);
                              }
                            }
                            (z.lanes |= b),
                              (Qe = z.alternate),
                              Qe !== null && (Qe.lanes |= b),
                              Ir(z.return, b, p),
                              (Me.lanes |= b);
                            break;
                          }
                          Qe = Qe.next;
                        }
                      } else if (z.tag === 10)
                        ce = z.type === p.type ? null : z.child;
                      else if (z.tag === 18) {
                        if (((ce = z.return), ce === null)) throw Error(s(341));
                        (ce.lanes |= b),
                          (Me = ce.alternate),
                          Me !== null && (Me.lanes |= b),
                          Ir(ce, b, p),
                          (ce = z.sibling);
                      } else ce = z.child;
                      if (ce !== null) ce.return = z;
                      else
                        for (ce = z; ce !== null; ) {
                          if (ce === p) {
                            ce = null;
                            break;
                          }
                          if (((z = ce.sibling), z !== null)) {
                            (z.return = ce.return), (ce = z);
                            break;
                          }
                          ce = ce.return;
                        }
                      z = ce;
                    }
                ir(d, p, D.children, b), (p = p.child);
              }
              return p;
            case 9:
              return (
                (D = p.type),
                (C = p.pendingProps.children),
                cr(p, b),
                (D = er(D)),
                (C = C(D)),
                (p.flags |= 1),
                ir(d, p, C, b),
                p.child
              );
            case 14:
              return (
                (C = p.type),
                (D = Gr(C, p.pendingProps)),
                (D = Gr(C.type, D)),
                Nn(d, p, C, D, b)
              );
            case 15:
              return Gs(d, p, p.type, p.pendingProps, b);
            case 17:
              return (
                (C = p.type),
                (D = p.pendingProps),
                (D = p.elementType === C ? D : Gr(C, D)),
                d !== null &&
                  ((d.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (p.tag = 1),
                Wn(C) ? ((d = !0), ur(p)) : (d = !1),
                cr(p, b),
                hg(p, C, D),
                Gh(p, C, D, b),
                mi(null, p, C, !0, d, b)
              );
            case 19:
              return cl(d, p, b);
            case 22:
              return ai(d, p, b);
          }
          throw Error(s(156, p.tag));
        };
        function yc(d, p) {
          return ro(d, p);
        }
        function vd(d, p, b, C) {
          (this.tag = d),
            (this.key = b),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = p),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = C),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function co(d, p, b, C) {
          return new vd(d, p, b, C);
        }
        function xc(d) {
          return (d = d.prototype), !(!d || !d.isReactComponent);
        }
        function Rg(d) {
          if (typeof d == "function") return xc(d) ? 1 : 0;
          if (d != null) {
            if (((d = d.$$typeof), d === S)) return 11;
            if (d === T) return 14;
          }
          return 2;
        }
        function Ks(d, p) {
          var b = d.alternate;
          return (
            b === null
              ? ((b = co(d.tag, p, d.key, d.mode)),
                (b.elementType = d.elementType),
                (b.type = d.type),
                (b.stateNode = d.stateNode),
                (b.alternate = d),
                (d.alternate = b))
              : ((b.pendingProps = p),
                (b.type = d.type),
                (b.flags = 0),
                (b.subtreeFlags = 0),
                (b.deletions = null)),
            (b.flags = d.flags & 14680064),
            (b.childLanes = d.childLanes),
            (b.lanes = d.lanes),
            (b.child = d.child),
            (b.memoizedProps = d.memoizedProps),
            (b.memoizedState = d.memoizedState),
            (b.updateQueue = d.updateQueue),
            (p = d.dependencies),
            (b.dependencies =
              p === null
                ? null
                : { lanes: p.lanes, firstContext: p.firstContext }),
            (b.sibling = d.sibling),
            (b.index = d.index),
            (b.ref = d.ref),
            b
          );
        }
        function _c(d, p, b, C, D, z) {
          var ce = 2;
          if (((C = d), typeof d == "function")) xc(d) && (ce = 1);
          else if (typeof d == "string") ce = 5;
          else
            e: switch (d) {
              case h:
                return ka(b.children, D, z, p);
              case m:
                (ce = 8), (D |= 8);
                break;
              case g:
                return (
                  (d = co(12, b, p, D | 2)),
                  (d.elementType = g),
                  (d.lanes = z),
                  d
                );
              case _:
                return (
                  (d = co(13, b, p, D)), (d.elementType = _), (d.lanes = z), d
                );
              case w:
                return (
                  (d = co(19, b, p, D)), (d.elementType = w), (d.lanes = z), d
                );
              case A:
                return vu(b, D, z, p);
              default:
                if (typeof d == "object" && d !== null)
                  switch (d.$$typeof) {
                    case y:
                      ce = 10;
                      break e;
                    case x:
                      ce = 9;
                      break e;
                    case S:
                      ce = 11;
                      break e;
                    case T:
                      ce = 14;
                      break e;
                    case E:
                      (ce = 16), (C = null);
                      break e;
                  }
                throw Error(s(130, d == null ? d : typeof d, ""));
            }
          return (
            (p = co(ce, b, p, D)),
            (p.elementType = d),
            (p.type = C),
            (p.lanes = z),
            p
          );
        }
        function ka(d, p, b, C) {
          return (d = co(7, d, C, p)), (d.lanes = b), d;
        }
        function vu(d, p, b, C) {
          return (
            (d = co(22, d, C, p)),
            (d.elementType = A),
            (d.lanes = b),
            (d.stateNode = {}),
            d
          );
        }
        function yd(d, p, b) {
          return (d = co(6, d, null, p)), (d.lanes = b), d;
        }
        function xd(d, p, b) {
          return (
            (p = co(4, d.children !== null ? d.children : [], d.key, p)),
            (p.lanes = b),
            (p.stateNode = {
              containerInfo: d.containerInfo,
              pendingChildren: null,
              implementation: d.implementation,
            }),
            p
          );
        }
        function Pg(d, p, b, C, D) {
          (this.tag = p),
            (this.containerInfo = d),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = Ee),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = Ka(0)),
            (this.expirationTimes = Ka(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = Ka(0)),
            (this.identifierPrefix = C),
            (this.onRecoverableError = D),
            we && (this.mutableSourceEagerHydrationData = null);
        }
        function Ig(d, p, b, C, D, z, ce, Me, Qe) {
          return (
            (d = new Pg(d, p, b, Me, Qe)),
            p === 1 ? ((p = 1), z === !0 && (p |= 8)) : (p = 0),
            (z = co(3, null, null, p)),
            (d.current = z),
            (z.stateNode = d),
            (z.memoizedState = {
              element: C,
              isDehydrated: b,
              cache: null,
              transitions: null,
            }),
            $l(z),
            d
          );
        }
        function vp(d) {
          if (!d) return Qt;
          d = d._reactInternals;
          e: {
            if (N(d) !== d || d.tag !== 1) throw Error(s(170));
            var p = d;
            do {
              switch (p.tag) {
                case 3:
                  p = p.stateNode.context;
                  break e;
                case 1:
                  if (Wn(p.type)) {
                    p = p.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              p = p.return;
            } while (p !== null);
            throw Error(s(171));
          }
          if (d.tag === 1) {
            var b = d.type;
            if (Wn(b)) return ls(d, b, p);
          }
          return p;
        }
        function Lg(d) {
          var p = d._reactInternals;
          if (p === void 0)
            throw typeof d.render == "function"
              ? Error(s(188))
              : ((d = Object.keys(d).join(",")), Error(s(268, d)));
          return (d = G(p)), d === null ? null : d.stateNode;
        }
        function kg(d, p) {
          if (((d = d.memoizedState), d !== null && d.dehydrated !== null)) {
            var b = d.retryLane;
            d.retryLane = b !== 0 && b < p ? b : p;
          }
        }
        function _d(d, p) {
          kg(d, p), (d = d.alternate) && kg(d, p);
        }
        function Dg(d) {
          return (d = G(d)), d === null ? null : d.stateNode;
        }
        function Ng() {
          return null;
        }
        return (
          (t.attemptContinuousHydration = function (d) {
            if (d.tag === 13) {
              var p = Zr();
              Gi(d, 134217728, p), _d(d, 134217728);
            }
          }),
          (t.attemptHydrationAtCurrentPriority = function (d) {
            if (d.tag === 13) {
              var p = Zr(),
                b = ys(d);
              Gi(d, b, p), _d(d, b);
            }
          }),
          (t.attemptSynchronousHydration = function (d) {
            switch (d.tag) {
              case 3:
                var p = d.stateNode;
                if (p.current.memoizedState.isDehydrated) {
                  var b = us(p.pendingLanes);
                  b !== 0 &&
                    (oi(p, b | 1), gi(p, Yn()), (rn & 6) === 0 && (ml(), pi()));
                }
                break;
              case 13:
                var C = Zr();
                gu(function () {
                  return Gi(d, 1, C);
                }),
                  _d(d, 1);
            }
          }),
          (t.batchedUpdates = function (d, p) {
            var b = rn;
            rn |= 1;
            try {
              return d(p);
            } finally {
              (rn = b), rn === 0 && (ml(), ds && pi());
            }
          }),
          (t.createComponentSelector = function (d) {
            return { $$typeof: lu, value: d };
          }),
          (t.createContainer = function (d, p, b, C, D, z, ce) {
            return Ig(d, p, !1, null, b, C, D, z, ce);
          }),
          (t.createHasPseudoClassSelector = function (d) {
            return { $$typeof: uu, value: d };
          }),
          (t.createHydrationContainer = function (
            d,
            p,
            b,
            C,
            D,
            z,
            ce,
            Me,
            Qe
          ) {
            return (
              (d = Ig(b, C, !0, d, D, z, ce, Me, Qe)),
              (d.context = vp(null)),
              (b = d.current),
              (C = Zr()),
              (D = ys(b)),
              (z = Os(C, D)),
              (z.callback = p ?? null),
              ya(b, z),
              (d.current.lanes = D),
              xo(d, D, C),
              gi(d, C),
              d
            );
          }),
          (t.createPortal = function (d, p, b) {
            var C =
              3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : null;
            return {
              $$typeof: f,
              key: C == null ? null : "" + C,
              children: d,
              containerInfo: p,
              implementation: b,
            };
          }),
          (t.createRoleSelector = function (d) {
            return { $$typeof: cu, value: d };
          }),
          (t.createTestNameSelector = function (d) {
            return { $$typeof: Xs, value: d };
          }),
          (t.createTextSelector = function (d) {
            return { $$typeof: Ti, value: d };
          }),
          (t.deferredUpdates = function (d) {
            var p = Xt,
              b = Kn.transition;
            try {
              return (Kn.transition = null), (Xt = 16), d();
            } finally {
              (Xt = p), (Kn.transition = b);
            }
          }),
          (t.discreteUpdates = function (d, p, b, C, D) {
            var z = Xt,
              ce = Kn.transition;
            try {
              return (Kn.transition = null), (Xt = 1), d(p, b, C, D);
            } finally {
              (Xt = z), (Kn.transition = ce), rn === 0 && ml();
            }
          }),
          (t.findAllNodes = pc),
          (t.findBoundingRects = function (d, p) {
            if (!ee) throw Error(s(363));
            (p = pc(d, p)), (d = []);
            for (var b = 0; b < p.length; b++) d.push(ve(p[b]));
            for (p = d.length - 1; 0 < p; p--) {
              b = d[p];
              for (
                var C = b.x,
                  D = C + b.width,
                  z = b.y,
                  ce = z + b.height,
                  Me = p - 1;
                0 <= Me;
                Me--
              )
                if (p !== Me) {
                  var Qe = d[Me],
                    ct = Qe.x,
                    Tt = ct + Qe.width,
                    Kt = Qe.y,
                    Bt = Kt + Qe.height;
                  if (C >= ct && z >= Kt && D <= Tt && ce <= Bt) {
                    d.splice(p, 1);
                    break;
                  } else if (
                    C !== ct ||
                    b.width !== Qe.width ||
                    Bt < z ||
                    Kt > ce
                  ) {
                    if (
                      !(z !== Kt || b.height !== Qe.height || Tt < C || ct > D)
                    ) {
                      ct > C && ((Qe.width += ct - C), (Qe.x = C)),
                        Tt < D && (Qe.width = D - ct),
                        d.splice(p, 1);
                      break;
                    }
                  } else {
                    Kt > z && ((Qe.height += Kt - z), (Qe.y = z)),
                      Bt < ce && (Qe.height = ce - Kt),
                      d.splice(p, 1);
                    break;
                  }
                }
            }
            return d;
          }),
          (t.findHostInstance = Lg),
          (t.findHostInstanceWithNoPortals = function (d) {
            return (
              (d = H(d)),
              (d = d !== null ? q(d) : null),
              d === null ? null : d.stateNode
            );
          }),
          (t.findHostInstanceWithWarning = function (d) {
            return Lg(d);
          }),
          (t.flushControlled = function (d) {
            var p = rn;
            rn |= 1;
            var b = Kn.transition,
              C = Xt;
            try {
              (Kn.transition = null), (Xt = 1), d();
            } finally {
              (Xt = C), (Kn.transition = b), (rn = p), rn === 0 && (ml(), pi());
            }
          }),
          (t.flushPassiveEffects = La),
          (t.flushSync = gu),
          (t.focusWithin = function (d, p) {
            if (!ee) throw Error(s(363));
            for (
              d = hc(d), p = Ys(d, p), p = Array.from(p), d = 0;
              d < p.length;

            ) {
              var b = p[d++];
              if (!_e(b)) {
                if (b.tag === 5 && at(b.stateNode)) return !0;
                for (b = b.child; b !== null; ) p.push(b), (b = b.sibling);
              }
            }
            return !1;
          }),
          (t.getCurrentUpdatePriority = function () {
            return Xt;
          }),
          (t.getFindAllNodesFailureDescription = function (d, p) {
            if (!ee) throw Error(s(363));
            var b = 0,
              C = [];
            d = [hc(d), 0];
            for (var D = 0; D < d.length; ) {
              var z = d[D++],
                ce = d[D++],
                Me = p[ce];
              if (
                (z.tag !== 5 || !_e(z)) &&
                (cd(z, Me) && (C.push(Zo(Me)), ce++, ce > b && (b = ce)),
                ce < p.length)
              )
                for (z = z.child; z !== null; ) d.push(z, ce), (z = z.sibling);
            }
            if (b < p.length) {
              for (d = []; b < p.length; b++) d.push(Zo(p[b]));
              return (
                `findAllNodes was able to match part of the selector:
  ` +
                (C.join(" > ") +
                  `

No matching component was found for:
  `) +
                d.join(" > ")
              );
            }
            return null;
          }),
          (t.getPublicRootInstance = function (d) {
            if (((d = d.current), !d.child)) return null;
            switch (d.child.tag) {
              case 5:
                return X(d.child.stateNode);
              default:
                return d.child.stateNode;
            }
          }),
          (t.injectIntoDevTools = function (d) {
            if (
              ((d = {
                bundleType: d.bundleType,
                version: d.version,
                rendererPackageName: d.rendererPackageName,
                rendererConfig: d.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: l.ReactCurrentDispatcher,
                findHostInstanceByFiber: Dg,
                findFiberByHostInstance: d.findFiberByHostInstance || Ng,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329",
              }),
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            )
              d = !1;
            else {
              var p = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (p.isDisabled || !p.supportsFiber) d = !0;
              else {
                try {
                  (pa = p.inject(d)), (io = p);
                } catch {}
                d = !!p.checkDCE;
              }
            }
            return d;
          }),
          (t.isAlreadyRendering = function () {
            return !1;
          }),
          (t.observeVisibleRects = function (d, p, b, C) {
            if (!ee) throw Error(s(363));
            d = pc(d, p);
            var D = Fe(d, b, C).disconnect;
            return {
              disconnect: function () {
                D();
              },
            };
          }),
          (t.registerMutableSourceForHydration = function (d, p) {
            var b = p._getVersion;
            (b = b(p._source)),
              d.mutableSourceEagerHydrationData == null
                ? (d.mutableSourceEagerHydrationData = [p, b])
                : d.mutableSourceEagerHydrationData.push(p, b);
          }),
          (t.runWithPriority = function (d, p) {
            var b = Xt;
            try {
              return (Xt = d), p();
            } finally {
              Xt = b;
            }
          }),
          (t.shouldError = function () {
            return null;
          }),
          (t.shouldSuspend = function () {
            return !1;
          }),
          (t.updateContainer = function (d, p, b, C) {
            var D = p.current,
              z = Zr(),
              ce = ys(D);
            return (
              (b = vp(b)),
              p.context === null ? (p.context = b) : (p.pendingContext = b),
              (p = Os(z, ce)),
              (p.payload = { element: d }),
              (C = C === void 0 ? null : C),
              C !== null && (p.callback = C),
              ya(D, p),
              (d = Gi(D, ce, z)),
              d !== null && kf(d, D, ce),
              ce
            );
          }),
          t
        );
      })),
    h1
  );
}
var XT;
function wG() {
  return XT || ((XT = 1), (c1.exports = SG())), c1.exports;
}
var bG = wG();
const MG = Ah(bG);
var YT = QR();
const EG = (n) => typeof n == "object" && typeof n.then == "function",
  cf = [];
function eP(n, e, t = (r, i) => r === i) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const r = n.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!t(n[i], e[i])) return !1;
  return !0;
}
function tP(n, e = null, t = !1, r = {}) {
  e === null && (e = [n]);
  for (const o of cf)
    if (eP(e, o.keys, o.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(o, "error")) throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (o.timeout && clearTimeout(o.timeout),
            (o.timeout = setTimeout(o.remove, r.lifespan))),
          o.response
        );
      if (!t) throw o.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const o = cf.indexOf(i);
      o !== -1 && cf.splice(o, 1);
    },
    promise: (EG(n) ? n : n(...e))
      .then((o) => {
        (i.response = o),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((o) => (i.error = o)),
  };
  if ((cf.push(i), !t)) throw i.promise;
}
const nP = (n, e, t) => tP(n, e, !1, t),
  TG = (n, e, t) => void tP(n, e, !0, t),
  CG = (n) => {
    if (n === void 0 || n.length === 0) cf.splice(0, cf.length);
    else {
      const e = cf.find((t) => eP(n, t.keys, t.equal));
      e && e.remove();
    }
  },
  Ww = {},
  AG = (n) => void Object.assign(Ww, n);
function RG(n, e) {
  function t(h, { args: m = [], attach: g, ...y }, x) {
    let S = `${h[0].toUpperCase()}${h.slice(1)}`,
      _;
    if (h === "primitive") {
      if (y.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const w = y.object;
      _ = oh(w, { type: h, root: x, attach: g, primitive: !0 });
    } else {
      const w = Ww[S];
      if (!w)
        throw new Error(
          `R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(m))
        throw new Error("R3F: The args prop must be an array!");
      _ = oh(new w(...m), {
        type: h,
        root: x,
        attach: g,
        memoizedProps: { args: m },
      });
    }
    return (
      _.__r3f.attach === void 0 &&
        (_ instanceof Jt
          ? (_.__r3f.attach = "geometry")
          : _ instanceof Oi && (_.__r3f.attach = "material")),
      S !== "inject" && g1(_, y),
      _
    );
  }
  function r(h, m) {
    let g = !1;
    if (m) {
      var y, x;
      (y = m.__r3f) != null && y.attach
        ? m1(h, m, m.__r3f.attach)
        : m.isObject3D && h.isObject3D && (h.add(m), (g = !0)),
        g || (x = h.__r3f) == null || x.objects.push(m),
        m.__r3f || oh(m, {}),
        (m.__r3f.parent = h),
        fS(m),
        sh(m);
    }
  }
  function i(h, m, g) {
    let y = !1;
    if (m) {
      var x, S;
      if ((x = m.__r3f) != null && x.attach) m1(h, m, m.__r3f.attach);
      else if (m.isObject3D && h.isObject3D) {
        (m.parent = h),
          m.dispatchEvent({ type: "added" }),
          h.dispatchEvent({ type: "childadded", child: m });
        const _ = h.children.filter((T) => T !== m),
          w = _.indexOf(g);
        (h.children = [..._.slice(0, w), m, ..._.slice(w)]), (y = !0);
      }
      y || (S = h.__r3f) == null || S.objects.push(m),
        m.__r3f || oh(m, {}),
        (m.__r3f.parent = h),
        fS(m),
        sh(m);
    }
  }
  function o(h, m, g = !1) {
    h && [...h].forEach((y) => s(m, y, g));
  }
  function s(h, m, g) {
    if (m) {
      var y, x, S;
      if (
        (m.__r3f && (m.__r3f.parent = null),
        (y = h.__r3f) != null &&
          y.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((A) => A !== m)),
        (x = m.__r3f) != null && x.attach)
      )
        QT(h, m, m.__r3f.attach);
      else if (m.isObject3D && h.isObject3D) {
        var _;
        h.remove(m), (_ = m.__r3f) != null && _.root && UG(h0(m), m);
      }
      const T = (S = m.__r3f) == null ? void 0 : S.primitive,
        E = !T && (g === void 0 ? m.dispose !== null : g);
      if (!T) {
        var w;
        o((w = m.__r3f) == null ? void 0 : w.objects, m, E),
          o(m.children, m, E);
      }
      if ((delete m.__r3f, E && m.dispose && m.type !== "Scene")) {
        const A = () => {
          try {
            m.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? YT.unstable_scheduleCallback(YT.unstable_IdlePriority, A)
          : A();
      }
      sh(h);
    }
  }
  function l(h, m, g, y) {
    var x;
    const S = (x = h.__r3f) == null ? void 0 : x.parent;
    if (!S) return;
    const _ = t(m, g, h.__r3f.root);
    if (h.children) {
      for (const w of h.children) w.__r3f && r(_, w);
      h.children = h.children.filter((w) => !w.__r3f);
    }
    h.__r3f.objects.forEach((w) => r(_, w)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || s(S, h),
      _.parent && (_.__r3f.autoRemovedBeforeAppend = !0),
      r(S, _),
      _.raycast &&
        _.__r3f.eventCount &&
        h0(_).getState().internal.interaction.push(_),
      [y, y.alternate].forEach((w) => {
        w !== null &&
          ((w.stateNode = _),
          w.ref &&
            (typeof w.ref == "function" ? w.ref(_) : (w.ref.current = _)));
      });
  }
  const u = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: MG({
      createInstance: t,
      removeChild: s,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, m) => {
        if (!m) return;
        const g = h.getState().scene;
        g.__r3f && ((g.__r3f.root = h), r(g, m));
      },
      removeChildFromContainer: (h, m) => {
        m && s(h.getState().scene, m);
      },
      insertInContainerBefore: (h, m, g) => {
        if (!m || !g) return;
        const y = h.getState().scene;
        y.__r3f && i(y, m, g);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var m;
        return !!((m = h == null ? void 0 : h.__r3f) != null ? m : {}).handlers;
      },
      prepareUpdate(h, m, g, y) {
        var x;
        if (
          ((x = h == null ? void 0 : h.__r3f) != null ? x : {}).primitive &&
          y.object &&
          y.object !== h
        )
          return [!0];
        {
          const { args: _ = [], children: w, ...T } = y,
            { args: E = [], children: A, ...R } = g;
          if (!Array.isArray(_))
            throw new Error("R3F: the args prop must be an array!");
          if (_.some((P, U) => P !== E[U])) return [!0];
          const k = uP(h, T, R, !0);
          return k.changes.length ? [!1, k] : null;
        }
      },
      commitUpdate(h, [m, g], y, x, S, _) {
        m ? l(h, y, S, _) : g1(h, g);
      },
      commitMount(h, m, g, y) {
        var x;
        const S = (x = h.__r3f) != null ? x : {};
        h.raycast &&
          S.handlers &&
          S.eventCount &&
          h0(h).getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => oh(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var m;
        const { attach: g, parent: y } = (m = h.__r3f) != null ? m : {};
        g && y && QT(y, h, g), h.isObject3D && (h.visible = !1), sh(h);
      },
      unhideInstance(h, m) {
        var g;
        const { attach: y, parent: x } = (g = h.__r3f) != null ? g : {};
        y && x && m1(x, h, y),
          ((h.isObject3D && m.visible == null) || m.visible) &&
            (h.visible = !0),
          sh(h);
      },
      createTextInstance: u,
      hideTextInstance: u,
      unhideTextInstance: u,
      getCurrentEventPriority: () => (e ? e() : dh.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Jn.fun(performance.now)
          ? performance.now
          : Jn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Jn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Jn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: g1,
  };
}
var qT, KT;
const p1 = (n) => "colorSpace" in n || "outputColorSpace" in n,
  rP = () => {
    var n;
    return (n = Ww.ColorManagement) != null ? n : null;
  },
  iP = (n) => n && n.isOrthographicCamera,
  PG = (n) => n && n.hasOwnProperty("current"),
  lg =
    typeof window < "u" &&
    (((qT = window.document) != null && qT.createElement) ||
      ((KT = window.navigator) == null ? void 0 : KT.product) === "ReactNative")
      ? K.useLayoutEffect
      : K.useEffect;
function oP(n) {
  const e = K.useRef(n);
  return lg(() => void (e.current = n), [n]), e;
}
function IG({ set: n }) {
  return lg(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class sP extends K.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
sP.getDerivedStateFromError = () => ({ error: !0 });
const aP = "__default",
  ZT = new Map(),
  LG = (n) => n && !!n.memoized && !!n.changes;
function lP(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const jp = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function h0(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Jn = {
  obj: (n) => n === Object(n) && !Jn.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (Jn.str(n) || Jn.num(n) || Jn.boo(n)) return n === e;
    const o = Jn.obj(n);
    if (o && r === "reference") return n === e;
    const s = Jn.arr(n);
    if (s && t === "reference") return n === e;
    if ((s || o) && n === e) return !0;
    let l;
    for (l in n) if (!(l in e)) return !1;
    if (o && t === "shallow" && r === "shallow") {
      for (l in i ? e : n)
        if (!Jn.equ(n[l], e[l], { strict: i, objects: "reference" })) return !1;
    } else for (l in i ? e : n) if (n[l] !== e[l]) return !1;
    if (Jn.und(l)) {
      if (
        (s && n.length === 0 && e.length === 0) ||
        (o && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function kG(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function DG(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function oh(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function cS(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (t = r.reduce((o, s) => o[s], n)), { target: t, key: i };
  } else return { target: t, key: e };
}
const JT = /-\d+$/;
function m1(n, e, t) {
  if (Jn.str(t)) {
    if (JT.test(t)) {
      const o = t.replace(JT, ""),
        { target: s, key: l } = cS(n, o);
      Array.isArray(s[l]) || (s[l] = []);
    }
    const { target: r, key: i } = cS(n, t);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function QT(n, e, t) {
  var r, i;
  if (Jn.str(t)) {
    const { target: o, key: s } = cS(n, t),
      l = e.__r3f.previousAttach;
    l === void 0 ? delete o[s] : (o[s] = l);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function uP(
  n,
  { children: e, key: t, ref: r, ...i },
  { children: o, key: s, ref: l, ...u } = {},
  f = !1
) {
  const h = n.__r3f,
    m = Object.entries(i),
    g = [];
  if (f) {
    const x = Object.keys(u);
    for (let S = 0; S < x.length; S++)
      i.hasOwnProperty(x[S]) || m.unshift([x[S], aP + "remove"]);
  }
  m.forEach(([x, S]) => {
    var _;
    if (
      ((_ = n.__r3f) != null && _.primitive && x === "object") ||
      Jn.equ(S, u[x])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(x))
      return g.push([x, S, !0, []]);
    let w = [];
    x.includes("-") && (w = x.split("-")), g.push([x, S, !1, w]);
    for (const T in i) {
      const E = i[T];
      T.startsWith(`${x}-`) && g.push([T, E, !1, T.split("-")]);
    }
  });
  const y = { ...i };
  return (
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.args &&
      (y.args = h.memoizedProps.args),
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.attach &&
      (y.attach = h.memoizedProps.attach),
    { memoized: y, changes: g }
  );
}
function g1(n, e) {
  var t;
  const r = n.__r3f,
    i = r == null ? void 0 : r.root,
    o = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: s, changes: l } = LG(e) ? e : uP(n, e),
    u = r == null ? void 0 : r.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = s);
  for (let h = 0; h < l.length; h++) {
    let [m, g, y, x] = l[h];
    if (p1(n)) {
      const T = "srgb",
        E = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (g = g === 3001 ? T : E))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (g = g === 3001 ? T : E));
    }
    let S = n,
      _ = S[m];
    if (x.length && ((_ = x.reduce((w, T) => w[T], n)), !(_ && _.set))) {
      const [w, ...T] = x.reverse();
      (S = T.reverse().reduce((E, A) => E[A], n)), (m = w);
    }
    if (g === aP + "remove")
      if (S.constructor) {
        let w = ZT.get(S.constructor);
        w || ((w = new S.constructor()), ZT.set(S.constructor, w)), (g = w[m]);
      } else g = 0;
    if (y && r)
      g ? (r.handlers[m] = g) : delete r.handlers[m],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (_ && _.set && (_.copy || _ instanceof pf)) {
      if (Array.isArray(g)) _.fromArray ? _.fromArray(g) : _.set(...g);
      else if (_.copy && g && g.constructor && _.constructor === g.constructor)
        _.copy(g);
      else if (g !== void 0) {
        const w = _ instanceof St;
        !w && _.setScalar
          ? _.setScalar(g)
          : _ instanceof pf && g instanceof pf
          ? (_.mask = g.mask)
          : _.set(g),
          !rP() && o && !o.linear && w && _.convertSRGBToLinear();
      }
    } else if (
      ((S[m] = g),
      S[m] instanceof Qn && S[m].format === Ji && S[m].type === aa && o)
    ) {
      const w = S[m];
      p1(w) && p1(o.gl)
        ? (w.colorSpace = o.gl.outputColorSpace)
        : (w.encoding = o.gl.outputEncoding);
    }
    sh(n);
  }
  if (r && r.parent && n.raycast && u !== r.eventCount) {
    const h = h0(n).getState().internal,
      m = h.interaction.indexOf(n);
    m > -1 && h.interaction.splice(m, 1), r.eventCount && h.interaction.push(n);
  }
  return (
    !(l.length === 1 && l[0][0] === "onUpdate") &&
      l.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      fS(n),
    n
  );
}
function sh(n) {
  var e, t;
  const r =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function fS(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function NG(n, e) {
  n.manual ||
    (iP(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function t0(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function OG() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return dh.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return dh.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return dh.ContinuousEventPriority;
    default:
      return dh.DefaultEventPriority;
  }
}
function cP(n, e, t, r) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function UG(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((r) => r !== e)),
    (t.initialHits = t.initialHits.filter((r) => r !== e)),
    t.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((r, i) => {
      cP(t.capturedMap, e, r, i);
    });
}
function FG(n) {
  function e(u) {
    const { internal: f } = n.getState(),
      h = u.offsetX - f.initialClick[0],
      m = u.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(h * h + m * m));
  }
  function t(u) {
    return u.filter((f) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
        var m;
        return (m = f.__r3f) == null ? void 0 : m.handlers["onPointer" + h];
      })
    );
  }
  function r(u, f) {
    const h = n.getState(),
      m = new Set(),
      g = [],
      y = f ? f(h.internal.interaction) : h.internal.interaction;
    for (let w = 0; w < y.length; w++) {
      const T = jp(y[w]);
      T && (T.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(u, h);
    function x(w) {
      const T = jp(w);
      if (!T || !T.events.enabled || T.raycaster.camera === null) return [];
      if (T.raycaster.camera === void 0) {
        var E;
        T.events.compute == null ||
          T.events.compute(
            u,
            T,
            (E = T.previousRoot) == null ? void 0 : E.getState()
          ),
          T.raycaster.camera === void 0 && (T.raycaster.camera = null);
      }
      return T.raycaster.camera ? T.raycaster.intersectObject(w, !0) : [];
    }
    let S = y
      .flatMap(x)
      .sort((w, T) => {
        const E = jp(w.object),
          A = jp(T.object);
        return !E || !A
          ? w.distance - T.distance
          : A.events.priority - E.events.priority || w.distance - T.distance;
      })
      .filter((w) => {
        const T = t0(w);
        return m.has(T) ? !1 : (m.add(T), !0);
      });
    h.events.filter && (S = h.events.filter(S, h));
    for (const w of S) {
      let T = w.object;
      for (; T; ) {
        var _;
        (_ = T.__r3f) != null &&
          _.eventCount &&
          g.push({ ...w, eventObject: T }),
          (T = T.parent);
      }
    }
    if ("pointerId" in u && h.internal.capturedMap.has(u.pointerId))
      for (let w of h.internal.capturedMap.get(u.pointerId).values())
        m.has(t0(w.intersection)) || g.push(w.intersection);
    return g;
  }
  function i(u, f, h, m) {
    const g = n.getState();
    if (u.length) {
      const y = { stopped: !1 };
      for (const x of u) {
        const S = jp(x.object) || g,
          { raycaster: _, pointer: w, camera: T, internal: E } = S,
          A = new se(w.x, w.y, 0).unproject(T),
          R = (L) => {
            var H, G;
            return (H =
              (G = E.capturedMap.get(L)) == null
                ? void 0
                : G.has(x.eventObject)) != null
              ? H
              : !1;
          },
          k = (L) => {
            const H = { intersection: x, target: f.target };
            E.capturedMap.has(L)
              ? E.capturedMap.get(L).set(x.eventObject, H)
              : E.capturedMap.set(L, new Map([[x.eventObject, H]])),
              f.target.setPointerCapture(L);
          },
          P = (L) => {
            const H = E.capturedMap.get(L);
            H && cP(E.capturedMap, x.eventObject, H, L);
          };
        let U = {};
        for (let L in f) {
          let H = f[L];
          typeof H != "function" && (U[L] = H);
        }
        let N = {
          ...x,
          ...U,
          pointer: w,
          intersections: u,
          stopped: y.stopped,
          delta: h,
          unprojectedPoint: A,
          ray: _.ray,
          camera: T,
          stopPropagation() {
            const L = "pointerId" in f && E.capturedMap.get(f.pointerId);
            if (
              (!L || L.has(x.eventObject)) &&
              ((N.stopped = y.stopped = !0),
              E.hovered.size &&
                Array.from(E.hovered.values()).find(
                  (H) => H.eventObject === x.eventObject
                ))
            ) {
              const H = u.slice(0, u.indexOf(x));
              o([...H, x]);
            }
          },
          target: {
            hasPointerCapture: R,
            setPointerCapture: k,
            releasePointerCapture: P,
          },
          currentTarget: {
            hasPointerCapture: R,
            setPointerCapture: k,
            releasePointerCapture: P,
          },
          nativeEvent: f,
        };
        if ((m(N), y.stopped === !0)) break;
      }
    }
    return u;
  }
  function o(u) {
    const { internal: f } = n.getState();
    for (const h of f.hovered.values())
      if (
        !u.length ||
        !u.find(
          (m) =>
            m.object === h.object &&
            m.index === h.index &&
            m.instanceId === h.instanceId
        )
      ) {
        const g = h.eventObject.__r3f,
          y = g == null ? void 0 : g.handlers;
        if ((f.hovered.delete(t0(h)), g != null && g.eventCount)) {
          const x = { ...h, intersections: u };
          y.onPointerOut == null || y.onPointerOut(x),
            y.onPointerLeave == null || y.onPointerLeave(x);
        }
      }
  }
  function s(u, f) {
    for (let h = 0; h < f.length; h++) {
      const m = f[h].__r3f;
      m == null ||
        m.handlers.onPointerMissed == null ||
        m.handlers.onPointerMissed(u);
    }
  }
  function l(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (f) => {
          const { internal: h } = n.getState();
          "pointerId" in f &&
            h.capturedMap.has(f.pointerId) &&
            requestAnimationFrame(() => {
              h.capturedMap.has(f.pointerId) &&
                (h.capturedMap.delete(f.pointerId), o([]));
            });
        };
    }
    return function (h) {
      const { onPointerMissed: m, internal: g } = n.getState();
      g.lastEvent.current = h;
      const y = u === "onPointerMove",
        x = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick",
        _ = r(h, y ? t : void 0),
        w = x ? e(h) : 0;
      u === "onPointerDown" &&
        ((g.initialClick = [h.offsetX, h.offsetY]),
        (g.initialHits = _.map((E) => E.eventObject))),
        x && !_.length && w <= 2 && (s(h, g.interaction), m && m(h)),
        y && o(_);
      function T(E) {
        const A = E.eventObject,
          R = A.__r3f,
          k = R == null ? void 0 : R.handlers;
        if (R != null && R.eventCount)
          if (y) {
            if (
              k.onPointerOver ||
              k.onPointerEnter ||
              k.onPointerOut ||
              k.onPointerLeave
            ) {
              const P = t0(E),
                U = g.hovered.get(P);
              U
                ? U.stopped && E.stopPropagation()
                : (g.hovered.set(P, E),
                  k.onPointerOver == null || k.onPointerOver(E),
                  k.onPointerEnter == null || k.onPointerEnter(E));
            }
            k.onPointerMove == null || k.onPointerMove(E);
          } else {
            const P = k[u];
            P
              ? (!x || g.initialHits.includes(A)) &&
                (s(
                  h,
                  g.interaction.filter((U) => !g.initialHits.includes(U))
                ),
                P(E))
              : x &&
                g.initialHits.includes(A) &&
                s(
                  h,
                  g.interaction.filter((U) => !g.initialHits.includes(U))
                );
          }
      }
      i(_, h, w, T);
    };
  }
  return { handlePointer: l };
}
const fP = (n) => !!(n != null && n.render),
  dP = K.createContext(null),
  BG = (n, e) => {
    const t = xG((l, u) => {
        const f = new se(),
          h = new se(),
          m = new se();
        function g(w = u().camera, T = h, E = u().size) {
          const { width: A, height: R, top: k, left: P } = E,
            U = A / R;
          T instanceof se ? m.copy(T) : m.set(...T);
          const N = w.getWorldPosition(f).distanceTo(m);
          if (iP(w))
            return {
              width: A / w.zoom,
              height: R / w.zoom,
              top: k,
              left: P,
              factor: 1,
              distance: N,
              aspect: U,
            };
          {
            const L = (w.fov * Math.PI) / 180,
              H = 2 * Math.tan(L / 2) * N,
              G = H * (A / R);
            return {
              width: G,
              height: H,
              top: k,
              left: P,
              factor: A / G,
              distance: N,
              aspect: U,
            };
          }
        }
        let y;
        const x = (w) =>
            l((T) => ({ performance: { ...T.performance, current: w } })),
          S = new tt();
        return {
          set: l,
          get: u,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (w = 1) => n(u(), w),
          advance: (w, T) => e(w, T, u()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new Bw(),
          pointer: S,
          mouse: S,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const w = u();
              y && clearTimeout(y),
                w.performance.current !== w.performance.min &&
                  x(w.performance.min),
                (y = setTimeout(
                  () => x(u().performance.max),
                  w.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: g,
          },
          setEvents: (w) => l((T) => ({ ...T, events: { ...T.events, ...w } })),
          setSize: (w, T, E, A, R) => {
            const k = u().camera,
              P = {
                width: w,
                height: T,
                top: A || 0,
                left: R || 0,
                updateStyle: E,
              };
            l((U) => ({ size: P, viewport: { ...U.viewport, ...g(k, h, P) } }));
          },
          setDpr: (w) =>
            l((T) => {
              const E = lP(w);
              return {
                viewport: {
                  ...T.viewport,
                  dpr: E,
                  initialDpr: T.viewport.initialDpr || E,
                },
              };
            }),
          setFrameloop: (w = "always") => {
            const T = u().clock;
            T.stop(),
              (T.elapsedTime = 0),
              w !== "never" && (T.start(), (T.elapsedTime = 0)),
              l(() => ({ frameloop: w }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: K.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (w, T, E) => {
              const A = u().internal;
              return (
                (A.priority = A.priority + (T > 0 ? 1 : 0)),
                A.subscribers.push({ ref: w, priority: T, store: E }),
                (A.subscribers = A.subscribers.sort(
                  (R, k) => R.priority - k.priority
                )),
                () => {
                  const R = u().internal;
                  R != null &&
                    R.subscribers &&
                    ((R.priority = R.priority - (T > 0 ? 1 : 0)),
                    (R.subscribers = R.subscribers.filter((k) => k.ref !== w)));
                }
              );
            },
          },
        };
      }),
      r = t.getState();
    let i = r.size,
      o = r.viewport.dpr,
      s = r.camera;
    return (
      t.subscribe(() => {
        const { camera: l, size: u, viewport: f, gl: h, set: m } = t.getState();
        if (u.width !== i.width || u.height !== i.height || f.dpr !== o) {
          var g;
          (i = u), (o = f.dpr), NG(l, u), h.setPixelRatio(f.dpr);
          const y =
            (g = u.updateStyle) != null
              ? g
              : typeof HTMLCanvasElement < "u" &&
                h.domElement instanceof HTMLCanvasElement;
          h.setSize(u.width, u.height, y);
        }
        l !== s &&
          ((s = l),
          m((y) => ({
            viewport: { ...y.viewport, ...y.viewport.getCurrentViewport(l) },
          })));
      }),
      t.subscribe((l) => n(l)),
      t
    );
  };
let n0,
  zG = new Set(),
  HG = new Set(),
  VG = new Set();
function v1(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function $p(n, e) {
  switch (n) {
    case "before":
      return v1(zG, e);
    case "after":
      return v1(HG, e);
    case "tail":
      return v1(VG, e);
  }
}
let y1, x1;
function _1(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((r = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      y1 = e.internal.subscribers,
      n0 = 0;
    n0 < y1.length;
    n0++
  )
    (x1 = y1[n0]), x1.ref.current(x1.store.getState(), r, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function GG(n) {
  let e = !1,
    t = !1,
    r,
    i,
    o;
  function s(f) {
    (i = requestAnimationFrame(s)),
      (e = !0),
      (r = 0),
      $p("before", f),
      (t = !0);
    for (const m of n.values()) {
      var h;
      (o = m.store.getState()),
        o.internal.active &&
          (o.frameloop === "always" || o.internal.frames > 0) &&
          !((h = o.gl.xr) != null && h.isPresenting) &&
          (r += _1(f, o));
    }
    if (((t = !1), $p("after", f), r === 0))
      return $p("tail", f), (e = !1), cancelAnimationFrame(i);
  }
  function l(f, h = 1) {
    var m;
    if (!f) return n.forEach((g) => l(g.store.getState(), h));
    ((m = f.gl.xr) != null && m.isPresenting) ||
      !f.internal.active ||
      f.frameloop === "never" ||
      (h > 1
        ? (f.internal.frames = Math.min(60, f.internal.frames + h))
        : t
        ? (f.internal.frames = 2)
        : (f.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function u(f, h = !0, m, g) {
    if ((h && $p("before", f), m)) _1(f, m, g);
    else for (const y of n.values()) _1(f, y.store.getState());
    h && $p("after", f);
  }
  return { loop: s, invalidate: l, advance: u };
}
function hP() {
  const n = K.useContext(dP);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function Na(n = (t) => t, e) {
  return hP()(n, e);
}
function ug(n, e = 0) {
  const t = hP(),
    r = t.getState().internal.subscribe,
    i = oP(n);
  return lg(() => r(i, e, t), [e, r, t]), null;
}
const eC = new WeakMap();
function pP(n, e) {
  return function (t, ...r) {
    let i = eC.get(t);
    return (
      i || ((i = new t()), eC.set(t, i)),
      n && n(i),
      Promise.all(
        r.map(
          (o) =>
            new Promise((s, l) =>
              i.load(
                o,
                (u) => {
                  u.scene && Object.assign(u, kG(u.scene)), s(u);
                },
                e,
                (u) =>
                  l(
                    new Error(
                      `Could not load ${o}: ${u == null ? void 0 : u.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function cg(n, e, t, r) {
  const i = Array.isArray(e) ? e : [e],
    o = nP(pP(t, r), [n, ...i], { equal: Jn.equ });
  return Array.isArray(e) ? o : o[0];
}
cg.preload = function (n, e, t) {
  const r = Array.isArray(e) ? e : [e];
  return TG(pP(t), [n, ...r]);
};
cg.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return CG([n, ...t]);
};
const Ch = new Map(),
  { invalidate: tC, advance: nC } = GG(Ch),
  { reconciler: ly, applyProps: Jd } = RG(Ch, OG),
  Qd = { objects: "shallow", strict: !1 },
  WG = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return fP(t)
      ? t
      : new oR({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function jG(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: o, left: s, updateStyle: l = t } = e;
    return { width: r, height: i, top: o, left: s, updateStyle: l };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: o,
      left: s,
    } = n.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: o, left: s, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function $G(n) {
  const e = Ch.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    o = r || BG(tC, nC),
    s =
      t ||
      ly.createContainer(o, dh.ConcurrentRoot, null, !1, null, "", i, null);
  e || Ch.set(n, { fiber: s, store: o });
  let l,
    u = !1,
    f;
  return {
    configure(h = {}) {
      let {
          gl: m,
          size: g,
          scene: y,
          events: x,
          onCreated: S,
          shadows: _ = !1,
          linear: w = !1,
          flat: T = !1,
          legacy: E = !1,
          orthographic: A = !1,
          frameloop: R = "always",
          dpr: k = [1, 2],
          performance: P,
          raycaster: U,
          camera: N,
          onPointerMissed: L,
        } = h,
        H = o.getState(),
        G = H.gl;
      H.gl || H.set({ gl: (G = WG(m, n)) });
      let $ = H.raycaster;
      $ || H.set({ raycaster: ($ = new ZR()) });
      const { params: q, ...Z } = U || {};
      if (
        (Jn.equ(Z, $, Qd) || Jd($, { ...Z }),
        Jn.equ(q, $.params, Qd) || Jd($, { params: { ...$.params, ...q } }),
        !H.camera || (H.camera === f && !Jn.equ(f, N, Qd)))
      ) {
        f = N;
        const F = N instanceof eg,
          V = F
            ? N
            : A
            ? new zu(0, 0, 0, 0, 0.1, 1e3)
            : new Or(75, 0, 0.1, 1e3);
        F ||
          ((V.position.z = 5),
          N &&
            (Jd(V, N),
            ("aspect" in N ||
              "left" in N ||
              "right" in N ||
              "bottom" in N ||
              "top" in N) &&
              ((V.manual = !0), V.updateProjectionMatrix())),
          !H.camera && !(N != null && N.rotation) && V.lookAt(0, 0, 0)),
          H.set({ camera: V }),
          ($.camera = V);
      }
      if (!H.scene) {
        let F;
        y instanceof iy ? (F = y) : ((F = new iy()), y && Jd(F, y)),
          H.set({ scene: oh(F) });
      }
      if (!H.xr) {
        var X;
        const F = (ae, J) => {
            const oe = o.getState();
            oe.frameloop !== "never" && nC(ae, !0, oe, J);
          },
          V = () => {
            const ae = o.getState();
            (ae.gl.xr.enabled = ae.gl.xr.isPresenting),
              ae.gl.xr.setAnimationLoop(ae.gl.xr.isPresenting ? F : null),
              ae.gl.xr.isPresenting || tC(ae);
          },
          ne = {
            connect() {
              const ae = o.getState().gl;
              ae.xr.addEventListener("sessionstart", V),
                ae.xr.addEventListener("sessionend", V);
            },
            disconnect() {
              const ae = o.getState().gl;
              ae.xr.removeEventListener("sessionstart", V),
                ae.xr.removeEventListener("sessionend", V);
            },
          };
        typeof ((X = G.xr) == null ? void 0 : X.addEventListener) ==
          "function" && ne.connect(),
          H.set({ xr: ne });
      }
      if (G.shadowMap) {
        const F = G.shadowMap.enabled,
          V = G.shadowMap.type;
        if (((G.shadowMap.enabled = !!_), Jn.boo(_))) G.shadowMap.type = sm;
        else if (Jn.str(_)) {
          var re;
          const ne = { basic: Z2, percentage: Iy, soft: sm, variance: ra };
          G.shadowMap.type = (re = ne[_]) != null ? re : sm;
        } else Jn.obj(_) && Object.assign(G.shadowMap, _);
        (F !== G.shadowMap.enabled || V !== G.shadowMap.type) &&
          (G.shadowMap.needsUpdate = !0);
      }
      const W = rP();
      W &&
        ("enabled" in W
          ? (W.enabled = !E)
          : "legacyMode" in W && (W.legacyMode = E)),
        u ||
          Jd(G, { outputEncoding: w ? 3e3 : 3001, toneMapping: T ? Ga : tw }),
        H.legacy !== E && H.set(() => ({ legacy: E })),
        H.linear !== w && H.set(() => ({ linear: w })),
        H.flat !== T && H.set(() => ({ flat: T })),
        m && !Jn.fun(m) && !fP(m) && !Jn.equ(m, G, Qd) && Jd(G, m),
        x && !H.events.handlers && H.set({ events: x(o) });
      const te = jG(n, g);
      return (
        Jn.equ(te, H.size, Qd) ||
          H.setSize(te.width, te.height, te.updateStyle, te.top, te.left),
        k && H.viewport.dpr !== lP(k) && H.setDpr(k),
        H.frameloop !== R && H.setFrameloop(R),
        H.onPointerMissed || H.set({ onPointerMissed: L }),
        P &&
          !Jn.equ(P, H.performance, Qd) &&
          H.set((F) => ({ performance: { ...F.performance, ...P } })),
        (l = S),
        (u = !0),
        this
      );
    },
    render(h) {
      return (
        u || this.configure(),
        ly.updateContainer(
          Q.jsx(XG, { store: o, children: h, onCreated: l, rootElement: n }),
          s,
          null,
          () => {}
        ),
        o
      );
    },
    unmount() {
      mP(n);
    },
  };
}
function XG({ store: n, children: e, onCreated: t, rootElement: r }) {
  return (
    lg(() => {
      const i = n.getState();
      i.set((o) => ({ internal: { ...o.internal, active: !0 } })),
        t && t(i),
        n.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    Q.jsx(dP.Provider, { value: n, children: e })
  );
}
function mP(n, e) {
  const t = Ch.get(n),
    r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      ly.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var o, s, l, u;
              i.events.disconnect == null || i.events.disconnect(),
                (o = i.gl) == null ||
                  (s = o.renderLists) == null ||
                  s.dispose == null ||
                  s.dispose(),
                (l = i.gl) == null ||
                  l.forceContextLoss == null ||
                  l.forceContextLoss(),
                (u = i.gl) != null && u.xr && i.xr.disconnect(),
                DG(i),
                Ch.delete(n);
            } catch {}
          }, 500);
      });
  }
}
ly.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: K.version,
});
function rC(n, e) {
  let t;
  return (...r) => {
    window.clearTimeout(t), (t = window.setTimeout(() => n(...r), e));
  };
}
function YG(
  { debounce: n, scroll: e, polyfill: t, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, s] = K.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = K.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
      orientationHandler: null,
    }),
    u = n ? (typeof n == "number" ? n : n.scroll) : null,
    f = n ? (typeof n == "number" ? n : n.resize) : null,
    h = K.useRef(!1);
  K.useEffect(() => ((h.current = !0), () => void (h.current = !1)));
  const [m, g, y] = K.useMemo(() => {
    const w = () => {
      if (!l.current.element) return;
      const {
          left: T,
          top: E,
          width: A,
          height: R,
          bottom: k,
          right: P,
          x: U,
          y: N,
        } = l.current.element.getBoundingClientRect(),
        L = {
          left: T,
          top: E,
          width: A,
          height: R,
          bottom: k,
          right: P,
          x: U,
          y: N,
        };
      l.current.element instanceof HTMLElement &&
        r &&
        ((L.height = l.current.element.offsetHeight),
        (L.width = l.current.element.offsetWidth)),
        Object.freeze(L),
        h.current &&
          !JG(l.current.lastBounds, L) &&
          s((l.current.lastBounds = L));
    };
    return [w, f ? rC(w, f) : w, u ? rC(w, u) : w];
  }, [s, r, u, f]);
  function x() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((w) =>
        w.removeEventListener("scroll", y, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null)),
      l.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              l.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              l.current.orientationHandler
            ));
  }
  function S() {
    l.current.element &&
      ((l.current.resizeObserver = new i(y)),
      l.current.resizeObserver.observe(l.current.element),
      e &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((w) =>
          w.addEventListener("scroll", y, { capture: !0, passive: !0 })
        ),
      (l.current.orientationHandler = () => {
        y();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            l.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            l.current.orientationHandler
          ));
  }
  const _ = (w) => {
    !w ||
      w === l.current.element ||
      (x(), (l.current.element = w), (l.current.scrollContainers = gP(w)), S());
  };
  return (
    KG(y, !!e),
    qG(g),
    K.useEffect(() => {
      x(), S();
    }, [e, y, g]),
    K.useEffect(() => x, []),
    [_, o, m]
  );
}
function qG(n) {
  K.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function KG(n, e) {
  K.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function gP(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(n);
  return (
    [t, r, i].some((o) => o === "auto" || o === "scroll") && e.push(n),
    [...e, ...gP(n.parentElement)]
  );
}
const ZG = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  JG = (n, e) => ZG.every((t) => n[t] === e[t]);
var QG = Object.defineProperty,
  eW = Object.defineProperties,
  tW = Object.getOwnPropertyDescriptors,
  iC = Object.getOwnPropertySymbols,
  nW = Object.prototype.hasOwnProperty,
  rW = Object.prototype.propertyIsEnumerable,
  oC = (n, e, t) =>
    e in n
      ? QG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  sC = (n, e) => {
    for (var t in e || (e = {})) nW.call(e, t) && oC(n, t, e[t]);
    if (iC) for (var t of iC(e)) rW.call(e, t) && oC(n, t, e[t]);
    return n;
  },
  iW = (n, e) => eW(n, tW(e)),
  aC,
  lC;
typeof window < "u" &&
(((aC = window.document) != null && aC.createElement) ||
  ((lC = window.navigator) == null ? void 0 : lC.product) === "ReactNative")
  ? K.useLayoutEffect
  : K.useEffect;
function vP(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = n.child;
  for (; r; ) {
    const i = vP(r, e, t);
    if (i) return i;
    r = r.sibling;
  }
}
function yP(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const uC = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = uC;
    return;
  }
  return uC.apply(this, arguments);
};
const jw = yP(K.createContext(null));
class xP extends K.Component {
  render() {
    return K.createElement(
      jw.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function oW() {
  const n = K.useContext(jw);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = K.useId();
  return K.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r) continue;
      const i = vP(r, !1, (o) => {
        let s = o.memoizedState;
        for (; s; ) {
          if (s.memoizedState === e) return !0;
          s = s.next;
        }
      });
      if (i) return i;
    }
  }, [n, e]);
}
function sW() {
  const n = oW(),
    [e] = K.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      i && i !== jw && !e.has(i) && e.set(i, K.useContext(yP(i)));
    }
    t = t.return;
  }
  return e;
}
function aW() {
  const n = sW();
  return K.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (r) =>
          K.createElement(
            e,
            null,
            K.createElement(t.Provider, iW(sC({}, r), { value: n.get(t) }))
          ),
        (e) => K.createElement(xP, sC({}, e))
      ),
    [n]
  );
}
const S1 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function lW(n) {
  const { handlePointer: e } = FG(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(
        (t.offsetX / r.size.width) * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(S1).reduce((t, r) => ({ ...t, [r]: e(r) }), {}),
    update: () => {
      var t;
      const { events: r, internal: i } = n.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const { set: i, events: o } = n.getState();
      o.disconnect == null || o.disconnect(),
        i((s) => ({ events: { ...s.events, connected: t } })),
        Object.entries((r = o.handlers) != null ? r : []).forEach(([s, l]) => {
          const [u, f] = S1[s];
          t.addEventListener(u, l, { passive: f });
        });
    },
    disconnect: () => {
      const { set: t, events: r } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([o, s]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [l] = S1[o];
            r.connected.removeEventListener(l, s);
          }
        }),
          t((o) => ({ events: { ...o.events, connected: void 0 } }));
      }
    },
  };
}
const uW = K.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: r,
      style: i,
      gl: o,
      events: s = lW,
      eventSource: l,
      eventPrefix: u,
      shadows: f,
      linear: h,
      flat: m,
      legacy: g,
      orthographic: y,
      frameloop: x,
      dpr: S,
      performance: _,
      raycaster: w,
      camera: T,
      scene: E,
      onPointerMissed: A,
      onCreated: R,
      ...k
    },
    P
  ) {
    K.useMemo(() => AG(pG), []);
    const U = aW(),
      [N, L] = YG({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      H = K.useRef(null),
      G = K.useRef(null);
    K.useImperativeHandle(P, () => H.current);
    const $ = oP(A),
      [q, Z] = K.useState(!1),
      [X, re] = K.useState(!1);
    if (q) throw q;
    if (X) throw X;
    const W = K.useRef(null);
    lg(() => {
      const F = H.current;
      L.width > 0 &&
        L.height > 0 &&
        F &&
        (W.current || (W.current = $G(F)),
        W.current.configure({
          gl: o,
          events: s,
          shadows: f,
          linear: h,
          flat: m,
          legacy: g,
          orthographic: y,
          frameloop: x,
          dpr: S,
          performance: _,
          raycaster: w,
          camera: T,
          scene: E,
          size: L,
          onPointerMissed: (...V) =>
            $.current == null ? void 0 : $.current(...V),
          onCreated: (V) => {
            V.events.connect == null ||
              V.events.connect(l ? (PG(l) ? l.current : l) : G.current),
              u &&
                V.setEvents({
                  compute: (ne, ae) => {
                    const J = ne[u + "X"],
                      oe = ne[u + "Y"];
                    ae.pointer.set(
                      (J / ae.size.width) * 2 - 1,
                      -(oe / ae.size.height) * 2 + 1
                    ),
                      ae.raycaster.setFromCamera(ae.pointer, ae.camera);
                  },
                }),
              R == null || R(V);
          },
        }),
        W.current.render(
          Q.jsx(U, {
            children: Q.jsx(sP, {
              set: re,
              children: Q.jsx(K.Suspense, {
                fallback: Q.jsx(IG, { set: Z }),
                children: e,
              }),
            }),
          })
        ));
    }),
      K.useEffect(() => {
        const F = H.current;
        if (F) return () => mP(F);
      }, []);
    const te = l ? "none" : "auto";
    return Q.jsx("div", {
      ref: G,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: te,
        ...i,
      },
      ...k,
      children: Q.jsx("div", {
        ref: N,
        style: { width: "100%", height: "100%" },
        children: Q.jsx("canvas", {
          ref: H,
          style: { display: "block" },
          children: t,
        }),
      }),
    });
  }),
  _P = K.forwardRef(function (e, t) {
    return Q.jsx(xP, { children: Q.jsx(uW, { ...e, ref: t }) });
  });
var cW = Object.defineProperty,
  fW = (n, e, t) =>
    e in n
      ? cW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  dW = (n, e, t) => (fW(n, e + "", t), t);
class hW {
  constructor() {
    dW(this, "_listeners");
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
}
var pW = Object.defineProperty,
  mW = (n, e, t) =>
    e in n
      ? pW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  Gt = (n, e, t) => (mW(n, typeof e != "symbol" ? e + "" : e, t), t);
const r0 = new Tf(),
  cC = new El(),
  gW = Math.cos(70 * (Math.PI / 180)),
  fC = (n, e) => ((n % e) + e) % e;
let vW = class extends hW {
  constructor(e, t) {
    super(),
      Gt(this, "object"),
      Gt(this, "domElement"),
      Gt(this, "enabled", !0),
      Gt(this, "target", new se()),
      Gt(this, "minDistance", 0),
      Gt(this, "maxDistance", 1 / 0),
      Gt(this, "minZoom", 0),
      Gt(this, "maxZoom", 1 / 0),
      Gt(this, "minPolarAngle", 0),
      Gt(this, "maxPolarAngle", Math.PI),
      Gt(this, "minAzimuthAngle", -1 / 0),
      Gt(this, "maxAzimuthAngle", 1 / 0),
      Gt(this, "enableDamping", !1),
      Gt(this, "dampingFactor", 0.05),
      Gt(this, "enableZoom", !0),
      Gt(this, "zoomSpeed", 1),
      Gt(this, "enableRotate", !0),
      Gt(this, "rotateSpeed", 1),
      Gt(this, "enablePan", !0),
      Gt(this, "panSpeed", 1),
      Gt(this, "screenSpacePanning", !0),
      Gt(this, "keyPanSpeed", 7),
      Gt(this, "zoomToCursor", !1),
      Gt(this, "autoRotate", !1),
      Gt(this, "autoRotateSpeed", 2),
      Gt(this, "reverseOrbit", !1),
      Gt(this, "reverseHorizontalOrbit", !1),
      Gt(this, "reverseVerticalOrbit", !1),
      Gt(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      Gt(this, "mouseButtons", {
        LEFT: Kc.ROTATE,
        MIDDLE: Kc.DOLLY,
        RIGHT: Kc.PAN,
      }),
      Gt(this, "touches", { ONE: Zc.ROTATE, TWO: Zc.DOLLY_PAN }),
      Gt(this, "target0"),
      Gt(this, "position0"),
      Gt(this, "zoom0"),
      Gt(this, "_domElementKeyEvents", null),
      Gt(this, "getPolarAngle"),
      Gt(this, "getAzimuthalAngle"),
      Gt(this, "setPolarAngle"),
      Gt(this, "setAzimuthalAngle"),
      Gt(this, "getDistance"),
      Gt(this, "getZoomScale"),
      Gt(this, "listenToKeyEvents"),
      Gt(this, "stopListenToKeyEvents"),
      Gt(this, "saveState"),
      Gt(this, "reset"),
      Gt(this, "update"),
      Gt(this, "connect"),
      Gt(this, "dispose"),
      Gt(this, "dollyIn"),
      Gt(this, "dollyOut"),
      Gt(this, "getScale"),
      Gt(this, "setScale"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => h.phi),
      (this.getAzimuthalAngle = () => h.theta),
      (this.setPolarAngle = (he) => {
        let Je = fC(he, 2 * Math.PI),
          me = h.phi;
        me < 0 && (me += 2 * Math.PI), Je < 0 && (Je += 2 * Math.PI);
        let Ve = Math.abs(Je - me);
        2 * Math.PI - Ve < Ve &&
          (Je < me ? (Je += 2 * Math.PI) : (me += 2 * Math.PI)),
          (m.phi = Je - me),
          r.update();
      }),
      (this.setAzimuthalAngle = (he) => {
        let Je = fC(he, 2 * Math.PI),
          me = h.theta;
        me < 0 && (me += 2 * Math.PI), Je < 0 && (Je += 2 * Math.PI);
        let Ve = Math.abs(Je - me);
        2 * Math.PI - Ve < Ve &&
          (Je < me ? (Je += 2 * Math.PI) : (me += 2 * Math.PI)),
          (m.theta = Je - me),
          r.update();
      }),
      (this.getDistance = () => r.object.position.distanceTo(r.target)),
      (this.listenToKeyEvents = (he) => {
        he.addEventListener("keydown", Be), (this._domElementKeyEvents = he);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Be),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = () => {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(i),
          r.update(),
          (u = l.NONE);
      }),
      (this.update = (() => {
        const he = new se(),
          Je = new se(0, 1, 0),
          me = new eo().setFromUnitVectors(e.up, Je),
          Ve = me.clone().invert(),
          Re = new se(),
          Ue = new eo(),
          it = 2 * Math.PI;
        return function () {
          const gt = r.object.position;
          me.setFromUnitVectors(e.up, Je),
            Ve.copy(me).invert(),
            he.copy(gt).sub(r.target),
            he.applyQuaternion(me),
            h.setFromVector3(he),
            r.autoRotate && u === l.NONE && q(G()),
            r.enableDamping
              ? ((h.theta += m.theta * r.dampingFactor),
                (h.phi += m.phi * r.dampingFactor))
              : ((h.theta += m.theta), (h.phi += m.phi));
          let Ot = r.minAzimuthAngle,
            Ut = r.maxAzimuthAngle;
          isFinite(Ot) &&
            isFinite(Ut) &&
            (Ot < -Math.PI ? (Ot += it) : Ot > Math.PI && (Ot -= it),
            Ut < -Math.PI ? (Ut += it) : Ut > Math.PI && (Ut -= it),
            Ot <= Ut
              ? (h.theta = Math.max(Ot, Math.min(Ut, h.theta)))
              : (h.theta =
                  h.theta > (Ot + Ut) / 2
                    ? Math.max(Ot, h.theta)
                    : Math.min(Ut, h.theta))),
            (h.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, h.phi)
            )),
            h.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(y, r.dampingFactor)
              : r.target.add(y),
            (r.zoomToCursor && N) || r.object.isOrthographicCamera
              ? (h.radius = ae(h.radius))
              : (h.radius = ae(h.radius * g)),
            he.setFromSpherical(h),
            he.applyQuaternion(Ve),
            gt.copy(r.target).add(he),
            r.object.matrixAutoUpdate || r.object.updateMatrix(),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((m.theta *= 1 - r.dampingFactor),
                (m.phi *= 1 - r.dampingFactor),
                y.multiplyScalar(1 - r.dampingFactor))
              : (m.set(0, 0, 0), y.set(0, 0, 0));
          let ht = !1;
          if (r.zoomToCursor && N) {
            let $t = null;
            if (r.object instanceof Or && r.object.isPerspectiveCamera) {
              const un = he.length();
              $t = ae(un * g);
              const Sn = un - $t;
              r.object.position.addScaledVector(P, Sn),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const un = new se(U.x, U.y, 0);
              un.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / g)
                )),
                r.object.updateProjectionMatrix(),
                (ht = !0);
              const Sn = new se(U.x, U.y, 0);
              Sn.unproject(r.object),
                r.object.position.sub(Sn).add(un),
                r.object.updateMatrixWorld(),
                ($t = he.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            $t !== null &&
              (r.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar($t)
                    .add(r.object.position)
                : (r0.origin.copy(r.object.position),
                  r0.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(r0.direction)) < gW
                    ? e.lookAt(r.target)
                    : (cC.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      r0.intersectPlane(cC, r.target))));
          } else
            r.object instanceof zu &&
              r.object.isOrthographicCamera &&
              ((ht = g !== 1),
              ht &&
                ((r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / g)
                )),
                r.object.updateProjectionMatrix()));
          return (
            (g = 1),
            (N = !1),
            ht ||
            Re.distanceToSquared(r.object.position) > f ||
            8 * (1 - Ue.dot(r.object.quaternion)) > f
              ? (r.dispatchEvent(i),
                Re.copy(r.object.position),
                Ue.copy(r.object.quaternion),
                (ht = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (he) => {
        (r.domElement = he),
          (r.domElement.style.touchAction = "none"),
          r.domElement.addEventListener("contextmenu", nt),
          r.domElement.addEventListener("pointerdown", ve),
          r.domElement.addEventListener("pointercancel", _e),
          r.domElement.addEventListener("wheel", Fe);
      }),
      (this.dispose = () => {
        var he, Je, me, Ve, Re, Ue;
        r.domElement && (r.domElement.style.touchAction = "auto"),
          (he = r.domElement) == null ||
            he.removeEventListener("contextmenu", nt),
          (Je = r.domElement) == null ||
            Je.removeEventListener("pointerdown", ve),
          (me = r.domElement) == null ||
            me.removeEventListener("pointercancel", _e),
          (Ve = r.domElement) == null || Ve.removeEventListener("wheel", Fe),
          (Re = r.domElement) == null ||
            Re.ownerDocument.removeEventListener("pointermove", Se),
          (Ue = r.domElement) == null ||
            Ue.ownerDocument.removeEventListener("pointerup", _e),
          r._domElementKeyEvents !== null &&
            r._domElementKeyEvents.removeEventListener("keydown", Be);
      });
    const r = this,
      i = { type: "change" },
      o = { type: "start" },
      s = { type: "end" },
      l = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let u = l.NONE;
    const f = 1e-6,
      h = new uS(),
      m = new uS();
    let g = 1;
    const y = new se(),
      x = new tt(),
      S = new tt(),
      _ = new tt(),
      w = new tt(),
      T = new tt(),
      E = new tt(),
      A = new tt(),
      R = new tt(),
      k = new tt(),
      P = new se(),
      U = new tt();
    let N = !1;
    const L = [],
      H = {};
    function G() {
      return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function $() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function q(he) {
      r.reverseOrbit || r.reverseHorizontalOrbit
        ? (m.theta += he)
        : (m.theta -= he);
    }
    function Z(he) {
      r.reverseOrbit || r.reverseVerticalOrbit ? (m.phi += he) : (m.phi -= he);
    }
    const X = (() => {
        const he = new se();
        return function (me, Ve) {
          he.setFromMatrixColumn(Ve, 0), he.multiplyScalar(-me), y.add(he);
        };
      })(),
      re = (() => {
        const he = new se();
        return function (me, Ve) {
          r.screenSpacePanning === !0
            ? he.setFromMatrixColumn(Ve, 1)
            : (he.setFromMatrixColumn(Ve, 0), he.crossVectors(r.object.up, he)),
            he.multiplyScalar(me),
            y.add(he);
        };
      })(),
      W = (() => {
        const he = new se();
        return function (me, Ve) {
          const Re = r.domElement;
          if (Re && r.object instanceof Or && r.object.isPerspectiveCamera) {
            const Ue = r.object.position;
            he.copy(Ue).sub(r.target);
            let it = he.length();
            (it *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              X((2 * me * it) / Re.clientHeight, r.object.matrix),
              re((2 * Ve * it) / Re.clientHeight, r.object.matrix);
          } else
            Re && r.object instanceof zu && r.object.isOrthographicCamera
              ? (X(
                  (me * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    Re.clientWidth,
                  r.object.matrix
                ),
                re(
                  (Ve * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    Re.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function te(he) {
      (r.object instanceof Or && r.object.isPerspectiveCamera) ||
      (r.object instanceof zu && r.object.isOrthographicCamera)
        ? (g = he)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function F(he) {
      te(g / he);
    }
    function V(he) {
      te(g * he);
    }
    function ne(he) {
      if (!r.zoomToCursor || !r.domElement) return;
      N = !0;
      const Je = r.domElement.getBoundingClientRect(),
        me = he.clientX - Je.left,
        Ve = he.clientY - Je.top,
        Re = Je.width,
        Ue = Je.height;
      (U.x = (me / Re) * 2 - 1),
        (U.y = -(Ve / Ue) * 2 + 1),
        P.set(U.x, U.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function ae(he) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, he));
    }
    function J(he) {
      x.set(he.clientX, he.clientY);
    }
    function oe(he) {
      ne(he), A.set(he.clientX, he.clientY);
    }
    function de(he) {
      w.set(he.clientX, he.clientY);
    }
    function le(he) {
      S.set(he.clientX, he.clientY),
        _.subVectors(S, x).multiplyScalar(r.rotateSpeed);
      const Je = r.domElement;
      Je &&
        (q((2 * Math.PI * _.x) / Je.clientHeight),
        Z((2 * Math.PI * _.y) / Je.clientHeight)),
        x.copy(S),
        r.update();
    }
    function fe(he) {
      R.set(he.clientX, he.clientY),
        k.subVectors(R, A),
        k.y > 0 ? F($()) : k.y < 0 && V($()),
        A.copy(R),
        r.update();
    }
    function Ee(he) {
      T.set(he.clientX, he.clientY),
        E.subVectors(T, w).multiplyScalar(r.panSpeed),
        W(E.x, E.y),
        w.copy(T),
        r.update();
    }
    function ge(he) {
      ne(he), he.deltaY < 0 ? V($()) : he.deltaY > 0 && F($()), r.update();
    }
    function xe(he) {
      let Je = !1;
      switch (he.code) {
        case r.keys.UP:
          W(0, r.keyPanSpeed), (Je = !0);
          break;
        case r.keys.BOTTOM:
          W(0, -r.keyPanSpeed), (Je = !0);
          break;
        case r.keys.LEFT:
          W(r.keyPanSpeed, 0), (Je = !0);
          break;
        case r.keys.RIGHT:
          W(-r.keyPanSpeed, 0), (Je = !0);
          break;
      }
      Je && (he.preventDefault(), r.update());
    }
    function j() {
      if (L.length == 1) x.set(L[0].pageX, L[0].pageY);
      else {
        const he = 0.5 * (L[0].pageX + L[1].pageX),
          Je = 0.5 * (L[0].pageY + L[1].pageY);
        x.set(he, Je);
      }
    }
    function we() {
      if (L.length == 1) w.set(L[0].pageX, L[0].pageY);
      else {
        const he = 0.5 * (L[0].pageX + L[1].pageX),
          Je = 0.5 * (L[0].pageY + L[1].pageY);
        w.set(he, Je);
      }
    }
    function Ae() {
      const he = L[0].pageX - L[1].pageX,
        Je = L[0].pageY - L[1].pageY,
        me = Math.sqrt(he * he + Je * Je);
      A.set(0, me);
    }
    function Ne() {
      r.enableZoom && Ae(), r.enablePan && we();
    }
    function Ie() {
      r.enableZoom && Ae(), r.enableRotate && j();
    }
    function rt(he) {
      if (L.length == 1) S.set(he.pageX, he.pageY);
      else {
        const me = et(he),
          Ve = 0.5 * (he.pageX + me.x),
          Re = 0.5 * (he.pageY + me.y);
        S.set(Ve, Re);
      }
      _.subVectors(S, x).multiplyScalar(r.rotateSpeed);
      const Je = r.domElement;
      Je &&
        (q((2 * Math.PI * _.x) / Je.clientHeight),
        Z((2 * Math.PI * _.y) / Je.clientHeight)),
        x.copy(S);
    }
    function ke(he) {
      if (L.length == 1) T.set(he.pageX, he.pageY);
      else {
        const Je = et(he),
          me = 0.5 * (he.pageX + Je.x),
          Ve = 0.5 * (he.pageY + Je.y);
        T.set(me, Ve);
      }
      E.subVectors(T, w).multiplyScalar(r.panSpeed), W(E.x, E.y), w.copy(T);
    }
    function Xe(he) {
      const Je = et(he),
        me = he.pageX - Je.x,
        Ve = he.pageY - Je.y,
        Re = Math.sqrt(me * me + Ve * Ve);
      R.set(0, Re),
        k.set(0, Math.pow(R.y / A.y, r.zoomSpeed)),
        F(k.y),
        A.copy(R);
    }
    function ee(he) {
      r.enableZoom && Xe(he), r.enablePan && ke(he);
    }
    function B(he) {
      r.enableZoom && Xe(he), r.enableRotate && rt(he);
    }
    function ve(he) {
      var Je, me;
      r.enabled !== !1 &&
        (L.length === 0 &&
          ((Je = r.domElement) == null ||
            Je.ownerDocument.addEventListener("pointermove", Se),
          (me = r.domElement) == null ||
            me.ownerDocument.addEventListener("pointerup", _e)),
        yt(he),
        he.pointerType === "touch" ? We(he) : Te(he));
    }
    function Se(he) {
      r.enabled !== !1 && (he.pointerType === "touch" ? Ye(he) : at(he));
    }
    function _e(he) {
      var Je, me, Ve;
      $e(he),
        L.length === 0 &&
          ((Je = r.domElement) == null ||
            Je.releasePointerCapture(he.pointerId),
          (me = r.domElement) == null ||
            me.ownerDocument.removeEventListener("pointermove", Se),
          (Ve = r.domElement) == null ||
            Ve.ownerDocument.removeEventListener("pointerup", _e)),
        r.dispatchEvent(s),
        (u = l.NONE);
    }
    function Te(he) {
      let Je;
      switch (he.button) {
        case 0:
          Je = r.mouseButtons.LEFT;
          break;
        case 1:
          Je = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Je = r.mouseButtons.RIGHT;
          break;
        default:
          Je = -1;
      }
      switch (Je) {
        case Kc.DOLLY:
          if (r.enableZoom === !1) return;
          oe(he), (u = l.DOLLY);
          break;
        case Kc.ROTATE:
          if (he.ctrlKey || he.metaKey || he.shiftKey) {
            if (r.enablePan === !1) return;
            de(he), (u = l.PAN);
          } else {
            if (r.enableRotate === !1) return;
            J(he), (u = l.ROTATE);
          }
          break;
        case Kc.PAN:
          if (he.ctrlKey || he.metaKey || he.shiftKey) {
            if (r.enableRotate === !1) return;
            J(he), (u = l.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            de(he), (u = l.PAN);
          }
          break;
        default:
          u = l.NONE;
      }
      u !== l.NONE && r.dispatchEvent(o);
    }
    function at(he) {
      if (r.enabled !== !1)
        switch (u) {
          case l.ROTATE:
            if (r.enableRotate === !1) return;
            le(he);
            break;
          case l.DOLLY:
            if (r.enableZoom === !1) return;
            fe(he);
            break;
          case l.PAN:
            if (r.enablePan === !1) return;
            Ee(he);
            break;
        }
    }
    function Fe(he) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        (u !== l.NONE && u !== l.ROTATE) ||
        (he.preventDefault(), r.dispatchEvent(o), ge(he), r.dispatchEvent(s));
    }
    function Be(he) {
      r.enabled === !1 || r.enablePan === !1 || xe(he);
    }
    function We(he) {
      switch ((qe(he), L.length)) {
        case 1:
          switch (r.touches.ONE) {
            case Zc.ROTATE:
              if (r.enableRotate === !1) return;
              j(), (u = l.TOUCH_ROTATE);
              break;
            case Zc.PAN:
              if (r.enablePan === !1) return;
              we(), (u = l.TOUCH_PAN);
              break;
            default:
              u = l.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case Zc.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              Ne(), (u = l.TOUCH_DOLLY_PAN);
              break;
            case Zc.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              Ie(), (u = l.TOUCH_DOLLY_ROTATE);
              break;
            default:
              u = l.NONE;
          }
          break;
        default:
          u = l.NONE;
      }
      u !== l.NONE && r.dispatchEvent(o);
    }
    function Ye(he) {
      switch ((qe(he), u)) {
        case l.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          rt(he), r.update();
          break;
        case l.TOUCH_PAN:
          if (r.enablePan === !1) return;
          ke(he), r.update();
          break;
        case l.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          ee(he), r.update();
          break;
        case l.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          B(he), r.update();
          break;
        default:
          u = l.NONE;
      }
    }
    function nt(he) {
      r.enabled !== !1 && he.preventDefault();
    }
    function yt(he) {
      L.push(he);
    }
    function $e(he) {
      delete H[he.pointerId];
      for (let Je = 0; Je < L.length; Je++)
        if (L[Je].pointerId == he.pointerId) {
          L.splice(Je, 1);
          return;
        }
    }
    function qe(he) {
      let Je = H[he.pointerId];
      Je === void 0 && ((Je = new tt()), (H[he.pointerId] = Je)),
        Je.set(he.pageX, he.pageY);
    }
    function et(he) {
      const Je = he.pointerId === L[0].pointerId ? L[1] : L[0];
      return H[Je.pointerId];
    }
    (this.dollyIn = (he = $()) => {
      V(he), r.update();
    }),
      (this.dollyOut = (he = $()) => {
        F(he), r.update();
      }),
      (this.getScale = () => g),
      (this.setScale = (he) => {
        te(he), r.update();
      }),
      (this.getZoomScale = () => $()),
      t !== void 0 && this.connect(t),
      this.update();
  }
};
function yW() {
  var n = Object.create(null);
  function e(i, o) {
    var s = i.id,
      l = i.name,
      u = i.dependencies;
    u === void 0 && (u = []);
    var f = i.init;
    f === void 0 && (f = function () {});
    var h = i.getTransferables;
    if ((h === void 0 && (h = null), !n[s]))
      try {
        (u = u.map(function (g) {
          return (
            g &&
              g.isWorkerModule &&
              (e(g, function (y) {
                if (y instanceof Error) throw y;
              }),
              (g = n[g.id].value)),
            g
          );
        })),
          (f = r("<" + l + ">.init", f)),
          h && (h = r("<" + l + ">.getTransferables", h));
        var m = null;
        typeof f == "function"
          ? (m = f.apply(void 0, u))
          : console.error("worker module init function failed to rehydrate"),
          (n[s] = { id: s, value: m, getTransferables: h }),
          o(m);
      } catch (g) {
        (g && g.noLog) || console.error(g), o(g);
      }
  }
  function t(i, o) {
    var s,
      l = i.id,
      u = i.args;
    (!n[l] || typeof n[l].value != "function") &&
      o(
        new Error(
          "Worker module " +
            l +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var f = (s = n[l]).value.apply(s, u);
      f && typeof f.then == "function"
        ? f.then(h, function (m) {
            return o(m instanceof Error ? m : new Error("" + m));
          })
        : h(f);
    } catch (m) {
      o(m);
    }
    function h(m) {
      try {
        var g = n[l].getTransferables && n[l].getTransferables(m);
        (!g || !Array.isArray(g) || !g.length) && (g = void 0), o(m, g);
      } catch (y) {
        console.error(y), o(y);
      }
    }
  }
  function r(i, o) {
    var s = void 0;
    self.troikaDefine = function (u) {
      return (s = u);
    };
    var l = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            i.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            o +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(l);
    } catch (u) {
      console.error(u);
    }
    return URL.revokeObjectURL(l), delete self.troikaDefine, s;
  }
  self.addEventListener("message", function (i) {
    var o = i.data,
      s = o.messageId,
      l = o.action,
      u = o.data;
    try {
      l === "registerModule" &&
        e(u, function (f) {
          f instanceof Error
            ? postMessage({ messageId: s, success: !1, error: f.message })
            : postMessage({
                messageId: s,
                success: !0,
                result: { isCallable: typeof f == "function" },
              });
        }),
        l === "callModule" &&
          t(u, function (f, h) {
            f instanceof Error
              ? postMessage({ messageId: s, success: !1, error: f.message })
              : postMessage(
                  { messageId: s, success: !0, result: f },
                  h || void 0
                );
          });
    } catch (f) {
      postMessage({ messageId: s, success: !1, error: f.stack });
    }
  });
}
function xW(n) {
  var e = function () {
    for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
    return e._getInitResult().then(function (i) {
      if (typeof i == "function") return i.apply(void 0, t);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var t = n.dependencies,
        r = n.init;
      t = Array.isArray(t)
        ? t.map(function (o) {
            return o && o._getInitResult ? o._getInitResult() : o;
          })
        : [];
      var i = Promise.all(t).then(function (o) {
        return r.apply(null, o);
      });
      return (
        (e._getInitResult = function () {
          return i;
        }),
        i
      );
    }),
    e
  );
}
var SP = function () {
    var n = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        e.terminate(), (n = !0);
      } catch (t) {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
            t.message +
            "]"
        );
      }
    return (
      (SP = function () {
        return n;
      }),
      n
    );
  },
  _W = 0,
  SW = 0,
  w1 = !1,
  gm = Object.create(null),
  vm = Object.create(null),
  dS = Object.create(null);
function Bh(n) {
  if ((!n || typeof n.init != "function") && !w1)
    throw new Error("requires `options.init` function");
  var e = n.dependencies,
    t = n.init,
    r = n.getTransferables,
    i = n.workerId;
  if (!SP()) return xW(n);
  i == null && (i = "#default");
  var o = "workerModule" + ++_W,
    s = n.name || o,
    l = null;
  e =
    e &&
    e.map(function (f) {
      return (
        typeof f == "function" &&
          !f.workerModuleData &&
          ((w1 = !0),
          (f = Bh({
            workerId: i,
            name: "<" + s + "> function dependency: " + f.name,
            init:
              `function(){return (
` +
              p0(f) +
              `
)}`,
          })),
          (w1 = !1)),
        f && f.workerModuleData && (f = f.workerModuleData),
        f
      );
    });
  function u() {
    for (var f = [], h = arguments.length; h--; ) f[h] = arguments[h];
    if (!l) {
      l = dC(i, "registerModule", u.workerModuleData);
      var m = function () {
        (l = null), vm[i].delete(m);
      };
      (vm[i] || (vm[i] = new Set())).add(m);
    }
    return l.then(function (g) {
      var y = g.isCallable;
      if (y) return dC(i, "callModule", { id: o, args: f });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (u.workerModuleData = {
      isWorkerModule: !0,
      id: o,
      name: s,
      dependencies: e,
      init: p0(t),
      getTransferables: r && p0(r),
    }),
    u
  );
}
function wW(n) {
  vm[n] &&
    vm[n].forEach(function (e) {
      e();
    }),
    gm[n] && (gm[n].terminate(), delete gm[n]);
}
function p0(n) {
  var e = n.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
  );
}
function bW(n) {
  var e = gm[n];
  if (!e) {
    var t = p0(yW);
    (e = gm[n] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                n.replace(/\*/g, "") +
                ` **/

;(` +
                t +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (e.onmessage = function (r) {
        var i = r.data,
          o = i.messageId,
          s = dS[o];
        if (!s)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete dS[o], s(i);
      });
  }
  return e;
}
function dC(n, e, t) {
  return new Promise(function (r, i) {
    var o = ++SW;
    (dS[o] = function (s) {
      s.success
        ? r(s.result)
        : i(new Error("Error in worker " + e + " call: " + s.error));
    }),
      bW(n).postMessage({ messageId: o, action: e, data: t });
  });
}
function wP() {
  var n = (function (e) {
    function t(te, F, V, ne, ae, J, oe, de) {
      var le = 1 - oe;
      (de.x = le * le * te + 2 * le * oe * V + oe * oe * ae),
        (de.y = le * le * F + 2 * le * oe * ne + oe * oe * J);
    }
    function r(te, F, V, ne, ae, J, oe, de, le, fe) {
      var Ee = 1 - le;
      (fe.x =
        Ee * Ee * Ee * te +
        3 * Ee * Ee * le * V +
        3 * Ee * le * le * ae +
        le * le * le * oe),
        (fe.y =
          Ee * Ee * Ee * F +
          3 * Ee * Ee * le * ne +
          3 * Ee * le * le * J +
          le * le * le * de);
    }
    function i(te, F) {
      for (
        var V = /([MLQCZ])([^MLQCZ]*)/g, ne, ae, J, oe, de;
        (ne = V.exec(te));

      ) {
        var le = ne[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (fe) {
            return parseFloat(fe);
          });
        switch (ne[1]) {
          case "M":
            (oe = ae = le[0]), (de = J = le[1]);
            break;
          case "L":
            (le[0] !== oe || le[1] !== de) &&
              F("L", oe, de, (oe = le[0]), (de = le[1]));
            break;
          case "Q": {
            F("Q", oe, de, (oe = le[2]), (de = le[3]), le[0], le[1]);
            break;
          }
          case "C": {
            F(
              "C",
              oe,
              de,
              (oe = le[4]),
              (de = le[5]),
              le[0],
              le[1],
              le[2],
              le[3]
            );
            break;
          }
          case "Z":
            (oe !== ae || de !== J) && F("L", oe, de, ae, J);
            break;
        }
      }
    }
    function o(te, F, V) {
      V === void 0 && (V = 16);
      var ne = { x: 0, y: 0 };
      i(te, function (ae, J, oe, de, le, fe, Ee, ge, xe) {
        switch (ae) {
          case "L":
            F(J, oe, de, le);
            break;
          case "Q": {
            for (var j = J, we = oe, Ae = 1; Ae < V; Ae++)
              t(J, oe, fe, Ee, de, le, Ae / (V - 1), ne),
                F(j, we, ne.x, ne.y),
                (j = ne.x),
                (we = ne.y);
            break;
          }
          case "C": {
            for (var Ne = J, Ie = oe, rt = 1; rt < V; rt++)
              r(J, oe, fe, Ee, ge, xe, de, le, rt / (V - 1), ne),
                F(Ne, Ie, ne.x, ne.y),
                (Ne = ne.x),
                (Ie = ne.y);
            break;
          }
        }
      });
    }
    var s =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      l =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      u = new WeakMap(),
      f = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function h(te, F) {
      var V = te.getContext ? te.getContext("webgl", f) : te,
        ne = u.get(V);
      if (!ne) {
        let Ne = function (B) {
            var ve = J[B];
            if (!ve && ((ve = J[B] = V.getExtension(B)), !ve))
              throw new Error(B + " not supported");
            return ve;
          },
          Ie = function (B, ve) {
            var Se = V.createShader(ve);
            return V.shaderSource(Se, B), V.compileShader(Se), Se;
          },
          rt = function (B, ve, Se, _e) {
            if (!oe[B]) {
              var Te = {},
                at = {},
                Fe = V.createProgram();
              V.attachShader(Fe, Ie(ve, V.VERTEX_SHADER)),
                V.attachShader(Fe, Ie(Se, V.FRAGMENT_SHADER)),
                V.linkProgram(Fe),
                (oe[B] = {
                  program: Fe,
                  transaction: function (We) {
                    V.useProgram(Fe),
                      We({
                        setUniform: function (nt, yt) {
                          for (
                            var $e = [], qe = arguments.length - 2;
                            qe-- > 0;

                          )
                            $e[qe] = arguments[qe + 2];
                          var et =
                            at[yt] || (at[yt] = V.getUniformLocation(Fe, yt));
                          V["uniform" + nt].apply(V, [et].concat($e));
                        },
                        setAttribute: function (nt, yt, $e, qe, et) {
                          var he = Te[nt];
                          he ||
                            (he = Te[nt] =
                              {
                                buf: V.createBuffer(),
                                loc: V.getAttribLocation(Fe, nt),
                                data: null,
                              }),
                            V.bindBuffer(V.ARRAY_BUFFER, he.buf),
                            V.vertexAttribPointer(
                              he.loc,
                              yt,
                              V.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            V.enableVertexAttribArray(he.loc),
                            ae
                              ? V.vertexAttribDivisor(he.loc, qe)
                              : Ne(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(he.loc, qe),
                            et !== he.data &&
                              (V.bufferData(V.ARRAY_BUFFER, et, $e),
                              (he.data = et));
                        },
                      });
                  },
                });
            }
            oe[B].transaction(_e);
          },
          ke = function (B, ve) {
            le++;
            try {
              V.activeTexture(V.TEXTURE0 + le);
              var Se = de[B];
              Se ||
                ((Se = de[B] = V.createTexture()),
                V.bindTexture(V.TEXTURE_2D, Se),
                V.texParameteri(V.TEXTURE_2D, V.TEXTURE_MIN_FILTER, V.NEAREST),
                V.texParameteri(V.TEXTURE_2D, V.TEXTURE_MAG_FILTER, V.NEAREST)),
                V.bindTexture(V.TEXTURE_2D, Se),
                ve(Se, le);
            } finally {
              le--;
            }
          },
          Xe = function (B, ve, Se) {
            var _e = V.createFramebuffer();
            fe.push(_e),
              V.bindFramebuffer(V.FRAMEBUFFER, _e),
              V.activeTexture(V.TEXTURE0 + ve),
              V.bindTexture(V.TEXTURE_2D, B),
              V.framebufferTexture2D(
                V.FRAMEBUFFER,
                V.COLOR_ATTACHMENT0,
                V.TEXTURE_2D,
                B,
                0
              );
            try {
              Se(_e);
            } finally {
              V.deleteFramebuffer(_e),
                V.bindFramebuffer(V.FRAMEBUFFER, fe[--fe.length - 1] || null);
            }
          },
          ee = function () {
            (J = {}), (oe = {}), (de = {}), (le = -1), (fe.length = 0);
          };
        var Ee = Ne,
          ge = Ie,
          xe = rt,
          j = ke,
          we = Xe,
          Ae = ee,
          ae =
            typeof WebGL2RenderingContext < "u" &&
            V instanceof WebGL2RenderingContext,
          J = {},
          oe = {},
          de = {},
          le = -1,
          fe = [];
        V.canvas.addEventListener(
          "webglcontextlost",
          function (B) {
            ee(), B.preventDefault();
          },
          !1
        ),
          u.set(
            V,
            (ne = {
              gl: V,
              isWebGL2: ae,
              getExtension: Ne,
              withProgram: rt,
              withTexture: ke,
              withTextureFramebuffer: Xe,
              handleContextLoss: ee,
            })
          );
      }
      F(ne);
    }
    function m(te, F, V, ne, ae, J, oe, de) {
      oe === void 0 && (oe = 15),
        de === void 0 && (de = null),
        h(te, function (le) {
          var fe = le.gl,
            Ee = le.withProgram,
            ge = le.withTexture;
          ge("copy", function (xe, j) {
            fe.texImage2D(
              fe.TEXTURE_2D,
              0,
              fe.RGBA,
              ae,
              J,
              0,
              fe.RGBA,
              fe.UNSIGNED_BYTE,
              F
            ),
              Ee("copy", s, l, function (we) {
                var Ae = we.setUniform,
                  Ne = we.setAttribute;
                Ne(
                  "aUV",
                  2,
                  fe.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  Ae("1i", "image", j),
                  fe.bindFramebuffer(fe.FRAMEBUFFER, de || null),
                  fe.disable(fe.BLEND),
                  fe.colorMask(oe & 8, oe & 4, oe & 2, oe & 1),
                  fe.viewport(V, ne, ae, J),
                  fe.scissor(V, ne, ae, J),
                  fe.drawArrays(fe.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function g(te, F, V) {
      var ne = te.width,
        ae = te.height;
      h(te, function (J) {
        var oe = J.gl,
          de = new Uint8Array(ne * ae * 4);
        oe.readPixels(0, 0, ne, ae, oe.RGBA, oe.UNSIGNED_BYTE, de),
          (te.width = F),
          (te.height = V),
          m(oe, de, 0, 0, ne, ae);
      });
    }
    var y = Object.freeze({
      __proto__: null,
      withWebGLContext: h,
      renderImageData: m,
      resizeWebGLCanvasWithoutClearing: g,
    });
    function x(te, F, V, ne, ae, J) {
      J === void 0 && (J = 1);
      var oe = new Uint8Array(te * F),
        de = ne[2] - ne[0],
        le = ne[3] - ne[1],
        fe = [];
      o(V, function (Ne, Ie, rt, ke) {
        fe.push({
          x1: Ne,
          y1: Ie,
          x2: rt,
          y2: ke,
          minX: Math.min(Ne, rt),
          minY: Math.min(Ie, ke),
          maxX: Math.max(Ne, rt),
          maxY: Math.max(Ie, ke),
        });
      }),
        fe.sort(function (Ne, Ie) {
          return Ne.maxX - Ie.maxX;
        });
      for (var Ee = 0; Ee < te; Ee++)
        for (var ge = 0; ge < F; ge++) {
          var xe = we(
              ne[0] + (de * (Ee + 0.5)) / te,
              ne[1] + (le * (ge + 0.5)) / F
            ),
            j = Math.pow(1 - Math.abs(xe) / ae, J) / 2;
          xe < 0 && (j = 1 - j),
            (j = Math.max(0, Math.min(255, Math.round(j * 255)))),
            (oe[ge * te + Ee] = j);
        }
      return oe;
      function we(Ne, Ie) {
        for (var rt = 1 / 0, ke = 1 / 0, Xe = fe.length; Xe--; ) {
          var ee = fe[Xe];
          if (ee.maxX + ke <= Ne) break;
          if (Ne + ke > ee.minX && Ie - ke < ee.maxY && Ie + ke > ee.minY) {
            var B = w(Ne, Ie, ee.x1, ee.y1, ee.x2, ee.y2);
            B < rt && ((rt = B), (ke = Math.sqrt(rt)));
          }
        }
        return Ae(Ne, Ie) && (ke = -ke), ke;
      }
      function Ae(Ne, Ie) {
        for (var rt = 0, ke = fe.length; ke--; ) {
          var Xe = fe[ke];
          if (Xe.maxX <= Ne) break;
          var ee =
            Xe.y1 > Ie != Xe.y2 > Ie &&
            Ne < ((Xe.x2 - Xe.x1) * (Ie - Xe.y1)) / (Xe.y2 - Xe.y1) + Xe.x1;
          ee && (rt += Xe.y1 < Xe.y2 ? 1 : -1);
        }
        return rt !== 0;
      }
    }
    function S(te, F, V, ne, ae, J, oe, de, le, fe) {
      J === void 0 && (J = 1),
        de === void 0 && (de = 0),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        _(te, F, V, ne, ae, J, oe, null, de, le, fe);
    }
    function _(te, F, V, ne, ae, J, oe, de, le, fe, Ee) {
      J === void 0 && (J = 1),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        Ee === void 0 && (Ee = 0);
      for (
        var ge = x(te, F, V, ne, ae, J),
          xe = new Uint8Array(ge.length * 4),
          j = 0;
        j < ge.length;
        j++
      )
        xe[j * 4 + Ee] = ge[j];
      m(oe, xe, le, fe, te, F, 1 << (3 - Ee), de);
    }
    function w(te, F, V, ne, ae, J) {
      var oe = ae - V,
        de = J - ne,
        le = oe * oe + de * de,
        fe = le
          ? Math.max(0, Math.min(1, ((te - V) * oe + (F - ne) * de) / le))
          : 0,
        Ee = te - (V + fe * oe),
        ge = F - (ne + fe * de);
      return Ee * Ee + ge * ge;
    }
    var T = Object.freeze({
        __proto__: null,
        generate: x,
        generateIntoCanvas: S,
        generateIntoFramebuffer: _,
      }),
      E =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      A =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      R =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      k = new Float32Array([0, 0, 2, 0, 0, 2]),
      P = null,
      U = !1,
      N = {},
      L = new WeakMap();
    function H(te) {
      if (!U && !Z(te)) throw new Error("WebGL generation not supported");
    }
    function G(te, F, V, ne, ae, J, oe) {
      if (
        (J === void 0 && (J = 1),
        oe === void 0 && (oe = null),
        !oe && ((oe = P), !oe))
      ) {
        var de =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!de) throw new Error("OffscreenCanvas or DOM canvas not supported");
        oe = P = de.getContext("webgl", { depth: !1 });
      }
      H(oe);
      var le = new Uint8Array(te * F * 4);
      h(oe, function (xe) {
        var j = xe.gl,
          we = xe.withTexture,
          Ae = xe.withTextureFramebuffer;
        we("readable", function (Ne, Ie) {
          j.texImage2D(
            j.TEXTURE_2D,
            0,
            j.RGBA,
            te,
            F,
            0,
            j.RGBA,
            j.UNSIGNED_BYTE,
            null
          ),
            Ae(Ne, Ie, function (rt) {
              q(te, F, V, ne, ae, J, j, rt, 0, 0, 0),
                j.readPixels(0, 0, te, F, j.RGBA, j.UNSIGNED_BYTE, le);
            });
        });
      });
      for (
        var fe = new Uint8Array(te * F), Ee = 0, ge = 0;
        Ee < le.length;
        Ee += 4
      )
        fe[ge++] = le[Ee];
      return fe;
    }
    function $(te, F, V, ne, ae, J, oe, de, le, fe) {
      J === void 0 && (J = 1),
        de === void 0 && (de = 0),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        q(te, F, V, ne, ae, J, oe, null, de, le, fe);
    }
    function q(te, F, V, ne, ae, J, oe, de, le, fe, Ee) {
      J === void 0 && (J = 1),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        Ee === void 0 && (Ee = 0),
        H(oe);
      var ge = [];
      o(V, function (xe, j, we, Ae) {
        ge.push(xe, j, we, Ae);
      }),
        (ge = new Float32Array(ge)),
        h(oe, function (xe) {
          var j = xe.gl,
            we = xe.isWebGL2,
            Ae = xe.getExtension,
            Ne = xe.withProgram,
            Ie = xe.withTexture,
            rt = xe.withTextureFramebuffer,
            ke = xe.handleContextLoss;
          if (
            (Ie("rawDistances", function (Xe, ee) {
              (te !== Xe._lastWidth || F !== Xe._lastHeight) &&
                j.texImage2D(
                  j.TEXTURE_2D,
                  0,
                  j.RGBA,
                  (Xe._lastWidth = te),
                  (Xe._lastHeight = F),
                  0,
                  j.RGBA,
                  j.UNSIGNED_BYTE,
                  null
                ),
                Ne("main", E, A, function (B) {
                  var ve = B.setAttribute,
                    Se = B.setUniform,
                    _e = !we && Ae("ANGLE_instanced_arrays"),
                    Te = !we && Ae("EXT_blend_minmax");
                  ve("aUV", 2, j.STATIC_DRAW, 0, k),
                    ve("aLineSegment", 4, j.DYNAMIC_DRAW, 1, ge),
                    Se.apply(void 0, ["4f", "uGlyphBounds"].concat(ne)),
                    Se("1f", "uMaxDistance", ae),
                    Se("1f", "uExponent", J),
                    rt(Xe, ee, function (at) {
                      j.enable(j.BLEND),
                        j.colorMask(!0, !0, !0, !0),
                        j.viewport(0, 0, te, F),
                        j.scissor(0, 0, te, F),
                        j.blendFunc(j.ONE, j.ONE),
                        j.blendEquationSeparate(
                          j.FUNC_ADD,
                          we ? j.MAX : Te.MAX_EXT
                        ),
                        j.clear(j.COLOR_BUFFER_BIT),
                        we
                          ? j.drawArraysInstanced(
                              j.TRIANGLES,
                              0,
                              3,
                              ge.length / 4
                            )
                          : _e.drawArraysInstancedANGLE(
                              j.TRIANGLES,
                              0,
                              3,
                              ge.length / 4
                            );
                    });
                }),
                Ne("post", s, R, function (B) {
                  B.setAttribute("aUV", 2, j.STATIC_DRAW, 0, k),
                    B.setUniform("1i", "tex", ee),
                    j.bindFramebuffer(j.FRAMEBUFFER, de),
                    j.disable(j.BLEND),
                    j.colorMask(Ee === 0, Ee === 1, Ee === 2, Ee === 3),
                    j.viewport(le, fe, te, F),
                    j.scissor(le, fe, te, F),
                    j.drawArrays(j.TRIANGLES, 0, 3);
                });
            }),
            j.isContextLost())
          )
            throw (ke(), new Error("webgl context lost"));
        });
    }
    function Z(te) {
      var F = !te || te === P ? N : te.canvas || te,
        V = L.get(F);
      if (V === void 0) {
        U = !0;
        var ne = null;
        try {
          var ae = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            J = G(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, te);
          (V =
            J &&
            ae.length === J.length &&
            J.every(function (oe, de) {
              return oe === ae[de];
            })),
            V || ((ne = "bad trial run results"), console.info(ae, J));
        } catch (oe) {
          (V = !1), (ne = oe.message);
        }
        ne && console.warn("WebGL SDF generation not supported:", ne),
          (U = !1),
          L.set(F, V);
      }
      return V;
    }
    var X = Object.freeze({
      __proto__: null,
      generate: G,
      generateIntoCanvas: $,
      generateIntoFramebuffer: q,
      isSupported: Z,
    });
    function re(te, F, V, ne, ae, J) {
      ae === void 0 && (ae = Math.max(ne[2] - ne[0], ne[3] - ne[1]) / 2),
        J === void 0 && (J = 1);
      try {
        return G.apply(X, arguments);
      } catch (oe) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", oe),
          x.apply(T, arguments)
        );
      }
    }
    function W(te, F, V, ne, ae, J, oe, de, le, fe) {
      ae === void 0 && (ae = Math.max(ne[2] - ne[0], ne[3] - ne[1]) / 2),
        J === void 0 && (J = 1),
        de === void 0 && (de = 0),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0);
      try {
        return $.apply(X, arguments);
      } catch (Ee) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", Ee),
          S.apply(T, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = i),
      (e.generate = re),
      (e.generateIntoCanvas = W),
      (e.javascript = T),
      (e.pathToLineSegments = o),
      (e.webgl = X),
      (e.webglUtils = y),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
function MW() {
  var n = (function (e) {
    var t = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      r = {},
      i = {};
    (r.L = 1),
      (i[1] = "L"),
      Object.keys(t).forEach(function (ke, Xe) {
        (r[ke] = 1 << (Xe + 1)), (i[r[ke]] = ke);
      }),
      Object.freeze(r);
    var o = r.LRI | r.RLI | r.FSI,
      s = r.L | r.R | r.AL,
      l = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI,
      u = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF,
      f = r.S | r.WS | r.B | o | r.PDI | u,
      h = null;
    function m() {
      if (!h) {
        h = new Map();
        var ke = function (ee) {
          if (t.hasOwnProperty(ee)) {
            var B = 0;
            t[ee].split(",").forEach(function (ve) {
              var Se = ve.split("+"),
                _e = Se[0],
                Te = Se[1];
              (_e = parseInt(_e, 36)),
                (Te = Te ? parseInt(Te, 36) : 0),
                h.set((B += _e), r[ee]);
              for (var at = 0; at < Te; at++) h.set(++B, r[ee]);
            });
          }
        };
        for (var Xe in t) ke(Xe);
      }
    }
    function g(ke) {
      return m(), h.get(ke.codePointAt(0)) || r.L;
    }
    function y(ke) {
      return i[g(ke)];
    }
    var x = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function S(ke, Xe) {
      var ee = 36,
        B = 0,
        ve = new Map(),
        Se = Xe && new Map(),
        _e;
      return (
        ke.split(",").forEach(function Te(at) {
          if (at.indexOf("+") !== -1) for (var Fe = +at; Fe--; ) Te(_e);
          else {
            _e = at;
            var Be = at.split(">"),
              We = Be[0],
              Ye = Be[1];
            (We = String.fromCodePoint((B += parseInt(We, ee)))),
              (Ye = String.fromCodePoint((B += parseInt(Ye, ee)))),
              ve.set(We, Ye),
              Xe && Se.set(Ye, We);
          }
        }),
        { map: ve, reverseMap: Se }
      );
    }
    var _, w, T;
    function E() {
      if (!_) {
        var ke = S(x.pairs, !0),
          Xe = ke.map,
          ee = ke.reverseMap;
        (_ = Xe), (w = ee), (T = S(x.canonical, !1).map);
      }
    }
    function A(ke) {
      return E(), _.get(ke) || null;
    }
    function R(ke) {
      return E(), w.get(ke) || null;
    }
    function k(ke) {
      return E(), T.get(ke) || null;
    }
    var P = r.L,
      U = r.R,
      N = r.EN,
      L = r.ES,
      H = r.ET,
      G = r.AN,
      $ = r.CS,
      q = r.B,
      Z = r.S,
      X = r.ON,
      re = r.BN,
      W = r.NSM,
      te = r.AL,
      F = r.LRO,
      V = r.RLO,
      ne = r.LRE,
      ae = r.RLE,
      J = r.PDF,
      oe = r.LRI,
      de = r.RLI,
      le = r.FSI,
      fe = r.PDI;
    function Ee(ke, Xe) {
      for (
        var ee = 125, B = new Uint32Array(ke.length), ve = 0;
        ve < ke.length;
        ve++
      )
        B[ve] = g(ke[ve]);
      var Se = new Map();
      function _e(_r, Ir) {
        var cr = B[_r];
        (B[_r] = Ir),
          Se.set(cr, Se.get(cr) - 1),
          cr & l && Se.set(l, Se.get(l) - 1),
          Se.set(Ir, (Se.get(Ir) || 0) + 1),
          Ir & l && Se.set(l, (Se.get(l) || 0) + 1);
      }
      for (
        var Te = new Uint8Array(ke.length),
          at = new Map(),
          Fe = [],
          Be = null,
          We = 0;
        We < ke.length;
        We++
      )
        Be ||
          Fe.push(
            (Be = {
              start: We,
              end: ke.length - 1,
              level: Xe === "rtl" ? 1 : Xe === "ltr" ? 0 : Wr(We, !1),
            })
          ),
          B[We] & q && ((Be.end = We), (Be = null));
      for (
        var Ye = ae | ne | V | F | o | fe | J | q,
          nt = function (_r) {
            return _r + (_r & 1 ? 1 : 2);
          },
          yt = function (_r) {
            return _r + (_r & 1 ? 2 : 1);
          },
          $e = 0;
        $e < Fe.length;
        $e++
      ) {
        Be = Fe[$e];
        var qe = [{ _level: Be.level, _override: 0, _isolate: 0 }],
          et = void 0,
          he = 0,
          Je = 0,
          me = 0;
        Se.clear();
        for (var Ve = Be.start; Ve <= Be.end; Ve++) {
          var Re = B[Ve];
          if (
            ((et = qe[qe.length - 1]),
            Se.set(Re, (Se.get(Re) || 0) + 1),
            Re & l && Se.set(l, (Se.get(l) || 0) + 1),
            Re & Ye)
          )
            if (Re & (ae | ne)) {
              Te[Ve] = et._level;
              var Ue = (Re === ae ? yt : nt)(et._level);
              Ue <= ee && !he && !Je
                ? qe.push({ _level: Ue, _override: 0, _isolate: 0 })
                : he || Je++;
            } else if (Re & (V | F)) {
              Te[Ve] = et._level;
              var it = (Re === V ? yt : nt)(et._level);
              it <= ee && !he && !Je
                ? qe.push({
                    _level: it,
                    _override: Re & V ? U : P,
                    _isolate: 0,
                  })
                : he || Je++;
            } else if (Re & o) {
              Re & le && (Re = Wr(Ve + 1, !0) === 1 ? de : oe),
                (Te[Ve] = et._level),
                et._override && _e(Ve, et._override);
              var mt = (Re === de ? yt : nt)(et._level);
              mt <= ee && he === 0 && Je === 0
                ? (me++,
                  qe.push({
                    _level: mt,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: Ve,
                  }))
                : he++;
            } else if (Re & fe) {
              if (he > 0) he--;
              else if (me > 0) {
                for (Je = 0; !qe[qe.length - 1]._isolate; ) qe.pop();
                var gt = qe[qe.length - 1]._isolInitIndex;
                gt != null && (at.set(gt, Ve), at.set(Ve, gt)), qe.pop(), me--;
              }
              (et = qe[qe.length - 1]),
                (Te[Ve] = et._level),
                et._override && _e(Ve, et._override);
            } else
              Re & J
                ? (he === 0 &&
                    (Je > 0
                      ? Je--
                      : !et._isolate &&
                        qe.length > 1 &&
                        (qe.pop(), (et = qe[qe.length - 1]))),
                  (Te[Ve] = et._level))
                : Re & q && (Te[Ve] = Be.level);
          else
            (Te[Ve] = et._level),
              et._override && Re !== re && _e(Ve, et._override);
        }
        for (var Ot = [], Ut = null, ht = Be.start; ht <= Be.end; ht++) {
          var $t = B[ht];
          if (!($t & u)) {
            var un = Te[ht],
              Sn = $t & o,
              mn = $t === fe;
            Ut && un === Ut._level
              ? ((Ut._end = ht), (Ut._endsWithIsolInit = Sn))
              : Ot.push(
                  (Ut = {
                    _start: ht,
                    _end: ht,
                    _level: un,
                    _startsWithPDI: mn,
                    _endsWithIsolInit: Sn,
                  })
                );
          }
        }
        for (var lr = [], Ui = 0; Ui < Ot.length; Ui++) {
          var yr = Ot[Ui];
          if (!yr._startsWithPDI || (yr._startsWithPDI && !at.has(yr._start))) {
            for (
              var Fr = [(Ut = yr)], Ar = void 0;
              Ut && Ut._endsWithIsolInit && (Ar = at.get(Ut._end)) != null;

            )
              for (var Br = Ui + 1; Br < Ot.length; Br++)
                if (Ot[Br]._start === Ar) {
                  Fr.push((Ut = Ot[Br]));
                  break;
                }
            for (var xr = [], yo = 0; yo < Fr.length; yo++)
              for (var Vl = Fr[yo], no = Vl._start; no <= Vl._end; no++)
                xr.push(no);
            for (
              var Gl = Te[xr[0]], ie = Be.level, Ce = xr[0] - 1;
              Ce >= 0;
              Ce--
            )
              if (!(B[Ce] & u)) {
                ie = Te[Ce];
                break;
              }
            var ze = xr[xr.length - 1],
              Ge = Te[ze],
              Le = Be.level;
            if (!(B[ze] & o)) {
              for (var ut = ze + 1; ut <= Be.end; ut++)
                if (!(B[ut] & u)) {
                  Le = Te[ut];
                  break;
                }
            }
            lr.push({
              _seqIndices: xr,
              _sosType: Math.max(ie, Gl) % 2 ? U : P,
              _eosType: Math.max(Le, Ge) % 2 ? U : P,
            });
          }
        }
        for (var vt = 0; vt < lr.length; vt++) {
          var Et = lr[vt],
            Ke = Et._seqIndices,
            Dt = Et._sosType,
            Ft = Et._eosType,
            At = Te[Ke[0]] & 1 ? U : P;
          if (Se.get(W))
            for (var nn = 0; nn < Ke.length; nn++) {
              var Cn = Ke[nn];
              if (B[Cn] & W) {
                for (var dn = Dt, wn = nn - 1; wn >= 0; wn--)
                  if (!(B[Ke[wn]] & u)) {
                    dn = B[Ke[wn]];
                    break;
                  }
                _e(Cn, dn & (o | fe) ? X : dn);
              }
            }
          if (Se.get(N))
            for (var wt = 0; wt < Ke.length; wt++) {
              var dt = Ke[wt];
              if (B[dt] & N)
                for (var Qt = wt - 1; Qt >= -1; Qt--) {
                  var zt = Qt === -1 ? Dt : B[Ke[Qt]];
                  if (zt & s) {
                    zt === te && _e(dt, G);
                    break;
                  }
                }
            }
          if (Se.get(te))
            for (var bn = 0; bn < Ke.length; bn++) {
              var ii = Ke[bn];
              B[ii] & te && _e(ii, U);
            }
          if (Se.get(L) || Se.get($))
            for (var An = 1; An < Ke.length - 1; An++) {
              var Wn = Ke[An];
              if (B[Wn] & (L | $)) {
                for (
                  var cn = 0, zr = 0, ls = An - 1;
                  ls >= 0 && ((cn = B[Ke[ls]]), !!(cn & u));
                  ls--
                );
                for (
                  var ur = An + 1;
                  ur < Ke.length && ((zr = B[Ke[ur]]), !!(zr & u));
                  ur++
                );
                cn === zr &&
                  (B[Wn] === L ? cn === N : cn & (N | G)) &&
                  _e(Wn, cn);
              }
            }
          if (Se.get(N))
            for (var Rr = 0; Rr < Ke.length; Rr++) {
              var di = Ke[Rr];
              if (B[di] & N) {
                for (var zo = Rr - 1; zo >= 0 && B[Ke[zo]] & (H | u); zo--)
                  _e(Ke[zo], N);
                for (Rr++; Rr < Ke.length && B[Ke[Rr]] & (H | u | N); Rr++)
                  B[Ke[Rr]] !== N && _e(Ke[Rr], N);
              }
            }
          if (Se.get(H) || Se.get(L) || Se.get($))
            for (var Ho = 0; Ho < Ke.length; Ho++) {
              var Pf = Ke[Ho];
              if (B[Pf] & (H | L | $)) {
                _e(Pf, X);
                for (var Vo = Ho - 1; Vo >= 0 && B[Ke[Vo]] & u; Vo--)
                  _e(Ke[Vo], X);
                for (var ln = Ho + 1; ln < Ke.length && B[Ke[ln]] & u; ln++)
                  _e(Ke[ln], X);
              }
            }
          if (Se.get(N))
            for (var us = 0, da = Dt; us < Ke.length; us++) {
              var Wl = Ke[us],
                jl = B[Wl];
              jl & N ? da === P && _e(Wl, P) : jl & s && (da = jl);
            }
          if (Se.get(l)) {
            var cs = U | N | G,
              Ka = cs | P,
              xo = [];
            {
              for (var Go = [], oi = 0; oi < Ke.length; oi++)
                if (B[Ke[oi]] & l) {
                  var Xt = ke[Ke[oi]],
                    _o = void 0;
                  if (A(Xt) !== null)
                    if (Go.length < 63) Go.push({ char: Xt, seqIndex: oi });
                    else break;
                  else if ((_o = R(Xt)) !== null)
                    for (var ro = Go.length - 1; ro >= 0; ro--) {
                      var fs = Go[ro].char;
                      if (fs === _o || fs === R(k(Xt)) || A(k(fs)) === Xt) {
                        xo.push([Go[ro].seqIndex, oi]), (Go.length = ro);
                        break;
                      }
                    }
                }
              xo.sort(function (_r, Ir) {
                return _r[0] - Ir[0];
              });
            }
            for (var So = 0; So < xo.length; So++) {
              for (
                var If = xo[So],
                  Yn = If[0],
                  Wo = If[1],
                  Lf = !1,
                  hi = 0,
                  ha = Yn + 1;
                ha < Wo;
                ha++
              ) {
                var pa = Ke[ha];
                if (B[pa] & Ka) {
                  Lf = !0;
                  var io = B[pa] & cs ? U : P;
                  if (io === At) {
                    hi = io;
                    break;
                  }
                }
              }
              if (Lf && !hi) {
                hi = Dt;
                for (var Is = Yn - 1; Is >= 0; Is--) {
                  var ma = Ke[Is];
                  if (B[ma] & Ka) {
                    var Hr = B[ma] & cs ? U : P;
                    Hr !== At ? (hi = Hr) : (hi = At);
                    break;
                  }
                }
              }
              if (hi) {
                if (((B[Ke[Yn]] = B[Ke[Wo]] = hi), hi !== At)) {
                  for (var Vr = Yn + 1; Vr < Ke.length; Vr++)
                    if (!(B[Ke[Vr]] & u)) {
                      g(ke[Ke[Vr]]) & W && (B[Ke[Vr]] = hi);
                      break;
                    }
                }
                if (hi !== At) {
                  for (var ds = Wo + 1; ds < Ke.length; ds++)
                    if (!(B[Ke[ds]] & u)) {
                      g(ke[Ke[ds]]) & W && (B[Ke[ds]] = hi);
                      break;
                    }
                }
              }
            }
            for (var wo = 0; wo < Ke.length; wo++)
              if (B[Ke[wo]] & l) {
                for (var Za = wo, ga = wo, pi = Dt, va = wo - 1; va >= 0; va--)
                  if (B[Ke[va]] & u) Za = va;
                  else {
                    pi = B[Ke[va]] & cs ? U : P;
                    break;
                  }
                for (var Fi = Ft, Ls = wo + 1; Ls < Ke.length; Ls++)
                  if (B[Ke[Ls]] & (l | u)) ga = Ls;
                  else {
                    Fi = B[Ke[Ls]] & cs ? U : P;
                    break;
                  }
                for (var Gr = Za; Gr <= ga; Gr++)
                  B[Ke[Gr]] = pi === Fi ? pi : At;
                wo = ga;
              }
          }
        }
        for (var Pr = Be.start; Pr <= Be.end; Pr++) {
          var ks = Te[Pr],
            Bi = B[Pr];
          if (
            (ks & 1
              ? Bi & (P | N | G) && Te[Pr]++
              : Bi & U
              ? Te[Pr]++
              : Bi & (G | N) && (Te[Pr] += 2),
            Bi & u && (Te[Pr] = Pr === 0 ? Be.level : Te[Pr - 1]),
            Pr === Be.end || g(ke[Pr]) & (Z | q))
          )
            for (var Ds = Pr; Ds >= 0 && g(ke[Ds]) & f; Ds--) Te[Ds] = Be.level;
        }
      }
      return { levels: Te, paragraphs: Fe };
      function Wr(_r, Ir) {
        for (var cr = _r; cr < ke.length; cr++) {
          var er = B[cr];
          if (er & (U | te)) return 1;
          if (er & (q | P) || (Ir && er === fe)) return 0;
          if (er & o) {
            var Si = Ns(cr);
            cr = Si === -1 ? ke.length : Si;
          }
        }
        return 0;
      }
      function Ns(_r) {
        for (var Ir = 1, cr = _r + 1; cr < ke.length; cr++) {
          var er = B[cr];
          if (er & q) break;
          if (er & fe) {
            if (--Ir === 0) return cr;
          } else er & o && Ir++;
        }
        return -1;
      }
    }
    var ge =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      xe;
    function j() {
      if (!xe) {
        var ke = S(ge, !0),
          Xe = ke.map,
          ee = ke.reverseMap;
        ee.forEach(function (B, ve) {
          Xe.set(ve, B);
        }),
          (xe = Xe);
      }
    }
    function we(ke) {
      return j(), xe.get(ke) || null;
    }
    function Ae(ke, Xe, ee, B) {
      var ve = ke.length;
      (ee = Math.max(0, ee == null ? 0 : +ee)),
        (B = Math.min(ve - 1, B == null ? ve - 1 : +B));
      for (var Se = new Map(), _e = ee; _e <= B; _e++)
        if (Xe[_e] & 1) {
          var Te = we(ke[_e]);
          Te !== null && Se.set(_e, Te);
        }
      return Se;
    }
    function Ne(ke, Xe, ee, B) {
      var ve = ke.length;
      (ee = Math.max(0, ee == null ? 0 : +ee)),
        (B = Math.min(ve - 1, B == null ? ve - 1 : +B));
      var Se = [];
      return (
        Xe.paragraphs.forEach(function (_e) {
          var Te = Math.max(ee, _e.start),
            at = Math.min(B, _e.end);
          if (Te < at) {
            for (
              var Fe = Xe.levels.slice(Te, at + 1), Be = at;
              Be >= Te && g(ke[Be]) & f;
              Be--
            )
              Fe[Be] = _e.level;
            for (var We = _e.level, Ye = 1 / 0, nt = 0; nt < Fe.length; nt++) {
              var yt = Fe[nt];
              yt > We && (We = yt), yt < Ye && (Ye = yt | 1);
            }
            for (var $e = We; $e >= Ye; $e--)
              for (var qe = 0; qe < Fe.length; qe++)
                if (Fe[qe] >= $e) {
                  for (var et = qe; qe + 1 < Fe.length && Fe[qe + 1] >= $e; )
                    qe++;
                  qe > et && Se.push([et + Te, qe + Te]);
                }
          }
        }),
        Se
      );
    }
    function Ie(ke, Xe, ee, B) {
      var ve = rt(ke, Xe, ee, B),
        Se = [].concat(ke);
      return (
        ve.forEach(function (_e, Te) {
          Se[Te] = (Xe.levels[_e] & 1 ? we(ke[_e]) : null) || ke[_e];
        }),
        Se.join("")
      );
    }
    function rt(ke, Xe, ee, B) {
      for (var ve = Ne(ke, Xe, ee, B), Se = [], _e = 0; _e < ke.length; _e++)
        Se[_e] = _e;
      return (
        ve.forEach(function (Te) {
          for (
            var at = Te[0],
              Fe = Te[1],
              Be = Se.slice(at, Fe + 1),
              We = Be.length;
            We--;

          )
            Se[Fe - We] = Be[We];
        }),
        Se
      );
    }
    return (
      (e.closingToOpeningBracket = R),
      (e.getBidiCharType = g),
      (e.getBidiCharTypeName = y),
      (e.getCanonicalBracket = k),
      (e.getEmbeddingLevels = Ee),
      (e.getMirroredCharacter = we),
      (e.getMirroredCharactersMap = Ae),
      (e.getReorderSegments = Ne),
      (e.getReorderedIndices = rt),
      (e.getReorderedString = Ie),
      (e.openingToClosingBracket = A),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
const bP = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function hS(n) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, i) {
    let o = on[i];
    return o ? hS(o) : r;
  }
  return n.replace(e, t);
}
const Li = [];
for (let n = 0; n < 256; n++) Li[n] = (n < 16 ? "0" : "") + n.toString(16);
function EW() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Li[n & 255] +
    Li[(n >> 8) & 255] +
    Li[(n >> 16) & 255] +
    Li[(n >> 24) & 255] +
    "-" +
    Li[e & 255] +
    Li[(e >> 8) & 255] +
    "-" +
    Li[((e >> 16) & 15) | 64] +
    Li[(e >> 24) & 255] +
    "-" +
    Li[(t & 63) | 128] +
    Li[(t >> 8) & 255] +
    "-" +
    Li[(t >> 16) & 255] +
    Li[(t >> 24) & 255] +
    Li[r & 255] +
    Li[(r >> 8) & 255] +
    Li[(r >> 16) & 255] +
    Li[(r >> 24) & 255]
  ).toUpperCase();
}
const Wc =
    Object.assign ||
    function () {
      let n = arguments[0];
      for (let e = 1, t = arguments.length; e < t; e++) {
        let r = arguments[e];
        if (r)
          for (let i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }
      return n;
    },
  TW = Date.now(),
  hC = new WeakMap(),
  pC = new Map();
let CW = 1e10;
function pS(n, e) {
  const t = IW(e);
  let r = hC.get(n);
  if ((r || hC.set(n, (r = Object.create(null))), r[t])) return new r[t]();
  const i = `_onBeforeCompile${t}`,
    o = function (f, h) {
      n.onBeforeCompile.call(this, f, h);
      const m =
        this.customProgramCacheKey() +
        "|" +
        f.vertexShader +
        "|" +
        f.fragmentShader;
      let g = pC[m];
      if (!g) {
        const y = AW(this, f, e, t);
        g = pC[m] = y;
      }
      (f.vertexShader = g.vertexShader),
        (f.fragmentShader = g.fragmentShader),
        Wc(f.uniforms, this.uniforms),
        e.timeUniform &&
          (f.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - TW;
            },
          }),
        this[i] && this[i](f);
    },
    s = function () {
      return l(e.chained ? n : n.clone());
    },
    l = function (f) {
      const h = Object.create(f, u);
      return (
        Object.defineProperty(h, "baseMaterial", { value: n }),
        Object.defineProperty(h, "id", { value: CW++ }),
        (h.uuid = EW()),
        (h.uniforms = Wc({}, f.uniforms, e.uniforms)),
        (h.defines = Wc({}, f.defines, e.defines)),
        (h.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = ""),
        (h.extensions = Wc({}, f.extensions, e.extensions)),
        (h._listeners = void 0),
        h
      );
    },
    u = {
      constructor: { value: s },
      isDerivedMaterial: { value: !0 },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return n.customProgramCacheKey() + "|" + t;
        },
      },
      onBeforeCompile: {
        get() {
          return o;
        },
        set(f) {
          this[i] = f;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (f) {
          return (
            n.copy.call(this, f),
            !n.isShaderMaterial &&
              !n.isDerivedMaterial &&
              (Wc(this.extensions, f.extensions),
              Wc(this.defines, f.defines),
              Wc(this.uniforms, xw.clone(f.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const f = new n.constructor();
          return l(f).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let f = this._depthMaterial;
          return (
            f ||
              ((f = this._depthMaterial =
                pS(
                  n.isDerivedMaterial
                    ? n.getDepthMaterial()
                    : new Gy({ depthPacking: hw }),
                  e
                )),
              (f.defines.IS_DEPTH_MATERIAL = ""),
              (f.uniforms = this.uniforms)),
            f
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let f = this._distanceMaterial;
          return (
            f ||
              ((f = this._distanceMaterial =
                pS(
                  n.isDerivedMaterial ? n.getDistanceMaterial() : new Wy(),
                  e
                )),
              (f.defines.IS_DISTANCE_MATERIAL = ""),
              (f.uniforms = this.uniforms)),
            f
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: f, _distanceMaterial: h } = this;
          f && f.dispose(), h && h.dispose(), n.dispose.call(this);
        },
      },
    };
  return (r[t] = s), new s();
}
function AW(n, { vertexShader: e, fragmentShader: t }, r, i) {
  let {
    vertexDefs: o,
    vertexMainIntro: s,
    vertexMainOutro: l,
    vertexTransform: u,
    fragmentDefs: f,
    fragmentMainIntro: h,
    fragmentMainOutro: m,
    fragmentColorTransform: g,
    customRewriter: y,
    timeUniform: x,
  } = r;
  if (
    ((o = o || ""),
    (s = s || ""),
    (l = l || ""),
    (f = f || ""),
    (h = h || ""),
    (m = m || ""),
    (u || y) && (e = hS(e)),
    (g || y) &&
      ((t = t.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (t = hS(t))),
    y)
  ) {
    let S = y({ vertexShader: e, fragmentShader: t });
    (e = S.vertexShader), (t = S.fragmentShader);
  }
  if (g) {
    let S = [];
    (t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (_) => (S.push(_), "")
    )),
      (m = `${g}
${S.join(`
`)}
${m}`);
  }
  if (x) {
    const S = `
uniform float ${x};
`;
    (o = S + o), (f = S + f);
  }
  return (
    u &&
      ((e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`),
      (o = `${o}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u}
}
`),
      (s = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${s}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (S, _, w, T) =>
        /\battribute\s+vec[23]\s+$/.test(T.substr(0, w))
          ? _
          : `troika_${_}_${i}`
      )),
      (n.map && n.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    (e = mC(e, i, o, s, l)),
    (t = mC(t, i, f, h, m)),
    { vertexShader: e, fragmentShader: t }
  );
}
function mC(n, e, t, r, i) {
  return (
    (r || i || t) &&
      ((n = n.replace(
        bP,
        `
${t}
void troikaOrigMain${e}() {`
      )),
      (n += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`)),
    n
  );
}
function RW(n, e) {
  return n === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let PW = 0;
const gC = new Map();
function IW(n) {
  const e = JSON.stringify(n, RW);
  let t = gC.get(e);
  return t == null && gC.set(e, (t = ++PW)), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function LW() {
  return (
    typeof window > "u" && (self.window = self),
    (function (n) {
      var e = {
        parse: function (i) {
          var o = e._bin,
            s = new Uint8Array(i);
          if (o.readASCII(s, 0, 4) == "ttcf") {
            var l = 4;
            o.readUshort(s, l), (l += 2), o.readUshort(s, l), (l += 2);
            var u = o.readUint(s, l);
            l += 4;
            for (var f = [], h = 0; h < u; h++) {
              var m = o.readUint(s, l);
              (l += 4), f.push(e._readFont(s, m));
            }
            return f;
          }
          return [e._readFont(s, 0)];
        },
        _readFont: function (i, o) {
          var s = e._bin,
            l = o;
          s.readFixed(i, o), (o += 4);
          var u = s.readUshort(i, o);
          (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2);
          for (
            var f = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              h = { _data: i, _offset: l },
              m = {},
              g = 0;
            g < u;
            g++
          ) {
            var y = s.readASCII(i, o, 4);
            (o += 4), s.readUint(i, o), (o += 4);
            var x = s.readUint(i, o);
            o += 4;
            var S = s.readUint(i, o);
            (o += 4), (m[y] = { offset: x, length: S });
          }
          for (g = 0; g < f.length; g++) {
            var _ = f[g];
            m[_] &&
              (h[_.trim()] = e[_.trim()].parse(i, m[_].offset, m[_].length, h));
          }
          return h;
        },
        _tabOffset: function (i, o, s) {
          for (
            var l = e._bin, u = l.readUshort(i, s + 4), f = s + 12, h = 0;
            h < u;
            h++
          ) {
            var m = l.readASCII(i, f, 4);
            (f += 4), l.readUint(i, f), (f += 4);
            var g = l.readUint(i, f);
            if (((f += 4), l.readUint(i, f), (f += 4), m == o)) return g;
          }
          return 0;
        },
      };
      (e._bin = {
        readFixed: function (i, o) {
          return (
            ((i[o] << 8) | i[o + 1]) + ((i[o + 2] << 8) | i[o + 3]) / 65540
          );
        },
        readF2dot14: function (i, o) {
          return e._bin.readShort(i, o) / 16384;
        },
        readInt: function (i, o) {
          return e._bin._view(i).getInt32(o);
        },
        readInt8: function (i, o) {
          return e._bin._view(i).getInt8(o);
        },
        readShort: function (i, o) {
          return e._bin._view(i).getInt16(o);
        },
        readUshort: function (i, o) {
          return e._bin._view(i).getUint16(o);
        },
        readUshorts: function (i, o, s) {
          for (var l = [], u = 0; u < s; u++)
            l.push(e._bin.readUshort(i, o + 2 * u));
          return l;
        },
        readUint: function (i, o) {
          return e._bin._view(i).getUint32(o);
        },
        readUint64: function (i, o) {
          return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4);
        },
        readASCII: function (i, o, s) {
          for (var l = "", u = 0; u < s; u++)
            l += String.fromCharCode(i[o + u]);
          return l;
        },
        readUnicode: function (i, o, s) {
          for (var l = "", u = 0; u < s; u++) {
            var f = (i[o++] << 8) | i[o++];
            l += String.fromCharCode(f);
          }
          return l;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (i, o, s) {
          var l = e._bin._tdec;
          return l && o == 0 && s == i.length
            ? l.decode(i)
            : e._bin.readASCII(i, o, s);
        },
        readBytes: function (i, o, s) {
          for (var l = [], u = 0; u < s; u++) l.push(i[o + u]);
          return l;
        },
        readASCIIArray: function (i, o, s) {
          for (var l = [], u = 0; u < s; u++)
            l.push(String.fromCharCode(i[o + u]));
          return l;
        },
        _view: function (i) {
          return (
            i._dataView ||
            (i._dataView = i.buffer
              ? new DataView(i.buffer, i.byteOffset, i.byteLength)
              : new DataView(new Uint8Array(i).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (i, o, s, l, u) {
          var f = e._bin,
            h = {},
            m = o;
          f.readFixed(i, o), (o += 4);
          var g = f.readUshort(i, o);
          o += 2;
          var y = f.readUshort(i, o);
          o += 2;
          var x = f.readUshort(i, o);
          return (
            (o += 2),
            (h.scriptList = e._lctf.readScriptList(i, m + g)),
            (h.featureList = e._lctf.readFeatureList(i, m + y)),
            (h.lookupList = e._lctf.readLookupList(i, m + x, u)),
            h
          );
        }),
        (e._lctf.readLookupList = function (i, o, s) {
          var l = e._bin,
            u = o,
            f = [],
            h = l.readUshort(i, o);
          o += 2;
          for (var m = 0; m < h; m++) {
            var g = l.readUshort(i, o);
            o += 2;
            var y = e._lctf.readLookupTable(i, u + g, s);
            f.push(y);
          }
          return f;
        }),
        (e._lctf.readLookupTable = function (i, o, s) {
          var l = e._bin,
            u = o,
            f = { tabs: [] };
          (f.ltype = l.readUshort(i, o)),
            (o += 2),
            (f.flag = l.readUshort(i, o)),
            (o += 2);
          var h = l.readUshort(i, o);
          o += 2;
          for (var m = f.ltype, g = 0; g < h; g++) {
            var y = l.readUshort(i, o);
            o += 2;
            var x = s(i, m, u + y, f);
            f.tabs.push(x);
          }
          return f;
        }),
        (e._lctf.numOfOnes = function (i) {
          for (var o = 0, s = 0; s < 32; s++) ((i >>> s) & 1) != 0 && o++;
          return o;
        }),
        (e._lctf.readClassDef = function (i, o) {
          var s = e._bin,
            l = [],
            u = s.readUshort(i, o);
          if (((o += 2), u == 1)) {
            var f = s.readUshort(i, o);
            o += 2;
            var h = s.readUshort(i, o);
            o += 2;
            for (var m = 0; m < h; m++)
              l.push(f + m),
                l.push(f + m),
                l.push(s.readUshort(i, o)),
                (o += 2);
          }
          if (u == 2) {
            var g = s.readUshort(i, o);
            for (o += 2, m = 0; m < g; m++)
              l.push(s.readUshort(i, o)),
                (o += 2),
                l.push(s.readUshort(i, o)),
                (o += 2),
                l.push(s.readUshort(i, o)),
                (o += 2);
          }
          return l;
        }),
        (e._lctf.getInterval = function (i, o) {
          for (var s = 0; s < i.length; s += 3) {
            var l = i[s],
              u = i[s + 1];
            if ((i[s + 2], l <= o && o <= u)) return s;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (i, o) {
          var s = e._bin,
            l = {};
          (l.fmt = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          return (
            (o += 2),
            l.fmt == 1 && (l.tab = s.readUshorts(i, o, u)),
            l.fmt == 2 && (l.tab = s.readUshorts(i, o, 3 * u)),
            l
          );
        }),
        (e._lctf.coverageIndex = function (i, o) {
          var s = i.tab;
          if (i.fmt == 1) return s.indexOf(o);
          if (i.fmt == 2) {
            var l = e._lctf.getInterval(s, o);
            if (l != -1) return s[l + 2] + (o - s[l]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (i, o) {
          var s = e._bin,
            l = o,
            u = [],
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readASCII(i, o, 4);
            o += 4;
            var g = s.readUshort(i, o);
            o += 2;
            var y = e._lctf.readFeatureTable(i, l + g);
            (y.tag = m.trim()), u.push(y);
          }
          return u;
        }),
        (e._lctf.readFeatureTable = function (i, o) {
          var s = e._bin,
            l = o,
            u = {},
            f = s.readUshort(i, o);
          (o += 2), f > 0 && (u.featureParams = l + f);
          var h = s.readUshort(i, o);
          (o += 2), (u.tab = []);
          for (var m = 0; m < h; m++) u.tab.push(s.readUshort(i, o + 2 * m));
          return u;
        }),
        (e._lctf.readScriptList = function (i, o) {
          var s = e._bin,
            l = o,
            u = {},
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readASCII(i, o, 4);
            o += 4;
            var g = s.readUshort(i, o);
            (o += 2), (u[m.trim()] = e._lctf.readScriptTable(i, l + g));
          }
          return u;
        }),
        (e._lctf.readScriptTable = function (i, o) {
          var s = e._bin,
            l = o,
            u = {},
            f = s.readUshort(i, o);
          (o += 2), f > 0 && (u.default = e._lctf.readLangSysTable(i, l + f));
          var h = s.readUshort(i, o);
          o += 2;
          for (var m = 0; m < h; m++) {
            var g = s.readASCII(i, o, 4);
            o += 4;
            var y = s.readUshort(i, o);
            (o += 2), (u[g.trim()] = e._lctf.readLangSysTable(i, l + y));
          }
          return u;
        }),
        (e._lctf.readLangSysTable = function (i, o) {
          var s = e._bin,
            l = {};
          s.readUshort(i, o),
            (o += 2),
            (l.reqFeature = s.readUshort(i, o)),
            (o += 2);
          var u = s.readUshort(i, o);
          return (o += 2), (l.features = s.readUshorts(i, o, u)), l;
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (i, o, s) {
          var l = e._bin;
          (i = new Uint8Array(i.buffer, o, s))[(o = 0)],
            i[++o],
            i[++o],
            i[++o],
            o++;
          var u = [];
          o = e.CFF.readIndex(i, o, u);
          for (var f = [], h = 0; h < u.length - 1; h++)
            f.push(l.readASCII(i, o + u[h], u[h + 1] - u[h]));
          o += u[u.length - 1];
          var m = [];
          o = e.CFF.readIndex(i, o, m);
          var g = [];
          for (h = 0; h < m.length - 1; h++)
            g.push(e.CFF.readDict(i, o + m[h], o + m[h + 1]));
          o += m[m.length - 1];
          var y = g[0],
            x = [];
          o = e.CFF.readIndex(i, o, x);
          var S = [];
          for (h = 0; h < x.length - 1; h++)
            S.push(l.readASCII(i, o + x[h], x[h + 1] - x[h]));
          if (
            ((o += x[x.length - 1]), e.CFF.readSubrs(i, o, y), y.CharStrings)
          ) {
            (o = y.CharStrings), (x = []), (o = e.CFF.readIndex(i, o, x));
            var _ = [];
            for (h = 0; h < x.length - 1; h++)
              _.push(l.readBytes(i, o + x[h], x[h + 1] - x[h]));
            y.CharStrings = _;
          }
          if (y.ROS) {
            o = y.FDArray;
            var w = [];
            for (
              o = e.CFF.readIndex(i, o, w), y.FDArray = [], h = 0;
              h < w.length - 1;
              h++
            ) {
              var T = e.CFF.readDict(i, o + w[h], o + w[h + 1]);
              e.CFF._readFDict(i, T, S), y.FDArray.push(T);
            }
            (o += w[w.length - 1]), (o = y.FDSelect), (y.FDSelect = []);
            var E = i[o];
            if ((o++, E != 3)) throw E;
            var A = l.readUshort(i, o);
            for (o += 2, h = 0; h < A + 1; h++)
              y.FDSelect.push(l.readUshort(i, o), i[o + 2]), (o += 3);
          }
          return (
            y.Encoding &&
              (y.Encoding = e.CFF.readEncoding(
                i,
                y.Encoding,
                y.CharStrings.length
              )),
            y.charset &&
              (y.charset = e.CFF.readCharset(
                i,
                y.charset,
                y.CharStrings.length
              )),
            e.CFF._readFDict(i, y, S),
            y
          );
        }),
        (e.CFF._readFDict = function (i, o, s) {
          var l;
          for (var u in (o.Private &&
            ((l = o.Private[1]),
            (o.Private = e.CFF.readDict(i, l, l + o.Private[0])),
            o.Private.Subrs &&
              e.CFF.readSubrs(i, l + o.Private.Subrs, o.Private)),
          o))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(u) != -1 && (o[u] = s[o[u] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (i, o, s) {
          var l = e._bin,
            u = [];
          o = e.CFF.readIndex(i, o, u);
          var f,
            h = u.length;
          (f = h < 1240 ? 107 : h < 33900 ? 1131 : 32768),
            (s.Bias = f),
            (s.Subrs = []);
          for (var m = 0; m < u.length - 1; m++)
            s.Subrs.push(l.readBytes(i, o + u[m], u[m + 1] - u[m]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (i, o) {
          for (var s = 0; s < i.charset.length; s++)
            if (i.charset[s] == o) return s;
          return -1;
        }),
        (e.CFF.glyphBySE = function (i, o) {
          return o < 0 || o > 255
            ? -1
            : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]);
        }),
        (e.CFF.readEncoding = function (i, o, s) {
          e._bin;
          var l = [".notdef"],
            u = i[o];
          if ((o++, u != 0)) throw "error: unknown encoding format: " + u;
          var f = i[o];
          o++;
          for (var h = 0; h < f; h++) l.push(i[o + h]);
          return l;
        }),
        (e.CFF.readCharset = function (i, o, s) {
          var l = e._bin,
            u = [".notdef"],
            f = i[o];
          if ((o++, f == 0))
            for (var h = 0; h < s; h++) {
              var m = l.readUshort(i, o);
              (o += 2), u.push(m);
            }
          else {
            if (f != 1 && f != 2) throw "error: format: " + f;
            for (; u.length < s; ) {
              (m = l.readUshort(i, o)), (o += 2);
              var g = 0;
              for (
                f == 1
                  ? ((g = i[o]), o++)
                  : ((g = l.readUshort(i, o)), (o += 2)),
                  h = 0;
                h <= g;
                h++
              )
                u.push(m), m++;
            }
          }
          return u;
        }),
        (e.CFF.readIndex = function (i, o, s) {
          var l = e._bin,
            u = l.readUshort(i, o) + 1,
            f = i[(o += 2)];
          if ((o++, f == 1)) for (var h = 0; h < u; h++) s.push(i[o + h]);
          else if (f == 2)
            for (h = 0; h < u; h++) s.push(l.readUshort(i, o + 2 * h));
          else if (f == 3)
            for (h = 0; h < u; h++)
              s.push(16777215 & l.readUint(i, o + 3 * h - 1));
          else if (u != 1)
            throw "unsupported offset size: " + f + ", count: " + u;
          return (o += u * f) - 1;
        }),
        (e.CFF.getCharString = function (i, o, s) {
          var l = e._bin,
            u = i[o],
            f = i[o + 1];
          i[o + 2], i[o + 3], i[o + 4];
          var h = 1,
            m = null,
            g = null;
          u <= 20 && ((m = u), (h = 1)),
            u == 12 && ((m = 100 * u + f), (h = 2)),
            21 <= u && u <= 27 && ((m = u), (h = 1)),
            u == 28 && ((g = l.readShort(i, o + 1)), (h = 3)),
            29 <= u && u <= 31 && ((m = u), (h = 1)),
            32 <= u && u <= 246 && ((g = u - 139), (h = 1)),
            247 <= u && u <= 250 && ((g = 256 * (u - 247) + f + 108), (h = 2)),
            251 <= u && u <= 254 && ((g = 256 * -(u - 251) - f - 108), (h = 2)),
            u == 255 && ((g = l.readInt(i, o + 1) / 65535), (h = 5)),
            (s.val = g ?? "o" + m),
            (s.size = h);
        }),
        (e.CFF.readCharString = function (i, o, s) {
          for (var l = o + s, u = e._bin, f = []; o < l; ) {
            var h = i[o],
              m = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var g = 1,
              y = null,
              x = null;
            h <= 20 && ((y = h), (g = 1)),
              h == 12 && ((y = 100 * h + m), (g = 2)),
              (h != 19 && h != 20) || ((y = h), (g = 2)),
              21 <= h && h <= 27 && ((y = h), (g = 1)),
              h == 28 && ((x = u.readShort(i, o + 1)), (g = 3)),
              29 <= h && h <= 31 && ((y = h), (g = 1)),
              32 <= h && h <= 246 && ((x = h - 139), (g = 1)),
              247 <= h &&
                h <= 250 &&
                ((x = 256 * (h - 247) + m + 108), (g = 2)),
              251 <= h &&
                h <= 254 &&
                ((x = 256 * -(h - 251) - m - 108), (g = 2)),
              h == 255 && ((x = u.readInt(i, o + 1) / 65535), (g = 5)),
              f.push(x ?? "o" + y),
              (o += g);
          }
          return f;
        }),
        (e.CFF.readDict = function (i, o, s) {
          for (var l = e._bin, u = {}, f = []; o < s; ) {
            var h = i[o],
              m = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var g = 1,
              y = null,
              x = null;
            if (
              (h == 28 && ((x = l.readShort(i, o + 1)), (g = 3)),
              h == 29 && ((x = l.readInt(i, o + 1)), (g = 5)),
              32 <= h && h <= 246 && ((x = h - 139), (g = 1)),
              247 <= h &&
                h <= 250 &&
                ((x = 256 * (h - 247) + m + 108), (g = 2)),
              251 <= h &&
                h <= 254 &&
                ((x = 256 * -(h - 251) - m - 108), (g = 2)),
              h == 255)
            )
              throw (
                ((x = l.readInt(i, o + 1) / 65535), (g = 5), "unknown number")
              );
            if (h == 30) {
              var S = [];
              for (g = 1; ; ) {
                var _ = i[o + g];
                g++;
                var w = _ >> 4,
                  T = 15 & _;
                if ((w != 15 && S.push(w), T != 15 && S.push(T), T == 15))
                  break;
              }
              for (
                var E = "",
                  A = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  R = 0;
                R < S.length;
                R++
              )
                E += A[S[R]];
              x = parseFloat(E);
            }
            h <= 21 &&
              ((y = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][h]),
              (g = 1),
              h == 12 &&
                ((y = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][m]),
                (g = 2))),
              y != null
                ? ((u[y] = f.length == 1 ? f[0] : f), (f = []))
                : f.push(x),
              (o += g);
          }
          return u;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (i, o, s) {
          (i = new Uint8Array(i.buffer, o, s)), (o = 0);
          var l = e._bin,
            u = {};
          l.readUshort(i, o), (o += 2);
          var f = l.readUshort(i, o);
          o += 2;
          var h = [];
          u.tables = [];
          for (var m = 0; m < f; m++) {
            var g = l.readUshort(i, o);
            o += 2;
            var y = l.readUshort(i, o);
            o += 2;
            var x = l.readUint(i, o);
            o += 4;
            var S = "p" + g + "e" + y,
              _ = h.indexOf(x);
            if (_ == -1) {
              var w;
              (_ = u.tables.length), h.push(x);
              var T = l.readUshort(i, x);
              T == 0
                ? (w = e.cmap.parse0(i, x))
                : T == 4
                ? (w = e.cmap.parse4(i, x))
                : T == 6
                ? (w = e.cmap.parse6(i, x))
                : T == 12
                ? (w = e.cmap.parse12(i, x))
                : console.debug("unknown format: " + T, g, y, x),
                u.tables.push(w);
            }
            if (u[S] != null) throw "multiple tables for one platform+encoding";
            u[S] = _;
          }
          return u;
        }),
        (e.cmap.parse0 = function (i, o) {
          var s = e._bin,
            l = {};
          (l.format = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2), (l.map = []);
          for (var f = 0; f < u - 6; f++) l.map.push(i[o + f]);
          return l;
        }),
        (e.cmap.parse4 = function (i, o) {
          var s = e._bin,
            l = o,
            u = {};
          (u.format = s.readUshort(i, o)), (o += 2);
          var f = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2);
          var h = s.readUshort(i, o);
          o += 2;
          var m = h / 2;
          (u.searchRange = s.readUshort(i, o)),
            (o += 2),
            (u.entrySelector = s.readUshort(i, o)),
            (o += 2),
            (u.rangeShift = s.readUshort(i, o)),
            (o += 2),
            (u.endCount = s.readUshorts(i, o, m)),
            (o += 2 * m),
            (o += 2),
            (u.startCount = s.readUshorts(i, o, m)),
            (o += 2 * m),
            (u.idDelta = []);
          for (var g = 0; g < m; g++)
            u.idDelta.push(s.readShort(i, o)), (o += 2);
          for (
            u.idRangeOffset = s.readUshorts(i, o, m),
              o += 2 * m,
              u.glyphIdArray = [];
            o < l + f;

          )
            u.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return u;
        }),
        (e.cmap.parse6 = function (i, o) {
          var s = e._bin,
            l = {};
          (l.format = s.readUshort(i, o)),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            (l.firstCode = s.readUshort(i, o)),
            (o += 2);
          var u = s.readUshort(i, o);
          (o += 2), (l.glyphIdArray = []);
          for (var f = 0; f < u; f++)
            l.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return l;
        }),
        (e.cmap.parse12 = function (i, o) {
          var s = e._bin,
            l = {};
          (l.format = s.readUshort(i, o)),
            (o += 2),
            (o += 2),
            s.readUint(i, o),
            (o += 4),
            s.readUint(i, o),
            (o += 4);
          var u = s.readUint(i, o);
          (o += 4), (l.groups = []);
          for (var f = 0; f < u; f++) {
            var h = o + 12 * f,
              m = s.readUint(i, h + 0),
              g = s.readUint(i, h + 4),
              y = s.readUint(i, h + 8);
            l.groups.push([m, g, y]);
          }
          return l;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (i, o, s, l) {
          for (var u = [], f = 0; f < l.maxp.numGlyphs; f++) u.push(null);
          return u;
        }),
        (e.glyf._parseGlyf = function (i, o) {
          var s = e._bin,
            l = i._data,
            u = e._tabOffset(l, "glyf", i._offset) + i.loca[o];
          if (i.loca[o] == i.loca[o + 1]) return null;
          var f = {};
          if (
            ((f.noc = s.readShort(l, u)),
            (u += 2),
            (f.xMin = s.readShort(l, u)),
            (u += 2),
            (f.yMin = s.readShort(l, u)),
            (u += 2),
            (f.xMax = s.readShort(l, u)),
            (u += 2),
            (f.yMax = s.readShort(l, u)),
            (u += 2),
            f.xMin >= f.xMax || f.yMin >= f.yMax)
          )
            return null;
          if (f.noc > 0) {
            f.endPts = [];
            for (var h = 0; h < f.noc; h++)
              f.endPts.push(s.readUshort(l, u)), (u += 2);
            var m = s.readUshort(l, u);
            if (((u += 2), l.length - u < m)) return null;
            (f.instructions = s.readBytes(l, u, m)), (u += m);
            var g = f.endPts[f.noc - 1] + 1;
            for (f.flags = [], h = 0; h < g; h++) {
              var y = l[u];
              if ((u++, f.flags.push(y), (8 & y) != 0)) {
                var x = l[u];
                u++;
                for (var S = 0; S < x; S++) f.flags.push(y), h++;
              }
            }
            for (f.xs = [], h = 0; h < g; h++) {
              var _ = (2 & f.flags[h]) != 0,
                w = (16 & f.flags[h]) != 0;
              _
                ? (f.xs.push(w ? l[u] : -l[u]), u++)
                : w
                ? f.xs.push(0)
                : (f.xs.push(s.readShort(l, u)), (u += 2));
            }
            for (f.ys = [], h = 0; h < g; h++)
              (_ = (4 & f.flags[h]) != 0),
                (w = (32 & f.flags[h]) != 0),
                _
                  ? (f.ys.push(w ? l[u] : -l[u]), u++)
                  : w
                  ? f.ys.push(0)
                  : (f.ys.push(s.readShort(l, u)), (u += 2));
            var T = 0,
              E = 0;
            for (h = 0; h < g; h++)
              (T += f.xs[h]), (E += f.ys[h]), (f.xs[h] = T), (f.ys[h] = E);
          } else {
            var A;
            f.parts = [];
            do {
              (A = s.readUshort(l, u)), (u += 2);
              var R = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (f.parts.push(R),
                (R.glyphIndex = s.readUshort(l, u)),
                (u += 2),
                1 & A)
              ) {
                var k = s.readShort(l, u);
                u += 2;
                var P = s.readShort(l, u);
                u += 2;
              } else (k = s.readInt8(l, u)), u++, (P = s.readInt8(l, u)), u++;
              2 & A ? ((R.m.tx = k), (R.m.ty = P)) : ((R.p1 = k), (R.p2 = P)),
                8 & A
                  ? ((R.m.a = R.m.d = s.readF2dot14(l, u)), (u += 2))
                  : 64 & A
                  ? ((R.m.a = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.d = s.readF2dot14(l, u)),
                    (u += 2))
                  : 128 & A &&
                    ((R.m.a = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.b = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.c = s.readF2dot14(l, u)),
                    (u += 2),
                    (R.m.d = s.readF2dot14(l, u)),
                    (u += 2));
            } while (32 & A);
            if (256 & A) {
              var U = s.readUshort(l, u);
              for (u += 2, f.instr = [], h = 0; h < U; h++)
                f.instr.push(l[u]), u++;
            }
          }
          return f;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (i, o, s, l) {
          var u = o;
          o += 4;
          var f = e._bin.readUshort(i, o);
          return {
            glyphClassDef: f === 0 ? null : e._lctf.readClassDef(i, u + f),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (i, o, s, l) {
          return e._lctf.parse(i, o, s, l, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (i, o, s, l) {
          var u = e._bin,
            f = s,
            h = {};
          if (
            ((h.fmt = u.readUshort(i, s)),
            (s += 2),
            o == 1 || o == 2 || o == 3 || o == 7 || (o == 8 && h.fmt <= 2))
          ) {
            var m = u.readUshort(i, s);
            (s += 2), (h.coverage = e._lctf.readCoverage(i, m + f));
          }
          if (o == 1 && h.fmt == 1) {
            var g = u.readUshort(i, s);
            (s += 2), g != 0 && (h.pos = e.GPOS.readValueRecord(i, s, g));
          } else if (o == 2 && h.fmt >= 1 && h.fmt <= 2) {
            (g = u.readUshort(i, s)), (s += 2);
            var y = u.readUshort(i, s);
            s += 2;
            var x = e._lctf.numOfOnes(g),
              S = e._lctf.numOfOnes(y);
            if (h.fmt == 1) {
              h.pairsets = [];
              var _ = u.readUshort(i, s);
              s += 2;
              for (var w = 0; w < _; w++) {
                var T = f + u.readUshort(i, s);
                s += 2;
                var E = u.readUshort(i, T);
                T += 2;
                for (var A = [], R = 0; R < E; R++) {
                  var k = u.readUshort(i, T);
                  (T += 2),
                    g != 0 &&
                      ((G = e.GPOS.readValueRecord(i, T, g)), (T += 2 * x)),
                    y != 0 &&
                      (($ = e.GPOS.readValueRecord(i, T, y)), (T += 2 * S)),
                    A.push({ gid2: k, val1: G, val2: $ });
                }
                h.pairsets.push(A);
              }
            }
            if (h.fmt == 2) {
              var P = u.readUshort(i, s);
              s += 2;
              var U = u.readUshort(i, s);
              s += 2;
              var N = u.readUshort(i, s);
              s += 2;
              var L = u.readUshort(i, s);
              for (
                s += 2,
                  h.classDef1 = e._lctf.readClassDef(i, f + P),
                  h.classDef2 = e._lctf.readClassDef(i, f + U),
                  h.matrix = [],
                  w = 0;
                w < N;
                w++
              ) {
                var H = [];
                for (R = 0; R < L; R++) {
                  var G = null,
                    $ = null;
                  g != 0 &&
                    ((G = e.GPOS.readValueRecord(i, s, g)), (s += 2 * x)),
                    y != 0 &&
                      (($ = e.GPOS.readValueRecord(i, s, y)), (s += 2 * S)),
                    H.push({ val1: G, val2: $ });
                }
                h.matrix.push(H);
              }
            }
          } else if (o == 4 && h.fmt == 1)
            (h.markCoverage = e._lctf.readCoverage(i, u.readUshort(i, s) + f)),
              (h.baseCoverage = e._lctf.readCoverage(
                i,
                u.readUshort(i, s + 2) + f
              )),
              (h.markClassCount = u.readUshort(i, s + 4)),
              (h.markArray = e.GPOS.readMarkArray(
                i,
                u.readUshort(i, s + 6) + f
              )),
              (h.baseArray = e.GPOS.readBaseArray(
                i,
                u.readUshort(i, s + 8) + f,
                h.markClassCount
              ));
          else if (o == 6 && h.fmt == 1)
            (h.mark1Coverage = e._lctf.readCoverage(i, u.readUshort(i, s) + f)),
              (h.mark2Coverage = e._lctf.readCoverage(
                i,
                u.readUshort(i, s + 2) + f
              )),
              (h.markClassCount = u.readUshort(i, s + 4)),
              (h.mark1Array = e.GPOS.readMarkArray(
                i,
                u.readUshort(i, s + 6) + f
              )),
              (h.mark2Array = e.GPOS.readBaseArray(
                i,
                u.readUshort(i, s + 8) + f,
                h.markClassCount
              ));
          else {
            if (o == 9 && h.fmt == 1) {
              var q = u.readUshort(i, s);
              s += 2;
              var Z = u.readUint(i, s);
              if (((s += 4), l.ltype == 9)) l.ltype = q;
              else if (l.ltype != q) throw "invalid extension substitution";
              return e.GPOS.subt(i, l.ltype, f + Z);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              o,
              "format",
              h.fmt
            );
          }
          return h;
        }),
        (e.GPOS.readValueRecord = function (i, o, s) {
          var l = e._bin,
            u = [];
          return (
            u.push(1 & s ? l.readShort(i, o) : 0),
            (o += 1 & s ? 2 : 0),
            u.push(2 & s ? l.readShort(i, o) : 0),
            (o += 2 & s ? 2 : 0),
            u.push(4 & s ? l.readShort(i, o) : 0),
            (o += 4 & s ? 2 : 0),
            u.push(8 & s ? l.readShort(i, o) : 0),
            (o += 8 & s ? 2 : 0),
            u
          );
        }),
        (e.GPOS.readBaseArray = function (i, o, s) {
          var l = e._bin,
            u = [],
            f = o,
            h = l.readUshort(i, o);
          o += 2;
          for (var m = 0; m < h; m++) {
            for (var g = [], y = 0; y < s; y++)
              g.push(e.GPOS.readAnchorRecord(i, f + l.readUshort(i, o))),
                (o += 2);
            u.push(g);
          }
          return u;
        }),
        (e.GPOS.readMarkArray = function (i, o) {
          var s = e._bin,
            l = [],
            u = o,
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = e.GPOS.readAnchorRecord(i, s.readUshort(i, o + 2) + u);
            (m.markClass = s.readUshort(i, o)), l.push(m), (o += 4);
          }
          return l;
        }),
        (e.GPOS.readAnchorRecord = function (i, o) {
          var s = e._bin,
            l = {};
          return (
            (l.fmt = s.readUshort(i, o)),
            (l.x = s.readShort(i, o + 2)),
            (l.y = s.readShort(i, o + 4)),
            l
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (i, o, s, l) {
          return e._lctf.parse(i, o, s, l, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (i, o, s, l) {
          var u = e._bin,
            f = s,
            h = {};
          if (
            ((h.fmt = u.readUshort(i, s)),
            (s += 2),
            o != 1 && o != 2 && o != 4 && o != 5 && o != 6)
          )
            return null;
          if (
            o == 1 ||
            o == 2 ||
            o == 4 ||
            (o == 5 && h.fmt <= 2) ||
            (o == 6 && h.fmt <= 2)
          ) {
            var m = u.readUshort(i, s);
            (s += 2), (h.coverage = e._lctf.readCoverage(i, f + m));
          }
          if (o == 1 && h.fmt >= 1 && h.fmt <= 2) {
            if (h.fmt == 1) (h.delta = u.readShort(i, s)), (s += 2);
            else if (h.fmt == 2) {
              var g = u.readUshort(i, s);
              (s += 2),
                (h.newg = u.readUshorts(i, s, g)),
                (s += 2 * h.newg.length);
            }
          } else if (o == 2 && h.fmt == 1) {
            (g = u.readUshort(i, s)), (s += 2), (h.seqs = []);
            for (var y = 0; y < g; y++) {
              var x = u.readUshort(i, s) + f;
              s += 2;
              var S = u.readUshort(i, x);
              h.seqs.push(u.readUshorts(i, x + 2, S));
            }
          } else if (o == 4)
            for (
              h.vals = [], g = u.readUshort(i, s), s += 2, y = 0;
              y < g;
              y++
            ) {
              var _ = u.readUshort(i, s);
              (s += 2), h.vals.push(e.GSUB.readLigatureSet(i, f + _));
            }
          else if (o == 5 && h.fmt == 2) {
            if (h.fmt == 2) {
              var w = u.readUshort(i, s);
              (s += 2),
                (h.cDef = e._lctf.readClassDef(i, f + w)),
                (h.scset = []);
              var T = u.readUshort(i, s);
              for (s += 2, y = 0; y < T; y++) {
                var E = u.readUshort(i, s);
                (s += 2),
                  h.scset.push(
                    E == 0 ? null : e.GSUB.readSubClassSet(i, f + E)
                  );
              }
            }
          } else if (o == 6 && h.fmt == 3) {
            if (h.fmt == 3) {
              for (y = 0; y < 3; y++) {
                (g = u.readUshort(i, s)), (s += 2);
                for (var A = [], R = 0; R < g; R++)
                  A.push(
                    e._lctf.readCoverage(i, f + u.readUshort(i, s + 2 * R))
                  );
                (s += 2 * g),
                  y == 0 && (h.backCvg = A),
                  y == 1 && (h.inptCvg = A),
                  y == 2 && (h.ahedCvg = A);
              }
              (g = u.readUshort(i, s)),
                (s += 2),
                (h.lookupRec = e.GSUB.readSubstLookupRecords(i, s, g));
            }
          } else {
            if (o == 7 && h.fmt == 1) {
              var k = u.readUshort(i, s);
              s += 2;
              var P = u.readUint(i, s);
              if (((s += 4), l.ltype == 9)) l.ltype = k;
              else if (l.ltype != k) throw "invalid extension substitution";
              return e.GSUB.subt(i, l.ltype, f + P);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              o,
              "format",
              h.fmt
            );
          }
          return h;
        }),
        (e.GSUB.readSubClassSet = function (i, o) {
          var s = e._bin.readUshort,
            l = o,
            u = [],
            f = s(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s(i, o);
            (o += 2), u.push(e.GSUB.readSubClassRule(i, l + m));
          }
          return u;
        }),
        (e.GSUB.readSubClassRule = function (i, o) {
          var s = e._bin.readUshort,
            l = {},
            u = s(i, o),
            f = s(i, (o += 2));
          (o += 2), (l.input = []);
          for (var h = 0; h < u - 1; h++) l.input.push(s(i, o)), (o += 2);
          return (
            (l.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, f)), l
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (i, o, s) {
          for (var l = e._bin.readUshort, u = [], f = 0; f < s; f++)
            u.push(l(i, o), l(i, o + 2)), (o += 4);
          return u;
        }),
        (e.GSUB.readChainSubClassSet = function (i, o) {
          var s = e._bin,
            l = o,
            u = [],
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readUshort(i, o);
            (o += 2), u.push(e.GSUB.readChainSubClassRule(i, l + m));
          }
          return u;
        }),
        (e.GSUB.readChainSubClassRule = function (i, o) {
          for (
            var s = e._bin,
              l = {},
              u = ["backtrack", "input", "lookahead"],
              f = 0;
            f < u.length;
            f++
          ) {
            var h = s.readUshort(i, o);
            (o += 2),
              f == 1 && h--,
              (l[u[f]] = s.readUshorts(i, o, h)),
              (o += 2 * l[u[f]].length);
          }
          return (
            (h = s.readUshort(i, o)),
            (o += 2),
            (l.subst = s.readUshorts(i, o, 2 * h)),
            (o += 2 * l.subst.length),
            l
          );
        }),
        (e.GSUB.readLigatureSet = function (i, o) {
          var s = e._bin,
            l = o,
            u = [],
            f = s.readUshort(i, o);
          o += 2;
          for (var h = 0; h < f; h++) {
            var m = s.readUshort(i, o);
            (o += 2), u.push(e.GSUB.readLigature(i, l + m));
          }
          return u;
        }),
        (e.GSUB.readLigature = function (i, o) {
          var s = e._bin,
            l = { chain: [] };
          (l.nglyph = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          o += 2;
          for (var f = 0; f < u - 1; f++)
            l.chain.push(s.readUshort(i, o)), (o += 2);
          return l;
        }),
        (e.head = {}),
        (e.head.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          return (
            l.readFixed(i, o),
            (o += 4),
            (u.fontRevision = l.readFixed(i, o)),
            (o += 4),
            l.readUint(i, o),
            (o += 4),
            l.readUint(i, o),
            (o += 4),
            (u.flags = l.readUshort(i, o)),
            (o += 2),
            (u.unitsPerEm = l.readUshort(i, o)),
            (o += 2),
            (u.created = l.readUint64(i, o)),
            (o += 8),
            (u.modified = l.readUint64(i, o)),
            (o += 8),
            (u.xMin = l.readShort(i, o)),
            (o += 2),
            (u.yMin = l.readShort(i, o)),
            (o += 2),
            (u.xMax = l.readShort(i, o)),
            (o += 2),
            (u.yMax = l.readShort(i, o)),
            (o += 2),
            (u.macStyle = l.readUshort(i, o)),
            (o += 2),
            (u.lowestRecPPEM = l.readUshort(i, o)),
            (o += 2),
            (u.fontDirectionHint = l.readShort(i, o)),
            (o += 2),
            (u.indexToLocFormat = l.readShort(i, o)),
            (o += 2),
            (u.glyphDataFormat = l.readShort(i, o)),
            (o += 2),
            u
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          return (
            l.readFixed(i, o),
            (o += 4),
            (u.ascender = l.readShort(i, o)),
            (o += 2),
            (u.descender = l.readShort(i, o)),
            (o += 2),
            (u.lineGap = l.readShort(i, o)),
            (o += 2),
            (u.advanceWidthMax = l.readUshort(i, o)),
            (o += 2),
            (u.minLeftSideBearing = l.readShort(i, o)),
            (o += 2),
            (u.minRightSideBearing = l.readShort(i, o)),
            (o += 2),
            (u.xMaxExtent = l.readShort(i, o)),
            (o += 2),
            (u.caretSlopeRise = l.readShort(i, o)),
            (o += 2),
            (u.caretSlopeRun = l.readShort(i, o)),
            (o += 2),
            (u.caretOffset = l.readShort(i, o)),
            (o += 2),
            (o += 8),
            (u.metricDataFormat = l.readShort(i, o)),
            (o += 2),
            (u.numberOfHMetrics = l.readUshort(i, o)),
            (o += 2),
            u
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (i, o, s, l) {
          for (
            var u = e._bin,
              f = { aWidth: [], lsBearing: [] },
              h = 0,
              m = 0,
              g = 0;
            g < l.maxp.numGlyphs;
            g++
          )
            g < l.hhea.numberOfHMetrics &&
              ((h = u.readUshort(i, o)),
              (o += 2),
              (m = u.readShort(i, o)),
              (o += 2)),
              f.aWidth.push(h),
              f.lsBearing.push(m);
          return f;
        }),
        (e.kern = {}),
        (e.kern.parse = function (i, o, s, l) {
          var u = e._bin,
            f = u.readUshort(i, o);
          if (((o += 2), f == 1)) return e.kern.parseV1(i, o - 2, s, l);
          var h = u.readUshort(i, o);
          o += 2;
          for (var m = { glyph1: [], rval: [] }, g = 0; g < h; g++) {
            (o += 2), (s = u.readUshort(i, o)), (o += 2);
            var y = u.readUshort(i, o);
            o += 2;
            var x = y >>> 8;
            if ((x &= 15) != 0) throw "unknown kern table format: " + x;
            o = e.kern.readFormat0(i, o, m);
          }
          return m;
        }),
        (e.kern.parseV1 = function (i, o, s, l) {
          var u = e._bin;
          u.readFixed(i, o), (o += 4);
          var f = u.readUint(i, o);
          o += 4;
          for (var h = { glyph1: [], rval: [] }, m = 0; m < f; m++) {
            u.readUint(i, o), (o += 4);
            var g = u.readUshort(i, o);
            (o += 2), u.readUshort(i, o), (o += 2);
            var y = g >>> 8;
            if ((y &= 15) != 0) throw "unknown kern table format: " + y;
            o = e.kern.readFormat0(i, o, h);
          }
          return h;
        }),
        (e.kern.readFormat0 = function (i, o, s) {
          var l = e._bin,
            u = -1,
            f = l.readUshort(i, o);
          (o += 2),
            l.readUshort(i, o),
            (o += 2),
            l.readUshort(i, o),
            (o += 2),
            l.readUshort(i, o),
            (o += 2);
          for (var h = 0; h < f; h++) {
            var m = l.readUshort(i, o);
            o += 2;
            var g = l.readUshort(i, o);
            o += 2;
            var y = l.readShort(i, o);
            (o += 2),
              m != u &&
                (s.glyph1.push(m), s.rval.push({ glyph2: [], vals: [] }));
            var x = s.rval[s.rval.length - 1];
            x.glyph2.push(g), x.vals.push(y), (u = m);
          }
          return o;
        }),
        (e.loca = {}),
        (e.loca.parse = function (i, o, s, l) {
          var u = e._bin,
            f = [],
            h = l.head.indexToLocFormat,
            m = l.maxp.numGlyphs + 1;
          if (h == 0)
            for (var g = 0; g < m; g++)
              f.push(u.readUshort(i, o + (g << 1)) << 1);
          if (h == 1)
            for (g = 0; g < m; g++) f.push(u.readUint(i, o + (g << 2)));
          return f;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (i, o, s) {
          var l = e._bin,
            u = {},
            f = l.readUint(i, o);
          return (
            (o += 4),
            (u.numGlyphs = l.readUshort(i, o)),
            (o += 2),
            f == 65536 &&
              ((u.maxPoints = l.readUshort(i, o)),
              (o += 2),
              (u.maxContours = l.readUshort(i, o)),
              (o += 2),
              (u.maxCompositePoints = l.readUshort(i, o)),
              (o += 2),
              (u.maxCompositeContours = l.readUshort(i, o)),
              (o += 2),
              (u.maxZones = l.readUshort(i, o)),
              (o += 2),
              (u.maxTwilightPoints = l.readUshort(i, o)),
              (o += 2),
              (u.maxStorage = l.readUshort(i, o)),
              (o += 2),
              (u.maxFunctionDefs = l.readUshort(i, o)),
              (o += 2),
              (u.maxInstructionDefs = l.readUshort(i, o)),
              (o += 2),
              (u.maxStackElements = l.readUshort(i, o)),
              (o += 2),
              (u.maxSizeOfInstructions = l.readUshort(i, o)),
              (o += 2),
              (u.maxComponentElements = l.readUshort(i, o)),
              (o += 2),
              (u.maxComponentDepth = l.readUshort(i, o)),
              (o += 2)),
            u
          );
        }),
        (e.name = {}),
        (e.name.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          l.readUshort(i, o), (o += 2);
          var f = l.readUshort(i, o);
          (o += 2), l.readUshort(i, o);
          for (
            var h,
              m = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              g = (o += 2),
              y = 0;
            y < f;
            y++
          ) {
            var x = l.readUshort(i, o);
            o += 2;
            var S = l.readUshort(i, o);
            o += 2;
            var _ = l.readUshort(i, o);
            o += 2;
            var w = l.readUshort(i, o);
            o += 2;
            var T = l.readUshort(i, o);
            o += 2;
            var E = l.readUshort(i, o);
            o += 2;
            var A,
              R = m[w],
              k = g + 12 * f + E;
            if (x == 0) A = l.readUnicode(i, k, T / 2);
            else if (x == 3 && S == 0) A = l.readUnicode(i, k, T / 2);
            else if (S == 0) A = l.readASCII(i, k, T);
            else if (S == 1) A = l.readUnicode(i, k, T / 2);
            else if (S == 3) A = l.readUnicode(i, k, T / 2);
            else {
              if (x != 1) throw "unknown encoding " + S + ", platformID: " + x;
              (A = l.readASCII(i, k, T)),
                console.debug(
                  "reading unknown MAC encoding " + S + " as ASCII"
                );
            }
            var P = "p" + x + "," + _.toString(16);
            u[P] == null && (u[P] = {}),
              (u[P][R !== void 0 ? R : w] = A),
              (u[P]._lang = _);
          }
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 1033) return u[U];
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 0) return u[U];
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 3084) return u[U];
          for (var U in u) if (u[U].postScriptName != null) return u[U];
          for (var U in u) {
            h = U;
            break;
          }
          return (
            console.debug("returning name table with languageID " + u[h]._lang),
            u[h]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (i, o, s) {
          var l = e._bin.readUshort(i, o);
          o += 2;
          var u = {};
          if (l == 0) e["OS/2"].version0(i, o, u);
          else if (l == 1) e["OS/2"].version1(i, o, u);
          else if (l == 2 || l == 3 || l == 4) e["OS/2"].version2(i, o, u);
          else {
            if (l != 5) throw "unknown OS/2 table version: " + l;
            e["OS/2"].version5(i, o, u);
          }
          return u;
        }),
        (e["OS/2"].version0 = function (i, o, s) {
          var l = e._bin;
          return (
            (s.xAvgCharWidth = l.readShort(i, o)),
            (o += 2),
            (s.usWeightClass = l.readUshort(i, o)),
            (o += 2),
            (s.usWidthClass = l.readUshort(i, o)),
            (o += 2),
            (s.fsType = l.readUshort(i, o)),
            (o += 2),
            (s.ySubscriptXSize = l.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYSize = l.readShort(i, o)),
            (o += 2),
            (s.ySubscriptXOffset = l.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYOffset = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXSize = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYSize = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXOffset = l.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYOffset = l.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutSize = l.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutPosition = l.readShort(i, o)),
            (o += 2),
            (s.sFamilyClass = l.readShort(i, o)),
            (o += 2),
            (s.panose = l.readBytes(i, o, 10)),
            (o += 10),
            (s.ulUnicodeRange1 = l.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange2 = l.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange3 = l.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange4 = l.readUint(i, o)),
            (o += 4),
            (s.achVendID = [
              l.readInt8(i, o),
              l.readInt8(i, o + 1),
              l.readInt8(i, o + 2),
              l.readInt8(i, o + 3),
            ]),
            (o += 4),
            (s.fsSelection = l.readUshort(i, o)),
            (o += 2),
            (s.usFirstCharIndex = l.readUshort(i, o)),
            (o += 2),
            (s.usLastCharIndex = l.readUshort(i, o)),
            (o += 2),
            (s.sTypoAscender = l.readShort(i, o)),
            (o += 2),
            (s.sTypoDescender = l.readShort(i, o)),
            (o += 2),
            (s.sTypoLineGap = l.readShort(i, o)),
            (o += 2),
            (s.usWinAscent = l.readUshort(i, o)),
            (o += 2),
            (s.usWinDescent = l.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version1 = function (i, o, s) {
          var l = e._bin;
          return (
            (o = e["OS/2"].version0(i, o, s)),
            (s.ulCodePageRange1 = l.readUint(i, o)),
            (o += 4),
            (s.ulCodePageRange2 = l.readUint(i, o)),
            (o += 4)
          );
        }),
        (e["OS/2"].version2 = function (i, o, s) {
          var l = e._bin;
          return (
            (o = e["OS/2"].version1(i, o, s)),
            (s.sxHeight = l.readShort(i, o)),
            (o += 2),
            (s.sCapHeight = l.readShort(i, o)),
            (o += 2),
            (s.usDefault = l.readUshort(i, o)),
            (o += 2),
            (s.usBreak = l.readUshort(i, o)),
            (o += 2),
            (s.usMaxContext = l.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version5 = function (i, o, s) {
          var l = e._bin;
          return (
            (o = e["OS/2"].version2(i, o, s)),
            (s.usLowerOpticalPointSize = l.readUshort(i, o)),
            (o += 2),
            (s.usUpperOpticalPointSize = l.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (i, o, s) {
          var l = e._bin,
            u = {};
          return (
            (u.version = l.readFixed(i, o)),
            (o += 4),
            (u.italicAngle = l.readFixed(i, o)),
            (o += 4),
            (u.underlinePosition = l.readShort(i, o)),
            (o += 2),
            (u.underlineThickness = l.readShort(i, o)),
            (o += 2),
            u
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (i, o) {
          var s = i.cmap,
            l = -1;
          if (
            (s.p0e4 != null
              ? (l = s.p0e4)
              : s.p3e1 != null
              ? (l = s.p3e1)
              : s.p1e0 != null
              ? (l = s.p1e0)
              : s.p0e3 != null && (l = s.p0e3),
            l == -1)
          )
            throw "no familiar platform and encoding!";
          var u = s.tables[l];
          if (u.format == 0) return o >= u.map.length ? 0 : u.map[o];
          if (u.format == 4) {
            for (var f = -1, h = 0; h < u.endCount.length; h++)
              if (o <= u.endCount[h]) {
                f = h;
                break;
              }
            return f == -1 || u.startCount[f] > o
              ? 0
              : 65535 &
                  (u.idRangeOffset[f] != 0
                    ? u.glyphIdArray[
                        o -
                          u.startCount[f] +
                          (u.idRangeOffset[f] >> 1) -
                          (u.idRangeOffset.length - f)
                      ]
                    : o + u.idDelta[f]);
          }
          if (u.format == 12) {
            if (o > u.groups[u.groups.length - 1][1]) return 0;
            for (h = 0; h < u.groups.length; h++) {
              var m = u.groups[h];
              if (m[0] <= o && o <= m[1]) return m[2] + (o - m[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + u.format;
        }),
        (e.U.glyphToPath = function (i, o) {
          var s = { cmds: [], crds: [] };
          if (i.SVG && i.SVG.entries[o]) {
            var l = i.SVG.entries[o];
            return l == null
              ? s
              : (typeof l == "string" &&
                  ((l = e.SVG.toPath(l)), (i.SVG.entries[o] = l)),
                l);
          }
          if (i.CFF) {
            var u = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              f = i.CFF,
              h = i.CFF.Private;
            if (f.ROS) {
              for (var m = 0; f.FDSelect[m + 2] <= o; ) m += 2;
              h = f.FDArray[f.FDSelect[m + 1]].Private;
            }
            e.U._drawCFF(i.CFF.CharStrings[o], u, f, h, s);
          } else i.glyf && e.U._drawGlyf(o, i, s);
          return s;
        }),
        (e.U._drawGlyf = function (i, o, s) {
          var l = o.glyf[i];
          l == null && (l = o.glyf[i] = e.glyf._parseGlyf(o, i)),
            l != null &&
              (l.noc > -1 ? e.U._simpleGlyph(l, s) : e.U._compoGlyph(l, o, s));
        }),
        (e.U._simpleGlyph = function (i, o) {
          for (var s = 0; s < i.noc; s++) {
            for (
              var l = s == 0 ? 0 : i.endPts[s - 1] + 1, u = i.endPts[s], f = l;
              f <= u;
              f++
            ) {
              var h = f == l ? u : f - 1,
                m = f == u ? l : f + 1,
                g = 1 & i.flags[f],
                y = 1 & i.flags[h],
                x = 1 & i.flags[m],
                S = i.xs[f],
                _ = i.ys[f];
              if (f == l)
                if (g) {
                  if (!y) {
                    e.U.P.moveTo(o, S, _);
                    continue;
                  }
                  e.U.P.moveTo(o, i.xs[h], i.ys[h]);
                } else
                  y
                    ? e.U.P.moveTo(o, i.xs[h], i.ys[h])
                    : e.U.P.moveTo(o, (i.xs[h] + S) / 2, (i.ys[h] + _) / 2);
              g
                ? y && e.U.P.lineTo(o, S, _)
                : x
                ? e.U.P.qcurveTo(o, S, _, i.xs[m], i.ys[m])
                : e.U.P.qcurveTo(o, S, _, (S + i.xs[m]) / 2, (_ + i.ys[m]) / 2);
            }
            e.U.P.closePath(o);
          }
        }),
        (e.U._compoGlyph = function (i, o, s) {
          for (var l = 0; l < i.parts.length; l++) {
            var u = { cmds: [], crds: [] },
              f = i.parts[l];
            e.U._drawGlyf(f.glyphIndex, o, u);
            for (var h = f.m, m = 0; m < u.crds.length; m += 2) {
              var g = u.crds[m],
                y = u.crds[m + 1];
              s.crds.push(g * h.a + y * h.b + h.tx),
                s.crds.push(g * h.c + y * h.d + h.ty);
            }
            for (m = 0; m < u.cmds.length; m++) s.cmds.push(u.cmds[m]);
          }
        }),
        (e.U._getGlyphClass = function (i, o) {
          var s = e._lctf.getInterval(o, i);
          return s == -1 ? 0 : o[s + 2];
        }),
        (e.U._applySubs = function (i, o, s, l) {
          for (var u = i.length - o - 1, f = 0; f < s.tabs.length; f++)
            if (s.tabs[f] != null) {
              var h,
                m = s.tabs[f];
              if (
                !m.coverage ||
                (h = e._lctf.coverageIndex(m.coverage, i[o])) != -1
              ) {
                if (s.ltype == 1)
                  i[o],
                    m.fmt == 1 ? (i[o] = i[o] + m.delta) : (i[o] = m.newg[h]);
                else if (s.ltype == 4)
                  for (var g = m.vals[h], y = 0; y < g.length; y++) {
                    var x = g[y],
                      S = x.chain.length;
                    if (!(S > u)) {
                      for (var _ = !0, w = 0, T = 0; T < S; T++) {
                        for (; i[o + w + (1 + T)] == -1; ) w++;
                        x.chain[T] != i[o + w + (1 + T)] && (_ = !1);
                      }
                      if (_) {
                        for (i[o] = x.nglyph, T = 0; T < S + w; T++)
                          i[o + T + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (s.ltype == 5 && m.fmt == 2)
                  for (
                    var E = e._lctf.getInterval(m.cDef, i[o]),
                      A = m.cDef[E + 2],
                      R = m.scset[A],
                      k = 0;
                    k < R.length;
                    k++
                  ) {
                    var P = R[k],
                      U = P.input;
                    if (!(U.length > u)) {
                      for (_ = !0, T = 0; T < U.length; T++) {
                        var N = e._lctf.getInterval(m.cDef, i[o + 1 + T]);
                        if (E == -1 && m.cDef[N + 2] != U[T]) {
                          _ = !1;
                          break;
                        }
                      }
                      if (_) {
                        var L = P.substLookupRecords;
                        for (y = 0; y < L.length; y += 2) L[y], L[y + 1];
                      }
                    }
                  }
                else if (s.ltype == 6 && m.fmt == 3) {
                  if (
                    !e.U._glsCovered(i, m.backCvg, o - m.backCvg.length) ||
                    !e.U._glsCovered(i, m.inptCvg, o) ||
                    !e.U._glsCovered(i, m.ahedCvg, o + m.inptCvg.length)
                  )
                    continue;
                  var H = m.lookupRec;
                  for (k = 0; k < H.length; k += 2) {
                    E = H[k];
                    var G = l[H[k + 1]];
                    e.U._applySubs(i, o + E, G, l);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (i, o, s) {
          for (var l = 0; l < o.length; l++)
            if (e._lctf.coverageIndex(o[l], i[s + l]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (i, o, s) {
          for (
            var l = { cmds: [], crds: [] }, u = 0, f = 0;
            f < o.length;
            f++
          ) {
            var h = o[f];
            if (h != -1) {
              for (
                var m = f < o.length - 1 && o[f + 1] != -1 ? o[f + 1] : 0,
                  g = e.U.glyphToPath(i, h),
                  y = 0;
                y < g.crds.length;
                y += 2
              )
                l.crds.push(g.crds[y] + u), l.crds.push(g.crds[y + 1]);
              for (s && l.cmds.push(s), y = 0; y < g.cmds.length; y++)
                l.cmds.push(g.cmds[y]);
              s && l.cmds.push("X"),
                (u += i.hmtx.aWidth[h]),
                f < o.length - 1 && (u += e.U.getPairAdjustment(i, h, m));
            }
          }
          return l;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (i, o, s) {
          i.cmds.push("M"), i.crds.push(o, s);
        }),
        (e.U.P.lineTo = function (i, o, s) {
          i.cmds.push("L"), i.crds.push(o, s);
        }),
        (e.U.P.curveTo = function (i, o, s, l, u, f, h) {
          i.cmds.push("C"), i.crds.push(o, s, l, u, f, h);
        }),
        (e.U.P.qcurveTo = function (i, o, s, l, u) {
          i.cmds.push("Q"), i.crds.push(o, s, l, u);
        }),
        (e.U.P.closePath = function (i) {
          i.cmds.push("Z");
        }),
        (e.U._drawCFF = function (i, o, s, l, u) {
          for (
            var f = o.stack,
              h = o.nStems,
              m = o.haveWidth,
              g = o.width,
              y = o.open,
              x = 0,
              S = o.x,
              _ = o.y,
              w = 0,
              T = 0,
              E = 0,
              A = 0,
              R = 0,
              k = 0,
              P = 0,
              U = 0,
              N = 0,
              L = 0,
              H = { val: 0, size: 0 };
            x < i.length;

          ) {
            e.CFF.getCharString(i, x, H);
            var G = H.val;
            if (((x += H.size), G == "o1" || G == "o18"))
              f.length % 2 != 0 && !m && (g = f.shift() + l.nominalWidthX),
                (h += f.length >> 1),
                (f.length = 0),
                (m = !0);
            else if (G == "o3" || G == "o23")
              f.length % 2 != 0 && !m && (g = f.shift() + l.nominalWidthX),
                (h += f.length >> 1),
                (f.length = 0),
                (m = !0);
            else if (G == "o4")
              f.length > 1 &&
                !m &&
                ((g = f.shift() + l.nominalWidthX), (m = !0)),
                y && e.U.P.closePath(u),
                (_ += f.pop()),
                e.U.P.moveTo(u, S, _),
                (y = !0);
            else if (G == "o5")
              for (; f.length > 0; )
                (S += f.shift()), (_ += f.shift()), e.U.P.lineTo(u, S, _);
            else if (G == "o6" || G == "o7")
              for (var $ = f.length, q = G == "o6", Z = 0; Z < $; Z++) {
                var X = f.shift();
                q ? (S += X) : (_ += X), (q = !q), e.U.P.lineTo(u, S, _);
              }
            else if (G == "o8" || G == "o24") {
              $ = f.length;
              for (var re = 0; re + 6 <= $; )
                (w = S + f.shift()),
                  (T = _ + f.shift()),
                  (E = w + f.shift()),
                  (A = T + f.shift()),
                  (S = E + f.shift()),
                  (_ = A + f.shift()),
                  e.U.P.curveTo(u, w, T, E, A, S, _),
                  (re += 6);
              G == "o24" &&
                ((S += f.shift()), (_ += f.shift()), e.U.P.lineTo(u, S, _));
            } else {
              if (G == "o11") break;
              if (G == "o1234" || G == "o1235" || G == "o1236" || G == "o1237")
                G == "o1234" &&
                  ((T = _),
                  (E = (w = S + f.shift()) + f.shift()),
                  (L = A = T + f.shift()),
                  (k = A),
                  (U = _),
                  (S =
                    (P = (R = (N = E + f.shift()) + f.shift()) + f.shift()) +
                    f.shift()),
                  e.U.P.curveTo(u, w, T, E, A, N, L),
                  e.U.P.curveTo(u, R, k, P, U, S, _)),
                  G == "o1235" &&
                    ((w = S + f.shift()),
                    (T = _ + f.shift()),
                    (E = w + f.shift()),
                    (A = T + f.shift()),
                    (N = E + f.shift()),
                    (L = A + f.shift()),
                    (R = N + f.shift()),
                    (k = L + f.shift()),
                    (P = R + f.shift()),
                    (U = k + f.shift()),
                    (S = P + f.shift()),
                    (_ = U + f.shift()),
                    f.shift(),
                    e.U.P.curveTo(u, w, T, E, A, N, L),
                    e.U.P.curveTo(u, R, k, P, U, S, _)),
                  G == "o1236" &&
                    ((w = S + f.shift()),
                    (T = _ + f.shift()),
                    (E = w + f.shift()),
                    (L = A = T + f.shift()),
                    (k = A),
                    (P = (R = (N = E + f.shift()) + f.shift()) + f.shift()),
                    (U = k + f.shift()),
                    (S = P + f.shift()),
                    e.U.P.curveTo(u, w, T, E, A, N, L),
                    e.U.P.curveTo(u, R, k, P, U, S, _)),
                  G == "o1237" &&
                    ((w = S + f.shift()),
                    (T = _ + f.shift()),
                    (E = w + f.shift()),
                    (A = T + f.shift()),
                    (N = E + f.shift()),
                    (L = A + f.shift()),
                    (R = N + f.shift()),
                    (k = L + f.shift()),
                    (P = R + f.shift()),
                    (U = k + f.shift()),
                    Math.abs(P - S) > Math.abs(U - _)
                      ? (S = P + f.shift())
                      : (_ = U + f.shift()),
                    e.U.P.curveTo(u, w, T, E, A, N, L),
                    e.U.P.curveTo(u, R, k, P, U, S, _));
              else if (G == "o14") {
                if (
                  (f.length > 0 &&
                    !m &&
                    ((g = f.shift() + s.nominalWidthX), (m = !0)),
                  f.length == 4)
                ) {
                  var W = f.shift(),
                    te = f.shift(),
                    F = f.shift(),
                    V = f.shift(),
                    ne = e.CFF.glyphBySE(s, F),
                    ae = e.CFF.glyphBySE(s, V);
                  e.U._drawCFF(s.CharStrings[ne], o, s, l, u),
                    (o.x = W),
                    (o.y = te),
                    e.U._drawCFF(s.CharStrings[ae], o, s, l, u);
                }
                y && (e.U.P.closePath(u), (y = !1));
              } else if (G == "o19" || G == "o20")
                f.length % 2 != 0 && !m && (g = f.shift() + l.nominalWidthX),
                  (h += f.length >> 1),
                  (f.length = 0),
                  (m = !0),
                  (x += (h + 7) >> 3);
              else if (G == "o21")
                f.length > 2 &&
                  !m &&
                  ((g = f.shift() + l.nominalWidthX), (m = !0)),
                  (_ += f.pop()),
                  (S += f.pop()),
                  y && e.U.P.closePath(u),
                  e.U.P.moveTo(u, S, _),
                  (y = !0);
              else if (G == "o22")
                f.length > 1 &&
                  !m &&
                  ((g = f.shift() + l.nominalWidthX), (m = !0)),
                  (S += f.pop()),
                  y && e.U.P.closePath(u),
                  e.U.P.moveTo(u, S, _),
                  (y = !0);
              else if (G == "o25") {
                for (; f.length > 6; )
                  (S += f.shift()), (_ += f.shift()), e.U.P.lineTo(u, S, _);
                (w = S + f.shift()),
                  (T = _ + f.shift()),
                  (E = w + f.shift()),
                  (A = T + f.shift()),
                  (S = E + f.shift()),
                  (_ = A + f.shift()),
                  e.U.P.curveTo(u, w, T, E, A, S, _);
              } else if (G == "o26")
                for (f.length % 2 && (S += f.shift()); f.length > 0; )
                  (w = S),
                    (T = _ + f.shift()),
                    (S = E = w + f.shift()),
                    (_ = (A = T + f.shift()) + f.shift()),
                    e.U.P.curveTo(u, w, T, E, A, S, _);
              else if (G == "o27")
                for (f.length % 2 && (_ += f.shift()); f.length > 0; )
                  (T = _),
                    (E = (w = S + f.shift()) + f.shift()),
                    (A = T + f.shift()),
                    (S = E + f.shift()),
                    (_ = A),
                    e.U.P.curveTo(u, w, T, E, A, S, _);
              else if (G == "o10" || G == "o29") {
                var J = G == "o10" ? l : s;
                if (f.length == 0) console.debug("error: empty stack");
                else {
                  var oe = f.pop(),
                    de = J.Subrs[oe + J.Bias];
                  (o.x = S),
                    (o.y = _),
                    (o.nStems = h),
                    (o.haveWidth = m),
                    (o.width = g),
                    (o.open = y),
                    e.U._drawCFF(de, o, s, l, u),
                    (S = o.x),
                    (_ = o.y),
                    (h = o.nStems),
                    (m = o.haveWidth),
                    (g = o.width),
                    (y = o.open);
                }
              } else if (G == "o30" || G == "o31") {
                var le = f.length,
                  fe = ((re = 0), G == "o31");
                for (re += le - ($ = -3 & le); re < $; )
                  fe
                    ? ((T = _),
                      (E = (w = S + f.shift()) + f.shift()),
                      (_ = (A = T + f.shift()) + f.shift()),
                      $ - re == 5 ? ((S = E + f.shift()), re++) : (S = E),
                      (fe = !1))
                    : ((w = S),
                      (T = _ + f.shift()),
                      (E = w + f.shift()),
                      (A = T + f.shift()),
                      (S = E + f.shift()),
                      $ - re == 5 ? ((_ = A + f.shift()), re++) : (_ = A),
                      (fe = !0)),
                    e.U.P.curveTo(u, w, T, E, A, S, _),
                    (re += 4);
              } else {
                if ((G + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + G, i), G);
                f.push(G);
              }
            }
          }
          (o.x = S),
            (o.y = _),
            (o.nStems = h),
            (o.haveWidth = m),
            (o.width = g),
            (o.open = y);
        });
      var t = e,
        r = { Typr: t };
      return (
        (n.Typr = t),
        (n.default = r),
        Object.defineProperty(n, "__esModule", { value: !0 }),
        n
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function kW() {
  return (function (n) {
    var e = Uint8Array,
      t = Uint16Array,
      r = Uint32Array,
      i = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      o = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      s = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      l = function (G, $) {
        for (var q = new t(31), Z = 0; Z < 31; ++Z) q[Z] = $ += 1 << G[Z - 1];
        var X = new r(q[30]);
        for (Z = 1; Z < 30; ++Z)
          for (var re = q[Z]; re < q[Z + 1]; ++re)
            X[re] = ((re - q[Z]) << 5) | Z;
        return [q, X];
      },
      u = l(i, 2),
      f = u[0],
      h = u[1];
    (f[28] = 258), (h[258] = 28);
    for (var m = l(o, 0)[0], g = new t(32768), y = 0; y < 32768; ++y) {
      var x = ((43690 & y) >>> 1) | ((21845 & y) << 1);
      (x =
        ((61680 & (x = ((52428 & x) >>> 2) | ((13107 & x) << 2))) >>> 4) |
        ((3855 & x) << 4)),
        (g[y] = (((65280 & x) >>> 8) | ((255 & x) << 8)) >>> 1);
    }
    var S = function (G, $, q) {
        for (var Z = G.length, X = 0, re = new t($); X < Z; ++X) ++re[G[X] - 1];
        var W,
          te = new t($);
        for (X = 0; X < $; ++X) te[X] = (te[X - 1] + re[X - 1]) << 1;
        {
          W = new t(1 << $);
          var F = 15 - $;
          for (X = 0; X < Z; ++X)
            if (G[X])
              for (
                var V = (X << 4) | G[X],
                  ne = $ - G[X],
                  ae = te[G[X] - 1]++ << ne,
                  J = ae | ((1 << ne) - 1);
                ae <= J;
                ++ae
              )
                W[g[ae] >>> F] = V;
        }
        return W;
      },
      _ = new e(288);
    for (y = 0; y < 144; ++y) _[y] = 8;
    for (y = 144; y < 256; ++y) _[y] = 9;
    for (y = 256; y < 280; ++y) _[y] = 7;
    for (y = 280; y < 288; ++y) _[y] = 8;
    var w = new e(32);
    for (y = 0; y < 32; ++y) w[y] = 5;
    var T = S(_, 9),
      E = S(w, 5),
      A = function (G) {
        for (var $ = G[0], q = 1; q < G.length; ++q) G[q] > $ && ($ = G[q]);
        return $;
      },
      R = function (G, $, q) {
        var Z = ($ / 8) | 0;
        return ((G[Z] | (G[Z + 1] << 8)) >> (7 & $)) & q;
      },
      k = function (G, $) {
        var q = ($ / 8) | 0;
        return (G[q] | (G[q + 1] << 8) | (G[q + 2] << 16)) >> (7 & $);
      },
      P = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      U = function (G, $, q) {
        var Z = new Error($ || P[G]);
        if (
          ((Z.code = G),
          Error.captureStackTrace && Error.captureStackTrace(Z, U),
          !q)
        )
          throw Z;
        return Z;
      },
      N = function (G, $, q) {
        var Z = G.length;
        if (!Z || (q && !q.l && Z < 5)) return $ || new e(0);
        var X = !$ || q,
          re = !q || q.i;
        q || (q = {}), $ || ($ = new e(3 * Z));
        var W,
          te = function (et) {
            var he = $.length;
            if (et > he) {
              var Je = new e(Math.max(2 * he, et));
              Je.set($), ($ = Je);
            }
          },
          F = q.f || 0,
          V = q.p || 0,
          ne = q.b || 0,
          ae = q.l,
          J = q.d,
          oe = q.m,
          de = q.n,
          le = 8 * Z;
        do {
          if (!ae) {
            q.f = F = R(G, V, 1);
            var fe = R(G, V + 1, 3);
            if (((V += 3), !fe)) {
              var Ee =
                  G[(ee = (((W = V) / 8) | 0) + (7 & W && 1) + 4) - 4] |
                  (G[ee - 3] << 8),
                ge = ee + Ee;
              if (ge > Z) {
                re && U(0);
                break;
              }
              X && te(ne + Ee),
                $.set(G.subarray(ee, ge), ne),
                (q.b = ne += Ee),
                (q.p = V = 8 * ge);
              continue;
            }
            if (fe == 1) (ae = T), (J = E), (oe = 9), (de = 5);
            else if (fe == 2) {
              var xe = R(G, V, 31) + 257,
                j = R(G, V + 10, 15) + 4,
                we = xe + R(G, V + 5, 31) + 1;
              V += 14;
              for (var Ae = new e(we), Ne = new e(19), Ie = 0; Ie < j; ++Ie)
                Ne[s[Ie]] = R(G, V + 3 * Ie, 7);
              V += 3 * j;
              var rt = A(Ne),
                ke = (1 << rt) - 1,
                Xe = S(Ne, rt);
              for (Ie = 0; Ie < we; ) {
                var ee,
                  B = Xe[R(G, V, ke)];
                if (((V += 15 & B), (ee = B >>> 4) < 16)) Ae[Ie++] = ee;
                else {
                  var ve = 0,
                    Se = 0;
                  for (
                    ee == 16
                      ? ((Se = 3 + R(G, V, 3)), (V += 2), (ve = Ae[Ie - 1]))
                      : ee == 17
                      ? ((Se = 3 + R(G, V, 7)), (V += 3))
                      : ee == 18 && ((Se = 11 + R(G, V, 127)), (V += 7));
                    Se--;

                  )
                    Ae[Ie++] = ve;
                }
              }
              var _e = Ae.subarray(0, xe),
                Te = Ae.subarray(xe);
              (oe = A(_e)), (de = A(Te)), (ae = S(_e, oe)), (J = S(Te, de));
            } else U(1);
            if (V > le) {
              re && U(0);
              break;
            }
          }
          X && te(ne + 131072);
          for (var at = (1 << oe) - 1, Fe = (1 << de) - 1, Be = V; ; Be = V) {
            var We = (ve = ae[k(G, V) & at]) >>> 4;
            if ((V += 15 & ve) > le) {
              re && U(0);
              break;
            }
            if ((ve || U(2), We < 256)) $[ne++] = We;
            else {
              if (We == 256) {
                (Be = V), (ae = null);
                break;
              }
              var Ye = We - 254;
              if (We > 264) {
                var nt = i[(Ie = We - 257)];
                (Ye = R(G, V, (1 << nt) - 1) + f[Ie]), (V += nt);
              }
              var yt = J[k(G, V) & Fe],
                $e = yt >>> 4;
              if (
                (yt || U(3),
                (V += 15 & yt),
                (Te = m[$e]),
                $e > 3 &&
                  ((nt = o[$e]), (Te += k(G, V) & ((1 << nt) - 1)), (V += nt)),
                V > le)
              ) {
                re && U(0);
                break;
              }
              X && te(ne + 131072);
              for (var qe = ne + Ye; ne < qe; ne += 4)
                ($[ne] = $[ne - Te]),
                  ($[ne + 1] = $[ne + 1 - Te]),
                  ($[ne + 2] = $[ne + 2 - Te]),
                  ($[ne + 3] = $[ne + 3 - Te]);
              ne = qe;
            }
          }
          (q.l = ae),
            (q.p = Be),
            (q.b = ne),
            ae && ((F = 1), (q.m = oe), (q.d = J), (q.n = de));
        } while (!F);
        return ne == $.length
          ? $
          : (function (et, he, Je) {
              (Je == null || Je > et.length) && (Je = et.length);
              var me = new (et instanceof t ? t : et instanceof r ? r : e)(
                Je - he
              );
              return me.set(et.subarray(he, Je)), me;
            })($, 0, ne);
      },
      L = new e(0),
      H = typeof TextDecoder < "u" && new TextDecoder();
    try {
      H.decode(L, { stream: !0 });
    } catch {}
    return (
      (n.convert_streams = function (G) {
        var $ = new DataView(G),
          q = 0;
        function Z() {
          var xe = $.getUint16(q);
          return (q += 2), xe;
        }
        function X() {
          var xe = $.getUint32(q);
          return (q += 4), xe;
        }
        function re(xe) {
          Ee.setUint16(ge, xe), (ge += 2);
        }
        function W(xe) {
          Ee.setUint32(ge, xe), (ge += 4);
        }
        for (
          var te = {
              signature: X(),
              flavor: X(),
              length: X(),
              numTables: Z(),
              reserved: Z(),
              totalSfntSize: X(),
              majorVersion: Z(),
              minorVersion: Z(),
              metaOffset: X(),
              metaLength: X(),
              metaOrigLength: X(),
              privOffset: X(),
              privLength: X(),
            },
            F = 0;
          Math.pow(2, F) <= te.numTables;

        )
          F++;
        F--;
        for (
          var V = 16 * Math.pow(2, F),
            ne = 16 * te.numTables - V,
            ae = 12,
            J = [],
            oe = 0;
          oe < te.numTables;
          oe++
        )
          J.push({
            tag: X(),
            offset: X(),
            compLength: X(),
            origLength: X(),
            origChecksum: X(),
          }),
            (ae += 16);
        var de,
          le = new Uint8Array(
            12 +
              16 * J.length +
              J.reduce(function (xe, j) {
                return xe + j.origLength + 4;
              }, 0)
          ),
          fe = le.buffer,
          Ee = new DataView(fe),
          ge = 0;
        return (
          W(te.flavor),
          re(te.numTables),
          re(V),
          re(F),
          re(ne),
          J.forEach(function (xe) {
            W(xe.tag),
              W(xe.origChecksum),
              W(ae),
              W(xe.origLength),
              (xe.outOffset = ae),
              (ae += xe.origLength) % 4 != 0 && (ae += 4 - (ae % 4));
          }),
          J.forEach(function (xe) {
            var j,
              we = G.slice(xe.offset, xe.offset + xe.compLength);
            if (xe.compLength != xe.origLength) {
              var Ae = new Uint8Array(xe.origLength);
              (j = new Uint8Array(we, 2)), N(j, Ae);
            } else Ae = new Uint8Array(we);
            le.set(Ae, xe.outOffset);
            var Ne = 0;
            (ae = xe.outOffset + xe.origLength) % 4 != 0 && (Ne = 4 - (ae % 4)),
              le.set(new Uint8Array(Ne).buffer, xe.outOffset + xe.origLength),
              (de = ae + Ne);
          }),
          fe.slice(0, de)
        );
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({}).convert_streams;
}
function DW(n, e) {
  const t = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    r = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    i = 1,
    o = 2,
    s = 4,
    l = 8,
    u = 16,
    f = 32;
  let h;
  function m(P) {
    if (!h) {
      const U = { R: o, L: i, D: s, C: u, U: f, T: l };
      h = new Map();
      for (let N in r) {
        let L = 0;
        r[N].split(",").forEach((H) => {
          let [G, $] = H.split("+");
          (G = parseInt(G, 36)),
            ($ = $ ? parseInt($, 36) : 0),
            h.set((L += G), U[N]);
          for (let q = $; q--; ) h.set(++L, U[N]);
        });
      }
    }
    return h.get(P) || f;
  }
  const g = 1,
    y = 2,
    x = 3,
    S = 4,
    _ = [null, "isol", "init", "fina", "medi"];
  function w(P) {
    const U = new Uint8Array(P.length);
    let N = f,
      L = g,
      H = -1;
    for (let G = 0; G < P.length; G++) {
      const $ = P.codePointAt(G);
      let q = m($) | 0,
        Z = g;
      q & l ||
        (N & (i | s | u)
          ? q & (o | s | u)
            ? ((Z = x), (L === g || L === x) && U[H]++)
            : q & (i | f) && (L === y || L === S) && U[H]--
          : N & (o | f) && (L === y || L === S) && U[H]--,
        (L = U[G] = Z),
        (N = q),
        (H = G),
        $ > 65535 && G++);
    }
    return U;
  }
  function T(P, U) {
    const N = [];
    for (let H = 0; H < U.length; H++) {
      const G = U.codePointAt(H);
      G > 65535 && H++, N.push(n.U.codeToGlyph(P, G));
    }
    const L = P.GSUB;
    if (L) {
      const { lookupList: H, featureList: G } = L;
      let $;
      const q = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        Z = [];
      G.forEach((X) => {
        if (q.test(X.tag))
          for (let re = 0; re < X.tab.length; re++) {
            if (Z[X.tab[re]]) continue;
            Z[X.tab[re]] = !0;
            const W = H[X.tab[re]],
              te = /^(isol|init|fina|medi)$/.test(X.tag);
            te && !$ && ($ = w(U));
            for (let F = 0; F < N.length; F++)
              (!$ || !te || _[$[F]] === X.tag) && n.U._applySubs(N, F, W, H);
          }
      });
    }
    return N;
  }
  function E(P, U) {
    const N = new Int16Array(U.length * 3);
    let L = 0;
    for (; L < U.length; L++) {
      const q = U[L];
      if (q === -1) continue;
      N[L * 3 + 2] = P.hmtx.aWidth[q];
      const Z = P.GPOS;
      if (Z) {
        const X = Z.lookupList;
        for (let re = 0; re < X.length; re++) {
          const W = X[re];
          for (let te = 0; te < W.tabs.length; te++) {
            const F = W.tabs[te];
            if (W.ltype === 1) {
              if (n._lctf.coverageIndex(F.coverage, q) !== -1 && F.pos) {
                $(F.pos, L);
                break;
              }
            } else if (W.ltype === 2) {
              let V = null,
                ne = H();
              if (ne !== -1) {
                const ae = n._lctf.coverageIndex(F.coverage, U[ne]);
                if (ae !== -1) {
                  if (F.fmt === 1) {
                    const J = F.pairsets[ae];
                    for (let oe = 0; oe < J.length; oe++)
                      J[oe].gid2 === q && (V = J[oe]);
                  } else if (F.fmt === 2) {
                    const J = n.U._getGlyphClass(U[ne], F.classDef1),
                      oe = n.U._getGlyphClass(q, F.classDef2);
                    V = F.matrix[J][oe];
                  }
                  if (V) {
                    V.val1 && $(V.val1, ne), V.val2 && $(V.val2, L);
                    break;
                  }
                }
              }
            } else if (W.ltype === 4) {
              const V = n._lctf.coverageIndex(F.markCoverage, q);
              if (V !== -1) {
                const ne = H(G),
                  ae =
                    ne === -1
                      ? -1
                      : n._lctf.coverageIndex(F.baseCoverage, U[ne]);
                if (ae !== -1) {
                  const J = F.markArray[V],
                    oe = F.baseArray[ae][J.markClass];
                  (N[L * 3] = oe.x - J.x + N[ne * 3] - N[ne * 3 + 2]),
                    (N[L * 3 + 1] = oe.y - J.y + N[ne * 3 + 1]);
                  break;
                }
              }
            } else if (W.ltype === 6) {
              const V = n._lctf.coverageIndex(F.mark1Coverage, q);
              if (V !== -1) {
                const ne = H();
                if (ne !== -1) {
                  const ae = U[ne];
                  if (A(P, ae) === 3) {
                    const J = n._lctf.coverageIndex(F.mark2Coverage, ae);
                    if (J !== -1) {
                      const oe = F.mark1Array[V],
                        de = F.mark2Array[J][oe.markClass];
                      (N[L * 3] = de.x - oe.x + N[ne * 3] - N[ne * 3 + 2]),
                        (N[L * 3 + 1] = de.y - oe.y + N[ne * 3 + 1]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (P.kern && !P.cff) {
        const X = H();
        if (X !== -1) {
          const re = P.kern.glyph1.indexOf(U[X]);
          if (re !== -1) {
            const W = P.kern.rval[re].glyph2.indexOf(q);
            W !== -1 && (N[X * 3 + 2] += P.kern.rval[re].vals[W]);
          }
        }
      }
    }
    return N;
    function H(q) {
      for (let Z = L - 1; Z >= 0; Z--)
        if (U[Z] !== -1 && (!q || q(U[Z]))) return Z;
      return -1;
    }
    function G(q) {
      return A(P, q) === 1;
    }
    function $(q, Z) {
      for (let X = 0; X < 3; X++) N[Z * 3 + X] += q[X] || 0;
    }
  }
  function A(P, U) {
    const N = P.GDEF && P.GDEF.glyphClassDef;
    return N ? n.U._getGlyphClass(U, N) : 0;
  }
  function R(...P) {
    for (let U = 0; U < P.length; U++) if (typeof P[U] == "number") return P[U];
  }
  function k(P) {
    const U = Object.create(null),
      N = P["OS/2"],
      L = P.hhea,
      H = P.head.unitsPerEm,
      G = R(N && N.sTypoAscender, L && L.ascender, H),
      $ = {
        unitsPerEm: H,
        ascender: G,
        descender: R(N && N.sTypoDescender, L && L.descender, 0),
        capHeight: R(N && N.sCapHeight, G),
        xHeight: R(N && N.sxHeight, G),
        lineGap: R(N && N.sTypoLineGap, L && L.lineGap),
        supportsCodePoint(q) {
          return n.U.codeToGlyph(P, q) > 0;
        },
        forEachGlyph(q, Z, X, re) {
          let W = 0;
          const te = (1 / $.unitsPerEm) * Z,
            F = T(P, q);
          let V = 0;
          const ne = E(P, F);
          return (
            F.forEach((ae, J) => {
              if (ae !== -1) {
                let oe = U[ae];
                if (!oe) {
                  const { cmds: de, crds: le } = n.U.glyphToPath(P, ae);
                  let fe = "",
                    Ee = 0;
                  for (let Ae = 0, Ne = de.length; Ae < Ne; Ae++) {
                    const Ie = t[de[Ae]];
                    fe += de[Ae];
                    for (let rt = 1; rt <= Ie; rt++)
                      fe += (rt > 1 ? "," : "") + le[Ee++];
                  }
                  let ge, xe, j, we;
                  if (le.length) {
                    (ge = xe = 1 / 0), (j = we = -1 / 0);
                    for (let Ae = 0, Ne = le.length; Ae < Ne; Ae += 2) {
                      let Ie = le[Ae],
                        rt = le[Ae + 1];
                      Ie < ge && (ge = Ie),
                        rt < xe && (xe = rt),
                        Ie > j && (j = Ie),
                        rt > we && (we = rt);
                    }
                  } else ge = j = xe = we = 0;
                  oe = U[ae] = {
                    index: ae,
                    advanceWidth: P.hmtx.aWidth[ae],
                    xMin: ge,
                    yMin: xe,
                    xMax: j,
                    yMax: we,
                    path: fe,
                  };
                }
                re.call(null, oe, W + ne[J * 3] * te, ne[J * 3 + 1] * te, V),
                  (W += ne[J * 3 + 2] * te),
                  X && (W += X * Z);
              }
              V += q.codePointAt(V) > 65535 ? 2 : 1;
            }),
            W
          );
        },
      };
    return $;
  }
  return function (U) {
    const N = new Uint8Array(U, 0, 4),
      L = n._bin.readASCII(N, 0, 4);
    if (L === "wOFF") U = e(U);
    else if (L === "wOF2") throw new Error("woff2 fonts not supported");
    return k(n.parse(U)[0]);
  };
}
const NW = Bh({
  name: "Typr Font Parser",
  dependencies: [LW, kW, DW],
  init(n, e, t) {
    const r = n(),
      i = e();
    return t(r, i);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function OW() {
  return (function (n) {
    var e = function () {
      this.buckets = new Map();
    };
    (e.prototype.add = function (E) {
      var A = E >> 5;
      this.buckets.set(A, (this.buckets.get(A) || 0) | (1 << (31 & E)));
    }),
      (e.prototype.has = function (E) {
        var A = this.buckets.get(E >> 5);
        return A !== void 0 && (A & (1 << (31 & E))) != 0;
      }),
      (e.prototype.serialize = function () {
        var E = [];
        return (
          this.buckets.forEach(function (A, R) {
            E.push((+R).toString(36) + ":" + A.toString(36));
          }),
          E.join(",")
        );
      }),
      (e.prototype.deserialize = function (E) {
        var A = this;
        this.buckets.clear(),
          E.split(",").forEach(function (R) {
            var k = R.split(":");
            A.buckets.set(parseInt(k[0], 36), parseInt(k[1], 36));
          });
      });
    var t = Math.pow(2, 8),
      r = t - 1,
      i = ~r;
    function o(E) {
      var A = (function (k) {
          return k & i;
        })(E).toString(16),
        R = (function (k) {
          return (k & i) + t - 1;
        })(E).toString(16);
      return "codepoint-index/plane" + (E >> 16) + "/" + A + "-" + R + ".json";
    }
    function s(E, A) {
      var R = E & r,
        k = A.codePointAt((R / 6) | 0);
      return ((k = (k || 48) - 48) & (1 << R % 6)) != 0;
    }
    function l(E, A) {
      var R;
      ((R = E),
      R.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (k) {
          return k.split("-").map(function (P) {
            return parseInt(P.trim(), 16);
          });
        })).forEach(function (k) {
        var P = k[0],
          U = k[1];
        U === void 0 && (U = P), A(P, U);
      });
    }
    function u(E, A) {
      l(E, function (R, k) {
        for (var P = R; P <= k; P++) A(P);
      });
    }
    var f = {},
      h = {},
      m = new WeakMap(),
      g =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function y(E) {
      var A = m.get(E);
      return (
        A ||
          ((A = new e()),
          u(E.ranges, function (R) {
            return A.add(R);
          }),
          m.set(E, A)),
        A
      );
    }
    var x,
      S = new Map();
    function _(E, A, R) {
      return E[A]
        ? A
        : E[R]
        ? R
        : (function (k) {
            for (var P in k) return P;
          })(E);
    }
    function w(E, A) {
      var R = A;
      if (!E.includes(R)) {
        R = 1 / 0;
        for (var k = 0; k < E.length; k++)
          Math.abs(E[k] - A) < Math.abs(R - A) && (R = E[k]);
      }
      return R;
    }
    function T(E) {
      return (
        x ||
          ((x = new Set()),
          u("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (A) {
            x.add(A);
          })),
        x.has(E)
      );
    }
    return (
      (n.CodePointSet = e),
      (n.clearCache = function () {
        (f = {}), (h = {});
      }),
      (n.getFontsForString = function (E, A) {
        A === void 0 && (A = {});
        var R,
          k = A.lang;
        k === void 0 &&
          (k = new RegExp("\\p{Script=Hangul}", "u").test((R = E))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                R
              )
            ? "ja"
            : "en");
        var P = A.category;
        P === void 0 && (P = "sans-serif");
        var U = A.style;
        U === void 0 && (U = "normal");
        var N = A.weight;
        N === void 0 && (N = 400);
        var L = (A.dataUrl || g).replace(/\/$/g, ""),
          H = new Map(),
          G = new Uint8Array(E.length),
          $ = {},
          q = {},
          Z = new Array(E.length),
          X = new Map(),
          re = !1;
        function W(V) {
          var ne = S.get(V);
          return (
            ne ||
              ((ne = fetch(L + "/" + V)
                .then(function (ae) {
                  if (!ae.ok) throw new Error(ae.statusText);
                  return ae.json().then(function (J) {
                    if (!Array.isArray(J) || J[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + J[0]
                      );
                    return J[1];
                  });
                })
                .catch(function (ae) {
                  if (L !== g)
                    return (
                      re ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            L +
                            '", trying default CDN. ' +
                            ae.message
                        ),
                        (re = !0)),
                      (L = g),
                      S.delete(V),
                      W(V)
                    );
                  throw ae;
                })),
              S.set(V, ne)),
            ne
          );
        }
        for (
          var te = function (V) {
              var ne = E.codePointAt(V),
                ae = o(ne);
              (Z[V] = ae),
                f[ae] ||
                  X.has(ae) ||
                  X.set(
                    ae,
                    W(ae).then(function (J) {
                      f[ae] = J;
                    })
                  ),
                ne > 65535 && (V++, (F = V));
            },
            F = 0;
          F < E.length;
          F++
        )
          te(F);
        return Promise.all(X.values())
          .then(function () {
            X.clear();
            for (
              var V = function (ae) {
                  var J = E.codePointAt(ae),
                    oe = null,
                    de = f[Z[ae]],
                    le = void 0;
                  for (var fe in de) {
                    var Ee = q[fe];
                    if (
                      (Ee === void 0 &&
                        (Ee = q[fe] = new RegExp(fe).test(k || "en")),
                      Ee)
                    ) {
                      for (var ge in ((le = fe), de[fe]))
                        if (s(J, de[fe][ge])) {
                          oe = ge;
                          break;
                        }
                      break;
                    }
                  }
                  if (!oe) {
                    e: for (var xe in de)
                      if (xe !== le) {
                        for (var j in de[xe])
                          if (s(J, de[xe][j])) {
                            oe = j;
                            break e;
                          }
                      }
                  }
                  oe ||
                    (console.debug("No font coverage for U+" + J.toString(16)),
                    (oe = "latin")),
                    (Z[ae] = oe),
                    h[oe] ||
                      X.has(oe) ||
                      X.set(
                        oe,
                        W("font-meta/" + oe + ".json").then(function (we) {
                          h[oe] = we;
                        })
                      ),
                    J > 65535 && (ae++, (ne = ae));
                },
                ne = 0;
              ne < E.length;
              ne++
            )
              V(ne);
            return Promise.all(X.values());
          })
          .then(function () {
            for (var V, ne = null, ae = 0; ae < E.length; ae++) {
              var J = E.codePointAt(ae);
              if (ne && (T(J) || y(ne).has(J))) G[ae] = G[ae - 1];
              else {
                ne = h[Z[ae]];
                var oe = $[ne.id];
                if (!oe) {
                  var de = ne.typeforms,
                    le = _(de, P, "sans-serif"),
                    fe = _(de[le], U, "normal"),
                    Ee = w(
                      (V = de[le]) === null || V === void 0 ? void 0 : V[fe],
                      N
                    );
                  oe = $[ne.id] =
                    L +
                    "/font-files/" +
                    ne.id +
                    "/" +
                    le +
                    "." +
                    fe +
                    "." +
                    Ee +
                    ".woff";
                }
                var ge = H.get(oe);
                ge == null && ((ge = H.size), H.set(oe, ge)), (G[ae] = ge);
              }
              J > 65535 && (ae++, (G[ae] = G[ae - 1]));
            }
            return { fontUrls: Array.from(H.keys()), chars: G };
          });
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({});
}
function UW(n, e) {
  const t = Object.create(null),
    r = Object.create(null);
  function i(s, l) {
    const u = (f) => {
      console.error(`Failure loading font ${s}`, f);
    };
    try {
      const f = new XMLHttpRequest();
      f.open("get", s, !0),
        (f.responseType = "arraybuffer"),
        (f.onload = function () {
          if (f.status >= 400) u(new Error(f.statusText));
          else if (f.status > 0)
            try {
              const h = n(f.response);
              (h.src = s), l(h);
            } catch (h) {
              u(h);
            }
        }),
        (f.onerror = u),
        f.send();
    } catch (f) {
      u(f);
    }
  }
  function o(s, l) {
    let u = t[s];
    u
      ? l(u)
      : r[s]
      ? r[s].push(l)
      : ((r[s] = [l]),
        i(s, (f) => {
          (f.src = s), (t[s] = f), r[s].forEach((h) => h(f)), delete r[s];
        }));
  }
  return function (
    s,
    l,
    {
      lang: u,
      fonts: f = [],
      style: h = "normal",
      weight: m = "normal",
      unicodeFontsURL: g,
    } = {}
  ) {
    const y = new Uint8Array(s.length),
      x = [];
    s.length || T();
    const S = new Map(),
      _ = [];
    if (
      (h !== "italic" && (h = "normal"),
      typeof m != "number" && (m = m === "bold" ? 700 : 400),
      f && !Array.isArray(f) && (f = [f]),
      (f = f
        .slice()
        .filter((A) => !A.lang || A.lang.test(u))
        .reverse()),
      f.length)
    ) {
      let P = 0;
      (function U(N = 0) {
        for (let L = N, H = s.length; L < H; L++) {
          const G = s.codePointAt(L);
          if ((P === 1 && x[y[L - 1]].supportsCodePoint(G)) || /\s/.test(s[L]))
            (y[L] = y[L - 1]), P === 2 && (_[_.length - 1][1] = L);
          else
            for (let $ = y[L], q = f.length; $ <= q; $++)
              if ($ === q) {
                const Z = P === 2 ? _[_.length - 1] : (_[_.length] = [L, L]);
                (Z[1] = L), (P = 2);
              } else {
                y[L] = $;
                const { src: Z, unicodeRange: X } = f[$];
                if (!X || E(G, X)) {
                  const re = t[Z];
                  if (!re) {
                    o(Z, () => {
                      U(L);
                    });
                    return;
                  }
                  if (re.supportsCodePoint(G)) {
                    let W = S.get(re);
                    typeof W != "number" &&
                      ((W = x.length), x.push(re), S.set(re, W)),
                      (y[L] = W),
                      (P = 1);
                    break;
                  }
                }
              }
          G > 65535 &&
            L + 1 < H &&
            ((y[L + 1] = y[L]), L++, P === 2 && (_[_.length - 1][1] = L));
        }
        w();
      })();
    } else _.push([0, s.length - 1]), w();
    function w() {
      if (_.length) {
        const A = _.map((R) => s.substring(R[0], R[1] + 1)).join(`
`);
        e.getFontsForString(A, {
          lang: u || void 0,
          style: h,
          weight: m,
          dataUrl: g,
        }).then(({ fontUrls: R, chars: k }) => {
          const P = x.length;
          let U = 0;
          _.forEach((L) => {
            for (let H = 0, G = L[1] - L[0]; H <= G; H++)
              y[L[0] + H] = k[U++] + P;
            U++;
          });
          let N = 0;
          R.forEach((L, H) => {
            o(L, (G) => {
              (x[H + P] = G), ++N === R.length && T();
            });
          });
        });
      } else T();
    }
    function T() {
      l({ chars: y, fonts: x });
    }
    function E(A, R) {
      for (let k = 0; k < R.length; k++) {
        const [P, U = P] = R[k];
        if (P <= A && A <= U) return !0;
      }
      return !1;
    }
  };
}
const FW = Bh({
  name: "FontResolver",
  dependencies: [UW, NW, OW],
  init(n, e, t) {
    return n(e, t());
  },
});
function BW(n, e) {
  const r =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    i = "[^\\S\\u00A0]",
    o = new RegExp(
      `${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function s(
    {
      text: x,
      lang: S,
      fonts: _,
      style: w,
      weight: T,
      preResolvedFonts: E,
      unicodeFontsURL: A,
    },
    R
  ) {
    const k = ({ chars: P, fonts: U }) => {
      let N, L;
      const H = [];
      for (let G = 0; G < P.length; G++)
        P[G] !== L
          ? ((L = P[G]), H.push((N = { start: G, end: G, fontObj: U[P[G]] })))
          : (N.end = G);
      R(H);
    };
    E
      ? k(E)
      : n(x, k, { lang: S, fonts: _, style: w, weight: T, unicodeFontsURL: A });
  }
  function l(
    {
      text: x = "",
      font: S,
      lang: _,
      sdfGlyphSize: w = 64,
      fontSize: T = 400,
      fontWeight: E = 1,
      fontStyle: A = "normal",
      letterSpacing: R = 0,
      lineHeight: k = "normal",
      maxWidth: P = 1 / 0,
      direction: U,
      textAlign: N = "left",
      textIndent: L = 0,
      whiteSpace: H = "normal",
      overflowWrap: G = "normal",
      anchorX: $ = 0,
      anchorY: q = 0,
      metricsOnly: Z = !1,
      unicodeFontsURL: X,
      preResolvedFonts: re = null,
      includeCaretPositions: W = !1,
      chunkedBoundsSize: te = 8192,
      colorRanges: F = null,
    },
    V
  ) {
    const ne = m(),
      ae = { fontLoad: 0, typesetting: 0 };
    x.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (x = x
        .replace(
          /\r\n/g,
          `
`
        )
        .replace(
          /\r/g,
          `
`
        ))),
      (T = +T),
      (R = +R),
      (P = +P),
      (k = k || "normal"),
      (L = +L),
      s(
        {
          text: x,
          lang: _,
          style: A,
          weight: E,
          fonts: typeof S == "string" ? [{ src: S }] : S,
          unicodeFontsURL: X,
          preResolvedFonts: re,
        },
        (J) => {
          ae.fontLoad = m() - ne;
          const oe = isFinite(P);
          let de = null,
            le = null,
            fe = null,
            Ee = null,
            ge = null,
            xe = null,
            j = null,
            we = null,
            Ae = 0,
            Ne = 0,
            Ie = H !== "nowrap";
          const rt = new Map(),
            ke = m();
          let Xe = L,
            ee = 0,
            B = new g();
          const ve = [B];
          J.forEach((Fe) => {
            const { fontObj: Be } = Fe,
              {
                ascender: We,
                descender: Ye,
                unitsPerEm: nt,
                lineGap: yt,
                capHeight: $e,
                xHeight: qe,
              } = Be;
            let et = rt.get(Be);
            if (!et) {
              const Re = T / nt,
                Ue = k === "normal" ? (We - Ye + yt) * Re : k * T,
                it = (Ue - (We - Ye) * Re) / 2,
                mt = Math.min(Ue, (We - Ye) * Re),
                gt = ((We + Ye) / 2) * Re + mt / 2;
              (et = {
                index: rt.size,
                src: Be.src,
                fontObj: Be,
                fontSizeMult: Re,
                unitsPerEm: nt,
                ascender: We * Re,
                descender: Ye * Re,
                capHeight: $e * Re,
                xHeight: qe * Re,
                lineHeight: Ue,
                baseline: -it - We * Re,
                caretTop: ((We + Ye) / 2) * Re + mt / 2,
                caretBottom: gt - mt,
              }),
                rt.set(Be, et);
            }
            const { fontSizeMult: he } = et,
              Je = x.slice(Fe.start, Fe.end + 1);
            let me, Ve;
            Be.forEachGlyph(Je, T, R, (Re, Ue, it, mt) => {
              (Ue += ee), (mt += Fe.start), (me = Ue), (Ve = Re);
              const gt = x.charAt(mt),
                Ot = Re.advanceWidth * he,
                Ut = B.count;
              let ht;
              if (
                ("isEmpty" in Re ||
                  ((Re.isWhitespace = !!gt && new RegExp(i).test(gt)),
                  (Re.canBreakAfter = !!gt && o.test(gt)),
                  (Re.isEmpty =
                    Re.xMin === Re.xMax || Re.yMin === Re.yMax || r.test(gt))),
                !Re.isWhitespace && !Re.isEmpty && Ne++,
                Ie && oe && !Re.isWhitespace && Ue + Ot + Xe > P && Ut)
              ) {
                if (B.glyphAt(Ut - 1).glyphObj.canBreakAfter)
                  (ht = new g()), (Xe = -Ue);
                else
                  for (let un = Ut; un--; )
                    if (un === 0 && G === "break-word") {
                      (ht = new g()), (Xe = -Ue);
                      break;
                    } else if (B.glyphAt(un).glyphObj.canBreakAfter) {
                      ht = B.splitAt(un + 1);
                      const Sn = ht.glyphAt(0).x;
                      Xe -= Sn;
                      for (let mn = ht.count; mn--; ) ht.glyphAt(mn).x -= Sn;
                      break;
                    }
                ht && ((B.isSoftWrapped = !0), (B = ht), ve.push(B), (Ae = P));
              }
              let $t = B.glyphAt(B.count);
              ($t.glyphObj = Re),
                ($t.x = Ue + Xe),
                ($t.y = it),
                ($t.width = Ot),
                ($t.charIndex = mt),
                ($t.fontData = et),
                gt ===
                  `
` && ((B = new g()), ve.push(B), (Xe = -(Ue + Ot + R * T) + L));
            }),
              (ee = me + Ve.advanceWidth * he + R * T);
          });
          let Se = 0;
          ve.forEach((Fe) => {
            let Be = !0;
            for (let We = Fe.count; We--; ) {
              const Ye = Fe.glyphAt(We);
              Be &&
                !Ye.glyphObj.isWhitespace &&
                ((Fe.width = Ye.x + Ye.width),
                Fe.width > Ae && (Ae = Fe.width),
                (Be = !1));
              let {
                lineHeight: nt,
                capHeight: yt,
                xHeight: $e,
                baseline: qe,
              } = Ye.fontData;
              nt > Fe.lineHeight && (Fe.lineHeight = nt);
              const et = qe - Fe.baseline;
              et < 0 && ((Fe.baseline += et), (Fe.cap += et), (Fe.ex += et)),
                (Fe.cap = Math.max(Fe.cap, Fe.baseline + yt)),
                (Fe.ex = Math.max(Fe.ex, Fe.baseline + $e));
            }
            (Fe.baseline -= Se),
              (Fe.cap -= Se),
              (Fe.ex -= Se),
              (Se += Fe.lineHeight);
          });
          let _e = 0,
            Te = 0;
          if (
            ($ &&
              (typeof $ == "number"
                ? (_e = -$)
                : typeof $ == "string" &&
                  (_e =
                    -Ae *
                    ($ === "left"
                      ? 0
                      : $ === "center"
                      ? 0.5
                      : $ === "right"
                      ? 1
                      : f($)))),
            q &&
              (typeof q == "number"
                ? (Te = -q)
                : typeof q == "string" &&
                  (Te =
                    q === "top"
                      ? 0
                      : q === "top-baseline"
                      ? -ve[0].baseline
                      : q === "top-cap"
                      ? -ve[0].cap
                      : q === "top-ex"
                      ? -ve[0].ex
                      : q === "middle"
                      ? Se / 2
                      : q === "bottom"
                      ? Se
                      : q === "bottom-baseline"
                      ? ve[ve.length - 1].baseline
                      : f(q) * Se)),
            !Z)
          ) {
            const Fe = e.getEmbeddingLevels(x, U);
            (de = new Uint16Array(Ne)),
              (le = new Uint8Array(Ne)),
              (fe = new Float32Array(Ne * 2)),
              (Ee = {}),
              (j = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (we = []),
              W && (xe = new Float32Array(x.length * 4)),
              F && (ge = new Uint8Array(Ne * 3));
            let Be = 0,
              We = -1,
              Ye = -1,
              nt,
              yt;
            if (
              (ve.forEach(($e, qe) => {
                let { count: et, width: he } = $e;
                if (et > 0) {
                  let Je = 0;
                  for (
                    let mt = et;
                    mt-- && $e.glyphAt(mt).glyphObj.isWhitespace;

                  )
                    Je++;
                  let me = 0,
                    Ve = 0;
                  if (N === "center") me = (Ae - he) / 2;
                  else if (N === "right") me = Ae - he;
                  else if (N === "justify" && $e.isSoftWrapped) {
                    let mt = 0;
                    for (let gt = et - Je; gt--; )
                      $e.glyphAt(gt).glyphObj.isWhitespace && mt++;
                    Ve = (Ae - he) / mt;
                  }
                  if (Ve || me) {
                    let mt = 0;
                    for (let gt = 0; gt < et; gt++) {
                      let Ot = $e.glyphAt(gt);
                      const Ut = Ot.glyphObj;
                      (Ot.x += me + mt),
                        Ve !== 0 &&
                          Ut.isWhitespace &&
                          gt < et - Je &&
                          ((mt += Ve), (Ot.width += Ve));
                    }
                  }
                  const Re = e.getReorderSegments(
                    x,
                    Fe,
                    $e.glyphAt(0).charIndex,
                    $e.glyphAt($e.count - 1).charIndex
                  );
                  for (let mt = 0; mt < Re.length; mt++) {
                    const [gt, Ot] = Re[mt];
                    let Ut = 1 / 0,
                      ht = -1 / 0;
                    for (let $t = 0; $t < et; $t++)
                      if ($e.glyphAt($t).charIndex >= gt) {
                        let un = $t,
                          Sn = $t;
                        for (; Sn < et; Sn++) {
                          let mn = $e.glyphAt(Sn);
                          if (mn.charIndex > Ot) break;
                          Sn < et - Je &&
                            ((Ut = Math.min(Ut, mn.x)),
                            (ht = Math.max(ht, mn.x + mn.width)));
                        }
                        for (let mn = un; mn < Sn; mn++) {
                          const lr = $e.glyphAt(mn);
                          lr.x = ht - (lr.x + lr.width - Ut);
                        }
                        break;
                      }
                  }
                  let Ue;
                  const it = (mt) => (Ue = mt);
                  for (let mt = 0; mt < et; mt++) {
                    const gt = $e.glyphAt(mt);
                    Ue = gt.glyphObj;
                    const Ot = Ue.index,
                      Ut = Fe.levels[gt.charIndex] & 1;
                    if (Ut) {
                      const ht = e.getMirroredCharacter(x[gt.charIndex]);
                      ht && gt.fontData.fontObj.forEachGlyph(ht, 0, 0, it);
                    }
                    if (W) {
                      const { charIndex: ht, fontData: $t } = gt,
                        un = gt.x + _e,
                        Sn = gt.x + gt.width + _e;
                      (xe[ht * 4] = Ut ? Sn : un),
                        (xe[ht * 4 + 1] = Ut ? un : Sn),
                        (xe[ht * 4 + 2] = $e.baseline + $t.caretBottom + Te),
                        (xe[ht * 4 + 3] = $e.baseline + $t.caretTop + Te);
                      const mn = ht - We;
                      mn > 1 && h(xe, We, mn), (We = ht);
                    }
                    if (F) {
                      const { charIndex: ht } = gt;
                      for (; ht > Ye; )
                        Ye++, F.hasOwnProperty(Ye) && (yt = F[Ye]);
                    }
                    if (!Ue.isWhitespace && !Ue.isEmpty) {
                      const ht = Be++,
                        { fontSizeMult: $t, src: un, index: Sn } = gt.fontData,
                        mn = Ee[un] || (Ee[un] = {});
                      mn[Ot] ||
                        (mn[Ot] = {
                          path: Ue.path,
                          pathBounds: [Ue.xMin, Ue.yMin, Ue.xMax, Ue.yMax],
                        });
                      const lr = gt.x + _e,
                        Ui = gt.y + $e.baseline + Te;
                      (fe[ht * 2] = lr), (fe[ht * 2 + 1] = Ui);
                      const yr = lr + Ue.xMin * $t,
                        Fr = Ui + Ue.yMin * $t,
                        Ar = lr + Ue.xMax * $t,
                        Br = Ui + Ue.yMax * $t;
                      yr < j[0] && (j[0] = yr),
                        Fr < j[1] && (j[1] = Fr),
                        Ar > j[2] && (j[2] = Ar),
                        Br > j[3] && (j[3] = Br),
                        ht % te === 0 &&
                          ((nt = {
                            start: ht,
                            end: ht,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          we.push(nt)),
                        nt.end++;
                      const xr = nt.rect;
                      if (
                        (yr < xr[0] && (xr[0] = yr),
                        Fr < xr[1] && (xr[1] = Fr),
                        Ar > xr[2] && (xr[2] = Ar),
                        Br > xr[3] && (xr[3] = Br),
                        (de[ht] = Ot),
                        (le[ht] = Sn),
                        F)
                      ) {
                        const yo = ht * 3;
                        (ge[yo] = (yt >> 16) & 255),
                          (ge[yo + 1] = (yt >> 8) & 255),
                          (ge[yo + 2] = yt & 255);
                      }
                    }
                  }
                }
              }),
              xe)
            ) {
              const $e = x.length - We;
              $e > 1 && h(xe, We, $e);
            }
          }
          const at = [];
          rt.forEach(
            ({
              index: Fe,
              src: Be,
              unitsPerEm: We,
              ascender: Ye,
              descender: nt,
              lineHeight: yt,
              capHeight: $e,
              xHeight: qe,
            }) => {
              at[Fe] = {
                src: Be,
                unitsPerEm: We,
                ascender: Ye,
                descender: nt,
                lineHeight: yt,
                capHeight: $e,
                xHeight: qe,
              };
            }
          ),
            (ae.typesetting = m() - ke),
            V({
              glyphIds: de,
              glyphFontIndices: le,
              glyphPositions: fe,
              glyphData: Ee,
              fontData: at,
              caretPositions: xe,
              glyphColors: ge,
              chunkedBounds: we,
              fontSize: T,
              topBaseline: Te + ve[0].baseline,
              blockBounds: [_e, Te - Se, _e + Ae, Te],
              visibleBounds: j,
              timings: ae,
            });
        }
      );
  }
  function u(x, S) {
    l({ ...x, metricsOnly: !0 }, (_) => {
      const [w, T, E, A] = _.blockBounds;
      S({ width: E - w, height: A - T });
    });
  }
  function f(x) {
    let S = x.match(/^([\d.]+)%$/),
      _ = S ? parseFloat(S[1]) : NaN;
    return isNaN(_) ? 0 : _ / 100;
  }
  function h(x, S, _) {
    const w = x[S * 4],
      T = x[S * 4 + 1],
      E = x[S * 4 + 2],
      A = x[S * 4 + 3],
      R = (T - w) / _;
    for (let k = 0; k < _; k++) {
      const P = (S + k) * 4;
      (x[P] = w + R * k),
        (x[P + 1] = w + R * (k + 1)),
        (x[P + 2] = E),
        (x[P + 3] = A);
    }
  }
  function m() {
    return (self.performance || Date).now();
  }
  function g() {
    this.data = [];
  }
  const y = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (g.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / y.length);
      },
      glyphAt(x) {
        let S = g.flyweight;
        return (S.data = this.data), (S.index = x), S;
      },
      splitAt(x) {
        let S = new g();
        return (S.data = this.data.splice(x * y.length)), S;
      },
    }),
    (g.flyweight = y.reduce(
      (x, S, _, w) => (
        Object.defineProperty(x, S, {
          get() {
            return this.data[this.index * y.length + _];
          },
          set(T) {
            this.data[this.index * y.length + _] = T;
          },
        }),
        x
      ),
      { data: null, index: 0 }
    )),
    { typeset: l, measure: u }
  );
}
const gf = () => (self.performance || Date).now(),
  dx = wP();
let vC;
function zW(n, e, t, r, i, o, s, l, u, f, h = !0) {
  return h
    ? VW(n, e, t, r, i, o, s, l, u, f).then(
        null,
        (m) => (
          vC ||
            (console.warn("WebGL SDF generation failed, falling back to JS", m),
            (vC = !0)),
          xC(n, e, t, r, i, o, s, l, u, f)
        )
      )
    : xC(n, e, t, r, i, o, s, l, u, f);
}
const m0 = [],
  HW = 5;
let mS = 0;
function MP() {
  const n = gf();
  for (; m0.length && gf() - n < HW; ) m0.shift()();
  mS = m0.length ? setTimeout(MP, 0) : 0;
}
const VW = (...n) =>
    new Promise((e, t) => {
      m0.push(() => {
        const r = gf();
        try {
          dx.webgl.generateIntoCanvas(...n), e({ timing: gf() - r });
        } catch (i) {
          t(i);
        }
      }),
        mS || (mS = setTimeout(MP, 0));
    }),
  GW = 4,
  WW = 2e3,
  yC = {};
let jW = 0;
function xC(n, e, t, r, i, o, s, l, u, f) {
  const h = "TroikaTextSDFGenerator_JS_" + (jW++ % GW);
  let m = yC[h];
  return (
    m ||
      (m = yC[h] =
        {
          workerModule: Bh({
            name: h,
            workerId: h,
            dependencies: [wP, gf],
            init(g, y) {
              const x = g().javascript.generate;
              return function (...S) {
                const _ = y();
                return { textureData: x(...S), timing: y() - _ };
              };
            },
            getTransferables(g) {
              return [g.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    m.requests++,
    clearTimeout(m.idleTimer),
    m.workerModule(n, e, t, r, i, o).then(({ textureData: g, timing: y }) => {
      const x = gf(),
        S = new Uint8Array(g.length * 4);
      for (let _ = 0; _ < g.length; _++) S[_ * 4 + f] = g[_];
      return (
        dx.webglUtils.renderImageData(s, S, l, u, n, e, 1 << (3 - f)),
        (y += gf() - x),
        --m.requests === 0 &&
          (m.idleTimer = setTimeout(() => {
            wW(h);
          }, WW)),
        { timing: y }
      );
    })
  );
}
function $W(n) {
  n._warm || (dx.webgl.isSupported(n), (n._warm = !0));
}
const XW = dx.webglUtils.resizeWebGLCanvasWithoutClearing,
  em = {
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  YW = new St();
function eh() {
  return (self.performance || Date).now();
}
const _C = Object.create(null);
function EP(n, e) {
  n = ZW({}, n);
  const t = eh(),
    r = [];
  if (
    (n.font && r.push({ label: "user", src: JW(n.font) }),
    (n.font = r),
    (n.text = "" + n.text),
    (n.sdfGlyphSize = n.sdfGlyphSize || em.sdfGlyphSize),
    (n.unicodeFontsURL = n.unicodeFontsURL || em.unicodeFontsURL),
    n.colorRanges != null)
  ) {
    let m = {};
    for (let g in n.colorRanges)
      if (n.colorRanges.hasOwnProperty(g)) {
        let y = n.colorRanges[g];
        typeof y != "number" && (y = YW.set(y).getHex()), (m[g] = y);
      }
    n.colorRanges = m;
  }
  Object.freeze(n);
  const { textureWidth: i, sdfExponent: o } = em,
    { sdfGlyphSize: s } = n,
    l = (i / s) * 4;
  let u = _C[s];
  if (!u) {
    const m = document.createElement("canvas");
    (m.width = i),
      (m.height = (s * 256) / l),
      (u = _C[s] =
        {
          glyphCount: 0,
          sdfGlyphSize: s,
          sdfCanvas: m,
          sdfTexture: new Qn(m, void 0, void 0, void 0, Cr, Cr),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (u.sdfTexture.generateMipmaps = !1),
      qW(u);
  }
  const { sdfTexture: f, sdfCanvas: h } = u;
  e9(n).then((m) => {
    const {
        glyphIds: g,
        glyphFontIndices: y,
        fontData: x,
        glyphPositions: S,
        fontSize: _,
        timings: w,
      } = m,
      T = [],
      E = new Float32Array(g.length * 4);
    let A = 0,
      R = 0;
    const k = eh(),
      P = x.map((G) => {
        let $ = u.glyphsByFont.get(G.src);
        return $ || u.glyphsByFont.set(G.src, ($ = new Map())), $;
      });
    g.forEach((G, $) => {
      const q = y[$],
        { src: Z, unitsPerEm: X } = x[q];
      let re = P[q].get(G);
      if (!re) {
        const { path: ne, pathBounds: ae } = m.glyphData[Z][G],
          J =
            (Math.max(ae[2] - ae[0], ae[3] - ae[1]) / s) *
            (em.sdfMargin * s + 0.5),
          oe = u.glyphCount++,
          de = [ae[0] - J, ae[1] - J, ae[2] + J, ae[3] + J];
        P[q].set(G, (re = { path: ne, atlasIndex: oe, sdfViewBox: de })),
          T.push(re);
      }
      const { sdfViewBox: W } = re,
        te = S[R++],
        F = S[R++],
        V = _ / X;
      (E[A++] = te + W[0] * V),
        (E[A++] = F + W[1] * V),
        (E[A++] = te + W[2] * V),
        (E[A++] = F + W[3] * V),
        (g[$] = re.atlasIndex);
    }),
      (w.quads = (w.quads || 0) + (eh() - k));
    const U = eh();
    w.sdf = {};
    const N = h.height,
      L = Math.ceil(u.glyphCount / l),
      H = Math.pow(2, Math.ceil(Math.log2(L * s)));
    H > N &&
      (console.info(`Increasing SDF texture size ${N}->${H}`),
      XW(h, i, H),
      f.dispose()),
      Promise.all(
        T.map((G) =>
          TP(G, u, n.gpuAccelerateSDF).then(({ timing: $ }) => {
            w.sdf[G.atlasIndex] = $;
          })
        )
      ).then(() => {
        T.length && !u.contextLost && (CP(u), (f.needsUpdate = !0)),
          (w.sdfTotal = eh() - U),
          (w.total = eh() - t),
          e(
            Object.freeze({
              parameters: n,
              sdfTexture: f,
              sdfGlyphSize: s,
              sdfExponent: o,
              glyphBounds: E,
              glyphAtlasIndices: g,
              glyphColors: m.glyphColors,
              caretPositions: m.caretPositions,
              chunkedBounds: m.chunkedBounds,
              ascender: m.ascender,
              descender: m.descender,
              lineHeight: m.lineHeight,
              capHeight: m.capHeight,
              xHeight: m.xHeight,
              topBaseline: m.topBaseline,
              blockBounds: m.blockBounds,
              visibleBounds: m.visibleBounds,
              timings: m.timings,
            })
          );
      });
  }),
    Promise.resolve().then(() => {
      u.contextLost || $W(h);
    });
}
function TP(
  { path: n, atlasIndex: e, sdfViewBox: t },
  { sdfGlyphSize: r, sdfCanvas: i, contextLost: o },
  s
) {
  if (o) return Promise.resolve({ timing: -1 });
  const { textureWidth: l, sdfExponent: u } = em,
    f = Math.max(t[2] - t[0], t[3] - t[1]),
    h = Math.floor(e / 4),
    m = (h % (l / r)) * r,
    g = Math.floor(h / (l / r)) * r,
    y = e % 4;
  return zW(r, r, n, t, f, u, i, m, g, y, s);
}
function qW(n) {
  const e = n.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), (n.contextLost = !0);
  }),
    e.addEventListener("webglcontextrestored", (t) => {
      console.log("Context Restored", t), (n.contextLost = !1);
      const r = [];
      n.glyphsByFont.forEach((i) => {
        i.forEach((o) => {
          r.push(TP(o, n, !0));
        });
      }),
        Promise.all(r).then(() => {
          CP(n), (n.sdfTexture.needsUpdate = !0);
        });
    });
}
function KW({ font: n, characters: e, sdfGlyphSize: t }, r) {
  let i = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  EP({ font: n, sdfGlyphSize: t, text: i }, r);
}
function ZW(n, e) {
  for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
  return n;
}
let i0;
function JW(n) {
  return (
    i0 || (i0 = typeof document > "u" ? {} : document.createElement("a")),
    (i0.href = n),
    i0.href
  );
}
function CP(n) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = n,
      { width: r, height: i } = e,
      o = n.sdfCanvas.getContext("webgl");
    let s = t.image.data;
    (!s || s.length !== r * i * 4) &&
      ((s = new Uint8Array(r * i * 4)),
      (t.image = { width: r, height: i, data: s }),
      (t.flipY = !1),
      (t.isDataTexture = !0)),
      o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, s);
  }
}
const QW = Bh({
    name: "Typesetter",
    dependencies: [BW, FW, MW],
    init(n, e, t) {
      return n(e, t());
    },
  }),
  e9 = Bh({
    name: "Typesetter",
    dependencies: [QW],
    init(n) {
      return function (e) {
        return new Promise((t) => {
          n.typeset(e, t);
        });
      };
    },
    getTransferables(n) {
      const e = [];
      for (let t in n) n[t] && n[t].buffer && e.push(n[t].buffer);
      return e;
    },
  }),
  SC = {};
function t9(n) {
  let e = SC[n];
  if (!e) {
    const t = new Hl(1, 1, n, n),
      r = t.clone(),
      i = t.attributes,
      o = r.attributes,
      s = new Jt(),
      l = i.uv.count;
    for (let u = 0; u < l; u++)
      (o.position.array[u * 3] *= -1), (o.normal.array[u * 3 + 2] *= -1);
    ["position", "normal", "uv"].forEach((u) => {
      s.setAttribute(u, new kt([...i[u].array, ...o[u].array], i[u].itemSize));
    }),
      s.setIndex([...t.index.array, ...r.index.array.map((u) => u + l)]),
      s.translate(0.5, 0.5, 0),
      (e = SC[n] = s);
  }
  return e;
}
const n9 = "aTroikaGlyphBounds",
  wC = "aTroikaGlyphIndex",
  r9 = "aTroikaGlyphColor";
class i9 extends Uw {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new Ni()),
      (this.boundingBox = new to());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === Qi ? t / 2 : 0, e === Ts ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      (this._detail = e), (typeof e != "number" || e < 1) && (e = 1);
      let t = t9(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }),
        this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, t, r, i, o) {
    b1(this, n9, e, 4),
      b1(this, wC, t, 1),
      b1(this, r9, o, 3),
      (this._blockBounds = r),
      (this._chunkedBounds = i),
      (this.instanceCount = t.length),
      this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: i, floor: o, min: s, max: l, sin: u, cos: f } = Math,
          h = i / 2,
          m = i * 2,
          g = Math.abs(t),
          y = e[0] / g,
          x = e[2] / g,
          S = o((y + h) / m) !== o((x + h) / m) ? -g : s(u(y) * g, u(x) * g),
          _ = o((y - h) / m) !== o((x - h) / m) ? g : l(u(y) * g, u(x) * g),
          w =
            o((y + i) / m) !== o((x + i) / m)
              ? g * 2
              : l(g - f(y) * g, g - f(x) * g);
        r.min.set(S, e[1], t < 0 ? -w : 0), r.max.set(_, e[3], t < 0 ? 0 : w);
      } else r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let t = this.getAttribute(wC).count,
      r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        t = r[i].end;
        let o = r[i].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x) break;
      }
    this.instanceCount = t;
  }
}
function b1(n, e, t, r) {
  const i = n.getAttribute(e);
  t
    ? i && i.array.length === t.length
      ? (i.array.set(t), (i.needsUpdate = !0))
      : (n.setAttribute(e, new wf(t, r)),
        delete n._maxInstanceCount,
        n.dispose())
    : i && n.deleteAttribute(e);
}
const o9 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  s9 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  a9 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  l9 = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function u9(n) {
  const e = pS(n, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new tt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Tn(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Tn(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new tt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new St() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new tn() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: o9,
    vertexTransform: s9,
    fragmentDefs: a9,
    fragmentColorTransform: l9,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return (
        i.test(r) &&
          ((r = r
            .replace(i, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          i.test(t) ||
            (t = t.replace(
              bP,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: t, fragmentShader: r }
      );
    },
  });
  return (
    (e.transparent = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const $w = new zl({ color: 16777215, side: Ts, transparent: !0 }),
  bC = 8421504,
  MC = new Wt(),
  o0 = new se(),
  M1 = new se(),
  Xp = [],
  c9 = new se(),
  E1 = "+x+y";
function EC(n) {
  return Array.isArray(n) ? n[0] : n;
}
let AP = () => {
    const n = new vr(new Hl(1, 1), $w);
    return (AP = () => n), n;
  },
  RP = () => {
    const n = new vr(new Hl(1, 1, 32, 1), $w);
    return (RP = () => n), n;
  };
const f9 = { type: "syncstart" },
  d9 = { type: "synccomplete" },
  PP = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  h9 = PP.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let IP = class extends vr {
  constructor() {
    const e = new i9();
    super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = bC),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = E1),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(f9),
          EP(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (t) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = t),
                this.geometry.updateGlyphs(
                  t.glyphBounds,
                  t.glyphAtlasIndices,
                  t.blockBounds,
                  t.chunkedBounds,
                  t.glyphColors
                );
              const r = this._queuedSyncs;
              r &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  r.forEach((i) => i && i());
                })),
                this.dispatchEvent(d9),
                e && e();
            }
          )));
  }
  onBeforeRender(e, t, r, i, o, s) {
    this.sync(),
      o.isTroikaTextMaterial && this._prepareForRender(o),
      (o._hadOwnSide = o.hasOwnProperty("side")),
      this.geometry.setSide((o._actualSide = o.side)),
      (o.side = Xa);
  }
  onAfterRender(e, t, r, i, o, s) {
    o._hadOwnSide ? (o.side = o._actualSide) : delete o.side;
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  get material() {
    let e = this._derivedMaterial;
    const t =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = $w.clone());
    if (
      ((!e || e.baseMaterial !== t) &&
        ((e = this._derivedMaterial = u9(t)),
        t.addEventListener("dispose", function r() {
          t.removeEventListener("dispose", r), e.dispose();
        })),
      this.outlineWidth ||
        this.outlineBlur ||
        this.outlineOffsetX ||
        this.outlineOffsetY)
    ) {
      let r = e._outlineMtl;
      return (
        r ||
          ((r = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (r.isTextOutlineMaterial = !0),
          (r.depthWrite = !1),
          (r.map = null),
          e.addEventListener("dispose", function i() {
            e.removeEventListener("dispose", i), r.dispose();
          })),
        [r, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return EC(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return EC(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial,
      r = e.uniforms,
      i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: l, blockBounds: u } = i;
      (r.uTroikaSDFTexture.value = l),
        r.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height),
        (r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize),
        (r.uTroikaSDFExponent.value = i.sdfExponent),
        r.uTroikaTotalBounds.value.fromArray(u),
        (r.uTroikaUseGlyphColors.value = !t && !!i.glyphColors);
      let f = 0,
        h = 0,
        m = 0,
        g,
        y,
        x,
        S = 0,
        _ = 0;
      if (t) {
        let {
          outlineWidth: T,
          outlineOffsetX: E,
          outlineOffsetY: A,
          outlineBlur: R,
          outlineOpacity: k,
        } = this;
        (f = this._parsePercent(T) || 0),
          (h = Math.max(0, this._parsePercent(R) || 0)),
          (g = k),
          (S = this._parsePercent(E) || 0),
          (_ = this._parsePercent(A) || 0);
      } else
        (m = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          m &&
            ((x = this.strokeColor),
            r.uTroikaStrokeColor.value.set(x ?? bC),
            (y = this.strokeOpacity),
            y == null && (y = 1)),
          (g = this.fillOpacity);
      (r.uTroikaDistanceOffset.value = f),
        r.uTroikaPositionOffset.value.set(S, _),
        (r.uTroikaBlurRadius.value = h),
        (r.uTroikaStrokeWidth.value = m),
        (r.uTroikaStrokeOpacity.value = y),
        (r.uTroikaFillOpacity.value = g ?? 1),
        (r.uTroikaCurveRadius.value = this.curveRadius || 0);
      let w = this.clipRect;
      if (w && Array.isArray(w) && w.length === 4)
        r.uTroikaClipRect.value.fromArray(w);
      else {
        const T = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(u[0] - T, u[1] - T, u[2] + T, u[3] + T);
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    (r.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0);
    const o = t ? this.outlineColor || 0 : this.color;
    if (o == null) delete e.color;
    else {
      const l = e.hasOwnProperty("color") ? e.color : (e.color = new St());
      (o !== l._input || typeof o == "object") && l.set((l._input = o));
    }
    let s = this.orientation || E1;
    if (s !== e._orientation) {
      let l = r.uTroikaOrient.value;
      s = s.replace(/[^-+xyz]/g, "");
      let u = s !== E1 && s.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (u) {
        let [, f, h, m, g] = u;
        (o0.set(0, 0, 0)[h] = f === "-" ? 1 : -1),
          (M1.set(0, 0, 0)[g] = m === "-" ? -1 : 1),
          MC.lookAt(c9, o0.cross(M1), M1),
          l.setFromMatrix4(MC);
      } else l.identity();
      e._orientation = s;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/),
        r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, t = new tt()) {
    t.copy(e);
    const r = this.curveRadius;
    return (
      r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t
    );
  }
  worldPositionToTextCoords(e, t = new tt()) {
    return o0.copy(e), this.localPositionToTextCoords(this.worldToLocal(o0), t);
  }
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const o = r.blockBounds,
        s = i ? RP() : AP(),
        l = s.geometry,
        { position: u, uv: f } = l.attributes;
      for (let h = 0; h < f.count; h++) {
        let m = o[0] + f.getX(h) * (o[2] - o[0]);
        const g = o[1] + f.getY(h) * (o[3] - o[1]);
        let y = 0;
        i && ((y = i - Math.cos(m / i) * i), (m = Math.sin(m / i) * i)),
          u.setXYZ(h, m, g, y);
      }
      (l.boundingSphere = this.geometry.boundingSphere),
        (l.boundingBox = this.geometry.boundingBox),
        (s.matrixWorld = this.matrixWorld),
        (s.material.side = this.material.side),
        (Xp.length = 0),
        s.raycast(e, Xp);
      for (let h = 0; h < Xp.length; h++) (Xp[h].object = this), t.push(Xp[h]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return (
      super.copy(e),
      (this.geometry = t),
      h9.forEach((r) => {
        this[r] = e[r];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
PP.forEach((n) => {
  const e = "_private_" + n;
  Object.defineProperty(IP.prototype, n, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && ((this[e] = t), (this._needsSync = !0));
    },
  });
});
const uy = K.forwardRef(
    (
      {
        sdfGlyphSize: n = 64,
        anchorX: e = "center",
        anchorY: t = "middle",
        font: r,
        fontSize: i = 1,
        children: o,
        characters: s,
        onSync: l,
        ...u
      },
      f
    ) => {
      const h = Na(({ invalidate: x }) => x),
        [m] = K.useState(() => new IP()),
        [g, y] = K.useMemo(() => {
          const x = [];
          let S = "";
          return (
            K.Children.forEach(o, (_) => {
              typeof _ == "string" || typeof _ == "number"
                ? (S += _)
                : x.push(_);
            }),
            [x, S]
          );
        }, [o]);
      return (
        nP(
          () => new Promise((x) => KW({ font: r, characters: s }, x)),
          ["troika-text", r, s]
        ),
        K.useLayoutEffect(
          () =>
            void m.sync(() => {
              h(), l && l(m);
            })
        ),
        K.useEffect(() => () => m.dispose(), [m]),
        K.createElement(
          "primitive",
          ue(
            {
              object: m,
              ref: f,
              font: r,
              text: y,
              anchorX: e,
              anchorY: t,
              fontSize: i,
              sdfGlyphSize: n,
            },
            u
          ),
          g
        )
      );
    }
  ),
  T1 = (n) => n === Object(n) && !Array.isArray(n) && typeof n != "function";
function Xw(n, e) {
  const t = Na((o) => o.gl),
    r = cg(cx, T1(n) ? Object.values(n) : n);
  return (
    K.useLayoutEffect(() => {
      e == null || e(r);
    }, [e]),
    K.useEffect(() => {
      if ("initTexture" in t) {
        let o = [];
        Array.isArray(r)
          ? (o = r)
          : r instanceof Qn
          ? (o = [r])
          : T1(r) && (o = Object.values(r)),
          o.forEach((s) => {
            s instanceof Qn && t.initTexture(s);
          });
      }
    }, [t, r]),
    K.useMemo(() => {
      if (T1(n)) {
        const o = {};
        let s = 0;
        for (const l in n) o[l] = r[s++];
        return o;
      } else return r;
    }, [n, r])
  );
}
Xw.preload = (n) => cg.preload(cx, n);
Xw.clear = (n) => cg.clear(cx, n);
const LP = K.forwardRef(
    (
      {
        makeDefault: n,
        camera: e,
        regress: t,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: o = !1,
        onChange: s,
        onStart: l,
        onEnd: u,
        ...f
      },
      h
    ) => {
      const m = Na((k) => k.invalidate),
        g = Na((k) => k.camera),
        y = Na((k) => k.gl),
        x = Na((k) => k.events),
        S = Na((k) => k.setEvents),
        _ = Na((k) => k.set),
        w = Na((k) => k.get),
        T = Na((k) => k.performance),
        E = e || g,
        A = r || x.connected || y.domElement,
        R = K.useMemo(() => new vW(E), [E]);
      return (
        ug(() => {
          R.enabled && R.update();
        }, -1),
        K.useEffect(
          () => (
            o && R.connect(o === !0 ? A : o),
            R.connect(A),
            () => void R.dispose()
          ),
          [o, A, t, R, m]
        ),
        K.useEffect(() => {
          const k = (N) => {
              m(), t && T.regress(), s && s(N);
            },
            P = (N) => {
              l && l(N);
            },
            U = (N) => {
              u && u(N);
            };
          return (
            R.addEventListener("change", k),
            R.addEventListener("start", P),
            R.addEventListener("end", U),
            () => {
              R.removeEventListener("start", P),
                R.removeEventListener("end", U),
                R.removeEventListener("change", k);
            }
          );
        }, [s, l, u, R, m, S]),
        K.useEffect(() => {
          if (n) {
            const k = w().controls;
            return _({ controls: R }), () => _({ controls: k });
          }
        }, [n, R]),
        K.createElement(
          "primitive",
          ue({ ref: h, object: R, enableDamping: i }, f)
        )
      );
    }
  ),
  p9 = "images/contractImage-CFOn4leh.png";
function m9({ nodes: n }) {
  const { contractAnimation: e } = $u((s) => s.simulation),
    t = K.useRef(),
    [r, i] = K.useState(0),
    o = Xw(p9);
  return (
    K.useEffect(() => {
      e && i(0);
    }, [e]),
    ug((s, l) => {
      e && r < 1 && i((u) => Math.min(u + l / 8, 3));
    }),
    e
      ? Q.jsx("group", {
          ref: t,
          children: n.map((s, l) => {
            const u = [s.position[0] * 1.6, 2, s.position[2] * 1.6],
              f = s.position,
              h = u[0] + (f[0] - u[0]) * r,
              m = u[1] + (f[1] - u[1]) * r,
              g = u[2] + (f[2] - u[2]) * r;
            return Q.jsxs(
              "mesh",
              {
                position: [h, m, g],
                children: [
                  Q.jsx("boxGeometry", { args: [1.9, 1.9, 1.9] }),
                  Q.jsx("meshBasicMaterial", {
                    map: o,
                    transparent: !0,
                    opacity: 1 - r,
                  }),
                ],
              },
              l
            );
          }),
        })
      : null
  );
}
yn.enabled = !0;
const s0 = 5,
  TC = 1,
  Fa = Array.from({ length: 10 }, (n, e) => {
    const t = (e / 10) * 2 * Math.PI,
      r = Math.cos(t) * s0,
      i = Math.sin(t) * s0,
      o = Math.cos(t) * (s0 + TC),
      s = Math.sin(t) * (s0 + TC);
    return {
      id: e,
      position: [r, 0, i],
      labelPosition: [o, 0.4, s],
      label: ` ${e + 1}`,
    };
  }),
  kP = [];
for (let n = 0; n < Fa.length; n++)
  for (let e = n + 1; e < Fa.length; e++)
    kP.push({ start: Fa[n].position, end: Fa[e].position, key: `${n}-${e}` });
function g9({
  position: n,
  label: e,
  isValidator: t,
  isSender: r,
  isReceiver: i,
  isHighlighted: o,
  phase: s,
}) {
  const l = K.useRef();
  ug(({ camera: f }) => {
    l.current && l.current.quaternion.copy(f.quaternion);
  });
  let u = "#000000";
  return (
    s === "transaction" && r
      ? (u = "red")
      : s === "transaction" && i
      ? (u = "#2e7d32")
      : t && o && (u = "blue"),
    Q.jsxs("group", {
      position: n,
      scale: [0.5, 0.5, 0.5],
      children: [
        Q.jsxs("mesh", {
          children: [
            Q.jsx("sphereGeometry", { args: [0.7, 32, 32] }),
            Q.jsx("meshBasicMaterial", { color: u }),
          ],
        }),
        Q.jsx(uy, {
          ref: l,
          position: [0, 1, 0],
          fontSize: 0.7,
          color: "white",
          anchorX: "center",
          anchorY: "middle",
          fontWeight: 1500,
          children: e,
        }),
      ],
    })
  );
}
function v9({ start: n, end: e, isActive: t }) {
  const r = [new se(...n), new se(...e)],
    i = new Jt().setFromPoints(r);
  return Q.jsxs("line", {
    children: [
      Q.jsx("bufferGeometry", { attach: "geometry", ...i }),
      Q.jsx("lineBasicMaterial", {
        color: t ? "yellow" : "#00695c",
        linewidth: t ? 4 : 2,
      }),
    ],
  });
}
function y9({ start: n, end: e, progress: t }) {
  const r = $u((o) => o.simulation.encryptedData),
    i = [
      n[0] + (e[0] - n[0]) * t,
      n[1] + (e[1] - n[1]) * t,
      n[2] + (e[2] - n[2]) * t,
    ];
  return Q.jsxs("mesh", {
    position: i,
    children: [
      Q.jsx("boxGeometry", { args: [0.3, 0.3, 0.3] }),
      Q.jsx("meshBasicMaterial", { color: "#2e7d32" }),
      Q.jsx(uy, {
        position: [0, 0, 0.2],
        fontSize: 0.2,
        color: "white",
        anchorX: "center",
        anchorY: "middle",
        children: r,
      }),
    ],
  });
}
function x9({ start: n, end: e, progress: t }) {
  const r = [
    n[0] + (e[0] - n[0]) * t,
    n[1] + (e[1] - n[1]) * t,
    n[2] + (e[2] - n[2]) * t,
  ];
  return Q.jsxs("mesh", {
    position: r,
    children: [
      Q.jsx("boxGeometry", { args: [0.3, 0.3, 0.3] }),
      Q.jsx("meshBasicMaterial", { color: "blue" }),
    ],
  });
}
function _9({ controlsRef: n }) {
  const e = yS(),
    {
      sender: t,
      receiver: r,
      validator: i,
      phase: o,
      transactionProgress: s,
      contractAnimation: l,
    } = $u((y) => y.simulation);
  console.log("Contract animation", l);
  const [u, f] = K.useState(0);
  K.useEffect(() => {
    console.log("Scene phase:", o), o === "idle" && f(0);
  }, [o]),
    ug((y, x) => {
      if (o === "transaction" && s < 1) {
        const S = Math.min(s + x / 5, 1);
        e(w_(S)), S >= 1 && e(s4());
      } else if (o === "validation")
        f((S) => S + x), u >= 2 && (e(a4()), e(w_(0)), f(0));
      else if (o === "broadcast" && s < 1) {
        const S = Math.min(s + x / 4, 1);
        e(w_(S)), S >= 1 && setTimeout(() => e(l4()), 1e3);
      }
    });
  const h = t !== null ? Fa[t] : null,
    m = r !== null ? Fa[r] : null,
    g = i !== null ? Fa[i] : null;
  return Q.jsxs(Q.Fragment, {
    children: [
      Q.jsx("ambientLight", { intensity: 0.5 }),
      Q.jsx("pointLight", { position: [10, 10, 10], intensity: 1 }),
      Fa.map((y) =>
        Q.jsx(
          g9,
          {
            position: y.position,
            label: y.label,
            isValidator: g && y.id === g.id,
            isSender: h && y.id === h.id,
            isReceiver: m && y.id === m.id,
            isHighlighted:
              o === "validation" || o === "broadcast" || o === "complete",
            phase: o,
          },
          y.id
        )
      ),
      kP.map((y) => {
        const x =
          o === "transaction" &&
          h &&
          m &&
          ((y.start === h.position && y.end === m.position) ||
            (y.start === m.position && y.end === h.position));
        return Q.jsx(v9, { start: y.start, end: y.end, isActive: x }, y.key);
      }),
      o === "transaction" &&
        h &&
        m &&
        s < 1 &&
        Q.jsx(y9, { start: h.position, end: m.position, progress: s }),
      o === "broadcast" &&
        g &&
        Fa.filter((y) => y.id !== g.id).map((y) =>
          Q.jsx(
            x9,
            { start: g.position, end: y.position, progress: s },
            `broadcast-${y.id}`
          )
        ),
      (o === "validation" || o === "broadcast" || o === "complete") &&
        g &&
        Q.jsx(Q.Fragment, {}),
      l && Q.jsx(m9, { nodes: Fa }),
      Q.jsx(LP, {
        ref: n,
        enablePan: !0,
        enableZoom: !0,
        enableRotate: !0,
        target: [0, 0, 0],
      }),
    ],
  });
}
function CC({ position: n, opacity: e = 1 }) {
  return Q.jsxs("mesh", {
    position: n,
    scale: [1, 1, 1],
    children: [
      Q.jsx("boxGeometry", { args: [0.6, 0.6, 0.6] }),
      Q.jsx("meshBasicMaterial", {
        color: "#2e7d32",
        opacity: e,
        transparent: !0,
      }),
    ],
  });
}
function S9({ start: n, end: e }) {
  const t = [new se(...n), new se(...e)],
    r = new Jt().setFromPoints(t);
  return Q.jsxs("line", {
    children: [
      Q.jsx("bufferGeometry", { attach: "geometry", ...r }),
      Q.jsx("lineBasicMaterial", { color: "#b0bec5", linewidth: 6 }),
    ],
  });
}
function w9({ phase: n }) {
  const [e, t] = K.useState([
      { id: 1, x: -12 },
      { id: 2, x: -8 },
      { id: 3, x: -4 },
      { id: 4, x: 0 },
    ]),
    [r, i] = K.useState(null),
    [o, s] = K.useState(null),
    [l, u] = K.useState(!1),
    [f, h] = K.useState(null),
    m = [
      { id: 1, x: -12 },
      { id: 2, x: -8 },
      { id: 3, x: -4 },
      { id: 4, x: 0 },
    ];
  K.useEffect(() => {
    if ((console.log("Ledger phase:", n, "LedgerBlocks:", e), n === "idle"))
      t(m), i(null), s(null), u(!1), h(null), console.log("Ledger reset");
    else if (n === "broadcast" && !r && !l) {
      const y = e.length + 1;
      i({ id: y }), s(8), u(!0), console.log("New block initialized at x=8.0");
    } else
      n === "complete" &&
        (u(!1), console.log("Reset hasAddedBlock for next cycle"));
  }, [n, r, l, e.length]),
    ug((y, x) => {
      r &&
        o !== null &&
        s((S) => {
          const w = Math.max(S - (x * 4) / 2, 4);
          return (
            console.log(`New block x: ${w}`),
            w <= 4 &&
              (t((T) => [...T, { id: r.id, x: 4 }]),
              h(r.id),
              i(null),
              s(null),
              console.log("New block added to ledger at x=4.0, id:", r.id)),
            w
          );
        });
    });
  const g = [];
  for (let y = 0; y < e.length - 1; y++)
    g.push({
      start: [e[y].x + 0.3, 0, 0],
      end: [e[y + 1].x - 0.3, 0, 0],
      key: `line-${y}`,
    });
  if (r && o !== null && o <= 4.5 && e.length > 0) {
    const y = e[e.length - 1].x;
    g.push({
      start: [y + 0.3, 0, 0],
      end: [o - 0.3, 0, 0],
      key: `line-new-${r.id}`,
    }),
      console.log(`Line: start=${y + 0.3}, end=${o - 0.3}`);
  }
  return Q.jsxs(Q.Fragment, {
    children: [
      Q.jsx("ambientLight", { intensity: 0.5 }),
      Q.jsx("pointLight", { position: [10, 10, 10], intensity: 1 }),
      e.map((y) =>
        Q.jsxs(
          Cs.Fragment,
          {
            children: [
              Q.jsx(CC, { position: [y.x, 0, 0] }),
              y.id === f &&
                Q.jsx(uy, {
                  position: [y.x, -0.5, 0],
                  fontSize: 0.35,
                  color: "white",
                  anchorX: "center",
                  anchorY: "middle",
                  children: "Newly Mined Block",
                }),
            ],
          },
          y.id
        )
      ),
      r &&
        o !== null &&
        Q.jsx(CC, { position: [o, 0, 0], opacity: (8 - o) / 4 }, `new-${r.id}`),
      g.map((y) => Q.jsx(S9, { start: y.start, end: y.end }, y.key)),
      Q.jsx(uy, {
        position: [-6, -0.5, 0],
        fontSize: 0.35,
        color: "white",
        anchorX: "center",
        anchorY: "middle",
        children: "Ledger",
      }),
    ],
  });
}
function b9({ phase: n }) {
  const [e, t] = K.useState("2d"),
    r = K.useRef(),
    i = () => {
      t("3d");
    };
  return (
    K.useEffect(() => {
      console.log("Ledger viewMode:", e);
      const o = r.current;
      if (o)
        return (
          o.addEventListener("start", i),
          () => o.removeEventListener("start", i)
        );
    }, []),
    Q.jsx(xn, {
      sx: {
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
      },
      children: Q.jsxs(_P, {
        orthographic: e === "2d",
        camera:
          e === "2d"
            ? {
                position: [0, 0, 10],
                zoom: 30,
                up: [0, 1, 0],
                near: 0.1,
                far: 1e3,
              }
            : { position: [0, 15, 20], fov: 60, near: 0.1, far: 1e3 },
        style: { width: "100%", height: "70px", maxHeight: "400px" },
        children: [
          Q.jsx(w9, { phase: n }),
          Q.jsx(LP, {
            ref: r,
            enablePan: !0,
            enableZoom: !0,
            enableRotate: !0,
            target: [-6, 0, 0],
          }),
        ],
      }),
    })
  );
}
function M9() {
  return Q.jsx(xn, {
    sx: {
      width: "100%",
      backgroundColor: "#1a202c",
      color: "white",
      padding: 2,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
    },
    children: Q.jsxs(R2, {
      spacing: 1,
      children: [
        Q.jsxs(xn, {
          display: "flex",
          alignItems: "center",
          children: [
            Q.jsx(xn, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "red",
                marginRight: 1,
              },
            }),
            Q.jsx(mr, { variant: "body2", children: "Looser" }),
          ],
        }),
        Q.jsxs(xn, {
          display: "flex",
          alignItems: "center",
          children: [
            Q.jsx(xn, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "#2e7d32",
                marginRight: 1,
              },
            }),
            Q.jsx(mr, { variant: "body2", children: "winner" }),
          ],
        }),
        Q.jsxs(xn, {
          display: "flex",
          alignItems: "center",
          children: [
            Q.jsx(xn, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "blue",
                marginRight: 1,
              },
            }),
            Q.jsx(mr, { variant: "body2", children: "Miner" }),
          ],
        }),
      ],
    }),
  });
}
function E9() {
  const { phase: n, validatorName: e } = $u((o) => o.simulation),
    [t, r] = K.useState([]);
  K.useEffect(() => {
    n === "idle" ||
      (n === "transaction" && !t.includes("step1")
        ? r((o) => [...o, "step1"])
        : n === "broadcast" && !t.includes("step2")
        ? r((o) => [...o, "step2"])
        : n === "complete" &&
          !t.includes("step3") &&
          r((o) => [...o, "step3"]));
  }, [n, t]);
  const i = (o) => {
    switch (o) {
      case "step1":
        return "Step 1: The Looser in the bet game initiates a transaction to the winner.";
      case "step2":
        return `Step 2: Node ${e} validates the transaction, adds the new block to the ledger, and distributes it to all nodes in the network.`;
      case "step3":
        return "Step 3: The transaction is finalized on the blockchain. A smart contract enforces predefined rules to ensure trust and transparency. The validator records the new block in the ledger, synchronizing it across all nodes and demonstrating decentralized consensus.";
      default:
        return "";
    }
  };
  return Q.jsx(xn, {
    sx: {
      width: "100%",
      backgroundColor: "#1a202c",
      color: "white",
      padding: { xs: 2, sm: 3 },
      display: "flex",
      flexDirection: "column",
      overflow: "auto",
      flexGrow: 1,
    },
    children: Q.jsxs(R2, {
      spacing: 1.5,
      children: [
        t.map((o, s) =>
          Q.jsx(
            mr,
            {
              variant: "body2",
              sx: {
                lineHeight: 1.7,
                fontSize: { xs: "0.85rem", sm: "0.95rem", md: "1rem" },
                whiteSpace: "normal",
                overflowWrap: "break-word",
                display: "block",
                paddingRight: { xs: 1, sm: 3, md: 5 },
                color: o === "step3" ? "#FFD700" : "white",
              },
              children: i(o),
            },
            s
          )
        ),
        Q.jsx(M9, {}),
        Q.jsxs(xn, {
          sx: { mt: 2, border: "1px solid #555", borderRadius: 2, p: 2 },
          children: [
            Q.jsx(mr, {
              variant: "h6",
              sx: { fontSize: { xs: "1rem", md: "1.25rem", color: "white" } },
              children: "Controls",
            }),
            Q.jsx(mr, {
              variant: "body2",
              sx: {
                fontSize: {
                  xs: "0.85rem",
                  sm: "0.95rem",
                  md: "1rem",
                  color: "white",
                },
                mt: 1,
              },
              children:
                "🖱️ Left-click + drag → Rotate the figure (vertically & horizontally).",
            }),
            Q.jsx(mr, {
              variant: "body2",
              sx: {
                fontSize: {
                  xs: "0.85rem",
                  sm: "0.95rem",
                  md: "1rem",
                  color: "white",
                },
              },
              children: "🖱️ Scroll wheel → Zoom in / Zoom out.",
            }),
          ],
        }),
      ],
    }),
  });
}
function T9() {
  const [n, e] = K.useState("2d"),
    t = K.useRef(),
    {
      phase: r,
      contractAnimation: i,
      smartContract: o,
      deploying: s,
      contractDeployed: l,
      winner: u,
      validator: f,
      sender: h,
    } = $u((w) => w.simulation),
    m = Array.from({ length: 10 }, (w, T) => ({
      id: T,
      name: `User ${T + 1}`,
    })),
    g = () => {
      e("3d");
    };
  K.useEffect(() => {
    console.log("DecagonSimulation phase:", r);
    const w = t.current;
    if (w)
      return (
        w.addEventListener("start", g), () => w.removeEventListener("start", g)
      );
  }, [r]);
  const [y, x] = K.useState(
      "This is the existing blockchain network where the smart contract you created will be deployed"
    ),
    [S, _] = K.useState("#2196F3");
  return (
    K.useEffect(() => {
      var w;
      r === "transaction"
        ? (_("#2196f3"),
          x(
            `Sending reward money to ${u} from ${
              m.find((T) => T.id === h).name
            }`
          ))
        : r === "broadcast"
        ? (_("#00acc1"),
          x(
            `${
              (w = m.find((T) => T.id === f)) == null ? void 0 : w.name
            } is sending the verification results to each nodes(players) in the blockchain netwrok`
          ))
        : r === "complete"
        ? (_("#4caf50"),
          x("Transaction completed and verified successfully"),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 4e3))
        : (_("#2196F3"),
          x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          ));
    }, [r]),
    K.useEffect(() => {
      var w;
      r === "validation" &&
        (_("#fbc02d"),
        x(
          `${
            (w = m.find((T) => T.id === f)) == null ? void 0 : w.name
          } is verifiying the transaction`
        ));
    }, [r === "validation"]),
    K.useEffect(() => {
      s
        ? (_("#ffeb3b"), x("Smart contract deploying"))
        : (_("#2196F3"),
          x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          ));
    }, [s]),
    K.useEffect(() => {
      l
        ? (_("#4caf50"),
          x("Smart contract deployed in blockchain network"),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 3e3))
        : x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          );
    }, [l]),
    K.useEffect(() => {
      u
        ? (_("#4CAF50"),
          x(`${u} is the winner in the betGame`),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 3e3))
        : x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          );
    }, [u]),
    K.useEffect(() => {
      var w;
      f
        ? (_("#4CAF50"),
          x(
            `${
              (w = m.find((T) => T.id === f)) == null ? void 0 : w.name
            } is selected as the miner to validate the transaction`
          ),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 3e3))
        : x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          );
    }, [f]),
    Q.jsxs(xn, {
      sx: {
        display: "flex",
        height: "100%",
        width: "100%",
        flexDirection: { xs: "column", md: "row" },
      },
      children: [
        Q.jsxs(xn, {
          sx: {
            paddingLeft: "180px",
            width: { xs: "100%", md: "75%" },
            height: { xs: "60%", md: "100%" },
            display: "flex",
            flexDirection: "column",
          },
          children: [
            Q.jsx(xn, {
              sx: {
                padding: 1,
                textAlign: "center",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
              },
            }),
            Q.jsx(xn, {
              sx: { flexGrow: 1, overflow: "hidden" },
              children: Q.jsx(_P, {
                orthographic: n === "2d",
                camera:
                  n === "2d"
                    ? {
                        position: [0, 10, 0],
                        zoom: 30,
                        up: [0, 1, 0],
                        near: 0.1,
                        far: 1e3,
                      }
                    : { position: [0, 10, 15], fov: 60, near: 0.1, far: 1e3 },
                style: { width: "100%", height: "100%" },
                gl: { outputEncoding: void 0 },
                children: Q.jsx(_9, { controlsRef: t }),
              }),
            }),
            Q.jsx(b9, { phase: r }),
            Q.jsx(xn, {
              sx: {
                paddingLeft: "200px",
                bgcolor: S,
                borderRadius: 2,
                mx: { xs: 1, sm: 2 },
                my: 1,
                px: 2,
                py: 1,
                textAlign: "left",
                opacity: 1,
                transform: "translateX(0)",
                transition: "opacity 0.6s ease, transform 0.6s ease",
              },
              className: "message-box",
              children: Q.jsx(mr, {
                variant: "body2",
                sx: {
                  color: s ? "black" : "white",
                  fontSize: { xs: "1.25rem", sm: "1.25rem" },
                },
                children: y,
              }),
            }),
          ],
        }),
        Q.jsx(xn, {
          sx: {
            width: { xs: "100%", md: "25%" },
            minWidth: { xs: "100%", sm: "280px", md: "280px" },
            display: "flex",
            flexDirection: "column",
            height: { xs: "40%", md: "100%" },
            boxSizing: "border-box",
            padding: 0.5,
          },
          children: Q.jsx(E9, {}),
        }),
      ],
    })
  );
}
function C9(n) {
  const { rootElementName: e = "" } = n,
    [t, r] = K.useState(e.toUpperCase()),
    i = K.useCallback((o) => {
      var s;
      r((s = o == null ? void 0 : o.tagName) != null ? s : "");
    }, []);
  return [t, i];
}
function A9(n = {}) {
  const {
      disabled: e = !1,
      focusableWhenDisabled: t,
      href: r,
      rootRef: i,
      tabIndex: o,
      to: s,
      type: l,
      rootElementName: u,
    } = n,
    f = K.useRef(null),
    [h, m] = K.useState(!1),
    { isFocusVisibleRef: g, onFocus: y, onBlur: x, ref: S } = NS(),
    [_, w] = K.useState(!1);
  e && !t && _ && w(!1),
    K.useEffect(() => {
      g.current = _;
    }, [_, g]);
  const [T, E] = C9({ rootElementName: u ?? (r || s ? "a" : void 0) }),
    A = (Z) => (X) => {
      var re;
      _ && X.preventDefault(), (re = Z.onMouseLeave) == null || re.call(Z, X);
    },
    R = (Z) => (X) => {
      var re;
      x(X), g.current === !1 && w(!1), (re = Z.onBlur) == null || re.call(Z, X);
    },
    k = (Z) => (X) => {
      var re;
      if (
        (f.current || (f.current = X.currentTarget), y(X), g.current === !0)
      ) {
        var W;
        w(!0), (W = Z.onFocusVisible) == null || W.call(Z, X);
      }
      (re = Z.onFocus) == null || re.call(Z, X);
    },
    P = () => {
      const Z = f.current;
      return (
        T === "BUTTON" ||
        (T === "INPUT" &&
          ["button", "submit", "reset"].includes(
            Z == null ? void 0 : Z.type
          )) ||
        (T === "A" && (Z == null ? void 0 : Z.href))
      );
    },
    U = (Z) => (X) => {
      if (!e) {
        var re;
        (re = Z.onClick) == null || re.call(Z, X);
      }
    },
    N = (Z) => (X) => {
      var re;
      e ||
        (m(!0),
        document.addEventListener(
          "mouseup",
          () => {
            m(!1);
          },
          { once: !0 }
        )),
        (re = Z.onMouseDown) == null || re.call(Z, X);
    },
    L = (Z) => (X) => {
      var re;
      if (
        ((re = Z.onKeyDown) == null || re.call(Z, X),
        !X.defaultMuiPrevented &&
          (X.target === X.currentTarget &&
            !P() &&
            X.key === " " &&
            X.preventDefault(),
          X.target === X.currentTarget && X.key === " " && !e && m(!0),
          X.target === X.currentTarget && !P() && X.key === "Enter" && !e))
      ) {
        var W;
        (W = Z.onClick) == null || W.call(Z, X), X.preventDefault();
      }
    },
    H = (Z) => (X) => {
      var re;
      if (
        (X.target === X.currentTarget && m(!1),
        (re = Z.onKeyUp) == null || re.call(Z, X),
        X.target === X.currentTarget &&
          !P() &&
          !e &&
          X.key === " " &&
          !X.defaultMuiPrevented)
      ) {
        var W;
        (W = Z.onClick) == null || W.call(Z, X);
      }
    },
    G = ri(E, i, S, f),
    $ = {};
  return (
    o !== void 0 && ($.tabIndex = o),
    T === "BUTTON"
      ? (($.type = l ?? "button"),
        t ? ($["aria-disabled"] = e) : ($.disabled = e))
      : T === "INPUT"
      ? l &&
        ["button", "submit", "reset"].includes(l) &&
        (t ? ($["aria-disabled"] = e) : ($.disabled = e))
      : T !== "" &&
        (!r && !s && (($.role = "button"), ($.tabIndex = o ?? 0)),
        e && (($["aria-disabled"] = e), ($.tabIndex = t ? o ?? 0 : -1))),
    {
      getRootProps: (Z = {}) => {
        const X = ue({}, x0(n), x0(Z)),
          re = ue({ type: l }, X, $, Z, {
            onBlur: R(X),
            onClick: U(X),
            onFocus: k(X),
            onKeyDown: L(X),
            onKeyUp: H(X),
            onMouseDown: N(X),
            onMouseLeave: A(X),
            ref: G,
          });
        return delete re.onFocusVisible, re;
      },
      focusVisible: _,
      setFocusVisible: w,
      active: h,
      rootRef: G,
    }
  );
}
const DP = "$$joy",
  R9 = ue({}, Ih, {
    borderRadius: { themeKey: "radius" },
    boxShadow: { themeKey: "shadow" },
    fontFamily: { themeKey: "fontFamily" },
    fontSize: { themeKey: "fontSize" },
    fontWeight: { themeKey: "fontWeight" },
    letterSpacing: { themeKey: "letterSpacing" },
    lineHeight: { themeKey: "lineHeight" },
  }),
  Yp = {
    grey: {
      50: "#FBFCFE",
      100: "#F0F4F8",
      200: "#DDE7EE",
      300: "#CDD7E1",
      400: "#9FA6AD",
      500: "#636B74",
      600: "#555E68",
      700: "#32383E",
      800: "#171A1C",
      900: "#0B0D0E",
    },
    blue: {
      50: "#EDF5FD",
      100: "#E3EFFB",
      200: "#C7DFF7",
      300: "#97C3F0",
      400: "#4393E4",
      500: "#0B6BCB",
      600: "#185EA5",
      700: "#12467B",
      800: "#0A2744",
      900: "#051423",
    },
    yellow: {
      50: "#FEFAF6",
      100: "#FDF0E1",
      200: "#FCE1C2",
      300: "#F3C896",
      400: "#EA9A3E",
      500: "#9A5B13",
      600: "#72430D",
      700: "#492B08",
      800: "#2E1B05",
      900: "#1D1002",
    },
    red: {
      50: "#FEF6F6",
      100: "#FCE4E4",
      200: "#F7C5C5",
      300: "#F09898",
      400: "#E47474",
      500: "#C41C1C",
      600: "#A51818",
      700: "#7D1212",
      800: "#430A0A",
      900: "#240505",
    },
    green: {
      50: "#F6FEF6",
      100: "#E3FBE3",
      200: "#C7F7C7",
      300: "#A1E8A1",
      400: "#51BC51",
      500: "#1F7A1F",
      600: "#136C13",
      700: "#0A470A",
      800: "#042F04",
      900: "#021D02",
    },
  };
function P9(n) {
  var e;
  return (
    !!n[0].match(/^(typography|variants|breakpoints)$/) ||
    !!n[0].match(/sxConfig$/) ||
    (n[0] === "palette" && !!((e = n[1]) != null && e.match(/^(mode)$/))) ||
    (n[0] === "focus" && n[1] !== "thickness")
  );
}
const Yw = (n, e) => Un(n, e, "Mui"),
  NP = (n, e) => In(n, e, "Mui"),
  I9 = (n) =>
    n &&
    typeof n == "object" &&
    Object.keys(n).some((e) => {
      var t;
      return (t = e.match) == null
        ? void 0
        : t.call(
            e,
            /^(plain(Hover|Active|Disabled)?(Color|Bg)|outlined(Hover|Active|Disabled)?(Color|Border|Bg)|soft(Hover|Active|Disabled)?(Color|Bg)|solid(Hover|Active|Disabled)?(Color|Bg))$/
          );
    }),
  AC = (n, e, t) => {
    e.includes("Color") && (n.color = t),
      e.includes("Bg") && (n.backgroundColor = t),
      e.includes("Border") && (n.borderColor = t);
  },
  RC = (n, e, t) => {
    const r = {};
    return (
      Object.entries(e || {}).forEach(([i, o]) => {
        if (i.match(new RegExp(`${n}(color|bg|border)`, "i")) && o) {
          const s = t ? t(i) : o;
          i.includes("Disabled") &&
            ((r.pointerEvents = "none"),
            (r.cursor = "default"),
            (r["--Icon-color"] = "currentColor")),
            i.match(/(Hover|Active|Disabled)/) ||
              (r["--variant-borderWidth"] ||
                (r["--variant-borderWidth"] = "0px"),
              i.includes("Border") &&
                ((r["--variant-borderWidth"] = "1px"),
                (r.border = "var(--variant-borderWidth) solid"))),
            AC(r, i, s);
        }
      }),
      r
    );
  },
  qi = (n, e) => {
    let t = {};
    if (e) {
      const { getCssVar: r, palette: i } = e;
      Object.entries(i).forEach((o) => {
        const [s, l] = o;
        I9(l) &&
          typeof l == "object" &&
          (t = ue({}, t, {
            [s]: RC(
              n,
              l,
              (u) => `var(--variant-${u}, ${r(`palette-${s}-${u}`, i[s][u])})`
            ),
          }));
      });
    }
    return (
      (t.context = RC(n, {
        plainColor: "var(--variant-plainColor)",
        plainHoverColor: "var(--variant-plainHoverColor)",
        plainHoverBg: "var(--variant-plainHoverBg)",
        plainActiveBg: "var(--variant-plainActiveBg)",
        plainDisabledColor: "var(--variant-plainDisabledColor)",
        outlinedColor: "var(--variant-outlinedColor)",
        outlinedBorder: "var(--variant-outlinedBorder)",
        outlinedHoverColor: "var(--variant-outlinedHoverColor)",
        outlinedHoverBorder: "var(--variant-outlinedHoverBorder)",
        outlinedHoverBg: "var(--variant-outlinedHoverBg)",
        outlinedActiveBg: "var(--variant-outlinedActiveBg)",
        outlinedDisabledColor: "var(--variant-outlinedDisabledColor)",
        outlinedDisabledBorder: "var(--variant-outlinedDisabledBorder)",
        softColor: "var(--variant-softColor)",
        softBg: "var(--variant-softBg)",
        softHoverColor: "var(--variant-softHoverColor)",
        softHoverBg: "var(--variant-softHoverBg)",
        softActiveBg: "var(--variant-softActiveBg)",
        softDisabledColor: "var(--variant-softDisabledColor)",
        softDisabledBg: "var(--variant-softDisabledBg)",
        solidColor: "var(--variant-solidColor)",
        solidBg: "var(--variant-solidBg)",
        solidHoverBg: "var(--variant-solidHoverBg)",
        solidActiveBg: "var(--variant-solidActiveBg)",
        solidDisabledColor: "var(--variant-solidDisabledColor)",
        solidDisabledBg: "var(--variant-solidDisabledBg)",
      })),
      t
    );
  },
  L9 = [
    "cssVarPrefix",
    "breakpoints",
    "spacing",
    "components",
    "variants",
    "shouldSkipGeneratingVar",
  ],
  k9 = ["colorSchemes"],
  D9 = (n = "joy") => Tk(n);
function N9(n) {
  var e, t, r, i, o, s, l, u, f, h;
  const m = {},
    {
      cssVarPrefix: g = "joy",
      breakpoints: y,
      spacing: x,
      components: S,
      variants: _,
      shouldSkipGeneratingVar: w = P9,
    } = m,
    T = Pt(m, L9),
    E = D9(g),
    A = {
      primary: Yp.blue,
      neutral: Yp.grey,
      danger: Yp.red,
      success: Yp.green,
      warning: Yp.yellow,
      common: { white: "#FFF", black: "#000" },
    },
    R = (fe) => {
      var Ee;
      const ge = fe.split("-"),
        xe = ge[1],
        j = ge[2];
      return E(fe, (Ee = A[xe]) == null ? void 0 : Ee[j]);
    },
    k = (fe) => ({
      plainColor: R(`palette-${fe}-500`),
      plainHoverBg: R(`palette-${fe}-100`),
      plainActiveBg: R(`palette-${fe}-200`),
      plainDisabledColor: R("palette-neutral-400"),
      outlinedColor: R(`palette-${fe}-500`),
      outlinedBorder: R(`palette-${fe}-300`),
      outlinedHoverBg: R(`palette-${fe}-100`),
      outlinedActiveBg: R(`palette-${fe}-200`),
      outlinedDisabledColor: R("palette-neutral-400"),
      outlinedDisabledBorder: R("palette-neutral-200"),
      softColor: R(`palette-${fe}-700`),
      softBg: R(`palette-${fe}-100`),
      softHoverBg: R(`palette-${fe}-200`),
      softActiveColor: R(`palette-${fe}-800`),
      softActiveBg: R(`palette-${fe}-300`),
      softDisabledColor: R("palette-neutral-400"),
      softDisabledBg: R("palette-neutral-50"),
      solidColor: R("palette-common-white"),
      solidBg: R(`palette-${fe}-500`),
      solidHoverBg: R(`palette-${fe}-600`),
      solidActiveBg: R(`palette-${fe}-700`),
      solidDisabledColor: R("palette-neutral-400"),
      solidDisabledBg: R("palette-neutral-100"),
    }),
    P = (fe) => ({
      plainColor: R(`palette-${fe}-300`),
      plainHoverBg: R(`palette-${fe}-800`),
      plainActiveBg: R(`palette-${fe}-700`),
      plainDisabledColor: R("palette-neutral-500"),
      outlinedColor: R(`palette-${fe}-200`),
      outlinedBorder: R(`palette-${fe}-700`),
      outlinedHoverBg: R(`palette-${fe}-800`),
      outlinedActiveBg: R(`palette-${fe}-700`),
      outlinedDisabledColor: R("palette-neutral-500"),
      outlinedDisabledBorder: R("palette-neutral-800"),
      softColor: R(`palette-${fe}-200`),
      softBg: R(`palette-${fe}-800`),
      softHoverBg: R(`palette-${fe}-700`),
      softActiveColor: R(`palette-${fe}-100`),
      softActiveBg: R(`palette-${fe}-600`),
      softDisabledColor: R("palette-neutral-500"),
      softDisabledBg: R("palette-neutral-800"),
      solidColor: R("palette-common-white"),
      solidBg: R(`palette-${fe}-500`),
      solidHoverBg: R(`palette-${fe}-600`),
      solidActiveBg: R(`palette-${fe}-700`),
      solidDisabledColor: R("palette-neutral-500"),
      solidDisabledBg: R("palette-neutral-800"),
    }),
    U = {
      palette: {
        mode: "light",
        primary: ue({}, A.primary, k("primary")),
        neutral: ue({}, A.neutral, k("neutral"), {
          plainColor: R("palette-neutral-700"),
          plainHoverColor: R("palette-neutral-900"),
          outlinedColor: R("palette-neutral-700"),
        }),
        danger: ue({}, A.danger, k("danger")),
        success: ue({}, A.success, k("success")),
        warning: ue({}, A.warning, k("warning")),
        common: { white: "#FFF", black: "#000" },
        text: {
          primary: R("palette-neutral-800"),
          secondary: R("palette-neutral-700"),
          tertiary: R("palette-neutral-600"),
          icon: R("palette-neutral-500"),
        },
        background: {
          body: R("palette-common-white"),
          surface: R("palette-neutral-50"),
          popup: R("palette-common-white"),
          level1: R("palette-neutral-100"),
          level2: R("palette-neutral-200"),
          level3: R("palette-neutral-300"),
          tooltip: R("palette-neutral-500"),
          backdrop: `rgba(${E(
            "palette-neutral-darkChannel",
            Tc(A.neutral[900])
          )} / 0.25)`,
        },
        divider: `rgba(${E(
          "palette-neutral-mainChannel",
          Tc(A.neutral[500])
        )} / 0.2)`,
        focusVisible: R("palette-primary-500"),
      },
      shadowRing: "0 0 #000",
      shadowChannel: "21 21 21",
      shadowOpacity: "0.08",
    },
    N = {
      palette: {
        mode: "dark",
        primary: ue({}, A.primary, P("primary")),
        neutral: ue({}, A.neutral, P("neutral"), {
          plainColor: R("palette-neutral-300"),
          plainHoverColor: R("palette-neutral-300"),
        }),
        danger: ue({}, A.danger, P("danger")),
        success: ue({}, A.success, P("success")),
        warning: ue({}, A.warning, P("warning")),
        common: { white: "#FFF", black: "#000" },
        text: {
          primary: R("palette-neutral-100"),
          secondary: R("palette-neutral-300"),
          tertiary: R("palette-neutral-400"),
          icon: R("palette-neutral-400"),
        },
        background: {
          body: R("palette-common-black"),
          surface: R("palette-neutral-900"),
          popup: R("palette-common-black"),
          level1: R("palette-neutral-800"),
          level2: R("palette-neutral-700"),
          level3: R("palette-neutral-600"),
          tooltip: R("palette-neutral-600"),
          backdrop: `rgba(${E(
            "palette-neutral-darkChannel",
            Tc(A.neutral[50])
          )} / 0.25)`,
        },
        divider: `rgba(${E(
          "palette-neutral-mainChannel",
          Tc(A.neutral[500])
        )} / 0.16)`,
        focusVisible: R("palette-primary-500"),
      },
      shadowRing: "0 0 #000",
      shadowChannel: "0 0 0",
      shadowOpacity: "0.6",
    },
    L =
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    H = ue(
      {
        body: `"Inter", ${E(`fontFamily-fallback, ${L}`)}`,
        display: `"Inter", ${E(`fontFamily-fallback, ${L}`)}`,
        code: "Source Code Pro,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace",
        fallback: L,
      },
      T.fontFamily
    ),
    G = ue({ sm: 300, md: 500, lg: 600, xl: 700 }, T.fontWeight),
    $ = ue(
      {
        xs: "0.75rem",
        sm: "0.875rem",
        md: "1rem",
        lg: "1.125rem",
        xl: "1.25rem",
        xl2: "1.5rem",
        xl3: "1.875rem",
        xl4: "2.25rem",
      },
      T.fontSize
    ),
    q = ue(
      { xs: "1.33334", sm: "1.42858", md: "1.5", lg: "1.55556", xl: "1.66667" },
      T.lineHeight
    ),
    Z =
      (e =
        (t = T.colorSchemes) == null || (t = t.light) == null
          ? void 0
          : t.shadowRing) != null
        ? e
        : U.shadowRing,
    X =
      (r =
        (i = T.colorSchemes) == null || (i = i.light) == null
          ? void 0
          : i.shadowChannel) != null
        ? r
        : U.shadowChannel,
    re =
      (o =
        (s = T.colorSchemes) == null || (s = s.light) == null
          ? void 0
          : s.shadowOpacity) != null
        ? o
        : U.shadowOpacity,
    W = {
      colorSchemes: { light: U, dark: N },
      fontSize: $,
      fontFamily: H,
      fontWeight: G,
      focus: {
        thickness: "2px",
        selector: `&.${Yw("", "focusVisible")}, &:focus-visible`,
        default: {
          outlineOffset: `var(--focus-outline-offset, ${E(
            "focus-thickness",
            (l = (u = T.focus) == null ? void 0 : u.thickness) != null
              ? l
              : "2px"
          )})`,
          outline: `${E(
            "focus-thickness",
            (f = (h = T.focus) == null ? void 0 : h.thickness) != null
              ? f
              : "2px"
          )} solid ${E("palette-focusVisible", A.primary[500])}`,
        },
      },
      lineHeight: q,
      radius: { xs: "2px", sm: "6px", md: "8px", lg: "12px", xl: "16px" },
      shadow: {
        xs: `${E("shadowRing", Z)}, 0px 1px 2px 0px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)})`,
        sm: `${E("shadowRing", Z)}, 0px 1px 2px 0px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)}), 0px 2px 4px 0px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)})`,
        md: `${E("shadowRing", Z)}, 0px 2px 8px -2px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)}), 0px 6px 12px -2px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)})`,
        lg: `${E("shadowRing", Z)}, 0px 2px 8px -2px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)}), 0px 12px 16px -4px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)})`,
        xl: `${E("shadowRing", Z)}, 0px 2px 8px -2px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)}), 0px 20px 24px -4px rgba(${E(
          "shadowChannel",
          X
        )} / ${E("shadowOpacity", re)})`,
      },
      zIndex: {
        badge: 1,
        table: 10,
        popup: 1e3,
        modal: 1300,
        snackbar: 1400,
        tooltip: 1500,
      },
      typography: {
        h1: {
          fontFamily: E(`fontFamily-display, ${H.display}`),
          fontWeight: E(`fontWeight-xl, ${G.xl}`),
          fontSize: E(`fontSize-xl4, ${$.xl4}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h2: {
          fontFamily: E(`fontFamily-display, ${H.display}`),
          fontWeight: E(`fontWeight-xl, ${G.xl}`),
          fontSize: E(`fontSize-xl3, ${$.xl3}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h3: {
          fontFamily: E(`fontFamily-display, ${H.display}`),
          fontWeight: E(`fontWeight-lg, ${G.lg}`),
          fontSize: E(`fontSize-xl2, ${$.xl2}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h4: {
          fontFamily: E(`fontFamily-display, ${H.display}`),
          fontWeight: E(`fontWeight-lg, ${G.lg}`),
          fontSize: E(`fontSize-xl, ${$.xl}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          letterSpacing: "-0.025em",
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-lg": {
          fontFamily: E(`fontFamily-body, ${H.body}`),
          fontWeight: E(`fontWeight-lg, ${G.lg}`),
          fontSize: E(`fontSize-lg, ${$.lg}`),
          lineHeight: E(`lineHeight-xs, ${q.xs}`),
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-md": {
          fontFamily: E(`fontFamily-body, ${H.body}`),
          fontWeight: E(`fontWeight-md, ${G.md}`),
          fontSize: E(`fontSize-md, ${$.md}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-sm": {
          fontFamily: E(`fontFamily-body, ${H.body}`),
          fontWeight: E(`fontWeight-md, ${G.md}`),
          fontSize: E(`fontSize-sm, ${$.sm}`),
          lineHeight: E(`lineHeight-sm, ${q.sm}`),
          color: E(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "body-lg": {
          fontFamily: E(`fontFamily-body, ${H.body}`),
          fontSize: E(`fontSize-lg, ${$.lg}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-secondary, ${U.palette.text.secondary}`),
        },
        "body-md": {
          fontFamily: E(`fontFamily-body, ${H.body}`),
          fontSize: E(`fontSize-md, ${$.md}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-secondary, ${U.palette.text.secondary}`),
        },
        "body-sm": {
          fontFamily: E(`fontFamily-body, ${H.body}`),
          fontSize: E(`fontSize-sm, ${$.sm}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-tertiary, ${U.palette.text.tertiary}`),
        },
        "body-xs": {
          fontFamily: E(`fontFamily-body, ${H.body}`),
          fontWeight: E(`fontWeight-md, ${G.md}`),
          fontSize: E(`fontSize-xs, ${$.xs}`),
          lineHeight: E(`lineHeight-md, ${q.md}`),
          color: E(`palette-text-tertiary, ${U.palette.text.tertiary}`),
        },
      },
    },
    te = T ? ni(W, T) : W,
    { colorSchemes: F } = te,
    V = Pt(te, k9),
    ne = ue({ colorSchemes: F }, V, {
      breakpoints: ES(y ?? {}),
      components: ni(
        {
          MuiSvgIcon: {
            defaultProps: { fontSize: "xl2" },
            styleOverrides: {
              root: ({ ownerState: fe, theme: Ee }) => {
                var ge;
                const xe = fe.instanceFontSize;
                return ue(
                  { margin: "var(--Icon-margin)" },
                  fe.fontSize &&
                    fe.fontSize !== "inherit" && {
                      fontSize: `var(--Icon-fontSize, ${
                        Ee.vars.fontSize[fe.fontSize]
                      })`,
                    },
                  !fe.htmlColor &&
                    ue(
                      {
                        color: `var(--Icon-color, ${ne.vars.palette.text.icon})`,
                      },
                      fe.color &&
                        fe.color !== "inherit" &&
                        Ee.vars.palette[fe.color] && {
                          color: `rgba(${
                            (ge = Ee.vars.palette[fe.color]) == null
                              ? void 0
                              : ge.mainChannel
                          } / 1)`,
                        }
                    ),
                  xe &&
                    xe !== "inherit" && {
                      "--Icon-fontSize": Ee.vars.fontSize[xe],
                    }
                );
              },
            },
          },
        },
        S
      ),
      cssVarPrefix: g,
      getCssVar: E,
      spacing: u2(x),
    });
  function ae(fe, Ee) {
    Object.keys(Ee).forEach((ge) => {
      const xe = { main: "500", light: "200", dark: "700" };
      fe === "dark" && (xe.main = 400),
        !Ee[ge].mainChannel &&
          Ee[ge][xe.main] &&
          (Ee[ge].mainChannel = Tc(Ee[ge][xe.main])),
        !Ee[ge].lightChannel &&
          Ee[ge][xe.light] &&
          (Ee[ge].lightChannel = Tc(Ee[ge][xe.light])),
        !Ee[ge].darkChannel &&
          Ee[ge][xe.dark] &&
          (Ee[ge].darkChannel = Tc(Ee[ge][xe.dark]));
    });
  }
  Object.entries(ne.colorSchemes).forEach(([fe, Ee]) => {
    ae(fe, Ee.palette);
  });
  const J = { prefix: g, shouldSkipGeneratingVar: w },
    { vars: oe, generateCssVars: de } = Ik(ue({ colorSchemes: F }, V), J);
  (ne.vars = oe),
    (ne.generateCssVars = de),
    (ne.unstable_sxConfig = ue({}, R9, void 0)),
    (ne.unstable_sx = function (Ee) {
      return Mf({ sx: Ee, theme: this });
    }),
    (ne.getColorSchemeSelector = (fe) =>
      fe === "light"
        ? "&"
        : `&[data-joy-color-scheme="${fe}"], [data-joy-color-scheme="${fe}"] &`);
  const le = { getCssVar: E, palette: ne.colorSchemes.light.palette };
  return (
    (ne.variants = ni(
      {
        plain: qi("plain", le),
        plainHover: qi("plainHover", le),
        plainActive: qi("plainActive", le),
        plainDisabled: qi("plainDisabled", le),
        outlined: qi("outlined", le),
        outlinedHover: qi("outlinedHover", le),
        outlinedActive: qi("outlinedActive", le),
        outlinedDisabled: qi("outlinedDisabled", le),
        soft: qi("soft", le),
        softHover: qi("softHover", le),
        softActive: qi("softActive", le),
        softDisabled: qi("softDisabled", le),
        solid: qi("solid", le),
        solidHover: qi("solidHover", le),
        solidActive: qi("solidActive", le),
        solidDisabled: qi("solidDisabled", le),
      },
      _
    )),
    (ne.palette = ue({}, ne.colorSchemes.light.palette, {
      colorScheme: "light",
    })),
    (ne.shouldSkipGeneratingVar = w),
    (ne.applyStyles = IS),
    ne
  );
}
const OP = N9(),
  Ku = p2({ defaultTheme: OP, themeId: DP });
function UP({ props: n, name: e }) {
  return m2({
    props: n,
    name: e,
    defaultTheme: ue({}, OP, { components: {} }),
    themeId: DP,
  });
}
const O9 = [
    "className",
    "elementType",
    "ownerState",
    "externalForwardedProps",
    "getSlotOwnerState",
    "internalForwardedProps",
  ],
  U9 = ["component", "slots", "slotProps"],
  F9 = ["component"];
function Uu(n, e) {
  const {
      className: t,
      elementType: r,
      ownerState: i,
      externalForwardedProps: o,
      getSlotOwnerState: s,
      internalForwardedProps: l,
    } = e,
    u = Pt(e, O9),
    {
      component: f,
      slots: h = { [n]: void 0 },
      slotProps: m = { [n]: void 0 },
    } = o,
    g = Pt(o, U9),
    y = h[n] || r,
    x = S2(m[n], i),
    S = _2(
      ue({ className: t }, u, {
        externalForwardedProps: n === "root" ? g : void 0,
        externalSlotProps: x,
      })
    ),
    {
      props: { component: _ },
      internalRef: w,
    } = S,
    T = Pt(S.props, F9),
    E = ri(w, x == null ? void 0 : x.ref, e.ref),
    A = s ? s(T) : {},
    R = ue({}, i, A),
    k = n === "root" ? _ || f : _,
    P = x2(
      y,
      ue(
        {},
        n === "root" && !f && !h[n] && l,
        n !== "root" && !h[n] && l,
        T,
        k && { as: k },
        { ref: E }
      ),
      R
    );
  return (
    Object.keys(A).forEach((U) => {
      delete P[U];
    }),
    [y, P]
  );
}
function B9(n) {
  return Yw("MuiCircularProgress", n);
}
NP("MuiCircularProgress", [
  "root",
  "determinate",
  "svg",
  "track",
  "progress",
  "colorPrimary",
  "colorNeutral",
  "colorDanger",
  "colorSuccess",
  "colorWarning",
  "colorContext",
  "sizeSm",
  "sizeMd",
  "sizeLg",
  "variantPlain",
  "variantOutlined",
  "variantSoft",
  "variantSolid",
]);
let z9 = (n) => n,
  PC;
const H9 = ["color", "backgroundColor"],
  V9 = [
    "children",
    "className",
    "color",
    "size",
    "variant",
    "thickness",
    "determinate",
    "value",
    "component",
    "slots",
    "slotProps",
  ],
  G9 = Ym({
    "0%": { transform: "rotate(-90deg)" },
    "100%": { transform: "rotate(270deg)" },
  }),
  W9 = (n) => {
    const { determinate: e, color: t, variant: r, size: i } = n,
      o = {
        root: [
          "root",
          e && "determinate",
          t && `color${an(t)}`,
          r && `variant${an(r)}`,
          i && `size${an(i)}`,
        ],
        svg: ["svg"],
        track: ["track"],
        progress: ["progress"],
      };
    return Fn(o, B9, {});
  };
function th(n, e) {
  return `var(--CircularProgress-${n}Thickness, var(--CircularProgress-thickness, ${e}))`;
}
const j9 = Ku("span", {
    name: "JoyCircularProgress",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })(({ ownerState: n, theme: e }) => {
    var t, r, i, o;
    const s = ((t = e.variants[n.variant]) == null ? void 0 : t[n.color]) || {},
      { color: l, backgroundColor: u } = s,
      f = Pt(s, H9);
    return ue(
      {
        "--Icon-fontSize": "calc(0.4 * var(--_root-size))",
        "--CircularProgress-trackColor": u,
        "--CircularProgress-progressColor": l,
        "--CircularProgress-percent": n.value,
        "--CircularProgress-linecap": "round",
      },
      n.size === "sm" && {
        "--_root-size": "var(--CircularProgress-size, 24px)",
        "--_track-thickness": th("track", "3px"),
        "--_progress-thickness": th("progress", "3px"),
      },
      n.instanceSize === "sm" && { "--CircularProgress-size": "24px" },
      n.size === "md" && {
        "--_track-thickness": th("track", "6px"),
        "--_progress-thickness": th("progress", "6px"),
        "--_root-size": "var(--CircularProgress-size, 40px)",
      },
      n.instanceSize === "md" && { "--CircularProgress-size": "40px" },
      n.size === "lg" && {
        "--_track-thickness": th("track", "8px"),
        "--_progress-thickness": th("progress", "8px"),
        "--_root-size": "var(--CircularProgress-size, 64px)",
      },
      n.instanceSize === "lg" && { "--CircularProgress-size": "64px" },
      n.thickness && {
        "--_track-thickness": `${n.thickness}px`,
        "--_progress-thickness": `${n.thickness}px`,
      },
      {
        "--_thickness-diff":
          "calc(var(--_track-thickness) - var(--_progress-thickness))",
        "--_inner-size":
          "calc(var(--_root-size) - 2 * var(--variant-borderWidth, 0px))",
        "--_outlined-inset":
          "max(var(--_track-thickness), var(--_progress-thickness))",
        width: "var(--_root-size)",
        height: "var(--_root-size)",
        borderRadius: "var(--_root-size)",
        margin: "var(--CircularProgress-margin)",
        boxSizing: "border-box",
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        flexShrink: 0,
        position: "relative",
        color: l,
      },
      n.children && {
        fontFamily: e.vars.fontFamily.body,
        fontWeight: e.vars.fontWeight.md,
        fontSize: "calc(0.2 * var(--_root-size))",
      },
      f,
      n.variant === "outlined" && {
        "&::before": ue(
          {
            content: '""',
            display: "block",
            position: "absolute",
            borderRadius: "inherit",
            top: "var(--_outlined-inset)",
            left: "var(--_outlined-inset)",
            right: "var(--_outlined-inset)",
            bottom: "var(--_outlined-inset)",
          },
          f
        ),
      },
      n.variant === "soft" && {
        "--CircularProgress-trackColor":
          e.variants.soft.neutral.backgroundColor,
        "--CircularProgress-progressColor":
          (r = e.variants.solid) == null ? void 0 : r[n.color].backgroundColor,
      },
      n.variant === "solid" && {
        "--CircularProgress-trackColor":
          (i = e.variants.softHover) == null
            ? void 0
            : i[n.color].backgroundColor,
        "--CircularProgress-progressColor":
          (o = e.variants.solid) == null ? void 0 : o[n.color].backgroundColor,
      }
    );
  }),
  $9 = Ku("svg", {
    name: "JoyCircularProgress",
    slot: "Svg",
    overridesResolver: (n, e) => e.svg,
  })({
    width: "inherit",
    height: "inherit",
    display: "inherit",
    boxSizing: "inherit",
    position: "absolute",
    top: "calc(-1 * var(--variant-borderWidth, 0px))",
    left: "calc(-1 * var(--variant-borderWidth, 0px))",
  }),
  X9 = Ku("circle", {
    name: "JoyCircularProgress",
    slot: "track",
    overridesResolver: (n, e) => e.track,
  })({
    cx: "50%",
    cy: "50%",
    r: "calc(var(--_inner-size) / 2 - var(--_track-thickness) / 2 + min(0px, var(--_thickness-diff) / 2))",
    fill: "transparent",
    strokeWidth: "var(--_track-thickness)",
    stroke: "var(--CircularProgress-trackColor)",
  }),
  Y9 = Ku("circle", {
    name: "JoyCircularProgress",
    slot: "progress",
    overridesResolver: (n, e) => e.progress,
  })(
    {
      "--_progress-radius":
        "calc(var(--_inner-size) / 2 - var(--_progress-thickness) / 2 - max(0px, var(--_thickness-diff) / 2))",
      "--_progress-length": "calc(2 * 3.1415926535 * var(--_progress-radius))",
      cx: "50%",
      cy: "50%",
      r: "var(--_progress-radius)",
      fill: "transparent",
      strokeWidth: "var(--_progress-thickness)",
      stroke: "var(--CircularProgress-progressColor)",
      strokeLinecap: "var(--CircularProgress-linecap, round)",
      strokeDasharray: "var(--_progress-length)",
      strokeDashoffset:
        "calc(var(--_progress-length) - var(--CircularProgress-percent) * var(--_progress-length) / 100)",
      transformOrigin: "center",
      transform: "rotate(-90deg)",
    },
    ({ ownerState: n }) =>
      !n.determinate &&
      bS(
        PC ||
          (PC = z9`
      animation: var(--CircularProgress-circulation, 0.8s linear 0s infinite normal none running)
        ${0};
    `),
        G9
      )
  ),
  q9 = K.forwardRef(function (e, t) {
    const r = UP({ props: e, name: "JoyCircularProgress" }),
      {
        children: i,
        className: o,
        color: s = "primary",
        size: l = "md",
        variant: u = "soft",
        thickness: f,
        determinate: h = !1,
        value: m = h ? 0 : 25,
        component: g,
        slots: y = {},
        slotProps: x = {},
      } = r,
      S = Pt(r, V9),
      _ = ue({}, r, {
        color: s,
        size: l,
        variant: u,
        thickness: f,
        value: m,
        determinate: h,
        instanceSize: e.size,
      }),
      w = W9(_),
      T = ue({}, S, { component: g, slots: y, slotProps: x }),
      [E, A] = Uu("root", {
        ref: t,
        className: Zt(w.root, o),
        elementType: j9,
        externalForwardedProps: T,
        ownerState: _,
        additionalProps: ue(
          { role: "progressbar", style: { "--CircularProgress-percent": m } },
          m &&
            h && {
              "aria-valuenow": Math.round(
                typeof m == "number" ? m : Number(m || 0)
              ),
            }
        ),
      }),
      [R, k] = Uu("svg", {
        className: w.svg,
        elementType: $9,
        externalForwardedProps: T,
        ownerState: _,
      }),
      [P, U] = Uu("track", {
        className: w.track,
        elementType: X9,
        externalForwardedProps: T,
        ownerState: _,
      }),
      [N, L] = Uu("progress", {
        className: w.progress,
        elementType: Y9,
        externalForwardedProps: T,
        ownerState: _,
      });
    return Q.jsxs(
      E,
      ue({}, A, {
        children: [
          Q.jsxs(
            R,
            ue({}, k, { children: [Q.jsx(P, ue({}, U)), Q.jsx(N, ue({}, L))] })
          ),
          i,
        ],
      })
    );
  });
function K9(n) {
  return Yw("MuiButton", n);
}
const IC = NP("MuiButton", [
    "root",
    "colorPrimary",
    "colorNeutral",
    "colorDanger",
    "colorSuccess",
    "colorWarning",
    "colorContext",
    "variantPlain",
    "variantOutlined",
    "variantSoft",
    "variantSolid",
    "focusVisible",
    "disabled",
    "sizeSm",
    "sizeMd",
    "sizeLg",
    "fullWidth",
    "startDecorator",
    "endDecorator",
    "loading",
    "loadingIndicatorCenter",
  ]),
  Z9 = K.createContext({}),
  J9 = K.createContext(void 0),
  Q9 = [
    "children",
    "action",
    "color",
    "variant",
    "size",
    "fullWidth",
    "startDecorator",
    "endDecorator",
    "loading",
    "loadingPosition",
    "loadingIndicator",
    "disabled",
    "component",
    "slots",
    "slotProps",
  ],
  e7 = (n) => {
    const {
        color: e,
        disabled: t,
        focusVisible: r,
        focusVisibleClassName: i,
        fullWidth: o,
        size: s,
        variant: l,
        loading: u,
      } = n,
      f = {
        root: [
          "root",
          t && "disabled",
          r && "focusVisible",
          o && "fullWidth",
          l && `variant${an(l)}`,
          e && `color${an(e)}`,
          s && `size${an(s)}`,
          u && "loading",
        ],
        startDecorator: ["startDecorator"],
        endDecorator: ["endDecorator"],
        loadingIndicatorCenter: ["loadingIndicatorCenter"],
      },
      h = Fn(f, K9, {});
    return r && i && (h.root += ` ${i}`), h;
  },
  t7 = Ku("span", {
    name: "JoyButton",
    slot: "StartDecorator",
    overridesResolver: (n, e) => e.startDecorator,
  })({
    "--Icon-margin": "0 0 0 calc(var(--Button-gap) / -2)",
    "--CircularProgress-margin": "0 0 0 calc(var(--Button-gap) / -2)",
    display: "inherit",
    marginRight: "var(--Button-gap)",
  }),
  n7 = Ku("span", {
    name: "JoyButton",
    slot: "EndDecorator",
    overridesResolver: (n, e) => e.endDecorator,
  })({
    "--Icon-margin": "0 calc(var(--Button-gap) / -2) 0 0",
    "--CircularProgress-margin": "0 calc(var(--Button-gap) / -2) 0 0",
    display: "inherit",
    marginLeft: "var(--Button-gap)",
  }),
  r7 = Ku("span", {
    name: "JoyButton",
    slot: "LoadingCenter",
    overridesResolver: (n, e) => e.loadingIndicatorCenter,
  })(({ theme: n, ownerState: e }) => {
    var t, r;
    return ue(
      {
        display: "inherit",
        position: "absolute",
        left: "50%",
        transform: "translateX(-50%)",
        color:
          (t = n.variants[e.variant]) == null || (t = t[e.color]) == null
            ? void 0
            : t.color,
      },
      e.disabled && {
        color:
          (r = n.variants[`${e.variant}Disabled`]) == null ||
          (r = r[e.color]) == null
            ? void 0
            : r.color,
      }
    );
  }),
  i7 = ({ theme: n, ownerState: e }) => {
    var t, r, i, o;
    return [
      ue(
        {
          "--Icon-margin": "initial",
          "--Icon-color":
            e.color !== "neutral" || e.variant === "solid"
              ? "currentColor"
              : n.vars.palette.text.icon,
        },
        e.size === "sm" && {
          "--Icon-fontSize": n.vars.fontSize.lg,
          "--CircularProgress-size": "20px",
          "--CircularProgress-thickness": "2px",
          "--Button-gap": "0.375rem",
          minHeight: "var(--Button-minHeight, 2rem)",
          fontSize: n.vars.fontSize.sm,
          paddingBlock: "var(--Button-paddingBlock, 0.25rem)",
          paddingInline: "0.75rem",
        },
        e.size === "md" && {
          "--Icon-fontSize": n.vars.fontSize.xl,
          "--CircularProgress-size": "20px",
          "--CircularProgress-thickness": "2px",
          "--Button-gap": "0.5rem",
          minHeight: "var(--Button-minHeight, 2.25rem)",
          fontSize: n.vars.fontSize.sm,
          paddingBlock: "var(--Button-paddingBlock, 0.375rem)",
          paddingInline: "1rem",
        },
        e.size === "lg" && {
          "--Icon-fontSize": n.vars.fontSize.xl2,
          "--CircularProgress-size": "28px",
          "--CircularProgress-thickness": "4px",
          "--Button-gap": "0.75rem",
          minHeight: "var(--Button-minHeight, 2.75rem)",
          fontSize: n.vars.fontSize.md,
          paddingBlock: "var(--Button-paddingBlock, 0.5rem)",
          paddingInline: "1.5rem",
        },
        {
          WebkitTapHighlightColor: "transparent",
          boxSizing: "border-box",
          borderRadius: `var(--Button-radius, ${n.vars.radius.sm})`,
          margin: "var(--Button-margin)",
          border: "none",
          backgroundColor: "transparent",
          cursor: "pointer",
          userSelect: "none",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          position: "relative",
          textDecoration: "none",
          fontFamily: n.vars.fontFamily.body,
          fontWeight: n.vars.fontWeight.lg,
          lineHeight: n.vars.lineHeight.md,
        },
        e.fullWidth && { width: "100%" },
        { [n.focus.selector]: n.focus.default }
      ),
      ue(
        {},
        (t = n.variants[e.variant]) == null ? void 0 : t[e.color],
        {
          "&:hover": {
            "@media (hover: hover)":
              (r = n.variants[`${e.variant}Hover`]) == null
                ? void 0
                : r[e.color],
          },
          '&:active, &[aria-pressed="true"]':
            (i = n.variants[`${e.variant}Active`]) == null
              ? void 0
              : i[e.color],
          [`&.${IC.disabled}`]:
            (o = n.variants[`${e.variant}Disabled`]) == null
              ? void 0
              : o[e.color],
        },
        e.loadingPosition === "center" && {
          [`&.${IC.loading}`]: { color: "transparent" },
        }
      ),
    ];
  },
  o7 = Ku("button", {
    name: "JoyButton",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })(i7),
  FP = K.forwardRef(function (e, t) {
    var r;
    const i = UP({ props: e, name: "JoyButton" }),
      {
        children: o,
        action: s,
        color: l = "primary",
        variant: u = "solid",
        size: f = "md",
        fullWidth: h = !1,
        startDecorator: m,
        endDecorator: g,
        loading: y = !1,
        loadingPosition: x = "center",
        loadingIndicator: S,
        disabled: _,
        component: w,
        slots: T = {},
        slotProps: E = {},
      } = i,
      A = Pt(i, Q9),
      R = K.useContext(Z9),
      k = K.useContext(J9),
      P = e.variant || R.variant || u,
      U = e.size || R.size || f,
      N = e.color || R.color || l,
      L = (r = e.loading || e.disabled) != null ? r : R.disabled || y || _,
      H = K.useRef(null),
      G = ri(H, t),
      {
        focusVisible: $,
        setFocusVisible: q,
        getRootProps: Z,
      } = A9(ue({}, i, { disabled: L, rootRef: G })),
      X =
        S ??
        Q.jsx(q9, { color: N, thickness: { sm: 2, md: 3, lg: 4 }[U] || 3 });
    K.useImperativeHandle(
      s,
      () => ({
        focusVisible: () => {
          var ge;
          q(!0), (ge = H.current) == null || ge.focus();
        },
      }),
      [q]
    );
    const re = ue({}, i, {
        color: N,
        fullWidth: h,
        variant: P,
        size: U,
        focusVisible: $,
        loading: y,
        loadingPosition: x,
        disabled: L,
      }),
      W = e7(re),
      te = (ge) => {
        var xe;
        let j = i.onClick;
        if (
          (typeof E.root == "function"
            ? (j = E.root(re).onClick)
            : E.root && (j = E.root.onClick),
          (xe = j) == null || xe(ge),
          k)
        ) {
          var we;
          (we = k.onClick) == null || we.call(k, ge, i.value);
        }
      };
    let F = i["aria-pressed"];
    typeof E.root == "function"
      ? (F = E.root(re)["aria-pressed"])
      : E.root && (F = E.root["aria-pressed"]),
      k != null &&
        k.value &&
        (Array.isArray(k.value)
          ? (F = k.value.indexOf(i.value) !== -1)
          : (F = k.value === i.value));
    const V = ue({}, A, { component: w, slots: T, slotProps: E }),
      [ne, ae] = Uu("root", {
        ref: t,
        className: W.root,
        elementType: o7,
        externalForwardedProps: V,
        getSlotProps: Z,
        ownerState: re,
        additionalProps: { onClick: te, "aria-pressed": F },
      }),
      [J, oe] = Uu("startDecorator", {
        className: W.startDecorator,
        elementType: t7,
        externalForwardedProps: V,
        ownerState: re,
      }),
      [de, le] = Uu("endDecorator", {
        className: W.endDecorator,
        elementType: n7,
        externalForwardedProps: V,
        ownerState: re,
      }),
      [fe, Ee] = Uu("loadingIndicatorCenter", {
        className: W.loadingIndicatorCenter,
        elementType: r7,
        externalForwardedProps: V,
        ownerState: re,
      });
    return Q.jsxs(
      ne,
      ue({}, ae, {
        children: [
          (m || (y && x === "start")) &&
            Q.jsx(J, ue({}, oe, { children: y && x === "start" ? X : m })),
          o,
          y && x === "center" && Q.jsx(fe, ue({}, Ee, { children: X })),
          (g || (y && x === "end")) &&
            Q.jsx(de, ue({}, le, { children: y && x === "end" ? X : g })),
        ],
      })
    );
  });
FP.muiName = "Button";
const s7 = Ef(
    Q.jsx("path", {
      d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z",
    }),
    "ArrowDownward"
  ),
  jc = Ef(Q.jsx("path", { d: "m10 17 5-5-5-5z" }), "ArrowRight"),
  a7 = Ef(
    Q.jsx("path", {
      d: "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96M10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41z",
    }),
    "CloudDone"
  ),
  l7 = Ef(
    Q.jsx("path", { d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z" }),
    "KeyboardArrowRight"
  ),
  u7 = Ef(
    Q.jsx("path", {
      d: "M9.19 6.35c-2.04 2.29-3.44 5.58-3.57 5.89L2 10.69l4.05-4.05c.47-.47 1.15-.68 1.81-.55zM11.17 17s3.74-1.55 5.89-3.7c5.4-5.4 4.5-9.62 4.21-10.57-.95-.3-5.17-1.19-10.57 4.21C8.55 9.09 7 12.83 7 12.83zm6.48-2.19c-2.29 2.04-5.58 3.44-5.89 3.57L13.31 22l4.05-4.05c.47-.47.68-1.15.55-1.81zM9 18c0 .83-.34 1.58-.88 2.12C6.94 21.3 2 22 2 22s.7-4.94 1.88-6.12C4.42 15.34 5.17 15 6 15c1.66 0 3 1.34 3 3m4-9c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2",
    }),
    "RocketLaunch"
  ),
  c7 = ({ onStart: n }) =>
    Q.jsxs("div", {
      style: {
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        backgroundColor: "#1A202C",
        justifyContent: "center",
        alignItems: "center",
        textAlign: "center",
        padding: "20px",
      },
      children: [
        Q.jsx("h1", {
          style: { color: "white", marginBottom: "20px" },
          children: "Demonstration of Smart Contract",
        }),
        Q.jsx("video", {
          width: "800",
          height: "450",
          controls: !0,
          className: "animation-video",
          children: Q.jsx("source", {
            src: "/Smart-contract.mp4",
            type: "video/mp4",
          }),
        }),
        Q.jsx("div", {
          style: {
            marginTop: "20px",
            width: "800px",
            display: "flex",
            justifyContent: "flex-end",
          },
          children: Q.jsx(FP, {
            endDecorator: Q.jsx(l7, {}),
            color: "success",
            size: "lg",
            onClick: n,
            children: "Go to Simulation",
          }),
        }),
      ],
    });
var qp = {},
  C1 = {};
const f7 = Ul(AD);
var LC;
function d7() {
  return (
    LC ||
      ((LC = 1),
      (function (n) {
        "use client";
        Object.defineProperty(n, "__esModule", { value: !0 }),
          Object.defineProperty(n, "default", {
            enumerable: !0,
            get: function () {
              return e.createSvgIcon;
            },
          });
        var e = f7;
      })(C1)),
    C1
  );
}
var kC;
function h7() {
  if (kC) return qp;
  kC = 1;
  var n = OS();
  Object.defineProperty(qp, "__esModule", { value: !0 }), (qp.default = void 0);
  var e = n(d7()),
    t = DC();
  return (
    (qp.default = (0, e.default)(
      (0, t.jsx)("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z",
      }),
      "CheckCircle"
    )),
    qp
  );
}
var p7 = h7();
const m7 = Ah(p7);
function g7() {
  var le, fe, Ee;
  const {
      sender: n,
      receiver: e,
      validator: t,
      phase: r,
      contractDeployed: i,
      contractHash: o,
      smartContract: s,
      winner: l,
      initialContract: u,
    } = $u((ge) => ge.simulation),
    [f, h] = K.useState(0),
    [m, g] = K.useState(""),
    [y, x] = K.useState(""),
    [S, _] = K.useState(""),
    [w, T] = K.useState(""),
    [E, A] = K.useState(""),
    [R, k] = K.useState(""),
    [P, U] = K.useState(Boolean),
    [N, L] = K.useState(""),
    [H, G] = K.useState(""),
    [$, q] = K.useState(""),
    [Z, X] = K.useState(u),
    [re, W] = K.useState(""),
    te = [
      {
        text: "Who will win in Barcelona vs Real Madrid?",
        answers: ["Barcelona", "Real Madrid", "Draw"],
      },
      {
        text: "Who will score the first goal in Manchester United vs Liverpool?",
        answers: ["Manchester United", "Liverpool", "No Goal"],
      },
      {
        text: "Who will win the 2026 FIFA World Cup?",
        answers: ["Argentina", "Brazil", "France", "Germany", "Other"],
      },
      {
        text: "Which team will qualify first for the Champions League semi-final?",
        answers: [
          "Manchester City",
          "Bayern Munich",
          "PSG",
          "Barcelona",
          "Other",
        ],
      },
      {
        text: "Who will win the next El Clasico?",
        answers: ["Barcelona", "Real Madrid", "Draw"],
      },
      {
        text: "Which player will get the Ballon d'Or next year?",
        answers: ["Messi", "Ronaldo", "Mbappe", "Haaland", "Other"],
      },
      {
        text: "Who will score more goals this season?",
        answers: ["Messi", "Ronaldo", "Equal"],
      },
      {
        text: "Which club will win the UEFA Champions League Final?",
        answers: [
          "Real Madrid",
          "Manchester City",
          "PSG",
          "Bayern Munich",
          "Other",
        ],
      },
    ],
    F = yS(),
    [V, ne] = K.useState({ open: !1, message: "", severity: "success" });
  K.useEffect(() => {
    s &&
      ne({
        open: !0,
        message: "Successfully created smart contract",
        severity: "success",
      });
  }, [s]),
    K.useEffect(() => {
      s &&
        ne({
          open: !0,
          message: "Successfully created smart contract",
          severity: "success",
        }),
        l &&
          ne({
            open: !0,
            message: `${l} is the winner in bet game`,
            severity: "success",
          });
    }, [l]),
    K.useEffect(() => {
      i &&
        ne({
          open: !0,
          message: "Smart Contract Deployed!",
          severity: "success",
        });
    }, [i]);
  const ae = Array.from({ length: 10 }, (ge, xe) => ({
      id: xe,
      name: `User ${xe + 1}`,
    })),
    J = ae.filter((ge) => ge.id !== w && ge.id !== E),
    oe = () => {
      const ge = [m, y].filter((xe) => xe.trim() !== "");
      if (ge.length > 0) {
        const xe = ge[Math.floor(Math.random() * ge.length)];
        _(xe),
          xe === m
            ? (F(aE(H)), W($), F(S_(w)), F(__(E)))
            : (F(aE($)), W(H), F(S_(E)), F(__(w)));
      }
    };
  K.useEffect(() => {
    if (i) {
      h(0);
      let ge = 1;
      const xe = setInterval(() => {
        h(ge), ge++, ge > 6 && clearInterval(xe);
      }, 3e3);
      return () => clearInterval(xe);
    }
  }, [i]);
  const de = (ge) => ({
    opacity: f >= ge ? 1 : 0,
    transform: f >= ge ? "translateY(0)" : "translateY(10px)",
    transition: "opacity 0.6s ease, transform 0.6s ease",
  });
  return Q.jsx(xn, {
    sx: {
      paddingLeft: "50px",
      width: "90%",
      maxWidth: { xs: "100%", sm: "600px" },
      mx: "auto",
      px: { xs: 1.5, sm: 2 },
      py: 2,
    },
    children:
      s &&
      Q.jsxs(Q.Fragment, {
        children: [
          Q.jsx(hF, {
            label: "Smart Contract",
            value: Z,
            onChange: (ge) => F(X(ge.target.value)),
            multiline: !0,
            fullWidth: !0,
            minRows: 8,
            spellCheck: !1,
            InputProps: {
              sx: {
                bgcolor: "#0b0b0b",
                borderRadius: 2,
                "& .MuiInputBase-input": {
                  fontFamily:
                    'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
                  fontSize: 14,
                  lineHeight: 1.6,
                },
                "& textarea": {
                  color: "#e6e6e6",
                  caretColor: "#e6e6e6",
                  whiteSpace: "pre",
                  overflow: "auto",
                },
              },
            },
            sx: {
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "#333" },
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "#555",
              },
              "& .Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "#888",
              },
              "& .MuiInputLabel-root": { color: "#bdbdbd" },
              "& .MuiInputLabel-root.Mui-focused": { color: "#d0d0d0" },
              "& textarea": { maxHeight: { xs: "200px", sm: "300px" } },
            },
            placeholder: "// Write your contract here...",
          }),
          Q.jsxs(xn, {
            sx: {
              display: "flex",
              flexDirection: "column",
              gap: 2,
              mt: 3,
              width: "100%",
            },
            children: [
              Q.jsxs(ef, {
                elevation: 3,
                sx: {
                  p: 2,
                  borderRadius: 2,
                  bgcolor: "#1e1e1e",
                  color: "white",
                  display: "flex",
                  alignItems: "center",
                  gap: 1.5,
                },
                children: [
                  Q.jsx(m7, { sx: { color: "lightgreen" } }),
                  Q.jsx(mr, {
                    children: "Smart contract created successfully.",
                  }),
                ],
              }),
              Q.jsxs(ef, {
                elevation: 3,
                sx: {
                  p: 2,
                  borderRadius: 2,
                  bgcolor: "#1e1e1e",
                  color: "white",
                  display: "flex",
                  alignItems: "center",
                  gap: 1.5,
                },
                children: [
                  Q.jsx(u7, { sx: { color: "#ffb74d" } }),
                  Q.jsx(mr, { children: "Next, deploy the smart contract." }),
                ],
              }),
              i &&
                Q.jsxs(ef, {
                  elevation: 3,
                  sx: {
                    p: 2,
                    borderRadius: 2,
                    bgcolor: "#1e1e1e",
                    color: "white",
                    display: "flex",
                    alignItems: "center",
                    gap: 1.5,
                  },
                  children: [
                    Q.jsx(a7, { sx: { color: "greenyellow" } }),
                    Q.jsx(mr, {
                      children:
                        "Smart contract deployed on blockchain network.",
                    }),
                  ],
                }),
              i &&
                Q.jsxs(Q.Fragment, {
                  children: [
                    Q.jsxs(ef, {
                      elevation: 3,
                      sx: {
                        p: 2,
                        borderRadius: 2,
                        bgcolor: "#1e1e1e",
                        color: "white",
                        display: "flex",
                        alignItems: "center",
                        gap: 1.5,
                        ...de(2),
                      },
                      children: [
                        Q.jsx(mr, {
                          children:
                            "Let’s move to the Bet game, which works on the deployed smart contract.",
                        }),
                        Q.jsx(s7, {
                          sx: {
                            color: "#4dabf7",
                            fontSize: 20,
                            animation: "blink 1s infinite",
                            "@keyframes blink": {
                              "0%, 50%, 100%": { opacity: 1 },
                              "25%, 75%": { opacity: 0 },
                            },
                          },
                        }),
                      ],
                    }),
                    Q.jsxs(ef, {
                      elevation: 3,
                      sx: {
                        p: 2,
                        borderRadius: 2,
                        bgcolor: "#494949ff",
                        color: "white",
                        ...de(3),
                      },
                      children: [
                        Q.jsx(mr, {
                          variant: "h6",
                          sx: { mb: 2, fontWeight: "bold", color: "#4dabf7" },
                          children: "🕹️ Bet Game Instructions",
                        }),
                        Q.jsxs(I2, {
                          sx: de(4),
                          children: [
                            Q.jsxs(Rc, {
                              alignItems: "flex-start",
                              children: [
                                Q.jsx(Pc, {
                                  children: Q.jsx(jc, {
                                    sx: { color: "#4dabf7" },
                                  }),
                                }),
                                Q.jsx(Ic, {
                                  primary:
                                    "First, select a question for the Bet Game.",
                                  primaryTypographyProps: { sx: { mb: 1 } },
                                }),
                              ],
                            }),
                            Q.jsx(xn, {
                              sx: {
                                bgcolor: "white",
                                p: 2,
                                borderRadius: 2,
                                mb: 2,
                              },
                              children: Q.jsxs(Yc, {
                                fullWidth: !0,
                                children: [
                                  Q.jsx(rh, { children: "Question" }),
                                  Q.jsx(tf, {
                                    disabled: !i,
                                    value: N,
                                    onChange: (ge) => {
                                      L(ge.target.value), __(""), S_("");
                                    },
                                    children: te.map((ge, xe) =>
                                      Q.jsx(
                                        Pp,
                                        { value: ge.text, children: ge.text },
                                        xe
                                      )
                                    ),
                                  }),
                                ],
                              }),
                            }),
                            N &&
                              Q.jsxs(Q.Fragment, {
                                children: [
                                  Q.jsxs(Rc, {
                                    alignItems: "flex-start",
                                    children: [
                                      Q.jsx(Pc, {
                                        children: Q.jsx(jc, {
                                          sx: { color: "#4dabf7" },
                                        }),
                                      }),
                                      Q.jsx(Ic, {
                                        primary:
                                          "Then, choose players and their bet answers. (Blocks in the blockchain network represent players in the Bet Game).",
                                        primaryTypographyProps: {
                                          sx: { mb: 1 },
                                        },
                                      }),
                                    ],
                                  }),
                                  Q.jsxs(xn, {
                                    sx: {
                                      bgcolor: "white",
                                      p: 2,
                                      borderRadius: 2,
                                      mb: 2,
                                      display: "flex",
                                      flexDirection: "column",
                                      gap: 2,
                                    },
                                    children: [
                                      Q.jsxs(xn, {
                                        sx: {
                                          display: "flex",
                                          gap: 2,
                                          flexDirection: {
                                            xs: "column",
                                            sm: "row",
                                          },
                                          bgcolor:
                                            l && H === l
                                              ? "green"
                                              : re && H === re
                                              ? "red"
                                              : "white",
                                        },
                                        children: [
                                          Q.jsxs(Yc, {
                                            fullWidth: !0,
                                            disabled: r !== "idle",
                                            children: [
                                              Q.jsx(rh, {
                                                children: "Player 1",
                                              }),
                                              Q.jsx(tf, {
                                                disabled: !i,
                                                value: w,
                                                onChange: (ge) => {
                                                  T(ge.target.value);
                                                  const xe = ae.find(
                                                    (j) =>
                                                      j.id === ge.target.value
                                                  );
                                                  G(xe.name);
                                                },
                                                children: ae
                                                  .filter((ge) => ge.id !== E)
                                                  .map((ge) =>
                                                    Q.jsx(
                                                      Pp,
                                                      {
                                                        value: ge.id,
                                                        children: ge.name,
                                                      },
                                                      ge.id
                                                    )
                                                  ),
                                              }),
                                            ],
                                          }),
                                          Q.jsxs(Yc, {
                                            fullWidth: !0,
                                            disabled: !N,
                                            children: [
                                              Q.jsx(rh, { children: "Answer" }),
                                              Q.jsx(tf, {
                                                disabled: !i,
                                                value: m,
                                                onChange: (ge) =>
                                                  g(ge.target.value),
                                                children:
                                                  (le = te.find(
                                                    (ge) => ge.text === N
                                                  )) == null
                                                    ? void 0
                                                    : le.answers
                                                        .filter(
                                                          (ge) => ge !== y
                                                        )
                                                        .map((ge, xe) =>
                                                          Q.jsx(
                                                            Pp,
                                                            {
                                                              value: ge,
                                                              children: ge,
                                                            },
                                                            xe
                                                          )
                                                        ),
                                              }),
                                            ],
                                          }),
                                        ],
                                      }),
                                      Q.jsxs(xn, {
                                        sx: {
                                          display: "flex",
                                          gap: 2,
                                          flexDirection: {
                                            xs: "column",
                                            sm: "row",
                                          },
                                          bgcolor:
                                            l && $ === l
                                              ? "green"
                                              : re && $ === re
                                              ? "red"
                                              : "white",
                                        },
                                        children: [
                                          Q.jsxs(Yc, {
                                            fullWidth: !0,
                                            disabled: r !== "idle",
                                            children: [
                                              Q.jsx(rh, {
                                                children: "Player 2",
                                              }),
                                              Q.jsx(tf, {
                                                disabled: !i,
                                                value: E,
                                                onChange: (ge) => {
                                                  A(ge.target.value);
                                                  const xe = ae.find(
                                                    (j) =>
                                                      j.id === ge.target.value
                                                  );
                                                  q(xe.name);
                                                },
                                                children: ae
                                                  .filter((ge) => ge.id !== w)
                                                  .map((ge) =>
                                                    Q.jsx(
                                                      Pp,
                                                      {
                                                        value: ge.id,
                                                        children: ge.name,
                                                      },
                                                      ge.id
                                                    )
                                                  ),
                                              }),
                                            ],
                                          }),
                                          Q.jsxs(Yc, {
                                            fullWidth: !0,
                                            disabled: !N,
                                            children: [
                                              Q.jsx(rh, { children: "Answer" }),
                                              Q.jsx(tf, {
                                                disabled: !i,
                                                value: y,
                                                onChange: (ge) =>
                                                  x(ge.target.value),
                                                children:
                                                  (fe = te.find(
                                                    (ge) => ge.text === N
                                                  )) == null
                                                    ? void 0
                                                    : fe.answers
                                                        .filter(
                                                          (ge) => ge !== m
                                                        )
                                                        .map((ge, xe) =>
                                                          Q.jsx(
                                                            Pp,
                                                            {
                                                              value: ge,
                                                              children: ge,
                                                            },
                                                            xe
                                                          )
                                                        ),
                                              }),
                                            ],
                                          }),
                                        ],
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                            w &&
                              E &&
                              m &&
                              y &&
                              Q.jsxs(Q.Fragment, {
                                children: [
                                  "   ",
                                  Q.jsxs(Rc, {
                                    alignItems: "flex-start",
                                    children: [
                                      Q.jsx(Pc, {
                                        children: Q.jsx(jc, {
                                          sx: { color: "#4dabf7" },
                                        }),
                                      }),
                                      Q.jsx(Ic, {
                                        primary:
                                          "After clicking the Play button, a random answer from the players is selected.",
                                        primaryTypographyProps: {
                                          sx: { mb: 1 },
                                        },
                                      }),
                                    ],
                                  }),
                                  Q.jsx(xn, {
                                    sx: {
                                      bgcolor: "white",
                                      p: 2,
                                      borderRadius: 2,
                                      mb: 2,
                                    },
                                    children: Q.jsxs(xn, {
                                      sx: {
                                        display: "flex",
                                        gap: 2,
                                        flexDirection: {
                                          xs: "column",
                                          sm: "row",
                                        },
                                        alignItems: {
                                          xs: "stretch",
                                          sm: "center",
                                        },
                                      },
                                      children: [
                                        Q.jsx(rm, {
                                          disabled:
                                            !i ||
                                            !w ||
                                            !E ||
                                            !m ||
                                            !y ||
                                            !N ||
                                            S,
                                          variant: "contained",
                                          color: "primary",
                                          onClick: oe,
                                          sx: {
                                            borderRadius: "8px",
                                            textTransform: "none",
                                            fontWeight: 600,
                                            flex: 1,
                                          },
                                          children: "Play",
                                        }),
                                        S &&
                                          Q.jsx(xn, {
                                            sx: {
                                              color: "black",
                                              flex: 1,
                                              p: 1,
                                              bgcolor: "#ffffffff",
                                              borderRadius: "6px",
                                              textAlign: "center",
                                              fontWeight: 600,
                                            },
                                            children: S,
                                          }),
                                      ],
                                    }),
                                  }),
                                ],
                              }),
                            S &&
                              Q.jsxs(Q.Fragment, {
                                children: [
                                  Q.jsxs(Rc, {
                                    children: [
                                      Q.jsx(Pc, {
                                        children: Q.jsx(jc, {
                                          sx: { color: "#4caf50" },
                                        }),
                                      }),
                                      Q.jsx(Ic, {
                                        primary:
                                          "The player whose answer is selected becomes the winner.",
                                      }),
                                    ],
                                  }),
                                  Q.jsxs(Rc, {
                                    children: [
                                      Q.jsx(Pc, {
                                        children: Q.jsx(jc, {
                                          sx: { color: "#4caf50" },
                                        }),
                                      }),
                                      Q.jsx(Ic, {
                                        primary:
                                          "Now you have to find a miner among the remaining palyers in the network",
                                      }),
                                    ],
                                  }),
                                  Q.jsxs(Rc, {
                                    children: [
                                      Q.jsx(Pc, {
                                        children: Q.jsx(jc, {
                                          sx: { color: "#4caf50" },
                                        }),
                                      }),
                                      Q.jsx(Ic, {
                                        primary: "Click the button Find miner",
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                            l &&
                              Q.jsx(Yc, {
                                fullWidth: !0,
                                disabled:
                                  w === null || E === null || r !== "idle",
                                children: Q.jsx(xn, {
                                  sx: {
                                    display: "flex",
                                    flexDirection: "column",
                                    gap: 1,
                                    mt: 2,
                                  },
                                  children: R
                                    ? R === "finding"
                                      ? Q.jsx(mr, {
                                          sx: {
                                            color: "orange",
                                            fontWeight: 600,
                                          },
                                          children: "Miners solving puzzles...",
                                        })
                                      : Q.jsxs(mr, {
                                          sx: {
                                            color: "green",
                                            fontWeight: 600,
                                          },
                                          children: [
                                            (Ee = ae.find(
                                              (ge) => ge.id === R
                                            )) == null
                                              ? void 0
                                              : Ee.name,
                                            " solved the puzzle first and is selected as the miner. ✅",
                                          ],
                                        })
                                    : Q.jsx(rm, {
                                        disabled: !i || r !== "idle",
                                        variant: "contained",
                                        color: "secondary",
                                        onClick: () => {
                                          k("finding"),
                                            setTimeout(() => {
                                              const ge =
                                                J[
                                                  Math.floor(
                                                    Math.random() * J.length
                                                  )
                                                ];
                                              k(ge.id), F(X2(ge.id));
                                            }, 1500);
                                        },
                                        sx: {
                                          borderRadius: "8px",
                                          textTransform: "none",
                                          fontWeight: 600,
                                        },
                                        children: "Find Miner",
                                      }),
                                }),
                              }),
                            R &&
                              Q.jsxs(Rc, {
                                children: [
                                  Q.jsx(Pc, {
                                    children: Q.jsx(jc, {
                                      sx: { color: "#ff7043" },
                                    }),
                                  }),
                                  Q.jsx(Ic, {
                                    primary:
                                      "Now initiate the Tranaction button ",
                                  }),
                                ],
                              }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
            ],
          }),
        ],
      }),
  });
}
function v7() {
  const [n, e] = K.useState(!1),
    [t, r] = K.useState(0),
    { showNetwork: i, smartContract: o } = $u((u) => u.simulation),
    s = () => {
      e(!0);
    },
    l = () => {
      r((u) => u + 1);
    };
  return Q.jsx(zC, {
    store: Y2,
    children: n
      ? Q.jsxs(
          xn,
          {
            sx: {
              height: "100vh",
              width: "100vw",
              display: "flex",
              flexDirection: { xs: "column", md: "row" },
              bgcolor: "#1a202c",
              position: "relative",
            },
            children: [
              Q.jsx(xn, {
                sx: {
                  width: { xs: "100%", md: i ? "18%" : "100%" },
                  height: { xs: "30%", md: "100%" },
                  zIndex: 1,
                },
                children: Q.jsx(c4, { onReset: l }),
              }),
              i &&
                Q.jsx(xn, {
                  sx: {
                    width: { xs: "100%", md: "54%" },
                    height: { xs: "40%", md: "100%" },
                    zIndex: 1,
                  },
                  children: Q.jsx(T9, {}),
                }),
              Q.jsx(xn, {
                padding: "30px",
                sx: {
                  width: { xs: "100%", md: i ? "28%" : o ? "82%" : "0%" },
                  height: "100%",
                  position: i ? { xs: "absolute", md: "relative" } : "relative",
                  top: i ? { xs: 0, md: "auto" } : "auto",
                  left: i ? { xs: 0, md: "auto" } : "auto",
                  zIndex: i ? { xs: 10, md: 1 } : 1,
                  bgcolor: i
                    ? { xs: "rgba(26,32,44,0.95)", md: "transparent" }
                    : "transparent",
                  overflowY: "auto",
                },
                children: Q.jsx(g7, {}),
              }),
            ],
          },
          t
        )
      : Q.jsx(c7, { onStart: s }),
  });
}
v3.createRoot(document.getElementById("root")).render(
  Q.jsx(Cs.StrictMode, {
    children: Q.jsx(zC, { store: Y2, children: Q.jsx(v7, {}) }),
  })
);
