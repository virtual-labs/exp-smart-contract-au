function z3(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o &&
            Object.defineProperty(
              n,
              i,
              o.get ? o : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const s of o.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const o = {};
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (o.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (o.credentials = "omit")
        : (o.credentials = "same-origin"),
      o
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const o = t(i);
    fetch(i.href, o);
  }
})();
function Oh(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function Gl(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(
        t,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return n[r];
              },
            }
      );
    }),
    t
  );
}
var Qx = { exports: {} },
  Ip = {},
  e_ = { exports: {} },
  hn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Gb;
function H3() {
  if (Gb) return hn;
  Gb = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    a = Symbol.for("react.forward_ref"),
    u = Symbol.for("react.suspense"),
    c = Symbol.for("react.memo"),
    d = Symbol.for("react.lazy"),
    m = Symbol.iterator;
  function g(F) {
    return F === null || typeof F != "object"
      ? null
      : ((F = (m && F[m]) || F["@@iterator"]),
        typeof F == "function" ? F : null);
  }
  var y = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    x = Object.assign,
    S = {};
  function _(F, V, ne) {
    (this.props = F),
      (this.context = V),
      (this.refs = S),
      (this.updater = ne || y);
  }
  (_.prototype.isReactComponent = {}),
    (_.prototype.setState = function (F, V) {
      if (typeof F != "object" && typeof F != "function" && F != null)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, F, V, "setState");
    }),
    (_.prototype.forceUpdate = function (F) {
      this.updater.enqueueForceUpdate(this, F, "forceUpdate");
    });
  function w() {}
  w.prototype = _.prototype;
  function T(F, V, ne) {
    (this.props = F),
      (this.context = V),
      (this.refs = S),
      (this.updater = ne || y);
  }
  var M = (T.prototype = new w());
  (M.constructor = T), x(M, _.prototype), (M.isPureReactComponent = !0);
  var A = Array.isArray,
    R = Object.prototype.hasOwnProperty,
    D = { current: null },
    P = { key: !0, ref: !0, __self: !0, __source: !0 };
  function U(F, V, ne) {
    var ae,
      J = {},
      se = null,
      de = null;
    if (V != null)
      for (ae in (V.ref !== void 0 && (de = V.ref),
      V.key !== void 0 && (se = "" + V.key),
      V))
        R.call(V, ae) && !P.hasOwnProperty(ae) && (J[ae] = V[ae]);
    var le = arguments.length - 2;
    if (le === 1) J.children = ne;
    else if (1 < le) {
      for (var fe = Array(le), Me = 0; Me < le; Me++)
        fe[Me] = arguments[Me + 2];
      J.children = fe;
    }
    if (F && F.defaultProps)
      for (ae in ((le = F.defaultProps), le))
        J[ae] === void 0 && (J[ae] = le[ae]);
    return {
      $$typeof: n,
      type: F,
      key: se,
      ref: de,
      props: J,
      _owner: D.current,
    };
  }
  function O(F, V) {
    return {
      $$typeof: n,
      type: F.type,
      key: V,
      ref: F.ref,
      props: F.props,
      _owner: F._owner,
    };
  }
  function L(F) {
    return typeof F == "object" && F !== null && F.$$typeof === n;
  }
  function H(F) {
    var V = { "=": "=0", ":": "=2" };
    return (
      "$" +
      F.replace(/[=:]/g, function (ne) {
        return V[ne];
      })
    );
  }
  var W = /\/+/g;
  function $(F, V) {
    return typeof F == "object" && F !== null && F.key != null
      ? H("" + F.key)
      : V.toString(36);
  }
  function K(F, V, ne, ae, J) {
    var se = typeof F;
    (se === "undefined" || se === "boolean") && (F = null);
    var de = !1;
    if (F === null) de = !0;
    else
      switch (se) {
        case "string":
        case "number":
          de = !0;
          break;
        case "object":
          switch (F.$$typeof) {
            case n:
            case e:
              de = !0;
          }
      }
    if (de)
      return (
        (de = F),
        (J = J(de)),
        (F = ae === "" ? "." + $(de, 0) : ae),
        A(J)
          ? ((ne = ""),
            F != null && (ne = F.replace(W, "$&/") + "/"),
            K(J, V, ne, "", function (Me) {
              return Me;
            }))
          : J != null &&
            (L(J) &&
              (J = O(
                J,
                ne +
                  (!J.key || (de && de.key === J.key)
                    ? ""
                    : ("" + J.key).replace(W, "$&/") + "/") +
                  F
              )),
            V.push(J)),
        1
      );
    if (((de = 0), (ae = ae === "" ? "." : ae + ":"), A(F)))
      for (var le = 0; le < F.length; le++) {
        se = F[le];
        var fe = ae + $(se, le);
        de += K(se, V, ne, fe, J);
      }
    else if (((fe = g(F)), typeof fe == "function"))
      for (F = fe.call(F), le = 0; !(se = F.next()).done; )
        (se = se.value), (fe = ae + $(se, le++)), (de += K(se, V, ne, fe, J));
    else if (se === "object")
      throw (
        ((V = String(F)),
        Error(
          "Objects are not valid as a React child (found: " +
            (V === "[object Object]"
              ? "object with keys {" + Object.keys(F).join(", ") + "}"
              : V) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    return de;
  }
  function Z(F, V, ne) {
    if (F == null) return F;
    var ae = [],
      J = 0;
    return (
      K(F, ae, "", "", function (se) {
        return V.call(ne, se, J++);
      }),
      ae
    );
  }
  function Y(F) {
    if (F._status === -1) {
      var V = F._result;
      (V = V()),
        V.then(
          function (ne) {
            (F._status === 0 || F._status === -1) &&
              ((F._status = 1), (F._result = ne));
          },
          function (ne) {
            (F._status === 0 || F._status === -1) &&
              ((F._status = 2), (F._result = ne));
          }
        ),
        F._status === -1 && ((F._status = 0), (F._result = V));
    }
    if (F._status === 1) return F._result.default;
    throw F._result;
  }
  var re = { current: null },
    G = { transition: null },
    te = {
      ReactCurrentDispatcher: re,
      ReactCurrentBatchConfig: G,
      ReactCurrentOwner: D,
    };
  return (
    (hn.Children = {
      map: Z,
      forEach: function (F, V, ne) {
        Z(
          F,
          function () {
            V.apply(this, arguments);
          },
          ne
        );
      },
      count: function (F) {
        var V = 0;
        return (
          Z(F, function () {
            V++;
          }),
          V
        );
      },
      toArray: function (F) {
        return (
          Z(F, function (V) {
            return V;
          }) || []
        );
      },
      only: function (F) {
        if (!L(F))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return F;
      },
    }),
    (hn.Component = _),
    (hn.Fragment = t),
    (hn.Profiler = i),
    (hn.PureComponent = T),
    (hn.StrictMode = r),
    (hn.Suspense = u),
    (hn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = te),
    (hn.cloneElement = function (F, V, ne) {
      if (F == null)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            F +
            "."
        );
      var ae = x({}, F.props),
        J = F.key,
        se = F.ref,
        de = F._owner;
      if (V != null) {
        if (
          (V.ref !== void 0 && ((se = V.ref), (de = D.current)),
          V.key !== void 0 && (J = "" + V.key),
          F.type && F.type.defaultProps)
        )
          var le = F.type.defaultProps;
        for (fe in V)
          R.call(V, fe) &&
            !P.hasOwnProperty(fe) &&
            (ae[fe] = V[fe] === void 0 && le !== void 0 ? le[fe] : V[fe]);
      }
      var fe = arguments.length - 2;
      if (fe === 1) ae.children = ne;
      else if (1 < fe) {
        le = Array(fe);
        for (var Me = 0; Me < fe; Me++) le[Me] = arguments[Me + 2];
        ae.children = le;
      }
      return {
        $$typeof: n,
        type: F.type,
        key: J,
        ref: se,
        props: ae,
        _owner: de,
      };
    }),
    (hn.createContext = function (F) {
      return (
        (F = {
          $$typeof: s,
          _currentValue: F,
          _currentValue2: F,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (F.Provider = { $$typeof: o, _context: F }),
        (F.Consumer = F)
      );
    }),
    (hn.createElement = U),
    (hn.createFactory = function (F) {
      var V = U.bind(null, F);
      return (V.type = F), V;
    }),
    (hn.createRef = function () {
      return { current: null };
    }),
    (hn.forwardRef = function (F) {
      return { $$typeof: a, render: F };
    }),
    (hn.isValidElement = L),
    (hn.lazy = function (F) {
      return { $$typeof: d, _payload: { _status: -1, _result: F }, _init: Y };
    }),
    (hn.memo = function (F, V) {
      return { $$typeof: c, type: F, compare: V === void 0 ? null : V };
    }),
    (hn.startTransition = function (F) {
      var V = G.transition;
      G.transition = {};
      try {
        F();
      } finally {
        G.transition = V;
      }
    }),
    (hn.unstable_act = function () {
      throw Error("act(...) is not supported in production builds of React.");
    }),
    (hn.useCallback = function (F, V) {
      return re.current.useCallback(F, V);
    }),
    (hn.useContext = function (F) {
      return re.current.useContext(F);
    }),
    (hn.useDebugValue = function () {}),
    (hn.useDeferredValue = function (F) {
      return re.current.useDeferredValue(F);
    }),
    (hn.useEffect = function (F, V) {
      return re.current.useEffect(F, V);
    }),
    (hn.useId = function () {
      return re.current.useId();
    }),
    (hn.useImperativeHandle = function (F, V, ne) {
      return re.current.useImperativeHandle(F, V, ne);
    }),
    (hn.useInsertionEffect = function (F, V) {
      return re.current.useInsertionEffect(F, V);
    }),
    (hn.useLayoutEffect = function (F, V) {
      return re.current.useLayoutEffect(F, V);
    }),
    (hn.useMemo = function (F, V) {
      return re.current.useMemo(F, V);
    }),
    (hn.useReducer = function (F, V, ne) {
      return re.current.useReducer(F, V, ne);
    }),
    (hn.useRef = function (F) {
      return re.current.useRef(F);
    }),
    (hn.useState = function (F) {
      return re.current.useState(F);
    }),
    (hn.useSyncExternalStore = function (F, V, ne) {
      return re.current.useSyncExternalStore(F, V, ne);
    }),
    (hn.useTransition = function () {
      return re.current.useTransition();
    }),
    (hn.version = "18.2.0"),
    hn
  );
}
var jb;
function Nh() {
  return jb || ((jb = 1), (e_.exports = H3())), e_.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var $b;
function V3() {
  if ($b) return Ip;
  $b = 1;
  var n = Nh(),
    e = Symbol.for("react.element"),
    t = Symbol.for("react.fragment"),
    r = Object.prototype.hasOwnProperty,
    i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, u, c) {
    var d,
      m = {},
      g = null,
      y = null;
    c !== void 0 && (g = "" + c),
      u.key !== void 0 && (g = "" + u.key),
      u.ref !== void 0 && (y = u.ref);
    for (d in u) r.call(u, d) && !o.hasOwnProperty(d) && (m[d] = u[d]);
    if (a && a.defaultProps)
      for (d in ((u = a.defaultProps), u)) m[d] === void 0 && (m[d] = u[d]);
    return {
      $$typeof: e,
      type: a,
      key: g,
      ref: y,
      props: m,
      _owner: i.current,
    };
  }
  return (Ip.Fragment = t), (Ip.jsx = s), (Ip.jsxs = s), Ip;
}
var Xb;
function rC() {
  return Xb || ((Xb = 1), (Qx.exports = V3())), Qx.exports;
}
var Q = rC(),
  X = Nh();
const Is = Oh(X),
  G1 = z3({ __proto__: null, default: Is }, [X]);
var dv = {},
  t_ = { exports: {} },
  Uo = {},
  n_ = { exports: {} },
  r_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Yb;
function W3() {
  return (
    Yb ||
      ((Yb = 1),
      (function (n) {
        function e(G, te) {
          var F = G.length;
          G.push(te);
          e: for (; 0 < F; ) {
            var V = (F - 1) >>> 1,
              ne = G[V];
            if (0 < i(ne, te)) (G[V] = te), (G[F] = ne), (F = V);
            else break e;
          }
        }
        function t(G) {
          return G.length === 0 ? null : G[0];
        }
        function r(G) {
          if (G.length === 0) return null;
          var te = G[0],
            F = G.pop();
          if (F !== te) {
            G[0] = F;
            e: for (var V = 0, ne = G.length, ae = ne >>> 1; V < ae; ) {
              var J = 2 * (V + 1) - 1,
                se = G[J],
                de = J + 1,
                le = G[de];
              if (0 > i(se, F))
                de < ne && 0 > i(le, se)
                  ? ((G[V] = le), (G[de] = F), (V = de))
                  : ((G[V] = se), (G[J] = F), (V = J));
              else if (de < ne && 0 > i(le, F))
                (G[V] = le), (G[de] = F), (V = de);
              else break e;
            }
          }
          return te;
        }
        function i(G, te) {
          var F = G.sortIndex - te.sortIndex;
          return F !== 0 ? F : G.id - te.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var s = Date,
            a = s.now();
          n.unstable_now = function () {
            return s.now() - a;
          };
        }
        var u = [],
          c = [],
          d = 1,
          m = null,
          g = 3,
          y = !1,
          x = !1,
          S = !1,
          _ = typeof setTimeout == "function" ? setTimeout : null,
          w = typeof clearTimeout == "function" ? clearTimeout : null,
          T = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function M(G) {
          for (var te = t(c); te !== null; ) {
            if (te.callback === null) r(c);
            else if (te.startTime <= G)
              r(c), (te.sortIndex = te.expirationTime), e(u, te);
            else break;
            te = t(c);
          }
        }
        function A(G) {
          if (((S = !1), M(G), !x))
            if (t(u) !== null) (x = !0), Y(R);
            else {
              var te = t(c);
              te !== null && re(A, te.startTime - G);
            }
        }
        function R(G, te) {
          (x = !1), S && ((S = !1), w(U), (U = -1)), (y = !0);
          var F = g;
          try {
            for (
              M(te), m = t(u);
              m !== null && (!(m.expirationTime > te) || (G && !H()));

            ) {
              var V = m.callback;
              if (typeof V == "function") {
                (m.callback = null), (g = m.priorityLevel);
                var ne = V(m.expirationTime <= te);
                (te = n.unstable_now()),
                  typeof ne == "function"
                    ? (m.callback = ne)
                    : m === t(u) && r(u),
                  M(te);
              } else r(u);
              m = t(u);
            }
            if (m !== null) var ae = !0;
            else {
              var J = t(c);
              J !== null && re(A, J.startTime - te), (ae = !1);
            }
            return ae;
          } finally {
            (m = null), (g = F), (y = !1);
          }
        }
        var D = !1,
          P = null,
          U = -1,
          O = 5,
          L = -1;
        function H() {
          return !(n.unstable_now() - L < O);
        }
        function W() {
          if (P !== null) {
            var G = n.unstable_now();
            L = G;
            var te = !0;
            try {
              te = P(!0, G);
            } finally {
              te ? $() : ((D = !1), (P = null));
            }
          } else D = !1;
        }
        var $;
        if (typeof T == "function")
          $ = function () {
            T(W);
          };
        else if (typeof MessageChannel < "u") {
          var K = new MessageChannel(),
            Z = K.port2;
          (K.port1.onmessage = W),
            ($ = function () {
              Z.postMessage(null);
            });
        } else
          $ = function () {
            _(W, 0);
          };
        function Y(G) {
          (P = G), D || ((D = !0), $());
        }
        function re(G, te) {
          U = _(function () {
            G(n.unstable_now());
          }, te);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (G) {
            G.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            x || y || ((x = !0), Y(R));
          }),
          (n.unstable_forceFrameRate = function (G) {
            0 > G || 125 < G
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (O = 0 < G ? Math.floor(1e3 / G) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(u);
          }),
          (n.unstable_next = function (G) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var te = 3;
                break;
              default:
                te = g;
            }
            var F = g;
            g = te;
            try {
              return G();
            } finally {
              g = F;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (G, te) {
            switch (G) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                G = 3;
            }
            var F = g;
            g = G;
            try {
              return te();
            } finally {
              g = F;
            }
          }),
          (n.unstable_scheduleCallback = function (G, te, F) {
            var V = n.unstable_now();
            switch (
              (typeof F == "object" && F !== null
                ? ((F = F.delay),
                  (F = typeof F == "number" && 0 < F ? V + F : V))
                : (F = V),
              G)
            ) {
              case 1:
                var ne = -1;
                break;
              case 2:
                ne = 250;
                break;
              case 5:
                ne = 1073741823;
                break;
              case 4:
                ne = 1e4;
                break;
              default:
                ne = 5e3;
            }
            return (
              (ne = F + ne),
              (G = {
                id: d++,
                callback: te,
                priorityLevel: G,
                startTime: F,
                expirationTime: ne,
                sortIndex: -1,
              }),
              F > V
                ? ((G.sortIndex = F),
                  e(c, G),
                  t(u) === null &&
                    G === t(c) &&
                    (S ? (w(U), (U = -1)) : (S = !0), re(A, F - V)))
                : ((G.sortIndex = ne), e(u, G), x || y || ((x = !0), Y(R))),
              G
            );
          }),
          (n.unstable_shouldYield = H),
          (n.unstable_wrapCallback = function (G) {
            var te = g;
            return function () {
              var F = g;
              g = te;
              try {
                return G.apply(this, arguments);
              } finally {
                g = F;
              }
            };
          });
      })(r_)),
    r_
  );
}
var qb;
function G3() {
  return qb || ((qb = 1), (n_.exports = W3())), n_.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Kb;
function j3() {
  if (Kb) return Uo;
  Kb = 1;
  var n = Nh(),
    e = G3();
  function t(l) {
    for (
      var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + l,
        v = 1;
      v < arguments.length;
      v++
    )
      f += "&args[]=" + encodeURIComponent(arguments[v]);
    return (
      "Minified React error #" +
      l +
      "; visit " +
      f +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var r = new Set(),
    i = {};
  function o(l, f) {
    s(l, f), s(l + "Capture", f);
  }
  function s(l, f) {
    for (i[l] = f, l = 0; l < f.length; l++) r.add(f[l]);
  }
  var a = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    u = Object.prototype.hasOwnProperty,
    c =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    d = {},
    m = {};
  function g(l) {
    return u.call(m, l)
      ? !0
      : u.call(d, l)
      ? !1
      : c.test(l)
      ? (m[l] = !0)
      : ((d[l] = !0), !1);
  }
  function y(l, f, v, E) {
    if (v !== null && v.type === 0) return !1;
    switch (typeof f) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return E
          ? !1
          : v !== null
          ? !v.acceptsBooleans
          : ((l = l.toLowerCase().slice(0, 5)), l !== "data-" && l !== "aria-");
      default:
        return !1;
    }
  }
  function x(l, f, v, E) {
    if (f === null || typeof f > "u" || y(l, f, v, E)) return !0;
    if (E) return !1;
    if (v !== null)
      switch (v.type) {
        case 3:
          return !f;
        case 4:
          return f === !1;
        case 5:
          return isNaN(f);
        case 6:
          return isNaN(f) || 1 > f;
      }
    return !1;
  }
  function S(l, f, v, E, I, N, q) {
    (this.acceptsBooleans = f === 2 || f === 3 || f === 4),
      (this.attributeName = E),
      (this.attributeNamespace = I),
      (this.mustUseProperty = v),
      (this.propertyName = l),
      (this.type = f),
      (this.sanitizeURL = N),
      (this.removeEmptyString = q);
  }
  var _ = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (l) {
      _[l] = new S(l, 0, !1, l, null, !1, !1);
    }),
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (l) {
      var f = l[0];
      _[f] = new S(f, 1, !1, l[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (
      l
    ) {
      _[l] = new S(l, 2, !1, l.toLowerCase(), null, !1, !1);
    }),
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (l) {
      _[l] = new S(l, 2, !1, l, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (l) {
        _[l] = new S(l, 3, !1, l.toLowerCase(), null, !1, !1);
      }),
    ["checked", "multiple", "muted", "selected"].forEach(function (l) {
      _[l] = new S(l, 3, !0, l, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (l) {
      _[l] = new S(l, 4, !1, l, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (l) {
      _[l] = new S(l, 6, !1, l, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (l) {
      _[l] = new S(l, 5, !1, l.toLowerCase(), null, !1, !1);
    });
  var w = /[\-:]([a-z])/g;
  function T(l) {
    return l[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (l) {
      var f = l.replace(w, T);
      _[f] = new S(f, 1, !1, l, null, !1, !1);
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (l) {
        var f = l.replace(w, T);
        _[f] = new S(f, 1, !1, l, "http://www.w3.org/1999/xlink", !1, !1);
      }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (l) {
      var f = l.replace(w, T);
      _[f] = new S(f, 1, !1, l, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (l) {
      _[l] = new S(l, 1, !1, l.toLowerCase(), null, !1, !1);
    }),
    (_.xlinkHref = new S(
      "xlinkHref",
      1,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    )),
    ["src", "href", "action", "formAction"].forEach(function (l) {
      _[l] = new S(l, 1, !1, l.toLowerCase(), null, !0, !0);
    });
  function M(l, f, v, E) {
    var I = _.hasOwnProperty(f) ? _[f] : null;
    (I !== null
      ? I.type !== 0
      : E ||
        !(2 < f.length) ||
        (f[0] !== "o" && f[0] !== "O") ||
        (f[1] !== "n" && f[1] !== "N")) &&
      (x(f, v, I, E) && (v = null),
      E || I === null
        ? g(f) &&
          (v === null ? l.removeAttribute(f) : l.setAttribute(f, "" + v))
        : I.mustUseProperty
        ? (l[I.propertyName] = v === null ? (I.type === 3 ? !1 : "") : v)
        : ((f = I.attributeName),
          (E = I.attributeNamespace),
          v === null
            ? l.removeAttribute(f)
            : ((I = I.type),
              (v = I === 3 || (I === 4 && v === !0) ? "" : "" + v),
              E ? l.setAttributeNS(E, f, v) : l.setAttribute(f, v))));
  }
  var A = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    R = Symbol.for("react.element"),
    D = Symbol.for("react.portal"),
    P = Symbol.for("react.fragment"),
    U = Symbol.for("react.strict_mode"),
    O = Symbol.for("react.profiler"),
    L = Symbol.for("react.provider"),
    H = Symbol.for("react.context"),
    W = Symbol.for("react.forward_ref"),
    $ = Symbol.for("react.suspense"),
    K = Symbol.for("react.suspense_list"),
    Z = Symbol.for("react.memo"),
    Y = Symbol.for("react.lazy"),
    re = Symbol.for("react.offscreen"),
    G = Symbol.iterator;
  function te(l) {
    return l === null || typeof l != "object"
      ? null
      : ((l = (G && l[G]) || l["@@iterator"]),
        typeof l == "function" ? l : null);
  }
  var F = Object.assign,
    V;
  function ne(l) {
    if (V === void 0)
      try {
        throw Error();
      } catch (v) {
        var f = v.stack.trim().match(/\n( *(at )?)/);
        V = (f && f[1]) || "";
      }
    return (
      `
` +
      V +
      l
    );
  }
  var ae = !1;
  function J(l, f) {
    if (!l || ae) return "";
    ae = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (f)
        if (
          ((f = function () {
            throw Error();
          }),
          Object.defineProperty(f.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(f, []);
          } catch (je) {
            var E = je;
          }
          Reflect.construct(l, [], f);
        } else {
          try {
            f.call();
          } catch (je) {
            E = je;
          }
          l.call(f.prototype);
        }
      else {
        try {
          throw Error();
        } catch (je) {
          E = je;
        }
        l();
      }
    } catch (je) {
      if (je && E && typeof je.stack == "string") {
        for (
          var I = je.stack.split(`
`),
            N = E.stack.split(`
`),
            q = I.length - 1,
            pe = N.length - 1;
          1 <= q && 0 <= pe && I[q] !== N[pe];

        )
          pe--;
        for (; 1 <= q && 0 <= pe; q--, pe--)
          if (I[q] !== N[pe]) {
            if (q !== 1 || pe !== 1)
              do
                if ((q--, pe--, 0 > pe || I[q] !== N[pe])) {
                  var ye =
                    `
` + I[q].replace(" at new ", " at ");
                  return (
                    l.displayName &&
                      ye.includes("<anonymous>") &&
                      (ye = ye.replace("<anonymous>", l.displayName)),
                    ye
                  );
                }
              while (1 <= q && 0 <= pe);
            break;
          }
      }
    } finally {
      (ae = !1), (Error.prepareStackTrace = v);
    }
    return (l = l ? l.displayName || l.name : "") ? ne(l) : "";
  }
  function se(l) {
    switch (l.tag) {
      case 5:
        return ne(l.type);
      case 16:
        return ne("Lazy");
      case 13:
        return ne("Suspense");
      case 19:
        return ne("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (l = J(l.type, !1)), l;
      case 11:
        return (l = J(l.type.render, !1)), l;
      case 1:
        return (l = J(l.type, !0)), l;
      default:
        return "";
    }
  }
  function de(l) {
    if (l == null) return null;
    if (typeof l == "function") return l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case P:
        return "Fragment";
      case D:
        return "Portal";
      case O:
        return "Profiler";
      case U:
        return "StrictMode";
      case $:
        return "Suspense";
      case K:
        return "SuspenseList";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case H:
          return (l.displayName || "Context") + ".Consumer";
        case L:
          return (l._context.displayName || "Context") + ".Provider";
        case W:
          var f = l.render;
          return (
            (l = l.displayName),
            l ||
              ((l = f.displayName || f.name || ""),
              (l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef")),
            l
          );
        case Z:
          return (
            (f = l.displayName || null), f !== null ? f : de(l.type) || "Memo"
          );
        case Y:
          (f = l._payload), (l = l._init);
          try {
            return de(l(f));
          } catch {}
      }
    return null;
  }
  function le(l) {
    var f = l.type;
    switch (l.tag) {
      case 24:
        return "Cache";
      case 9:
        return (f.displayName || "Context") + ".Consumer";
      case 10:
        return (f._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (l = f.render),
          (l = l.displayName || l.name || ""),
          f.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return f;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return de(f);
      case 8:
        return f === U ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof f == "function") return f.displayName || f.name || null;
        if (typeof f == "string") return f;
    }
    return null;
  }
  function fe(l) {
    switch (typeof l) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return l;
      case "object":
        return l;
      default:
        return "";
    }
  }
  function Me(l) {
    var f = l.type;
    return (
      (l = l.nodeName) &&
      l.toLowerCase() === "input" &&
      (f === "checkbox" || f === "radio")
    );
  }
  function ge(l) {
    var f = Me(l) ? "checked" : "value",
      v = Object.getOwnPropertyDescriptor(l.constructor.prototype, f),
      E = "" + l[f];
    if (
      !l.hasOwnProperty(f) &&
      typeof v < "u" &&
      typeof v.get == "function" &&
      typeof v.set == "function"
    ) {
      var I = v.get,
        N = v.set;
      return (
        Object.defineProperty(l, f, {
          configurable: !0,
          get: function () {
            return I.call(this);
          },
          set: function (q) {
            (E = "" + q), N.call(this, q);
          },
        }),
        Object.defineProperty(l, f, { enumerable: v.enumerable }),
        {
          getValue: function () {
            return E;
          },
          setValue: function (q) {
            E = "" + q;
          },
          stopTracking: function () {
            (l._valueTracker = null), delete l[f];
          },
        }
      );
    }
  }
  function xe(l) {
    l._valueTracker || (l._valueTracker = ge(l));
  }
  function j(l) {
    if (!l) return !1;
    var f = l._valueTracker;
    if (!f) return !0;
    var v = f.getValue(),
      E = "";
    return (
      l && (E = Me(l) ? (l.checked ? "true" : "false") : l.value),
      (l = E),
      l !== v ? (f.setValue(l), !0) : !1
    );
  }
  function we(l) {
    if (
      ((l = l || (typeof document < "u" ? document : void 0)), typeof l > "u")
    )
      return null;
    try {
      return l.activeElement || l.body;
    } catch {
      return l.body;
    }
  }
  function Ae(l, f) {
    var v = f.checked;
    return F({}, f, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: v ?? l._wrapperState.initialChecked,
    });
  }
  function Oe(l, f) {
    var v = f.defaultValue == null ? "" : f.defaultValue,
      E = f.checked != null ? f.checked : f.defaultChecked;
    (v = fe(f.value != null ? f.value : v)),
      (l._wrapperState = {
        initialChecked: E,
        initialValue: v,
        controlled:
          f.type === "checkbox" || f.type === "radio"
            ? f.checked != null
            : f.value != null,
      });
  }
  function Ie(l, f) {
    (f = f.checked), f != null && M(l, "checked", f, !1);
  }
  function rt(l, f) {
    Ie(l, f);
    var v = fe(f.value),
      E = f.type;
    if (v != null)
      E === "number"
        ? ((v === 0 && l.value === "") || l.value != v) && (l.value = "" + v)
        : l.value !== "" + v && (l.value = "" + v);
    else if (E === "submit" || E === "reset") {
      l.removeAttribute("value");
      return;
    }
    f.hasOwnProperty("value")
      ? Xe(l, f.type, v)
      : f.hasOwnProperty("defaultValue") && Xe(l, f.type, fe(f.defaultValue)),
      f.checked == null &&
        f.defaultChecked != null &&
        (l.defaultChecked = !!f.defaultChecked);
  }
  function De(l, f, v) {
    if (f.hasOwnProperty("value") || f.hasOwnProperty("defaultValue")) {
      var E = f.type;
      if (
        !(
          (E !== "submit" && E !== "reset") ||
          (f.value !== void 0 && f.value !== null)
        )
      )
        return;
      (f = "" + l._wrapperState.initialValue),
        v || f === l.value || (l.value = f),
        (l.defaultValue = f);
    }
    (v = l.name),
      v !== "" && (l.name = ""),
      (l.defaultChecked = !!l._wrapperState.initialChecked),
      v !== "" && (l.name = v);
  }
  function Xe(l, f, v) {
    (f !== "number" || we(l.ownerDocument) !== l) &&
      (v == null
        ? (l.defaultValue = "" + l._wrapperState.initialValue)
        : l.defaultValue !== "" + v && (l.defaultValue = "" + v));
  }
  var ee = Array.isArray;
  function B(l, f, v, E) {
    if (((l = l.options), f)) {
      f = {};
      for (var I = 0; I < v.length; I++) f["$" + v[I]] = !0;
      for (v = 0; v < l.length; v++)
        (I = f.hasOwnProperty("$" + l[v].value)),
          l[v].selected !== I && (l[v].selected = I),
          I && E && (l[v].defaultSelected = !0);
    } else {
      for (v = "" + fe(v), f = null, I = 0; I < l.length; I++) {
        if (l[I].value === v) {
          (l[I].selected = !0), E && (l[I].defaultSelected = !0);
          return;
        }
        f !== null || l[I].disabled || (f = l[I]);
      }
      f !== null && (f.selected = !0);
    }
  }
  function ve(l, f) {
    if (f.dangerouslySetInnerHTML != null) throw Error(t(91));
    return F({}, f, {
      value: void 0,
      defaultValue: void 0,
      children: "" + l._wrapperState.initialValue,
    });
  }
  function Se(l, f) {
    var v = f.value;
    if (v == null) {
      if (((v = f.children), (f = f.defaultValue), v != null)) {
        if (f != null) throw Error(t(92));
        if (ee(v)) {
          if (1 < v.length) throw Error(t(93));
          v = v[0];
        }
        f = v;
      }
      f == null && (f = ""), (v = f);
    }
    l._wrapperState = { initialValue: fe(v) };
  }
  function _e(l, f) {
    var v = fe(f.value),
      E = fe(f.defaultValue);
    v != null &&
      ((v = "" + v),
      v !== l.value && (l.value = v),
      f.defaultValue == null && l.defaultValue !== v && (l.defaultValue = v)),
      E != null && (l.defaultValue = "" + E);
  }
  function Te(l) {
    var f = l.textContent;
    f === l._wrapperState.initialValue &&
      f !== "" &&
      f !== null &&
      (l.value = f);
  }
  function at(l) {
    switch (l) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Fe(l, f) {
    return l == null || l === "http://www.w3.org/1999/xhtml"
      ? at(f)
      : l === "http://www.w3.org/2000/svg" && f === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : l;
  }
  var Be,
    Ge = (function (l) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (f, v, E, I) {
            MSApp.execUnsafeLocalFunction(function () {
              return l(f, v, E, I);
            });
          }
        : l;
    })(function (l, f) {
      if (l.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in l)
        l.innerHTML = f;
      else {
        for (
          Be = Be || document.createElement("div"),
            Be.innerHTML = "<svg>" + f.valueOf().toString() + "</svg>",
            f = Be.firstChild;
          l.firstChild;

        )
          l.removeChild(l.firstChild);
        for (; f.firstChild; ) l.appendChild(f.firstChild);
      }
    });
  function Ye(l, f) {
    if (f) {
      var v = l.firstChild;
      if (v && v === l.lastChild && v.nodeType === 3) {
        v.nodeValue = f;
        return;
      }
    }
    l.textContent = f;
  }
  var nt = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    xt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(nt).forEach(function (l) {
    xt.forEach(function (f) {
      (f = f + l.charAt(0).toUpperCase() + l.substring(1)), (nt[f] = nt[l]);
    });
  });
  function $e(l, f, v) {
    return f == null || typeof f == "boolean" || f === ""
      ? ""
      : v || typeof f != "number" || f === 0 || (nt.hasOwnProperty(l) && nt[l])
      ? ("" + f).trim()
      : f + "px";
  }
  function qe(l, f) {
    l = l.style;
    for (var v in f)
      if (f.hasOwnProperty(v)) {
        var E = v.indexOf("--") === 0,
          I = $e(v, f[v], E);
        v === "float" && (v = "cssFloat"), E ? l.setProperty(v, I) : (l[v] = I);
      }
  }
  var et = F(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    }
  );
  function he(l, f) {
    if (f) {
      if (et[l] && (f.children != null || f.dangerouslySetInnerHTML != null))
        throw Error(t(137, l));
      if (f.dangerouslySetInnerHTML != null) {
        if (f.children != null) throw Error(t(60));
        if (
          typeof f.dangerouslySetInnerHTML != "object" ||
          !("__html" in f.dangerouslySetInnerHTML)
        )
          throw Error(t(61));
      }
      if (f.style != null && typeof f.style != "object") throw Error(t(62));
    }
  }
  function Je(l, f) {
    if (l.indexOf("-") === -1) return typeof f.is == "string";
    switch (l) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var me = null;
  function Ve(l) {
    return (
      (l = l.target || l.srcElement || window),
      l.correspondingUseElement && (l = l.correspondingUseElement),
      l.nodeType === 3 ? l.parentNode : l
    );
  }
  var Re = null,
    Ue = null,
    it = null;
  function mt(l) {
    if ((l = Xs(l))) {
      if (typeof Re != "function") throw Error(t(280));
      var f = l.stateNode;
      f && ((f = ud(f)), Re(l.stateNode, l.type, f));
    }
  }
  function gt(l) {
    Ue ? (it ? it.push(l) : (it = [l])) : (Ue = l);
  }
  function Nt() {
    if (Ue) {
      var l = Ue,
        f = it;
      if (((it = Ue = null), mt(l), f)) for (l = 0; l < f.length; l++) mt(f[l]);
    }
  }
  function Ut(l, f) {
    return l(f);
  }
  function ht() {}
  var $t = !1;
  function un(l, f, v) {
    if ($t) return l(f, v);
    $t = !0;
    try {
      return Ut(l, f, v);
    } finally {
      ($t = !1), (Ue !== null || it !== null) && (ht(), Nt());
    }
  }
  function bn(l, f) {
    var v = l.stateNode;
    if (v === null) return null;
    var E = ud(v);
    if (E === null) return null;
    v = E[f];
    e: switch (f) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (E = !E.disabled) ||
          ((l = l.type),
          (E = !(
            l === "button" ||
            l === "input" ||
            l === "select" ||
            l === "textarea"
          ))),
          (l = !E);
        break e;
      default:
        l = !1;
    }
    if (l) return null;
    if (v && typeof v != "function") throw Error(t(231, f, typeof v));
    return v;
  }
  var yn = !1;
  if (a)
    try {
      var cr = {};
      Object.defineProperty(cr, "passive", {
        get: function () {
          yn = !0;
        },
      }),
        window.addEventListener("test", cr, cr),
        window.removeEventListener("test", cr, cr);
    } catch {
      yn = !1;
    }
  function Hi(l, f, v, E, I, N, q, pe, ye) {
    var je = Array.prototype.slice.call(arguments, 3);
    try {
      f.apply(v, je);
    } catch (st) {
      this.onError(st);
    }
  }
  var yr = !1,
    Fr = null,
    Ar = !1,
    Br = null,
    xr = {
      onError: function (l) {
        (yr = !0), (Fr = l);
      },
    };
  function So(l, f, v, E, I, N, q, pe, ye) {
    (yr = !1), (Fr = null), Hi.apply(xr, arguments);
  }
  function ql(l, f, v, E, I, N, q, pe, ye) {
    if ((So.apply(this, arguments), yr)) {
      if (yr) {
        var je = Fr;
        (yr = !1), (Fr = null);
      } else throw Error(t(198));
      Ar || ((Ar = !0), (Br = je));
    }
  }
  function oo(l) {
    var f = l,
      v = l;
    if (l.alternate) for (; f.return; ) f = f.return;
    else {
      l = f;
      do (f = l), (f.flags & 4098) !== 0 && (v = f.return), (l = f.return);
      while (l);
    }
    return f.tag === 3 ? v : null;
  }
  function Kl(l) {
    if (l.tag === 13) {
      var f = l.memoizedState;
      if (
        (f === null && ((l = l.alternate), l !== null && (f = l.memoizedState)),
        f !== null)
      )
        return f.dehydrated;
    }
    return null;
  }
  function ie(l) {
    if (oo(l) !== l) throw Error(t(188));
  }
  function Ce(l) {
    var f = l.alternate;
    if (!f) {
      if (((f = oo(l)), f === null)) throw Error(t(188));
      return f !== l ? null : l;
    }
    for (var v = l, E = f; ; ) {
      var I = v.return;
      if (I === null) break;
      var N = I.alternate;
      if (N === null) {
        if (((E = I.return), E !== null)) {
          v = E;
          continue;
        }
        break;
      }
      if (I.child === N.child) {
        for (N = I.child; N; ) {
          if (N === v) return ie(I), l;
          if (N === E) return ie(I), f;
          N = N.sibling;
        }
        throw Error(t(188));
      }
      if (v.return !== E.return) (v = I), (E = N);
      else {
        for (var q = !1, pe = I.child; pe; ) {
          if (pe === v) {
            (q = !0), (v = I), (E = N);
            break;
          }
          if (pe === E) {
            (q = !0), (E = I), (v = N);
            break;
          }
          pe = pe.sibling;
        }
        if (!q) {
          for (pe = N.child; pe; ) {
            if (pe === v) {
              (q = !0), (v = N), (E = I);
              break;
            }
            if (pe === E) {
              (q = !0), (E = N), (v = I);
              break;
            }
            pe = pe.sibling;
          }
          if (!q) throw Error(t(189));
        }
      }
      if (v.alternate !== E) throw Error(t(190));
    }
    if (v.tag !== 3) throw Error(t(188));
    return v.stateNode.current === v ? l : f;
  }
  function ze(l) {
    return (l = Ce(l)), l !== null ? We(l) : null;
  }
  function We(l) {
    if (l.tag === 5 || l.tag === 6) return l;
    for (l = l.child; l !== null; ) {
      var f = We(l);
      if (f !== null) return f;
      l = l.sibling;
    }
    return null;
  }
  var Le = e.unstable_scheduleCallback,
    ut = e.unstable_cancelCallback,
    yt = e.unstable_shouldYield,
    Et = e.unstable_requestPaint,
    Ke = e.unstable_now,
    kt = e.unstable_getCurrentPriorityLevel,
    Ft = e.unstable_ImmediatePriority,
    At = e.unstable_UserBlockingPriority,
    tn = e.unstable_NormalPriority,
    An = e.unstable_LowPriority,
    pn = e.unstable_IdlePriority,
    Mn = null,
    wt = null;
  function dt(l) {
    if (wt && typeof wt.onCommitFiberRoot == "function")
      try {
        wt.onCommitFiberRoot(Mn, l, void 0, (l.current.flags & 128) === 128);
      } catch {}
  }
  var Jt = Math.clz32 ? Math.clz32 : ii,
    zt = Math.log,
    En = Math.LN2;
  function ii(l) {
    return (l >>>= 0), l === 0 ? 32 : (31 - ((zt(l) / En) | 0)) | 0;
  }
  var Rn = 64,
    jn = 4194304;
  function cn(l) {
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return l & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return l;
    }
  }
  function zr(l, f) {
    var v = l.pendingLanes;
    if (v === 0) return 0;
    var E = 0,
      I = l.suspendedLanes,
      N = l.pingedLanes,
      q = v & 268435455;
    if (q !== 0) {
      var pe = q & ~I;
      pe !== 0 ? (E = cn(pe)) : ((N &= q), N !== 0 && (E = cn(N)));
    } else (q = v & ~I), q !== 0 ? (E = cn(q)) : N !== 0 && (E = cn(N));
    if (E === 0) return 0;
    if (
      f !== 0 &&
      f !== E &&
      (f & I) === 0 &&
      ((I = E & -E), (N = f & -f), I >= N || (I === 16 && (N & 4194240) !== 0))
    )
      return f;
    if (((E & 4) !== 0 && (E |= v & 16), (f = l.entangledLanes), f !== 0))
      for (l = l.entanglements, f &= E; 0 < f; )
        (v = 31 - Jt(f)), (I = 1 << v), (E |= l[v]), (f &= ~I);
    return E;
  }
  function ds(l, f) {
    switch (l) {
      case 1:
      case 2:
      case 4:
        return f + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function fr(l, f) {
    for (
      var v = l.suspendedLanes,
        E = l.pingedLanes,
        I = l.expirationTimes,
        N = l.pendingLanes;
      0 < N;

    ) {
      var q = 31 - Jt(N),
        pe = 1 << q,
        ye = I[q];
      ye === -1
        ? ((pe & v) === 0 || (pe & E) !== 0) && (I[q] = ds(pe, f))
        : ye <= f && (l.expiredLanes |= pe),
        (N &= ~pe);
    }
  }
  function Rr(l) {
    return (
      (l = l.pendingLanes & -1073741825),
      l !== 0 ? l : l & 1073741824 ? 1073741824 : 0
    );
  }
  function pi() {
    var l = Rn;
    return (Rn <<= 1), (Rn & 4194240) === 0 && (Rn = 64), l;
  }
  function Wo(l) {
    for (var f = [], v = 0; 31 > v; v++) f.push(l);
    return f;
  }
  function Go(l, f, v) {
    (l.pendingLanes |= f),
      f !== 536870912 && ((l.suspendedLanes = 0), (l.pingedLanes = 0)),
      (l = l.eventTimes),
      (f = 31 - Jt(f)),
      (l[f] = v);
  }
  function Uf(l, f) {
    var v = l.pendingLanes & ~f;
    (l.pendingLanes = f),
      (l.suspendedLanes = 0),
      (l.pingedLanes = 0),
      (l.expiredLanes &= f),
      (l.mutableReadLanes &= f),
      (l.entangledLanes &= f),
      (f = l.entanglements);
    var E = l.eventTimes;
    for (l = l.expirationTimes; 0 < v; ) {
      var I = 31 - Jt(v),
        N = 1 << I;
      (f[I] = 0), (E[I] = -1), (l[I] = -1), (v &= ~N);
    }
  }
  function jo(l, f) {
    var v = (l.entangledLanes |= f);
    for (l = l.entanglements; v; ) {
      var E = 31 - Jt(v),
        I = 1 << E;
      (I & f) | (l[E] & f) && (l[E] |= f), (v &= ~I);
    }
  }
  var ln = 0;
  function hs(l) {
    return (
      (l &= -l),
      1 < l ? (4 < l ? ((l & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
    );
  }
  var ya,
    Zl,
    Jl,
    ps,
    rl,
    wo = !1,
    $o = [],
    oi = null,
    Xt = null,
    bo = null,
    so = new Map(),
    ms = new Map(),
    Mo = [],
    Ff =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
  function qn(l, f) {
    switch (l) {
      case "focusin":
      case "focusout":
        oi = null;
        break;
      case "dragenter":
      case "dragleave":
        Xt = null;
        break;
      case "mouseover":
      case "mouseout":
        bo = null;
        break;
      case "pointerover":
      case "pointerout":
        so.delete(f.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        ms.delete(f.pointerId);
    }
  }
  function Xo(l, f, v, E, I, N) {
    return l === null || l.nativeEvent !== N
      ? ((l = {
          blockedOn: f,
          domEventName: v,
          eventSystemFlags: E,
          nativeEvent: N,
          targetContainers: [I],
        }),
        f !== null && ((f = Xs(f)), f !== null && Zl(f)),
        l)
      : ((l.eventSystemFlags |= E),
        (f = l.targetContainers),
        I !== null && f.indexOf(I) === -1 && f.push(I),
        l);
  }
  function Bf(l, f, v, E, I) {
    switch (f) {
      case "focusin":
        return (oi = Xo(oi, l, f, v, E, I)), !0;
      case "dragenter":
        return (Xt = Xo(Xt, l, f, v, E, I)), !0;
      case "mouseover":
        return (bo = Xo(bo, l, f, v, E, I)), !0;
      case "pointerover":
        var N = I.pointerId;
        return so.set(N, Xo(so.get(N) || null, l, f, v, E, I)), !0;
      case "gotpointercapture":
        return (
          (N = I.pointerId), ms.set(N, Xo(ms.get(N) || null, l, f, v, E, I)), !0
        );
    }
    return !1;
  }
  function mi(l) {
    var f = Pa(l.target);
    if (f !== null) {
      var v = oo(f);
      if (v !== null) {
        if (((f = v.tag), f === 13)) {
          if (((f = Kl(v)), f !== null)) {
            (l.blockedOn = f),
              rl(l.priority, function () {
                Jl(v);
              });
            return;
          }
        } else if (f === 3 && v.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = v.tag === 3 ? v.stateNode.containerInfo : null;
          return;
        }
      }
    }
    l.blockedOn = null;
  }
  function xa(l) {
    if (l.blockedOn !== null) return !1;
    for (var f = l.targetContainers; 0 < f.length; ) {
      var v = gi(l.domEventName, l.eventSystemFlags, f[0], l.nativeEvent);
      if (v === null) {
        v = l.nativeEvent;
        var E = new v.constructor(v.type, v);
        (me = E), v.target.dispatchEvent(E), (me = null);
      } else return (f = Xs(v)), f !== null && Zl(f), (l.blockedOn = v), !1;
      f.shift();
    }
    return !0;
  }
  function _a(l, f, v) {
    xa(l) && v.delete(f);
  }
  function ao() {
    (wo = !1),
      oi !== null && xa(oi) && (oi = null),
      Xt !== null && xa(Xt) && (Xt = null),
      bo !== null && xa(bo) && (bo = null),
      so.forEach(_a),
      ms.forEach(_a);
  }
  function Ns(l, f) {
    l.blockedOn === f &&
      ((l.blockedOn = null),
      wo ||
        ((wo = !0),
        e.unstable_scheduleCallback(e.unstable_NormalPriority, ao)));
  }
  function Sa(l) {
    function f(I) {
      return Ns(I, l);
    }
    if (0 < $o.length) {
      Ns($o[0], l);
      for (var v = 1; v < $o.length; v++) {
        var E = $o[v];
        E.blockedOn === l && (E.blockedOn = null);
      }
    }
    for (
      oi !== null && Ns(oi, l),
        Xt !== null && Ns(Xt, l),
        bo !== null && Ns(bo, l),
        so.forEach(f),
        ms.forEach(f),
        v = 0;
      v < Mo.length;
      v++
    )
      (E = Mo[v]), E.blockedOn === l && (E.blockedOn = null);
    for (; 0 < Mo.length && ((v = Mo[0]), v.blockedOn === null); )
      mi(v), v.blockedOn === null && Mo.shift();
  }
  var Hr = A.ReactCurrentBatchConfig,
    Vr = !0;
  function gs(l, f, v, E) {
    var I = ln,
      N = Hr.transition;
    Hr.transition = null;
    try {
      (ln = 1), il(l, f, v, E);
    } finally {
      (ln = I), (Hr.transition = N);
    }
  }
  function Eo(l, f, v, E) {
    var I = ln,
      N = Hr.transition;
    Hr.transition = null;
    try {
      (ln = 4), il(l, f, v, E);
    } finally {
      (ln = I), (Hr.transition = N);
    }
  }
  function il(l, f, v, E) {
    if (Vr) {
      var I = gi(l, f, v, E);
      if (I === null) rd(l, f, E, wa, v), qn(l, E);
      else if (Bf(I, l, f, v, E)) E.stopPropagation();
      else if ((qn(l, E), f & 4 && -1 < Ff.indexOf(l))) {
        for (; I !== null; ) {
          var N = Xs(I);
          if (
            (N !== null && ya(N),
            (N = gi(l, f, v, E)),
            N === null && rd(l, f, E, wa, v),
            N === I)
          )
            break;
          I = N;
        }
        I !== null && E.stopPropagation();
      } else rd(l, f, E, null, v);
    }
  }
  var wa = null;
  function gi(l, f, v, E) {
    if (((wa = null), (l = Ve(E)), (l = Pa(l)), l !== null))
      if (((f = oo(l)), f === null)) l = null;
      else if (((v = f.tag), v === 13)) {
        if (((l = Kl(f)), l !== null)) return l;
        l = null;
      } else if (v === 3) {
        if (f.stateNode.current.memoizedState.isDehydrated)
          return f.tag === 3 ? f.stateNode.containerInfo : null;
        l = null;
      } else f !== l && (l = null);
    return (wa = l), null;
  }
  function ba(l) {
    switch (l) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (kt()) {
          case Ft:
            return 1;
          case At:
            return 4;
          case tn:
          case An:
            return 16;
          case pn:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Vi = null,
    Us = null,
    Wr = null;
  function Pr() {
    if (Wr) return Wr;
    var l,
      f = Us,
      v = f.length,
      E,
      I = "value" in Vi ? Vi.value : Vi.textContent,
      N = I.length;
    for (l = 0; l < v && f[l] === I[l]; l++);
    var q = v - l;
    for (E = 1; E <= q && f[v - E] === I[N - E]; E++);
    return (Wr = I.slice(l, 1 < E ? 1 - E : void 0));
  }
  function Fs(l) {
    var f = l.keyCode;
    return (
      "charCode" in l
        ? ((l = l.charCode), l === 0 && f === 13 && (l = 13))
        : (l = f),
      l === 10 && (l = 13),
      32 <= l || l === 13 ? l : 0
    );
  }
  function Wi() {
    return !0;
  }
  function Bs() {
    return !1;
  }
  function Gr(l) {
    function f(v, E, I, N, q) {
      (this._reactName = v),
        (this._targetInst = I),
        (this.type = E),
        (this.nativeEvent = N),
        (this.target = q),
        (this.currentTarget = null);
      for (var pe in l)
        l.hasOwnProperty(pe) && ((v = l[pe]), (this[pe] = v ? v(N) : N[pe]));
      return (
        (this.isDefaultPrevented = (
          N.defaultPrevented != null ? N.defaultPrevented : N.returnValue === !1
        )
          ? Wi
          : Bs),
        (this.isPropagationStopped = Bs),
        this
      );
    }
    return (
      F(f.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var v = this.nativeEvent;
          v &&
            (v.preventDefault
              ? v.preventDefault()
              : typeof v.returnValue != "unknown" && (v.returnValue = !1),
            (this.isDefaultPrevented = Wi));
        },
        stopPropagation: function () {
          var v = this.nativeEvent;
          v &&
            (v.stopPropagation
              ? v.stopPropagation()
              : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0),
            (this.isPropagationStopped = Wi));
        },
        persist: function () {},
        isPersistent: Wi,
      }),
      f
    );
  }
  var zs = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (l) {
        return l.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    _r = Gr(zs),
    Ir = F({}, zs, { view: 0, detail: 0 }),
    dr = Gr(Ir),
    tr,
    bi,
    To,
    Ql = F({}, Ir, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Ea,
      button: 0,
      buttons: 0,
      relatedTarget: function (l) {
        return l.relatedTarget === void 0
          ? l.fromElement === l.srcElement
            ? l.toElement
            : l.fromElement
          : l.relatedTarget;
      },
      movementX: function (l) {
        return "movementX" in l
          ? l.movementX
          : (l !== To &&
              (To && l.type === "mousemove"
                ? ((tr = l.screenX - To.screenX), (bi = l.screenY - To.screenY))
                : (bi = tr = 0),
              (To = l)),
            tr);
      },
      movementY: function (l) {
        return "movementY" in l ? l.movementY : bi;
      },
    }),
    Xh = Gr(Ql),
    Hs = F({}, Ql, { dataTransfer: 0 }),
    Ma = Gr(Hs),
    zf = F({}, Ir, { relatedTarget: 0 }),
    Hf = Gr(zf),
    Vf = F({}, zs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    _g = Gr(Vf),
    Sg = F({}, zs, {
      clipboardData: function (l) {
        return "clipboardData" in l ? l.clipboardData : window.clipboardData;
      },
    }),
    Yh = Gr(Sg),
    Wf = F({}, zs, { data: 0 }),
    qh = Gr(Wf),
    wg = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    bg = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    Kh = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function eu(l) {
    var f = this.nativeEvent;
    return f.getModifierState
      ? f.getModifierState(l)
      : (l = Kh[l])
      ? !!f[l]
      : !1;
  }
  function Ea() {
    return eu;
  }
  var Gf = F({}, Ir, {
      key: function (l) {
        if (l.key) {
          var f = wg[l.key] || l.key;
          if (f !== "Unidentified") return f;
        }
        return l.type === "keypress"
          ? ((l = Fs(l)), l === 13 ? "Enter" : String.fromCharCode(l))
          : l.type === "keydown" || l.type === "keyup"
          ? bg[l.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Ea,
      charCode: function (l) {
        return l.type === "keypress" ? Fs(l) : 0;
      },
      keyCode: function (l) {
        return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
      },
      which: function (l) {
        return l.type === "keypress"
          ? Fs(l)
          : l.type === "keydown" || l.type === "keyup"
          ? l.keyCode
          : 0;
      },
    }),
    jf = Gr(Gf),
    Co = F({}, Ql, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    lo = Gr(Co),
    ol = F({}, Ir, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Ea,
    }),
    Vs = Gr(ol),
    Ws = F({}, zs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    sl = Gr(Ws),
    Mg = F({}, Ql, {
      deltaX: function (l) {
        return "deltaX" in l
          ? l.deltaX
          : "wheelDeltaX" in l
          ? -l.wheelDeltaX
          : 0;
      },
      deltaY: function (l) {
        return "deltaY" in l
          ? l.deltaY
          : "wheelDeltaY" in l
          ? -l.wheelDeltaY
          : "wheelDelta" in l
          ? -l.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    Zh = Gr(Mg),
    Jh = [9, 13, 27, 32],
    Mi = a && "CompositionEvent" in window,
    si = null;
  a && "documentMode" in document && (si = document.documentMode);
  var Kn = a && "TextEvent" in window && !si,
    tu = a && (!Mi || (si && 8 < si && 11 >= si)),
    Ao = " ",
    Qh = !1;
  function ep(l, f) {
    switch (l) {
      case "keyup":
        return Jh.indexOf(f.keyCode) !== -1;
      case "keydown":
        return f.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function $f(l) {
    return (l = l.detail), typeof l == "object" && "data" in l ? l.data : null;
  }
  var Ta = !1;
  function Eg(l, f) {
    switch (l) {
      case "compositionend":
        return $f(f);
      case "keypress":
        return f.which !== 32 ? null : ((Qh = !0), Ao);
      case "textInput":
        return (l = f.data), l === Ao && Qh ? null : l;
      default:
        return null;
    }
  }
  function ic(l, f) {
    if (Ta)
      return l === "compositionend" || (!Mi && ep(l, f))
        ? ((l = Pr()), (Wr = Us = Vi = null), (Ta = !1), l)
        : null;
    switch (l) {
      case "paste":
        return null;
      case "keypress":
        if (!(f.ctrlKey || f.altKey || f.metaKey) || (f.ctrlKey && f.altKey)) {
          if (f.char && 1 < f.char.length) return f.char;
          if (f.which) return String.fromCharCode(f.which);
        }
        return null;
      case "compositionend":
        return tu && f.locale !== "ko" ? null : f.data;
      default:
        return null;
    }
  }
  var nu = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function Xf(l) {
    var f = l && l.nodeName && l.nodeName.toLowerCase();
    return f === "input" ? !!nu[l.type] : f === "textarea";
  }
  function ru(l, f, v, E) {
    gt(E),
      (f = id(f, "onChange")),
      0 < f.length &&
        ((v = new _r("onChange", "change", null, v, E)),
        l.push({ event: v, listeners: f }));
  }
  var Ca = null,
    iu = null;
  function Tg(l) {
    lu(l, 0);
  }
  function Gs(l) {
    var f = hr(l);
    if (j(f)) return l;
  }
  function Cg(l, f) {
    if (l === "change") return f;
  }
  var ou = !1;
  if (a) {
    var Gi;
    if (a) {
      var al = "oninput" in document;
      if (!al) {
        var ll = document.createElement("div");
        ll.setAttribute("oninput", "return;"),
          (al = typeof ll.oninput == "function");
      }
      Gi = al;
    } else Gi = !1;
    ou = Gi && (!document.documentMode || 9 < document.documentMode);
  }
  function Yo() {
    Ca && (Ca.detachEvent("onpropertychange", Yf), (iu = Ca = null));
  }
  function Yf(l) {
    if (l.propertyName === "value" && Gs(iu)) {
      var f = [];
      ru(f, iu, l, Ve(l)), un(Tg, f);
    }
  }
  function su(l, f, v) {
    l === "focusin"
      ? (Yo(), (Ca = f), (iu = v), Ca.attachEvent("onpropertychange", Yf))
      : l === "focusout" && Yo();
  }
  function Ag(l) {
    if (l === "selectionchange" || l === "keyup" || l === "keydown")
      return Gs(iu);
  }
  function tp(l, f) {
    if (l === "click") return Gs(f);
  }
  function nr(l, f) {
    if (l === "input" || l === "change") return Gs(f);
  }
  function qf(l, f) {
    return (l === f && (l !== 0 || 1 / l === 1 / f)) || (l !== l && f !== f);
  }
  var uo = typeof Object.is == "function" ? Object.is : qf;
  function ul(l, f) {
    if (uo(l, f)) return !0;
    if (
      typeof l != "object" ||
      l === null ||
      typeof f != "object" ||
      f === null
    )
      return !1;
    var v = Object.keys(l),
      E = Object.keys(f);
    if (v.length !== E.length) return !1;
    for (E = 0; E < v.length; E++) {
      var I = v[E];
      if (!u.call(f, I) || !uo(l[I], f[I])) return !1;
    }
    return !0;
  }
  function oc(l) {
    for (; l && l.firstChild; ) l = l.firstChild;
    return l;
  }
  function co(l, f) {
    var v = oc(l);
    l = 0;
    for (var E; v; ) {
      if (v.nodeType === 3) {
        if (((E = l + v.textContent.length), l <= f && E >= f))
          return { node: v, offset: f - l };
        l = E;
      }
      e: {
        for (; v; ) {
          if (v.nextSibling) {
            v = v.nextSibling;
            break e;
          }
          v = v.parentNode;
        }
        v = void 0;
      }
      v = oc(v);
    }
  }
  function cl(l, f) {
    return l && f
      ? l === f
        ? !0
        : l && l.nodeType === 3
        ? !1
        : f && f.nodeType === 3
        ? cl(l, f.parentNode)
        : "contains" in l
        ? l.contains(f)
        : l.compareDocumentPosition
        ? !!(l.compareDocumentPosition(f) & 16)
        : !1
      : !1;
  }
  function rr() {
    for (var l = window, f = we(); f instanceof l.HTMLIFrameElement; ) {
      try {
        var v = typeof f.contentWindow.location.href == "string";
      } catch {
        v = !1;
      }
      if (v) l = f.contentWindow;
      else break;
      f = we(l.document);
    }
    return f;
  }
  function jr(l) {
    var f = l && l.nodeName && l.nodeName.toLowerCase();
    return (
      f &&
      ((f === "input" &&
        (l.type === "text" ||
          l.type === "search" ||
          l.type === "tel" ||
          l.type === "url" ||
          l.type === "password")) ||
        f === "textarea" ||
        l.contentEditable === "true")
    );
  }
  function $r(l) {
    var f = rr(),
      v = l.focusedElem,
      E = l.selectionRange;
    if (
      f !== v &&
      v &&
      v.ownerDocument &&
      cl(v.ownerDocument.documentElement, v)
    ) {
      if (E !== null && jr(v)) {
        if (
          ((f = E.start),
          (l = E.end),
          l === void 0 && (l = f),
          "selectionStart" in v)
        )
          (v.selectionStart = f),
            (v.selectionEnd = Math.min(l, v.value.length));
        else if (
          ((l = ((f = v.ownerDocument || document) && f.defaultView) || window),
          l.getSelection)
        ) {
          l = l.getSelection();
          var I = v.textContent.length,
            N = Math.min(E.start, I);
          (E = E.end === void 0 ? N : Math.min(E.end, I)),
            !l.extend && N > E && ((I = E), (E = N), (N = I)),
            (I = co(v, N));
          var q = co(v, E);
          I &&
            q &&
            (l.rangeCount !== 1 ||
              l.anchorNode !== I.node ||
              l.anchorOffset !== I.offset ||
              l.focusNode !== q.node ||
              l.focusOffset !== q.offset) &&
            ((f = f.createRange()),
            f.setStart(I.node, I.offset),
            l.removeAllRanges(),
            N > E
              ? (l.addRange(f), l.extend(q.node, q.offset))
              : (f.setEnd(q.node, q.offset), l.addRange(f)));
        }
      }
      for (f = [], l = v; (l = l.parentNode); )
        l.nodeType === 1 &&
          f.push({ element: l, left: l.scrollLeft, top: l.scrollTop });
      for (typeof v.focus == "function" && v.focus(), v = 0; v < f.length; v++)
        (l = f[v]),
          (l.element.scrollLeft = l.left),
          (l.element.scrollTop = l.top);
    }
  }
  var Kf = a && "documentMode" in document && 11 >= document.documentMode,
    vs = null,
    fl = null,
    sc = null,
    Xr = !1;
  function Zf(l, f, v) {
    var E =
      v.window === v ? v.document : v.nodeType === 9 ? v : v.ownerDocument;
    Xr ||
      vs == null ||
      vs !== we(E) ||
      ((E = vs),
      "selectionStart" in E && jr(E)
        ? (E = { start: E.selectionStart, end: E.selectionEnd })
        : ((E = (
            (E.ownerDocument && E.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (E = {
            anchorNode: E.anchorNode,
            anchorOffset: E.anchorOffset,
            focusNode: E.focusNode,
            focusOffset: E.focusOffset,
          })),
      (sc && ul(sc, E)) ||
        ((sc = E),
        (E = id(fl, "onSelect")),
        0 < E.length &&
          ((f = new _r("onSelect", "select", null, f, v)),
          l.push({ event: f, listeners: E }),
          (f.target = vs))));
  }
  function au(l, f) {
    var v = {};
    return (
      (v[l.toLowerCase()] = f.toLowerCase()),
      (v["Webkit" + l] = "webkit" + f),
      (v["Moz" + l] = "moz" + f),
      v
    );
  }
  var Aa = {
      animationend: au("Animation", "AnimationEnd"),
      animationiteration: au("Animation", "AnimationIteration"),
      animationstart: au("Animation", "AnimationStart"),
      transitionend: au("Transition", "TransitionEnd"),
    },
    qo = {},
    Ko = {};
  a &&
    ((Ko = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete Aa.animationend.animation,
      delete Aa.animationiteration.animation,
      delete Aa.animationstart.animation),
    "TransitionEvent" in window || delete Aa.transitionend.transition);
  function ys(l) {
    if (qo[l]) return qo[l];
    if (!Aa[l]) return l;
    var f = Aa[l],
      v;
    for (v in f) if (f.hasOwnProperty(v) && v in Ko) return (qo[l] = f[v]);
    return l;
  }
  var ac = ys("animationend"),
    lc = ys("animationiteration"),
    np = ys("animationstart"),
    rp = ys("transitionend"),
    ip = new Map(),
    op =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  function js(l, f) {
    ip.set(l, f), o(f, [l]);
  }
  for (var Jf = 0; Jf < op.length; Jf++) {
    var uc = op[Jf],
      cc = uc.toLowerCase(),
      Rg = uc[0].toUpperCase() + uc.slice(1);
    js(cc, "on" + Rg);
  }
  js(ac, "onAnimationEnd"),
    js(lc, "onAnimationIteration"),
    js(np, "onAnimationStart"),
    js("dblclick", "onDoubleClick"),
    js("focusin", "onFocus"),
    js("focusout", "onBlur"),
    js(rp, "onTransitionEnd"),
    s("onMouseEnter", ["mouseout", "mouseover"]),
    s("onMouseLeave", ["mouseout", "mouseover"]),
    s("onPointerEnter", ["pointerout", "pointerover"]),
    s("onPointerLeave", ["pointerout", "pointerover"]),
    o(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    o(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    o(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var Ra =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    Qf = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(Ra)
    );
  function ed(l, f, v) {
    var E = l.type || "unknown-event";
    (l.currentTarget = v), ql(E, f, void 0, l), (l.currentTarget = null);
  }
  function lu(l, f) {
    f = (f & 4) !== 0;
    for (var v = 0; v < l.length; v++) {
      var E = l[v],
        I = E.event;
      E = E.listeners;
      e: {
        var N = void 0;
        if (f)
          for (var q = E.length - 1; 0 <= q; q--) {
            var pe = E[q],
              ye = pe.instance,
              je = pe.currentTarget;
            if (((pe = pe.listener), ye !== N && I.isPropagationStopped()))
              break e;
            ed(I, pe, je), (N = ye);
          }
        else
          for (q = 0; q < E.length; q++) {
            if (
              ((pe = E[q]),
              (ye = pe.instance),
              (je = pe.currentTarget),
              (pe = pe.listener),
              ye !== N && I.isPropagationStopped())
            )
              break e;
            ed(I, pe, je), (N = ye);
          }
      }
    }
    if (Ar) throw ((l = Br), (Ar = !1), (Br = null), l);
  }
  function zn(l, f) {
    var v = f[pl];
    v === void 0 && (v = f[pl] = new Set());
    var E = l + "__bubble";
    v.has(E) || (nd(f, l, 2, !1), v.add(E));
  }
  function td(l, f, v) {
    var E = 0;
    f && (E |= 4), nd(v, l, E, f);
  }
  var fc = "_reactListening" + Math.random().toString(36).slice(2);
  function uu(l) {
    if (!l[fc]) {
      (l[fc] = !0),
        r.forEach(function (v) {
          v !== "selectionchange" && (Qf.has(v) || td(v, !1, l), td(v, !0, l));
        });
      var f = l.nodeType === 9 ? l : l.ownerDocument;
      f === null || f[fc] || ((f[fc] = !0), td("selectionchange", !1, f));
    }
  }
  function nd(l, f, v, E) {
    switch (ba(f)) {
      case 1:
        var I = gs;
        break;
      case 4:
        I = Eo;
        break;
      default:
        I = il;
    }
    (v = I.bind(null, f, v, l)),
      (I = void 0),
      !yn ||
        (f !== "touchstart" && f !== "touchmove" && f !== "wheel") ||
        (I = !0),
      E
        ? I !== void 0
          ? l.addEventListener(f, v, { capture: !0, passive: I })
          : l.addEventListener(f, v, !0)
        : I !== void 0
        ? l.addEventListener(f, v, { passive: I })
        : l.addEventListener(f, v, !1);
  }
  function rd(l, f, v, E, I) {
    var N = E;
    if ((f & 1) === 0 && (f & 2) === 0 && E !== null)
      e: for (;;) {
        if (E === null) return;
        var q = E.tag;
        if (q === 3 || q === 4) {
          var pe = E.stateNode.containerInfo;
          if (pe === I || (pe.nodeType === 8 && pe.parentNode === I)) break;
          if (q === 4)
            for (q = E.return; q !== null; ) {
              var ye = q.tag;
              if (
                (ye === 3 || ye === 4) &&
                ((ye = q.stateNode.containerInfo),
                ye === I || (ye.nodeType === 8 && ye.parentNode === I))
              )
                return;
              q = q.return;
            }
          for (; pe !== null; ) {
            if (((q = Pa(pe)), q === null)) return;
            if (((ye = q.tag), ye === 5 || ye === 6)) {
              E = N = q;
              continue e;
            }
            pe = pe.parentNode;
          }
        }
        E = E.return;
      }
    un(function () {
      var je = N,
        st = Ve(v),
        lt = [];
      e: {
        var ot = ip.get(l);
        if (ot !== void 0) {
          var Mt = _r,
            Rt = l;
          switch (l) {
            case "keypress":
              if (Fs(v) === 0) break e;
            case "keydown":
            case "keyup":
              Mt = jf;
              break;
            case "focusin":
              (Rt = "focus"), (Mt = Hf);
              break;
            case "focusout":
              (Rt = "blur"), (Mt = Hf);
              break;
            case "beforeblur":
            case "afterblur":
              Mt = Hf;
              break;
            case "click":
              if (v.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Mt = Xh;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Mt = Ma;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Mt = Vs;
              break;
            case ac:
            case lc:
            case np:
              Mt = _g;
              break;
            case rp:
              Mt = sl;
              break;
            case "scroll":
              Mt = dr;
              break;
            case "wheel":
              Mt = Zh;
              break;
            case "copy":
            case "cut":
            case "paste":
              Mt = Yh;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Mt = lo;
          }
          var Dt = (f & 4) !== 0,
            kr = !Dt && l === "scroll",
            ke = Dt ? (ot !== null ? ot + "Capture" : null) : ot;
          Dt = [];
          for (var be = je, Ne; be !== null; ) {
            Ne = be;
            var ft = Ne.stateNode;
            if (
              (Ne.tag === 5 &&
                ft !== null &&
                ((Ne = ft),
                ke !== null &&
                  ((ft = bn(be, ke)), ft != null && Dt.push(cu(be, ft, Ne)))),
              kr)
            )
              break;
            be = be.return;
          }
          0 < Dt.length &&
            ((ot = new Mt(ot, Rt, null, v, st)),
            lt.push({ event: ot, listeners: Dt }));
        }
      }
      if ((f & 7) === 0) {
        e: {
          if (
            ((ot = l === "mouseover" || l === "pointerover"),
            (Mt = l === "mouseout" || l === "pointerout"),
            ot &&
              v !== me &&
              (Rt = v.relatedTarget || v.fromElement) &&
              (Pa(Rt) || Rt[fo]))
          )
            break e;
          if (
            (Mt || ot) &&
            ((ot =
              st.window === st
                ? st
                : (ot = st.ownerDocument)
                ? ot.defaultView || ot.parentWindow
                : window),
            Mt
              ? ((Rt = v.relatedTarget || v.toElement),
                (Mt = je),
                (Rt = Rt ? Pa(Rt) : null),
                Rt !== null &&
                  ((kr = oo(Rt)),
                  Rt !== kr || (Rt.tag !== 5 && Rt.tag !== 6)) &&
                  (Rt = null))
              : ((Mt = null), (Rt = je)),
            Mt !== Rt)
          ) {
            if (
              ((Dt = Xh),
              (ft = "onMouseLeave"),
              (ke = "onMouseEnter"),
              (be = "mouse"),
              (l === "pointerout" || l === "pointerover") &&
                ((Dt = lo),
                (ft = "onPointerLeave"),
                (ke = "onPointerEnter"),
                (be = "pointer")),
              (kr = Mt == null ? ot : hr(Mt)),
              (Ne = Rt == null ? ot : hr(Rt)),
              (ot = new Dt(ft, be + "leave", Mt, v, st)),
              (ot.target = kr),
              (ot.relatedTarget = Ne),
              (ft = null),
              Pa(st) === je &&
                ((Dt = new Dt(ke, be + "enter", Rt, v, st)),
                (Dt.target = Ne),
                (Dt.relatedTarget = kr),
                (ft = Dt)),
              (kr = ft),
              Mt && Rt)
            )
              t: {
                for (Dt = Mt, ke = Rt, be = 0, Ne = Dt; Ne; Ne = dl(Ne)) be++;
                for (Ne = 0, ft = ke; ft; ft = dl(ft)) Ne++;
                for (; 0 < be - Ne; ) (Dt = dl(Dt)), be--;
                for (; 0 < Ne - be; ) (ke = dl(ke)), Ne--;
                for (; be--; ) {
                  if (Dt === ke || (ke !== null && Dt === ke.alternate))
                    break t;
                  (Dt = dl(Dt)), (ke = dl(ke));
                }
                Dt = null;
              }
            else Dt = null;
            Mt !== null && Pg(lt, ot, Mt, Dt, !1),
              Rt !== null && kr !== null && Pg(lt, kr, Rt, Dt, !0);
          }
        }
        e: {
          if (
            ((ot = je ? hr(je) : window),
            (Mt = ot.nodeName && ot.nodeName.toLowerCase()),
            Mt === "select" || (Mt === "input" && ot.type === "file"))
          )
            var Ot = Cg;
          else if (Xf(ot))
            if (ou) Ot = nr;
            else {
              Ot = Ag;
              var Ht = su;
            }
          else
            (Mt = ot.nodeName) &&
              Mt.toLowerCase() === "input" &&
              (ot.type === "checkbox" || ot.type === "radio") &&
              (Ot = tp);
          if (Ot && (Ot = Ot(l, je))) {
            ru(lt, Ot, v, st);
            break e;
          }
          Ht && Ht(l, ot, je),
            l === "focusout" &&
              (Ht = ot._wrapperState) &&
              Ht.controlled &&
              ot.type === "number" &&
              Xe(ot, "number", ot.value);
        }
        switch (((Ht = je ? hr(je) : window), l)) {
          case "focusin":
            (Xf(Ht) || Ht.contentEditable === "true") &&
              ((vs = Ht), (fl = je), (sc = null));
            break;
          case "focusout":
            sc = fl = vs = null;
            break;
          case "mousedown":
            Xr = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (Xr = !1), Zf(lt, v, st);
            break;
          case "selectionchange":
            if (Kf) break;
          case "keydown":
          case "keyup":
            Zf(lt, v, st);
        }
        var Vt;
        if (Mi)
          e: {
            switch (l) {
              case "compositionstart":
                var qt = "onCompositionStart";
                break e;
              case "compositionend":
                qt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                qt = "onCompositionUpdate";
                break e;
            }
            qt = void 0;
          }
        else
          Ta
            ? ep(l, v) && (qt = "onCompositionEnd")
            : l === "keydown" &&
              v.keyCode === 229 &&
              (qt = "onCompositionStart");
        qt &&
          (tu &&
            v.locale !== "ko" &&
            (Ta || qt !== "onCompositionStart"
              ? qt === "onCompositionEnd" && Ta && (Vt = Pr())
              : ((Vi = st),
                (Us = "value" in Vi ? Vi.value : Vi.textContent),
                (Ta = !0))),
          (Ht = id(je, qt)),
          0 < Ht.length &&
            ((qt = new qh(qt, l, null, v, st)),
            lt.push({ event: qt, listeners: Ht }),
            Vt
              ? (qt.data = Vt)
              : ((Vt = $f(v)), Vt !== null && (qt.data = Vt)))),
          (Vt = Kn ? Eg(l, v) : ic(l, v)) &&
            ((je = id(je, "onBeforeInput")),
            0 < je.length &&
              ((st = new qh("onBeforeInput", "beforeinput", null, v, st)),
              lt.push({ event: st, listeners: je }),
              (st.data = Vt)));
      }
      lu(lt, f);
    });
  }
  function cu(l, f, v) {
    return { instance: l, listener: f, currentTarget: v };
  }
  function id(l, f) {
    for (var v = f + "Capture", E = []; l !== null; ) {
      var I = l,
        N = I.stateNode;
      I.tag === 5 &&
        N !== null &&
        ((I = N),
        (N = bn(l, v)),
        N != null && E.unshift(cu(l, N, I)),
        (N = bn(l, f)),
        N != null && E.push(cu(l, N, I))),
        (l = l.return);
    }
    return E;
  }
  function dl(l) {
    if (l === null) return null;
    do l = l.return;
    while (l && l.tag !== 5);
    return l || null;
  }
  function Pg(l, f, v, E, I) {
    for (var N = f._reactName, q = []; v !== null && v !== E; ) {
      var pe = v,
        ye = pe.alternate,
        je = pe.stateNode;
      if (ye !== null && ye === E) break;
      pe.tag === 5 &&
        je !== null &&
        ((pe = je),
        I
          ? ((ye = bn(v, N)), ye != null && q.unshift(cu(v, ye, pe)))
          : I || ((ye = bn(v, N)), ye != null && q.push(cu(v, ye, pe)))),
        (v = v.return);
    }
    q.length !== 0 && l.push({ event: f, listeners: q });
  }
  var Tx = /\r\n?/g,
    Ig = /\u0000|\uFFFD/g;
  function sp(l) {
    return (typeof l == "string" ? l : "" + l)
      .replace(
        Tx,
        `
`
      )
      .replace(Ig, "");
  }
  function dc(l, f, v) {
    if (((f = sp(f)), sp(l) !== f && v)) throw Error(t(425));
  }
  function hc() {}
  var fu = null,
    ap = null;
  function lp(l, f) {
    return (
      l === "textarea" ||
      l === "noscript" ||
      typeof f.children == "string" ||
      typeof f.children == "number" ||
      (typeof f.dangerouslySetInnerHTML == "object" &&
        f.dangerouslySetInnerHTML !== null &&
        f.dangerouslySetInnerHTML.__html != null)
    );
  }
  var up = typeof setTimeout == "function" ? setTimeout : void 0,
    cp = typeof clearTimeout == "function" ? clearTimeout : void 0,
    od = typeof Promise == "function" ? Promise : void 0,
    Cx =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof od < "u"
        ? function (l) {
            return od.resolve(null).then(l).catch(Lg);
          }
        : up;
  function Lg(l) {
    setTimeout(function () {
      throw l;
    });
  }
  function sd(l, f) {
    var v = f,
      E = 0;
    do {
      var I = v.nextSibling;
      if ((l.removeChild(v), I && I.nodeType === 8))
        if (((v = I.data), v === "/$")) {
          if (E === 0) {
            l.removeChild(I), Sa(f);
            return;
          }
          E--;
        } else (v !== "$" && v !== "$?" && v !== "$!") || E++;
      v = I;
    } while (v);
    Sa(f);
  }
  function $s(l) {
    for (; l != null; l = l.nextSibling) {
      var f = l.nodeType;
      if (f === 1 || f === 3) break;
      if (f === 8) {
        if (((f = l.data), f === "$" || f === "$!" || f === "$?")) break;
        if (f === "/$") return null;
      }
    }
    return l;
  }
  function fp(l) {
    l = l.previousSibling;
    for (var f = 0; l; ) {
      if (l.nodeType === 8) {
        var v = l.data;
        if (v === "$" || v === "$!" || v === "$?") {
          if (f === 0) return l;
          f--;
        } else v === "/$" && f++;
      }
      l = l.previousSibling;
    }
    return null;
  }
  var hl = Math.random().toString(36).slice(2),
    Lr = "__reactFiber$" + hl,
    du = "__reactProps$" + hl,
    fo = "__reactContainer$" + hl,
    pl = "__reactEvents$" + hl,
    ad = "__reactListeners$" + hl,
    ld = "__reactHandles$" + hl;
  function Pa(l) {
    var f = l[Lr];
    if (f) return f;
    for (var v = l.parentNode; v; ) {
      if ((f = v[fo] || v[Lr])) {
        if (
          ((v = f.alternate),
          f.child !== null || (v !== null && v.child !== null))
        )
          for (l = fp(l); l !== null; ) {
            if ((v = l[Lr])) return v;
            l = fp(l);
          }
        return f;
      }
      (l = v), (v = l.parentNode);
    }
    return null;
  }
  function Xs(l) {
    return (
      (l = l[Lr] || l[fo]),
      !l || (l.tag !== 5 && l.tag !== 6 && l.tag !== 13 && l.tag !== 3)
        ? null
        : l
    );
  }
  function hr(l) {
    if (l.tag === 5 || l.tag === 6) return l.stateNode;
    throw Error(t(33));
  }
  function ud(l) {
    return l[du] || null;
  }
  var dp = [],
    Yr = -1;
  function or(l) {
    return { current: l };
  }
  function Hn(l) {
    0 > Yr || ((l.current = dp[Yr]), (dp[Yr] = null), Yr--);
  }
  function Nn(l, f) {
    Yr++, (dp[Yr] = l.current), (l.current = f);
  }
  var Ys = {},
    ai = or(Ys),
    Ei = or(!1),
    qs = Ys;
  function ml(l, f) {
    var v = l.type.contextTypes;
    if (!v) return Ys;
    var E = l.stateNode;
    if (E && E.__reactInternalMemoizedUnmaskedChildContext === f)
      return E.__reactInternalMemoizedMaskedChildContext;
    var I = {},
      N;
    for (N in v) I[N] = f[N];
    return (
      E &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = f),
        (l.__reactInternalMemoizedMaskedChildContext = I)),
      I
    );
  }
  function vi(l) {
    return (l = l.childContextTypes), l != null;
  }
  function pc() {
    Hn(Ei), Hn(ai);
  }
  function hp(l, f, v) {
    if (ai.current !== Ys) throw Error(t(168));
    Nn(ai, f), Nn(Ei, v);
  }
  function mc(l, f, v) {
    var E = l.stateNode;
    if (((f = f.childContextTypes), typeof E.getChildContext != "function"))
      return v;
    E = E.getChildContext();
    for (var I in E) if (!(I in f)) throw Error(t(108, le(l) || "Unknown", I));
    return F({}, v, E);
  }
  function gl(l) {
    return (
      (l =
        ((l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext) ||
        Ys),
      (qs = ai.current),
      Nn(ai, l),
      Nn(Ei, Ei.current),
      !0
    );
  }
  function pp(l, f, v) {
    var E = l.stateNode;
    if (!E) throw Error(t(169));
    v
      ? ((l = mc(l, f, qs)),
        (E.__reactInternalMemoizedMergedChildContext = l),
        Hn(Ei),
        Hn(ai),
        Nn(ai, l))
      : Hn(Ei),
      Nn(Ei, v);
  }
  var Zo = null,
    gc = !1,
    cd = !1;
  function vc(l) {
    Zo === null ? (Zo = [l]) : Zo.push(l);
  }
  function Dg(l) {
    (gc = !0), vc(l);
  }
  function xs() {
    if (!cd && Zo !== null) {
      cd = !0;
      var l = 0,
        f = ln;
      try {
        var v = Zo;
        for (ln = 1; l < v.length; l++) {
          var E = v[l];
          do E = E(!0);
          while (E !== null);
        }
        (Zo = null), (gc = !1);
      } catch (I) {
        throw (Zo !== null && (Zo = Zo.slice(l + 1)), Le(Ft, xs), I);
      } finally {
        (ln = f), (cd = !1);
      }
    }
    return null;
  }
  var vl = [],
    ji = 0,
    fd = null,
    dd = 0,
    Ti = [],
    qr = 0,
    yl = null,
    pt = 1,
    Ro = "";
  function Ks(l, f) {
    (vl[ji++] = dd), (vl[ji++] = fd), (fd = l), (dd = f);
  }
  function mp(l, f, v) {
    (Ti[qr++] = pt), (Ti[qr++] = Ro), (Ti[qr++] = yl), (yl = l);
    var E = pt;
    l = Ro;
    var I = 32 - Jt(E) - 1;
    (E &= ~(1 << I)), (v += 1);
    var N = 32 - Jt(f) + I;
    if (30 < N) {
      var q = I - (I % 5);
      (N = (E & ((1 << q) - 1)).toString(32)),
        (E >>= q),
        (I -= q),
        (pt = (1 << (32 - Jt(f) + I)) | (v << I) | E),
        (Ro = N + l);
    } else (pt = (1 << N) | (v << I) | E), (Ro = l);
  }
  function gp(l) {
    l.return !== null && (Ks(l, 1), mp(l, 1, 0));
  }
  function Zs(l) {
    for (; l === fd; )
      (fd = vl[--ji]), (vl[ji] = null), (dd = vl[--ji]), (vl[ji] = null);
    for (; l === yl; )
      (yl = Ti[--qr]),
        (Ti[qr] = null),
        (Ro = Ti[--qr]),
        (Ti[qr] = null),
        (pt = Ti[--qr]),
        (Ti[qr] = null);
  }
  var li = null,
    Ci = null,
    $n = !1,
    Po = null;
  function vp(l, f) {
    var v = Es(5, null, null, 0);
    (v.elementType = "DELETED"),
      (v.stateNode = f),
      (v.return = l),
      (f = l.deletions),
      f === null ? ((l.deletions = [v]), (l.flags |= 16)) : f.push(v);
  }
  function yp(l, f) {
    switch (l.tag) {
      case 5:
        var v = l.type;
        return (
          (f =
            f.nodeType !== 1 || v.toLowerCase() !== f.nodeName.toLowerCase()
              ? null
              : f),
          f !== null
            ? ((l.stateNode = f), (li = l), (Ci = $s(f.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (f = l.pendingProps === "" || f.nodeType !== 3 ? null : f),
          f !== null ? ((l.stateNode = f), (li = l), (Ci = null), !0) : !1
        );
      case 13:
        return (
          (f = f.nodeType !== 8 ? null : f),
          f !== null
            ? ((v = yl !== null ? { id: pt, overflow: Ro } : null),
              (l.memoizedState = {
                dehydrated: f,
                treeContext: v,
                retryLane: 1073741824,
              }),
              (v = Es(18, null, null, 0)),
              (v.stateNode = f),
              (v.return = l),
              (l.child = v),
              (li = l),
              (Ci = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function hd(l) {
    return (l.mode & 1) !== 0 && (l.flags & 128) === 0;
  }
  function pd(l) {
    if ($n) {
      var f = Ci;
      if (f) {
        var v = f;
        if (!yp(l, f)) {
          if (hd(l)) throw Error(t(418));
          f = $s(v.nextSibling);
          var E = li;
          f && yp(l, f)
            ? vp(E, v)
            : ((l.flags = (l.flags & -4097) | 2), ($n = !1), (li = l));
        }
      } else {
        if (hd(l)) throw Error(t(418));
        (l.flags = (l.flags & -4097) | 2), ($n = !1), (li = l);
      }
    }
  }
  function md(l) {
    for (
      l = l.return;
      l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13;

    )
      l = l.return;
    li = l;
  }
  function hu(l) {
    if (l !== li) return !1;
    if (!$n) return md(l), ($n = !0), !1;
    var f;
    if (
      ((f = l.tag !== 3) &&
        !(f = l.tag !== 5) &&
        ((f = l.type),
        (f = f !== "head" && f !== "body" && !lp(l.type, l.memoizedProps))),
      f && (f = Ci))
    ) {
      if (hd(l)) throw (xp(), Error(t(418)));
      for (; f; ) vp(l, f), (f = $s(f.nextSibling));
    }
    if ((md(l), l.tag === 13)) {
      if (((l = l.memoizedState), (l = l !== null ? l.dehydrated : null), !l))
        throw Error(t(317));
      e: {
        for (l = l.nextSibling, f = 0; l; ) {
          if (l.nodeType === 8) {
            var v = l.data;
            if (v === "/$") {
              if (f === 0) {
                Ci = $s(l.nextSibling);
                break e;
              }
              f--;
            } else (v !== "$" && v !== "$!" && v !== "$?") || f++;
          }
          l = l.nextSibling;
        }
        Ci = null;
      }
    } else Ci = li ? $s(l.stateNode.nextSibling) : null;
    return !0;
  }
  function xp() {
    for (var l = Ci; l; ) l = $s(l.nextSibling);
  }
  function Ia() {
    (Ci = li = null), ($n = !1);
  }
  function pu(l) {
    Po === null ? (Po = [l]) : Po.push(l);
  }
  var Ax = A.ReactCurrentBatchConfig;
  function Jo(l, f) {
    if (l && l.defaultProps) {
      (f = F({}, f)), (l = l.defaultProps);
      for (var v in l) f[v] === void 0 && (f[v] = l[v]);
      return f;
    }
    return f;
  }
  var yc = or(null),
    xc = null,
    xl = null,
    gd = null;
  function mu() {
    gd = xl = xc = null;
  }
  function gu(l) {
    var f = yc.current;
    Hn(yc), (l._currentValue = f);
  }
  function vu(l, f, v) {
    for (; l !== null; ) {
      var E = l.alternate;
      if (
        ((l.childLanes & f) !== f
          ? ((l.childLanes |= f), E !== null && (E.childLanes |= f))
          : E !== null && (E.childLanes & f) !== f && (E.childLanes |= f),
        l === v)
      )
        break;
      l = l.return;
    }
  }
  function Js(l, f) {
    (xc = l),
      (gd = xl = null),
      (l = l.dependencies),
      l !== null &&
        l.firstContext !== null &&
        ((l.lanes & f) !== 0 && (bt = !0), (l.firstContext = null));
  }
  function Ai(l) {
    var f = l._currentValue;
    if (gd !== l)
      if (((l = { context: l, memoizedValue: f, next: null }), xl === null)) {
        if (xc === null) throw Error(t(308));
        (xl = l), (xc.dependencies = { lanes: 0, firstContext: l });
      } else xl = xl.next = l;
    return f;
  }
  var Qo = null;
  function _c(l) {
    Qo === null ? (Qo = [l]) : Qo.push(l);
  }
  function vd(l, f, v, E) {
    var I = f.interleaved;
    return (
      I === null ? ((v.next = v), _c(f)) : ((v.next = I.next), (I.next = v)),
      (f.interleaved = v),
      es(l, E)
    );
  }
  function es(l, f) {
    l.lanes |= f;
    var v = l.alternate;
    for (v !== null && (v.lanes |= f), v = l, l = l.return; l !== null; )
      (l.childLanes |= f),
        (v = l.alternate),
        v !== null && (v.childLanes |= f),
        (v = l),
        (l = l.return);
    return v.tag === 3 ? v.stateNode : null;
  }
  var Qs = !1;
  function Sc(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function kg(l, f) {
    (l = l.updateQueue),
      f.updateQueue === l &&
        (f.updateQueue = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          effects: l.effects,
        });
  }
  function Io(l, f) {
    return {
      eventTime: l,
      lane: f,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function _s(l, f, v) {
    var E = l.updateQueue;
    if (E === null) return null;
    if (((E = E.shared), (xn & 2) !== 0)) {
      var I = E.pending;
      return (
        I === null ? (f.next = f) : ((f.next = I.next), (I.next = f)),
        (E.pending = f),
        es(l, v)
      );
    }
    return (
      (I = E.interleaved),
      I === null ? ((f.next = f), _c(E)) : ((f.next = I.next), (I.next = f)),
      (E.interleaved = f),
      es(l, v)
    );
  }
  function Zn(l, f, v) {
    if (
      ((f = f.updateQueue), f !== null && ((f = f.shared), (v & 4194240) !== 0))
    ) {
      var E = f.lanes;
      (E &= l.pendingLanes), (v |= E), (f.lanes = v), jo(l, v);
    }
  }
  function nn(l, f) {
    var v = l.updateQueue,
      E = l.alternate;
    if (E !== null && ((E = E.updateQueue), v === E)) {
      var I = null,
        N = null;
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var q = {
            eventTime: v.eventTime,
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null,
          };
          N === null ? (I = N = q) : (N = N.next = q), (v = v.next);
        } while (v !== null);
        N === null ? (I = N = f) : (N = N.next = f);
      } else I = N = f;
      (v = {
        baseState: E.baseState,
        firstBaseUpdate: I,
        lastBaseUpdate: N,
        shared: E.shared,
        effects: E.effects,
      }),
        (l.updateQueue = v);
      return;
    }
    (l = v.lastBaseUpdate),
      l === null ? (v.firstBaseUpdate = f) : (l.next = f),
      (v.lastBaseUpdate = f);
  }
  function ir(l, f, v, E) {
    var I = l.updateQueue;
    Qs = !1;
    var N = I.firstBaseUpdate,
      q = I.lastBaseUpdate,
      pe = I.shared.pending;
    if (pe !== null) {
      I.shared.pending = null;
      var ye = pe,
        je = ye.next;
      (ye.next = null), q === null ? (N = je) : (q.next = je), (q = ye);
      var st = l.alternate;
      st !== null &&
        ((st = st.updateQueue),
        (pe = st.lastBaseUpdate),
        pe !== q &&
          (pe === null ? (st.firstBaseUpdate = je) : (pe.next = je),
          (st.lastBaseUpdate = ye)));
    }
    if (N !== null) {
      var lt = I.baseState;
      (q = 0), (st = je = ye = null), (pe = N);
      do {
        var ot = pe.lane,
          Mt = pe.eventTime;
        if ((E & ot) === ot) {
          st !== null &&
            (st = st.next =
              {
                eventTime: Mt,
                lane: 0,
                tag: pe.tag,
                payload: pe.payload,
                callback: pe.callback,
                next: null,
              });
          e: {
            var Rt = l,
              Dt = pe;
            switch (((ot = f), (Mt = v), Dt.tag)) {
              case 1:
                if (((Rt = Dt.payload), typeof Rt == "function")) {
                  lt = Rt.call(Mt, lt, ot);
                  break e;
                }
                lt = Rt;
                break e;
              case 3:
                Rt.flags = (Rt.flags & -65537) | 128;
              case 0:
                if (
                  ((Rt = Dt.payload),
                  (ot = typeof Rt == "function" ? Rt.call(Mt, lt, ot) : Rt),
                  ot == null)
                )
                  break e;
                lt = F({}, lt, ot);
                break e;
              case 2:
                Qs = !0;
            }
          }
          pe.callback !== null &&
            pe.lane !== 0 &&
            ((l.flags |= 64),
            (ot = I.effects),
            ot === null ? (I.effects = [pe]) : ot.push(pe));
        } else
          (Mt = {
            eventTime: Mt,
            lane: ot,
            tag: pe.tag,
            payload: pe.payload,
            callback: pe.callback,
            next: null,
          }),
            st === null ? ((je = st = Mt), (ye = lt)) : (st = st.next = Mt),
            (q |= ot);
        if (((pe = pe.next), pe === null)) {
          if (((pe = I.shared.pending), pe === null)) break;
          (ot = pe),
            (pe = ot.next),
            (ot.next = null),
            (I.lastBaseUpdate = ot),
            (I.shared.pending = null);
        }
      } while (!0);
      if (
        (st === null && (ye = lt),
        (I.baseState = ye),
        (I.firstBaseUpdate = je),
        (I.lastBaseUpdate = st),
        (f = I.shared.interleaved),
        f !== null)
      ) {
        I = f;
        do (q |= I.lane), (I = I.next);
        while (I !== f);
      } else N === null && (I.shared.lanes = 0);
      (Ac |= q), (l.lanes = q), (l.memoizedState = lt);
    }
  }
  function pr(l, f, v) {
    if (((l = f.effects), (f.effects = null), l !== null))
      for (f = 0; f < l.length; f++) {
        var E = l[f],
          I = E.callback;
        if (I !== null) {
          if (((E.callback = null), (E = v), typeof I != "function"))
            throw Error(t(191, I));
          I.call(E);
        }
      }
  }
  var Kr = new n.Component().refs;
  function Ri(l, f, v, E) {
    (f = l.memoizedState),
      (v = v(E, f)),
      (v = v == null ? f : F({}, f, v)),
      (l.memoizedState = v),
      l.lanes === 0 && (l.updateQueue.baseState = v);
  }
  var ea = {
    isMounted: function (l) {
      return (l = l._reactInternals) ? oo(l) === l : !1;
    },
    enqueueSetState: function (l, f, v) {
      l = l._reactInternals;
      var E = go(),
        I = Au(l),
        N = Io(E, I);
      (N.payload = f),
        v != null && (N.callback = v),
        (f = _s(l, N, I)),
        f !== null && (ia(f, l, I, E), Zn(f, l, I));
    },
    enqueueReplaceState: function (l, f, v) {
      l = l._reactInternals;
      var E = go(),
        I = Au(l),
        N = Io(E, I);
      (N.tag = 1),
        (N.payload = f),
        v != null && (N.callback = v),
        (f = _s(l, N, I)),
        f !== null && (ia(f, l, I, E), Zn(f, l, I));
    },
    enqueueForceUpdate: function (l, f) {
      l = l._reactInternals;
      var v = go(),
        E = Au(l),
        I = Io(v, E);
      (I.tag = 2),
        f != null && (I.callback = f),
        (f = _s(l, I, E)),
        f !== null && (ia(f, l, E, v), Zn(f, l, E));
    },
  };
  function Sr(l, f, v, E, I, N, q) {
    return (
      (l = l.stateNode),
      typeof l.shouldComponentUpdate == "function"
        ? l.shouldComponentUpdate(E, N, q)
        : f.prototype && f.prototype.isPureReactComponent
        ? !ul(v, E) || !ul(I, N)
        : !0
    );
  }
  function yu(l, f, v) {
    var E = !1,
      I = Ys,
      N = f.contextType;
    return (
      typeof N == "object" && N !== null
        ? (N = Ai(N))
        : ((I = vi(f) ? qs : ai.current),
          (E = f.contextTypes),
          (N = (E = E != null) ? ml(l, I) : Ys)),
      (f = new f(v, N)),
      (l.memoizedState =
        f.state !== null && f.state !== void 0 ? f.state : null),
      (f.updater = ea),
      (l.stateNode = f),
      (f._reactInternals = l),
      E &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = I),
        (l.__reactInternalMemoizedMaskedChildContext = N)),
      f
    );
  }
  function _l(l, f, v, E) {
    (l = f.state),
      typeof f.componentWillReceiveProps == "function" &&
        f.componentWillReceiveProps(v, E),
      typeof f.UNSAFE_componentWillReceiveProps == "function" &&
        f.UNSAFE_componentWillReceiveProps(v, E),
      f.state !== l && ea.enqueueReplaceState(f, f.state, null);
  }
  function xu(l, f, v, E) {
    var I = l.stateNode;
    (I.props = v), (I.state = l.memoizedState), (I.refs = Kr), Sc(l);
    var N = f.contextType;
    typeof N == "object" && N !== null
      ? (I.context = Ai(N))
      : ((N = vi(f) ? qs : ai.current), (I.context = ml(l, N))),
      (I.state = l.memoizedState),
      (N = f.getDerivedStateFromProps),
      typeof N == "function" && (Ri(l, f, N, v), (I.state = l.memoizedState)),
      typeof f.getDerivedStateFromProps == "function" ||
        typeof I.getSnapshotBeforeUpdate == "function" ||
        (typeof I.UNSAFE_componentWillMount != "function" &&
          typeof I.componentWillMount != "function") ||
        ((f = I.state),
        typeof I.componentWillMount == "function" && I.componentWillMount(),
        typeof I.UNSAFE_componentWillMount == "function" &&
          I.UNSAFE_componentWillMount(),
        f !== I.state && ea.enqueueReplaceState(I, I.state, null),
        ir(l, v, I, E),
        (I.state = l.memoizedState)),
      typeof I.componentDidMount == "function" && (l.flags |= 4194308);
  }
  function Sl(l, f, v) {
    if (
      ((l = v.ref),
      l !== null && typeof l != "function" && typeof l != "object")
    ) {
      if (v._owner) {
        if (((v = v._owner), v)) {
          if (v.tag !== 1) throw Error(t(309));
          var E = v.stateNode;
        }
        if (!E) throw Error(t(147, l));
        var I = E,
          N = "" + l;
        return f !== null &&
          f.ref !== null &&
          typeof f.ref == "function" &&
          f.ref._stringRef === N
          ? f.ref
          : ((f = function (q) {
              var pe = I.refs;
              pe === Kr && (pe = I.refs = {}),
                q === null ? delete pe[N] : (pe[N] = q);
            }),
            (f._stringRef = N),
            f);
      }
      if (typeof l != "string") throw Error(t(284));
      if (!v._owner) throw Error(t(290, l));
    }
    return l;
  }
  function La(l, f) {
    throw (
      ((l = Object.prototype.toString.call(f)),
      Error(
        t(
          31,
          l === "[object Object]"
            ? "object with keys {" + Object.keys(f).join(", ") + "}"
            : l
        )
      ))
    );
  }
  function Pi(l) {
    var f = l._init;
    return f(l._payload);
  }
  function yd(l) {
    function f(ke, be) {
      if (l) {
        var Ne = ke.deletions;
        Ne === null ? ((ke.deletions = [be]), (ke.flags |= 16)) : Ne.push(be);
      }
    }
    function v(ke, be) {
      if (!l) return null;
      for (; be !== null; ) f(ke, be), (be = be.sibling);
      return null;
    }
    function E(ke, be) {
      for (ke = new Map(); be !== null; )
        be.key !== null ? ke.set(be.key, be) : ke.set(be.index, be),
          (be = be.sibling);
      return ke;
    }
    function I(ke, be) {
      return (ke = Pu(ke, be)), (ke.index = 0), (ke.sibling = null), ke;
    }
    function N(ke, be, Ne) {
      return (
        (ke.index = Ne),
        l
          ? ((Ne = ke.alternate),
            Ne !== null
              ? ((Ne = Ne.index), Ne < be ? ((ke.flags |= 2), be) : Ne)
              : ((ke.flags |= 2), be))
          : ((ke.flags |= 1048576), be)
      );
    }
    function q(ke) {
      return l && ke.alternate === null && (ke.flags |= 2), ke;
    }
    function pe(ke, be, Ne, ft) {
      return be === null || be.tag !== 6
        ? ((be = Xx(Ne, ke.mode, ft)), (be.return = ke), be)
        : ((be = I(be, Ne)), (be.return = ke), be);
    }
    function ye(ke, be, Ne, ft) {
      var Ot = Ne.type;
      return Ot === P
        ? st(ke, be, Ne.props.children, ft, Ne.key)
        : be !== null &&
          (be.elementType === Ot ||
            (typeof Ot == "object" &&
              Ot !== null &&
              Ot.$$typeof === Y &&
              Pi(Ot) === be.type))
        ? ((ft = I(be, Ne.props)),
          (ft.ref = Sl(ke, be, Ne)),
          (ft.return = ke),
          ft)
        : ((ft = iv(Ne.type, Ne.key, Ne.props, null, ke.mode, ft)),
          (ft.ref = Sl(ke, be, Ne)),
          (ft.return = ke),
          ft);
    }
    function je(ke, be, Ne, ft) {
      return be === null ||
        be.tag !== 4 ||
        be.stateNode.containerInfo !== Ne.containerInfo ||
        be.stateNode.implementation !== Ne.implementation
        ? ((be = Yx(Ne, ke.mode, ft)), (be.return = ke), be)
        : ((be = I(be, Ne.children || [])), (be.return = ke), be);
    }
    function st(ke, be, Ne, ft, Ot) {
      return be === null || be.tag !== 7
        ? ((be = Lc(Ne, ke.mode, ft, Ot)), (be.return = ke), be)
        : ((be = I(be, Ne)), (be.return = ke), be);
    }
    function lt(ke, be, Ne) {
      if ((typeof be == "string" && be !== "") || typeof be == "number")
        return (be = Xx("" + be, ke.mode, Ne)), (be.return = ke), be;
      if (typeof be == "object" && be !== null) {
        switch (be.$$typeof) {
          case R:
            return (
              (Ne = iv(be.type, be.key, be.props, null, ke.mode, Ne)),
              (Ne.ref = Sl(ke, null, be)),
              (Ne.return = ke),
              Ne
            );
          case D:
            return (be = Yx(be, ke.mode, Ne)), (be.return = ke), be;
          case Y:
            var ft = be._init;
            return lt(ke, ft(be._payload), Ne);
        }
        if (ee(be) || te(be))
          return (be = Lc(be, ke.mode, Ne, null)), (be.return = ke), be;
        La(ke, be);
      }
      return null;
    }
    function ot(ke, be, Ne, ft) {
      var Ot = be !== null ? be.key : null;
      if ((typeof Ne == "string" && Ne !== "") || typeof Ne == "number")
        return Ot !== null ? null : pe(ke, be, "" + Ne, ft);
      if (typeof Ne == "object" && Ne !== null) {
        switch (Ne.$$typeof) {
          case R:
            return Ne.key === Ot ? ye(ke, be, Ne, ft) : null;
          case D:
            return Ne.key === Ot ? je(ke, be, Ne, ft) : null;
          case Y:
            return (Ot = Ne._init), ot(ke, be, Ot(Ne._payload), ft);
        }
        if (ee(Ne) || te(Ne))
          return Ot !== null ? null : st(ke, be, Ne, ft, null);
        La(ke, Ne);
      }
      return null;
    }
    function Mt(ke, be, Ne, ft, Ot) {
      if ((typeof ft == "string" && ft !== "") || typeof ft == "number")
        return (ke = ke.get(Ne) || null), pe(be, ke, "" + ft, Ot);
      if (typeof ft == "object" && ft !== null) {
        switch (ft.$$typeof) {
          case R:
            return (
              (ke = ke.get(ft.key === null ? Ne : ft.key) || null),
              ye(be, ke, ft, Ot)
            );
          case D:
            return (
              (ke = ke.get(ft.key === null ? Ne : ft.key) || null),
              je(be, ke, ft, Ot)
            );
          case Y:
            var Ht = ft._init;
            return Mt(ke, be, Ne, Ht(ft._payload), Ot);
        }
        if (ee(ft) || te(ft))
          return (ke = ke.get(Ne) || null), st(be, ke, ft, Ot, null);
        La(be, ft);
      }
      return null;
    }
    function Rt(ke, be, Ne, ft) {
      for (
        var Ot = null, Ht = null, Vt = be, qt = (be = 0), _i = null;
        Vt !== null && qt < Ne.length;
        qt++
      ) {
        Vt.index > qt ? ((_i = Vt), (Vt = null)) : (_i = Vt.sibling);
        var Cn = ot(ke, Vt, Ne[qt], ft);
        if (Cn === null) {
          Vt === null && (Vt = _i);
          break;
        }
        l && Vt && Cn.alternate === null && f(ke, Vt),
          (be = N(Cn, be, qt)),
          Ht === null ? (Ot = Cn) : (Ht.sibling = Cn),
          (Ht = Cn),
          (Vt = _i);
      }
      if (qt === Ne.length) return v(ke, Vt), $n && Ks(ke, qt), Ot;
      if (Vt === null) {
        for (; qt < Ne.length; qt++)
          (Vt = lt(ke, Ne[qt], ft)),
            Vt !== null &&
              ((be = N(Vt, be, qt)),
              Ht === null ? (Ot = Vt) : (Ht.sibling = Vt),
              (Ht = Vt));
        return $n && Ks(ke, qt), Ot;
      }
      for (Vt = E(ke, Vt); qt < Ne.length; qt++)
        (_i = Mt(Vt, ke, qt, Ne[qt], ft)),
          _i !== null &&
            (l &&
              _i.alternate !== null &&
              Vt.delete(_i.key === null ? qt : _i.key),
            (be = N(_i, be, qt)),
            Ht === null ? (Ot = _i) : (Ht.sibling = _i),
            (Ht = _i));
      return (
        l &&
          Vt.forEach(function (Iu) {
            return f(ke, Iu);
          }),
        $n && Ks(ke, qt),
        Ot
      );
    }
    function Dt(ke, be, Ne, ft) {
      var Ot = te(Ne);
      if (typeof Ot != "function") throw Error(t(150));
      if (((Ne = Ot.call(Ne)), Ne == null)) throw Error(t(151));
      for (
        var Ht = (Ot = null), Vt = be, qt = (be = 0), _i = null, Cn = Ne.next();
        Vt !== null && !Cn.done;
        qt++, Cn = Ne.next()
      ) {
        Vt.index > qt ? ((_i = Vt), (Vt = null)) : (_i = Vt.sibling);
        var Iu = ot(ke, Vt, Cn.value, ft);
        if (Iu === null) {
          Vt === null && (Vt = _i);
          break;
        }
        l && Vt && Iu.alternate === null && f(ke, Vt),
          (be = N(Iu, be, qt)),
          Ht === null ? (Ot = Iu) : (Ht.sibling = Iu),
          (Ht = Iu),
          (Vt = _i);
      }
      if (Cn.done) return v(ke, Vt), $n && Ks(ke, qt), Ot;
      if (Vt === null) {
        for (; !Cn.done; qt++, Cn = Ne.next())
          (Cn = lt(ke, Cn.value, ft)),
            Cn !== null &&
              ((be = N(Cn, be, qt)),
              Ht === null ? (Ot = Cn) : (Ht.sibling = Cn),
              (Ht = Cn));
        return $n && Ks(ke, qt), Ot;
      }
      for (Vt = E(ke, Vt); !Cn.done; qt++, Cn = Ne.next())
        (Cn = Mt(Vt, ke, qt, Cn.value, ft)),
          Cn !== null &&
            (l &&
              Cn.alternate !== null &&
              Vt.delete(Cn.key === null ? qt : Cn.key),
            (be = N(Cn, be, qt)),
            Ht === null ? (Ot = Cn) : (Ht.sibling = Cn),
            (Ht = Cn));
      return (
        l &&
          Vt.forEach(function (B3) {
            return f(ke, B3);
          }),
        $n && Ks(ke, qt),
        Ot
      );
    }
    function kr(ke, be, Ne, ft) {
      if (
        (typeof Ne == "object" &&
          Ne !== null &&
          Ne.type === P &&
          Ne.key === null &&
          (Ne = Ne.props.children),
        typeof Ne == "object" && Ne !== null)
      ) {
        switch (Ne.$$typeof) {
          case R:
            e: {
              for (var Ot = Ne.key, Ht = be; Ht !== null; ) {
                if (Ht.key === Ot) {
                  if (((Ot = Ne.type), Ot === P)) {
                    if (Ht.tag === 7) {
                      v(ke, Ht.sibling),
                        (be = I(Ht, Ne.props.children)),
                        (be.return = ke),
                        (ke = be);
                      break e;
                    }
                  } else if (
                    Ht.elementType === Ot ||
                    (typeof Ot == "object" &&
                      Ot !== null &&
                      Ot.$$typeof === Y &&
                      Pi(Ot) === Ht.type)
                  ) {
                    v(ke, Ht.sibling),
                      (be = I(Ht, Ne.props)),
                      (be.ref = Sl(ke, Ht, Ne)),
                      (be.return = ke),
                      (ke = be);
                    break e;
                  }
                  v(ke, Ht);
                  break;
                } else f(ke, Ht);
                Ht = Ht.sibling;
              }
              Ne.type === P
                ? ((be = Lc(Ne.props.children, ke.mode, ft, Ne.key)),
                  (be.return = ke),
                  (ke = be))
                : ((ft = iv(Ne.type, Ne.key, Ne.props, null, ke.mode, ft)),
                  (ft.ref = Sl(ke, be, Ne)),
                  (ft.return = ke),
                  (ke = ft));
            }
            return q(ke);
          case D:
            e: {
              for (Ht = Ne.key; be !== null; ) {
                if (be.key === Ht)
                  if (
                    be.tag === 4 &&
                    be.stateNode.containerInfo === Ne.containerInfo &&
                    be.stateNode.implementation === Ne.implementation
                  ) {
                    v(ke, be.sibling),
                      (be = I(be, Ne.children || [])),
                      (be.return = ke),
                      (ke = be);
                    break e;
                  } else {
                    v(ke, be);
                    break;
                  }
                else f(ke, be);
                be = be.sibling;
              }
              (be = Yx(Ne, ke.mode, ft)), (be.return = ke), (ke = be);
            }
            return q(ke);
          case Y:
            return (Ht = Ne._init), kr(ke, be, Ht(Ne._payload), ft);
        }
        if (ee(Ne)) return Rt(ke, be, Ne, ft);
        if (te(Ne)) return Dt(ke, be, Ne, ft);
        La(ke, Ne);
      }
      return (typeof Ne == "string" && Ne !== "") || typeof Ne == "number"
        ? ((Ne = "" + Ne),
          be !== null && be.tag === 6
            ? (v(ke, be.sibling), (be = I(be, Ne)), (be.return = ke), (ke = be))
            : (v(ke, be),
              (be = Xx(Ne, ke.mode, ft)),
              (be.return = ke),
              (ke = be)),
          q(ke))
        : v(ke, be);
    }
    return kr;
  }
  var Da = yd(!0),
    wl = yd(!1),
    ka = {},
    Lo = or(ka),
    Do = or(ka),
    Oa = or(ka);
  function $i(l) {
    if (l === ka) throw Error(t(174));
    return l;
  }
  function _u(l, f) {
    switch ((Nn(Oa, f), Nn(Do, l), Nn(Lo, ka), (l = f.nodeType), l)) {
      case 9:
      case 11:
        f = (f = f.documentElement) ? f.namespaceURI : Fe(null, "");
        break;
      default:
        (l = l === 8 ? f.parentNode : f),
          (f = l.namespaceURI || null),
          (l = l.tagName),
          (f = Fe(f, l));
    }
    Hn(Lo), Nn(Lo, f);
  }
  function Ss() {
    Hn(Lo), Hn(Do), Hn(Oa);
  }
  function xd(l) {
    $i(Oa.current);
    var f = $i(Lo.current),
      v = Fe(f, l.type);
    f !== v && (Nn(Do, l), Nn(Lo, v));
  }
  function Su(l) {
    Do.current === l && (Hn(Lo), Hn(Do));
  }
  var Vn = or(0);
  function Zr(l) {
    for (var f = l; f !== null; ) {
      if (f.tag === 13) {
        var v = f.memoizedState;
        if (
          v !== null &&
          ((v = v.dehydrated), v === null || v.data === "$?" || v.data === "$!")
        )
          return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if ((f.flags & 128) !== 0) return f;
      } else if (f.child !== null) {
        (f.child.return = f), (f = f.child);
        continue;
      }
      if (f === l) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === l) return null;
        f = f.return;
      }
      (f.sibling.return = f.return), (f = f.sibling);
    }
    return null;
  }
  var ws = [];
  function Xi() {
    for (var l = 0; l < ws.length; l++)
      ws[l]._workInProgressVersionPrimary = null;
    ws.length = 0;
  }
  var bl = A.ReactCurrentDispatcher,
    yi = A.ReactCurrentBatchConfig,
    Na = 0,
    Xn = null,
    mr = null,
    Jr = null,
    ts = !1,
    wu = !1,
    bu = 0,
    _p = 0;
  function sr() {
    throw Error(t(321));
  }
  function _d(l, f) {
    if (f === null) return !1;
    for (var v = 0; v < f.length && v < l.length; v++)
      if (!uo(l[v], f[v])) return !1;
    return !0;
  }
  function Sd(l, f, v, E, I, N) {
    if (
      ((Na = N),
      (Xn = f),
      (f.memoizedState = null),
      (f.updateQueue = null),
      (f.lanes = 0),
      (bl.current = l === null || l.memoizedState === null ? p : b),
      (l = v(E, I)),
      wu)
    ) {
      N = 0;
      do {
        if (((wu = !1), (bu = 0), 25 <= N)) throw Error(t(301));
        (N += 1),
          (Jr = mr = null),
          (f.updateQueue = null),
          (bl.current = C),
          (l = v(E, I));
      } while (wu);
    }
    if (
      ((bl.current = h),
      (f = mr !== null && mr.next !== null),
      (Na = 0),
      (Jr = mr = Xn = null),
      (ts = !1),
      f)
    )
      throw Error(t(300));
    return l;
  }
  function wc() {
    var l = bu !== 0;
    return (bu = 0), l;
  }
  function ho() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Jr === null ? (Xn.memoizedState = Jr = l) : (Jr = Jr.next = l), Jr;
  }
  function ko() {
    if (mr === null) {
      var l = Xn.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = mr.next;
    var f = Jr === null ? Xn.memoizedState : Jr.next;
    if (f !== null) (Jr = f), (mr = l);
    else {
      if (l === null) throw Error(t(310));
      (mr = l),
        (l = {
          memoizedState: mr.memoizedState,
          baseState: mr.baseState,
          baseQueue: mr.baseQueue,
          queue: mr.queue,
          next: null,
        }),
        Jr === null ? (Xn.memoizedState = Jr = l) : (Jr = Jr.next = l);
    }
    return Jr;
  }
  function bc(l, f) {
    return typeof f == "function" ? f(l) : f;
  }
  function wd(l) {
    var f = ko(),
      v = f.queue;
    if (v === null) throw Error(t(311));
    v.lastRenderedReducer = l;
    var E = mr,
      I = E.baseQueue,
      N = v.pending;
    if (N !== null) {
      if (I !== null) {
        var q = I.next;
        (I.next = N.next), (N.next = q);
      }
      (E.baseQueue = I = N), (v.pending = null);
    }
    if (I !== null) {
      (N = I.next), (E = E.baseState);
      var pe = (q = null),
        ye = null,
        je = N;
      do {
        var st = je.lane;
        if ((Na & st) === st)
          ye !== null &&
            (ye = ye.next =
              {
                lane: 0,
                action: je.action,
                hasEagerState: je.hasEagerState,
                eagerState: je.eagerState,
                next: null,
              }),
            (E = je.hasEagerState ? je.eagerState : l(E, je.action));
        else {
          var lt = {
            lane: st,
            action: je.action,
            hasEagerState: je.hasEagerState,
            eagerState: je.eagerState,
            next: null,
          };
          ye === null ? ((pe = ye = lt), (q = E)) : (ye = ye.next = lt),
            (Xn.lanes |= st),
            (Ac |= st);
        }
        je = je.next;
      } while (je !== null && je !== N);
      ye === null ? (q = E) : (ye.next = pe),
        uo(E, f.memoizedState) || (bt = !0),
        (f.memoizedState = E),
        (f.baseState = q),
        (f.baseQueue = ye),
        (v.lastRenderedState = E);
    }
    if (((l = v.interleaved), l !== null)) {
      I = l;
      do (N = I.lane), (Xn.lanes |= N), (Ac |= N), (I = I.next);
      while (I !== l);
    } else I === null && (v.lanes = 0);
    return [f.memoizedState, v.dispatch];
  }
  function bd(l) {
    var f = ko(),
      v = f.queue;
    if (v === null) throw Error(t(311));
    v.lastRenderedReducer = l;
    var E = v.dispatch,
      I = v.pending,
      N = f.memoizedState;
    if (I !== null) {
      v.pending = null;
      var q = (I = I.next);
      do (N = l(N, q.action)), (q = q.next);
      while (q !== I);
      uo(N, f.memoizedState) || (bt = !0),
        (f.memoizedState = N),
        f.baseQueue === null && (f.baseState = N),
        (v.lastRenderedState = N);
    }
    return [N, E];
  }
  function Ua() {}
  function Og(l, f) {
    var v = Xn,
      E = ko(),
      I = f(),
      N = !uo(E.memoizedState, I);
    if (
      (N && ((E.memoizedState = I), (bt = !0)),
      (E = E.queue),
      Tc(Ii.bind(null, v, E, l), [l]),
      E.getSnapshot !== f || N || (Jr !== null && Jr.memoizedState.tag & 1))
    ) {
      if (
        ((v.flags |= 2048),
        Mc(9, Sp.bind(null, v, E, I, f), void 0, null),
        xi === null)
      )
        throw Error(t(349));
      (Na & 30) !== 0 || Fa(v, f, I);
    }
    return I;
  }
  function Fa(l, f, v) {
    (l.flags |= 16384),
      (l = { getSnapshot: f, value: v }),
      (f = Xn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (Xn.updateQueue = f),
          (f.stores = [l]))
        : ((v = f.stores), v === null ? (f.stores = [l]) : v.push(l));
  }
  function Sp(l, f, v, E) {
    (f.value = v), (f.getSnapshot = E), Ng(f) && wp(l);
  }
  function Ii(l, f, v) {
    return v(function () {
      Ng(f) && wp(l);
    });
  }
  function Ng(l) {
    var f = l.getSnapshot;
    l = l.value;
    try {
      var v = f();
      return !uo(l, v);
    } catch {
      return !0;
    }
  }
  function wp(l) {
    var f = es(l, 1);
    f !== null && ia(f, l, 1, -1);
  }
  function Ug(l) {
    var f = ho();
    return (
      typeof l == "function" && (l = l()),
      (f.memoizedState = f.baseState = l),
      (l = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: bc,
        lastRenderedState: l,
      }),
      (f.queue = l),
      (l = l.dispatch = Vg.bind(null, Xn, l)),
      [f.memoizedState, l]
    );
  }
  function Mc(l, f, v, E) {
    return (
      (l = { tag: l, create: f, destroy: v, deps: E, next: null }),
      (f = Xn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (Xn.updateQueue = f),
          (f.lastEffect = l.next = l))
        : ((v = f.lastEffect),
          v === null
            ? (f.lastEffect = l.next = l)
            : ((E = v.next), (v.next = l), (l.next = E), (f.lastEffect = l))),
      l
    );
  }
  function bp() {
    return ko().memoizedState;
  }
  function Ec(l, f, v, E) {
    var I = ho();
    (Xn.flags |= l),
      (I.memoizedState = Mc(1 | f, v, void 0, E === void 0 ? null : E));
  }
  function Md(l, f, v, E) {
    var I = ko();
    E = E === void 0 ? null : E;
    var N = void 0;
    if (mr !== null) {
      var q = mr.memoizedState;
      if (((N = q.destroy), E !== null && _d(E, q.deps))) {
        I.memoizedState = Mc(f, v, N, E);
        return;
      }
    }
    (Xn.flags |= l), (I.memoizedState = Mc(1 | f, v, N, E));
  }
  function po(l, f) {
    return Ec(8390656, 8, l, f);
  }
  function Tc(l, f) {
    return Md(2048, 8, l, f);
  }
  function Fg(l, f) {
    return Md(4, 2, l, f);
  }
  function ta(l, f) {
    return Md(4, 4, l, f);
  }
  function Cc(l, f) {
    if (typeof f == "function")
      return (
        (l = l()),
        f(l),
        function () {
          f(null);
        }
      );
    if (f != null)
      return (
        (l = l()),
        (f.current = l),
        function () {
          f.current = null;
        }
      );
  }
  function Ba(l, f, v) {
    return (
      (v = v != null ? v.concat([l]) : null), Md(4, 4, Cc.bind(null, f, l), v)
    );
  }
  function Mu() {}
  function Ed(l, f) {
    var v = ko();
    f = f === void 0 ? null : f;
    var E = v.memoizedState;
    return E !== null && f !== null && _d(f, E[1])
      ? E[0]
      : ((v.memoizedState = [l, f]), l);
  }
  function Td(l, f) {
    var v = ko();
    f = f === void 0 ? null : f;
    var E = v.memoizedState;
    return E !== null && f !== null && _d(f, E[1])
      ? E[0]
      : ((l = l()), (v.memoizedState = [l, f]), l);
  }
  function Bg(l, f, v) {
    return (Na & 21) === 0
      ? (l.baseState && ((l.baseState = !1), (bt = !0)), (l.memoizedState = v))
      : (uo(v, f) ||
          ((v = pi()), (Xn.lanes |= v), (Ac |= v), (l.baseState = !0)),
        f);
  }
  function zg(l, f) {
    var v = ln;
    (ln = v !== 0 && 4 > v ? v : 4), l(!0);
    var E = yi.transition;
    yi.transition = {};
    try {
      l(!1), f();
    } finally {
      (ln = v), (yi.transition = E);
    }
  }
  function Mp() {
    return ko().memoizedState;
  }
  function Hg(l, f, v) {
    var E = Au(l);
    if (
      ((v = {
        lane: E,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      Cd(l))
    )
      Wg(f, v);
    else if (((v = vd(l, f, v, E)), v !== null)) {
      var I = go();
      ia(v, l, E, I), Gg(v, f, E);
    }
  }
  function Vg(l, f, v) {
    var E = Au(l),
      I = {
        lane: E,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (Cd(l)) Wg(f, I);
    else {
      var N = l.alternate;
      if (
        l.lanes === 0 &&
        (N === null || N.lanes === 0) &&
        ((N = f.lastRenderedReducer), N !== null)
      )
        try {
          var q = f.lastRenderedState,
            pe = N(q, v);
          if (((I.hasEagerState = !0), (I.eagerState = pe), uo(pe, q))) {
            var ye = f.interleaved;
            ye === null
              ? ((I.next = I), _c(f))
              : ((I.next = ye.next), (ye.next = I)),
              (f.interleaved = I);
            return;
          }
        } catch {
        } finally {
        }
      (v = vd(l, f, I, E)),
        v !== null && ((I = go()), ia(v, l, E, I), Gg(v, f, E));
    }
  }
  function Cd(l) {
    var f = l.alternate;
    return l === Xn || (f !== null && f === Xn);
  }
  function Wg(l, f) {
    wu = ts = !0;
    var v = l.pending;
    v === null ? (f.next = f) : ((f.next = v.next), (v.next = f)),
      (l.pending = f);
  }
  function Gg(l, f, v) {
    if ((v & 4194240) !== 0) {
      var E = f.lanes;
      (E &= l.pendingLanes), (v |= E), (f.lanes = v), jo(l, v);
    }
  }
  var h = {
      readContext: Ai,
      useCallback: sr,
      useContext: sr,
      useEffect: sr,
      useImperativeHandle: sr,
      useInsertionEffect: sr,
      useLayoutEffect: sr,
      useMemo: sr,
      useReducer: sr,
      useRef: sr,
      useState: sr,
      useDebugValue: sr,
      useDeferredValue: sr,
      useTransition: sr,
      useMutableSource: sr,
      useSyncExternalStore: sr,
      useId: sr,
      unstable_isNewReconciler: !1,
    },
    p = {
      readContext: Ai,
      useCallback: function (l, f) {
        return (ho().memoizedState = [l, f === void 0 ? null : f]), l;
      },
      useContext: Ai,
      useEffect: po,
      useImperativeHandle: function (l, f, v) {
        return (
          (v = v != null ? v.concat([l]) : null),
          Ec(4194308, 4, Cc.bind(null, f, l), v)
        );
      },
      useLayoutEffect: function (l, f) {
        return Ec(4194308, 4, l, f);
      },
      useInsertionEffect: function (l, f) {
        return Ec(4, 2, l, f);
      },
      useMemo: function (l, f) {
        var v = ho();
        return (
          (f = f === void 0 ? null : f),
          (l = l()),
          (v.memoizedState = [l, f]),
          l
        );
      },
      useReducer: function (l, f, v) {
        var E = ho();
        return (
          (f = v !== void 0 ? v(f) : f),
          (E.memoizedState = E.baseState = f),
          (l = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: l,
            lastRenderedState: f,
          }),
          (E.queue = l),
          (l = l.dispatch = Hg.bind(null, Xn, l)),
          [E.memoizedState, l]
        );
      },
      useRef: function (l) {
        var f = ho();
        return (l = { current: l }), (f.memoizedState = l);
      },
      useState: Ug,
      useDebugValue: Mu,
      useDeferredValue: function (l) {
        return (ho().memoizedState = l);
      },
      useTransition: function () {
        var l = Ug(!1),
          f = l[0];
        return (l = zg.bind(null, l[1])), (ho().memoizedState = l), [f, l];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (l, f, v) {
        var E = Xn,
          I = ho();
        if ($n) {
          if (v === void 0) throw Error(t(407));
          v = v();
        } else {
          if (((v = f()), xi === null)) throw Error(t(349));
          (Na & 30) !== 0 || Fa(E, f, v);
        }
        I.memoizedState = v;
        var N = { value: v, getSnapshot: f };
        return (
          (I.queue = N),
          po(Ii.bind(null, E, N, l), [l]),
          (E.flags |= 2048),
          Mc(9, Sp.bind(null, E, N, v, f), void 0, null),
          v
        );
      },
      useId: function () {
        var l = ho(),
          f = xi.identifierPrefix;
        if ($n) {
          var v = Ro,
            E = pt;
          (v = (E & ~(1 << (32 - Jt(E) - 1))).toString(32) + v),
            (f = ":" + f + "R" + v),
            (v = bu++),
            0 < v && (f += "H" + v.toString(32)),
            (f += ":");
        } else (v = _p++), (f = ":" + f + "r" + v.toString(32) + ":");
        return (l.memoizedState = f);
      },
      unstable_isNewReconciler: !1,
    },
    b = {
      readContext: Ai,
      useCallback: Ed,
      useContext: Ai,
      useEffect: Tc,
      useImperativeHandle: Ba,
      useInsertionEffect: Fg,
      useLayoutEffect: ta,
      useMemo: Td,
      useReducer: wd,
      useRef: bp,
      useState: function () {
        return wd(bc);
      },
      useDebugValue: Mu,
      useDeferredValue: function (l) {
        var f = ko();
        return Bg(f, mr.memoizedState, l);
      },
      useTransition: function () {
        var l = wd(bc)[0],
          f = ko().memoizedState;
        return [l, f];
      },
      useMutableSource: Ua,
      useSyncExternalStore: Og,
      useId: Mp,
      unstable_isNewReconciler: !1,
    },
    C = {
      readContext: Ai,
      useCallback: Ed,
      useContext: Ai,
      useEffect: Tc,
      useImperativeHandle: Ba,
      useInsertionEffect: Fg,
      useLayoutEffect: ta,
      useMemo: Td,
      useReducer: bd,
      useRef: bp,
      useState: function () {
        return bd(bc);
      },
      useDebugValue: Mu,
      useDeferredValue: function (l) {
        var f = ko();
        return mr === null ? (f.memoizedState = l) : Bg(f, mr.memoizedState, l);
      },
      useTransition: function () {
        var l = bd(bc)[0],
          f = ko().memoizedState;
        return [l, f];
      },
      useMutableSource: Ua,
      useSyncExternalStore: Og,
      useId: Mp,
      unstable_isNewReconciler: !1,
    };
  function k(l, f) {
    try {
      var v = "",
        E = f;
      do (v += se(E)), (E = E.return);
      while (E);
      var I = v;
    } catch (N) {
      I =
        `
Error generating stack: ` +
        N.message +
        `
` +
        N.stack;
    }
    return { value: l, source: f, stack: I, digest: null };
  }
  function z(l, f, v) {
    return { value: l, source: null, stack: v ?? null, digest: f ?? null };
  }
  function ce(l, f) {
    try {
      console.error(f.value);
    } catch (v) {
      setTimeout(function () {
        throw v;
      });
    }
  }
  var Ee = typeof WeakMap == "function" ? WeakMap : Map;
  function Qe(l, f, v) {
    (v = Io(-1, v)), (v.tag = 3), (v.payload = { element: null });
    var E = f.value;
    return (
      (v.callback = function () {
        Jg || ((Jg = !0), (Bx = E)), ce(l, f);
      }),
      v
    );
  }
  function ct(l, f, v) {
    (v = Io(-1, v)), (v.tag = 3);
    var E = l.type.getDerivedStateFromError;
    if (typeof E == "function") {
      var I = f.value;
      (v.payload = function () {
        return E(I);
      }),
        (v.callback = function () {
          ce(l, f);
        });
    }
    var N = l.stateNode;
    return (
      N !== null &&
        typeof N.componentDidCatch == "function" &&
        (v.callback = function () {
          ce(l, f),
            typeof E != "function" &&
              (Tu === null ? (Tu = new Set([this])) : Tu.add(this));
          var q = f.stack;
          this.componentDidCatch(f.value, {
            componentStack: q !== null ? q : "",
          });
        }),
      v
    );
  }
  function Tt(l, f, v) {
    var E = l.pingCache;
    if (E === null) {
      E = l.pingCache = new Ee();
      var I = new Set();
      E.set(f, I);
    } else (I = E.get(f)), I === void 0 && ((I = new Set()), E.set(f, I));
    I.has(v) || (I.add(v), (l = A3.bind(null, l, f, v)), f.then(l, l));
  }
  function Kt(l) {
    do {
      var f;
      if (
        ((f = l.tag === 13) &&
          ((f = l.memoizedState),
          (f = f !== null ? f.dehydrated !== null : !0)),
        f)
      )
        return l;
      l = l.return;
    } while (l !== null);
    return null;
  }
  function Bt(l, f, v, E, I) {
    return (l.mode & 1) === 0
      ? (l === f
          ? (l.flags |= 65536)
          : ((l.flags |= 128),
            (v.flags |= 131072),
            (v.flags &= -52805),
            v.tag === 1 &&
              (v.alternate === null
                ? (v.tag = 17)
                : ((f = Io(-1, 1)), (f.tag = 2), _s(v, f, 1))),
            (v.lanes |= 1)),
        l)
      : ((l.flags |= 65536), (l.lanes = I), l);
  }
  var Un = A.ReactCurrentOwner,
    bt = !1;
  function Tn(l, f, v, E) {
    f.child = l === null ? wl(f, null, v, E) : Da(f, l.child, v, E);
  }
  function mo(l, f, v, E, I) {
    v = v.render;
    var N = f.ref;
    return (
      Js(f, I),
      (E = Sd(l, f, v, E, N, I)),
      (v = wc()),
      l !== null && !bt
        ? ((f.updateQueue = l.updateQueue),
          (f.flags &= -2053),
          (l.lanes &= ~I),
          Ml(l, f, I))
        : ($n && v && gp(f), (f.flags |= 1), Tn(l, f, E, I), f.child)
    );
  }
  function He(l, f, v, E, I) {
    if (l === null) {
      var N = v.type;
      return typeof N == "function" &&
        !$x(N) &&
        N.defaultProps === void 0 &&
        v.compare === null &&
        v.defaultProps === void 0
        ? ((f.tag = 15), (f.type = N), Pe(l, f, N, E, I))
        : ((l = iv(v.type, null, E, f, f.mode, I)),
          (l.ref = f.ref),
          (l.return = f),
          (f.child = l));
    }
    if (((N = l.child), (l.lanes & I) === 0)) {
      var q = N.memoizedProps;
      if (
        ((v = v.compare), (v = v !== null ? v : ul), v(q, E) && l.ref === f.ref)
      )
        return Ml(l, f, I);
    }
    return (
      (f.flags |= 1),
      (l = Pu(N, E)),
      (l.ref = f.ref),
      (l.return = f),
      (f.child = l)
    );
  }
  function Pe(l, f, v, E, I) {
    if (l !== null) {
      var N = l.memoizedProps;
      if (ul(N, E) && l.ref === f.ref)
        if (((bt = !1), (f.pendingProps = E = N), (l.lanes & I) !== 0))
          (l.flags & 131072) !== 0 && (bt = !0);
        else return (f.lanes = l.lanes), Ml(l, f, I);
    }
    return Lt(l, f, v, E, I);
  }
  function Ze(l, f, v) {
    var E = f.pendingProps,
      I = E.children,
      N = l !== null ? l.memoizedState : null;
    if (E.mode === "hidden")
      if ((f.mode & 1) === 0)
        (f.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          Nn(Rd, ns),
          (ns |= v);
      else {
        if ((v & 1073741824) === 0)
          return (
            (l = N !== null ? N.baseLanes | v : v),
            (f.lanes = f.childLanes = 1073741824),
            (f.memoizedState = {
              baseLanes: l,
              cachePool: null,
              transitions: null,
            }),
            (f.updateQueue = null),
            Nn(Rd, ns),
            (ns |= l),
            null
          );
        (f.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (E = N !== null ? N.baseLanes : v),
          Nn(Rd, ns),
          (ns |= E);
      }
    else
      N !== null ? ((E = N.baseLanes | v), (f.memoizedState = null)) : (E = v),
        Nn(Rd, ns),
        (ns |= E);
    return Tn(l, f, I, v), f.child;
  }
  function _t(l, f) {
    var v = f.ref;
    ((l === null && v !== null) || (l !== null && l.ref !== v)) &&
      ((f.flags |= 512), (f.flags |= 2097152));
  }
  function Lt(l, f, v, E, I) {
    var N = vi(v) ? qs : ai.current;
    return (
      (N = ml(f, N)),
      Js(f, I),
      (v = Sd(l, f, v, E, N, I)),
      (E = wc()),
      l !== null && !bt
        ? ((f.updateQueue = l.updateQueue),
          (f.flags &= -2053),
          (l.lanes &= ~I),
          Ml(l, f, I))
        : ($n && E && gp(f), (f.flags |= 1), Tn(l, f, v, I), f.child)
    );
  }
  function Qt(l, f, v, E, I) {
    if (vi(v)) {
      var N = !0;
      gl(f);
    } else N = !1;
    if ((Js(f, I), f.stateNode === null))
      Xg(l, f), yu(f, v, E), xu(f, v, E, I), (E = !0);
    else if (l === null) {
      var q = f.stateNode,
        pe = f.memoizedProps;
      q.props = pe;
      var ye = q.context,
        je = v.contextType;
      typeof je == "object" && je !== null
        ? (je = Ai(je))
        : ((je = vi(v) ? qs : ai.current), (je = ml(f, je)));
      var st = v.getDerivedStateFromProps,
        lt =
          typeof st == "function" ||
          typeof q.getSnapshotBeforeUpdate == "function";
      lt ||
        (typeof q.UNSAFE_componentWillReceiveProps != "function" &&
          typeof q.componentWillReceiveProps != "function") ||
        ((pe !== E || ye !== je) && _l(f, q, E, je)),
        (Qs = !1);
      var ot = f.memoizedState;
      (q.state = ot),
        ir(f, E, q, I),
        (ye = f.memoizedState),
        pe !== E || ot !== ye || Ei.current || Qs
          ? (typeof st == "function" &&
              (Ri(f, v, st, E), (ye = f.memoizedState)),
            (pe = Qs || Sr(f, v, pe, E, ot, ye, je))
              ? (lt ||
                  (typeof q.UNSAFE_componentWillMount != "function" &&
                    typeof q.componentWillMount != "function") ||
                  (typeof q.componentWillMount == "function" &&
                    q.componentWillMount(),
                  typeof q.UNSAFE_componentWillMount == "function" &&
                    q.UNSAFE_componentWillMount()),
                typeof q.componentDidMount == "function" &&
                  (f.flags |= 4194308))
              : (typeof q.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (f.memoizedProps = E),
                (f.memoizedState = ye)),
            (q.props = E),
            (q.state = ye),
            (q.context = je),
            (E = pe))
          : (typeof q.componentDidMount == "function" && (f.flags |= 4194308),
            (E = !1));
    } else {
      (q = f.stateNode),
        kg(l, f),
        (pe = f.memoizedProps),
        (je = f.type === f.elementType ? pe : Jo(f.type, pe)),
        (q.props = je),
        (lt = f.pendingProps),
        (ot = q.context),
        (ye = v.contextType),
        typeof ye == "object" && ye !== null
          ? (ye = Ai(ye))
          : ((ye = vi(v) ? qs : ai.current), (ye = ml(f, ye)));
      var Mt = v.getDerivedStateFromProps;
      (st =
        typeof Mt == "function" ||
        typeof q.getSnapshotBeforeUpdate == "function") ||
        (typeof q.UNSAFE_componentWillReceiveProps != "function" &&
          typeof q.componentWillReceiveProps != "function") ||
        ((pe !== lt || ot !== ye) && _l(f, q, E, ye)),
        (Qs = !1),
        (ot = f.memoizedState),
        (q.state = ot),
        ir(f, E, q, I);
      var Rt = f.memoizedState;
      pe !== lt || ot !== Rt || Ei.current || Qs
        ? (typeof Mt == "function" && (Ri(f, v, Mt, E), (Rt = f.memoizedState)),
          (je = Qs || Sr(f, v, je, E, ot, Rt, ye) || !1)
            ? (st ||
                (typeof q.UNSAFE_componentWillUpdate != "function" &&
                  typeof q.componentWillUpdate != "function") ||
                (typeof q.componentWillUpdate == "function" &&
                  q.componentWillUpdate(E, Rt, ye),
                typeof q.UNSAFE_componentWillUpdate == "function" &&
                  q.UNSAFE_componentWillUpdate(E, Rt, ye)),
              typeof q.componentDidUpdate == "function" && (f.flags |= 4),
              typeof q.getSnapshotBeforeUpdate == "function" &&
                (f.flags |= 1024))
            : (typeof q.componentDidUpdate != "function" ||
                (pe === l.memoizedProps && ot === l.memoizedState) ||
                (f.flags |= 4),
              typeof q.getSnapshotBeforeUpdate != "function" ||
                (pe === l.memoizedProps && ot === l.memoizedState) ||
                (f.flags |= 1024),
              (f.memoizedProps = E),
              (f.memoizedState = Rt)),
          (q.props = E),
          (q.state = Rt),
          (q.context = ye),
          (E = je))
        : (typeof q.componentDidUpdate != "function" ||
            (pe === l.memoizedProps && ot === l.memoizedState) ||
            (f.flags |= 4),
          typeof q.getSnapshotBeforeUpdate != "function" ||
            (pe === l.memoizedProps && ot === l.memoizedState) ||
            (f.flags |= 1024),
          (E = !1));
    }
    return Yt(l, f, v, E, N, I);
  }
  function Yt(l, f, v, E, I, N) {
    _t(l, f);
    var q = (f.flags & 128) !== 0;
    if (!E && !q) return I && pp(f, v, !1), Ml(l, f, N);
    (E = f.stateNode), (Un.current = f);
    var pe =
      q && typeof v.getDerivedStateFromError != "function" ? null : E.render();
    return (
      (f.flags |= 1),
      l !== null && q
        ? ((f.child = Da(f, l.child, null, N)), (f.child = Da(f, null, pe, N)))
        : Tn(l, f, pe, N),
      (f.memoizedState = E.state),
      I && pp(f, v, !0),
      f.child
    );
  }
  function gn(l) {
    var f = l.stateNode;
    f.pendingContext
      ? hp(l, f.pendingContext, f.pendingContext !== f.context)
      : f.context && hp(l, f.context, !1),
      _u(l, f.containerInfo);
  }
  function Dr(l, f, v, E, I) {
    return Ia(), pu(I), (f.flags |= 256), Tn(l, f, v, E), f.child;
  }
  var mn = { dehydrated: null, treeContext: null, retryLane: 0 };
  function bs(l) {
    return { baseLanes: l, cachePool: null, transitions: null };
  }
  function jg(l, f, v) {
    var E = f.pendingProps,
      I = Vn.current,
      N = !1,
      q = (f.flags & 128) !== 0,
      pe;
    if (
      ((pe = q) ||
        (pe = l !== null && l.memoizedState === null ? !1 : (I & 2) !== 0),
      pe
        ? ((N = !0), (f.flags &= -129))
        : (l === null || l.memoizedState !== null) && (I |= 1),
      Nn(Vn, I & 1),
      l === null)
    )
      return (
        pd(f),
        (l = f.memoizedState),
        l !== null && ((l = l.dehydrated), l !== null)
          ? ((f.mode & 1) === 0
              ? (f.lanes = 1)
              : l.data === "$!"
              ? (f.lanes = 8)
              : (f.lanes = 1073741824),
            null)
          : ((q = E.children),
            (l = E.fallback),
            N
              ? ((E = f.mode),
                (N = f.child),
                (q = { mode: "hidden", children: q }),
                (E & 1) === 0 && N !== null
                  ? ((N.childLanes = 0), (N.pendingProps = q))
                  : (N = ov(q, E, 0, null)),
                (l = Lc(l, E, v, null)),
                (N.return = f),
                (l.return = f),
                (N.sibling = l),
                (f.child = N),
                (f.child.memoizedState = bs(v)),
                (f.memoizedState = mn),
                l)
              : Rx(f, q))
      );
    if (
      ((I = l.memoizedState), I !== null && ((pe = I.dehydrated), pe !== null))
    )
      return g3(l, f, q, E, pe, I, v);
    if (N) {
      (N = E.fallback), (q = f.mode), (I = l.child), (pe = I.sibling);
      var ye = { mode: "hidden", children: E.children };
      return (
        (q & 1) === 0 && f.child !== I
          ? ((E = f.child),
            (E.childLanes = 0),
            (E.pendingProps = ye),
            (f.deletions = null))
          : ((E = Pu(I, ye)), (E.subtreeFlags = I.subtreeFlags & 14680064)),
        pe !== null
          ? (N = Pu(pe, N))
          : ((N = Lc(N, q, v, null)), (N.flags |= 2)),
        (N.return = f),
        (E.return = f),
        (E.sibling = N),
        (f.child = E),
        (E = N),
        (N = f.child),
        (q = l.child.memoizedState),
        (q =
          q === null
            ? bs(v)
            : {
                baseLanes: q.baseLanes | v,
                cachePool: null,
                transitions: q.transitions,
              }),
        (N.memoizedState = q),
        (N.childLanes = l.childLanes & ~v),
        (f.memoizedState = mn),
        E
      );
    }
    return (
      (N = l.child),
      (l = N.sibling),
      (E = Pu(N, { mode: "visible", children: E.children })),
      (f.mode & 1) === 0 && (E.lanes = v),
      (E.return = f),
      (E.sibling = null),
      l !== null &&
        ((v = f.deletions),
        v === null ? ((f.deletions = [l]), (f.flags |= 16)) : v.push(l)),
      (f.child = E),
      (f.memoizedState = null),
      E
    );
  }
  function Rx(l, f) {
    return (
      (f = ov({ mode: "visible", children: f }, l.mode, 0, null)),
      (f.return = l),
      (l.child = f)
    );
  }
  function $g(l, f, v, E) {
    return (
      E !== null && pu(E),
      Da(f, l.child, null, v),
      (l = Rx(f, f.pendingProps.children)),
      (l.flags |= 2),
      (f.memoizedState = null),
      l
    );
  }
  function g3(l, f, v, E, I, N, q) {
    if (v)
      return f.flags & 256
        ? ((f.flags &= -257), (E = z(Error(t(422)))), $g(l, f, q, E))
        : f.memoizedState !== null
        ? ((f.child = l.child), (f.flags |= 128), null)
        : ((N = E.fallback),
          (I = f.mode),
          (E = ov({ mode: "visible", children: E.children }, I, 0, null)),
          (N = Lc(N, I, q, null)),
          (N.flags |= 2),
          (E.return = f),
          (N.return = f),
          (E.sibling = N),
          (f.child = E),
          (f.mode & 1) !== 0 && Da(f, l.child, null, q),
          (f.child.memoizedState = bs(q)),
          (f.memoizedState = mn),
          N);
    if ((f.mode & 1) === 0) return $g(l, f, q, null);
    if (I.data === "$!") {
      if (((E = I.nextSibling && I.nextSibling.dataset), E)) var pe = E.dgst;
      return (
        (E = pe), (N = Error(t(419))), (E = z(N, E, void 0)), $g(l, f, q, E)
      );
    }
    if (((pe = (q & l.childLanes) !== 0), bt || pe)) {
      if (((E = xi), E !== null)) {
        switch (q & -q) {
          case 4:
            I = 2;
            break;
          case 16:
            I = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            I = 32;
            break;
          case 536870912:
            I = 268435456;
            break;
          default:
            I = 0;
        }
        (I = (I & (E.suspendedLanes | q)) !== 0 ? 0 : I),
          I !== 0 &&
            I !== N.retryLane &&
            ((N.retryLane = I), es(l, I), ia(E, l, I, -1));
      }
      return jx(), (E = z(Error(t(421)))), $g(l, f, q, E);
    }
    return I.data === "$?"
      ? ((f.flags |= 128),
        (f.child = l.child),
        (f = R3.bind(null, l)),
        (I._reactRetry = f),
        null)
      : ((l = N.treeContext),
        (Ci = $s(I.nextSibling)),
        (li = f),
        ($n = !0),
        (Po = null),
        l !== null &&
          ((Ti[qr++] = pt),
          (Ti[qr++] = Ro),
          (Ti[qr++] = yl),
          (pt = l.id),
          (Ro = l.overflow),
          (yl = f)),
        (f = Rx(f, E.children)),
        (f.flags |= 4096),
        f);
  }
  function hb(l, f, v) {
    l.lanes |= f;
    var E = l.alternate;
    E !== null && (E.lanes |= f), vu(l.return, f, v);
  }
  function Px(l, f, v, E, I) {
    var N = l.memoizedState;
    N === null
      ? (l.memoizedState = {
          isBackwards: f,
          rendering: null,
          renderingStartTime: 0,
          last: E,
          tail: v,
          tailMode: I,
        })
      : ((N.isBackwards = f),
        (N.rendering = null),
        (N.renderingStartTime = 0),
        (N.last = E),
        (N.tail = v),
        (N.tailMode = I));
  }
  function pb(l, f, v) {
    var E = f.pendingProps,
      I = E.revealOrder,
      N = E.tail;
    if ((Tn(l, f, E.children, v), (E = Vn.current), (E & 2) !== 0))
      (E = (E & 1) | 2), (f.flags |= 128);
    else {
      if (l !== null && (l.flags & 128) !== 0)
        e: for (l = f.child; l !== null; ) {
          if (l.tag === 13) l.memoizedState !== null && hb(l, v, f);
          else if (l.tag === 19) hb(l, v, f);
          else if (l.child !== null) {
            (l.child.return = l), (l = l.child);
            continue;
          }
          if (l === f) break e;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === f) break e;
            l = l.return;
          }
          (l.sibling.return = l.return), (l = l.sibling);
        }
      E &= 1;
    }
    if ((Nn(Vn, E), (f.mode & 1) === 0)) f.memoizedState = null;
    else
      switch (I) {
        case "forwards":
          for (v = f.child, I = null; v !== null; )
            (l = v.alternate),
              l !== null && Zr(l) === null && (I = v),
              (v = v.sibling);
          (v = I),
            v === null
              ? ((I = f.child), (f.child = null))
              : ((I = v.sibling), (v.sibling = null)),
            Px(f, !1, I, v, N);
          break;
        case "backwards":
          for (v = null, I = f.child, f.child = null; I !== null; ) {
            if (((l = I.alternate), l !== null && Zr(l) === null)) {
              f.child = I;
              break;
            }
            (l = I.sibling), (I.sibling = v), (v = I), (I = l);
          }
          Px(f, !0, v, null, N);
          break;
        case "together":
          Px(f, !1, null, null, void 0);
          break;
        default:
          f.memoizedState = null;
      }
    return f.child;
  }
  function Xg(l, f) {
    (f.mode & 1) === 0 &&
      l !== null &&
      ((l.alternate = null), (f.alternate = null), (f.flags |= 2));
  }
  function Ml(l, f, v) {
    if (
      (l !== null && (f.dependencies = l.dependencies),
      (Ac |= f.lanes),
      (v & f.childLanes) === 0)
    )
      return null;
    if (l !== null && f.child !== l.child) throw Error(t(153));
    if (f.child !== null) {
      for (
        l = f.child, v = Pu(l, l.pendingProps), f.child = v, v.return = f;
        l.sibling !== null;

      )
        (l = l.sibling),
          (v = v.sibling = Pu(l, l.pendingProps)),
          (v.return = f);
      v.sibling = null;
    }
    return f.child;
  }
  function v3(l, f, v) {
    switch (f.tag) {
      case 3:
        gn(f), Ia();
        break;
      case 5:
        xd(f);
        break;
      case 1:
        vi(f.type) && gl(f);
        break;
      case 4:
        _u(f, f.stateNode.containerInfo);
        break;
      case 10:
        var E = f.type._context,
          I = f.memoizedProps.value;
        Nn(yc, E._currentValue), (E._currentValue = I);
        break;
      case 13:
        if (((E = f.memoizedState), E !== null))
          return E.dehydrated !== null
            ? (Nn(Vn, Vn.current & 1), (f.flags |= 128), null)
            : (v & f.child.childLanes) !== 0
            ? jg(l, f, v)
            : (Nn(Vn, Vn.current & 1),
              (l = Ml(l, f, v)),
              l !== null ? l.sibling : null);
        Nn(Vn, Vn.current & 1);
        break;
      case 19:
        if (((E = (v & f.childLanes) !== 0), (l.flags & 128) !== 0)) {
          if (E) return pb(l, f, v);
          f.flags |= 128;
        }
        if (
          ((I = f.memoizedState),
          I !== null &&
            ((I.rendering = null), (I.tail = null), (I.lastEffect = null)),
          Nn(Vn, Vn.current),
          E)
        )
          break;
        return null;
      case 22:
      case 23:
        return (f.lanes = 0), Ze(l, f, v);
    }
    return Ml(l, f, v);
  }
  var mb, Ix, gb, vb;
  (mb = function (l, f) {
    for (var v = f.child; v !== null; ) {
      if (v.tag === 5 || v.tag === 6) l.appendChild(v.stateNode);
      else if (v.tag !== 4 && v.child !== null) {
        (v.child.return = v), (v = v.child);
        continue;
      }
      if (v === f) break;
      for (; v.sibling === null; ) {
        if (v.return === null || v.return === f) return;
        v = v.return;
      }
      (v.sibling.return = v.return), (v = v.sibling);
    }
  }),
    (Ix = function () {}),
    (gb = function (l, f, v, E) {
      var I = l.memoizedProps;
      if (I !== E) {
        (l = f.stateNode), $i(Lo.current);
        var N = null;
        switch (v) {
          case "input":
            (I = Ae(l, I)), (E = Ae(l, E)), (N = []);
            break;
          case "select":
            (I = F({}, I, { value: void 0 })),
              (E = F({}, E, { value: void 0 })),
              (N = []);
            break;
          case "textarea":
            (I = ve(l, I)), (E = ve(l, E)), (N = []);
            break;
          default:
            typeof I.onClick != "function" &&
              typeof E.onClick == "function" &&
              (l.onclick = hc);
        }
        he(v, E);
        var q;
        v = null;
        for (je in I)
          if (!E.hasOwnProperty(je) && I.hasOwnProperty(je) && I[je] != null)
            if (je === "style") {
              var pe = I[je];
              for (q in pe)
                pe.hasOwnProperty(q) && (v || (v = {}), (v[q] = ""));
            } else
              je !== "dangerouslySetInnerHTML" &&
                je !== "children" &&
                je !== "suppressContentEditableWarning" &&
                je !== "suppressHydrationWarning" &&
                je !== "autoFocus" &&
                (i.hasOwnProperty(je)
                  ? N || (N = [])
                  : (N = N || []).push(je, null));
        for (je in E) {
          var ye = E[je];
          if (
            ((pe = I != null ? I[je] : void 0),
            E.hasOwnProperty(je) && ye !== pe && (ye != null || pe != null))
          )
            if (je === "style")
              if (pe) {
                for (q in pe)
                  !pe.hasOwnProperty(q) ||
                    (ye && ye.hasOwnProperty(q)) ||
                    (v || (v = {}), (v[q] = ""));
                for (q in ye)
                  ye.hasOwnProperty(q) &&
                    pe[q] !== ye[q] &&
                    (v || (v = {}), (v[q] = ye[q]));
              } else v || (N || (N = []), N.push(je, v)), (v = ye);
            else
              je === "dangerouslySetInnerHTML"
                ? ((ye = ye ? ye.__html : void 0),
                  (pe = pe ? pe.__html : void 0),
                  ye != null && pe !== ye && (N = N || []).push(je, ye))
                : je === "children"
                ? (typeof ye != "string" && typeof ye != "number") ||
                  (N = N || []).push(je, "" + ye)
                : je !== "suppressContentEditableWarning" &&
                  je !== "suppressHydrationWarning" &&
                  (i.hasOwnProperty(je)
                    ? (ye != null && je === "onScroll" && zn("scroll", l),
                      N || pe === ye || (N = []))
                    : (N = N || []).push(je, ye));
        }
        v && (N = N || []).push("style", v);
        var je = N;
        (f.updateQueue = je) && (f.flags |= 4);
      }
    }),
    (vb = function (l, f, v, E) {
      v !== E && (f.flags |= 4);
    });
  function Ep(l, f) {
    if (!$n)
      switch (l.tailMode) {
        case "hidden":
          f = l.tail;
          for (var v = null; f !== null; )
            f.alternate !== null && (v = f), (f = f.sibling);
          v === null ? (l.tail = null) : (v.sibling = null);
          break;
        case "collapsed":
          v = l.tail;
          for (var E = null; v !== null; )
            v.alternate !== null && (E = v), (v = v.sibling);
          E === null
            ? f || l.tail === null
              ? (l.tail = null)
              : (l.tail.sibling = null)
            : (E.sibling = null);
      }
  }
  function Yi(l) {
    var f = l.alternate !== null && l.alternate.child === l.child,
      v = 0,
      E = 0;
    if (f)
      for (var I = l.child; I !== null; )
        (v |= I.lanes | I.childLanes),
          (E |= I.subtreeFlags & 14680064),
          (E |= I.flags & 14680064),
          (I.return = l),
          (I = I.sibling);
    else
      for (I = l.child; I !== null; )
        (v |= I.lanes | I.childLanes),
          (E |= I.subtreeFlags),
          (E |= I.flags),
          (I.return = l),
          (I = I.sibling);
    return (l.subtreeFlags |= E), (l.childLanes = v), f;
  }
  function y3(l, f, v) {
    var E = f.pendingProps;
    switch ((Zs(f), f.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Yi(f), null;
      case 1:
        return vi(f.type) && pc(), Yi(f), null;
      case 3:
        return (
          (E = f.stateNode),
          Ss(),
          Hn(Ei),
          Hn(ai),
          Xi(),
          E.pendingContext &&
            ((E.context = E.pendingContext), (E.pendingContext = null)),
          (l === null || l.child === null) &&
            (hu(f)
              ? (f.flags |= 4)
              : l === null ||
                (l.memoizedState.isDehydrated && (f.flags & 256) === 0) ||
                ((f.flags |= 1024), Po !== null && (Vx(Po), (Po = null)))),
          Ix(l, f),
          Yi(f),
          null
        );
      case 5:
        Su(f);
        var I = $i(Oa.current);
        if (((v = f.type), l !== null && f.stateNode != null))
          gb(l, f, v, E, I),
            l.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152));
        else {
          if (!E) {
            if (f.stateNode === null) throw Error(t(166));
            return Yi(f), null;
          }
          if (((l = $i(Lo.current)), hu(f))) {
            (E = f.stateNode), (v = f.type);
            var N = f.memoizedProps;
            switch (((E[Lr] = f), (E[du] = N), (l = (f.mode & 1) !== 0), v)) {
              case "dialog":
                zn("cancel", E), zn("close", E);
                break;
              case "iframe":
              case "object":
              case "embed":
                zn("load", E);
                break;
              case "video":
              case "audio":
                for (I = 0; I < Ra.length; I++) zn(Ra[I], E);
                break;
              case "source":
                zn("error", E);
                break;
              case "img":
              case "image":
              case "link":
                zn("error", E), zn("load", E);
                break;
              case "details":
                zn("toggle", E);
                break;
              case "input":
                Oe(E, N), zn("invalid", E);
                break;
              case "select":
                (E._wrapperState = { wasMultiple: !!N.multiple }),
                  zn("invalid", E);
                break;
              case "textarea":
                Se(E, N), zn("invalid", E);
            }
            he(v, N), (I = null);
            for (var q in N)
              if (N.hasOwnProperty(q)) {
                var pe = N[q];
                q === "children"
                  ? typeof pe == "string"
                    ? E.textContent !== pe &&
                      (N.suppressHydrationWarning !== !0 &&
                        dc(E.textContent, pe, l),
                      (I = ["children", pe]))
                    : typeof pe == "number" &&
                      E.textContent !== "" + pe &&
                      (N.suppressHydrationWarning !== !0 &&
                        dc(E.textContent, pe, l),
                      (I = ["children", "" + pe]))
                  : i.hasOwnProperty(q) &&
                    pe != null &&
                    q === "onScroll" &&
                    zn("scroll", E);
              }
            switch (v) {
              case "input":
                xe(E), De(E, N, !0);
                break;
              case "textarea":
                xe(E), Te(E);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof N.onClick == "function" && (E.onclick = hc);
            }
            (E = I), (f.updateQueue = E), E !== null && (f.flags |= 4);
          } else {
            (q = I.nodeType === 9 ? I : I.ownerDocument),
              l === "http://www.w3.org/1999/xhtml" && (l = at(v)),
              l === "http://www.w3.org/1999/xhtml"
                ? v === "script"
                  ? ((l = q.createElement("div")),
                    (l.innerHTML = "<script></script>"),
                    (l = l.removeChild(l.firstChild)))
                  : typeof E.is == "string"
                  ? (l = q.createElement(v, { is: E.is }))
                  : ((l = q.createElement(v)),
                    v === "select" &&
                      ((q = l),
                      E.multiple
                        ? (q.multiple = !0)
                        : E.size && (q.size = E.size)))
                : (l = q.createElementNS(l, v)),
              (l[Lr] = f),
              (l[du] = E),
              mb(l, f, !1, !1),
              (f.stateNode = l);
            e: {
              switch (((q = Je(v, E)), v)) {
                case "dialog":
                  zn("cancel", l), zn("close", l), (I = E);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  zn("load", l), (I = E);
                  break;
                case "video":
                case "audio":
                  for (I = 0; I < Ra.length; I++) zn(Ra[I], l);
                  I = E;
                  break;
                case "source":
                  zn("error", l), (I = E);
                  break;
                case "img":
                case "image":
                case "link":
                  zn("error", l), zn("load", l), (I = E);
                  break;
                case "details":
                  zn("toggle", l), (I = E);
                  break;
                case "input":
                  Oe(l, E), (I = Ae(l, E)), zn("invalid", l);
                  break;
                case "option":
                  I = E;
                  break;
                case "select":
                  (l._wrapperState = { wasMultiple: !!E.multiple }),
                    (I = F({}, E, { value: void 0 })),
                    zn("invalid", l);
                  break;
                case "textarea":
                  Se(l, E), (I = ve(l, E)), zn("invalid", l);
                  break;
                default:
                  I = E;
              }
              he(v, I), (pe = I);
              for (N in pe)
                if (pe.hasOwnProperty(N)) {
                  var ye = pe[N];
                  N === "style"
                    ? qe(l, ye)
                    : N === "dangerouslySetInnerHTML"
                    ? ((ye = ye ? ye.__html : void 0), ye != null && Ge(l, ye))
                    : N === "children"
                    ? typeof ye == "string"
                      ? (v !== "textarea" || ye !== "") && Ye(l, ye)
                      : typeof ye == "number" && Ye(l, "" + ye)
                    : N !== "suppressContentEditableWarning" &&
                      N !== "suppressHydrationWarning" &&
                      N !== "autoFocus" &&
                      (i.hasOwnProperty(N)
                        ? ye != null && N === "onScroll" && zn("scroll", l)
                        : ye != null && M(l, N, ye, q));
                }
              switch (v) {
                case "input":
                  xe(l), De(l, E, !1);
                  break;
                case "textarea":
                  xe(l), Te(l);
                  break;
                case "option":
                  E.value != null && l.setAttribute("value", "" + fe(E.value));
                  break;
                case "select":
                  (l.multiple = !!E.multiple),
                    (N = E.value),
                    N != null
                      ? B(l, !!E.multiple, N, !1)
                      : E.defaultValue != null &&
                        B(l, !!E.multiple, E.defaultValue, !0);
                  break;
                default:
                  typeof I.onClick == "function" && (l.onclick = hc);
              }
              switch (v) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  E = !!E.autoFocus;
                  break e;
                case "img":
                  E = !0;
                  break e;
                default:
                  E = !1;
              }
            }
            E && (f.flags |= 4);
          }
          f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152));
        }
        return Yi(f), null;
      case 6:
        if (l && f.stateNode != null) vb(l, f, l.memoizedProps, E);
        else {
          if (typeof E != "string" && f.stateNode === null) throw Error(t(166));
          if (((v = $i(Oa.current)), $i(Lo.current), hu(f))) {
            if (
              ((E = f.stateNode),
              (v = f.memoizedProps),
              (E[Lr] = f),
              (N = E.nodeValue !== v) && ((l = li), l !== null))
            )
              switch (l.tag) {
                case 3:
                  dc(E.nodeValue, v, (l.mode & 1) !== 0);
                  break;
                case 5:
                  l.memoizedProps.suppressHydrationWarning !== !0 &&
                    dc(E.nodeValue, v, (l.mode & 1) !== 0);
              }
            N && (f.flags |= 4);
          } else
            (E = (v.nodeType === 9 ? v : v.ownerDocument).createTextNode(E)),
              (E[Lr] = f),
              (f.stateNode = E);
        }
        return Yi(f), null;
      case 13:
        if (
          (Hn(Vn),
          (E = f.memoizedState),
          l === null ||
            (l.memoizedState !== null && l.memoizedState.dehydrated !== null))
        ) {
          if ($n && Ci !== null && (f.mode & 1) !== 0 && (f.flags & 128) === 0)
            xp(), Ia(), (f.flags |= 98560), (N = !1);
          else if (((N = hu(f)), E !== null && E.dehydrated !== null)) {
            if (l === null) {
              if (!N) throw Error(t(318));
              if (
                ((N = f.memoizedState),
                (N = N !== null ? N.dehydrated : null),
                !N)
              )
                throw Error(t(317));
              N[Lr] = f;
            } else
              Ia(),
                (f.flags & 128) === 0 && (f.memoizedState = null),
                (f.flags |= 4);
            Yi(f), (N = !1);
          } else Po !== null && (Vx(Po), (Po = null)), (N = !0);
          if (!N) return f.flags & 65536 ? f : null;
        }
        return (f.flags & 128) !== 0
          ? ((f.lanes = v), f)
          : ((E = E !== null),
            E !== (l !== null && l.memoizedState !== null) &&
              E &&
              ((f.child.flags |= 8192),
              (f.mode & 1) !== 0 &&
                (l === null || (Vn.current & 1) !== 0
                  ? ui === 0 && (ui = 3)
                  : jx())),
            f.updateQueue !== null && (f.flags |= 4),
            Yi(f),
            null);
      case 4:
        return (
          Ss(),
          Ix(l, f),
          l === null && uu(f.stateNode.containerInfo),
          Yi(f),
          null
        );
      case 10:
        return gu(f.type._context), Yi(f), null;
      case 17:
        return vi(f.type) && pc(), Yi(f), null;
      case 19:
        if ((Hn(Vn), (N = f.memoizedState), N === null)) return Yi(f), null;
        if (((E = (f.flags & 128) !== 0), (q = N.rendering), q === null))
          if (E) Ep(N, !1);
          else {
            if (ui !== 0 || (l !== null && (l.flags & 128) !== 0))
              for (l = f.child; l !== null; ) {
                if (((q = Zr(l)), q !== null)) {
                  for (
                    f.flags |= 128,
                      Ep(N, !1),
                      E = q.updateQueue,
                      E !== null && ((f.updateQueue = E), (f.flags |= 4)),
                      f.subtreeFlags = 0,
                      E = v,
                      v = f.child;
                    v !== null;

                  )
                    (N = v),
                      (l = E),
                      (N.flags &= 14680066),
                      (q = N.alternate),
                      q === null
                        ? ((N.childLanes = 0),
                          (N.lanes = l),
                          (N.child = null),
                          (N.subtreeFlags = 0),
                          (N.memoizedProps = null),
                          (N.memoizedState = null),
                          (N.updateQueue = null),
                          (N.dependencies = null),
                          (N.stateNode = null))
                        : ((N.childLanes = q.childLanes),
                          (N.lanes = q.lanes),
                          (N.child = q.child),
                          (N.subtreeFlags = 0),
                          (N.deletions = null),
                          (N.memoizedProps = q.memoizedProps),
                          (N.memoizedState = q.memoizedState),
                          (N.updateQueue = q.updateQueue),
                          (N.type = q.type),
                          (l = q.dependencies),
                          (N.dependencies =
                            l === null
                              ? null
                              : {
                                  lanes: l.lanes,
                                  firstContext: l.firstContext,
                                })),
                      (v = v.sibling);
                  return Nn(Vn, (Vn.current & 1) | 2), f.child;
                }
                l = l.sibling;
              }
            N.tail !== null &&
              Ke() > Pd &&
              ((f.flags |= 128), (E = !0), Ep(N, !1), (f.lanes = 4194304));
          }
        else {
          if (!E)
            if (((l = Zr(q)), l !== null)) {
              if (
                ((f.flags |= 128),
                (E = !0),
                (v = l.updateQueue),
                v !== null && ((f.updateQueue = v), (f.flags |= 4)),
                Ep(N, !0),
                N.tail === null &&
                  N.tailMode === "hidden" &&
                  !q.alternate &&
                  !$n)
              )
                return Yi(f), null;
            } else
              2 * Ke() - N.renderingStartTime > Pd &&
                v !== 1073741824 &&
                ((f.flags |= 128), (E = !0), Ep(N, !1), (f.lanes = 4194304));
          N.isBackwards
            ? ((q.sibling = f.child), (f.child = q))
            : ((v = N.last),
              v !== null ? (v.sibling = q) : (f.child = q),
              (N.last = q));
        }
        return N.tail !== null
          ? ((f = N.tail),
            (N.rendering = f),
            (N.tail = f.sibling),
            (N.renderingStartTime = Ke()),
            (f.sibling = null),
            (v = Vn.current),
            Nn(Vn, E ? (v & 1) | 2 : v & 1),
            f)
          : (Yi(f), null);
      case 22:
      case 23:
        return (
          Gx(),
          (E = f.memoizedState !== null),
          l !== null && (l.memoizedState !== null) !== E && (f.flags |= 8192),
          E && (f.mode & 1) !== 0
            ? (ns & 1073741824) !== 0 &&
              (Yi(f), f.subtreeFlags & 6 && (f.flags |= 8192))
            : Yi(f),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, f.tag));
  }
  function x3(l, f) {
    switch ((Zs(f), f.tag)) {
      case 1:
        return (
          vi(f.type) && pc(),
          (l = f.flags),
          l & 65536 ? ((f.flags = (l & -65537) | 128), f) : null
        );
      case 3:
        return (
          Ss(),
          Hn(Ei),
          Hn(ai),
          Xi(),
          (l = f.flags),
          (l & 65536) !== 0 && (l & 128) === 0
            ? ((f.flags = (l & -65537) | 128), f)
            : null
        );
      case 5:
        return Su(f), null;
      case 13:
        if (
          (Hn(Vn), (l = f.memoizedState), l !== null && l.dehydrated !== null)
        ) {
          if (f.alternate === null) throw Error(t(340));
          Ia();
        }
        return (
          (l = f.flags), l & 65536 ? ((f.flags = (l & -65537) | 128), f) : null
        );
      case 19:
        return Hn(Vn), null;
      case 4:
        return Ss(), null;
      case 10:
        return gu(f.type._context), null;
      case 22:
      case 23:
        return Gx(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Yg = !1,
    qi = !1,
    _3 = typeof WeakSet == "function" ? WeakSet : Set,
    Ct = null;
  function Ad(l, f) {
    var v = l.ref;
    if (v !== null)
      if (typeof v == "function")
        try {
          v(null);
        } catch (E) {
          wr(l, f, E);
        }
      else v.current = null;
  }
  function Lx(l, f, v) {
    try {
      v();
    } catch (E) {
      wr(l, f, E);
    }
  }
  var yb = !1;
  function S3(l, f) {
    if (((fu = Vr), (l = rr()), jr(l))) {
      if ("selectionStart" in l)
        var v = { start: l.selectionStart, end: l.selectionEnd };
      else
        e: {
          v = ((v = l.ownerDocument) && v.defaultView) || window;
          var E = v.getSelection && v.getSelection();
          if (E && E.rangeCount !== 0) {
            v = E.anchorNode;
            var I = E.anchorOffset,
              N = E.focusNode;
            E = E.focusOffset;
            try {
              v.nodeType, N.nodeType;
            } catch {
              v = null;
              break e;
            }
            var q = 0,
              pe = -1,
              ye = -1,
              je = 0,
              st = 0,
              lt = l,
              ot = null;
            t: for (;;) {
              for (
                var Mt;
                lt !== v || (I !== 0 && lt.nodeType !== 3) || (pe = q + I),
                  lt !== N || (E !== 0 && lt.nodeType !== 3) || (ye = q + E),
                  lt.nodeType === 3 && (q += lt.nodeValue.length),
                  (Mt = lt.firstChild) !== null;

              )
                (ot = lt), (lt = Mt);
              for (;;) {
                if (lt === l) break t;
                if (
                  (ot === v && ++je === I && (pe = q),
                  ot === N && ++st === E && (ye = q),
                  (Mt = lt.nextSibling) !== null)
                )
                  break;
                (lt = ot), (ot = lt.parentNode);
              }
              lt = Mt;
            }
            v = pe === -1 || ye === -1 ? null : { start: pe, end: ye };
          } else v = null;
        }
      v = v || { start: 0, end: 0 };
    } else v = null;
    for (
      ap = { focusedElem: l, selectionRange: v }, Vr = !1, Ct = f;
      Ct !== null;

    )
      if (
        ((f = Ct), (l = f.child), (f.subtreeFlags & 1028) !== 0 && l !== null)
      )
        (l.return = f), (Ct = l);
      else
        for (; Ct !== null; ) {
          f = Ct;
          try {
            var Rt = f.alternate;
            if ((f.flags & 1024) !== 0)
              switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Rt !== null) {
                    var Dt = Rt.memoizedProps,
                      kr = Rt.memoizedState,
                      ke = f.stateNode,
                      be = ke.getSnapshotBeforeUpdate(
                        f.elementType === f.type ? Dt : Jo(f.type, Dt),
                        kr
                      );
                    ke.__reactInternalSnapshotBeforeUpdate = be;
                  }
                  break;
                case 3:
                  var Ne = f.stateNode.containerInfo;
                  Ne.nodeType === 1
                    ? (Ne.textContent = "")
                    : Ne.nodeType === 9 &&
                      Ne.documentElement &&
                      Ne.removeChild(Ne.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (ft) {
            wr(f, f.return, ft);
          }
          if (((l = f.sibling), l !== null)) {
            (l.return = f.return), (Ct = l);
            break;
          }
          Ct = f.return;
        }
    return (Rt = yb), (yb = !1), Rt;
  }
  function Tp(l, f, v) {
    var E = f.updateQueue;
    if (((E = E !== null ? E.lastEffect : null), E !== null)) {
      var I = (E = E.next);
      do {
        if ((I.tag & l) === l) {
          var N = I.destroy;
          (I.destroy = void 0), N !== void 0 && Lx(f, v, N);
        }
        I = I.next;
      } while (I !== E);
    }
  }
  function qg(l, f) {
    if (
      ((f = f.updateQueue), (f = f !== null ? f.lastEffect : null), f !== null)
    ) {
      var v = (f = f.next);
      do {
        if ((v.tag & l) === l) {
          var E = v.create;
          v.destroy = E();
        }
        v = v.next;
      } while (v !== f);
    }
  }
  function Dx(l) {
    var f = l.ref;
    if (f !== null) {
      var v = l.stateNode;
      switch (l.tag) {
        case 5:
          l = v;
          break;
        default:
          l = v;
      }
      typeof f == "function" ? f(l) : (f.current = l);
    }
  }
  function xb(l) {
    var f = l.alternate;
    f !== null && ((l.alternate = null), xb(f)),
      (l.child = null),
      (l.deletions = null),
      (l.sibling = null),
      l.tag === 5 &&
        ((f = l.stateNode),
        f !== null &&
          (delete f[Lr],
          delete f[du],
          delete f[pl],
          delete f[ad],
          delete f[ld])),
      (l.stateNode = null),
      (l.return = null),
      (l.dependencies = null),
      (l.memoizedProps = null),
      (l.memoizedState = null),
      (l.pendingProps = null),
      (l.stateNode = null),
      (l.updateQueue = null);
  }
  function _b(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 4;
  }
  function Sb(l) {
    e: for (;;) {
      for (; l.sibling === null; ) {
        if (l.return === null || _b(l.return)) return null;
        l = l.return;
      }
      for (
        l.sibling.return = l.return, l = l.sibling;
        l.tag !== 5 && l.tag !== 6 && l.tag !== 18;

      ) {
        if (l.flags & 2 || l.child === null || l.tag === 4) continue e;
        (l.child.return = l), (l = l.child);
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function kx(l, f, v) {
    var E = l.tag;
    if (E === 5 || E === 6)
      (l = l.stateNode),
        f
          ? v.nodeType === 8
            ? v.parentNode.insertBefore(l, f)
            : v.insertBefore(l, f)
          : (v.nodeType === 8
              ? ((f = v.parentNode), f.insertBefore(l, v))
              : ((f = v), f.appendChild(l)),
            (v = v._reactRootContainer),
            v != null || f.onclick !== null || (f.onclick = hc));
    else if (E !== 4 && ((l = l.child), l !== null))
      for (kx(l, f, v), l = l.sibling; l !== null; )
        kx(l, f, v), (l = l.sibling);
  }
  function Ox(l, f, v) {
    var E = l.tag;
    if (E === 5 || E === 6)
      (l = l.stateNode), f ? v.insertBefore(l, f) : v.appendChild(l);
    else if (E !== 4 && ((l = l.child), l !== null))
      for (Ox(l, f, v), l = l.sibling; l !== null; )
        Ox(l, f, v), (l = l.sibling);
  }
  var Li = null,
    na = !1;
  function Eu(l, f, v) {
    for (v = v.child; v !== null; ) wb(l, f, v), (v = v.sibling);
  }
  function wb(l, f, v) {
    if (wt && typeof wt.onCommitFiberUnmount == "function")
      try {
        wt.onCommitFiberUnmount(Mn, v);
      } catch {}
    switch (v.tag) {
      case 5:
        qi || Ad(v, f);
      case 6:
        var E = Li,
          I = na;
        (Li = null),
          Eu(l, f, v),
          (Li = E),
          (na = I),
          Li !== null &&
            (na
              ? ((l = Li),
                (v = v.stateNode),
                l.nodeType === 8
                  ? l.parentNode.removeChild(v)
                  : l.removeChild(v))
              : Li.removeChild(v.stateNode));
        break;
      case 18:
        Li !== null &&
          (na
            ? ((l = Li),
              (v = v.stateNode),
              l.nodeType === 8
                ? sd(l.parentNode, v)
                : l.nodeType === 1 && sd(l, v),
              Sa(l))
            : sd(Li, v.stateNode));
        break;
      case 4:
        (E = Li),
          (I = na),
          (Li = v.stateNode.containerInfo),
          (na = !0),
          Eu(l, f, v),
          (Li = E),
          (na = I);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !qi &&
          ((E = v.updateQueue), E !== null && ((E = E.lastEffect), E !== null))
        ) {
          I = E = E.next;
          do {
            var N = I,
              q = N.destroy;
            (N = N.tag),
              q !== void 0 && ((N & 2) !== 0 || (N & 4) !== 0) && Lx(v, f, q),
              (I = I.next);
          } while (I !== E);
        }
        Eu(l, f, v);
        break;
      case 1:
        if (
          !qi &&
          (Ad(v, f),
          (E = v.stateNode),
          typeof E.componentWillUnmount == "function")
        )
          try {
            (E.props = v.memoizedProps),
              (E.state = v.memoizedState),
              E.componentWillUnmount();
          } catch (pe) {
            wr(v, f, pe);
          }
        Eu(l, f, v);
        break;
      case 21:
        Eu(l, f, v);
        break;
      case 22:
        v.mode & 1
          ? ((qi = (E = qi) || v.memoizedState !== null), Eu(l, f, v), (qi = E))
          : Eu(l, f, v);
        break;
      default:
        Eu(l, f, v);
    }
  }
  function bb(l) {
    var f = l.updateQueue;
    if (f !== null) {
      l.updateQueue = null;
      var v = l.stateNode;
      v === null && (v = l.stateNode = new _3()),
        f.forEach(function (E) {
          var I = P3.bind(null, l, E);
          v.has(E) || (v.add(E), E.then(I, I));
        });
    }
  }
  function ra(l, f) {
    var v = f.deletions;
    if (v !== null)
      for (var E = 0; E < v.length; E++) {
        var I = v[E];
        try {
          var N = l,
            q = f,
            pe = q;
          e: for (; pe !== null; ) {
            switch (pe.tag) {
              case 5:
                (Li = pe.stateNode), (na = !1);
                break e;
              case 3:
                (Li = pe.stateNode.containerInfo), (na = !0);
                break e;
              case 4:
                (Li = pe.stateNode.containerInfo), (na = !0);
                break e;
            }
            pe = pe.return;
          }
          if (Li === null) throw Error(t(160));
          wb(N, q, I), (Li = null), (na = !1);
          var ye = I.alternate;
          ye !== null && (ye.return = null), (I.return = null);
        } catch (je) {
          wr(I, f, je);
        }
      }
    if (f.subtreeFlags & 12854)
      for (f = f.child; f !== null; ) Mb(f, l), (f = f.sibling);
  }
  function Mb(l, f) {
    var v = l.alternate,
      E = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((ra(f, l), za(l), E & 4)) {
          try {
            Tp(3, l, l.return), qg(3, l);
          } catch (Dt) {
            wr(l, l.return, Dt);
          }
          try {
            Tp(5, l, l.return);
          } catch (Dt) {
            wr(l, l.return, Dt);
          }
        }
        break;
      case 1:
        ra(f, l), za(l), E & 512 && v !== null && Ad(v, v.return);
        break;
      case 5:
        if (
          (ra(f, l),
          za(l),
          E & 512 && v !== null && Ad(v, v.return),
          l.flags & 32)
        ) {
          var I = l.stateNode;
          try {
            Ye(I, "");
          } catch (Dt) {
            wr(l, l.return, Dt);
          }
        }
        if (E & 4 && ((I = l.stateNode), I != null)) {
          var N = l.memoizedProps,
            q = v !== null ? v.memoizedProps : N,
            pe = l.type,
            ye = l.updateQueue;
          if (((l.updateQueue = null), ye !== null))
            try {
              pe === "input" &&
                N.type === "radio" &&
                N.name != null &&
                Ie(I, N),
                Je(pe, q);
              var je = Je(pe, N);
              for (q = 0; q < ye.length; q += 2) {
                var st = ye[q],
                  lt = ye[q + 1];
                st === "style"
                  ? qe(I, lt)
                  : st === "dangerouslySetInnerHTML"
                  ? Ge(I, lt)
                  : st === "children"
                  ? Ye(I, lt)
                  : M(I, st, lt, je);
              }
              switch (pe) {
                case "input":
                  rt(I, N);
                  break;
                case "textarea":
                  _e(I, N);
                  break;
                case "select":
                  var ot = I._wrapperState.wasMultiple;
                  I._wrapperState.wasMultiple = !!N.multiple;
                  var Mt = N.value;
                  Mt != null
                    ? B(I, !!N.multiple, Mt, !1)
                    : ot !== !!N.multiple &&
                      (N.defaultValue != null
                        ? B(I, !!N.multiple, N.defaultValue, !0)
                        : B(I, !!N.multiple, N.multiple ? [] : "", !1));
              }
              I[du] = N;
            } catch (Dt) {
              wr(l, l.return, Dt);
            }
        }
        break;
      case 6:
        if ((ra(f, l), za(l), E & 4)) {
          if (l.stateNode === null) throw Error(t(162));
          (I = l.stateNode), (N = l.memoizedProps);
          try {
            I.nodeValue = N;
          } catch (Dt) {
            wr(l, l.return, Dt);
          }
        }
        break;
      case 3:
        if (
          (ra(f, l), za(l), E & 4 && v !== null && v.memoizedState.isDehydrated)
        )
          try {
            Sa(f.containerInfo);
          } catch (Dt) {
            wr(l, l.return, Dt);
          }
        break;
      case 4:
        ra(f, l), za(l);
        break;
      case 13:
        ra(f, l),
          za(l),
          (I = l.child),
          I.flags & 8192 &&
            ((N = I.memoizedState !== null),
            (I.stateNode.isHidden = N),
            !N ||
              (I.alternate !== null && I.alternate.memoizedState !== null) ||
              (Fx = Ke())),
          E & 4 && bb(l);
        break;
      case 22:
        if (
          ((st = v !== null && v.memoizedState !== null),
          l.mode & 1 ? ((qi = (je = qi) || st), ra(f, l), (qi = je)) : ra(f, l),
          za(l),
          E & 8192)
        ) {
          if (
            ((je = l.memoizedState !== null),
            (l.stateNode.isHidden = je) && !st && (l.mode & 1) !== 0)
          )
            for (Ct = l, st = l.child; st !== null; ) {
              for (lt = Ct = st; Ct !== null; ) {
                switch (((ot = Ct), (Mt = ot.child), ot.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Tp(4, ot, ot.return);
                    break;
                  case 1:
                    Ad(ot, ot.return);
                    var Rt = ot.stateNode;
                    if (typeof Rt.componentWillUnmount == "function") {
                      (E = ot), (v = ot.return);
                      try {
                        (f = E),
                          (Rt.props = f.memoizedProps),
                          (Rt.state = f.memoizedState),
                          Rt.componentWillUnmount();
                      } catch (Dt) {
                        wr(E, v, Dt);
                      }
                    }
                    break;
                  case 5:
                    Ad(ot, ot.return);
                    break;
                  case 22:
                    if (ot.memoizedState !== null) {
                      Cb(lt);
                      continue;
                    }
                }
                Mt !== null ? ((Mt.return = ot), (Ct = Mt)) : Cb(lt);
              }
              st = st.sibling;
            }
          e: for (st = null, lt = l; ; ) {
            if (lt.tag === 5) {
              if (st === null) {
                st = lt;
                try {
                  (I = lt.stateNode),
                    je
                      ? ((N = I.style),
                        typeof N.setProperty == "function"
                          ? N.setProperty("display", "none", "important")
                          : (N.display = "none"))
                      : ((pe = lt.stateNode),
                        (ye = lt.memoizedProps.style),
                        (q =
                          ye != null && ye.hasOwnProperty("display")
                            ? ye.display
                            : null),
                        (pe.style.display = $e("display", q)));
                } catch (Dt) {
                  wr(l, l.return, Dt);
                }
              }
            } else if (lt.tag === 6) {
              if (st === null)
                try {
                  lt.stateNode.nodeValue = je ? "" : lt.memoizedProps;
                } catch (Dt) {
                  wr(l, l.return, Dt);
                }
            } else if (
              ((lt.tag !== 22 && lt.tag !== 23) ||
                lt.memoizedState === null ||
                lt === l) &&
              lt.child !== null
            ) {
              (lt.child.return = lt), (lt = lt.child);
              continue;
            }
            if (lt === l) break e;
            for (; lt.sibling === null; ) {
              if (lt.return === null || lt.return === l) break e;
              st === lt && (st = null), (lt = lt.return);
            }
            st === lt && (st = null),
              (lt.sibling.return = lt.return),
              (lt = lt.sibling);
          }
        }
        break;
      case 19:
        ra(f, l), za(l), E & 4 && bb(l);
        break;
      case 21:
        break;
      default:
        ra(f, l), za(l);
    }
  }
  function za(l) {
    var f = l.flags;
    if (f & 2) {
      try {
        e: {
          for (var v = l.return; v !== null; ) {
            if (_b(v)) {
              var E = v;
              break e;
            }
            v = v.return;
          }
          throw Error(t(160));
        }
        switch (E.tag) {
          case 5:
            var I = E.stateNode;
            E.flags & 32 && (Ye(I, ""), (E.flags &= -33));
            var N = Sb(l);
            Ox(l, N, I);
            break;
          case 3:
          case 4:
            var q = E.stateNode.containerInfo,
              pe = Sb(l);
            kx(l, pe, q);
            break;
          default:
            throw Error(t(161));
        }
      } catch (ye) {
        wr(l, l.return, ye);
      }
      l.flags &= -3;
    }
    f & 4096 && (l.flags &= -4097);
  }
  function w3(l, f, v) {
    (Ct = l), Eb(l);
  }
  function Eb(l, f, v) {
    for (var E = (l.mode & 1) !== 0; Ct !== null; ) {
      var I = Ct,
        N = I.child;
      if (I.tag === 22 && E) {
        var q = I.memoizedState !== null || Yg;
        if (!q) {
          var pe = I.alternate,
            ye = (pe !== null && pe.memoizedState !== null) || qi;
          pe = Yg;
          var je = qi;
          if (((Yg = q), (qi = ye) && !je))
            for (Ct = I; Ct !== null; )
              (q = Ct),
                (ye = q.child),
                q.tag === 22 && q.memoizedState !== null
                  ? Ab(I)
                  : ye !== null
                  ? ((ye.return = q), (Ct = ye))
                  : Ab(I);
          for (; N !== null; ) (Ct = N), Eb(N), (N = N.sibling);
          (Ct = I), (Yg = pe), (qi = je);
        }
        Tb(l);
      } else
        (I.subtreeFlags & 8772) !== 0 && N !== null
          ? ((N.return = I), (Ct = N))
          : Tb(l);
    }
  }
  function Tb(l) {
    for (; Ct !== null; ) {
      var f = Ct;
      if ((f.flags & 8772) !== 0) {
        var v = f.alternate;
        try {
          if ((f.flags & 8772) !== 0)
            switch (f.tag) {
              case 0:
              case 11:
              case 15:
                qi || qg(5, f);
                break;
              case 1:
                var E = f.stateNode;
                if (f.flags & 4 && !qi)
                  if (v === null) E.componentDidMount();
                  else {
                    var I =
                      f.elementType === f.type
                        ? v.memoizedProps
                        : Jo(f.type, v.memoizedProps);
                    E.componentDidUpdate(
                      I,
                      v.memoizedState,
                      E.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var N = f.updateQueue;
                N !== null && pr(f, N, E);
                break;
              case 3:
                var q = f.updateQueue;
                if (q !== null) {
                  if (((v = null), f.child !== null))
                    switch (f.child.tag) {
                      case 5:
                        v = f.child.stateNode;
                        break;
                      case 1:
                        v = f.child.stateNode;
                    }
                  pr(f, q, v);
                }
                break;
              case 5:
                var pe = f.stateNode;
                if (v === null && f.flags & 4) {
                  v = pe;
                  var ye = f.memoizedProps;
                  switch (f.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ye.autoFocus && v.focus();
                      break;
                    case "img":
                      ye.src && (v.src = ye.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (f.memoizedState === null) {
                  var je = f.alternate;
                  if (je !== null) {
                    var st = je.memoizedState;
                    if (st !== null) {
                      var lt = st.dehydrated;
                      lt !== null && Sa(lt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          qi || (f.flags & 512 && Dx(f));
        } catch (ot) {
          wr(f, f.return, ot);
        }
      }
      if (f === l) {
        Ct = null;
        break;
      }
      if (((v = f.sibling), v !== null)) {
        (v.return = f.return), (Ct = v);
        break;
      }
      Ct = f.return;
    }
  }
  function Cb(l) {
    for (; Ct !== null; ) {
      var f = Ct;
      if (f === l) {
        Ct = null;
        break;
      }
      var v = f.sibling;
      if (v !== null) {
        (v.return = f.return), (Ct = v);
        break;
      }
      Ct = f.return;
    }
  }
  function Ab(l) {
    for (; Ct !== null; ) {
      var f = Ct;
      try {
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            var v = f.return;
            try {
              qg(4, f);
            } catch (ye) {
              wr(f, v, ye);
            }
            break;
          case 1:
            var E = f.stateNode;
            if (typeof E.componentDidMount == "function") {
              var I = f.return;
              try {
                E.componentDidMount();
              } catch (ye) {
                wr(f, I, ye);
              }
            }
            var N = f.return;
            try {
              Dx(f);
            } catch (ye) {
              wr(f, N, ye);
            }
            break;
          case 5:
            var q = f.return;
            try {
              Dx(f);
            } catch (ye) {
              wr(f, q, ye);
            }
        }
      } catch (ye) {
        wr(f, f.return, ye);
      }
      if (f === l) {
        Ct = null;
        break;
      }
      var pe = f.sibling;
      if (pe !== null) {
        (pe.return = f.return), (Ct = pe);
        break;
      }
      Ct = f.return;
    }
  }
  var b3 = Math.ceil,
    Kg = A.ReactCurrentDispatcher,
    Nx = A.ReactCurrentOwner,
    Ms = A.ReactCurrentBatchConfig,
    xn = 0,
    xi = null,
    Qr = null,
    Di = 0,
    ns = 0,
    Rd = or(0),
    ui = 0,
    Cp = null,
    Ac = 0,
    Zg = 0,
    Ux = 0,
    Ap = null,
    Oo = null,
    Fx = 0,
    Pd = 1 / 0,
    El = null,
    Jg = !1,
    Bx = null,
    Tu = null,
    Qg = !1,
    Cu = null,
    ev = 0,
    Rp = 0,
    zx = null,
    tv = -1,
    nv = 0;
  function go() {
    return (xn & 6) !== 0 ? Ke() : tv !== -1 ? tv : (tv = Ke());
  }
  function Au(l) {
    return (l.mode & 1) === 0
      ? 1
      : (xn & 2) !== 0 && Di !== 0
      ? Di & -Di
      : Ax.transition !== null
      ? (nv === 0 && (nv = pi()), nv)
      : ((l = ln),
        l !== 0 || ((l = window.event), (l = l === void 0 ? 16 : ba(l.type))),
        l);
  }
  function ia(l, f, v, E) {
    if (50 < Rp) throw ((Rp = 0), (zx = null), Error(t(185)));
    Go(l, v, E),
      ((xn & 2) === 0 || l !== xi) &&
        (l === xi && ((xn & 2) === 0 && (Zg |= v), ui === 4 && Ru(l, Di)),
        No(l, E),
        v === 1 &&
          xn === 0 &&
          (f.mode & 1) === 0 &&
          ((Pd = Ke() + 500), gc && xs()));
  }
  function No(l, f) {
    var v = l.callbackNode;
    fr(l, f);
    var E = zr(l, l === xi ? Di : 0);
    if (E === 0)
      v !== null && ut(v), (l.callbackNode = null), (l.callbackPriority = 0);
    else if (((f = E & -E), l.callbackPriority !== f)) {
      if ((v != null && ut(v), f === 1))
        l.tag === 0 ? Dg(Pb.bind(null, l)) : vc(Pb.bind(null, l)),
          Cx(function () {
            (xn & 6) === 0 && xs();
          }),
          (v = null);
      else {
        switch (hs(E)) {
          case 1:
            v = Ft;
            break;
          case 4:
            v = At;
            break;
          case 16:
            v = tn;
            break;
          case 536870912:
            v = pn;
            break;
          default:
            v = tn;
        }
        v = Fb(v, Rb.bind(null, l));
      }
      (l.callbackPriority = f), (l.callbackNode = v);
    }
  }
  function Rb(l, f) {
    if (((tv = -1), (nv = 0), (xn & 6) !== 0)) throw Error(t(327));
    var v = l.callbackNode;
    if (Id() && l.callbackNode !== v) return null;
    var E = zr(l, l === xi ? Di : 0);
    if (E === 0) return null;
    if ((E & 30) !== 0 || (E & l.expiredLanes) !== 0 || f) f = rv(l, E);
    else {
      f = E;
      var I = xn;
      xn |= 2;
      var N = Lb();
      (xi !== l || Di !== f) && ((El = null), (Pd = Ke() + 500), Pc(l, f));
      do
        try {
          T3();
          break;
        } catch (pe) {
          Ib(l, pe);
        }
      while (!0);
      mu(),
        (Kg.current = N),
        (xn = I),
        Qr !== null ? (f = 0) : ((xi = null), (Di = 0), (f = ui));
    }
    if (f !== 0) {
      if (
        (f === 2 && ((I = Rr(l)), I !== 0 && ((E = I), (f = Hx(l, I)))),
        f === 1)
      )
        throw ((v = Cp), Pc(l, 0), Ru(l, E), No(l, Ke()), v);
      if (f === 6) Ru(l, E);
      else {
        if (
          ((I = l.current.alternate),
          (E & 30) === 0 &&
            !M3(I) &&
            ((f = rv(l, E)),
            f === 2 && ((N = Rr(l)), N !== 0 && ((E = N), (f = Hx(l, N)))),
            f === 1))
        )
          throw ((v = Cp), Pc(l, 0), Ru(l, E), No(l, Ke()), v);
        switch (((l.finishedWork = I), (l.finishedLanes = E), f)) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            Ic(l, Oo, El);
            break;
          case 3:
            if (
              (Ru(l, E),
              (E & 130023424) === E && ((f = Fx + 500 - Ke()), 10 < f))
            ) {
              if (zr(l, 0) !== 0) break;
              if (((I = l.suspendedLanes), (I & E) !== E)) {
                go(), (l.pingedLanes |= l.suspendedLanes & I);
                break;
              }
              l.timeoutHandle = up(Ic.bind(null, l, Oo, El), f);
              break;
            }
            Ic(l, Oo, El);
            break;
          case 4:
            if ((Ru(l, E), (E & 4194240) === E)) break;
            for (f = l.eventTimes, I = -1; 0 < E; ) {
              var q = 31 - Jt(E);
              (N = 1 << q), (q = f[q]), q > I && (I = q), (E &= ~N);
            }
            if (
              ((E = I),
              (E = Ke() - E),
              (E =
                (120 > E
                  ? 120
                  : 480 > E
                  ? 480
                  : 1080 > E
                  ? 1080
                  : 1920 > E
                  ? 1920
                  : 3e3 > E
                  ? 3e3
                  : 4320 > E
                  ? 4320
                  : 1960 * b3(E / 1960)) - E),
              10 < E)
            ) {
              l.timeoutHandle = up(Ic.bind(null, l, Oo, El), E);
              break;
            }
            Ic(l, Oo, El);
            break;
          case 5:
            Ic(l, Oo, El);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return No(l, Ke()), l.callbackNode === v ? Rb.bind(null, l) : null;
  }
  function Hx(l, f) {
    var v = Ap;
    return (
      l.current.memoizedState.isDehydrated && (Pc(l, f).flags |= 256),
      (l = rv(l, f)),
      l !== 2 && ((f = Oo), (Oo = v), f !== null && Vx(f)),
      l
    );
  }
  function Vx(l) {
    Oo === null ? (Oo = l) : Oo.push.apply(Oo, l);
  }
  function M3(l) {
    for (var f = l; ; ) {
      if (f.flags & 16384) {
        var v = f.updateQueue;
        if (v !== null && ((v = v.stores), v !== null))
          for (var E = 0; E < v.length; E++) {
            var I = v[E],
              N = I.getSnapshot;
            I = I.value;
            try {
              if (!uo(N(), I)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((v = f.child), f.subtreeFlags & 16384 && v !== null))
        (v.return = f), (f = v);
      else {
        if (f === l) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === l) return !0;
          f = f.return;
        }
        (f.sibling.return = f.return), (f = f.sibling);
      }
    }
    return !0;
  }
  function Ru(l, f) {
    for (
      f &= ~Ux,
        f &= ~Zg,
        l.suspendedLanes |= f,
        l.pingedLanes &= ~f,
        l = l.expirationTimes;
      0 < f;

    ) {
      var v = 31 - Jt(f),
        E = 1 << v;
      (l[v] = -1), (f &= ~E);
    }
  }
  function Pb(l) {
    if ((xn & 6) !== 0) throw Error(t(327));
    Id();
    var f = zr(l, 0);
    if ((f & 1) === 0) return No(l, Ke()), null;
    var v = rv(l, f);
    if (l.tag !== 0 && v === 2) {
      var E = Rr(l);
      E !== 0 && ((f = E), (v = Hx(l, E)));
    }
    if (v === 1) throw ((v = Cp), Pc(l, 0), Ru(l, f), No(l, Ke()), v);
    if (v === 6) throw Error(t(345));
    return (
      (l.finishedWork = l.current.alternate),
      (l.finishedLanes = f),
      Ic(l, Oo, El),
      No(l, Ke()),
      null
    );
  }
  function Wx(l, f) {
    var v = xn;
    xn |= 1;
    try {
      return l(f);
    } finally {
      (xn = v), xn === 0 && ((Pd = Ke() + 500), gc && xs());
    }
  }
  function Rc(l) {
    Cu !== null && Cu.tag === 0 && (xn & 6) === 0 && Id();
    var f = xn;
    xn |= 1;
    var v = Ms.transition,
      E = ln;
    try {
      if (((Ms.transition = null), (ln = 1), l)) return l();
    } finally {
      (ln = E), (Ms.transition = v), (xn = f), (xn & 6) === 0 && xs();
    }
  }
  function Gx() {
    (ns = Rd.current), Hn(Rd);
  }
  function Pc(l, f) {
    (l.finishedWork = null), (l.finishedLanes = 0);
    var v = l.timeoutHandle;
    if ((v !== -1 && ((l.timeoutHandle = -1), cp(v)), Qr !== null))
      for (v = Qr.return; v !== null; ) {
        var E = v;
        switch ((Zs(E), E.tag)) {
          case 1:
            (E = E.type.childContextTypes), E != null && pc();
            break;
          case 3:
            Ss(), Hn(Ei), Hn(ai), Xi();
            break;
          case 5:
            Su(E);
            break;
          case 4:
            Ss();
            break;
          case 13:
            Hn(Vn);
            break;
          case 19:
            Hn(Vn);
            break;
          case 10:
            gu(E.type._context);
            break;
          case 22:
          case 23:
            Gx();
        }
        v = v.return;
      }
    if (
      ((xi = l),
      (Qr = l = Pu(l.current, null)),
      (Di = ns = f),
      (ui = 0),
      (Cp = null),
      (Ux = Zg = Ac = 0),
      (Oo = Ap = null),
      Qo !== null)
    ) {
      for (f = 0; f < Qo.length; f++)
        if (((v = Qo[f]), (E = v.interleaved), E !== null)) {
          v.interleaved = null;
          var I = E.next,
            N = v.pending;
          if (N !== null) {
            var q = N.next;
            (N.next = I), (E.next = q);
          }
          v.pending = E;
        }
      Qo = null;
    }
    return l;
  }
  function Ib(l, f) {
    do {
      var v = Qr;
      try {
        if ((mu(), (bl.current = h), ts)) {
          for (var E = Xn.memoizedState; E !== null; ) {
            var I = E.queue;
            I !== null && (I.pending = null), (E = E.next);
          }
          ts = !1;
        }
        if (
          ((Na = 0),
          (Jr = mr = Xn = null),
          (wu = !1),
          (bu = 0),
          (Nx.current = null),
          v === null || v.return === null)
        ) {
          (ui = 1), (Cp = f), (Qr = null);
          break;
        }
        e: {
          var N = l,
            q = v.return,
            pe = v,
            ye = f;
          if (
            ((f = Di),
            (pe.flags |= 32768),
            ye !== null &&
              typeof ye == "object" &&
              typeof ye.then == "function")
          ) {
            var je = ye,
              st = pe,
              lt = st.tag;
            if ((st.mode & 1) === 0 && (lt === 0 || lt === 11 || lt === 15)) {
              var ot = st.alternate;
              ot
                ? ((st.updateQueue = ot.updateQueue),
                  (st.memoizedState = ot.memoizedState),
                  (st.lanes = ot.lanes))
                : ((st.updateQueue = null), (st.memoizedState = null));
            }
            var Mt = Kt(q);
            if (Mt !== null) {
              (Mt.flags &= -257),
                Bt(Mt, q, pe, N, f),
                Mt.mode & 1 && Tt(N, je, f),
                (f = Mt),
                (ye = je);
              var Rt = f.updateQueue;
              if (Rt === null) {
                var Dt = new Set();
                Dt.add(ye), (f.updateQueue = Dt);
              } else Rt.add(ye);
              break e;
            } else {
              if ((f & 1) === 0) {
                Tt(N, je, f), jx();
                break e;
              }
              ye = Error(t(426));
            }
          } else if ($n && pe.mode & 1) {
            var kr = Kt(q);
            if (kr !== null) {
              (kr.flags & 65536) === 0 && (kr.flags |= 256),
                Bt(kr, q, pe, N, f),
                pu(k(ye, pe));
              break e;
            }
          }
          (N = ye = k(ye, pe)),
            ui !== 4 && (ui = 2),
            Ap === null ? (Ap = [N]) : Ap.push(N),
            (N = q);
          do {
            switch (N.tag) {
              case 3:
                (N.flags |= 65536), (f &= -f), (N.lanes |= f);
                var ke = Qe(N, ye, f);
                nn(N, ke);
                break e;
              case 1:
                pe = ye;
                var be = N.type,
                  Ne = N.stateNode;
                if (
                  (N.flags & 128) === 0 &&
                  (typeof be.getDerivedStateFromError == "function" ||
                    (Ne !== null &&
                      typeof Ne.componentDidCatch == "function" &&
                      (Tu === null || !Tu.has(Ne))))
                ) {
                  (N.flags |= 65536), (f &= -f), (N.lanes |= f);
                  var ft = ct(N, pe, f);
                  nn(N, ft);
                  break e;
                }
            }
            N = N.return;
          } while (N !== null);
        }
        kb(v);
      } catch (Ot) {
        (f = Ot), Qr === v && v !== null && (Qr = v = v.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Lb() {
    var l = Kg.current;
    return (Kg.current = h), l === null ? h : l;
  }
  function jx() {
    (ui === 0 || ui === 3 || ui === 2) && (ui = 4),
      xi === null ||
        ((Ac & 268435455) === 0 && (Zg & 268435455) === 0) ||
        Ru(xi, Di);
  }
  function rv(l, f) {
    var v = xn;
    xn |= 2;
    var E = Lb();
    (xi !== l || Di !== f) && ((El = null), Pc(l, f));
    do
      try {
        E3();
        break;
      } catch (I) {
        Ib(l, I);
      }
    while (!0);
    if ((mu(), (xn = v), (Kg.current = E), Qr !== null)) throw Error(t(261));
    return (xi = null), (Di = 0), ui;
  }
  function E3() {
    for (; Qr !== null; ) Db(Qr);
  }
  function T3() {
    for (; Qr !== null && !yt(); ) Db(Qr);
  }
  function Db(l) {
    var f = Ub(l.alternate, l, ns);
    (l.memoizedProps = l.pendingProps),
      f === null ? kb(l) : (Qr = f),
      (Nx.current = null);
  }
  function kb(l) {
    var f = l;
    do {
      var v = f.alternate;
      if (((l = f.return), (f.flags & 32768) === 0)) {
        if (((v = y3(v, f, ns)), v !== null)) {
          Qr = v;
          return;
        }
      } else {
        if (((v = x3(v, f)), v !== null)) {
          (v.flags &= 32767), (Qr = v);
          return;
        }
        if (l !== null)
          (l.flags |= 32768), (l.subtreeFlags = 0), (l.deletions = null);
        else {
          (ui = 6), (Qr = null);
          return;
        }
      }
      if (((f = f.sibling), f !== null)) {
        Qr = f;
        return;
      }
      Qr = f = l;
    } while (f !== null);
    ui === 0 && (ui = 5);
  }
  function Ic(l, f, v) {
    var E = ln,
      I = Ms.transition;
    try {
      (Ms.transition = null), (ln = 1), C3(l, f, v, E);
    } finally {
      (Ms.transition = I), (ln = E);
    }
    return null;
  }
  function C3(l, f, v, E) {
    do Id();
    while (Cu !== null);
    if ((xn & 6) !== 0) throw Error(t(327));
    v = l.finishedWork;
    var I = l.finishedLanes;
    if (v === null) return null;
    if (((l.finishedWork = null), (l.finishedLanes = 0), v === l.current))
      throw Error(t(177));
    (l.callbackNode = null), (l.callbackPriority = 0);
    var N = v.lanes | v.childLanes;
    if (
      (Uf(l, N),
      l === xi && ((Qr = xi = null), (Di = 0)),
      ((v.subtreeFlags & 2064) === 0 && (v.flags & 2064) === 0) ||
        Qg ||
        ((Qg = !0),
        Fb(tn, function () {
          return Id(), null;
        })),
      (N = (v.flags & 15990) !== 0),
      (v.subtreeFlags & 15990) !== 0 || N)
    ) {
      (N = Ms.transition), (Ms.transition = null);
      var q = ln;
      ln = 1;
      var pe = xn;
      (xn |= 4),
        (Nx.current = null),
        S3(l, v),
        Mb(v, l),
        $r(ap),
        (Vr = !!fu),
        (ap = fu = null),
        (l.current = v),
        w3(v),
        Et(),
        (xn = pe),
        (ln = q),
        (Ms.transition = N);
    } else l.current = v;
    if (
      (Qg && ((Qg = !1), (Cu = l), (ev = I)),
      (N = l.pendingLanes),
      N === 0 && (Tu = null),
      dt(v.stateNode),
      No(l, Ke()),
      f !== null)
    )
      for (E = l.onRecoverableError, v = 0; v < f.length; v++)
        (I = f[v]), E(I.value, { componentStack: I.stack, digest: I.digest });
    if (Jg) throw ((Jg = !1), (l = Bx), (Bx = null), l);
    return (
      (ev & 1) !== 0 && l.tag !== 0 && Id(),
      (N = l.pendingLanes),
      (N & 1) !== 0 ? (l === zx ? Rp++ : ((Rp = 0), (zx = l))) : (Rp = 0),
      xs(),
      null
    );
  }
  function Id() {
    if (Cu !== null) {
      var l = hs(ev),
        f = Ms.transition,
        v = ln;
      try {
        if (((Ms.transition = null), (ln = 16 > l ? 16 : l), Cu === null))
          var E = !1;
        else {
          if (((l = Cu), (Cu = null), (ev = 0), (xn & 6) !== 0))
            throw Error(t(331));
          var I = xn;
          for (xn |= 4, Ct = l.current; Ct !== null; ) {
            var N = Ct,
              q = N.child;
            if ((Ct.flags & 16) !== 0) {
              var pe = N.deletions;
              if (pe !== null) {
                for (var ye = 0; ye < pe.length; ye++) {
                  var je = pe[ye];
                  for (Ct = je; Ct !== null; ) {
                    var st = Ct;
                    switch (st.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Tp(8, st, N);
                    }
                    var lt = st.child;
                    if (lt !== null) (lt.return = st), (Ct = lt);
                    else
                      for (; Ct !== null; ) {
                        st = Ct;
                        var ot = st.sibling,
                          Mt = st.return;
                        if ((xb(st), st === je)) {
                          Ct = null;
                          break;
                        }
                        if (ot !== null) {
                          (ot.return = Mt), (Ct = ot);
                          break;
                        }
                        Ct = Mt;
                      }
                  }
                }
                var Rt = N.alternate;
                if (Rt !== null) {
                  var Dt = Rt.child;
                  if (Dt !== null) {
                    Rt.child = null;
                    do {
                      var kr = Dt.sibling;
                      (Dt.sibling = null), (Dt = kr);
                    } while (Dt !== null);
                  }
                }
                Ct = N;
              }
            }
            if ((N.subtreeFlags & 2064) !== 0 && q !== null)
              (q.return = N), (Ct = q);
            else
              e: for (; Ct !== null; ) {
                if (((N = Ct), (N.flags & 2048) !== 0))
                  switch (N.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Tp(9, N, N.return);
                  }
                var ke = N.sibling;
                if (ke !== null) {
                  (ke.return = N.return), (Ct = ke);
                  break e;
                }
                Ct = N.return;
              }
          }
          var be = l.current;
          for (Ct = be; Ct !== null; ) {
            q = Ct;
            var Ne = q.child;
            if ((q.subtreeFlags & 2064) !== 0 && Ne !== null)
              (Ne.return = q), (Ct = Ne);
            else
              e: for (q = be; Ct !== null; ) {
                if (((pe = Ct), (pe.flags & 2048) !== 0))
                  try {
                    switch (pe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        qg(9, pe);
                    }
                  } catch (Ot) {
                    wr(pe, pe.return, Ot);
                  }
                if (pe === q) {
                  Ct = null;
                  break e;
                }
                var ft = pe.sibling;
                if (ft !== null) {
                  (ft.return = pe.return), (Ct = ft);
                  break e;
                }
                Ct = pe.return;
              }
          }
          if (
            ((xn = I),
            xs(),
            wt && typeof wt.onPostCommitFiberRoot == "function")
          )
            try {
              wt.onPostCommitFiberRoot(Mn, l);
            } catch {}
          E = !0;
        }
        return E;
      } finally {
        (ln = v), (Ms.transition = f);
      }
    }
    return !1;
  }
  function Ob(l, f, v) {
    (f = k(v, f)),
      (f = Qe(l, f, 1)),
      (l = _s(l, f, 1)),
      (f = go()),
      l !== null && (Go(l, 1, f), No(l, f));
  }
  function wr(l, f, v) {
    if (l.tag === 3) Ob(l, l, v);
    else
      for (; f !== null; ) {
        if (f.tag === 3) {
          Ob(f, l, v);
          break;
        } else if (f.tag === 1) {
          var E = f.stateNode;
          if (
            typeof f.type.getDerivedStateFromError == "function" ||
            (typeof E.componentDidCatch == "function" &&
              (Tu === null || !Tu.has(E)))
          ) {
            (l = k(v, l)),
              (l = ct(f, l, 1)),
              (f = _s(f, l, 1)),
              (l = go()),
              f !== null && (Go(f, 1, l), No(f, l));
            break;
          }
        }
        f = f.return;
      }
  }
  function A3(l, f, v) {
    var E = l.pingCache;
    E !== null && E.delete(f),
      (f = go()),
      (l.pingedLanes |= l.suspendedLanes & v),
      xi === l &&
        (Di & v) === v &&
        (ui === 4 || (ui === 3 && (Di & 130023424) === Di && 500 > Ke() - Fx)
          ? Pc(l, 0)
          : (Ux |= v)),
      No(l, f);
  }
  function Nb(l, f) {
    f === 0 &&
      ((l.mode & 1) === 0
        ? (f = 1)
        : ((f = jn), (jn <<= 1), (jn & 130023424) === 0 && (jn = 4194304)));
    var v = go();
    (l = es(l, f)), l !== null && (Go(l, f, v), No(l, v));
  }
  function R3(l) {
    var f = l.memoizedState,
      v = 0;
    f !== null && (v = f.retryLane), Nb(l, v);
  }
  function P3(l, f) {
    var v = 0;
    switch (l.tag) {
      case 13:
        var E = l.stateNode,
          I = l.memoizedState;
        I !== null && (v = I.retryLane);
        break;
      case 19:
        E = l.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    E !== null && E.delete(f), Nb(l, v);
  }
  var Ub;
  Ub = function (l, f, v) {
    if (l !== null)
      if (l.memoizedProps !== f.pendingProps || Ei.current) bt = !0;
      else {
        if ((l.lanes & v) === 0 && (f.flags & 128) === 0)
          return (bt = !1), v3(l, f, v);
        bt = (l.flags & 131072) !== 0;
      }
    else (bt = !1), $n && (f.flags & 1048576) !== 0 && mp(f, dd, f.index);
    switch (((f.lanes = 0), f.tag)) {
      case 2:
        var E = f.type;
        Xg(l, f), (l = f.pendingProps);
        var I = ml(f, ai.current);
        Js(f, v), (I = Sd(null, f, E, l, I, v));
        var N = wc();
        return (
          (f.flags |= 1),
          typeof I == "object" &&
          I !== null &&
          typeof I.render == "function" &&
          I.$$typeof === void 0
            ? ((f.tag = 1),
              (f.memoizedState = null),
              (f.updateQueue = null),
              vi(E) ? ((N = !0), gl(f)) : (N = !1),
              (f.memoizedState =
                I.state !== null && I.state !== void 0 ? I.state : null),
              Sc(f),
              (I.updater = ea),
              (f.stateNode = I),
              (I._reactInternals = f),
              xu(f, E, l, v),
              (f = Yt(null, f, E, !0, N, v)))
            : ((f.tag = 0), $n && N && gp(f), Tn(null, f, I, v), (f = f.child)),
          f
        );
      case 16:
        E = f.elementType;
        e: {
          switch (
            (Xg(l, f),
            (l = f.pendingProps),
            (I = E._init),
            (E = I(E._payload)),
            (f.type = E),
            (I = f.tag = L3(E)),
            (l = Jo(E, l)),
            I)
          ) {
            case 0:
              f = Lt(null, f, E, l, v);
              break e;
            case 1:
              f = Qt(null, f, E, l, v);
              break e;
            case 11:
              f = mo(null, f, E, l, v);
              break e;
            case 14:
              f = He(null, f, E, Jo(E.type, l), v);
              break e;
          }
          throw Error(t(306, E, ""));
        }
        return f;
      case 0:
        return (
          (E = f.type),
          (I = f.pendingProps),
          (I = f.elementType === E ? I : Jo(E, I)),
          Lt(l, f, E, I, v)
        );
      case 1:
        return (
          (E = f.type),
          (I = f.pendingProps),
          (I = f.elementType === E ? I : Jo(E, I)),
          Qt(l, f, E, I, v)
        );
      case 3:
        e: {
          if ((gn(f), l === null)) throw Error(t(387));
          (E = f.pendingProps),
            (N = f.memoizedState),
            (I = N.element),
            kg(l, f),
            ir(f, E, null, v);
          var q = f.memoizedState;
          if (((E = q.element), N.isDehydrated))
            if (
              ((N = {
                element: E,
                isDehydrated: !1,
                cache: q.cache,
                pendingSuspenseBoundaries: q.pendingSuspenseBoundaries,
                transitions: q.transitions,
              }),
              (f.updateQueue.baseState = N),
              (f.memoizedState = N),
              f.flags & 256)
            ) {
              (I = k(Error(t(423)), f)), (f = Dr(l, f, E, v, I));
              break e;
            } else if (E !== I) {
              (I = k(Error(t(424)), f)), (f = Dr(l, f, E, v, I));
              break e;
            } else
              for (
                Ci = $s(f.stateNode.containerInfo.firstChild),
                  li = f,
                  $n = !0,
                  Po = null,
                  v = wl(f, null, E, v),
                  f.child = v;
                v;

              )
                (v.flags = (v.flags & -3) | 4096), (v = v.sibling);
          else {
            if ((Ia(), E === I)) {
              f = Ml(l, f, v);
              break e;
            }
            Tn(l, f, E, v);
          }
          f = f.child;
        }
        return f;
      case 5:
        return (
          xd(f),
          l === null && pd(f),
          (E = f.type),
          (I = f.pendingProps),
          (N = l !== null ? l.memoizedProps : null),
          (q = I.children),
          lp(E, I) ? (q = null) : N !== null && lp(E, N) && (f.flags |= 32),
          _t(l, f),
          Tn(l, f, q, v),
          f.child
        );
      case 6:
        return l === null && pd(f), null;
      case 13:
        return jg(l, f, v);
      case 4:
        return (
          _u(f, f.stateNode.containerInfo),
          (E = f.pendingProps),
          l === null ? (f.child = Da(f, null, E, v)) : Tn(l, f, E, v),
          f.child
        );
      case 11:
        return (
          (E = f.type),
          (I = f.pendingProps),
          (I = f.elementType === E ? I : Jo(E, I)),
          mo(l, f, E, I, v)
        );
      case 7:
        return Tn(l, f, f.pendingProps, v), f.child;
      case 8:
        return Tn(l, f, f.pendingProps.children, v), f.child;
      case 12:
        return Tn(l, f, f.pendingProps.children, v), f.child;
      case 10:
        e: {
          if (
            ((E = f.type._context),
            (I = f.pendingProps),
            (N = f.memoizedProps),
            (q = I.value),
            Nn(yc, E._currentValue),
            (E._currentValue = q),
            N !== null)
          )
            if (uo(N.value, q)) {
              if (N.children === I.children && !Ei.current) {
                f = Ml(l, f, v);
                break e;
              }
            } else
              for (N = f.child, N !== null && (N.return = f); N !== null; ) {
                var pe = N.dependencies;
                if (pe !== null) {
                  q = N.child;
                  for (var ye = pe.firstContext; ye !== null; ) {
                    if (ye.context === E) {
                      if (N.tag === 1) {
                        (ye = Io(-1, v & -v)), (ye.tag = 2);
                        var je = N.updateQueue;
                        if (je !== null) {
                          je = je.shared;
                          var st = je.pending;
                          st === null
                            ? (ye.next = ye)
                            : ((ye.next = st.next), (st.next = ye)),
                            (je.pending = ye);
                        }
                      }
                      (N.lanes |= v),
                        (ye = N.alternate),
                        ye !== null && (ye.lanes |= v),
                        vu(N.return, v, f),
                        (pe.lanes |= v);
                      break;
                    }
                    ye = ye.next;
                  }
                } else if (N.tag === 10) q = N.type === f.type ? null : N.child;
                else if (N.tag === 18) {
                  if (((q = N.return), q === null)) throw Error(t(341));
                  (q.lanes |= v),
                    (pe = q.alternate),
                    pe !== null && (pe.lanes |= v),
                    vu(q, v, f),
                    (q = N.sibling);
                } else q = N.child;
                if (q !== null) q.return = N;
                else
                  for (q = N; q !== null; ) {
                    if (q === f) {
                      q = null;
                      break;
                    }
                    if (((N = q.sibling), N !== null)) {
                      (N.return = q.return), (q = N);
                      break;
                    }
                    q = q.return;
                  }
                N = q;
              }
          Tn(l, f, I.children, v), (f = f.child);
        }
        return f;
      case 9:
        return (
          (I = f.type),
          (E = f.pendingProps.children),
          Js(f, v),
          (I = Ai(I)),
          (E = E(I)),
          (f.flags |= 1),
          Tn(l, f, E, v),
          f.child
        );
      case 14:
        return (
          (E = f.type),
          (I = Jo(E, f.pendingProps)),
          (I = Jo(E.type, I)),
          He(l, f, E, I, v)
        );
      case 15:
        return Pe(l, f, f.type, f.pendingProps, v);
      case 17:
        return (
          (E = f.type),
          (I = f.pendingProps),
          (I = f.elementType === E ? I : Jo(E, I)),
          Xg(l, f),
          (f.tag = 1),
          vi(E) ? ((l = !0), gl(f)) : (l = !1),
          Js(f, v),
          yu(f, E, I),
          xu(f, E, I, v),
          Yt(null, f, E, !0, l, v)
        );
      case 19:
        return pb(l, f, v);
      case 22:
        return Ze(l, f, v);
    }
    throw Error(t(156, f.tag));
  };
  function Fb(l, f) {
    return Le(l, f);
  }
  function I3(l, f, v, E) {
    (this.tag = l),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = f),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = E),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Es(l, f, v, E) {
    return new I3(l, f, v, E);
  }
  function $x(l) {
    return (l = l.prototype), !(!l || !l.isReactComponent);
  }
  function L3(l) {
    if (typeof l == "function") return $x(l) ? 1 : 0;
    if (l != null) {
      if (((l = l.$$typeof), l === W)) return 11;
      if (l === Z) return 14;
    }
    return 2;
  }
  function Pu(l, f) {
    var v = l.alternate;
    return (
      v === null
        ? ((v = Es(l.tag, f, l.key, l.mode)),
          (v.elementType = l.elementType),
          (v.type = l.type),
          (v.stateNode = l.stateNode),
          (v.alternate = l),
          (l.alternate = v))
        : ((v.pendingProps = f),
          (v.type = l.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = l.flags & 14680064),
      (v.childLanes = l.childLanes),
      (v.lanes = l.lanes),
      (v.child = l.child),
      (v.memoizedProps = l.memoizedProps),
      (v.memoizedState = l.memoizedState),
      (v.updateQueue = l.updateQueue),
      (f = l.dependencies),
      (v.dependencies =
        f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
      (v.sibling = l.sibling),
      (v.index = l.index),
      (v.ref = l.ref),
      v
    );
  }
  function iv(l, f, v, E, I, N) {
    var q = 2;
    if (((E = l), typeof l == "function")) $x(l) && (q = 1);
    else if (typeof l == "string") q = 5;
    else
      e: switch (l) {
        case P:
          return Lc(v.children, I, N, f);
        case U:
          (q = 8), (I |= 8);
          break;
        case O:
          return (
            (l = Es(12, v, f, I | 2)), (l.elementType = O), (l.lanes = N), l
          );
        case $:
          return (l = Es(13, v, f, I)), (l.elementType = $), (l.lanes = N), l;
        case K:
          return (l = Es(19, v, f, I)), (l.elementType = K), (l.lanes = N), l;
        case re:
          return ov(v, I, N, f);
        default:
          if (typeof l == "object" && l !== null)
            switch (l.$$typeof) {
              case L:
                q = 10;
                break e;
              case H:
                q = 9;
                break e;
              case W:
                q = 11;
                break e;
              case Z:
                q = 14;
                break e;
              case Y:
                (q = 16), (E = null);
                break e;
            }
          throw Error(t(130, l == null ? l : typeof l, ""));
      }
    return (
      (f = Es(q, v, f, I)), (f.elementType = l), (f.type = E), (f.lanes = N), f
    );
  }
  function Lc(l, f, v, E) {
    return (l = Es(7, l, E, f)), (l.lanes = v), l;
  }
  function ov(l, f, v, E) {
    return (
      (l = Es(22, l, E, f)),
      (l.elementType = re),
      (l.lanes = v),
      (l.stateNode = { isHidden: !1 }),
      l
    );
  }
  function Xx(l, f, v) {
    return (l = Es(6, l, null, f)), (l.lanes = v), l;
  }
  function Yx(l, f, v) {
    return (
      (f = Es(4, l.children !== null ? l.children : [], l.key, f)),
      (f.lanes = v),
      (f.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        implementation: l.implementation,
      }),
      f
    );
  }
  function D3(l, f, v, E, I) {
    (this.tag = f),
      (this.containerInfo = l),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Wo(0)),
      (this.expirationTimes = Wo(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Wo(0)),
      (this.identifierPrefix = E),
      (this.onRecoverableError = I),
      (this.mutableSourceEagerHydrationData = null);
  }
  function qx(l, f, v, E, I, N, q, pe, ye) {
    return (
      (l = new D3(l, f, v, pe, ye)),
      f === 1 ? ((f = 1), N === !0 && (f |= 8)) : (f = 0),
      (N = Es(3, null, null, f)),
      (l.current = N),
      (N.stateNode = l),
      (N.memoizedState = {
        element: E,
        isDehydrated: v,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      Sc(N),
      l
    );
  }
  function k3(l, f, v) {
    var E =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: D,
      key: E == null ? null : "" + E,
      children: l,
      containerInfo: f,
      implementation: v,
    };
  }
  function Bb(l) {
    if (!l) return Ys;
    l = l._reactInternals;
    e: {
      if (oo(l) !== l || l.tag !== 1) throw Error(t(170));
      var f = l;
      do {
        switch (f.tag) {
          case 3:
            f = f.stateNode.context;
            break e;
          case 1:
            if (vi(f.type)) {
              f = f.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        f = f.return;
      } while (f !== null);
      throw Error(t(171));
    }
    if (l.tag === 1) {
      var v = l.type;
      if (vi(v)) return mc(l, v, f);
    }
    return f;
  }
  function zb(l, f, v, E, I, N, q, pe, ye) {
    return (
      (l = qx(v, E, !0, l, I, N, q, pe, ye)),
      (l.context = Bb(null)),
      (v = l.current),
      (E = go()),
      (I = Au(v)),
      (N = Io(E, I)),
      (N.callback = f ?? null),
      _s(v, N, I),
      (l.current.lanes = I),
      Go(l, I, E),
      No(l, E),
      l
    );
  }
  function sv(l, f, v, E) {
    var I = f.current,
      N = go(),
      q = Au(I);
    return (
      (v = Bb(v)),
      f.context === null ? (f.context = v) : (f.pendingContext = v),
      (f = Io(N, q)),
      (f.payload = { element: l }),
      (E = E === void 0 ? null : E),
      E !== null && (f.callback = E),
      (l = _s(I, f, q)),
      l !== null && (ia(l, I, q, N), Zn(l, I, q)),
      q
    );
  }
  function av(l) {
    if (((l = l.current), !l.child)) return null;
    switch (l.child.tag) {
      case 5:
        return l.child.stateNode;
      default:
        return l.child.stateNode;
    }
  }
  function Hb(l, f) {
    if (((l = l.memoizedState), l !== null && l.dehydrated !== null)) {
      var v = l.retryLane;
      l.retryLane = v !== 0 && v < f ? v : f;
    }
  }
  function Kx(l, f) {
    Hb(l, f), (l = l.alternate) && Hb(l, f);
  }
  function O3() {
    return null;
  }
  var Vb =
    typeof reportError == "function"
      ? reportError
      : function (l) {
          console.error(l);
        };
  function Zx(l) {
    this._internalRoot = l;
  }
  (lv.prototype.render = Zx.prototype.render =
    function (l) {
      var f = this._internalRoot;
      if (f === null) throw Error(t(409));
      sv(l, f, null, null);
    }),
    (lv.prototype.unmount = Zx.prototype.unmount =
      function () {
        var l = this._internalRoot;
        if (l !== null) {
          this._internalRoot = null;
          var f = l.containerInfo;
          Rc(function () {
            sv(null, l, null, null);
          }),
            (f[fo] = null);
        }
      });
  function lv(l) {
    this._internalRoot = l;
  }
  lv.prototype.unstable_scheduleHydration = function (l) {
    if (l) {
      var f = ps();
      l = { blockedOn: null, target: l, priority: f };
      for (var v = 0; v < Mo.length && f !== 0 && f < Mo[v].priority; v++);
      Mo.splice(v, 0, l), v === 0 && mi(l);
    }
  };
  function Jx(l) {
    return !(!l || (l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11));
  }
  function uv(l) {
    return !(
      !l ||
      (l.nodeType !== 1 &&
        l.nodeType !== 9 &&
        l.nodeType !== 11 &&
        (l.nodeType !== 8 || l.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function Wb() {}
  function N3(l, f, v, E, I) {
    if (I) {
      if (typeof E == "function") {
        var N = E;
        E = function () {
          var je = av(q);
          N.call(je);
        };
      }
      var q = zb(f, E, l, 0, null, !1, !1, "", Wb);
      return (
        (l._reactRootContainer = q),
        (l[fo] = q.current),
        uu(l.nodeType === 8 ? l.parentNode : l),
        Rc(),
        q
      );
    }
    for (; (I = l.lastChild); ) l.removeChild(I);
    if (typeof E == "function") {
      var pe = E;
      E = function () {
        var je = av(ye);
        pe.call(je);
      };
    }
    var ye = qx(l, 0, !1, null, null, !1, !1, "", Wb);
    return (
      (l._reactRootContainer = ye),
      (l[fo] = ye.current),
      uu(l.nodeType === 8 ? l.parentNode : l),
      Rc(function () {
        sv(f, ye, v, E);
      }),
      ye
    );
  }
  function cv(l, f, v, E, I) {
    var N = v._reactRootContainer;
    if (N) {
      var q = N;
      if (typeof I == "function") {
        var pe = I;
        I = function () {
          var ye = av(q);
          pe.call(ye);
        };
      }
      sv(f, q, l, I);
    } else q = N3(v, f, l, I, E);
    return av(q);
  }
  (ya = function (l) {
    switch (l.tag) {
      case 3:
        var f = l.stateNode;
        if (f.current.memoizedState.isDehydrated) {
          var v = cn(f.pendingLanes);
          v !== 0 &&
            (jo(f, v | 1),
            No(f, Ke()),
            (xn & 6) === 0 && ((Pd = Ke() + 500), xs()));
        }
        break;
      case 13:
        Rc(function () {
          var E = es(l, 1);
          if (E !== null) {
            var I = go();
            ia(E, l, 1, I);
          }
        }),
          Kx(l, 1);
    }
  }),
    (Zl = function (l) {
      if (l.tag === 13) {
        var f = es(l, 134217728);
        if (f !== null) {
          var v = go();
          ia(f, l, 134217728, v);
        }
        Kx(l, 134217728);
      }
    }),
    (Jl = function (l) {
      if (l.tag === 13) {
        var f = Au(l),
          v = es(l, f);
        if (v !== null) {
          var E = go();
          ia(v, l, f, E);
        }
        Kx(l, f);
      }
    }),
    (ps = function () {
      return ln;
    }),
    (rl = function (l, f) {
      var v = ln;
      try {
        return (ln = l), f();
      } finally {
        ln = v;
      }
    }),
    (Re = function (l, f, v) {
      switch (f) {
        case "input":
          if ((rt(l, v), (f = v.name), v.type === "radio" && f != null)) {
            for (v = l; v.parentNode; ) v = v.parentNode;
            for (
              v = v.querySelectorAll(
                "input[name=" + JSON.stringify("" + f) + '][type="radio"]'
              ),
                f = 0;
              f < v.length;
              f++
            ) {
              var E = v[f];
              if (E !== l && E.form === l.form) {
                var I = ud(E);
                if (!I) throw Error(t(90));
                j(E), rt(E, I);
              }
            }
          }
          break;
        case "textarea":
          _e(l, v);
          break;
        case "select":
          (f = v.value), f != null && B(l, !!v.multiple, f, !1);
      }
    }),
    (Ut = Wx),
    (ht = Rc);
  var U3 = { usingClientEntryPoint: !1, Events: [Xs, hr, ud, gt, Nt, Wx] },
    Pp = {
      findFiberByHostInstance: Pa,
      bundleType: 0,
      version: "18.2.0",
      rendererPackageName: "react-dom",
    },
    F3 = {
      bundleType: Pp.bundleType,
      version: Pp.version,
      rendererPackageName: Pp.rendererPackageName,
      rendererConfig: Pp.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: A.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (l) {
        return (l = ze(l)), l === null ? null : l.stateNode;
      },
      findFiberByHostInstance: Pp.findFiberByHostInstance || O3,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var fv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!fv.isDisabled && fv.supportsFiber)
      try {
        (Mn = fv.inject(F3)), (wt = fv);
      } catch {}
  }
  return (
    (Uo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = U3),
    (Uo.createPortal = function (l, f) {
      var v =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Jx(f)) throw Error(t(200));
      return k3(l, f, null, v);
    }),
    (Uo.createRoot = function (l, f) {
      if (!Jx(l)) throw Error(t(299));
      var v = !1,
        E = "",
        I = Vb;
      return (
        f != null &&
          (f.unstable_strictMode === !0 && (v = !0),
          f.identifierPrefix !== void 0 && (E = f.identifierPrefix),
          f.onRecoverableError !== void 0 && (I = f.onRecoverableError)),
        (f = qx(l, 1, !1, null, null, v, !1, E, I)),
        (l[fo] = f.current),
        uu(l.nodeType === 8 ? l.parentNode : l),
        new Zx(f)
      );
    }),
    (Uo.findDOMNode = function (l) {
      if (l == null) return null;
      if (l.nodeType === 1) return l;
      var f = l._reactInternals;
      if (f === void 0)
        throw typeof l.render == "function"
          ? Error(t(188))
          : ((l = Object.keys(l).join(",")), Error(t(268, l)));
      return (l = ze(f)), (l = l === null ? null : l.stateNode), l;
    }),
    (Uo.flushSync = function (l) {
      return Rc(l);
    }),
    (Uo.hydrate = function (l, f, v) {
      if (!uv(f)) throw Error(t(200));
      return cv(null, l, f, !0, v);
    }),
    (Uo.hydrateRoot = function (l, f, v) {
      if (!Jx(l)) throw Error(t(405));
      var E = (v != null && v.hydratedSources) || null,
        I = !1,
        N = "",
        q = Vb;
      if (
        (v != null &&
          (v.unstable_strictMode === !0 && (I = !0),
          v.identifierPrefix !== void 0 && (N = v.identifierPrefix),
          v.onRecoverableError !== void 0 && (q = v.onRecoverableError)),
        (f = zb(f, null, l, 1, v ?? null, I, !1, N, q)),
        (l[fo] = f.current),
        uu(l),
        E)
      )
        for (l = 0; l < E.length; l++)
          (v = E[l]),
            (I = v._getVersion),
            (I = I(v._source)),
            f.mutableSourceEagerHydrationData == null
              ? (f.mutableSourceEagerHydrationData = [v, I])
              : f.mutableSourceEagerHydrationData.push(v, I);
      return new lv(f);
    }),
    (Uo.render = function (l, f, v) {
      if (!uv(f)) throw Error(t(200));
      return cv(null, l, f, !1, v);
    }),
    (Uo.unmountComponentAtNode = function (l) {
      if (!uv(l)) throw Error(t(40));
      return l._reactRootContainer
        ? (Rc(function () {
            cv(null, null, l, !1, function () {
              (l._reactRootContainer = null), (l[fo] = null);
            });
          }),
          !0)
        : !1;
    }),
    (Uo.unstable_batchedUpdates = Wx),
    (Uo.unstable_renderSubtreeIntoContainer = function (l, f, v, E) {
      if (!uv(v)) throw Error(t(200));
      if (l == null || l._reactInternals === void 0) throw Error(t(38));
      return cv(l, f, v, !1, E);
    }),
    (Uo.version = "18.2.0-next-9e3b772b8-20220608"),
    Uo
  );
}
var Zb;
function iC() {
  if (Zb) return t_.exports;
  Zb = 1;
  function n() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
  }
  return n(), (t_.exports = j3()), t_.exports;
}
var Jb;
function $3() {
  if (Jb) return dv;
  Jb = 1;
  var n = iC();
  return (dv.createRoot = n.createRoot), (dv.hydrateRoot = n.hydrateRoot), dv;
}
var X3 = $3();
const Y3 = Oh(X3);
var i_ = { exports: {} },
  o_ = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Qb;
function q3() {
  if (Qb) return o_;
  Qb = 1;
  var n = Nh();
  function e(m, g) {
    return (m === g && (m !== 0 || 1 / m === 1 / g)) || (m !== m && g !== g);
  }
  var t = typeof Object.is == "function" ? Object.is : e,
    r = n.useState,
    i = n.useEffect,
    o = n.useLayoutEffect,
    s = n.useDebugValue;
  function a(m, g) {
    var y = g(),
      x = r({ inst: { value: y, getSnapshot: g } }),
      S = x[0].inst,
      _ = x[1];
    return (
      o(
        function () {
          (S.value = y), (S.getSnapshot = g), u(S) && _({ inst: S });
        },
        [m, y, g]
      ),
      i(
        function () {
          return (
            u(S) && _({ inst: S }),
            m(function () {
              u(S) && _({ inst: S });
            })
          );
        },
        [m]
      ),
      s(y),
      y
    );
  }
  function u(m) {
    var g = m.getSnapshot;
    m = m.value;
    try {
      var y = g();
      return !t(m, y);
    } catch {
      return !0;
    }
  }
  function c(m, g) {
    return g();
  }
  var d =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? c
      : a;
  return (
    (o_.useSyncExternalStore =
      n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : d),
    o_
  );
}
var eM;
function oC() {
  return eM || ((eM = 1), (i_.exports = q3())), i_.exports;
}
oC();
var s_ = { exports: {} },
  a_ = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var tM;
function K3() {
  if (tM) return a_;
  tM = 1;
  var n = Nh(),
    e = oC();
  function t(c, d) {
    return (c === d && (c !== 0 || 1 / c === 1 / d)) || (c !== c && d !== d);
  }
  var r = typeof Object.is == "function" ? Object.is : t,
    i = e.useSyncExternalStore,
    o = n.useRef,
    s = n.useEffect,
    a = n.useMemo,
    u = n.useDebugValue;
  return (
    (a_.useSyncExternalStoreWithSelector = function (c, d, m, g, y) {
      var x = o(null);
      if (x.current === null) {
        var S = { hasValue: !1, value: null };
        x.current = S;
      } else S = x.current;
      x = a(
        function () {
          function w(D) {
            if (!T) {
              if (((T = !0), (M = D), (D = g(D)), y !== void 0 && S.hasValue)) {
                var P = S.value;
                if (y(P, D)) return (A = P);
              }
              return (A = D);
            }
            if (((P = A), r(M, D))) return P;
            var U = g(D);
            return y !== void 0 && y(P, U) ? ((M = D), P) : ((M = D), (A = U));
          }
          var T = !1,
            M,
            A,
            R = m === void 0 ? null : m;
          return [
            function () {
              return w(d());
            },
            R === null
              ? void 0
              : function () {
                  return w(R());
                },
          ];
        },
        [d, m, g, y]
      );
      var _ = i(c, x[0], x[1]);
      return (
        s(
          function () {
            (S.hasValue = !0), (S.value = _);
          },
          [_]
        ),
        u(_),
        _
      );
    }),
    a_
  );
}
var nM;
function Z3() {
  return nM || ((nM = 1), (s_.exports = K3())), s_.exports;
}
var J3 = Z3(),
  DS = iC();
const hv = Oh(DS);
function Q3(n) {
  n();
}
let sC = Q3;
const eI = (n) => (sC = n),
  tI = () => sC,
  rM = Symbol.for("react-redux-context"),
  iM = typeof globalThis < "u" ? globalThis : {};
function nI() {
  var n;
  if (!X.createContext) return {};
  const e = (n = iM[rM]) != null ? n : (iM[rM] = new Map());
  let t = e.get(X.createContext);
  return t || ((t = X.createContext(null)), e.set(X.createContext, t)), t;
}
const Yu = nI();
function kS(n = Yu) {
  return function () {
    return X.useContext(n);
  };
}
const aC = kS(),
  rI = () => {
    throw new Error("uSES not initialized!");
  };
let lC = rI;
const iI = (n) => {
    lC = n;
  },
  oI = (n, e) => n === e;
function sI(n = Yu) {
  const e = n === Yu ? aC : kS(n);
  return function (r, i = {}) {
    const {
        equalityFn: o = oI,
        stabilityCheck: s = void 0,
        noopCheck: a = void 0,
      } = typeof i == "function" ? { equalityFn: i } : i,
      {
        store: u,
        subscription: c,
        getServerState: d,
        stabilityCheck: m,
        noopCheck: g,
      } = e();
    X.useRef(!0);
    const y = X.useCallback(
        {
          [r.name](S) {
            return r(S);
          },
        }[r.name],
        [r, m, s]
      ),
      x = lC(c.addNestedSub, u.getState, d || u.getState, y, o);
    return X.useDebugValue(x), x;
  };
}
const Qu = sI();
function ue() {
  return (
    (ue = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    ue.apply(null, arguments)
  );
}
function It(n, e) {
  if (n == null) return {};
  var t = {};
  for (var r in n)
    if ({}.hasOwnProperty.call(n, r)) {
      if (e.indexOf(r) !== -1) continue;
      t[r] = n[r];
    }
  return t;
}
var l_ = { exports: {} },
  Dn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var oM;
function aI() {
  if (oM) return Dn;
  oM = 1;
  var n = typeof Symbol == "function" && Symbol.for,
    e = n ? Symbol.for("react.element") : 60103,
    t = n ? Symbol.for("react.portal") : 60106,
    r = n ? Symbol.for("react.fragment") : 60107,
    i = n ? Symbol.for("react.strict_mode") : 60108,
    o = n ? Symbol.for("react.profiler") : 60114,
    s = n ? Symbol.for("react.provider") : 60109,
    a = n ? Symbol.for("react.context") : 60110,
    u = n ? Symbol.for("react.async_mode") : 60111,
    c = n ? Symbol.for("react.concurrent_mode") : 60111,
    d = n ? Symbol.for("react.forward_ref") : 60112,
    m = n ? Symbol.for("react.suspense") : 60113,
    g = n ? Symbol.for("react.suspense_list") : 60120,
    y = n ? Symbol.for("react.memo") : 60115,
    x = n ? Symbol.for("react.lazy") : 60116,
    S = n ? Symbol.for("react.block") : 60121,
    _ = n ? Symbol.for("react.fundamental") : 60117,
    w = n ? Symbol.for("react.responder") : 60118,
    T = n ? Symbol.for("react.scope") : 60119;
  function M(R) {
    if (typeof R == "object" && R !== null) {
      var D = R.$$typeof;
      switch (D) {
        case e:
          switch (((R = R.type), R)) {
            case u:
            case c:
            case r:
            case o:
            case i:
            case m:
              return R;
            default:
              switch (((R = R && R.$$typeof), R)) {
                case a:
                case d:
                case x:
                case y:
                case s:
                  return R;
                default:
                  return D;
              }
          }
        case t:
          return D;
      }
    }
  }
  function A(R) {
    return M(R) === c;
  }
  return (
    (Dn.AsyncMode = u),
    (Dn.ConcurrentMode = c),
    (Dn.ContextConsumer = a),
    (Dn.ContextProvider = s),
    (Dn.Element = e),
    (Dn.ForwardRef = d),
    (Dn.Fragment = r),
    (Dn.Lazy = x),
    (Dn.Memo = y),
    (Dn.Portal = t),
    (Dn.Profiler = o),
    (Dn.StrictMode = i),
    (Dn.Suspense = m),
    (Dn.isAsyncMode = function (R) {
      return A(R) || M(R) === u;
    }),
    (Dn.isConcurrentMode = A),
    (Dn.isContextConsumer = function (R) {
      return M(R) === a;
    }),
    (Dn.isContextProvider = function (R) {
      return M(R) === s;
    }),
    (Dn.isElement = function (R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }),
    (Dn.isForwardRef = function (R) {
      return M(R) === d;
    }),
    (Dn.isFragment = function (R) {
      return M(R) === r;
    }),
    (Dn.isLazy = function (R) {
      return M(R) === x;
    }),
    (Dn.isMemo = function (R) {
      return M(R) === y;
    }),
    (Dn.isPortal = function (R) {
      return M(R) === t;
    }),
    (Dn.isProfiler = function (R) {
      return M(R) === o;
    }),
    (Dn.isStrictMode = function (R) {
      return M(R) === i;
    }),
    (Dn.isSuspense = function (R) {
      return M(R) === m;
    }),
    (Dn.isValidElementType = function (R) {
      return (
        typeof R == "string" ||
        typeof R == "function" ||
        R === r ||
        R === c ||
        R === o ||
        R === i ||
        R === m ||
        R === g ||
        (typeof R == "object" &&
          R !== null &&
          (R.$$typeof === x ||
            R.$$typeof === y ||
            R.$$typeof === s ||
            R.$$typeof === a ||
            R.$$typeof === d ||
            R.$$typeof === _ ||
            R.$$typeof === w ||
            R.$$typeof === T ||
            R.$$typeof === S))
      );
    }),
    (Dn.typeOf = M),
    Dn
  );
}
var sM;
function lI() {
  return sM || ((sM = 1), (l_.exports = aI())), l_.exports;
}
var u_, aM;
function uI() {
  if (aM) return u_;
  aM = 1;
  var n = lI(),
    e = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0,
    },
    t = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0,
    },
    r = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
    },
    i = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0,
    },
    o = {};
  (o[n.ForwardRef] = r), (o[n.Memo] = i);
  function s(x) {
    return n.isMemo(x) ? i : o[x.$$typeof] || e;
  }
  var a = Object.defineProperty,
    u = Object.getOwnPropertyNames,
    c = Object.getOwnPropertySymbols,
    d = Object.getOwnPropertyDescriptor,
    m = Object.getPrototypeOf,
    g = Object.prototype;
  function y(x, S, _) {
    if (typeof S != "string") {
      if (g) {
        var w = m(S);
        w && w !== g && y(x, w, _);
      }
      var T = u(S);
      c && (T = T.concat(c(S)));
      for (var M = s(x), A = s(S), R = 0; R < T.length; ++R) {
        var D = T[R];
        if (!t[D] && !(_ && _[D]) && !(A && A[D]) && !(M && M[D])) {
          var P = d(S, D);
          try {
            a(x, D, P);
          } catch {}
        }
      }
    }
    return x;
  }
  return (u_ = y), u_;
}
uI();
var c_ = { exports: {} },
  kn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var lM;
function cI() {
  if (lM) return kn;
  lM = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    a = Symbol.for("react.server_context"),
    u = Symbol.for("react.forward_ref"),
    c = Symbol.for("react.suspense"),
    d = Symbol.for("react.suspense_list"),
    m = Symbol.for("react.memo"),
    g = Symbol.for("react.lazy"),
    y = Symbol.for("react.offscreen"),
    x;
  x = Symbol.for("react.module.reference");
  function S(_) {
    if (typeof _ == "object" && _ !== null) {
      var w = _.$$typeof;
      switch (w) {
        case n:
          switch (((_ = _.type), _)) {
            case t:
            case i:
            case r:
            case c:
            case d:
              return _;
            default:
              switch (((_ = _ && _.$$typeof), _)) {
                case a:
                case s:
                case u:
                case g:
                case m:
                case o:
                  return _;
                default:
                  return w;
              }
          }
        case e:
          return w;
      }
    }
  }
  return (
    (kn.ContextConsumer = s),
    (kn.ContextProvider = o),
    (kn.Element = n),
    (kn.ForwardRef = u),
    (kn.Fragment = t),
    (kn.Lazy = g),
    (kn.Memo = m),
    (kn.Portal = e),
    (kn.Profiler = i),
    (kn.StrictMode = r),
    (kn.Suspense = c),
    (kn.SuspenseList = d),
    (kn.isAsyncMode = function () {
      return !1;
    }),
    (kn.isConcurrentMode = function () {
      return !1;
    }),
    (kn.isContextConsumer = function (_) {
      return S(_) === s;
    }),
    (kn.isContextProvider = function (_) {
      return S(_) === o;
    }),
    (kn.isElement = function (_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === n;
    }),
    (kn.isForwardRef = function (_) {
      return S(_) === u;
    }),
    (kn.isFragment = function (_) {
      return S(_) === t;
    }),
    (kn.isLazy = function (_) {
      return S(_) === g;
    }),
    (kn.isMemo = function (_) {
      return S(_) === m;
    }),
    (kn.isPortal = function (_) {
      return S(_) === e;
    }),
    (kn.isProfiler = function (_) {
      return S(_) === i;
    }),
    (kn.isStrictMode = function (_) {
      return S(_) === r;
    }),
    (kn.isSuspense = function (_) {
      return S(_) === c;
    }),
    (kn.isSuspenseList = function (_) {
      return S(_) === d;
    }),
    (kn.isValidElementType = function (_) {
      return (
        typeof _ == "string" ||
        typeof _ == "function" ||
        _ === t ||
        _ === i ||
        _ === r ||
        _ === c ||
        _ === d ||
        _ === y ||
        (typeof _ == "object" &&
          _ !== null &&
          (_.$$typeof === g ||
            _.$$typeof === m ||
            _.$$typeof === o ||
            _.$$typeof === s ||
            _.$$typeof === u ||
            _.$$typeof === x ||
            _.getModuleId !== void 0))
      );
    }),
    (kn.typeOf = S),
    kn
  );
}
var uM;
function fI() {
  return uM || ((uM = 1), (c_.exports = cI())), c_.exports;
}
fI();
function dI() {
  const n = tI();
  let e = null,
    t = null;
  return {
    clear() {
      (e = null), (t = null);
    },
    notify() {
      n(() => {
        let r = e;
        for (; r; ) r.callback(), (r = r.next);
      });
    },
    get() {
      let r = [],
        i = e;
      for (; i; ) r.push(i), (i = i.next);
      return r;
    },
    subscribe(r) {
      let i = !0,
        o = (t = { callback: r, next: null, prev: t });
      return (
        o.prev ? (o.prev.next = o) : (e = o),
        function () {
          !i ||
            e === null ||
            ((i = !1),
            o.next ? (o.next.prev = o.prev) : (t = o.prev),
            o.prev ? (o.prev.next = o.next) : (e = o.next));
        }
      );
    },
  };
}
const cM = { notify() {}, get: () => [] };
function hI(n, e) {
  let t,
    r = cM,
    i = 0,
    o = !1;
  function s(S) {
    d();
    const _ = r.subscribe(S);
    let w = !1;
    return () => {
      w || ((w = !0), _(), m());
    };
  }
  function a() {
    r.notify();
  }
  function u() {
    x.onStateChange && x.onStateChange();
  }
  function c() {
    return o;
  }
  function d() {
    i++, t || ((t = n.subscribe(u)), (r = dI()));
  }
  function m() {
    i--, t && i === 0 && (t(), (t = void 0), r.clear(), (r = cM));
  }
  function g() {
    o || ((o = !0), d());
  }
  function y() {
    o && ((o = !1), m());
  }
  const x = {
    addNestedSub: s,
    notifyNestedSubs: a,
    handleChangeWrapper: u,
    isSubscribed: c,
    trySubscribe: g,
    tryUnsubscribe: y,
    getListeners: () => r,
  };
  return x;
}
const pI =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  mI = pI ? X.useLayoutEffect : X.useEffect;
function uC({
  store: n,
  context: e,
  children: t,
  serverState: r,
  stabilityCheck: i = "once",
  noopCheck: o = "once",
}) {
  const s = X.useMemo(() => {
      const c = hI(n);
      return {
        store: n,
        subscription: c,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        noopCheck: o,
      };
    }, [n, r, i, o]),
    a = X.useMemo(() => n.getState(), [n]);
  mI(() => {
    const { subscription: c } = s;
    return (
      (c.onStateChange = c.notifyNestedSubs),
      c.trySubscribe(),
      a !== n.getState() && c.notifyNestedSubs(),
      () => {
        c.tryUnsubscribe(), (c.onStateChange = void 0);
      }
    );
  }, [s, a]);
  const u = e || Yu;
  return X.createElement(u.Provider, { value: s }, t);
}
function cC(n = Yu) {
  const e = n === Yu ? aC : kS(n);
  return function () {
    const { store: r } = e();
    return r;
  };
}
const gI = cC();
function vI(n = Yu) {
  const e = n === Yu ? gI : cC(n);
  return function () {
    return e().dispatch;
  };
}
const OS = vI();
iI(J3.useSyncExternalStoreWithSelector);
eI(DS.unstable_batchedUpdates);
const Em = { black: "#000", white: "#fff" },
  Ld = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828",
  },
  Dd = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2",
  },
  kd = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0",
  },
  Od = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b",
  },
  Nd = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
  },
  Lp = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100",
  },
  yI = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161",
  };
function Bl(n) {
  let e = "https://mui.com/production-error/?code=" + n;
  for (let t = 1; t < arguments.length; t += 1)
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified MUI error #" + n + "; visit " + e + " for the full message.";
}
const xI = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: Bl },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  by = "$$material";
function fC(n) {
  var e = Object.create(null);
  return function (t) {
    return e[t] === void 0 && (e[t] = n(t)), e[t];
  };
}
var _I =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  SI = fC(function (n) {
    return (
      _I.test(n) ||
      (n.charCodeAt(0) === 111 &&
        n.charCodeAt(1) === 110 &&
        n.charCodeAt(2) < 91)
    );
  });
function wI(n) {
  if (n.sheet) return n.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === n) return document.styleSheets[e];
}
function bI(n) {
  var e = document.createElement("style");
  return (
    e.setAttribute("data-emotion", n.key),
    n.nonce !== void 0 && e.setAttribute("nonce", n.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
  );
}
var MI = (function () {
    function n(t) {
      var r = this;
      (this._insertTag = function (i) {
        var o;
        r.tags.length === 0
          ? r.insertionPoint
            ? (o = r.insertionPoint.nextSibling)
            : r.prepend
            ? (o = r.container.firstChild)
            : (o = r.before)
          : (o = r.tags[r.tags.length - 1].nextSibling),
          r.container.insertBefore(i, o),
          r.tags.push(i);
      }),
        (this.isSpeedy = t.speedy === void 0 ? !0 : t.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = t.nonce),
        (this.key = t.key),
        (this.container = t.container),
        (this.prepend = t.prepend),
        (this.insertionPoint = t.insertionPoint),
        (this.before = null);
    }
    var e = n.prototype;
    return (
      (e.hydrate = function (r) {
        r.forEach(this._insertTag);
      }),
      (e.insert = function (r) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(bI(this));
        var i = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var o = wI(i);
          try {
            o.insertRule(r, o.cssRules.length);
          } catch {}
        } else i.appendChild(document.createTextNode(r));
        this.ctr++;
      }),
      (e.flush = function () {
        this.tags.forEach(function (r) {
          var i;
          return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      n
    );
  })(),
  eo = "-ms-",
  A0 = "-moz-",
  Pn = "-webkit-",
  dC = "comm",
  NS = "rule",
  US = "decl",
  EI = "@import",
  hC = "@keyframes",
  TI = "@layer",
  CI = Math.abs,
  My = String.fromCharCode,
  AI = Object.assign;
function RI(n, e) {
  return Fi(n, 0) ^ 45
    ? (((((((e << 2) ^ Fi(n, 0)) << 2) ^ Fi(n, 1)) << 2) ^ Fi(n, 2)) << 2) ^
        Fi(n, 3)
    : 0;
}
function pC(n) {
  return n.trim();
}
function PI(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function In(n, e, t) {
  return n.replace(e, t);
}
function j1(n, e) {
  return n.indexOf(e);
}
function Fi(n, e) {
  return n.charCodeAt(e) | 0;
}
function Tm(n, e, t) {
  return n.slice(e, t);
}
function Wa(n) {
  return n.length;
}
function FS(n) {
  return n.length;
}
function pv(n, e) {
  return e.push(n), n;
}
function II(n, e) {
  return n.map(e).join("");
}
var Ey = 1,
  Th = 1,
  mC = 0,
  Ho = 0,
  ti = 0,
  Uh = "";
function Ty(n, e, t, r, i, o, s) {
  return {
    value: n,
    root: e,
    parent: t,
    type: r,
    props: i,
    children: o,
    line: Ey,
    column: Th,
    length: s,
    return: "",
  };
}
function Dp(n, e) {
  return AI(Ty("", null, null, "", null, null, 0), n, { length: -n.length }, e);
}
function LI() {
  return ti;
}
function DI() {
  return (
    (ti = Ho > 0 ? Fi(Uh, --Ho) : 0), Th--, ti === 10 && ((Th = 1), Ey--), ti
  );
}
function ls() {
  return (
    (ti = Ho < mC ? Fi(Uh, Ho++) : 0), Th++, ti === 10 && ((Th = 1), Ey++), ti
  );
}
function qa() {
  return Fi(Uh, Ho);
}
function x0() {
  return Ho;
}
function tg(n, e) {
  return Tm(Uh, n, e);
}
function Cm(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function gC(n) {
  return (Ey = Th = 1), (mC = Wa((Uh = n))), (Ho = 0), [];
}
function vC(n) {
  return (Uh = ""), n;
}
function _0(n) {
  return pC(tg(Ho - 1, $1(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function kI(n) {
  for (; (ti = qa()) && ti < 33; ) ls();
  return Cm(n) > 2 || Cm(ti) > 3 ? "" : " ";
}
function OI(n, e) {
  for (
    ;
    --e &&
    ls() &&
    !(ti < 48 || ti > 102 || (ti > 57 && ti < 65) || (ti > 70 && ti < 97));

  );
  return tg(n, x0() + (e < 6 && qa() == 32 && ls() == 32));
}
function $1(n) {
  for (; ls(); )
    switch (ti) {
      case n:
        return Ho;
      case 34:
      case 39:
        n !== 34 && n !== 39 && $1(ti);
        break;
      case 40:
        n === 41 && $1(n);
        break;
      case 92:
        ls();
        break;
    }
  return Ho;
}
function NI(n, e) {
  for (; ls() && n + ti !== 57; ) if (n + ti === 84 && qa() === 47) break;
  return "/*" + tg(e, Ho - 1) + "*" + My(n === 47 ? n : ls());
}
function UI(n) {
  for (; !Cm(qa()); ) ls();
  return tg(n, Ho);
}
function FI(n) {
  return vC(S0("", null, null, null, [""], (n = gC(n)), 0, [0], n));
}
function S0(n, e, t, r, i, o, s, a, u) {
  for (
    var c = 0,
      d = 0,
      m = s,
      g = 0,
      y = 0,
      x = 0,
      S = 1,
      _ = 1,
      w = 1,
      T = 0,
      M = "",
      A = i,
      R = o,
      D = r,
      P = M;
    _;

  )
    switch (((x = T), (T = ls()))) {
      case 40:
        if (x != 108 && Fi(P, m - 1) == 58) {
          j1((P += In(_0(T), "&", "&\f")), "&\f") != -1 && (w = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        P += _0(T);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        P += kI(x);
        break;
      case 92:
        P += OI(x0() - 1, 7);
        continue;
      case 47:
        switch (qa()) {
          case 42:
          case 47:
            pv(BI(NI(ls(), x0()), e, t), u);
            break;
          default:
            P += "/";
        }
        break;
      case 123 * S:
        a[c++] = Wa(P) * w;
      case 125 * S:
      case 59:
      case 0:
        switch (T) {
          case 0:
          case 125:
            _ = 0;
          case 59 + d:
            w == -1 && (P = In(P, /\f/g, "")),
              y > 0 &&
                Wa(P) - m &&
                pv(
                  y > 32
                    ? dM(P + ";", r, t, m - 1)
                    : dM(In(P, " ", "") + ";", r, t, m - 2),
                  u
                );
            break;
          case 59:
            P += ";";
          default:
            if (
              (pv((D = fM(P, e, t, c, d, i, a, M, (A = []), (R = []), m)), o),
              T === 123)
            )
              if (d === 0) S0(P, e, D, D, A, o, m, a, R);
              else
                switch (g === 99 && Fi(P, 3) === 110 ? 100 : g) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    S0(
                      n,
                      D,
                      D,
                      r && pv(fM(n, D, D, 0, 0, i, a, M, i, (A = []), m), R),
                      i,
                      R,
                      m,
                      a,
                      r ? A : R
                    );
                    break;
                  default:
                    S0(P, D, D, D, [""], R, 0, a, R);
                }
        }
        (c = d = y = 0), (S = w = 1), (M = P = ""), (m = s);
        break;
      case 58:
        (m = 1 + Wa(P)), (y = x);
      default:
        if (S < 1) {
          if (T == 123) --S;
          else if (T == 125 && S++ == 0 && DI() == 125) continue;
        }
        switch (((P += My(T)), T * S)) {
          case 38:
            w = d > 0 ? 1 : ((P += "\f"), -1);
            break;
          case 44:
            (a[c++] = (Wa(P) - 1) * w), (w = 1);
            break;
          case 64:
            qa() === 45 && (P += _0(ls())),
              (g = qa()),
              (d = m = Wa((M = P += UI(x0())))),
              T++;
            break;
          case 45:
            x === 45 && Wa(P) == 2 && (S = 0);
        }
    }
  return o;
}
function fM(n, e, t, r, i, o, s, a, u, c, d) {
  for (
    var m = i - 1, g = i === 0 ? o : [""], y = FS(g), x = 0, S = 0, _ = 0;
    x < r;
    ++x
  )
    for (var w = 0, T = Tm(n, m + 1, (m = CI((S = s[x])))), M = n; w < y; ++w)
      (M = pC(S > 0 ? g[w] + " " + T : In(T, /&\f/g, g[w]))) && (u[_++] = M);
  return Ty(n, e, t, i === 0 ? NS : a, u, c, d);
}
function BI(n, e, t) {
  return Ty(n, e, t, dC, My(LI()), Tm(n, 2, -2), 0);
}
function dM(n, e, t, r) {
  return Ty(n, e, t, US, Tm(n, 0, r), Tm(n, r + 1, -1), r);
}
function _h(n, e) {
  for (var t = "", r = FS(n), i = 0; i < r; i++) t += e(n[i], i, n, e) || "";
  return t;
}
function zI(n, e, t, r) {
  switch (n.type) {
    case TI:
      if (n.children.length) break;
    case EI:
    case US:
      return (n.return = n.return || n.value);
    case dC:
      return "";
    case hC:
      return (n.return = n.value + "{" + _h(n.children, r) + "}");
    case NS:
      n.value = n.props.join(",");
  }
  return Wa((t = _h(n.children, r)))
    ? (n.return = n.value + "{" + t + "}")
    : "";
}
function HI(n) {
  var e = FS(n);
  return function (t, r, i, o) {
    for (var s = "", a = 0; a < e; a++) s += n[a](t, r, i, o) || "";
    return s;
  };
}
function VI(n) {
  return function (e) {
    e.root || ((e = e.return) && n(e));
  };
}
var WI = function (e, t, r) {
    for (
      var i = 0, o = 0;
      (i = o), (o = qa()), i === 38 && o === 12 && (t[r] = 1), !Cm(o);

    )
      ls();
    return tg(e, Ho);
  },
  GI = function (e, t) {
    var r = -1,
      i = 44;
    do
      switch (Cm(i)) {
        case 0:
          i === 38 && qa() === 12 && (t[r] = 1), (e[r] += WI(Ho - 1, t, r));
          break;
        case 2:
          e[r] += _0(i);
          break;
        case 4:
          if (i === 44) {
            (e[++r] = qa() === 58 ? "&\f" : ""), (t[r] = e[r].length);
            break;
          }
        default:
          e[r] += My(i);
      }
    while ((i = ls()));
    return e;
  },
  jI = function (e, t) {
    return vC(GI(gC(e), t));
  },
  hM = new WeakMap(),
  $I = function (e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (
        var t = e.value,
          r = e.parent,
          i = e.column === r.column && e.line === r.line;
        r.type !== "rule";

      )
        if (((r = r.parent), !r)) return;
      if (
        !(e.props.length === 1 && t.charCodeAt(0) !== 58 && !hM.get(r)) &&
        !i
      ) {
        hM.set(e, !0);
        for (
          var o = [], s = jI(t, o), a = r.props, u = 0, c = 0;
          u < s.length;
          u++
        )
          for (var d = 0; d < a.length; d++, c++)
            e.props[c] = o[u] ? s[u].replace(/&\f/g, a[d]) : a[d] + " " + s[u];
      }
    }
  },
  XI = function (e) {
    if (e.type === "decl") {
      var t = e.value;
      t.charCodeAt(0) === 108 &&
        t.charCodeAt(2) === 98 &&
        ((e.return = ""), (e.value = ""));
    }
  };
function yC(n, e) {
  switch (RI(n, e)) {
    case 5103:
      return Pn + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Pn + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Pn + n + A0 + n + eo + n + n;
    case 6828:
    case 4268:
      return Pn + n + eo + n + n;
    case 6165:
      return Pn + n + eo + "flex-" + n + n;
    case 5187:
      return (
        Pn + n + In(n, /(\w+).+(:[^]+)/, Pn + "box-$1$2" + eo + "flex-$1$2") + n
      );
    case 5443:
      return Pn + n + eo + "flex-item-" + In(n, /flex-|-self/, "") + n;
    case 4675:
      return (
        Pn +
        n +
        eo +
        "flex-line-pack" +
        In(n, /align-content|flex-|-self/, "") +
        n
      );
    case 5548:
      return Pn + n + eo + In(n, "shrink", "negative") + n;
    case 5292:
      return Pn + n + eo + In(n, "basis", "preferred-size") + n;
    case 6060:
      return (
        Pn +
        "box-" +
        In(n, "-grow", "") +
        Pn +
        n +
        eo +
        In(n, "grow", "positive") +
        n
      );
    case 4554:
      return Pn + In(n, /([^-])(transform)/g, "$1" + Pn + "$2") + n;
    case 6187:
      return (
        In(
          In(In(n, /(zoom-|grab)/, Pn + "$1"), /(image-set)/, Pn + "$1"),
          n,
          ""
        ) + n
      );
    case 5495:
    case 3959:
      return In(n, /(image-set\([^]*)/, Pn + "$1$`$1");
    case 4968:
      return (
        In(
          In(n, /(.+:)(flex-)?(.*)/, Pn + "box-pack:$3" + eo + "flex-pack:$3"),
          /s.+-b[^;]+/,
          "justify"
        ) +
        Pn +
        n +
        n
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return In(n, /(.+)-inline(.+)/, Pn + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Wa(n) - 1 - e > 6)
        switch (Fi(n, e + 1)) {
          case 109:
            if (Fi(n, e + 4) !== 45) break;
          case 102:
            return (
              In(
                n,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  Pn +
                  "$2-$3$1" +
                  A0 +
                  (Fi(n, e + 3) == 108 ? "$3" : "$2-$3")
              ) + n
            );
          case 115:
            return ~j1(n, "stretch")
              ? yC(In(n, "stretch", "fill-available"), e) + n
              : n;
        }
      break;
    case 4949:
      if (Fi(n, e + 1) !== 115) break;
    case 6444:
      switch (Fi(n, Wa(n) - 3 - (~j1(n, "!important") && 10))) {
        case 107:
          return In(n, ":", ":" + Pn) + n;
        case 101:
          return (
            In(
              n,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                Pn +
                (Fi(n, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                Pn +
                "$2$3$1" +
                eo +
                "$2box$3"
            ) + n
          );
      }
      break;
    case 5936:
      switch (Fi(n, e + 11)) {
        case 114:
          return Pn + n + eo + In(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return Pn + n + eo + In(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return Pn + n + eo + In(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
      return Pn + n + eo + n + n;
  }
  return n;
}
var YI = function (e, t, r, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case US:
          e.return = yC(e.value, e.length);
          break;
        case hC:
          return _h([Dp(e, { value: In(e.value, "@", "@" + Pn) })], i);
        case NS:
          if (e.length)
            return II(e.props, function (o) {
              switch (PI(o, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return _h(
                    [Dp(e, { props: [In(o, /:(read-\w+)/, ":" + A0 + "$1")] })],
                    i
                  );
                case "::placeholder":
                  return _h(
                    [
                      Dp(e, {
                        props: [In(o, /:(plac\w+)/, ":" + Pn + "input-$1")],
                      }),
                      Dp(e, { props: [In(o, /:(plac\w+)/, ":" + A0 + "$1")] }),
                      Dp(e, { props: [In(o, /:(plac\w+)/, eo + "input-$1")] }),
                    ],
                    i
                  );
              }
              return "";
            });
      }
  },
  qI = [YI],
  xC = function (e) {
    var t = e.key;
    if (t === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function (S) {
        var _ = S.getAttribute("data-emotion");
        _.indexOf(" ") !== -1 &&
          (document.head.appendChild(S), S.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || qI,
      o = {},
      s,
      a = [];
    (s = e.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
        function (S) {
          for (
            var _ = S.getAttribute("data-emotion").split(" "), w = 1;
            w < _.length;
            w++
          )
            o[_[w]] = !0;
          a.push(S);
        }
      );
    var u,
      c = [$I, XI];
    {
      var d,
        m = [
          zI,
          VI(function (S) {
            d.insert(S);
          }),
        ],
        g = HI(c.concat(i, m)),
        y = function (_) {
          return _h(FI(_), g);
        };
      u = function (_, w, T, M) {
        (d = T),
          y(_ ? _ + "{" + w.styles + "}" : w.styles),
          M && (x.inserted[w.name] = !0);
      };
    }
    var x = {
      key: t,
      sheet: new MI({
        key: t,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint,
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: u,
    };
    return x.sheet.hydrate(a), x;
  },
  KI = !0;
function ZI(n, e, t) {
  var r = "";
  return (
    t.split(" ").forEach(function (i) {
      n[i] !== void 0 ? e.push(n[i] + ";") : i && (r += i + " ");
    }),
    r
  );
}
var _C = function (e, t, r) {
    var i = e.key + "-" + t.name;
    (r === !1 || KI === !1) &&
      e.registered[i] === void 0 &&
      (e.registered[i] = t.styles);
  },
  SC = function (e, t, r) {
    _C(e, t, r);
    var i = e.key + "-" + t.name;
    if (e.inserted[t.name] === void 0) {
      var o = t;
      do e.insert(t === o ? "." + i : "", o, e.sheet, !0), (o = o.next);
      while (o !== void 0);
    }
  };
function JI(n) {
  for (var e = 0, t, r = 0, i = n.length; i >= 4; ++r, i -= 4)
    (t =
      (n.charCodeAt(r) & 255) |
      ((n.charCodeAt(++r) & 255) << 8) |
      ((n.charCodeAt(++r) & 255) << 16) |
      ((n.charCodeAt(++r) & 255) << 24)),
      (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)),
      (t ^= t >>> 24),
      (e =
        ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (n.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (n.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= n.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
var QI = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  eL = /[A-Z]|^ms/g,
  tL = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  wC = function (e) {
    return e.charCodeAt(1) === 45;
  },
  pM = function (e) {
    return e != null && typeof e != "boolean";
  },
  f_ = fC(function (n) {
    return wC(n) ? n : n.replace(eL, "-$&").toLowerCase();
  }),
  mM = function (e, t) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof t == "string")
          return t.replace(tL, function (r, i, o) {
            return (Ga = { name: i, styles: o, next: Ga }), i;
          });
    }
    return QI[e] !== 1 && !wC(e) && typeof t == "number" && t !== 0
      ? t + "px"
      : t;
  };
function Am(n, e, t) {
  if (t == null) return "";
  var r = t;
  if (r.__emotion_styles !== void 0) return r;
  switch (typeof t) {
    case "boolean":
      return "";
    case "object": {
      var i = t;
      if (i.anim === 1)
        return (Ga = { name: i.name, styles: i.styles, next: Ga }), i.name;
      var o = t;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            (Ga = { name: s.name, styles: s.styles, next: Ga }), (s = s.next);
        var a = o.styles + ";";
        return a;
      }
      return nL(n, e, t);
    }
    case "function": {
      if (n !== void 0) {
        var u = Ga,
          c = t(n);
        return (Ga = u), Am(n, e, c);
      }
      break;
    }
  }
  var d = t;
  if (e == null) return d;
  var m = e[d];
  return m !== void 0 ? m : d;
}
function nL(n, e, t) {
  var r = "";
  if (Array.isArray(t))
    for (var i = 0; i < t.length; i++) r += Am(n, e, t[i]) + ";";
  else
    for (var o in t) {
      var s = t[o];
      if (typeof s != "object") {
        var a = s;
        e != null && e[a] !== void 0
          ? (r += o + "{" + e[a] + "}")
          : pM(a) && (r += f_(o) + ":" + mM(o, a) + ";");
      } else if (
        Array.isArray(s) &&
        typeof s[0] == "string" &&
        (e == null || e[s[0]] === void 0)
      )
        for (var u = 0; u < s.length; u++)
          pM(s[u]) && (r += f_(o) + ":" + mM(o, s[u]) + ";");
      else {
        var c = Am(n, e, s);
        switch (o) {
          case "animation":
          case "animationName": {
            r += f_(o) + ":" + c + ";";
            break;
          }
          default:
            r += o + "{" + c + "}";
        }
      }
    }
  return r;
}
var gM = /label:\s*([^\s;{]+)\s*(;|$)/g,
  Ga;
function BS(n, e, t) {
  if (
    n.length === 1 &&
    typeof n[0] == "object" &&
    n[0] !== null &&
    n[0].styles !== void 0
  )
    return n[0];
  var r = !0,
    i = "";
  Ga = void 0;
  var o = n[0];
  if (o == null || o.raw === void 0) (r = !1), (i += Am(t, e, o));
  else {
    var s = o;
    i += s[0];
  }
  for (var a = 1; a < n.length; a++)
    if (((i += Am(t, e, n[a])), r)) {
      var u = o;
      i += u[a];
    }
  gM.lastIndex = 0;
  for (var c = "", d; (d = gM.exec(i)) !== null; ) c += "-" + d[1];
  var m = JI(i) + c;
  return { name: m, styles: i, next: Ga };
}
var rL = function (e) {
    return e();
  },
  bC = G1.useInsertionEffect ? G1.useInsertionEffect : !1,
  iL = bC || rL,
  vM = bC || X.useLayoutEffect,
  MC = X.createContext(typeof HTMLElement < "u" ? xC({ key: "css" }) : null),
  oL = MC.Provider,
  EC = function (e) {
    return X.forwardRef(function (t, r) {
      var i = X.useContext(MC);
      return e(t, i, r);
    });
  },
  Cy = X.createContext({}),
  sL = EC(function (n, e) {
    var t = n.styles,
      r = BS([t], void 0, X.useContext(Cy)),
      i = X.useRef();
    return (
      vM(
        function () {
          var o = e.key + "-global",
            s = new e.sheet.constructor({
              key: o,
              nonce: e.sheet.nonce,
              container: e.sheet.container,
              speedy: e.sheet.isSpeedy,
            }),
            a = !1,
            u = document.querySelector(
              'style[data-emotion="' + o + " " + r.name + '"]'
            );
          return (
            e.sheet.tags.length && (s.before = e.sheet.tags[0]),
            u !== null &&
              ((a = !0), u.setAttribute("data-emotion", o), s.hydrate([u])),
            (i.current = [s, a]),
            function () {
              s.flush();
            }
          );
        },
        [e]
      ),
      vM(
        function () {
          var o = i.current,
            s = o[0],
            a = o[1];
          if (a) {
            o[1] = !1;
            return;
          }
          if ((r.next !== void 0 && SC(e, r.next, !0), s.tags.length)) {
            var u = s.tags[s.tags.length - 1].nextElementSibling;
            (s.before = u), s.flush();
          }
          e.insert("", r, s, !1);
        },
        [e, r.name]
      ),
      null
    );
  });
function zS() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return BS(e);
}
var ng = function () {
    var e = zS.apply(void 0, arguments),
      t = "animation-" + e.name;
    return {
      name: t,
      styles: "@keyframes " + t + "{" + e.styles + "}",
      anim: 1,
      toString: function () {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      },
    };
  },
  aL = SI,
  lL = function (e) {
    return e !== "theme";
  },
  yM = function (e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? aL : lL;
  },
  xM = function (e, t, r) {
    var i;
    if (t) {
      var o = t.shouldForwardProp;
      i =
        e.__emotion_forwardProp && o
          ? function (s) {
              return e.__emotion_forwardProp(s) && o(s);
            }
          : o;
    }
    return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
  },
  uL = function (e) {
    var t = e.cache,
      r = e.serialized,
      i = e.isStringTag;
    return (
      _C(t, r, i),
      iL(function () {
        return SC(t, r, i);
      }),
      null
    );
  },
  cL = function n(e, t) {
    var r = e.__emotion_real === e,
      i = (r && e.__emotion_base) || e,
      o,
      s;
    t !== void 0 && ((o = t.label), (s = t.target));
    var a = xM(e, t, r),
      u = a || yM(i),
      c = !u("as");
    return function () {
      var d = arguments,
        m =
          r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (
        (o !== void 0 && m.push("label:" + o + ";"),
        d[0] == null || d[0].raw === void 0)
      )
        m.push.apply(m, d);
      else {
        m.push(d[0][0]);
        for (var g = d.length, y = 1; y < g; y++) m.push(d[y], d[0][y]);
      }
      var x = EC(function (S, _, w) {
        var T = (c && S.as) || i,
          M = "",
          A = [],
          R = S;
        if (S.theme == null) {
          R = {};
          for (var D in S) R[D] = S[D];
          R.theme = X.useContext(Cy);
        }
        typeof S.className == "string"
          ? (M = ZI(_.registered, A, S.className))
          : S.className != null && (M = S.className + " ");
        var P = BS(m.concat(A), _.registered, R);
        (M += _.key + "-" + P.name), s !== void 0 && (M += " " + s);
        var U = c && a === void 0 ? yM(T) : u,
          O = {};
        for (var L in S) (c && L === "as") || (U(L) && (O[L] = S[L]));
        return (
          (O.className = M),
          w && (O.ref = w),
          X.createElement(
            X.Fragment,
            null,
            X.createElement(uL, {
              cache: _,
              serialized: P,
              isStringTag: typeof T == "string",
            }),
            X.createElement(T, O)
          )
        );
      });
      return (
        (x.displayName =
          o !== void 0
            ? o
            : "Styled(" +
              (typeof i == "string"
                ? i
                : i.displayName || i.name || "Component") +
              ")"),
        (x.defaultProps = e.defaultProps),
        (x.__emotion_real = x),
        (x.__emotion_base = i),
        (x.__emotion_styles = m),
        (x.__emotion_forwardProp = a),
        Object.defineProperty(x, "toString", {
          value: function () {
            return "." + s;
          },
        }),
        (x.withComponent = function (S, _) {
          return n(S, ue({}, t, _, { shouldForwardProp: xM(x, _, !0) })).apply(
            void 0,
            m
          );
        }),
        x
      );
    };
  },
  fL = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  X1 = cL.bind();
fL.forEach(function (n) {
  X1[n] = X1(n);
});
let Y1;
typeof document == "object" && (Y1 = xC({ key: "css", prepend: !0 }));
function dL(n) {
  const { injectFirst: e, children: t } = n;
  return e && Y1 ? Q.jsx(oL, { value: Y1, children: t }) : t;
}
function hL(n) {
  return n == null || Object.keys(n).length === 0;
}
function TC(n) {
  const { styles: e, defaultTheme: t = {} } = n,
    r = typeof e == "function" ? (i) => e(hL(i) ? t : i) : e;
  return Q.jsx(sL, { styles: r });
}
function HS(n, e) {
  return X1(n, e);
}
const CC = (n, e) => {
    Array.isArray(n.__emotion_styles) &&
      (n.__emotion_styles = e(n.__emotion_styles));
  },
  pL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        GlobalStyles: TC,
        StyledEngineProvider: dL,
        ThemeContext: Cy,
        css: zS,
        default: HS,
        internal_processStyles: CC,
        keyframes: ng,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
function Dl(n) {
  if (typeof n != "object" || n === null) return !1;
  const e = Object.getPrototypeOf(n);
  return (
    (e === null ||
      e === Object.prototype ||
      Object.getPrototypeOf(e) === null) &&
    !(Symbol.toStringTag in n) &&
    !(Symbol.iterator in n)
  );
}
function AC(n) {
  if (X.isValidElement(n) || !Dl(n)) return n;
  const e = {};
  return (
    Object.keys(n).forEach((t) => {
      e[t] = AC(n[t]);
    }),
    e
  );
}
function ni(n, e, t = { clone: !0 }) {
  const r = t.clone ? ue({}, n) : n;
  return (
    Dl(n) &&
      Dl(e) &&
      Object.keys(e).forEach((i) => {
        X.isValidElement(e[i])
          ? (r[i] = e[i])
          : Dl(e[i]) && Object.prototype.hasOwnProperty.call(n, i) && Dl(n[i])
          ? (r[i] = ni(n[i], e[i], t))
          : t.clone
          ? (r[i] = Dl(e[i]) ? AC(e[i]) : e[i])
          : (r[i] = e[i]);
      }),
    r
  );
}
const mL = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: ni, isPlainObject: Dl },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  gL = ["values", "unit", "step"],
  vL = (n) => {
    const e = Object.keys(n).map((t) => ({ key: t, val: n[t] })) || [];
    return (
      e.sort((t, r) => t.val - r.val),
      e.reduce((t, r) => ue({}, t, { [r.key]: r.val }), {})
    );
  };
function VS(n) {
  const {
      values: e = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
      unit: t = "px",
      step: r = 5,
    } = n,
    i = It(n, gL),
    o = vL(e),
    s = Object.keys(o);
  function a(g) {
    return `@media (min-width:${typeof e[g] == "number" ? e[g] : g}${t})`;
  }
  function u(g) {
    return `@media (max-width:${
      (typeof e[g] == "number" ? e[g] : g) - r / 100
    }${t})`;
  }
  function c(g, y) {
    const x = s.indexOf(y);
    return `@media (min-width:${
      typeof e[g] == "number" ? e[g] : g
    }${t}) and (max-width:${
      (x !== -1 && typeof e[s[x]] == "number" ? e[s[x]] : y) - r / 100
    }${t})`;
  }
  function d(g) {
    return s.indexOf(g) + 1 < s.length ? c(g, s[s.indexOf(g) + 1]) : a(g);
  }
  function m(g) {
    const y = s.indexOf(g);
    return y === 0
      ? a(s[1])
      : y === s.length - 1
      ? u(s[y])
      : c(g, s[s.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return ue(
    {
      keys: s,
      values: o,
      up: a,
      down: u,
      between: c,
      only: d,
      not: m,
      unit: t,
    },
    i
  );
}
const yL = { borderRadius: 4 };
function lm(n, e) {
  return e ? ni(n, e, { clone: !1 }) : n;
}
const WS = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
  _M = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (n) => `@media (min-width:${WS[n]}px)`,
  };
function da(n, e, t) {
  const r = n.theme || {};
  if (Array.isArray(e)) {
    const o = r.breakpoints || _M;
    return e.reduce((s, a, u) => ((s[o.up(o.keys[u])] = t(e[u])), s), {});
  }
  if (typeof e == "object") {
    const o = r.breakpoints || _M;
    return Object.keys(e).reduce((s, a) => {
      if (Object.keys(o.values || WS).indexOf(a) !== -1) {
        const u = o.up(a);
        s[u] = t(e[a], a);
      } else {
        const u = a;
        s[u] = e[u];
      }
      return s;
    }, {});
  }
  return t(e);
}
function RC(n = {}) {
  var e;
  return (
    ((e = n.keys) == null
      ? void 0
      : e.reduce((r, i) => {
          const o = n.up(i);
          return (r[o] = {}), r;
        }, {})) || {}
  );
}
function PC(n, e) {
  return n.reduce((t, r) => {
    const i = t[r];
    return (!i || Object.keys(i).length === 0) && delete t[r], t;
  }, e);
}
function xL(n, ...e) {
  const t = RC(n),
    r = [t, ...e].reduce((i, o) => ni(i, o), {});
  return PC(Object.keys(t), r);
}
function _L(n, e) {
  if (typeof n != "object") return {};
  const t = {},
    r = Object.keys(e);
  return (
    Array.isArray(n)
      ? r.forEach((i, o) => {
          o < n.length && (t[i] = !0);
        })
      : r.forEach((i) => {
          n[i] != null && (t[i] = !0);
        }),
    t
  );
}
function d_({ values: n, breakpoints: e, base: t }) {
  const r = t || _L(n, e),
    i = Object.keys(r);
  if (i.length === 0) return n;
  let o;
  return i.reduce(
    (s, a, u) => (
      Array.isArray(n)
        ? ((s[a] = n[u] != null ? n[u] : n[o]), (o = u))
        : typeof n == "object"
        ? ((s[a] = n[a] != null ? n[a] : n[o]), (o = a))
        : (s[a] = n),
      s
    ),
    {}
  );
}
function an(n) {
  if (typeof n != "string") throw new Error(Bl(7));
  return n.charAt(0).toUpperCase() + n.slice(1);
}
const SL = Object.freeze(
  Object.defineProperty({ __proto__: null, default: an }, Symbol.toStringTag, {
    value: "Module",
  })
);
function Ay(n, e, t = !0) {
  if (!e || typeof e != "string") return null;
  if (n && n.vars && t) {
    const r = `vars.${e}`
      .split(".")
      .reduce((i, o) => (i && i[o] ? i[o] : null), n);
    if (r != null) return r;
  }
  return e.split(".").reduce((r, i) => (r && r[i] != null ? r[i] : null), n);
}
function R0(n, e, t, r = t) {
  let i;
  return (
    typeof n == "function"
      ? (i = n(t))
      : Array.isArray(n)
      ? (i = n[t] || r)
      : (i = Ay(n, t) || r),
    e && (i = e(i, r, n)),
    i
  );
}
function Ur(n) {
  const { prop: e, cssProperty: t = n.prop, themeKey: r, transform: i } = n,
    o = (s) => {
      if (s[e] == null) return null;
      const a = s[e],
        u = s.theme,
        c = Ay(u, r) || {};
      return da(s, a, (m) => {
        let g = R0(c, i, m);
        return (
          m === g &&
            typeof m == "string" &&
            (g = R0(c, i, `${e}${m === "default" ? "" : an(m)}`, m)),
          t === !1 ? g : { [t]: g }
        );
      });
    };
  return (o.propTypes = {}), (o.filterProps = [e]), o;
}
function wL(n) {
  const e = {};
  return (t) => (e[t] === void 0 && (e[t] = n(t)), e[t]);
}
const bL = { m: "margin", p: "padding" },
  ML = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"],
  },
  SM = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" },
  EL = wL((n) => {
    if (n.length > 2)
      if (SM[n]) n = SM[n];
      else return [n];
    const [e, t] = n.split(""),
      r = bL[e],
      i = ML[t] || "";
    return Array.isArray(i) ? i.map((o) => r + o) : [r + i];
  }),
  GS = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",
    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",
  ],
  jS = [
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
  ];
[...GS, ...jS];
function rg(n, e, t, r) {
  var i;
  const o = (i = Ay(n, e, !1)) != null ? i : t;
  return typeof o == "number"
    ? (s) => (typeof s == "string" ? s : o * s)
    : Array.isArray(o)
    ? (s) => (typeof s == "string" ? s : o[s])
    : typeof o == "function"
    ? o
    : () => {};
}
function $S(n) {
  return rg(n, "spacing", 8);
}
function Ef(n, e) {
  if (typeof e == "string" || e == null) return e;
  const t = Math.abs(e),
    r = n(t);
  return e >= 0 ? r : typeof r == "number" ? -r : `-${r}`;
}
function TL(n, e) {
  return (t) => n.reduce((r, i) => ((r[i] = Ef(e, t)), r), {});
}
function CL(n, e, t, r) {
  if (e.indexOf(t) === -1) return null;
  const i = EL(t),
    o = TL(i, r),
    s = n[t];
  return da(n, s, o);
}
function IC(n, e) {
  const t = $S(n.theme);
  return Object.keys(n)
    .map((r) => CL(n, e, r, t))
    .reduce(lm, {});
}
function Mr(n) {
  return IC(n, GS);
}
Mr.propTypes = {};
Mr.filterProps = GS;
function Er(n) {
  return IC(n, jS);
}
Er.propTypes = {};
Er.filterProps = jS;
function LC(n = 8) {
  if (n.mui) return n;
  const e = $S({ spacing: n }),
    t = (...r) =>
      (r.length === 0 ? [1] : r)
        .map((o) => {
          const s = e(o);
          return typeof s == "number" ? `${s}px` : s;
        })
        .join(" ");
  return (t.mui = !0), t;
}
function Ry(...n) {
  const e = n.reduce(
      (r, i) => (
        i.filterProps.forEach((o) => {
          r[o] = i;
        }),
        r
      ),
      {}
    ),
    t = (r) => Object.keys(r).reduce((i, o) => (e[o] ? lm(i, e[o](r)) : i), {});
  return (
    (t.propTypes = {}),
    (t.filterProps = n.reduce((r, i) => r.concat(i.filterProps), [])),
    t
  );
}
function Rs(n) {
  return typeof n != "number" ? n : `${n}px solid`;
}
function ks(n, e) {
  return Ur({ prop: n, themeKey: "borders", transform: e });
}
const AL = ks("border", Rs),
  RL = ks("borderTop", Rs),
  PL = ks("borderRight", Rs),
  IL = ks("borderBottom", Rs),
  LL = ks("borderLeft", Rs),
  DL = ks("borderColor"),
  kL = ks("borderTopColor"),
  OL = ks("borderRightColor"),
  NL = ks("borderBottomColor"),
  UL = ks("borderLeftColor"),
  FL = ks("outline", Rs),
  BL = ks("outlineColor"),
  Py = (n) => {
    if (n.borderRadius !== void 0 && n.borderRadius !== null) {
      const e = rg(n.theme, "shape.borderRadius", 4),
        t = (r) => ({ borderRadius: Ef(e, r) });
      return da(n, n.borderRadius, t);
    }
    return null;
  };
Py.propTypes = {};
Py.filterProps = ["borderRadius"];
Ry(AL, RL, PL, IL, LL, DL, kL, OL, NL, UL, Py, FL, BL);
const Iy = (n) => {
  if (n.gap !== void 0 && n.gap !== null) {
    const e = rg(n.theme, "spacing", 8),
      t = (r) => ({ gap: Ef(e, r) });
    return da(n, n.gap, t);
  }
  return null;
};
Iy.propTypes = {};
Iy.filterProps = ["gap"];
const Ly = (n) => {
  if (n.columnGap !== void 0 && n.columnGap !== null) {
    const e = rg(n.theme, "spacing", 8),
      t = (r) => ({ columnGap: Ef(e, r) });
    return da(n, n.columnGap, t);
  }
  return null;
};
Ly.propTypes = {};
Ly.filterProps = ["columnGap"];
const Dy = (n) => {
  if (n.rowGap !== void 0 && n.rowGap !== null) {
    const e = rg(n.theme, "spacing", 8),
      t = (r) => ({ rowGap: Ef(e, r) });
    return da(n, n.rowGap, t);
  }
  return null;
};
Dy.propTypes = {};
Dy.filterProps = ["rowGap"];
const zL = Ur({ prop: "gridColumn" }),
  HL = Ur({ prop: "gridRow" }),
  VL = Ur({ prop: "gridAutoFlow" }),
  WL = Ur({ prop: "gridAutoColumns" }),
  GL = Ur({ prop: "gridAutoRows" }),
  jL = Ur({ prop: "gridTemplateColumns" }),
  $L = Ur({ prop: "gridTemplateRows" }),
  XL = Ur({ prop: "gridTemplateAreas" }),
  YL = Ur({ prop: "gridArea" });
Ry(Iy, Ly, Dy, zL, HL, VL, WL, GL, jL, $L, XL, YL);
function Sh(n, e) {
  return e === "grey" ? e : n;
}
const qL = Ur({ prop: "color", themeKey: "palette", transform: Sh }),
  KL = Ur({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: Sh,
  }),
  ZL = Ur({ prop: "backgroundColor", themeKey: "palette", transform: Sh });
Ry(qL, KL, ZL);
function os(n) {
  return n <= 1 && n !== 0 ? `${n * 100}%` : n;
}
const JL = Ur({ prop: "width", transform: os }),
  XS = (n) => {
    if (n.maxWidth !== void 0 && n.maxWidth !== null) {
      const e = (t) => {
        var r, i;
        const o =
          ((r = n.theme) == null ||
          (r = r.breakpoints) == null ||
          (r = r.values) == null
            ? void 0
            : r[t]) || WS[t];
        return o
          ? ((i = n.theme) == null || (i = i.breakpoints) == null
              ? void 0
              : i.unit) !== "px"
            ? { maxWidth: `${o}${n.theme.breakpoints.unit}` }
            : { maxWidth: o }
          : { maxWidth: os(t) };
      };
      return da(n, n.maxWidth, e);
    }
    return null;
  };
XS.filterProps = ["maxWidth"];
const QL = Ur({ prop: "minWidth", transform: os }),
  eD = Ur({ prop: "height", transform: os }),
  tD = Ur({ prop: "maxHeight", transform: os }),
  nD = Ur({ prop: "minHeight", transform: os });
Ur({ prop: "size", cssProperty: "width", transform: os });
Ur({ prop: "size", cssProperty: "height", transform: os });
const rD = Ur({ prop: "boxSizing" });
Ry(JL, XS, QL, eD, tD, nD, rD);
const Fh = {
  border: { themeKey: "borders", transform: Rs },
  borderTop: { themeKey: "borders", transform: Rs },
  borderRight: { themeKey: "borders", transform: Rs },
  borderBottom: { themeKey: "borders", transform: Rs },
  borderLeft: { themeKey: "borders", transform: Rs },
  borderColor: { themeKey: "palette" },
  borderTopColor: { themeKey: "palette" },
  borderRightColor: { themeKey: "palette" },
  borderBottomColor: { themeKey: "palette" },
  borderLeftColor: { themeKey: "palette" },
  outline: { themeKey: "borders", transform: Rs },
  outlineColor: { themeKey: "palette" },
  borderRadius: { themeKey: "shape.borderRadius", style: Py },
  color: { themeKey: "palette", transform: Sh },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Sh,
  },
  backgroundColor: { themeKey: "palette", transform: Sh },
  p: { style: Er },
  pt: { style: Er },
  pr: { style: Er },
  pb: { style: Er },
  pl: { style: Er },
  px: { style: Er },
  py: { style: Er },
  padding: { style: Er },
  paddingTop: { style: Er },
  paddingRight: { style: Er },
  paddingBottom: { style: Er },
  paddingLeft: { style: Er },
  paddingX: { style: Er },
  paddingY: { style: Er },
  paddingInline: { style: Er },
  paddingInlineStart: { style: Er },
  paddingInlineEnd: { style: Er },
  paddingBlock: { style: Er },
  paddingBlockStart: { style: Er },
  paddingBlockEnd: { style: Er },
  m: { style: Mr },
  mt: { style: Mr },
  mr: { style: Mr },
  mb: { style: Mr },
  ml: { style: Mr },
  mx: { style: Mr },
  my: { style: Mr },
  margin: { style: Mr },
  marginTop: { style: Mr },
  marginRight: { style: Mr },
  marginBottom: { style: Mr },
  marginLeft: { style: Mr },
  marginX: { style: Mr },
  marginY: { style: Mr },
  marginInline: { style: Mr },
  marginInlineStart: { style: Mr },
  marginInlineEnd: { style: Mr },
  marginBlock: { style: Mr },
  marginBlockStart: { style: Mr },
  marginBlockEnd: { style: Mr },
  displayPrint: {
    cssProperty: !1,
    transform: (n) => ({ "@media print": { display: n } }),
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  gap: { style: Iy },
  rowGap: { style: Dy },
  columnGap: { style: Ly },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  position: {},
  zIndex: { themeKey: "zIndex" },
  top: {},
  right: {},
  bottom: {},
  left: {},
  boxShadow: { themeKey: "shadows" },
  width: { transform: os },
  maxWidth: { style: XS },
  minWidth: { transform: os },
  height: { transform: os },
  maxHeight: { transform: os },
  minHeight: { transform: os },
  boxSizing: {},
  fontFamily: { themeKey: "typography" },
  fontSize: { themeKey: "typography" },
  fontStyle: { themeKey: "typography" },
  fontWeight: { themeKey: "typography" },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: { cssProperty: !1, themeKey: "typography" },
};
function iD(...n) {
  const e = n.reduce((r, i) => r.concat(Object.keys(i)), []),
    t = new Set(e);
  return n.every((r) => t.size === Object.keys(r).length);
}
function oD(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function DC() {
  function n(t, r, i, o) {
    const s = { [t]: r, theme: i },
      a = o[t];
    if (!a) return { [t]: r };
    const { cssProperty: u = t, themeKey: c, transform: d, style: m } = a;
    if (r == null) return null;
    if (c === "typography" && r === "inherit") return { [t]: r };
    const g = Ay(i, c) || {};
    return m
      ? m(s)
      : da(s, r, (x) => {
          let S = R0(g, d, x);
          return (
            x === S &&
              typeof x == "string" &&
              (S = R0(g, d, `${t}${x === "default" ? "" : an(x)}`, x)),
            u === !1 ? S : { [u]: S }
          );
        });
  }
  function e(t) {
    var r;
    const { sx: i, theme: o = {} } = t || {};
    if (!i) return null;
    const s = (r = o.unstable_sxConfig) != null ? r : Fh;
    function a(u) {
      let c = u;
      if (typeof u == "function") c = u(o);
      else if (typeof u != "object") return u;
      if (!c) return null;
      const d = RC(o.breakpoints),
        m = Object.keys(d);
      let g = d;
      return (
        Object.keys(c).forEach((y) => {
          const x = oD(c[y], o);
          if (x != null)
            if (typeof x == "object")
              if (s[y]) g = lm(g, n(y, x, o, s));
              else {
                const S = da({ theme: o }, x, (_) => ({ [y]: _ }));
                iD(S, x) ? (g[y] = e({ sx: x, theme: o })) : (g = lm(g, S));
              }
            else g = lm(g, n(y, x, o, s));
        }),
        PC(m, g)
      );
    }
    return Array.isArray(i) ? i.map(a) : a(i);
  }
  return e;
}
const If = DC();
If.filterProps = ["sx"];
function YS(n, e) {
  const t = this;
  return t.vars && typeof t.getColorSchemeSelector == "function"
    ? {
        [t.getColorSchemeSelector(n).replace(/(\[[^\]]+\])/, "*:where($1)")]: e,
      }
    : t.palette.mode === n
    ? e
    : {};
}
const sD = ["breakpoints", "palette", "spacing", "shape"];
function ig(n = {}, ...e) {
  const { breakpoints: t = {}, palette: r = {}, spacing: i, shape: o = {} } = n,
    s = It(n, sD),
    a = VS(t),
    u = LC(i);
  let c = ni(
    {
      breakpoints: a,
      direction: "ltr",
      components: {},
      palette: ue({ mode: "light" }, r),
      spacing: u,
      shape: ue({}, yL, o),
    },
    s
  );
  return (
    (c.applyStyles = YS),
    (c = e.reduce((d, m) => ni(d, m), c)),
    (c.unstable_sxConfig = ue(
      {},
      Fh,
      s == null ? void 0 : s.unstable_sxConfig
    )),
    (c.unstable_sx = function (m) {
      return If({ sx: m, theme: this });
    }),
    c
  );
}
const aD = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      default: ig,
      private_createBreakpoints: VS,
      unstable_applyStyles: YS,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
function lD(n) {
  return Object.keys(n).length === 0;
}
function kC(n = null) {
  const e = X.useContext(Cy);
  return !e || lD(e) ? n : e;
}
const uD = ig();
function ky(n = uD) {
  return kC(n);
}
function cD({ styles: n, themeId: e, defaultTheme: t = {} }) {
  const r = ky(t),
    i = typeof n == "function" ? n((e && r[e]) || r) : n;
  return Q.jsx(TC, { styles: i });
}
const fD = ["sx"],
  dD = (n) => {
    var e, t;
    const r = { systemProps: {}, otherProps: {} },
      i =
        (e =
          n == null || (t = n.theme) == null ? void 0 : t.unstable_sxConfig) !=
        null
          ? e
          : Fh;
    return (
      Object.keys(n).forEach((o) => {
        i[o] ? (r.systemProps[o] = n[o]) : (r.otherProps[o] = n[o]);
      }),
      r
    );
  };
function Oy(n) {
  const { sx: e } = n,
    t = It(n, fD),
    { systemProps: r, otherProps: i } = dD(t);
  let o;
  return (
    Array.isArray(e)
      ? (o = [r, ...e])
      : typeof e == "function"
      ? (o = (...s) => {
          const a = e(...s);
          return Dl(a) ? ue({}, r, a) : r;
        })
      : (o = ue({}, r, e)),
    ue({}, i, { sx: o })
  );
}
const hD = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        default: If,
        extendSxProp: Oy,
        unstable_createStyleFunctionSx: DC,
        unstable_defaultSxConfig: Fh,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  wM = (n) => n,
  pD = () => {
    let n = wM;
    return {
      configure(e) {
        n = e;
      },
      generate(e) {
        return n(e);
      },
      reset() {
        n = wM;
      },
    };
  },
  qS = pD();
function OC(n) {
  var e,
    t,
    r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object")
    if (Array.isArray(n)) {
      var i = n.length;
      for (e = 0; e < i; e++)
        n[e] && (t = OC(n[e])) && (r && (r += " "), (r += t));
    } else for (t in n) n[t] && (r && (r += " "), (r += t));
  return r;
}
function Zt() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++)
    (n = arguments[t]) && (e = OC(n)) && (r && (r += " "), (r += e));
  return r;
}
const mD = ["className", "component"];
function gD(n = {}) {
  const {
      themeId: e,
      defaultTheme: t,
      defaultClassName: r = "MuiBox-root",
      generateClassName: i,
    } = n,
    o = HS("div", {
      shouldForwardProp: (a) => a !== "theme" && a !== "sx" && a !== "as",
    })(If);
  return X.forwardRef(function (u, c) {
    const d = ky(t),
      m = Oy(u),
      { className: g, component: y = "div" } = m,
      x = It(m, mD);
    return Q.jsx(
      o,
      ue(
        {
          as: y,
          ref: c,
          className: Zt(g, i ? i(r) : r),
          theme: (e && d[e]) || d,
        },
        x
      )
    );
  });
}
const vD = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected",
};
function Fn(n, e, t = "Mui") {
  const r = vD[e];
  return r ? `${t}-${r}` : `${qS.generate(n)}-${e}`;
}
function Ln(n, e, t = "Mui") {
  const r = {};
  return (
    e.forEach((i) => {
      r[i] = Fn(n, i, t);
    }),
    r
  );
}
var h_ = { exports: {} },
  Wn = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var bM;
function yD() {
  if (bM) return Wn;
  bM = 1;
  var n = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.consumer"),
    s = Symbol.for("react.context"),
    a = Symbol.for("react.forward_ref"),
    u = Symbol.for("react.suspense"),
    c = Symbol.for("react.suspense_list"),
    d = Symbol.for("react.memo"),
    m = Symbol.for("react.lazy"),
    g = Symbol.for("react.view_transition"),
    y = Symbol.for("react.client.reference");
  function x(S) {
    if (typeof S == "object" && S !== null) {
      var _ = S.$$typeof;
      switch (_) {
        case n:
          switch (((S = S.type), S)) {
            case t:
            case i:
            case r:
            case u:
            case c:
            case g:
              return S;
            default:
              switch (((S = S && S.$$typeof), S)) {
                case s:
                case a:
                case m:
                case d:
                  return S;
                case o:
                  return S;
                default:
                  return _;
              }
          }
        case e:
          return _;
      }
    }
  }
  return (
    (Wn.ContextConsumer = o),
    (Wn.ContextProvider = s),
    (Wn.Element = n),
    (Wn.ForwardRef = a),
    (Wn.Fragment = t),
    (Wn.Lazy = m),
    (Wn.Memo = d),
    (Wn.Portal = e),
    (Wn.Profiler = i),
    (Wn.StrictMode = r),
    (Wn.Suspense = u),
    (Wn.SuspenseList = c),
    (Wn.isContextConsumer = function (S) {
      return x(S) === o;
    }),
    (Wn.isContextProvider = function (S) {
      return x(S) === s;
    }),
    (Wn.isElement = function (S) {
      return typeof S == "object" && S !== null && S.$$typeof === n;
    }),
    (Wn.isForwardRef = function (S) {
      return x(S) === a;
    }),
    (Wn.isFragment = function (S) {
      return x(S) === t;
    }),
    (Wn.isLazy = function (S) {
      return x(S) === m;
    }),
    (Wn.isMemo = function (S) {
      return x(S) === d;
    }),
    (Wn.isPortal = function (S) {
      return x(S) === e;
    }),
    (Wn.isProfiler = function (S) {
      return x(S) === i;
    }),
    (Wn.isStrictMode = function (S) {
      return x(S) === r;
    }),
    (Wn.isSuspense = function (S) {
      return x(S) === u;
    }),
    (Wn.isSuspenseList = function (S) {
      return x(S) === c;
    }),
    (Wn.isValidElementType = function (S) {
      return (
        typeof S == "string" ||
        typeof S == "function" ||
        S === t ||
        S === i ||
        S === r ||
        S === u ||
        S === c ||
        (typeof S == "object" &&
          S !== null &&
          (S.$$typeof === m ||
            S.$$typeof === d ||
            S.$$typeof === s ||
            S.$$typeof === o ||
            S.$$typeof === a ||
            S.$$typeof === y ||
            S.getModuleId !== void 0))
      );
    }),
    (Wn.typeOf = x),
    Wn
  );
}
var MM;
function xD() {
  return MM || ((MM = 1), (h_.exports = yD())), h_.exports;
}
var EM = xD();
const _D = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function NC(n) {
  const e = `${n}`.match(_D);
  return (e && e[1]) || "";
}
function UC(n, e = "") {
  return n.displayName || n.name || NC(n) || e;
}
function TM(n, e, t) {
  const r = UC(e);
  return n.displayName || (r !== "" ? `${t}(${r})` : t);
}
function SD(n) {
  if (n != null) {
    if (typeof n == "string") return n;
    if (typeof n == "function") return UC(n, "Component");
    if (typeof n == "object")
      switch (n.$$typeof) {
        case EM.ForwardRef:
          return TM(n, n.render, "ForwardRef");
        case EM.Memo:
          return TM(n, n.type, "memo");
        default:
          return;
      }
  }
}
const wD = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: SD, getFunctionName: NC },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  bD = ["ownerState"],
  MD = ["variants"],
  ED = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function TD(n) {
  return Object.keys(n).length === 0;
}
function CD(n) {
  return typeof n == "string" && n.charCodeAt(0) > 96;
}
function p_(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
const AD = ig(),
  RD = (n) => n && n.charAt(0).toLowerCase() + n.slice(1);
function mv({ defaultTheme: n, theme: e, themeId: t }) {
  return TD(e) ? n : e[t] || e;
}
function PD(n) {
  return n ? (e, t) => t[n] : null;
}
function w0(n, e) {
  let { ownerState: t } = e,
    r = It(e, bD);
  const i = typeof n == "function" ? n(ue({ ownerState: t }, r)) : n;
  if (Array.isArray(i))
    return i.flatMap((o) => w0(o, ue({ ownerState: t }, r)));
  if (i && typeof i == "object" && Array.isArray(i.variants)) {
    const { variants: o = [] } = i;
    let a = It(i, MD);
    return (
      o.forEach((u) => {
        let c = !0;
        typeof u.props == "function"
          ? (c = u.props(ue({ ownerState: t }, r, t)))
          : Object.keys(u.props).forEach((d) => {
              (t == null ? void 0 : t[d]) !== u.props[d] &&
                r[d] !== u.props[d] &&
                (c = !1);
            }),
          c &&
            (Array.isArray(a) || (a = [a]),
            a.push(
              typeof u.style == "function"
                ? u.style(ue({ ownerState: t }, r, t))
                : u.style
            ));
      }),
      a
    );
  }
  return i;
}
function FC(n = {}) {
  const {
      themeId: e,
      defaultTheme: t = AD,
      rootShouldForwardProp: r = p_,
      slotShouldForwardProp: i = p_,
    } = n,
    o = (s) =>
      If(ue({}, s, { theme: mv(ue({}, s, { defaultTheme: t, themeId: e })) }));
  return (
    (o.__mui_systemSx = !0),
    (s, a = {}) => {
      CC(s, (R) => R.filter((D) => !(D != null && D.__mui_systemSx)));
      const {
          name: u,
          slot: c,
          skipVariantsResolver: d,
          skipSx: m,
          overridesResolver: g = PD(RD(c)),
        } = a,
        y = It(a, ED),
        x = d !== void 0 ? d : (c && c !== "Root" && c !== "root") || !1,
        S = m || !1;
      let _,
        w = p_;
      c === "Root" || c === "root"
        ? (w = r)
        : c
        ? (w = i)
        : CD(s) && (w = void 0);
      const T = HS(s, ue({ shouldForwardProp: w, label: _ }, y)),
        M = (R) =>
          (typeof R == "function" && R.__emotion_real !== R) || Dl(R)
            ? (D) =>
                w0(
                  R,
                  ue({}, D, {
                    theme: mv({ theme: D.theme, defaultTheme: t, themeId: e }),
                  })
                )
            : R,
        A = (R, ...D) => {
          let P = M(R);
          const U = D ? D.map(M) : [];
          u &&
            g &&
            U.push((H) => {
              const W = mv(ue({}, H, { defaultTheme: t, themeId: e }));
              if (
                !W.components ||
                !W.components[u] ||
                !W.components[u].styleOverrides
              )
                return null;
              const $ = W.components[u].styleOverrides,
                K = {};
              return (
                Object.entries($).forEach(([Z, Y]) => {
                  K[Z] = w0(Y, ue({}, H, { theme: W }));
                }),
                g(H, K)
              );
            }),
            u &&
              !x &&
              U.push((H) => {
                var W;
                const $ = mv(ue({}, H, { defaultTheme: t, themeId: e })),
                  K =
                    $ == null ||
                    (W = $.components) == null ||
                    (W = W[u]) == null
                      ? void 0
                      : W.variants;
                return w0({ variants: K }, ue({}, H, { theme: $ }));
              }),
            S || U.push(o);
          const O = U.length - D.length;
          if (Array.isArray(R) && O > 0) {
            const H = new Array(O).fill("");
            (P = [...R, ...H]), (P.raw = [...R.raw, ...H]);
          }
          const L = T(P, ...U);
          return s.muiName && (L.muiName = s.muiName), L;
        };
      return T.withConfig && (A.withConfig = T.withConfig), A;
    }
  );
}
const ID = FC();
function Rm(n, e) {
  const t = ue({}, e);
  return (
    Object.keys(n).forEach((r) => {
      if (r.toString().match(/^(components|slots)$/)) t[r] = ue({}, n[r], t[r]);
      else if (r.toString().match(/^(componentsProps|slotProps)$/)) {
        const i = n[r] || {},
          o = e[r];
        (t[r] = {}),
          !o || !Object.keys(o)
            ? (t[r] = i)
            : !i || !Object.keys(i)
            ? (t[r] = o)
            : ((t[r] = ue({}, o)),
              Object.keys(i).forEach((s) => {
                t[r][s] = Rm(i[s], o[s]);
              }));
      } else t[r] === void 0 && (t[r] = n[r]);
    }),
    t
  );
}
function BC(n) {
  const { theme: e, name: t, props: r } = n;
  return !e ||
    !e.components ||
    !e.components[t] ||
    !e.components[t].defaultProps
    ? r
    : Rm(e.components[t].defaultProps, r);
}
function zC({ props: n, name: e, defaultTheme: t, themeId: r }) {
  let i = ky(t);
  return r && (i = i[r] || i), BC({ theme: i, name: e, props: n });
}
const ha = typeof window < "u" ? X.useLayoutEffect : X.useEffect;
function LD(n, e, t, r, i) {
  const [o, s] = X.useState(() =>
    i && t ? t(n).matches : r ? r(n).matches : e
  );
  return (
    ha(() => {
      let a = !0;
      if (!t) return;
      const u = t(n),
        c = () => {
          a && s(u.matches);
        };
      return (
        c(),
        u.addListener(c),
        () => {
          (a = !1), u.removeListener(c);
        }
      );
    }, [n, t]),
    o
  );
}
const HC = X.useSyncExternalStore;
function DD(n, e, t, r, i) {
  const o = X.useCallback(() => e, [e]),
    s = X.useMemo(() => {
      if (i && t) return () => t(n).matches;
      if (r !== null) {
        const { matches: d } = r(n);
        return () => d;
      }
      return o;
    }, [o, n, r, i, t]),
    [a, u] = X.useMemo(() => {
      if (t === null) return [o, () => () => {}];
      const d = t(n);
      return [
        () => d.matches,
        (m) => (
          d.addListener(m),
          () => {
            d.removeListener(m);
          }
        ),
      ];
    }, [o, t, n]);
  return HC(u, a, s);
}
function kD(n, e = {}) {
  const t = kC(),
    r = typeof window < "u" && typeof window.matchMedia < "u",
    {
      defaultMatches: i = !1,
      matchMedia: o = r ? window.matchMedia : null,
      ssrMatchMedia: s = null,
      noSsr: a = !1,
    } = BC({ name: "MuiUseMediaQuery", props: e, theme: t });
  let u = n;
  return (
    (u = u.replace(/^@media( ?)/m, "")),
    (HC !== void 0 ? DD : LD)(u, i, o, s, a)
  );
}
function OD(n, e = Number.MIN_SAFE_INTEGER, t = Number.MAX_SAFE_INTEGER) {
  return Math.max(e, Math.min(n, t));
}
const ND = Object.freeze(
  Object.defineProperty({ __proto__: null, default: OD }, Symbol.toStringTag, {
    value: "Module",
  })
);
function UD(n) {
  n = n.slice(1);
  const e = new RegExp(`.{1,${n.length >= 6 ? 2 : 1}}`, "g");
  let t = n.match(e);
  return (
    t && t[0].length === 1 && (t = t.map((r) => r + r)),
    t
      ? `rgb${t.length === 4 ? "a" : ""}(${t
          .map((r, i) =>
            i < 3
              ? parseInt(r, 16)
              : Math.round((parseInt(r, 16) / 255) * 1e3) / 1e3
          )
          .join(", ")})`
      : ""
  );
}
function VC(n) {
  if (n.type) return n;
  if (n.charAt(0) === "#") return VC(UD(n));
  const e = n.indexOf("("),
    t = n.substring(0, e);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(t) === -1)
    throw new Error(Bl(9, n));
  let r = n.substring(e + 1, n.length - 1),
    i;
  if (t === "color") {
    if (
      ((r = r.split(" ")),
      (i = r.shift()),
      r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)),
      ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(
        i
      ) === -1)
    )
      throw new Error(Bl(10, i));
  } else r = r.split(",");
  return (
    (r = r.map((o) => parseFloat(o))), { type: t, values: r, colorSpace: i }
  );
}
const Dc = (n) => {
  const e = VC(n);
  return e.values
    .slice(0, 3)
    .map((t, r) => (e.type.indexOf("hsl") !== -1 && r !== 0 ? `${t}%` : t))
    .join(" ");
};
function q1(...n) {
  return n.reduce(
    (e, t) =>
      t == null
        ? e
        : function (...i) {
            e.apply(this, i), t.apply(this, i);
          },
    () => {}
  );
}
function KS(n, e = 166) {
  let t;
  function r(...i) {
    const o = () => {
      n.apply(this, i);
    };
    clearTimeout(t), (t = setTimeout(o, e));
  }
  return (
    (r.clear = () => {
      clearTimeout(t);
    }),
    r
  );
}
function FD(n, e) {
  return () => null;
}
function um(n, e) {
  var t, r;
  return (
    X.isValidElement(n) &&
    e.indexOf(
      (t = n.type.muiName) != null
        ? t
        : (r = n.type) == null ||
          (r = r._payload) == null ||
          (r = r.value) == null
        ? void 0
        : r.muiName
    ) !== -1
  );
}
function zo(n) {
  return (n && n.ownerDocument) || document;
}
function qu(n) {
  return zo(n).defaultView || window;
}
function BD(n, e) {
  return () => null;
}
function P0(n, e) {
  typeof n == "function" ? n(e) : n && (n.current = e);
}
let CM = 0;
function zD(n) {
  const [e, t] = X.useState(n),
    r = n || e;
  return (
    X.useEffect(() => {
      e == null && ((CM += 1), t(`mui-${CM}`));
    }, [e]),
    r
  );
}
const AM = G1.useId;
function ZS(n) {
  if (AM !== void 0) {
    const e = AM();
    return n ?? e;
  }
  return zD(n);
}
function HD(n, e, t, r, i) {
  return null;
}
function K1({ controlled: n, default: e, name: t, state: r = "value" }) {
  const { current: i } = X.useRef(n !== void 0),
    [o, s] = X.useState(e),
    a = i ? n : o,
    u = X.useCallback((c) => {
      i || s(c);
    }, []);
  return [a, u];
}
function ff(n) {
  const e = X.useRef(n);
  return (
    ha(() => {
      e.current = n;
    }),
    X.useRef((...t) => (0, e.current)(...t)).current
  );
}
function ri(...n) {
  return X.useMemo(
    () =>
      n.every((e) => e == null)
        ? null
        : (e) => {
            n.forEach((t) => {
              P0(t, e);
            });
          },
    n
  );
}
const RM = {};
function VD(n, e) {
  const t = X.useRef(RM);
  return t.current === RM && (t.current = n(e)), t;
}
const WD = [];
function GD(n) {
  X.useEffect(n, WD);
}
class Ny {
  constructor() {
    (this.currentId = null),
      (this.clear = () => {
        this.currentId !== null &&
          (clearTimeout(this.currentId), (this.currentId = null));
      }),
      (this.disposeEffect = () => this.clear);
  }
  static create() {
    return new Ny();
  }
  start(e, t) {
    this.clear(),
      (this.currentId = setTimeout(() => {
        (this.currentId = null), t();
      }, e));
  }
}
function WC() {
  const n = VD(Ny.create).current;
  return GD(n.disposeEffect), n;
}
let Uy = !0,
  Z1 = !1;
const jD = new Ny(),
  $D = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    "datetime-local": !0,
  };
function XD(n) {
  const { type: e, tagName: t } = n;
  return !!(
    (t === "INPUT" && $D[e] && !n.readOnly) ||
    (t === "TEXTAREA" && !n.readOnly) ||
    n.isContentEditable
  );
}
function YD(n) {
  n.metaKey || n.altKey || n.ctrlKey || (Uy = !0);
}
function m_() {
  Uy = !1;
}
function qD() {
  this.visibilityState === "hidden" && Z1 && (Uy = !0);
}
function KD(n) {
  n.addEventListener("keydown", YD, !0),
    n.addEventListener("mousedown", m_, !0),
    n.addEventListener("pointerdown", m_, !0),
    n.addEventListener("touchstart", m_, !0),
    n.addEventListener("visibilitychange", qD, !0);
}
function ZD(n) {
  const { target: e } = n;
  try {
    return e.matches(":focus-visible");
  } catch {}
  return Uy || XD(e);
}
function JS() {
  const n = X.useCallback((i) => {
      i != null && KD(i.ownerDocument);
    }, []),
    e = X.useRef(!1);
  function t() {
    return e.current
      ? ((Z1 = !0),
        jD.start(100, () => {
          Z1 = !1;
        }),
        (e.current = !1),
        !0)
      : !1;
  }
  function r(i) {
    return ZD(i) ? ((e.current = !0), !0) : !1;
  }
  return { isFocusVisibleRef: e, onFocus: r, onBlur: t, ref: n };
}
function GC(n) {
  const e = n.documentElement.clientWidth;
  return Math.abs(window.innerWidth - e);
}
function Bn(n, e, t = void 0) {
  const r = {};
  return (
    Object.keys(n).forEach((i) => {
      r[i] = n[i]
        .reduce((o, s) => {
          if (s) {
            const a = e(s);
            a !== "" && o.push(a), t && t[s] && o.push(t[s]);
          }
          return o;
        }, [])
        .join(" ");
    }),
    r
  );
}
function Ch(n) {
  return typeof n == "string";
}
function jC(n, e, t) {
  return n === void 0 || Ch(n)
    ? e
    : ue({}, e, { ownerState: ue({}, e.ownerState, t) });
}
function I0(n, e = []) {
  if (n === void 0) return {};
  const t = {};
  return (
    Object.keys(n)
      .filter(
        (r) =>
          r.match(/^on[A-Z]/) && typeof n[r] == "function" && !e.includes(r)
      )
      .forEach((r) => {
        t[r] = n[r];
      }),
    t
  );
}
function PM(n) {
  if (n === void 0) return {};
  const e = {};
  return (
    Object.keys(n)
      .filter((t) => !(t.match(/^on[A-Z]/) && typeof n[t] == "function"))
      .forEach((t) => {
        e[t] = n[t];
      }),
    e
  );
}
function $C(n) {
  const {
    getSlotProps: e,
    additionalProps: t,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: o,
  } = n;
  if (!e) {
    const y = Zt(
        t == null ? void 0 : t.className,
        o,
        i == null ? void 0 : i.className,
        r == null ? void 0 : r.className
      ),
      x = ue(
        {},
        t == null ? void 0 : t.style,
        i == null ? void 0 : i.style,
        r == null ? void 0 : r.style
      ),
      S = ue({}, t, i, r);
    return (
      y.length > 0 && (S.className = y),
      Object.keys(x).length > 0 && (S.style = x),
      { props: S, internalRef: void 0 }
    );
  }
  const s = I0(ue({}, i, r)),
    a = PM(r),
    u = PM(i),
    c = e(s),
    d = Zt(
      c == null ? void 0 : c.className,
      t == null ? void 0 : t.className,
      o,
      i == null ? void 0 : i.className,
      r == null ? void 0 : r.className
    ),
    m = ue(
      {},
      c == null ? void 0 : c.style,
      t == null ? void 0 : t.style,
      i == null ? void 0 : i.style,
      r == null ? void 0 : r.style
    ),
    g = ue({}, c, t, u, a);
  return (
    d.length > 0 && (g.className = d),
    Object.keys(m).length > 0 && (g.style = m),
    { props: g, internalRef: c.ref }
  );
}
function XC(n, e, t) {
  return typeof n == "function" ? n(e, t) : n;
}
const JD = [
  "elementType",
  "externalSlotProps",
  "ownerState",
  "skipResolvingSlotProps",
];
function Ah(n) {
  var e;
  const {
      elementType: t,
      externalSlotProps: r,
      ownerState: i,
      skipResolvingSlotProps: o = !1,
    } = n,
    s = It(n, JD),
    a = o ? {} : XC(r, i),
    { props: u, internalRef: c } = $C(ue({}, s, { externalSlotProps: a })),
    d = ri(
      c,
      a == null ? void 0 : a.ref,
      (e = n.additionalProps) == null ? void 0 : e.ref
    );
  return jC(t, ue({}, u, { ref: d }), i);
}
const QD = X.createContext(),
  ek = () => {
    const n = X.useContext(QD);
    return n ?? !1;
  },
  tk = X.createContext(void 0);
function nk(n) {
  const { theme: e, name: t, props: r } = n;
  if (!e || !e.components || !e.components[t]) return r;
  const i = e.components[t];
  return i.defaultProps
    ? Rm(i.defaultProps, r)
    : !i.styleOverrides && !i.variants
    ? Rm(i, r)
    : r;
}
function rk({ props: n, name: e }) {
  const t = X.useContext(tk);
  return nk({ props: n, name: e, theme: { components: t } });
}
function ik(n = "") {
  function e(...r) {
    if (!r.length) return "";
    const i = r[0];
    return typeof i == "string" &&
      !i.match(
        /(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/
      )
      ? `, var(--${n ? `${n}-` : ""}${i}${e(...r.slice(1))})`
      : `, ${i}`;
  }
  return (r, ...i) => `var(--${n ? `${n}-` : ""}${r}${e(...i)})`;
}
const IM = (n, e, t, r = []) => {
    let i = n;
    e.forEach((o, s) => {
      s === e.length - 1
        ? Array.isArray(i)
          ? (i[Number(o)] = t)
          : i && typeof i == "object" && (i[o] = t)
        : i &&
          typeof i == "object" &&
          (i[o] || (i[o] = r.includes(o) ? [] : {}), (i = i[o]));
    });
  },
  ok = (n, e, t) => {
    function r(i, o = [], s = []) {
      Object.entries(i).forEach(([a, u]) => {
        (!t || (t && !t([...o, a]))) &&
          u != null &&
          (typeof u == "object" && Object.keys(u).length > 0
            ? r(u, [...o, a], Array.isArray(u) ? [...s, a] : s)
            : e([...o, a], u, s));
      });
    }
    r(n);
  },
  sk = (n, e) =>
    typeof e == "number"
      ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) =>
          n.includes(r)
        ) || n[n.length - 1].toLowerCase().indexOf("opacity") >= 0
        ? e
        : `${e}px`
      : e;
function g_(n, e) {
  const { prefix: t, shouldSkipGeneratingVar: r } = e || {},
    i = {},
    o = {},
    s = {};
  return (
    ok(
      n,
      (a, u, c) => {
        if (
          (typeof u == "string" || typeof u == "number") &&
          (!r || !r(a, u))
        ) {
          const d = `--${t ? `${t}-` : ""}${a.join("-")}`;
          Object.assign(i, { [d]: sk(a, u) }),
            IM(o, a, `var(${d})`, c),
            IM(s, a, `var(${d}, ${u})`, c);
        }
      },
      (a) => a[0] === "vars"
    ),
    { css: i, vars: o, varsWithDefaults: s }
  );
}
function Pm(n) {
  "@babel/helpers - typeof";
  return (
    (Pm =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Pm(n)
  );
}
function ak(n, e) {
  if (Pm(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e);
    if (Pm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function YC(n) {
  var e = ak(n, "string");
  return Pm(e) == "symbol" ? e : e + "";
}
const lk = ["colorSchemes", "components", "defaultColorScheme"];
function uk(n, e) {
  const { colorSchemes: t = {}, defaultColorScheme: r = "light" } = n,
    i = It(n, lk),
    { vars: o, css: s, varsWithDefaults: a } = g_(i, e);
  let u = a;
  const c = {},
    { [r]: d } = t,
    m = It(t, [r].map(YC));
  if (
    (Object.entries(m || {}).forEach(([y, x]) => {
      const { vars: S, css: _, varsWithDefaults: w } = g_(x, e);
      (u = ni(u, w)), (c[y] = { css: _, vars: S });
    }),
    d)
  ) {
    const { css: y, vars: x, varsWithDefaults: S } = g_(d, e);
    (u = ni(u, S)), (c[r] = { css: y, vars: x });
  }
  return {
    vars: u,
    generateCssVars: (y) => {
      var x;
      if (!y) {
        var S;
        const w = ue({}, s);
        return {
          css: w,
          vars: o,
          selector:
            (e == null || (S = e.getSelector) == null
              ? void 0
              : S.call(e, y, w)) || ":root",
        };
      }
      const _ = ue({}, c[y].css);
      return {
        css: _,
        vars: c[y].vars,
        selector:
          (e == null || (x = e.getSelector) == null
            ? void 0
            : x.call(e, y, _)) || ":root",
      };
    },
  };
}
const ck = [
    "component",
    "direction",
    "spacing",
    "divider",
    "children",
    "className",
    "useFlexGap",
  ],
  fk = ig(),
  dk = ID("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  });
function hk(n) {
  return zC({ props: n, name: "MuiStack", defaultTheme: fk });
}
function pk(n, e) {
  const t = X.Children.toArray(n).filter(Boolean);
  return t.reduce(
    (r, i, o) => (
      r.push(i),
      o < t.length - 1 && r.push(X.cloneElement(e, { key: `separator-${o}` })),
      r
    ),
    []
  );
}
const mk = (n) =>
    ({
      row: "Left",
      "row-reverse": "Right",
      column: "Top",
      "column-reverse": "Bottom",
    }[n]),
  gk = ({ ownerState: n, theme: e }) => {
    let t = ue(
      { display: "flex", flexDirection: "column" },
      da(
        { theme: e },
        d_({ values: n.direction, breakpoints: e.breakpoints.values }),
        (r) => ({ flexDirection: r })
      )
    );
    if (n.spacing) {
      const r = $S(e),
        i = Object.keys(e.breakpoints.values).reduce(
          (u, c) => (
            ((typeof n.spacing == "object" && n.spacing[c] != null) ||
              (typeof n.direction == "object" && n.direction[c] != null)) &&
              (u[c] = !0),
            u
          ),
          {}
        ),
        o = d_({ values: n.direction, base: i }),
        s = d_({ values: n.spacing, base: i });
      typeof o == "object" &&
        Object.keys(o).forEach((u, c, d) => {
          if (!o[u]) {
            const g = c > 0 ? o[d[c - 1]] : "column";
            o[u] = g;
          }
        }),
        (t = ni(
          t,
          da({ theme: e }, s, (u, c) =>
            n.useFlexGap
              ? { gap: Ef(r, u) }
              : {
                  "& > :not(style):not(style)": { margin: 0 },
                  "& > :not(style) ~ :not(style)": {
                    [`margin${mk(c ? o[c] : n.direction)}`]: Ef(r, u),
                  },
                }
          )
        ));
    }
    return (t = xL(e.breakpoints, t)), t;
  };
function vk(n = {}) {
  const {
      createStyledComponent: e = dk,
      useThemeProps: t = hk,
      componentName: r = "MuiStack",
    } = n,
    i = () => Bn({ root: ["root"] }, (u) => Fn(r, u), {}),
    o = e(gk);
  return X.forwardRef(function (u, c) {
    const d = t(u),
      m = Oy(d),
      {
        component: g = "div",
        direction: y = "column",
        spacing: x = 0,
        divider: S,
        children: _,
        className: w,
        useFlexGap: T = !1,
      } = m,
      M = It(m, ck),
      A = { direction: y, spacing: x, useFlexGap: T },
      R = i();
    return Q.jsx(
      o,
      ue({ as: g, ownerState: A, ref: c, className: Zt(R.root, w) }, M, {
        children: S ? pk(_, S) : _,
      })
    );
  });
}
function yk(n, e) {
  return ue(
    {
      toolbar: {
        minHeight: 56,
        [n.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
        [n.up("sm")]: { minHeight: 64 },
      },
    },
    e
  );
}
var gr = {},
  v_ = { exports: {} },
  LM;
function QS() {
  return (
    LM ||
      ((LM = 1),
      (function (n) {
        function e(t) {
          return t && t.__esModule ? t : { default: t };
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(v_)),
    v_.exports
  );
}
const xk = Gl(xI),
  _k = Gl(ND);
var DM;
function Sk() {
  if (DM) return gr;
  DM = 1;
  var n = QS();
  Object.defineProperty(gr, "__esModule", { value: !0 }),
    (gr.alpha = x),
    (gr.blend = D),
    (gr.colorChannel = void 0),
    (gr.darken = _),
    (gr.decomposeColor = s),
    (gr.emphasize = A),
    (gr.getContrastRatio = y),
    (gr.getLuminance = g),
    (gr.hexToRgb = i),
    (gr.hslToRgb = m),
    (gr.lighten = T),
    (gr.private_safeAlpha = S),
    (gr.private_safeColorChannel = void 0),
    (gr.private_safeDarken = w),
    (gr.private_safeEmphasize = R),
    (gr.private_safeLighten = M),
    (gr.recomposeColor = c),
    (gr.rgbToHex = d);
  var e = n(xk),
    t = n(_k);
  function r(P, U = 0, O = 1) {
    return (0, t.default)(P, U, O);
  }
  function i(P) {
    P = P.slice(1);
    const U = new RegExp(`.{1,${P.length >= 6 ? 2 : 1}}`, "g");
    let O = P.match(U);
    return (
      O && O[0].length === 1 && (O = O.map((L) => L + L)),
      O
        ? `rgb${O.length === 4 ? "a" : ""}(${O.map((L, H) =>
            H < 3
              ? parseInt(L, 16)
              : Math.round((parseInt(L, 16) / 255) * 1e3) / 1e3
          ).join(", ")})`
        : ""
    );
  }
  function o(P) {
    const U = P.toString(16);
    return U.length === 1 ? `0${U}` : U;
  }
  function s(P) {
    if (P.type) return P;
    if (P.charAt(0) === "#") return s(i(P));
    const U = P.indexOf("("),
      O = P.substring(0, U);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(O) === -1)
      throw new Error((0, e.default)(9, P));
    let L = P.substring(U + 1, P.length - 1),
      H;
    if (O === "color") {
      if (
        ((L = L.split(" ")),
        (H = L.shift()),
        L.length === 4 && L[3].charAt(0) === "/" && (L[3] = L[3].slice(1)),
        ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(
          H
        ) === -1)
      )
        throw new Error((0, e.default)(10, H));
    } else L = L.split(",");
    return (
      (L = L.map((W) => parseFloat(W))), { type: O, values: L, colorSpace: H }
    );
  }
  const a = (P) => {
    const U = s(P);
    return U.values
      .slice(0, 3)
      .map((O, L) => (U.type.indexOf("hsl") !== -1 && L !== 0 ? `${O}%` : O))
      .join(" ");
  };
  gr.colorChannel = a;
  const u = (P, U) => {
    try {
      return a(P);
    } catch {
      return P;
    }
  };
  gr.private_safeColorChannel = u;
  function c(P) {
    const { type: U, colorSpace: O } = P;
    let { values: L } = P;
    return (
      U.indexOf("rgb") !== -1
        ? (L = L.map((H, W) => (W < 3 ? parseInt(H, 10) : H)))
        : U.indexOf("hsl") !== -1 && ((L[1] = `${L[1]}%`), (L[2] = `${L[2]}%`)),
      U.indexOf("color") !== -1
        ? (L = `${O} ${L.join(" ")}`)
        : (L = `${L.join(", ")}`),
      `${U}(${L})`
    );
  }
  function d(P) {
    if (P.indexOf("#") === 0) return P;
    const { values: U } = s(P);
    return `#${U.map((O, L) => o(L === 3 ? Math.round(255 * O) : O)).join("")}`;
  }
  function m(P) {
    P = s(P);
    const { values: U } = P,
      O = U[0],
      L = U[1] / 100,
      H = U[2] / 100,
      W = L * Math.min(H, 1 - H),
      $ = (Y, re = (Y + O / 30) % 12) =>
        H - W * Math.max(Math.min(re - 3, 9 - re, 1), -1);
    let K = "rgb";
    const Z = [
      Math.round($(0) * 255),
      Math.round($(8) * 255),
      Math.round($(4) * 255),
    ];
    return (
      P.type === "hsla" && ((K += "a"), Z.push(U[3])), c({ type: K, values: Z })
    );
  }
  function g(P) {
    P = s(P);
    let U = P.type === "hsl" || P.type === "hsla" ? s(m(P)).values : P.values;
    return (
      (U = U.map(
        (O) => (
          P.type !== "color" && (O /= 255),
          O <= 0.03928 ? O / 12.92 : ((O + 0.055) / 1.055) ** 2.4
        )
      )),
      Number((0.2126 * U[0] + 0.7152 * U[1] + 0.0722 * U[2]).toFixed(3))
    );
  }
  function y(P, U) {
    const O = g(P),
      L = g(U);
    return (Math.max(O, L) + 0.05) / (Math.min(O, L) + 0.05);
  }
  function x(P, U) {
    return (
      (P = s(P)),
      (U = r(U)),
      (P.type === "rgb" || P.type === "hsl") && (P.type += "a"),
      P.type === "color" ? (P.values[3] = `/${U}`) : (P.values[3] = U),
      c(P)
    );
  }
  function S(P, U, O) {
    try {
      return x(P, U);
    } catch {
      return P;
    }
  }
  function _(P, U) {
    if (((P = s(P)), (U = r(U)), P.type.indexOf("hsl") !== -1))
      P.values[2] *= 1 - U;
    else if (P.type.indexOf("rgb") !== -1 || P.type.indexOf("color") !== -1)
      for (let O = 0; O < 3; O += 1) P.values[O] *= 1 - U;
    return c(P);
  }
  function w(P, U, O) {
    try {
      return _(P, U);
    } catch {
      return P;
    }
  }
  function T(P, U) {
    if (((P = s(P)), (U = r(U)), P.type.indexOf("hsl") !== -1))
      P.values[2] += (100 - P.values[2]) * U;
    else if (P.type.indexOf("rgb") !== -1)
      for (let O = 0; O < 3; O += 1) P.values[O] += (255 - P.values[O]) * U;
    else if (P.type.indexOf("color") !== -1)
      for (let O = 0; O < 3; O += 1) P.values[O] += (1 - P.values[O]) * U;
    return c(P);
  }
  function M(P, U, O) {
    try {
      return T(P, U);
    } catch {
      return P;
    }
  }
  function A(P, U = 0.15) {
    return g(P) > 0.5 ? _(P, U) : T(P, U);
  }
  function R(P, U, O) {
    try {
      return A(P, U);
    } catch {
      return P;
    }
  }
  function D(P, U, O, L = 1) {
    const H = (Z, Y) =>
        Math.round((Z ** (1 / L) * (1 - O) + Y ** (1 / L) * O) ** L),
      W = s(P),
      $ = s(U),
      K = [
        H(W.values[0], $.values[0]),
        H(W.values[1], $.values[1]),
        H(W.values[2], $.values[2]),
      ];
    return c({ type: "rgb", values: K });
  }
  return gr;
}
var Bi = Sk();
const wk = ["mode", "contrastThreshold", "tonalOffset"],
  kM = {
    text: {
      primary: "rgba(0, 0, 0, 0.87)",
      secondary: "rgba(0, 0, 0, 0.6)",
      disabled: "rgba(0, 0, 0, 0.38)",
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: { paper: Em.white, default: Em.white },
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  },
  y_ = {
    text: {
      primary: Em.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)",
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: { paper: "#121212", default: "#121212" },
    action: {
      active: Em.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  };
function OM(n, e, t, r) {
  const i = r.light || r,
    o = r.dark || r * 1.5;
  n[e] ||
    (n.hasOwnProperty(t)
      ? (n[e] = n[t])
      : e === "light"
      ? (n.light = Bi.lighten(n.main, i))
      : e === "dark" && (n.dark = Bi.darken(n.main, o)));
}
function bk(n = "light") {
  return n === "dark"
    ? { main: kd[200], light: kd[50], dark: kd[400] }
    : { main: kd[700], light: kd[400], dark: kd[800] };
}
function Mk(n = "light") {
  return n === "dark"
    ? { main: Dd[200], light: Dd[50], dark: Dd[400] }
    : { main: Dd[500], light: Dd[300], dark: Dd[700] };
}
function Ek(n = "light") {
  return n === "dark"
    ? { main: Ld[500], light: Ld[300], dark: Ld[700] }
    : { main: Ld[700], light: Ld[400], dark: Ld[800] };
}
function Tk(n = "light") {
  return n === "dark"
    ? { main: Od[400], light: Od[300], dark: Od[700] }
    : { main: Od[700], light: Od[500], dark: Od[900] };
}
function Ck(n = "light") {
  return n === "dark"
    ? { main: Nd[400], light: Nd[300], dark: Nd[700] }
    : { main: Nd[800], light: Nd[500], dark: Nd[900] };
}
function Ak(n = "light") {
  return n === "dark"
    ? { main: Lp[400], light: Lp[300], dark: Lp[700] }
    : { main: "#ed6c02", light: Lp[500], dark: Lp[900] };
}
function Rk(n) {
  const {
      mode: e = "light",
      contrastThreshold: t = 3,
      tonalOffset: r = 0.2,
    } = n,
    i = It(n, wk),
    o = n.primary || bk(e),
    s = n.secondary || Mk(e),
    a = n.error || Ek(e),
    u = n.info || Tk(e),
    c = n.success || Ck(e),
    d = n.warning || Ak(e);
  function m(S) {
    return Bi.getContrastRatio(S, y_.text.primary) >= t
      ? y_.text.primary
      : kM.text.primary;
  }
  const g = ({
      color: S,
      name: _,
      mainShade: w = 500,
      lightShade: T = 300,
      darkShade: M = 700,
    }) => {
      if (
        ((S = ue({}, S)),
        !S.main && S[w] && (S.main = S[w]),
        !S.hasOwnProperty("main"))
      )
        throw new Error(Bl(11, _ ? ` (${_})` : "", w));
      if (typeof S.main != "string")
        throw new Error(Bl(12, _ ? ` (${_})` : "", JSON.stringify(S.main)));
      return (
        OM(S, "light", T, r),
        OM(S, "dark", M, r),
        S.contrastText || (S.contrastText = m(S.main)),
        S
      );
    },
    y = { dark: y_, light: kM };
  return ni(
    ue(
      {
        common: ue({}, Em),
        mode: e,
        primary: g({ color: o, name: "primary" }),
        secondary: g({
          color: s,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700",
        }),
        error: g({ color: a, name: "error" }),
        warning: g({ color: d, name: "warning" }),
        info: g({ color: u, name: "info" }),
        success: g({ color: c, name: "success" }),
        grey: yI,
        contrastThreshold: t,
        getContrastText: m,
        augmentColor: g,
        tonalOffset: r,
      },
      y[e]
    ),
    i
  );
}
const Pk = [
  "fontFamily",
  "fontSize",
  "fontWeightLight",
  "fontWeightRegular",
  "fontWeightMedium",
  "fontWeightBold",
  "htmlFontSize",
  "allVariants",
  "pxToRem",
];
function Ik(n) {
  return Math.round(n * 1e5) / 1e5;
}
const NM = { textTransform: "uppercase" },
  UM = '"Roboto", "Helvetica", "Arial", sans-serif';
function Lk(n, e) {
  const t = typeof e == "function" ? e(n) : e,
    {
      fontFamily: r = UM,
      fontSize: i = 14,
      fontWeightLight: o = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: a = 500,
      fontWeightBold: u = 700,
      htmlFontSize: c = 16,
      allVariants: d,
      pxToRem: m,
    } = t,
    g = It(t, Pk),
    y = i / 14,
    x = m || ((w) => `${(w / c) * y}rem`),
    S = (w, T, M, A, R) =>
      ue(
        { fontFamily: r, fontWeight: w, fontSize: x(T), lineHeight: M },
        r === UM ? { letterSpacing: `${Ik(A / T)}em` } : {},
        R,
        d
      ),
    _ = {
      h1: S(o, 96, 1.167, -1.5),
      h2: S(o, 60, 1.2, -0.5),
      h3: S(s, 48, 1.167, 0),
      h4: S(s, 34, 1.235, 0.25),
      h5: S(s, 24, 1.334, 0),
      h6: S(a, 20, 1.6, 0.15),
      subtitle1: S(s, 16, 1.75, 0.15),
      subtitle2: S(a, 14, 1.57, 0.1),
      body1: S(s, 16, 1.5, 0.15),
      body2: S(s, 14, 1.43, 0.15),
      button: S(a, 14, 1.75, 0.4, NM),
      caption: S(s, 12, 1.66, 0.4),
      overline: S(s, 12, 2.66, 1, NM),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit",
      },
    };
  return ni(
    ue(
      {
        htmlFontSize: c,
        pxToRem: x,
        fontFamily: r,
        fontSize: i,
        fontWeightLight: o,
        fontWeightRegular: s,
        fontWeightMedium: a,
        fontWeightBold: u,
      },
      _
    ),
    g,
    { clone: !1 }
  );
}
const Dk = 0.2,
  kk = 0.14,
  Ok = 0.12;
function ar(...n) {
  return [
    `${n[0]}px ${n[1]}px ${n[2]}px ${n[3]}px rgba(0,0,0,${Dk})`,
    `${n[4]}px ${n[5]}px ${n[6]}px ${n[7]}px rgba(0,0,0,${kk})`,
    `${n[8]}px ${n[9]}px ${n[10]}px ${n[11]}px rgba(0,0,0,${Ok})`,
  ].join(",");
}
const Nk = [
    "none",
    ar(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    ar(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    ar(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    ar(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    ar(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    ar(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    ar(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    ar(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    ar(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    ar(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    ar(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    ar(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    ar(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    ar(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    ar(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    ar(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    ar(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    ar(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    ar(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    ar(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    ar(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    ar(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    ar(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    ar(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  Uk = ["duration", "easing", "delay"],
  Fk = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
  },
  Bk = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195,
  };
function FM(n) {
  return `${Math.round(n)}ms`;
}
function zk(n) {
  if (!n) return 0;
  const e = n / 36;
  return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
}
function Hk(n) {
  const e = ue({}, Fk, n.easing),
    t = ue({}, Bk, n.duration);
  return ue(
    {
      getAutoHeightDuration: zk,
      create: (i = ["all"], o = {}) => {
        const {
          duration: s = t.standard,
          easing: a = e.easeInOut,
          delay: u = 0,
        } = o;
        return (
          It(o, Uk),
          (Array.isArray(i) ? i : [i])
            .map(
              (c) =>
                `${c} ${typeof s == "string" ? s : FM(s)} ${a} ${
                  typeof u == "string" ? u : FM(u)
                }`
            )
            .join(",")
        );
      },
    },
    n,
    { easing: e, duration: t }
  );
}
const Vk = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500,
  },
  Wk = [
    "breakpoints",
    "mixins",
    "spacing",
    "palette",
    "transitions",
    "typography",
    "shape",
  ];
function qC(n = {}, ...e) {
  const {
      mixins: t = {},
      palette: r = {},
      transitions: i = {},
      typography: o = {},
    } = n,
    s = It(n, Wk);
  if (n.vars) throw new Error(Bl(18));
  const a = Rk(r),
    u = ig(n);
  let c = ni(u, {
    mixins: yk(u.breakpoints, t),
    palette: a,
    shadows: Nk.slice(),
    typography: Lk(a, o),
    transitions: Hk(i),
    zIndex: ue({}, Vk),
  });
  return (
    (c = ni(c, s)),
    (c = e.reduce((d, m) => ni(d, m), c)),
    (c.unstable_sxConfig = ue(
      {},
      Fh,
      s == null ? void 0 : s.unstable_sxConfig
    )),
    (c.unstable_sx = function (m) {
      return If({ sx: m, theme: this });
    }),
    c
  );
}
const ew = qC();
function KC() {
  const n = ky(ew);
  return n[by] || n;
}
var kc = {},
  x_ = { exports: {} },
  BM;
function Gk() {
  return (
    BM ||
      ((BM = 1),
      (function (n) {
        function e() {
          return (
            (n.exports = e =
              Object.assign
                ? Object.assign.bind()
                : function (t) {
                    for (var r = 1; r < arguments.length; r++) {
                      var i = arguments[r];
                      for (var o in i)
                        ({}).hasOwnProperty.call(i, o) && (t[o] = i[o]);
                    }
                    return t;
                  }),
            (n.exports.__esModule = !0),
            (n.exports.default = n.exports),
            e.apply(null, arguments)
          );
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(x_)),
    x_.exports
  );
}
var __ = { exports: {} },
  zM;
function jk() {
  return (
    zM ||
      ((zM = 1),
      (function (n) {
        function e(t, r) {
          if (t == null) return {};
          var i = {};
          for (var o in t)
            if ({}.hasOwnProperty.call(t, o)) {
              if (r.indexOf(o) !== -1) continue;
              i[o] = t[o];
            }
          return i;
        }
        (n.exports = e),
          (n.exports.__esModule = !0),
          (n.exports.default = n.exports);
      })(__)),
    __.exports
  );
}
const $k = Gl(pL),
  Xk = Gl(mL),
  Yk = Gl(SL),
  qk = Gl(wD),
  Kk = Gl(aD),
  Zk = Gl(hD);
var HM;
function Jk() {
  if (HM) return kc;
  HM = 1;
  var n = QS();
  Object.defineProperty(kc, "__esModule", { value: !0 }),
    (kc.default = A),
    (kc.shouldForwardProp = x),
    (kc.systemDefaultTheme = void 0);
  var e = n(Gk()),
    t = n(jk()),
    r = m($k),
    i = Xk;
  n(Yk), n(qk);
  var o = n(Kk),
    s = n(Zk);
  const a = ["ownerState"],
    u = ["variants"],
    c = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function d(R) {
    if (typeof WeakMap != "function") return null;
    var D = new WeakMap(),
      P = new WeakMap();
    return (d = function (U) {
      return U ? P : D;
    })(R);
  }
  function m(R, D) {
    if (R && R.__esModule) return R;
    if (R === null || (typeof R != "object" && typeof R != "function"))
      return { default: R };
    var P = d(D);
    if (P && P.has(R)) return P.get(R);
    var U = { __proto__: null },
      O = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var L in R)
      if (L !== "default" && Object.prototype.hasOwnProperty.call(R, L)) {
        var H = O ? Object.getOwnPropertyDescriptor(R, L) : null;
        H && (H.get || H.set) ? Object.defineProperty(U, L, H) : (U[L] = R[L]);
      }
    return (U.default = R), P && P.set(R, U), U;
  }
  function g(R) {
    return Object.keys(R).length === 0;
  }
  function y(R) {
    return typeof R == "string" && R.charCodeAt(0) > 96;
  }
  function x(R) {
    return R !== "ownerState" && R !== "theme" && R !== "sx" && R !== "as";
  }
  const S = (kc.systemDefaultTheme = (0, o.default)()),
    _ = (R) => R && R.charAt(0).toLowerCase() + R.slice(1);
  function w({ defaultTheme: R, theme: D, themeId: P }) {
    return g(D) ? R : D[P] || D;
  }
  function T(R) {
    return R ? (D, P) => P[R] : null;
  }
  function M(R, D) {
    let { ownerState: P } = D,
      U = (0, t.default)(D, a);
    const O =
      typeof R == "function" ? R((0, e.default)({ ownerState: P }, U)) : R;
    if (Array.isArray(O))
      return O.flatMap((L) => M(L, (0, e.default)({ ownerState: P }, U)));
    if (O && typeof O == "object" && Array.isArray(O.variants)) {
      const { variants: L = [] } = O;
      let W = (0, t.default)(O, u);
      return (
        L.forEach(($) => {
          let K = !0;
          typeof $.props == "function"
            ? (K = $.props((0, e.default)({ ownerState: P }, U, P)))
            : Object.keys($.props).forEach((Z) => {
                (P == null ? void 0 : P[Z]) !== $.props[Z] &&
                  U[Z] !== $.props[Z] &&
                  (K = !1);
              }),
            K &&
              (Array.isArray(W) || (W = [W]),
              W.push(
                typeof $.style == "function"
                  ? $.style((0, e.default)({ ownerState: P }, U, P))
                  : $.style
              ));
        }),
        W
      );
    }
    return O;
  }
  function A(R = {}) {
    const {
        themeId: D,
        defaultTheme: P = S,
        rootShouldForwardProp: U = x,
        slotShouldForwardProp: O = x,
      } = R,
      L = (H) =>
        (0, s.default)(
          (0, e.default)({}, H, {
            theme: w((0, e.default)({}, H, { defaultTheme: P, themeId: D })),
          })
        );
    return (
      (L.__mui_systemSx = !0),
      (H, W = {}) => {
        (0, r.internal_processStyles)(H, (de) =>
          de.filter((le) => !(le != null && le.__mui_systemSx))
        );
        const {
            name: $,
            slot: K,
            skipVariantsResolver: Z,
            skipSx: Y,
            overridesResolver: re = T(_(K)),
          } = W,
          G = (0, t.default)(W, c),
          te = Z !== void 0 ? Z : (K && K !== "Root" && K !== "root") || !1,
          F = Y || !1;
        let V,
          ne = x;
        K === "Root" || K === "root"
          ? (ne = U)
          : K
          ? (ne = O)
          : y(H) && (ne = void 0);
        const ae = (0, r.default)(
            H,
            (0, e.default)({ shouldForwardProp: ne, label: V }, G)
          ),
          J = (de) =>
            (typeof de == "function" && de.__emotion_real !== de) ||
            (0, i.isPlainObject)(de)
              ? (le) =>
                  M(
                    de,
                    (0, e.default)({}, le, {
                      theme: w({
                        theme: le.theme,
                        defaultTheme: P,
                        themeId: D,
                      }),
                    })
                  )
              : de,
          se = (de, ...le) => {
            let fe = J(de);
            const Me = le ? le.map(J) : [];
            $ &&
              re &&
              Me.push((j) => {
                const we = w(
                  (0, e.default)({}, j, { defaultTheme: P, themeId: D })
                );
                if (
                  !we.components ||
                  !we.components[$] ||
                  !we.components[$].styleOverrides
                )
                  return null;
                const Ae = we.components[$].styleOverrides,
                  Oe = {};
                return (
                  Object.entries(Ae).forEach(([Ie, rt]) => {
                    Oe[Ie] = M(rt, (0, e.default)({}, j, { theme: we }));
                  }),
                  re(j, Oe)
                );
              }),
              $ &&
                !te &&
                Me.push((j) => {
                  var we;
                  const Ae = w(
                      (0, e.default)({}, j, { defaultTheme: P, themeId: D })
                    ),
                    Oe =
                      Ae == null ||
                      (we = Ae.components) == null ||
                      (we = we[$]) == null
                        ? void 0
                        : we.variants;
                  return M(
                    { variants: Oe },
                    (0, e.default)({}, j, { theme: Ae })
                  );
                }),
              F || Me.push(L);
            const ge = Me.length - le.length;
            if (Array.isArray(de) && ge > 0) {
              const j = new Array(ge).fill("");
              (fe = [...de, ...j]), (fe.raw = [...de.raw, ...j]);
            }
            const xe = ae(fe, ...Me);
            return H.muiName && (xe.muiName = H.muiName), xe;
          };
        return ae.withConfig && (se.withConfig = ae.withConfig), se;
      }
    );
  }
  return kc;
}
var Qk = Jk();
const eO = Oh(Qk);
function ZC(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
const Os = (n) => ZC(n) && n !== "classes",
  jt = eO({ themeId: by, defaultTheme: ew, rootShouldForwardProp: Os }),
  VM = (n) => {
    let e;
    return (
      n < 1 ? (e = 5.11916 * n ** 2) : (e = 4.5 * Math.log(n + 1) + 2),
      (e / 100).toFixed(2)
    );
  };
function Yn(n) {
  return rk(n);
}
function tO(n) {
  return Fn("MuiSvgIcon", n);
}
Ln("MuiSvgIcon", [
  "root",
  "colorPrimary",
  "colorSecondary",
  "colorAction",
  "colorError",
  "colorDisabled",
  "fontSizeInherit",
  "fontSizeSmall",
  "fontSizeMedium",
  "fontSizeLarge",
]);
const nO = [
    "children",
    "className",
    "color",
    "component",
    "fontSize",
    "htmlColor",
    "inheritViewBox",
    "titleAccess",
    "viewBox",
  ],
  rO = (n) => {
    const { color: e, fontSize: t, classes: r } = n,
      i = {
        root: ["root", e !== "inherit" && `color${an(e)}`, `fontSize${an(t)}`],
      };
    return Bn(i, tO, r);
  },
  iO = jt("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.color !== "inherit" && e[`color${an(t.color)}`],
        e[`fontSize${an(t.fontSize)}`],
      ];
    },
  })(({ theme: n, ownerState: e }) => {
    var t, r, i, o, s, a, u, c, d, m, g, y, x;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: e.hasSvgAsChild ? void 0 : "currentColor",
      flexShrink: 0,
      transition:
        (t = n.transitions) == null || (r = t.create) == null
          ? void 0
          : r.call(t, "fill", {
              duration:
                (i = n.transitions) == null || (i = i.duration) == null
                  ? void 0
                  : i.shorter,
            }),
      fontSize: {
        inherit: "inherit",
        small:
          ((o = n.typography) == null || (s = o.pxToRem) == null
            ? void 0
            : s.call(o, 20)) || "1.25rem",
        medium:
          ((a = n.typography) == null || (u = a.pxToRem) == null
            ? void 0
            : u.call(a, 24)) || "1.5rem",
        large:
          ((c = n.typography) == null || (d = c.pxToRem) == null
            ? void 0
            : d.call(c, 35)) || "2.1875rem",
      }[e.fontSize],
      color:
        (m =
          (g = (n.vars || n).palette) == null || (g = g[e.color]) == null
            ? void 0
            : g.main) != null
          ? m
          : {
              action:
                (y = (n.vars || n).palette) == null || (y = y.action) == null
                  ? void 0
                  : y.active,
              disabled:
                (x = (n.vars || n).palette) == null || (x = x.action) == null
                  ? void 0
                  : x.disabled,
              inherit: void 0,
            }[e.color],
    };
  }),
  J1 = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiSvgIcon" }),
      {
        children: i,
        className: o,
        color: s = "inherit",
        component: a = "svg",
        fontSize: u = "medium",
        htmlColor: c,
        inheritViewBox: d = !1,
        titleAccess: m,
        viewBox: g = "0 0 24 24",
      } = r,
      y = It(r, nO),
      x = X.isValidElement(i) && i.type === "svg",
      S = ue({}, r, {
        color: s,
        component: a,
        fontSize: u,
        instanceFontSize: e.fontSize,
        inheritViewBox: d,
        viewBox: g,
        hasSvgAsChild: x,
      }),
      _ = {};
    d || (_.viewBox = g);
    const w = rO(S);
    return Q.jsxs(
      iO,
      ue(
        {
          as: a,
          className: Zt(w.root, o),
          focusable: "false",
          color: c,
          "aria-hidden": m ? void 0 : !0,
          role: m ? "img" : void 0,
          ref: t,
        },
        _,
        y,
        x && i.props,
        {
          ownerState: S,
          children: [
            x ? i.props.children : i,
            m ? Q.jsx("title", { children: m }) : null,
          ],
        }
      )
    );
  });
J1.muiName = "SvgIcon";
function Lf(n, e) {
  function t(r, i) {
    return Q.jsx(
      J1,
      ue({ "data-testid": `${e}Icon`, ref: i }, r, { children: n })
    );
  }
  return (t.muiName = J1.muiName), X.memo(X.forwardRef(t));
}
const oO = {
    configure: (n) => {
      qS.configure(n);
    },
  },
  sO = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        capitalize: an,
        createChainedFunction: q1,
        createSvgIcon: Lf,
        debounce: KS,
        deprecatedPropType: FD,
        isMuiElement: um,
        ownerDocument: zo,
        ownerWindow: qu,
        requirePropFactory: BD,
        setRef: P0,
        unstable_ClassNameGenerator: oO,
        unstable_useEnhancedEffect: ha,
        unstable_useId: ZS,
        unsupportedProp: HD,
        useControlled: K1,
        useEventCallback: ff,
        useForkRef: ri,
        useIsFocusVisible: JS,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
var S_ = { exports: {} },
  On = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var WM;
function aO() {
  if (WM) return On;
  WM = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    s = Symbol.for("react.context"),
    a = Symbol.for("react.server_context"),
    u = Symbol.for("react.forward_ref"),
    c = Symbol.for("react.suspense"),
    d = Symbol.for("react.suspense_list"),
    m = Symbol.for("react.memo"),
    g = Symbol.for("react.lazy"),
    y = Symbol.for("react.offscreen"),
    x;
  x = Symbol.for("react.module.reference");
  function S(_) {
    if (typeof _ == "object" && _ !== null) {
      var w = _.$$typeof;
      switch (w) {
        case n:
          switch (((_ = _.type), _)) {
            case t:
            case i:
            case r:
            case c:
            case d:
              return _;
            default:
              switch (((_ = _ && _.$$typeof), _)) {
                case a:
                case s:
                case u:
                case g:
                case m:
                case o:
                  return _;
                default:
                  return w;
              }
          }
        case e:
          return w;
      }
    }
  }
  return (
    (On.ContextConsumer = s),
    (On.ContextProvider = o),
    (On.Element = n),
    (On.ForwardRef = u),
    (On.Fragment = t),
    (On.Lazy = g),
    (On.Memo = m),
    (On.Portal = e),
    (On.Profiler = i),
    (On.StrictMode = r),
    (On.Suspense = c),
    (On.SuspenseList = d),
    (On.isAsyncMode = function () {
      return !1;
    }),
    (On.isConcurrentMode = function () {
      return !1;
    }),
    (On.isContextConsumer = function (_) {
      return S(_) === s;
    }),
    (On.isContextProvider = function (_) {
      return S(_) === o;
    }),
    (On.isElement = function (_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === n;
    }),
    (On.isForwardRef = function (_) {
      return S(_) === u;
    }),
    (On.isFragment = function (_) {
      return S(_) === t;
    }),
    (On.isLazy = function (_) {
      return S(_) === g;
    }),
    (On.isMemo = function (_) {
      return S(_) === m;
    }),
    (On.isPortal = function (_) {
      return S(_) === e;
    }),
    (On.isProfiler = function (_) {
      return S(_) === i;
    }),
    (On.isStrictMode = function (_) {
      return S(_) === r;
    }),
    (On.isSuspense = function (_) {
      return S(_) === c;
    }),
    (On.isSuspenseList = function (_) {
      return S(_) === d;
    }),
    (On.isValidElementType = function (_) {
      return (
        typeof _ == "string" ||
        typeof _ == "function" ||
        _ === t ||
        _ === i ||
        _ === r ||
        _ === c ||
        _ === d ||
        _ === y ||
        (typeof _ == "object" &&
          _ !== null &&
          (_.$$typeof === g ||
            _.$$typeof === m ||
            _.$$typeof === o ||
            _.$$typeof === s ||
            _.$$typeof === u ||
            _.$$typeof === x ||
            _.getModuleId !== void 0))
      );
    }),
    (On.typeOf = S),
    On
  );
}
var GM;
function lO() {
  return GM || ((GM = 1), (S_.exports = aO())), S_.exports;
}
lO();
function Q1(n, e) {
  return (
    (Q1 = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (t, r) {
          return (t.__proto__ = r), t;
        }),
    Q1(n, e)
  );
}
function JC(n, e) {
  (n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    Q1(n, e);
}
const jM = { disabled: !1 },
  L0 = Is.createContext(null);
var uO = function (e) {
    return e.scrollTop;
  },
  rm = "unmounted",
  Qc = "exited",
  ef = "entering",
  uh = "entered",
  eS = "exiting",
  tl = (function (n) {
    JC(e, n);
    function e(r, i) {
      var o;
      o = n.call(this, r, i) || this;
      var s = i,
        a = s && !s.isMounting ? r.enter : r.appear,
        u;
      return (
        (o.appearStatus = null),
        r.in
          ? a
            ? ((u = Qc), (o.appearStatus = ef))
            : (u = uh)
          : r.unmountOnExit || r.mountOnEnter
          ? (u = rm)
          : (u = Qc),
        (o.state = { status: u }),
        (o.nextCallback = null),
        o
      );
    }
    e.getDerivedStateFromProps = function (i, o) {
      var s = i.in;
      return s && o.status === rm ? { status: Qc } : null;
    };
    var t = e.prototype;
    return (
      (t.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (t.componentDidUpdate = function (i) {
        var o = null;
        if (i !== this.props) {
          var s = this.state.status;
          this.props.in
            ? s !== ef && s !== uh && (o = ef)
            : (s === ef || s === uh) && (o = eS);
        }
        this.updateStatus(!1, o);
      }),
      (t.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (t.getTimeouts = function () {
        var i = this.props.timeout,
          o,
          s,
          a;
        return (
          (o = s = a = i),
          i != null &&
            typeof i != "number" &&
            ((o = i.exit),
            (s = i.enter),
            (a = i.appear !== void 0 ? i.appear : s)),
          { exit: o, enter: s, appear: a }
        );
      }),
      (t.updateStatus = function (i, o) {
        if ((i === void 0 && (i = !1), o !== null))
          if ((this.cancelNextCallback(), o === ef)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var s = this.props.nodeRef
                ? this.props.nodeRef.current
                : hv.findDOMNode(this);
              s && uO(s);
            }
            this.performEnter(i);
          } else this.performExit();
        else
          this.props.unmountOnExit &&
            this.state.status === Qc &&
            this.setState({ status: rm });
      }),
      (t.performEnter = function (i) {
        var o = this,
          s = this.props.enter,
          a = this.context ? this.context.isMounting : i,
          u = this.props.nodeRef ? [a] : [hv.findDOMNode(this), a],
          c = u[0],
          d = u[1],
          m = this.getTimeouts(),
          g = a ? m.appear : m.enter;
        if ((!i && !s) || jM.disabled) {
          this.safeSetState({ status: uh }, function () {
            o.props.onEntered(c);
          });
          return;
        }
        this.props.onEnter(c, d),
          this.safeSetState({ status: ef }, function () {
            o.props.onEntering(c, d),
              o.onTransitionEnd(g, function () {
                o.safeSetState({ status: uh }, function () {
                  o.props.onEntered(c, d);
                });
              });
          });
      }),
      (t.performExit = function () {
        var i = this,
          o = this.props.exit,
          s = this.getTimeouts(),
          a = this.props.nodeRef ? void 0 : hv.findDOMNode(this);
        if (!o || jM.disabled) {
          this.safeSetState({ status: Qc }, function () {
            i.props.onExited(a);
          });
          return;
        }
        this.props.onExit(a),
          this.safeSetState({ status: eS }, function () {
            i.props.onExiting(a),
              i.onTransitionEnd(s.exit, function () {
                i.safeSetState({ status: Qc }, function () {
                  i.props.onExited(a);
                });
              });
          });
      }),
      (t.cancelNextCallback = function () {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (t.safeSetState = function (i, o) {
        (o = this.setNextCallback(o)), this.setState(i, o);
      }),
      (t.setNextCallback = function (i) {
        var o = this,
          s = !0;
        return (
          (this.nextCallback = function (a) {
            s && ((s = !1), (o.nextCallback = null), i(a));
          }),
          (this.nextCallback.cancel = function () {
            s = !1;
          }),
          this.nextCallback
        );
      }),
      (t.onTransitionEnd = function (i, o) {
        this.setNextCallback(o);
        var s = this.props.nodeRef
            ? this.props.nodeRef.current
            : hv.findDOMNode(this),
          a = i == null && !this.props.addEndListener;
        if (!s || a) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var u = this.props.nodeRef
              ? [this.nextCallback]
              : [s, this.nextCallback],
            c = u[0],
            d = u[1];
          this.props.addEndListener(c, d);
        }
        i != null && setTimeout(this.nextCallback, i);
      }),
      (t.render = function () {
        var i = this.state.status;
        if (i === rm) return null;
        var o = this.props,
          s = o.children;
        o.in,
          o.mountOnEnter,
          o.unmountOnExit,
          o.appear,
          o.enter,
          o.exit,
          o.timeout,
          o.addEndListener,
          o.onEnter,
          o.onEntering,
          o.onEntered,
          o.onExit,
          o.onExiting,
          o.onExited,
          o.nodeRef;
        var a = It(o, [
          "children",
          "in",
          "mountOnEnter",
          "unmountOnExit",
          "appear",
          "enter",
          "exit",
          "timeout",
          "addEndListener",
          "onEnter",
          "onEntering",
          "onEntered",
          "onExit",
          "onExiting",
          "onExited",
          "nodeRef",
        ]);
        return Is.createElement(
          L0.Provider,
          { value: null },
          typeof s == "function"
            ? s(i, a)
            : Is.cloneElement(Is.Children.only(s), a)
        );
      }),
      e
    );
  })(Is.Component);
tl.contextType = L0;
tl.propTypes = {};
function Ud() {}
tl.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: Ud,
  onEntering: Ud,
  onEntered: Ud,
  onExit: Ud,
  onExiting: Ud,
  onExited: Ud,
};
tl.UNMOUNTED = rm;
tl.EXITED = Qc;
tl.ENTERING = ef;
tl.ENTERED = uh;
tl.EXITING = eS;
function cO(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function tw(n, e) {
  var t = function (o) {
      return e && X.isValidElement(o) ? e(o) : o;
    },
    r = Object.create(null);
  return (
    n &&
      X.Children.map(n, function (i) {
        return i;
      }).forEach(function (i) {
        r[i.key] = t(i);
      }),
    r
  );
}
function fO(n, e) {
  (n = n || {}), (e = e || {});
  function t(d) {
    return d in e ? e[d] : n[d];
  }
  var r = Object.create(null),
    i = [];
  for (var o in n) o in e ? i.length && ((r[o] = i), (i = [])) : i.push(o);
  var s,
    a = {};
  for (var u in e) {
    if (r[u])
      for (s = 0; s < r[u].length; s++) {
        var c = r[u][s];
        a[r[u][s]] = t(c);
      }
    a[u] = t(u);
  }
  for (s = 0; s < i.length; s++) a[i[s]] = t(i[s]);
  return a;
}
function df(n, e, t) {
  return t[e] != null ? t[e] : n.props[e];
}
function dO(n, e) {
  return tw(n.children, function (t) {
    return X.cloneElement(t, {
      onExited: e.bind(null, t),
      in: !0,
      appear: df(t, "appear", n),
      enter: df(t, "enter", n),
      exit: df(t, "exit", n),
    });
  });
}
function hO(n, e, t) {
  var r = tw(n.children),
    i = fO(e, r);
  return (
    Object.keys(i).forEach(function (o) {
      var s = i[o];
      if (X.isValidElement(s)) {
        var a = o in e,
          u = o in r,
          c = e[o],
          d = X.isValidElement(c) && !c.props.in;
        u && (!a || d)
          ? (i[o] = X.cloneElement(s, {
              onExited: t.bind(null, s),
              in: !0,
              exit: df(s, "exit", n),
              enter: df(s, "enter", n),
            }))
          : !u && a && !d
          ? (i[o] = X.cloneElement(s, { in: !1 }))
          : u &&
            a &&
            X.isValidElement(c) &&
            (i[o] = X.cloneElement(s, {
              onExited: t.bind(null, s),
              in: c.props.in,
              exit: df(s, "exit", n),
              enter: df(s, "enter", n),
            }));
      }
    }),
    i
  );
}
var pO =
    Object.values ||
    function (n) {
      return Object.keys(n).map(function (e) {
        return n[e];
      });
    },
  mO = {
    component: "div",
    childFactory: function (e) {
      return e;
    },
  },
  nw = (function (n) {
    JC(e, n);
    function e(r, i) {
      var o;
      o = n.call(this, r, i) || this;
      var s = o.handleExited.bind(cO(o));
      return (
        (o.state = {
          contextValue: { isMounting: !0 },
          handleExited: s,
          firstRender: !0,
        }),
        o
      );
    }
    var t = e.prototype;
    return (
      (t.componentDidMount = function () {
        (this.mounted = !0),
          this.setState({ contextValue: { isMounting: !1 } });
      }),
      (t.componentWillUnmount = function () {
        this.mounted = !1;
      }),
      (e.getDerivedStateFromProps = function (i, o) {
        var s = o.children,
          a = o.handleExited,
          u = o.firstRender;
        return { children: u ? dO(i, a) : hO(i, s, a), firstRender: !1 };
      }),
      (t.handleExited = function (i, o) {
        var s = tw(this.props.children);
        i.key in s ||
          (i.props.onExited && i.props.onExited(o),
          this.mounted &&
            this.setState(function (a) {
              var u = ue({}, a.children);
              return delete u[i.key], { children: u };
            }));
      }),
      (t.render = function () {
        var i = this.props,
          o = i.component,
          s = i.childFactory,
          a = It(i, ["component", "childFactory"]),
          u = this.state.contextValue,
          c = pO(this.state.children).map(s);
        return (
          delete a.appear,
          delete a.enter,
          delete a.exit,
          o === null
            ? Is.createElement(L0.Provider, { value: u }, c)
            : Is.createElement(
                L0.Provider,
                { value: u },
                Is.createElement(o, a, c)
              )
        );
      }),
      e
    );
  })(Is.Component);
nw.propTypes = {};
nw.defaultProps = mO;
const QC = (n) => n.scrollTop;
function D0(n, e) {
  var t, r;
  const { timeout: i, easing: o, style: s = {} } = n;
  return {
    duration:
      (t = s.transitionDuration) != null
        ? t
        : typeof i == "number"
        ? i
        : i[e.mode] || 0,
    easing:
      (r = s.transitionTimingFunction) != null
        ? r
        : typeof o == "object"
        ? o[e.mode]
        : o,
    delay: s.transitionDelay,
  };
}
function gO(n) {
  return Fn("MuiPaper", n);
}
Ln("MuiPaper", [
  "root",
  "rounded",
  "outlined",
  "elevation",
  "elevation0",
  "elevation1",
  "elevation2",
  "elevation3",
  "elevation4",
  "elevation5",
  "elevation6",
  "elevation7",
  "elevation8",
  "elevation9",
  "elevation10",
  "elevation11",
  "elevation12",
  "elevation13",
  "elevation14",
  "elevation15",
  "elevation16",
  "elevation17",
  "elevation18",
  "elevation19",
  "elevation20",
  "elevation21",
  "elevation22",
  "elevation23",
  "elevation24",
]);
const vO = ["className", "component", "elevation", "square", "variant"],
  yO = (n) => {
    const { square: e, elevation: t, variant: r, classes: i } = n,
      o = {
        root: [
          "root",
          r,
          !e && "rounded",
          r === "elevation" && `elevation${t}`,
        ],
      };
    return Bn(o, gO, i);
  },
  xO = jt("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        e[t.variant],
        !t.square && e.rounded,
        t.variant === "elevation" && e[`elevation${t.elevation}`],
      ];
    },
  })(({ theme: n, ownerState: e }) => {
    var t;
    return ue(
      {
        backgroundColor: (n.vars || n).palette.background.paper,
        color: (n.vars || n).palette.text.primary,
        transition: n.transitions.create("box-shadow"),
      },
      !e.square && { borderRadius: n.shape.borderRadius },
      e.variant === "outlined" && {
        border: `1px solid ${(n.vars || n).palette.divider}`,
      },
      e.variant === "elevation" &&
        ue(
          { boxShadow: (n.vars || n).shadows[e.elevation] },
          !n.vars &&
            n.palette.mode === "dark" && {
              backgroundImage: `linear-gradient(${Bi.alpha(
                "#fff",
                VM(e.elevation)
              )}, ${Bi.alpha("#fff", VM(e.elevation))})`,
            },
          n.vars && {
            backgroundImage:
              (t = n.vars.overlays) == null ? void 0 : t[e.elevation],
          }
        )
    );
  }),
  lf = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiPaper" }),
      {
        className: i,
        component: o = "div",
        elevation: s = 1,
        square: a = !1,
        variant: u = "elevation",
      } = r,
      c = It(r, vO),
      d = ue({}, r, { component: o, elevation: s, square: a, variant: u }),
      m = yO(d);
    return Q.jsx(
      xO,
      ue({ as: o, ownerState: d, className: Zt(m.root, i), ref: t }, c)
    );
  });
function _O(n) {
  const {
      className: e,
      classes: t,
      pulsate: r = !1,
      rippleX: i,
      rippleY: o,
      rippleSize: s,
      in: a,
      onExited: u,
      timeout: c,
    } = n,
    [d, m] = X.useState(!1),
    g = Zt(e, t.ripple, t.rippleVisible, r && t.ripplePulsate),
    y = { width: s, height: s, top: -(s / 2) + o, left: -(s / 2) + i },
    x = Zt(t.child, d && t.childLeaving, r && t.childPulsate);
  return (
    !a && !d && m(!0),
    X.useEffect(() => {
      if (!a && u != null) {
        const S = setTimeout(u, c);
        return () => {
          clearTimeout(S);
        };
      }
    }, [u, a, c]),
    Q.jsx("span", {
      className: g,
      style: y,
      children: Q.jsx("span", { className: x }),
    })
  );
}
const Cs = Ln("MuiTouchRipple", [
    "root",
    "ripple",
    "rippleVisible",
    "ripplePulsate",
    "child",
    "childLeaving",
    "childPulsate",
  ]),
  SO = ["center", "classes", "className"];
let Fy = (n) => n,
  $M,
  XM,
  YM,
  qM;
const tS = 550,
  wO = 80,
  bO = ng(
    $M ||
      ($M = Fy`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
  ),
  MO = ng(
    XM ||
      (XM = Fy`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
  ),
  EO = ng(
    YM ||
      (YM = Fy`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
  ),
  TO = jt("span", { name: "MuiTouchRipple", slot: "Root" })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit",
  }),
  CO = jt(_O, { name: "MuiTouchRipple", slot: "Ripple" })(
    qM ||
      (qM = Fy`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
    Cs.rippleVisible,
    bO,
    tS,
    ({ theme: n }) => n.transitions.easing.easeInOut,
    Cs.ripplePulsate,
    ({ theme: n }) => n.transitions.duration.shorter,
    Cs.child,
    Cs.childLeaving,
    MO,
    tS,
    ({ theme: n }) => n.transitions.easing.easeInOut,
    Cs.childPulsate,
    EO,
    ({ theme: n }) => n.transitions.easing.easeInOut
  ),
  AO = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiTouchRipple" }),
      { center: i = !1, classes: o = {}, className: s } = r,
      a = It(r, SO),
      [u, c] = X.useState([]),
      d = X.useRef(0),
      m = X.useRef(null);
    X.useEffect(() => {
      m.current && (m.current(), (m.current = null));
    }, [u]);
    const g = X.useRef(!1),
      y = WC(),
      x = X.useRef(null),
      S = X.useRef(null),
      _ = X.useCallback(
        (A) => {
          const {
            pulsate: R,
            rippleX: D,
            rippleY: P,
            rippleSize: U,
            cb: O,
          } = A;
          c((L) => [
            ...L,
            Q.jsx(
              CO,
              {
                classes: {
                  ripple: Zt(o.ripple, Cs.ripple),
                  rippleVisible: Zt(o.rippleVisible, Cs.rippleVisible),
                  ripplePulsate: Zt(o.ripplePulsate, Cs.ripplePulsate),
                  child: Zt(o.child, Cs.child),
                  childLeaving: Zt(o.childLeaving, Cs.childLeaving),
                  childPulsate: Zt(o.childPulsate, Cs.childPulsate),
                },
                timeout: tS,
                pulsate: R,
                rippleX: D,
                rippleY: P,
                rippleSize: U,
              },
              d.current
            ),
          ]),
            (d.current += 1),
            (m.current = O);
        },
        [o]
      ),
      w = X.useCallback(
        (A = {}, R = {}, D = () => {}) => {
          const {
            pulsate: P = !1,
            center: U = i || R.pulsate,
            fakeElement: O = !1,
          } = R;
          if ((A == null ? void 0 : A.type) === "mousedown" && g.current) {
            g.current = !1;
            return;
          }
          (A == null ? void 0 : A.type) === "touchstart" && (g.current = !0);
          const L = O ? null : S.current,
            H = L
              ? L.getBoundingClientRect()
              : { width: 0, height: 0, left: 0, top: 0 };
          let W, $, K;
          if (
            U ||
            A === void 0 ||
            (A.clientX === 0 && A.clientY === 0) ||
            (!A.clientX && !A.touches)
          )
            (W = Math.round(H.width / 2)), ($ = Math.round(H.height / 2));
          else {
            const { clientX: Z, clientY: Y } =
              A.touches && A.touches.length > 0 ? A.touches[0] : A;
            (W = Math.round(Z - H.left)), ($ = Math.round(Y - H.top));
          }
          if (U)
            (K = Math.sqrt((2 * H.width ** 2 + H.height ** 2) / 3)),
              K % 2 === 0 && (K += 1);
          else {
            const Z =
                Math.max(Math.abs((L ? L.clientWidth : 0) - W), W) * 2 + 2,
              Y = Math.max(Math.abs((L ? L.clientHeight : 0) - $), $) * 2 + 2;
            K = Math.sqrt(Z ** 2 + Y ** 2);
          }
          A != null && A.touches
            ? x.current === null &&
              ((x.current = () => {
                _({ pulsate: P, rippleX: W, rippleY: $, rippleSize: K, cb: D });
              }),
              y.start(wO, () => {
                x.current && (x.current(), (x.current = null));
              }))
            : _({ pulsate: P, rippleX: W, rippleY: $, rippleSize: K, cb: D });
        },
        [i, _, y]
      ),
      T = X.useCallback(() => {
        w({}, { pulsate: !0 });
      }, [w]),
      M = X.useCallback(
        (A, R) => {
          if (
            (y.clear(),
            (A == null ? void 0 : A.type) === "touchend" && x.current)
          ) {
            x.current(),
              (x.current = null),
              y.start(0, () => {
                M(A, R);
              });
            return;
          }
          (x.current = null),
            c((D) => (D.length > 0 ? D.slice(1) : D)),
            (m.current = R);
        },
        [y]
      );
    return (
      X.useImperativeHandle(t, () => ({ pulsate: T, start: w, stop: M }), [
        T,
        w,
        M,
      ]),
      Q.jsx(
        TO,
        ue({ className: Zt(Cs.root, o.root, s), ref: S }, a, {
          children: Q.jsx(nw, { component: null, exit: !0, children: u }),
        })
      )
    );
  });
function RO(n) {
  return Fn("MuiButtonBase", n);
}
const PO = Ln("MuiButtonBase", ["root", "disabled", "focusVisible"]),
  IO = [
    "action",
    "centerRipple",
    "children",
    "className",
    "component",
    "disabled",
    "disableRipple",
    "disableTouchRipple",
    "focusRipple",
    "focusVisibleClassName",
    "LinkComponent",
    "onBlur",
    "onClick",
    "onContextMenu",
    "onDragLeave",
    "onFocus",
    "onFocusVisible",
    "onKeyDown",
    "onKeyUp",
    "onMouseDown",
    "onMouseLeave",
    "onMouseUp",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "tabIndex",
    "TouchRippleProps",
    "touchRippleRef",
    "type",
  ],
  LO = (n) => {
    const {
        disabled: e,
        focusVisible: t,
        focusVisibleClassName: r,
        classes: i,
      } = n,
      s = Bn({ root: ["root", e && "disabled", t && "focusVisible"] }, RO, i);
    return t && r && (s.root += ` ${r}`), s;
  },
  DO = jt("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": { borderStyle: "none" },
    [`&.${PO.disabled}`]: { pointerEvents: "none", cursor: "default" },
    "@media print": { colorAdjust: "exact" },
  }),
  rw = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiButtonBase" }),
      {
        action: i,
        centerRipple: o = !1,
        children: s,
        className: a,
        component: u = "button",
        disabled: c = !1,
        disableRipple: d = !1,
        disableTouchRipple: m = !1,
        focusRipple: g = !1,
        LinkComponent: y = "a",
        onBlur: x,
        onClick: S,
        onContextMenu: _,
        onDragLeave: w,
        onFocus: T,
        onFocusVisible: M,
        onKeyDown: A,
        onKeyUp: R,
        onMouseDown: D,
        onMouseLeave: P,
        onMouseUp: U,
        onTouchEnd: O,
        onTouchMove: L,
        onTouchStart: H,
        tabIndex: W = 0,
        TouchRippleProps: $,
        touchRippleRef: K,
        type: Z,
      } = r,
      Y = It(r, IO),
      re = X.useRef(null),
      G = X.useRef(null),
      te = ri(G, K),
      { isFocusVisibleRef: F, onFocus: V, onBlur: ne, ref: ae } = JS(),
      [J, se] = X.useState(!1);
    c && J && se(!1),
      X.useImperativeHandle(
        i,
        () => ({
          focusVisible: () => {
            se(!0), re.current.focus();
          },
        }),
        []
      );
    const [de, le] = X.useState(!1);
    X.useEffect(() => {
      le(!0);
    }, []);
    const fe = de && !d && !c;
    X.useEffect(() => {
      J && g && !d && de && G.current.pulsate();
    }, [d, g, J, de]);
    function Me(Ge, Ye, nt = m) {
      return ff(
        (xt) => (Ye && Ye(xt), !nt && G.current && G.current[Ge](xt), !0)
      );
    }
    const ge = Me("start", D),
      xe = Me("stop", _),
      j = Me("stop", w),
      we = Me("stop", U),
      Ae = Me("stop", (Ge) => {
        J && Ge.preventDefault(), P && P(Ge);
      }),
      Oe = Me("start", H),
      Ie = Me("stop", O),
      rt = Me("stop", L),
      De = Me(
        "stop",
        (Ge) => {
          ne(Ge), F.current === !1 && se(!1), x && x(Ge);
        },
        !1
      ),
      Xe = ff((Ge) => {
        re.current || (re.current = Ge.currentTarget),
          V(Ge),
          F.current === !0 && (se(!0), M && M(Ge)),
          T && T(Ge);
      }),
      ee = () => {
        const Ge = re.current;
        return u && u !== "button" && !(Ge.tagName === "A" && Ge.href);
      },
      B = X.useRef(!1),
      ve = ff((Ge) => {
        g &&
          !B.current &&
          J &&
          G.current &&
          Ge.key === " " &&
          ((B.current = !0),
          G.current.stop(Ge, () => {
            G.current.start(Ge);
          })),
          Ge.target === Ge.currentTarget &&
            ee() &&
            Ge.key === " " &&
            Ge.preventDefault(),
          A && A(Ge),
          Ge.target === Ge.currentTarget &&
            ee() &&
            Ge.key === "Enter" &&
            !c &&
            (Ge.preventDefault(), S && S(Ge));
      }),
      Se = ff((Ge) => {
        g &&
          Ge.key === " " &&
          G.current &&
          J &&
          !Ge.defaultPrevented &&
          ((B.current = !1),
          G.current.stop(Ge, () => {
            G.current.pulsate(Ge);
          })),
          R && R(Ge),
          S &&
            Ge.target === Ge.currentTarget &&
            ee() &&
            Ge.key === " " &&
            !Ge.defaultPrevented &&
            S(Ge);
      });
    let _e = u;
    _e === "button" && (Y.href || Y.to) && (_e = y);
    const Te = {};
    _e === "button"
      ? ((Te.type = Z === void 0 ? "button" : Z), (Te.disabled = c))
      : (!Y.href && !Y.to && (Te.role = "button"),
        c && (Te["aria-disabled"] = c));
    const at = ri(t, ae, re),
      Fe = ue({}, r, {
        centerRipple: o,
        component: u,
        disabled: c,
        disableRipple: d,
        disableTouchRipple: m,
        focusRipple: g,
        tabIndex: W,
        focusVisible: J,
      }),
      Be = LO(Fe);
    return Q.jsxs(
      DO,
      ue(
        {
          as: _e,
          className: Zt(Be.root, a),
          ownerState: Fe,
          onBlur: De,
          onClick: S,
          onContextMenu: xe,
          onFocus: Xe,
          onKeyDown: ve,
          onKeyUp: Se,
          onMouseDown: ge,
          onMouseLeave: Ae,
          onMouseUp: we,
          onDragLeave: j,
          onTouchEnd: Ie,
          onTouchMove: rt,
          onTouchStart: Oe,
          ref: at,
          tabIndex: c ? -1 : W,
          type: Z,
        },
        Te,
        Y,
        { children: [s, fe ? Q.jsx(AO, ue({ ref: te, center: o }, $)) : null] }
      )
    );
  });
function kO(n) {
  return Fn("MuiTypography", n);
}
Ln("MuiTypography", [
  "root",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "subtitle1",
  "subtitle2",
  "body1",
  "body2",
  "inherit",
  "button",
  "caption",
  "overline",
  "alignLeft",
  "alignRight",
  "alignCenter",
  "alignJustify",
  "noWrap",
  "gutterBottom",
  "paragraph",
]);
const OO = [
    "align",
    "className",
    "component",
    "gutterBottom",
    "noWrap",
    "paragraph",
    "variant",
    "variantMapping",
  ],
  NO = (n) => {
    const {
        align: e,
        gutterBottom: t,
        noWrap: r,
        paragraph: i,
        variant: o,
        classes: s,
      } = n,
      a = {
        root: [
          "root",
          o,
          n.align !== "inherit" && `align${an(e)}`,
          t && "gutterBottom",
          r && "noWrap",
          i && "paragraph",
        ],
      };
    return Bn(a, kO, s);
  },
  UO = jt("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.variant && e[t.variant],
        t.align !== "inherit" && e[`align${an(t.align)}`],
        t.noWrap && e.noWrap,
        t.gutterBottom && e.gutterBottom,
        t.paragraph && e.paragraph,
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      { margin: 0 },
      e.variant === "inherit" && { font: "inherit" },
      e.variant !== "inherit" && n.typography[e.variant],
      e.align !== "inherit" && { textAlign: e.align },
      e.noWrap && {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
      },
      e.gutterBottom && { marginBottom: "0.35em" },
      e.paragraph && { marginBottom: 16 }
    )
  ),
  KM = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p",
  },
  FO = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main",
  },
  BO = (n) => FO[n] || n,
  vn = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiTypography" }),
      i = BO(r.color),
      o = Oy(ue({}, r, { color: i })),
      {
        align: s = "inherit",
        className: a,
        component: u,
        gutterBottom: c = !1,
        noWrap: d = !1,
        paragraph: m = !1,
        variant: g = "body1",
        variantMapping: y = KM,
      } = o,
      x = It(o, OO),
      S = ue({}, o, {
        align: s,
        color: i,
        className: a,
        component: u,
        gutterBottom: c,
        noWrap: d,
        paragraph: m,
        variant: g,
        variantMapping: y,
      }),
      _ = u || (m ? "p" : y[g] || KM[g]) || "span",
      w = NO(S);
    return Q.jsx(
      UO,
      ue({ as: _, ref: t, ownerState: S, className: Zt(w.root, a) }, x)
    );
  });
function zO(n) {
  return typeof n == "function" ? n() : n;
}
const HO = X.forwardRef(function (e, t) {
    const { children: r, container: i, disablePortal: o = !1 } = e,
      [s, a] = X.useState(null),
      u = ri(X.isValidElement(r) ? r.ref : null, t);
    if (
      (ha(() => {
        o || a(zO(i) || document.body);
      }, [i, o]),
      ha(() => {
        if (s && !o)
          return (
            P0(t, s),
            () => {
              P0(t, null);
            }
          );
      }, [t, s, o]),
      o)
    ) {
      if (X.isValidElement(r)) {
        const c = { ref: u };
        return X.cloneElement(r, c);
      }
      return Q.jsx(X.Fragment, { children: r });
    }
    return Q.jsx(X.Fragment, { children: s && DS.createPortal(r, s) });
  }),
  VO = ["onChange", "maxRows", "minRows", "style", "value"];
function gv(n) {
  return parseInt(n, 10) || 0;
}
const WO = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)",
  },
};
function GO(n) {
  return (
    n == null ||
    Object.keys(n).length === 0 ||
    (n.outerHeightStyle === 0 && !n.overflowing)
  );
}
const jO = X.forwardRef(function (e, t) {
  const { onChange: r, maxRows: i, minRows: o = 1, style: s, value: a } = e,
    u = It(e, VO),
    { current: c } = X.useRef(a != null),
    d = X.useRef(null),
    m = ri(t, d),
    g = X.useRef(null),
    y = X.useRef(null),
    x = X.useCallback(() => {
      const w = d.current,
        M = qu(w).getComputedStyle(w);
      if (M.width === "0px") return { outerHeightStyle: 0, overflowing: !1 };
      const A = y.current;
      (A.style.width = M.width),
        (A.value = w.value || e.placeholder || "x"),
        A.value.slice(-1) ===
          `
` && (A.value += " ");
      const R = M.boxSizing,
        D = gv(M.paddingBottom) + gv(M.paddingTop),
        P = gv(M.borderBottomWidth) + gv(M.borderTopWidth),
        U = A.scrollHeight;
      A.value = "x";
      const O = A.scrollHeight;
      let L = U;
      o && (L = Math.max(Number(o) * O, L)),
        i && (L = Math.min(Number(i) * O, L)),
        (L = Math.max(L, O));
      const H = L + (R === "border-box" ? D + P : 0),
        W = Math.abs(L - U) <= 1;
      return { outerHeightStyle: H, overflowing: W };
    }, [i, o, e.placeholder]),
    S = X.useCallback(() => {
      const w = x();
      if (GO(w)) return;
      const T = w.outerHeightStyle,
        M = d.current;
      g.current !== T && ((g.current = T), (M.style.height = `${T}px`)),
        (M.style.overflow = w.overflowing ? "hidden" : "");
    }, [x]);
  ha(() => {
    const w = () => {
      S();
    };
    let T;
    const M = KS(w),
      A = d.current,
      R = qu(A);
    R.addEventListener("resize", M);
    let D;
    return (
      typeof ResizeObserver < "u" &&
        ((D = new ResizeObserver(w)), D.observe(A)),
      () => {
        M.clear(),
          cancelAnimationFrame(T),
          R.removeEventListener("resize", M),
          D && D.disconnect();
      }
    );
  }, [x, S]),
    ha(() => {
      S();
    });
  const _ = (w) => {
    c || S(), r && r(w);
  };
  return Q.jsxs(X.Fragment, {
    children: [
      Q.jsx(
        "textarea",
        ue({ value: a, onChange: _, ref: m, rows: o, style: s }, u)
      ),
      Q.jsx("textarea", {
        "aria-hidden": !0,
        className: e.className,
        readOnly: !0,
        ref: y,
        tabIndex: -1,
        style: ue({}, WO.shadow, s, { paddingTop: 0, paddingBottom: 0 }),
      }),
    ],
  });
});
function Bh({ props: n, states: e, muiFormControl: t }) {
  return e.reduce(
    (r, i) => ((r[i] = n[i]), t && typeof n[i] > "u" && (r[i] = t[i]), r),
    {}
  );
}
const iw = X.createContext(void 0);
function zh() {
  return X.useContext(iw);
}
function $O(n) {
  return Q.jsx(cD, ue({}, n, { defaultTheme: ew, themeId: by }));
}
function ZM(n) {
  return n != null && !(Array.isArray(n) && n.length === 0);
}
function k0(n, e = !1) {
  return (
    n &&
    ((ZM(n.value) && n.value !== "") ||
      (e && ZM(n.defaultValue) && n.defaultValue !== ""))
  );
}
function XO(n) {
  return n.startAdornment;
}
function YO(n) {
  return Fn("MuiInputBase", n);
}
const Rh = Ln("MuiInputBase", [
    "root",
    "formControl",
    "focused",
    "disabled",
    "adornedStart",
    "adornedEnd",
    "error",
    "sizeSmall",
    "multiline",
    "colorSecondary",
    "fullWidth",
    "hiddenLabel",
    "readOnly",
    "input",
    "inputSizeSmall",
    "inputMultiline",
    "inputTypeSearch",
    "inputAdornedStart",
    "inputAdornedEnd",
    "inputHiddenLabel",
  ]),
  qO = [
    "aria-describedby",
    "autoComplete",
    "autoFocus",
    "className",
    "color",
    "components",
    "componentsProps",
    "defaultValue",
    "disabled",
    "disableInjectingGlobalStyles",
    "endAdornment",
    "error",
    "fullWidth",
    "id",
    "inputComponent",
    "inputProps",
    "inputRef",
    "margin",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onClick",
    "onFocus",
    "onKeyDown",
    "onKeyUp",
    "placeholder",
    "readOnly",
    "renderSuffix",
    "rows",
    "size",
    "slotProps",
    "slots",
    "startAdornment",
    "type",
    "value",
  ],
  By = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.formControl && e.formControl,
      t.startAdornment && e.adornedStart,
      t.endAdornment && e.adornedEnd,
      t.error && e.error,
      t.size === "small" && e.sizeSmall,
      t.multiline && e.multiline,
      t.color && e[`color${an(t.color)}`],
      t.fullWidth && e.fullWidth,
      t.hiddenLabel && e.hiddenLabel,
    ];
  },
  zy = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.input,
      t.size === "small" && e.inputSizeSmall,
      t.multiline && e.inputMultiline,
      t.type === "search" && e.inputTypeSearch,
      t.startAdornment && e.inputAdornedStart,
      t.endAdornment && e.inputAdornedEnd,
      t.hiddenLabel && e.inputHiddenLabel,
    ];
  },
  KO = (n) => {
    const {
        classes: e,
        color: t,
        disabled: r,
        error: i,
        endAdornment: o,
        focused: s,
        formControl: a,
        fullWidth: u,
        hiddenLabel: c,
        multiline: d,
        readOnly: m,
        size: g,
        startAdornment: y,
        type: x,
      } = n,
      S = {
        root: [
          "root",
          `color${an(t)}`,
          r && "disabled",
          i && "error",
          u && "fullWidth",
          s && "focused",
          a && "formControl",
          g && g !== "medium" && `size${an(g)}`,
          d && "multiline",
          y && "adornedStart",
          o && "adornedEnd",
          c && "hiddenLabel",
          m && "readOnly",
        ],
        input: [
          "input",
          r && "disabled",
          x === "search" && "inputTypeSearch",
          d && "inputMultiline",
          g === "small" && "inputSizeSmall",
          c && "inputHiddenLabel",
          y && "inputAdornedStart",
          o && "inputAdornedEnd",
          m && "readOnly",
        ],
      };
    return Bn(S, YO, e);
  },
  Hy = jt("div", { name: "MuiInputBase", slot: "Root", overridesResolver: By })(
    ({ theme: n, ownerState: e }) =>
      ue(
        {},
        n.typography.body1,
        {
          color: (n.vars || n).palette.text.primary,
          lineHeight: "1.4375em",
          boxSizing: "border-box",
          position: "relative",
          cursor: "text",
          display: "inline-flex",
          alignItems: "center",
          [`&.${Rh.disabled}`]: {
            color: (n.vars || n).palette.text.disabled,
            cursor: "default",
          },
        },
        e.multiline &&
          ue({ padding: "4px 0 5px" }, e.size === "small" && { paddingTop: 1 }),
        e.fullWidth && { width: "100%" }
      )
  ),
  Vy = jt("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: zy,
  })(({ theme: n, ownerState: e }) => {
    const t = n.palette.mode === "light",
      r = ue(
        { color: "currentColor" },
        n.vars
          ? { opacity: n.vars.opacity.inputPlaceholder }
          : { opacity: t ? 0.42 : 0.5 },
        {
          transition: n.transitions.create("opacity", {
            duration: n.transitions.duration.shorter,
          }),
        }
      ),
      i = { opacity: "0 !important" },
      o = n.vars
        ? { opacity: n.vars.opacity.inputPlaceholder }
        : { opacity: t ? 0.42 : 0.5 };
    return ue(
      {
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": r,
        "&::-moz-placeholder": r,
        "&:-ms-input-placeholder": r,
        "&::-ms-input-placeholder": r,
        "&:focus": { outline: 0 },
        "&:invalid": { boxShadow: "none" },
        "&::-webkit-search-decoration": { WebkitAppearance: "none" },
        [`label[data-shrink=false] + .${Rh.formControl} &`]: {
          "&::-webkit-input-placeholder": i,
          "&::-moz-placeholder": i,
          "&:-ms-input-placeholder": i,
          "&::-ms-input-placeholder": i,
          "&:focus::-webkit-input-placeholder": o,
          "&:focus::-moz-placeholder": o,
          "&:focus:-ms-input-placeholder": o,
          "&:focus::-ms-input-placeholder": o,
        },
        [`&.${Rh.disabled}`]: {
          opacity: 1,
          WebkitTextFillColor: (n.vars || n).palette.text.disabled,
        },
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill",
        },
      },
      e.size === "small" && { paddingTop: 1 },
      e.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0,
      },
      e.type === "search" && { MozAppearance: "textfield" }
    );
  }),
  ZO = Q.jsx($O, {
    styles: {
      "@keyframes mui-auto-fill": { from: { display: "block" } },
      "@keyframes mui-auto-fill-cancel": { from: { display: "block" } },
    },
  }),
  ow = X.forwardRef(function (e, t) {
    var r;
    const i = Yn({ props: e, name: "MuiInputBase" }),
      {
        "aria-describedby": o,
        autoComplete: s,
        autoFocus: a,
        className: u,
        components: c = {},
        componentsProps: d = {},
        defaultValue: m,
        disabled: g,
        disableInjectingGlobalStyles: y,
        endAdornment: x,
        fullWidth: S = !1,
        id: _,
        inputComponent: w = "input",
        inputProps: T = {},
        inputRef: M,
        maxRows: A,
        minRows: R,
        multiline: D = !1,
        name: P,
        onBlur: U,
        onChange: O,
        onClick: L,
        onFocus: H,
        onKeyDown: W,
        onKeyUp: $,
        placeholder: K,
        readOnly: Z,
        renderSuffix: Y,
        rows: re,
        slotProps: G = {},
        slots: te = {},
        startAdornment: F,
        type: V = "text",
        value: ne,
      } = i,
      ae = It(i, qO),
      J = T.value != null ? T.value : ne,
      { current: se } = X.useRef(J != null),
      de = X.useRef(),
      le = X.useCallback((Be) => {}, []),
      fe = ri(de, M, T.ref, le),
      [Me, ge] = X.useState(!1),
      xe = zh(),
      j = Bh({
        props: i,
        muiFormControl: xe,
        states: [
          "color",
          "disabled",
          "error",
          "hiddenLabel",
          "size",
          "required",
          "filled",
        ],
      });
    (j.focused = xe ? xe.focused : Me),
      X.useEffect(() => {
        !xe && g && Me && (ge(!1), U && U());
      }, [xe, g, Me, U]);
    const we = xe && xe.onFilled,
      Ae = xe && xe.onEmpty,
      Oe = X.useCallback(
        (Be) => {
          k0(Be) ? we && we() : Ae && Ae();
        },
        [we, Ae]
      );
    ha(() => {
      se && Oe({ value: J });
    }, [J, Oe, se]);
    const Ie = (Be) => {
        if (j.disabled) {
          Be.stopPropagation();
          return;
        }
        H && H(Be),
          T.onFocus && T.onFocus(Be),
          xe && xe.onFocus ? xe.onFocus(Be) : ge(!0);
      },
      rt = (Be) => {
        U && U(Be),
          T.onBlur && T.onBlur(Be),
          xe && xe.onBlur ? xe.onBlur(Be) : ge(!1);
      },
      De = (Be, ...Ge) => {
        if (!se) {
          const Ye = Be.target || de.current;
          if (Ye == null) throw new Error(Bl(1));
          Oe({ value: Ye.value });
        }
        T.onChange && T.onChange(Be, ...Ge), O && O(Be, ...Ge);
      };
    X.useEffect(() => {
      Oe(de.current);
    }, []);
    const Xe = (Be) => {
      de.current && Be.currentTarget === Be.target && de.current.focus(),
        L && L(Be);
    };
    let ee = w,
      B = T;
    D &&
      ee === "input" &&
      (re
        ? (B = ue({ type: void 0, minRows: re, maxRows: re }, B))
        : (B = ue({ type: void 0, maxRows: A, minRows: R }, B)),
      (ee = jO));
    const ve = (Be) => {
      Oe(
        Be.animationName === "mui-auto-fill-cancel"
          ? de.current
          : { value: "x" }
      );
    };
    X.useEffect(() => {
      xe && xe.setAdornedStart(!!F);
    }, [xe, F]);
    const Se = ue({}, i, {
        color: j.color || "primary",
        disabled: j.disabled,
        endAdornment: x,
        error: j.error,
        focused: j.focused,
        formControl: xe,
        fullWidth: S,
        hiddenLabel: j.hiddenLabel,
        multiline: D,
        size: j.size,
        startAdornment: F,
        type: V,
      }),
      _e = KO(Se),
      Te = te.root || c.Root || Hy,
      at = G.root || d.root || {},
      Fe = te.input || c.Input || Vy;
    return (
      (B = ue({}, B, (r = G.input) != null ? r : d.input)),
      Q.jsxs(X.Fragment, {
        children: [
          !y && ZO,
          Q.jsxs(
            Te,
            ue(
              {},
              at,
              !Ch(Te) && { ownerState: ue({}, Se, at.ownerState) },
              { ref: t, onClick: Xe },
              ae,
              {
                className: Zt(
                  _e.root,
                  at.className,
                  u,
                  Z && "MuiInputBase-readOnly"
                ),
                children: [
                  F,
                  Q.jsx(iw.Provider, {
                    value: null,
                    children: Q.jsx(
                      Fe,
                      ue(
                        {
                          ownerState: Se,
                          "aria-invalid": j.error,
                          "aria-describedby": o,
                          autoComplete: s,
                          autoFocus: a,
                          defaultValue: m,
                          disabled: j.disabled,
                          id: _,
                          onAnimationStart: ve,
                          name: P,
                          placeholder: K,
                          readOnly: Z,
                          required: j.required,
                          rows: re,
                          value: J,
                          onKeyDown: W,
                          onKeyUp: $,
                          type: V,
                        },
                        B,
                        !Ch(Fe) && {
                          as: ee,
                          ownerState: ue({}, Se, B.ownerState),
                        },
                        {
                          ref: fe,
                          className: Zt(
                            _e.input,
                            B.className,
                            Z && "MuiInputBase-readOnly"
                          ),
                          onBlur: rt,
                          onChange: De,
                          onFocus: Ie,
                        }
                      )
                    ),
                  }),
                  x,
                  Y ? Y(ue({}, j, { startAdornment: F })) : null,
                ],
              }
            )
          ),
        ],
      })
    );
  });
function JO(n) {
  return Fn("MuiInput", n);
}
const kp = ue({}, Rh, Ln("MuiInput", ["root", "underline", "input"]));
function QO(n) {
  return Fn("MuiOutlinedInput", n);
}
const Lu = ue(
  {},
  Rh,
  Ln("MuiOutlinedInput", ["root", "notchedOutline", "input"])
);
function eN(n) {
  return Fn("MuiFilledInput", n);
}
const Oc = ue({}, Rh, Ln("MuiFilledInput", ["root", "underline", "input"])),
  tN = Lf(Q.jsx("path", { d: "M7 10l5 5 5-5z" }), "ArrowDropDown"),
  nN = [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    "TransitionComponent",
  ],
  rN = { entering: { opacity: 1 }, entered: { opacity: 1 } },
  iN = X.forwardRef(function (e, t) {
    const r = KC(),
      i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen,
      },
      {
        addEndListener: o,
        appear: s = !0,
        children: a,
        easing: u,
        in: c,
        onEnter: d,
        onEntered: m,
        onEntering: g,
        onExit: y,
        onExited: x,
        onExiting: S,
        style: _,
        timeout: w = i,
        TransitionComponent: T = tl,
      } = e,
      M = It(e, nN),
      A = X.useRef(null),
      R = ri(A, a.ref, t),
      D = (K) => (Z) => {
        if (K) {
          const Y = A.current;
          Z === void 0 ? K(Y) : K(Y, Z);
        }
      },
      P = D(g),
      U = D((K, Z) => {
        QC(K);
        const Y = D0({ style: _, timeout: w, easing: u }, { mode: "enter" });
        (K.style.webkitTransition = r.transitions.create("opacity", Y)),
          (K.style.transition = r.transitions.create("opacity", Y)),
          d && d(K, Z);
      }),
      O = D(m),
      L = D(S),
      H = D((K) => {
        const Z = D0({ style: _, timeout: w, easing: u }, { mode: "exit" });
        (K.style.webkitTransition = r.transitions.create("opacity", Z)),
          (K.style.transition = r.transitions.create("opacity", Z)),
          y && y(K);
      }),
      W = D(x),
      $ = (K) => {
        o && o(A.current, K);
      };
    return Q.jsx(
      T,
      ue(
        {
          appear: s,
          in: c,
          nodeRef: A,
          onEnter: U,
          onEntered: O,
          onEntering: P,
          onExit: H,
          onExited: W,
          onExiting: L,
          addEndListener: $,
          timeout: w,
        },
        M,
        {
          children: (K, Z) =>
            X.cloneElement(
              a,
              ue(
                {
                  style: ue(
                    {
                      opacity: 0,
                      visibility: K === "exited" && !c ? "hidden" : void 0,
                    },
                    rN[K],
                    _,
                    a.props.style
                  ),
                  ref: R,
                },
                Z
              )
            ),
        }
      )
    );
  });
function oN(n) {
  return Fn("MuiBackdrop", n);
}
Ln("MuiBackdrop", ["root", "invisible"]);
const sN = [
    "children",
    "className",
    "component",
    "components",
    "componentsProps",
    "invisible",
    "open",
    "slotProps",
    "slots",
    "TransitionComponent",
    "transitionDuration",
  ],
  aN = (n) => {
    const { classes: e, invisible: t } = n;
    return Bn({ root: ["root", t && "invisible"] }, oN, e);
  },
  lN = jt("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, t.invisible && e.invisible];
    },
  })(({ ownerState: n }) =>
    ue(
      {
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        WebkitTapHighlightColor: "transparent",
      },
      n.invisible && { backgroundColor: "transparent" }
    )
  ),
  uN = X.forwardRef(function (e, t) {
    var r, i, o;
    const s = Yn({ props: e, name: "MuiBackdrop" }),
      {
        children: a,
        className: u,
        component: c = "div",
        components: d = {},
        componentsProps: m = {},
        invisible: g = !1,
        open: y,
        slotProps: x = {},
        slots: S = {},
        TransitionComponent: _ = iN,
        transitionDuration: w,
      } = s,
      T = It(s, sN),
      M = ue({}, s, { component: c, invisible: g }),
      A = aN(M),
      R = (r = x.root) != null ? r : m.root;
    return Q.jsx(
      _,
      ue({ in: y, timeout: w }, T, {
        children: Q.jsx(
          lN,
          ue({ "aria-hidden": !0 }, R, {
            as: (i = (o = S.root) != null ? o : d.Root) != null ? i : c,
            className: Zt(A.root, u, R == null ? void 0 : R.className),
            ownerState: ue({}, M, R == null ? void 0 : R.ownerState),
            classes: A,
            ref: t,
            children: a,
          })
        ),
      })
    );
  }),
  cN = Ln("MuiBox", ["root"]),
  fN = qC(),
  fn = gD({
    themeId: by,
    defaultTheme: fN,
    defaultClassName: cN.root,
    generateClassName: qS.generate,
  });
function dN(n) {
  return Fn("MuiButton", n);
}
const vv = Ln("MuiButton", [
    "root",
    "text",
    "textInherit",
    "textPrimary",
    "textSecondary",
    "textSuccess",
    "textError",
    "textInfo",
    "textWarning",
    "outlined",
    "outlinedInherit",
    "outlinedPrimary",
    "outlinedSecondary",
    "outlinedSuccess",
    "outlinedError",
    "outlinedInfo",
    "outlinedWarning",
    "contained",
    "containedInherit",
    "containedPrimary",
    "containedSecondary",
    "containedSuccess",
    "containedError",
    "containedInfo",
    "containedWarning",
    "disableElevation",
    "focusVisible",
    "disabled",
    "colorInherit",
    "colorPrimary",
    "colorSecondary",
    "colorSuccess",
    "colorError",
    "colorInfo",
    "colorWarning",
    "textSizeSmall",
    "textSizeMedium",
    "textSizeLarge",
    "outlinedSizeSmall",
    "outlinedSizeMedium",
    "outlinedSizeLarge",
    "containedSizeSmall",
    "containedSizeMedium",
    "containedSizeLarge",
    "sizeMedium",
    "sizeSmall",
    "sizeLarge",
    "fullWidth",
    "startIcon",
    "endIcon",
    "icon",
    "iconSizeSmall",
    "iconSizeMedium",
    "iconSizeLarge",
  ]),
  hN = X.createContext({}),
  pN = X.createContext(void 0),
  mN = [
    "children",
    "color",
    "component",
    "className",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "endIcon",
    "focusVisibleClassName",
    "fullWidth",
    "size",
    "startIcon",
    "type",
    "variant",
  ],
  gN = (n) => {
    const {
        color: e,
        disableElevation: t,
        fullWidth: r,
        size: i,
        variant: o,
        classes: s,
      } = n,
      a = {
        root: [
          "root",
          o,
          `${o}${an(e)}`,
          `size${an(i)}`,
          `${o}Size${an(i)}`,
          `color${an(e)}`,
          t && "disableElevation",
          r && "fullWidth",
        ],
        label: ["label"],
        startIcon: ["icon", "startIcon", `iconSize${an(i)}`],
        endIcon: ["icon", "endIcon", `iconSize${an(i)}`],
      },
      u = Bn(a, dN, s);
    return ue({}, s, u);
  },
  eA = (n) =>
    ue(
      {},
      n.size === "small" && { "& > *:nth-of-type(1)": { fontSize: 18 } },
      n.size === "medium" && { "& > *:nth-of-type(1)": { fontSize: 20 } },
      n.size === "large" && { "& > *:nth-of-type(1)": { fontSize: 22 } }
    ),
  vN = jt(rw, {
    shouldForwardProp: (n) => Os(n) || n === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        e[t.variant],
        e[`${t.variant}${an(t.color)}`],
        e[`size${an(t.size)}`],
        e[`${t.variant}Size${an(t.size)}`],
        t.color === "inherit" && e.colorInherit,
        t.disableElevation && e.disableElevation,
        t.fullWidth && e.fullWidth,
      ];
    },
  })(
    ({ theme: n, ownerState: e }) => {
      var t, r;
      const i =
          n.palette.mode === "light"
            ? n.palette.grey[300]
            : n.palette.grey[800],
        o =
          n.palette.mode === "light"
            ? n.palette.grey.A100
            : n.palette.grey[700];
      return ue(
        {},
        n.typography.button,
        {
          minWidth: 64,
          padding: "6px 16px",
          borderRadius: (n.vars || n).shape.borderRadius,
          transition: n.transitions.create(
            ["background-color", "box-shadow", "border-color", "color"],
            { duration: n.transitions.duration.short }
          ),
          "&:hover": ue(
            {
              textDecoration: "none",
              backgroundColor: n.vars
                ? `rgba(${n.vars.palette.text.primaryChannel} / ${n.vars.palette.action.hoverOpacity})`
                : Bi.alpha(
                    n.palette.text.primary,
                    n.palette.action.hoverOpacity
                  ),
              "@media (hover: none)": { backgroundColor: "transparent" },
            },
            e.variant === "text" &&
              e.color !== "inherit" && {
                backgroundColor: n.vars
                  ? `rgba(${n.vars.palette[e.color].mainChannel} / ${
                      n.vars.palette.action.hoverOpacity
                    })`
                  : Bi.alpha(
                      n.palette[e.color].main,
                      n.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            e.variant === "outlined" &&
              e.color !== "inherit" && {
                border: `1px solid ${(n.vars || n).palette[e.color].main}`,
                backgroundColor: n.vars
                  ? `rgba(${n.vars.palette[e.color].mainChannel} / ${
                      n.vars.palette.action.hoverOpacity
                    })`
                  : Bi.alpha(
                      n.palette[e.color].main,
                      n.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            e.variant === "contained" && {
              backgroundColor: n.vars
                ? n.vars.palette.Button.inheritContainedHoverBg
                : o,
              boxShadow: (n.vars || n).shadows[4],
              "@media (hover: none)": {
                boxShadow: (n.vars || n).shadows[2],
                backgroundColor: (n.vars || n).palette.grey[300],
              },
            },
            e.variant === "contained" &&
              e.color !== "inherit" && {
                backgroundColor: (n.vars || n).palette[e.color].dark,
                "@media (hover: none)": {
                  backgroundColor: (n.vars || n).palette[e.color].main,
                },
              }
          ),
          "&:active": ue(
            {},
            e.variant === "contained" && { boxShadow: (n.vars || n).shadows[8] }
          ),
          [`&.${vv.focusVisible}`]: ue(
            {},
            e.variant === "contained" && { boxShadow: (n.vars || n).shadows[6] }
          ),
          [`&.${vv.disabled}`]: ue(
            { color: (n.vars || n).palette.action.disabled },
            e.variant === "outlined" && {
              border: `1px solid ${
                (n.vars || n).palette.action.disabledBackground
              }`,
            },
            e.variant === "contained" && {
              color: (n.vars || n).palette.action.disabled,
              boxShadow: (n.vars || n).shadows[0],
              backgroundColor: (n.vars || n).palette.action.disabledBackground,
            }
          ),
        },
        e.variant === "text" && { padding: "6px 8px" },
        e.variant === "text" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].main,
          },
        e.variant === "outlined" && {
          padding: "5px 15px",
          border: "1px solid currentColor",
        },
        e.variant === "outlined" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].main,
            border: n.vars
              ? `1px solid rgba(${n.vars.palette[e.color].mainChannel} / 0.5)`
              : `1px solid ${Bi.alpha(n.palette[e.color].main, 0.5)}`,
          },
        e.variant === "contained" && {
          color: n.vars
            ? n.vars.palette.text.primary
            : (t = (r = n.palette).getContrastText) == null
            ? void 0
            : t.call(r, n.palette.grey[300]),
          backgroundColor: n.vars
            ? n.vars.palette.Button.inheritContainedBg
            : i,
          boxShadow: (n.vars || n).shadows[2],
        },
        e.variant === "contained" &&
          e.color !== "inherit" && {
            color: (n.vars || n).palette[e.color].contrastText,
            backgroundColor: (n.vars || n).palette[e.color].main,
          },
        e.color === "inherit" && {
          color: "inherit",
          borderColor: "currentColor",
        },
        e.size === "small" &&
          e.variant === "text" && {
            padding: "4px 5px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "text" && {
            padding: "8px 11px",
            fontSize: n.typography.pxToRem(15),
          },
        e.size === "small" &&
          e.variant === "outlined" && {
            padding: "3px 9px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "outlined" && {
            padding: "7px 21px",
            fontSize: n.typography.pxToRem(15),
          },
        e.size === "small" &&
          e.variant === "contained" && {
            padding: "4px 10px",
            fontSize: n.typography.pxToRem(13),
          },
        e.size === "large" &&
          e.variant === "contained" && {
            padding: "8px 22px",
            fontSize: n.typography.pxToRem(15),
          },
        e.fullWidth && { width: "100%" }
      );
    },
    ({ ownerState: n }) =>
      n.disableElevation && {
        boxShadow: "none",
        "&:hover": { boxShadow: "none" },
        [`&.${vv.focusVisible}`]: { boxShadow: "none" },
        "&:active": { boxShadow: "none" },
        [`&.${vv.disabled}`]: { boxShadow: "none" },
      }
  ),
  yN = jt("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.startIcon, e[`iconSize${an(t.size)}`]];
    },
  })(({ ownerState: n }) =>
    ue(
      { display: "inherit", marginRight: 8, marginLeft: -4 },
      n.size === "small" && { marginLeft: -2 },
      eA(n)
    )
  ),
  xN = jt("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.endIcon, e[`iconSize${an(t.size)}`]];
    },
  })(({ ownerState: n }) =>
    ue(
      { display: "inherit", marginRight: -4, marginLeft: 8 },
      n.size === "small" && { marginRight: -2 },
      eA(n)
    )
  ),
  cm = X.forwardRef(function (e, t) {
    const r = X.useContext(hN),
      i = X.useContext(pN),
      o = Rm(r, e),
      s = Yn({ props: o, name: "MuiButton" }),
      {
        children: a,
        color: u = "primary",
        component: c = "button",
        className: d,
        disabled: m = !1,
        disableElevation: g = !1,
        disableFocusRipple: y = !1,
        endIcon: x,
        focusVisibleClassName: S,
        fullWidth: _ = !1,
        size: w = "medium",
        startIcon: T,
        type: M,
        variant: A = "text",
      } = s,
      R = It(s, mN),
      D = ue({}, s, {
        color: u,
        component: c,
        disabled: m,
        disableElevation: g,
        disableFocusRipple: y,
        fullWidth: _,
        size: w,
        type: M,
        variant: A,
      }),
      P = gN(D),
      U =
        T && Q.jsx(yN, { className: P.startIcon, ownerState: D, children: T }),
      O = x && Q.jsx(xN, { className: P.endIcon, ownerState: D, children: x }),
      L = i || "";
    return Q.jsxs(
      vN,
      ue(
        {
          ownerState: D,
          className: Zt(r.className, P.root, d, L),
          component: c,
          disabled: m,
          focusRipple: !y,
          focusVisibleClassName: Zt(P.focusVisible, S),
          ref: t,
          type: M,
        },
        R,
        { classes: P, children: [U, a, O] }
      )
    );
  });
function _N(n) {
  const e = zo(n);
  return e.body === n
    ? qu(n).innerWidth > e.documentElement.clientWidth
    : n.scrollHeight > n.clientHeight;
}
function fm(n, e) {
  e ? n.setAttribute("aria-hidden", "true") : n.removeAttribute("aria-hidden");
}
function JM(n) {
  return parseInt(qu(n).getComputedStyle(n).paddingRight, 10) || 0;
}
function SN(n) {
  const t =
      [
        "TEMPLATE",
        "SCRIPT",
        "STYLE",
        "LINK",
        "MAP",
        "META",
        "NOSCRIPT",
        "PICTURE",
        "COL",
        "COLGROUP",
        "PARAM",
        "SLOT",
        "SOURCE",
        "TRACK",
      ].indexOf(n.tagName) !== -1,
    r = n.tagName === "INPUT" && n.getAttribute("type") === "hidden";
  return t || r;
}
function QM(n, e, t, r, i) {
  const o = [e, t, ...r];
  [].forEach.call(n.children, (s) => {
    const a = o.indexOf(s) === -1,
      u = !SN(s);
    a && u && fm(s, i);
  });
}
function w_(n, e) {
  let t = -1;
  return n.some((r, i) => (e(r) ? ((t = i), !0) : !1)), t;
}
function wN(n, e) {
  const t = [],
    r = n.container;
  if (!e.disableScrollLock) {
    if (_N(r)) {
      const s = GC(zo(r));
      t.push({ value: r.style.paddingRight, property: "padding-right", el: r }),
        (r.style.paddingRight = `${JM(r) + s}px`);
      const a = zo(r).querySelectorAll(".mui-fixed");
      [].forEach.call(a, (u) => {
        t.push({
          value: u.style.paddingRight,
          property: "padding-right",
          el: u,
        }),
          (u.style.paddingRight = `${JM(u) + s}px`);
      });
    }
    let o;
    if (r.parentNode instanceof DocumentFragment) o = zo(r).body;
    else {
      const s = r.parentElement,
        a = qu(r);
      o =
        (s == null ? void 0 : s.nodeName) === "HTML" &&
        a.getComputedStyle(s).overflowY === "scroll"
          ? s
          : r;
    }
    t.push(
      { value: o.style.overflow, property: "overflow", el: o },
      { value: o.style.overflowX, property: "overflow-x", el: o },
      { value: o.style.overflowY, property: "overflow-y", el: o }
    ),
      (o.style.overflow = "hidden");
  }
  return () => {
    t.forEach(({ value: o, el: s, property: a }) => {
      o ? s.style.setProperty(a, o) : s.style.removeProperty(a);
    });
  };
}
function bN(n) {
  const e = [];
  return (
    [].forEach.call(n.children, (t) => {
      t.getAttribute("aria-hidden") === "true" && e.push(t);
    }),
    e
  );
}
class MN {
  constructor() {
    (this.containers = void 0),
      (this.modals = void 0),
      (this.modals = []),
      (this.containers = []);
  }
  add(e, t) {
    let r = this.modals.indexOf(e);
    if (r !== -1) return r;
    (r = this.modals.length),
      this.modals.push(e),
      e.modalRef && fm(e.modalRef, !1);
    const i = bN(t);
    QM(t, e.mount, e.modalRef, i, !0);
    const o = w_(this.containers, (s) => s.container === t);
    return o !== -1
      ? (this.containers[o].modals.push(e), r)
      : (this.containers.push({
          modals: [e],
          container: t,
          restore: null,
          hiddenSiblings: i,
        }),
        r);
  }
  mount(e, t) {
    const r = w_(this.containers, (o) => o.modals.indexOf(e) !== -1),
      i = this.containers[r];
    i.restore || (i.restore = wN(i, t));
  }
  remove(e, t = !0) {
    const r = this.modals.indexOf(e);
    if (r === -1) return r;
    const i = w_(this.containers, (s) => s.modals.indexOf(e) !== -1),
      o = this.containers[i];
    if (
      (o.modals.splice(o.modals.indexOf(e), 1),
      this.modals.splice(r, 1),
      o.modals.length === 0)
    )
      o.restore && o.restore(),
        e.modalRef && fm(e.modalRef, t),
        QM(o.container, e.mount, e.modalRef, o.hiddenSiblings, !1),
        this.containers.splice(i, 1);
    else {
      const s = o.modals[o.modals.length - 1];
      s.modalRef && fm(s.modalRef, !1);
    }
    return r;
  }
  isTopModal(e) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === e;
  }
}
const EN = [
  "input",
  "select",
  "textarea",
  "a[href]",
  "button",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable="false"])',
].join(",");
function TN(n) {
  const e = parseInt(n.getAttribute("tabindex") || "", 10);
  return Number.isNaN(e)
    ? n.contentEditable === "true" ||
      ((n.nodeName === "AUDIO" ||
        n.nodeName === "VIDEO" ||
        n.nodeName === "DETAILS") &&
        n.getAttribute("tabindex") === null)
      ? 0
      : n.tabIndex
    : e;
}
function CN(n) {
  if (n.tagName !== "INPUT" || n.type !== "radio" || !n.name) return !1;
  const e = (r) => n.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let t = e(`[name="${n.name}"]:checked`);
  return t || (t = e(`[name="${n.name}"]`)), t !== n;
}
function AN(n) {
  return !(
    n.disabled ||
    (n.tagName === "INPUT" && n.type === "hidden") ||
    CN(n)
  );
}
function RN(n) {
  const e = [],
    t = [];
  return (
    Array.from(n.querySelectorAll(EN)).forEach((r, i) => {
      const o = TN(r);
      o === -1 ||
        !AN(r) ||
        (o === 0
          ? e.push(r)
          : t.push({ documentOrder: i, tabIndex: o, node: r }));
    }),
    t
      .sort((r, i) =>
        r.tabIndex === i.tabIndex
          ? r.documentOrder - i.documentOrder
          : r.tabIndex - i.tabIndex
      )
      .map((r) => r.node)
      .concat(e)
  );
}
function PN() {
  return !0;
}
function IN(n) {
  const {
      children: e,
      disableAutoFocus: t = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: i = !1,
      getTabbable: o = RN,
      isEnabled: s = PN,
      open: a,
    } = n,
    u = X.useRef(!1),
    c = X.useRef(null),
    d = X.useRef(null),
    m = X.useRef(null),
    g = X.useRef(null),
    y = X.useRef(!1),
    x = X.useRef(null),
    S = ri(e.ref, x),
    _ = X.useRef(null);
  X.useEffect(() => {
    !a || !x.current || (y.current = !t);
  }, [t, a]),
    X.useEffect(() => {
      if (!a || !x.current) return;
      const M = zo(x.current);
      return (
        x.current.contains(M.activeElement) ||
          (x.current.hasAttribute("tabIndex") ||
            x.current.setAttribute("tabIndex", "-1"),
          y.current && x.current.focus()),
        () => {
          i ||
            (m.current &&
              m.current.focus &&
              ((u.current = !0), m.current.focus()),
            (m.current = null));
        }
      );
    }, [a]),
    X.useEffect(() => {
      if (!a || !x.current) return;
      const M = zo(x.current),
        A = (P) => {
          (_.current = P),
            !(r || !s() || P.key !== "Tab") &&
              M.activeElement === x.current &&
              P.shiftKey &&
              ((u.current = !0), d.current && d.current.focus());
        },
        R = () => {
          const P = x.current;
          if (P === null) return;
          if (!M.hasFocus() || !s() || u.current) {
            u.current = !1;
            return;
          }
          if (
            P.contains(M.activeElement) ||
            (r &&
              M.activeElement !== c.current &&
              M.activeElement !== d.current)
          )
            return;
          if (M.activeElement !== g.current) g.current = null;
          else if (g.current !== null) return;
          if (!y.current) return;
          let U = [];
          if (
            ((M.activeElement === c.current || M.activeElement === d.current) &&
              (U = o(x.current)),
            U.length > 0)
          ) {
            var O, L;
            const H = !!(
                (O = _.current) != null &&
                O.shiftKey &&
                ((L = _.current) == null ? void 0 : L.key) === "Tab"
              ),
              W = U[0],
              $ = U[U.length - 1];
            typeof W != "string" &&
              typeof $ != "string" &&
              (H ? $.focus() : W.focus());
          } else P.focus();
        };
      M.addEventListener("focusin", R), M.addEventListener("keydown", A, !0);
      const D = setInterval(() => {
        M.activeElement && M.activeElement.tagName === "BODY" && R();
      }, 50);
      return () => {
        clearInterval(D),
          M.removeEventListener("focusin", R),
          M.removeEventListener("keydown", A, !0);
      };
    }, [t, r, i, s, a, o]);
  const w = (M) => {
      m.current === null && (m.current = M.relatedTarget),
        (y.current = !0),
        (g.current = M.target);
      const A = e.props.onFocus;
      A && A(M);
    },
    T = (M) => {
      m.current === null && (m.current = M.relatedTarget), (y.current = !0);
    };
  return Q.jsxs(X.Fragment, {
    children: [
      Q.jsx("div", {
        tabIndex: a ? 0 : -1,
        onFocus: T,
        ref: c,
        "data-testid": "sentinelStart",
      }),
      X.cloneElement(e, { ref: S, onFocus: w }),
      Q.jsx("div", {
        tabIndex: a ? 0 : -1,
        onFocus: T,
        ref: d,
        "data-testid": "sentinelEnd",
      }),
    ],
  });
}
function LN(n) {
  return typeof n == "function" ? n() : n;
}
function DN(n) {
  return n ? n.props.hasOwnProperty("in") : !1;
}
const kN = new MN();
function ON(n) {
  const {
      container: e,
      disableEscapeKeyDown: t = !1,
      disableScrollLock: r = !1,
      manager: i = kN,
      closeAfterTransition: o = !1,
      onTransitionEnter: s,
      onTransitionExited: a,
      children: u,
      onClose: c,
      open: d,
      rootRef: m,
    } = n,
    g = X.useRef({}),
    y = X.useRef(null),
    x = X.useRef(null),
    S = ri(x, m),
    [_, w] = X.useState(!d),
    T = DN(u);
  let M = !0;
  (n["aria-hidden"] === "false" || n["aria-hidden"] === !1) && (M = !1);
  const A = () => zo(y.current),
    R = () => (
      (g.current.modalRef = x.current), (g.current.mount = y.current), g.current
    ),
    D = () => {
      i.mount(R(), { disableScrollLock: r }),
        x.current && (x.current.scrollTop = 0);
    },
    P = ff(() => {
      const Y = LN(e) || A().body;
      i.add(R(), Y), x.current && D();
    }),
    U = X.useCallback(() => i.isTopModal(R()), [i]),
    O = ff((Y) => {
      (y.current = Y), Y && (d && U() ? D() : x.current && fm(x.current, M));
    }),
    L = X.useCallback(() => {
      i.remove(R(), M);
    }, [M, i]);
  X.useEffect(
    () => () => {
      L();
    },
    [L]
  ),
    X.useEffect(() => {
      d ? P() : (!T || !o) && L();
    }, [d, L, T, o, P]);
  const H = (Y) => (re) => {
      var G;
      (G = Y.onKeyDown) == null || G.call(Y, re),
        !(re.key !== "Escape" || re.which === 229 || !U()) &&
          (t || (re.stopPropagation(), c && c(re, "escapeKeyDown")));
    },
    W = (Y) => (re) => {
      var G;
      (G = Y.onClick) == null || G.call(Y, re),
        re.target === re.currentTarget && c && c(re, "backdropClick");
    };
  return {
    getRootProps: (Y = {}) => {
      const re = I0(n);
      delete re.onTransitionEnter, delete re.onTransitionExited;
      const G = ue({}, re, Y);
      return ue({ role: "presentation" }, G, { onKeyDown: H(G), ref: S });
    },
    getBackdropProps: (Y = {}) => {
      const re = Y;
      return ue({ "aria-hidden": !0 }, re, { onClick: W(re), open: d });
    },
    getTransitionProps: () => {
      const Y = () => {
          w(!1), s && s();
        },
        re = () => {
          w(!0), a && a(), o && L();
        };
      return {
        onEnter: q1(Y, u == null ? void 0 : u.props.onEnter),
        onExited: q1(re, u == null ? void 0 : u.props.onExited),
      };
    },
    rootRef: S,
    portalRef: O,
    isTopModal: U,
    exited: _,
    hasTransition: T,
  };
}
function NN(n) {
  return Fn("MuiModal", n);
}
Ln("MuiModal", ["root", "hidden", "backdrop"]);
const UN = [
    "BackdropComponent",
    "BackdropProps",
    "classes",
    "className",
    "closeAfterTransition",
    "children",
    "container",
    "component",
    "components",
    "componentsProps",
    "disableAutoFocus",
    "disableEnforceFocus",
    "disableEscapeKeyDown",
    "disablePortal",
    "disableRestoreFocus",
    "disableScrollLock",
    "hideBackdrop",
    "keepMounted",
    "onBackdropClick",
    "onClose",
    "onTransitionEnter",
    "onTransitionExited",
    "open",
    "slotProps",
    "slots",
    "theme",
  ],
  FN = (n) => {
    const { open: e, exited: t, classes: r } = n;
    return Bn(
      { root: ["root", !e && t && "hidden"], backdrop: ["backdrop"] },
      NN,
      r
    );
  },
  BN = jt("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, !t.open && t.exited && e.hidden];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      {
        position: "fixed",
        zIndex: (n.vars || n).zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
      },
      !e.open && e.exited && { visibility: "hidden" }
    )
  ),
  zN = jt(uN, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (n, e) => e.backdrop,
  })({ zIndex: -1 }),
  HN = X.forwardRef(function (e, t) {
    var r, i, o, s, a, u;
    const c = Yn({ name: "MuiModal", props: e }),
      {
        BackdropComponent: d = zN,
        BackdropProps: m,
        className: g,
        closeAfterTransition: y = !1,
        children: x,
        container: S,
        component: _,
        components: w = {},
        componentsProps: T = {},
        disableAutoFocus: M = !1,
        disableEnforceFocus: A = !1,
        disableEscapeKeyDown: R = !1,
        disablePortal: D = !1,
        disableRestoreFocus: P = !1,
        disableScrollLock: U = !1,
        hideBackdrop: O = !1,
        keepMounted: L = !1,
        onBackdropClick: H,
        open: W,
        slotProps: $,
        slots: K,
      } = c,
      Z = It(c, UN),
      Y = ue({}, c, {
        closeAfterTransition: y,
        disableAutoFocus: M,
        disableEnforceFocus: A,
        disableEscapeKeyDown: R,
        disablePortal: D,
        disableRestoreFocus: P,
        disableScrollLock: U,
        hideBackdrop: O,
        keepMounted: L,
      }),
      {
        getRootProps: re,
        getBackdropProps: G,
        getTransitionProps: te,
        portalRef: F,
        isTopModal: V,
        exited: ne,
        hasTransition: ae,
      } = ON(ue({}, Y, { rootRef: t })),
      J = ue({}, Y, { exited: ne }),
      se = FN(J),
      de = {};
    if ((x.props.tabIndex === void 0 && (de.tabIndex = "-1"), ae)) {
      const { onEnter: we, onExited: Ae } = te();
      (de.onEnter = we), (de.onExited = Ae);
    }
    const le =
        (r = (i = K == null ? void 0 : K.root) != null ? i : w.Root) != null
          ? r
          : BN,
      fe =
        (o = (s = K == null ? void 0 : K.backdrop) != null ? s : w.Backdrop) !=
        null
          ? o
          : d,
      Me = (a = $ == null ? void 0 : $.root) != null ? a : T.root,
      ge = (u = $ == null ? void 0 : $.backdrop) != null ? u : T.backdrop,
      xe = Ah({
        elementType: le,
        externalSlotProps: Me,
        externalForwardedProps: Z,
        getSlotProps: re,
        additionalProps: { ref: t, as: _ },
        ownerState: J,
        className: Zt(
          g,
          Me == null ? void 0 : Me.className,
          se == null ? void 0 : se.root,
          !J.open && J.exited && (se == null ? void 0 : se.hidden)
        ),
      }),
      j = Ah({
        elementType: fe,
        externalSlotProps: ge,
        additionalProps: m,
        getSlotProps: (we) =>
          G(
            ue({}, we, {
              onClick: (Ae) => {
                H && H(Ae), we != null && we.onClick && we.onClick(Ae);
              },
            })
          ),
        className: Zt(
          ge == null ? void 0 : ge.className,
          m == null ? void 0 : m.className,
          se == null ? void 0 : se.backdrop
        ),
        ownerState: J,
      });
    return !L && !W && (!ae || ne)
      ? null
      : Q.jsx(HO, {
          ref: F,
          container: S,
          disablePortal: D,
          children: Q.jsxs(
            le,
            ue({}, xe, {
              children: [
                !O && d ? Q.jsx(fe, ue({}, j)) : null,
                Q.jsx(IN, {
                  disableEnforceFocus: A,
                  disableAutoFocus: M,
                  disableRestoreFocus: P,
                  isEnabled: V,
                  open: W,
                  children: X.cloneElement(x, de),
                }),
              ],
            })
          ),
        });
  }),
  eE = Ln("MuiDivider", [
    "root",
    "absolute",
    "fullWidth",
    "inset",
    "middle",
    "flexItem",
    "light",
    "vertical",
    "withChildren",
    "withChildrenVertical",
    "textAlignRight",
    "textAlignLeft",
    "wrapper",
    "wrapperVertical",
  ]),
  VN = [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "hiddenLabel",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type",
  ],
  WN = (n) => {
    const { classes: e, disableUnderline: t } = n,
      i = Bn({ root: ["root", !t && "underline"], input: ["input"] }, eN, e);
    return ue({}, e, i);
  },
  GN = jt(Hy, {
    shouldForwardProp: (n) => Os(n) || n === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [...By(n, e), !t.disableUnderline && e.underline];
    },
  })(({ theme: n, ownerState: e }) => {
    var t;
    const r = n.palette.mode === "light",
      i = r ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
      o = r ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
      s = r ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
      a = r ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return ue(
      {
        position: "relative",
        backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
        borderTopLeftRadius: (n.vars || n).shape.borderRadius,
        borderTopRightRadius: (n.vars || n).shape.borderRadius,
        transition: n.transitions.create("background-color", {
          duration: n.transitions.duration.shorter,
          easing: n.transitions.easing.easeOut,
        }),
        "&:hover": {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.hoverBg : s,
          "@media (hover: none)": {
            backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
          },
        },
        [`&.${Oc.focused}`]: {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : o,
        },
        [`&.${Oc.disabled}`]: {
          backgroundColor: n.vars ? n.vars.palette.FilledInput.disabledBg : a,
        },
      },
      !e.disableUnderline && {
        "&::after": {
          borderBottom: `2px solid ${
            (t = (n.vars || n).palette[e.color || "primary"]) == null
              ? void 0
              : t.main
          }`,
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: n.transitions.create("transform", {
            duration: n.transitions.duration.shorter,
            easing: n.transitions.easing.easeOut,
          }),
          pointerEvents: "none",
        },
        [`&.${Oc.focused}:after`]: { transform: "scaleX(1) translateX(0)" },
        [`&.${Oc.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (n.vars || n).palette.error.main,
          },
        },
        "&::before": {
          borderBottom: `1px solid ${
            n.vars
              ? `rgba(${n.vars.palette.common.onBackgroundChannel} / ${n.vars.opacity.inputUnderline})`
              : i
          }`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: n.transitions.create("border-bottom-color", {
            duration: n.transitions.duration.shorter,
          }),
          pointerEvents: "none",
        },
        [`&:hover:not(.${Oc.disabled}, .${Oc.error}):before`]: {
          borderBottom: `1px solid ${(n.vars || n).palette.text.primary}`,
        },
        [`&.${Oc.disabled}:before`]: { borderBottomStyle: "dotted" },
      },
      e.startAdornment && { paddingLeft: 12 },
      e.endAdornment && { paddingRight: 12 },
      e.multiline &&
        ue(
          { padding: "25px 12px 8px" },
          e.size === "small" && { paddingTop: 21, paddingBottom: 4 },
          e.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
          e.hiddenLabel &&
            e.size === "small" && { paddingTop: 8, paddingBottom: 9 }
        )
    );
  }),
  jN = jt(Vy, { name: "MuiFilledInput", slot: "Input", overridesResolver: zy })(
    ({ theme: n, ownerState: e }) =>
      ue(
        { paddingTop: 25, paddingRight: 12, paddingBottom: 8, paddingLeft: 12 },
        !n.vars && {
          "&:-webkit-autofill": {
            WebkitBoxShadow:
              n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
            caretColor: n.palette.mode === "light" ? null : "#fff",
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit",
          },
        },
        n.vars && {
          "&:-webkit-autofill": {
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit",
          },
          [n.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
              WebkitBoxShadow: "0 0 0 100px #266798 inset",
              WebkitTextFillColor: "#fff",
              caretColor: "#fff",
            },
          },
        },
        e.size === "small" && { paddingTop: 21, paddingBottom: 4 },
        e.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
        e.startAdornment && { paddingLeft: 0 },
        e.endAdornment && { paddingRight: 0 },
        e.hiddenLabel &&
          e.size === "small" && { paddingTop: 8, paddingBottom: 9 },
        e.multiline && {
          paddingTop: 0,
          paddingBottom: 0,
          paddingLeft: 0,
          paddingRight: 0,
        }
      )
  ),
  sw = X.forwardRef(function (e, t) {
    var r, i, o, s;
    const a = Yn({ props: e, name: "MuiFilledInput" }),
      {
        components: u = {},
        componentsProps: c,
        fullWidth: d = !1,
        inputComponent: m = "input",
        multiline: g = !1,
        slotProps: y,
        slots: x = {},
        type: S = "text",
      } = a,
      _ = It(a, VN),
      w = ue({}, a, { fullWidth: d, inputComponent: m, multiline: g, type: S }),
      T = WN(a),
      M = { root: { ownerState: w }, input: { ownerState: w } },
      A = y ?? c ? ni(M, y ?? c) : M,
      R = (r = (i = x.root) != null ? i : u.Root) != null ? r : GN,
      D = (o = (s = x.input) != null ? s : u.Input) != null ? o : jN;
    return Q.jsx(
      ow,
      ue(
        {
          slots: { root: R, input: D },
          componentsProps: A,
          fullWidth: d,
          inputComponent: m,
          multiline: g,
          ref: t,
          type: S,
        },
        _,
        { classes: T }
      )
    );
  });
sw.muiName = "Input";
function $N(n) {
  return Fn("MuiFormControl", n);
}
Ln("MuiFormControl", [
  "root",
  "marginNone",
  "marginNormal",
  "marginDense",
  "fullWidth",
  "disabled",
]);
const XN = [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "focused",
    "fullWidth",
    "hiddenLabel",
    "margin",
    "required",
    "size",
    "variant",
  ],
  YN = (n) => {
    const { classes: e, margin: t, fullWidth: r } = n,
      i = {
        root: ["root", t !== "none" && `margin${an(t)}`, r && "fullWidth"],
      };
    return Bn(i, $N, e);
  },
  qN = jt("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({ ownerState: n }, e) =>
      ue({}, e.root, e[`margin${an(n.margin)}`], n.fullWidth && e.fullWidth),
  })(({ ownerState: n }) =>
    ue(
      {
        display: "inline-flex",
        flexDirection: "column",
        position: "relative",
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: "top",
      },
      n.margin === "normal" && { marginTop: 16, marginBottom: 8 },
      n.margin === "dense" && { marginTop: 8, marginBottom: 4 },
      n.fullWidth && { width: "100%" }
    )
  ),
  tf = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiFormControl" }),
      {
        children: i,
        className: o,
        color: s = "primary",
        component: a = "div",
        disabled: u = !1,
        error: c = !1,
        focused: d,
        fullWidth: m = !1,
        hiddenLabel: g = !1,
        margin: y = "none",
        required: x = !1,
        size: S = "medium",
        variant: _ = "outlined",
      } = r,
      w = It(r, XN),
      T = ue({}, r, {
        color: s,
        component: a,
        disabled: u,
        error: c,
        fullWidth: m,
        hiddenLabel: g,
        margin: y,
        required: x,
        size: S,
        variant: _,
      }),
      M = YN(T),
      [A, R] = X.useState(() => {
        let $ = !1;
        return (
          i &&
            X.Children.forEach(i, (K) => {
              if (!um(K, ["Input", "Select"])) return;
              const Z = um(K, ["Select"]) ? K.props.input : K;
              Z && XO(Z.props) && ($ = !0);
            }),
          $
        );
      }),
      [D, P] = X.useState(() => {
        let $ = !1;
        return (
          i &&
            X.Children.forEach(i, (K) => {
              um(K, ["Input", "Select"]) &&
                (k0(K.props, !0) || k0(K.props.inputProps, !0)) &&
                ($ = !0);
            }),
          $
        );
      }),
      [U, O] = X.useState(!1);
    u && U && O(!1);
    const L = d !== void 0 && !u ? d : U;
    let H;
    const W = X.useMemo(
      () => ({
        adornedStart: A,
        setAdornedStart: R,
        color: s,
        disabled: u,
        error: c,
        filled: D,
        focused: L,
        fullWidth: m,
        hiddenLabel: g,
        size: S,
        onBlur: () => {
          O(!1);
        },
        onEmpty: () => {
          P(!1);
        },
        onFilled: () => {
          P(!0);
        },
        onFocus: () => {
          O(!0);
        },
        registerEffect: H,
        required: x,
        variant: _,
      }),
      [A, s, u, c, D, L, m, g, H, x, S, _]
    );
    return Q.jsx(iw.Provider, {
      value: W,
      children: Q.jsx(
        qN,
        ue({ as: a, ownerState: T, className: Zt(M.root, o), ref: t }, w, {
          children: i,
        })
      ),
    });
  }),
  tA = vk({
    createStyledComponent: jt("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (n, e) => e.root,
    }),
    useThemeProps: (n) => Yn({ props: n, name: "MuiStack" }),
  });
function KN(n) {
  return Fn("MuiFormHelperText", n);
}
const tE = Ln("MuiFormHelperText", [
  "root",
  "error",
  "disabled",
  "sizeSmall",
  "sizeMedium",
  "contained",
  "focused",
  "filled",
  "required",
]);
var nE;
const ZN = [
    "children",
    "className",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "margin",
    "required",
    "variant",
  ],
  JN = (n) => {
    const {
        classes: e,
        contained: t,
        size: r,
        disabled: i,
        error: o,
        filled: s,
        focused: a,
        required: u,
      } = n,
      c = {
        root: [
          "root",
          i && "disabled",
          o && "error",
          r && `size${an(r)}`,
          t && "contained",
          a && "focused",
          s && "filled",
          u && "required",
        ],
      };
    return Bn(c, KN, e);
  },
  QN = jt("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        t.size && e[`size${an(t.size)}`],
        t.contained && e.contained,
        t.filled && e.filled,
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      { color: (n.vars || n).palette.text.secondary },
      n.typography.caption,
      {
        textAlign: "left",
        marginTop: 3,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        [`&.${tE.disabled}`]: { color: (n.vars || n).palette.text.disabled },
        [`&.${tE.error}`]: { color: (n.vars || n).palette.error.main },
      },
      e.size === "small" && { marginTop: 4 },
      e.contained && { marginLeft: 14, marginRight: 14 }
    )
  ),
  eU = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiFormHelperText" }),
      { children: i, className: o, component: s = "p" } = r,
      a = It(r, ZN),
      u = zh(),
      c = Bh({
        props: r,
        muiFormControl: u,
        states: [
          "variant",
          "size",
          "disabled",
          "error",
          "filled",
          "focused",
          "required",
        ],
      }),
      d = ue({}, r, {
        component: s,
        contained: c.variant === "filled" || c.variant === "outlined",
        variant: c.variant,
        size: c.size,
        disabled: c.disabled,
        error: c.error,
        filled: c.filled,
        focused: c.focused,
        required: c.required,
      }),
      m = JN(d);
    return Q.jsx(
      QN,
      ue({ as: s, ownerState: d, className: Zt(m.root, o), ref: t }, a, {
        children:
          i === " "
            ? nE ||
              (nE = Q.jsx("span", { className: "notranslate", children: "" }))
            : i,
      })
    );
  });
function tU(n) {
  return Fn("MuiFormLabel", n);
}
const dm = Ln("MuiFormLabel", [
    "root",
    "colorSecondary",
    "focused",
    "disabled",
    "error",
    "filled",
    "required",
    "asterisk",
  ]),
  nU = [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "required",
  ],
  rU = (n) => {
    const {
        classes: e,
        color: t,
        focused: r,
        disabled: i,
        error: o,
        filled: s,
        required: a,
      } = n,
      u = {
        root: [
          "root",
          `color${an(t)}`,
          i && "disabled",
          o && "error",
          s && "filled",
          r && "focused",
          a && "required",
        ],
        asterisk: ["asterisk", o && "error"],
      };
    return Bn(u, tU, e);
  },
  iU = jt("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: ({ ownerState: n }, e) =>
      ue(
        {},
        e.root,
        n.color === "secondary" && e.colorSecondary,
        n.filled && e.filled
      ),
  })(({ theme: n, ownerState: e }) =>
    ue({ color: (n.vars || n).palette.text.secondary }, n.typography.body1, {
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      [`&.${dm.focused}`]: { color: (n.vars || n).palette[e.color].main },
      [`&.${dm.disabled}`]: { color: (n.vars || n).palette.text.disabled },
      [`&.${dm.error}`]: { color: (n.vars || n).palette.error.main },
    })
  ),
  oU = jt("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (n, e) => e.asterisk,
  })(({ theme: n }) => ({
    [`&.${dm.error}`]: { color: (n.vars || n).palette.error.main },
  })),
  sU = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiFormLabel" }),
      { children: i, className: o, component: s = "label" } = r,
      a = It(r, nU),
      u = zh(),
      c = Bh({
        props: r,
        muiFormControl: u,
        states: ["color", "required", "focused", "disabled", "error", "filled"],
      }),
      d = ue({}, r, {
        color: c.color || "primary",
        component: s,
        disabled: c.disabled,
        error: c.error,
        filled: c.filled,
        focused: c.focused,
        required: c.required,
      }),
      m = rU(d);
    return Q.jsxs(
      iU,
      ue({ as: s, ownerState: d, className: Zt(m.root, o), ref: t }, a, {
        children: [
          i,
          c.required &&
            Q.jsxs(oU, {
              ownerState: d,
              "aria-hidden": !0,
              className: m.asterisk,
              children: ["", "*"],
            }),
        ],
      })
    );
  }),
  aU = [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    "TransitionComponent",
  ];
function nS(n) {
  return `scale(${n}, ${n ** 2})`;
}
const lU = {
    entering: { opacity: 1, transform: nS(1) },
    entered: { opacity: 1, transform: "none" },
  },
  b_ =
    typeof navigator < "u" &&
    /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
    /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  nA = X.forwardRef(function (e, t) {
    const {
        addEndListener: r,
        appear: i = !0,
        children: o,
        easing: s,
        in: a,
        onEnter: u,
        onEntered: c,
        onEntering: d,
        onExit: m,
        onExited: g,
        onExiting: y,
        style: x,
        timeout: S = "auto",
        TransitionComponent: _ = tl,
      } = e,
      w = It(e, aU),
      T = WC(),
      M = X.useRef(),
      A = KC(),
      R = X.useRef(null),
      D = ri(R, o.ref, t),
      P = (Z) => (Y) => {
        if (Z) {
          const re = R.current;
          Y === void 0 ? Z(re) : Z(re, Y);
        }
      },
      U = P(d),
      O = P((Z, Y) => {
        QC(Z);
        const {
          duration: re,
          delay: G,
          easing: te,
        } = D0({ style: x, timeout: S, easing: s }, { mode: "enter" });
        let F;
        S === "auto"
          ? ((F = A.transitions.getAutoHeightDuration(Z.clientHeight)),
            (M.current = F))
          : (F = re),
          (Z.style.transition = [
            A.transitions.create("opacity", { duration: F, delay: G }),
            A.transitions.create("transform", {
              duration: b_ ? F : F * 0.666,
              delay: G,
              easing: te,
            }),
          ].join(",")),
          u && u(Z, Y);
      }),
      L = P(c),
      H = P(y),
      W = P((Z) => {
        const {
          duration: Y,
          delay: re,
          easing: G,
        } = D0({ style: x, timeout: S, easing: s }, { mode: "exit" });
        let te;
        S === "auto"
          ? ((te = A.transitions.getAutoHeightDuration(Z.clientHeight)),
            (M.current = te))
          : (te = Y),
          (Z.style.transition = [
            A.transitions.create("opacity", { duration: te, delay: re }),
            A.transitions.create("transform", {
              duration: b_ ? te : te * 0.666,
              delay: b_ ? re : re || te * 0.333,
              easing: G,
            }),
          ].join(",")),
          (Z.style.opacity = 0),
          (Z.style.transform = nS(0.75)),
          m && m(Z);
      }),
      $ = P(g),
      K = (Z) => {
        S === "auto" && T.start(M.current || 0, Z), r && r(R.current, Z);
      };
    return Q.jsx(
      _,
      ue(
        {
          appear: i,
          in: a,
          nodeRef: R,
          onEnter: O,
          onEntered: L,
          onEntering: U,
          onExit: W,
          onExited: $,
          onExiting: H,
          addEndListener: K,
          timeout: S === "auto" ? null : S,
        },
        w,
        {
          children: (Z, Y) =>
            X.cloneElement(
              o,
              ue(
                {
                  style: ue(
                    {
                      opacity: 0,
                      transform: nS(0.75),
                      visibility: Z === "exited" && !a ? "hidden" : void 0,
                    },
                    lU[Z],
                    x,
                    o.props.style
                  ),
                  ref: D,
                },
                Y
              )
            ),
        }
      )
    );
  });
nA.muiSupportAuto = !0;
const uU = [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type",
  ],
  cU = (n) => {
    const { classes: e, disableUnderline: t } = n,
      i = Bn({ root: ["root", !t && "underline"], input: ["input"] }, JO, e);
    return ue({}, e, i);
  },
  fU = jt(Hy, {
    shouldForwardProp: (n) => Os(n) || n === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [...By(n, e), !t.disableUnderline && e.underline];
    },
  })(({ theme: n, ownerState: e }) => {
    let r =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.42)"
        : "rgba(255, 255, 255, 0.7)";
    return (
      n.vars &&
        (r = `rgba(${n.vars.palette.common.onBackgroundChannel} / ${n.vars.opacity.inputUnderline})`),
      ue(
        { position: "relative" },
        e.formControl && { "label + &": { marginTop: 16 } },
        !e.disableUnderline && {
          "&::after": {
            borderBottom: `2px solid ${(n.vars || n).palette[e.color].main}`,
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: n.transitions.create("transform", {
              duration: n.transitions.duration.shorter,
              easing: n.transitions.easing.easeOut,
            }),
            pointerEvents: "none",
          },
          [`&.${kp.focused}:after`]: { transform: "scaleX(1) translateX(0)" },
          [`&.${kp.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (n.vars || n).palette.error.main,
            },
          },
          "&::before": {
            borderBottom: `1px solid ${r}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: n.transitions.create("border-bottom-color", {
              duration: n.transitions.duration.shorter,
            }),
            pointerEvents: "none",
          },
          [`&:hover:not(.${kp.disabled}, .${kp.error}):before`]: {
            borderBottom: `2px solid ${(n.vars || n).palette.text.primary}`,
            "@media (hover: none)": { borderBottom: `1px solid ${r}` },
          },
          [`&.${kp.disabled}:before`]: { borderBottomStyle: "dotted" },
        }
      )
    );
  }),
  dU = jt(Vy, { name: "MuiInput", slot: "Input", overridesResolver: zy })({}),
  aw = X.forwardRef(function (e, t) {
    var r, i, o, s;
    const a = Yn({ props: e, name: "MuiInput" }),
      {
        disableUnderline: u,
        components: c = {},
        componentsProps: d,
        fullWidth: m = !1,
        inputComponent: g = "input",
        multiline: y = !1,
        slotProps: x,
        slots: S = {},
        type: _ = "text",
      } = a,
      w = It(a, uU),
      T = cU(a),
      A = { root: { ownerState: { disableUnderline: u } } },
      R = x ?? d ? ni(x ?? d, A) : A,
      D = (r = (i = S.root) != null ? i : c.Root) != null ? r : fU,
      P = (o = (s = S.input) != null ? s : c.Input) != null ? o : dU;
    return Q.jsx(
      ow,
      ue(
        {
          slots: { root: D, input: P },
          slotProps: R,
          fullWidth: m,
          inputComponent: g,
          multiline: y,
          ref: t,
          type: _,
        },
        w,
        { classes: T }
      )
    );
  });
aw.muiName = "Input";
function hU(n) {
  return Fn("MuiInputLabel", n);
}
Ln("MuiInputLabel", [
  "root",
  "focused",
  "disabled",
  "error",
  "required",
  "asterisk",
  "formControl",
  "sizeSmall",
  "shrink",
  "animated",
  "standard",
  "filled",
  "outlined",
]);
const pU = ["disableAnimation", "margin", "shrink", "variant", "className"],
  mU = (n) => {
    const {
        classes: e,
        formControl: t,
        size: r,
        shrink: i,
        disableAnimation: o,
        variant: s,
        required: a,
      } = n,
      u = {
        root: [
          "root",
          t && "formControl",
          !o && "animated",
          i && "shrink",
          r && r !== "normal" && `size${an(r)}`,
          s,
        ],
        asterisk: [a && "asterisk"],
      },
      c = Bn(u, hU, e);
    return ue({}, e, c);
  },
  gU = jt(sU, {
    shouldForwardProp: (n) => Os(n) || n === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`& .${dm.asterisk}`]: e.asterisk },
        e.root,
        t.formControl && e.formControl,
        t.size === "small" && e.sizeSmall,
        t.shrink && e.shrink,
        !t.disableAnimation && e.animated,
        t.focused && e.focused,
        e[t.variant],
      ];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      {
        display: "block",
        transformOrigin: "top left",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        maxWidth: "100%",
      },
      e.formControl && {
        position: "absolute",
        left: 0,
        top: 0,
        transform: "translate(0, 20px) scale(1)",
      },
      e.size === "small" && { transform: "translate(0, 17px) scale(1)" },
      e.shrink && {
        transform: "translate(0, -1.5px) scale(0.75)",
        transformOrigin: "top left",
        maxWidth: "133%",
      },
      !e.disableAnimation && {
        transition: n.transitions.create(["color", "transform", "max-width"], {
          duration: n.transitions.duration.shorter,
          easing: n.transitions.easing.easeOut,
        }),
      },
      e.variant === "filled" &&
        ue(
          {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(12px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
          e.size === "small" && { transform: "translate(12px, 13px) scale(1)" },
          e.shrink &&
            ue(
              {
                userSelect: "none",
                pointerEvents: "auto",
                transform: "translate(12px, 7px) scale(0.75)",
                maxWidth: "calc(133% - 24px)",
              },
              e.size === "small" && {
                transform: "translate(12px, 4px) scale(0.75)",
              }
            )
        ),
      e.variant === "outlined" &&
        ue(
          {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(14px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
          e.size === "small" && { transform: "translate(14px, 9px) scale(1)" },
          e.shrink && {
            userSelect: "none",
            pointerEvents: "auto",
            maxWidth: "calc(133% - 32px)",
            transform: "translate(14px, -9px) scale(0.75)",
          }
        )
    )
  ),
  ch = X.forwardRef(function (e, t) {
    const r = Yn({ name: "MuiInputLabel", props: e }),
      { disableAnimation: i = !1, shrink: o, className: s } = r,
      a = It(r, pU),
      u = zh();
    let c = o;
    typeof c > "u" && u && (c = u.filled || u.focused || u.adornedStart);
    const d = Bh({
        props: r,
        muiFormControl: u,
        states: ["size", "variant", "required", "focused"],
      }),
      m = ue({}, r, {
        disableAnimation: i,
        formControl: u,
        shrink: c,
        size: d.size,
        variant: d.variant,
        required: d.required,
        focused: d.focused,
      }),
      g = mU(m);
    return Q.jsx(
      gU,
      ue(
        { "data-shrink": c, ownerState: m, ref: t, className: Zt(g.root, s) },
        a,
        { classes: g }
      )
    );
  }),
  Ul = X.createContext({});
function vU(n) {
  return Fn("MuiList", n);
}
Ln("MuiList", ["root", "padding", "dense", "subheader"]);
const yU = [
    "children",
    "className",
    "component",
    "dense",
    "disablePadding",
    "subheader",
  ],
  xU = (n) => {
    const { classes: e, disablePadding: t, dense: r, subheader: i } = n;
    return Bn(
      { root: ["root", !t && "padding", r && "dense", i && "subheader"] },
      vU,
      e
    );
  },
  _U = jt("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.root,
        !t.disablePadding && e.padding,
        t.dense && e.dense,
        t.subheader && e.subheader,
      ];
    },
  })(({ ownerState: n }) =>
    ue(
      { listStyle: "none", margin: 0, padding: 0, position: "relative" },
      !n.disablePadding && { paddingTop: 8, paddingBottom: 8 },
      n.subheader && { paddingTop: 0 }
    )
  ),
  rA = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiList" }),
      {
        children: i,
        className: o,
        component: s = "ul",
        dense: a = !1,
        disablePadding: u = !1,
        subheader: c,
      } = r,
      d = It(r, yU),
      m = X.useMemo(() => ({ dense: a }), [a]),
      g = ue({}, r, { component: s, dense: a, disablePadding: u }),
      y = xU(g);
    return Q.jsx(Ul.Provider, {
      value: m,
      children: Q.jsxs(
        _U,
        ue({ as: s, className: Zt(y.root, o), ref: t, ownerState: g }, d, {
          children: [c, i],
        })
      ),
    });
  });
function SU(n) {
  return Fn("MuiListItem", n);
}
const fh = Ln("MuiListItem", [
    "root",
    "container",
    "focusVisible",
    "dense",
    "alignItemsFlexStart",
    "disabled",
    "divider",
    "gutters",
    "padding",
    "button",
    "secondaryAction",
    "selected",
  ]),
  wU = Ln("MuiListItemButton", [
    "root",
    "focusVisible",
    "dense",
    "alignItemsFlexStart",
    "disabled",
    "divider",
    "gutters",
    "selected",
  ]);
function bU(n) {
  return Fn("MuiListItemSecondaryAction", n);
}
Ln("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const MU = ["className"],
  EU = (n) => {
    const { disableGutters: e, classes: t } = n;
    return Bn({ root: ["root", e && "disableGutters"] }, bU, t);
  },
  TU = jt("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, t.disableGutters && e.disableGutters];
    },
  })(({ ownerState: n }) =>
    ue(
      {
        position: "absolute",
        right: 16,
        top: "50%",
        transform: "translateY(-50%)",
      },
      n.disableGutters && { right: 0 }
    )
  ),
  iA = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiListItemSecondaryAction" }),
      { className: i } = r,
      o = It(r, MU),
      s = X.useContext(Ul),
      a = ue({}, r, { disableGutters: s.disableGutters }),
      u = EU(a);
    return Q.jsx(
      TU,
      ue({ className: Zt(u.root, i), ownerState: a, ref: t }, o)
    );
  });
iA.muiName = "ListItemSecondaryAction";
const CU = ["className"],
  AU = [
    "alignItems",
    "autoFocus",
    "button",
    "children",
    "className",
    "component",
    "components",
    "componentsProps",
    "ContainerComponent",
    "ContainerProps",
    "dense",
    "disabled",
    "disableGutters",
    "disablePadding",
    "divider",
    "focusVisibleClassName",
    "secondaryAction",
    "selected",
    "slotProps",
    "slots",
  ],
  RU = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.dense && e.dense,
      t.alignItems === "flex-start" && e.alignItemsFlexStart,
      t.divider && e.divider,
      !t.disableGutters && e.gutters,
      !t.disablePadding && e.padding,
      t.button && e.button,
      t.hasSecondaryAction && e.secondaryAction,
    ];
  },
  PU = (n) => {
    const {
      alignItems: e,
      button: t,
      classes: r,
      dense: i,
      disabled: o,
      disableGutters: s,
      disablePadding: a,
      divider: u,
      hasSecondaryAction: c,
      selected: d,
    } = n;
    return Bn(
      {
        root: [
          "root",
          i && "dense",
          !s && "gutters",
          !a && "padding",
          u && "divider",
          o && "disabled",
          t && "button",
          e === "flex-start" && "alignItemsFlexStart",
          c && "secondaryAction",
          d && "selected",
        ],
        container: ["container"],
      },
      SU,
      r
    );
  },
  IU = jt("div", { name: "MuiListItem", slot: "Root", overridesResolver: RU })(
    ({ theme: n, ownerState: e }) =>
      ue(
        {
          display: "flex",
          justifyContent: "flex-start",
          alignItems: "center",
          position: "relative",
          textDecoration: "none",
          width: "100%",
          boxSizing: "border-box",
          textAlign: "left",
        },
        !e.disablePadding &&
          ue(
            { paddingTop: 8, paddingBottom: 8 },
            e.dense && { paddingTop: 4, paddingBottom: 4 },
            !e.disableGutters && { paddingLeft: 16, paddingRight: 16 },
            !!e.secondaryAction && { paddingRight: 48 }
          ),
        !!e.secondaryAction && { [`& > .${wU.root}`]: { paddingRight: 48 } },
        {
          [`&.${fh.focusVisible}`]: {
            backgroundColor: (n.vars || n).palette.action.focus,
          },
          [`&.${fh.selected}`]: {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
              : Bi.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity
                ),
            [`&.${fh.focusVisible}`]: {
              backgroundColor: n.vars
                ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.focusOpacity}))`
                : Bi.alpha(
                    n.palette.primary.main,
                    n.palette.action.selectedOpacity +
                      n.palette.action.focusOpacity
                  ),
            },
          },
          [`&.${fh.disabled}`]: {
            opacity: (n.vars || n).palette.action.disabledOpacity,
          },
        },
        e.alignItems === "flex-start" && { alignItems: "flex-start" },
        e.divider && {
          borderBottom: `1px solid ${(n.vars || n).palette.divider}`,
          backgroundClip: "padding-box",
        },
        e.button && {
          transition: n.transitions.create("background-color", {
            duration: n.transitions.duration.shortest,
          }),
          "&:hover": {
            textDecoration: "none",
            backgroundColor: (n.vars || n).palette.action.hover,
            "@media (hover: none)": { backgroundColor: "transparent" },
          },
          [`&.${fh.selected}:hover`]: {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.hoverOpacity}))`
              : Bi.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity +
                    n.palette.action.hoverOpacity
                ),
            "@media (hover: none)": {
              backgroundColor: n.vars
                ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
                : Bi.alpha(
                    n.palette.primary.main,
                    n.palette.action.selectedOpacity
                  ),
            },
          },
        },
        e.hasSecondaryAction && { paddingRight: 48 }
      )
  ),
  LU = jt("li", {
    name: "MuiListItem",
    slot: "Container",
    overridesResolver: (n, e) => e.container,
  })({ position: "relative" }),
  Nc = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiListItem" }),
      {
        alignItems: i = "center",
        autoFocus: o = !1,
        button: s = !1,
        children: a,
        className: u,
        component: c,
        components: d = {},
        componentsProps: m = {},
        ContainerComponent: g = "li",
        ContainerProps: { className: y } = {},
        dense: x = !1,
        disabled: S = !1,
        disableGutters: _ = !1,
        disablePadding: w = !1,
        divider: T = !1,
        focusVisibleClassName: M,
        secondaryAction: A,
        selected: R = !1,
        slotProps: D = {},
        slots: P = {},
      } = r,
      U = It(r.ContainerProps, CU),
      O = It(r, AU),
      L = X.useContext(Ul),
      H = X.useMemo(
        () => ({ dense: x || L.dense || !1, alignItems: i, disableGutters: _ }),
        [i, L.dense, x, _]
      ),
      W = X.useRef(null);
    ha(() => {
      o && W.current && W.current.focus();
    }, [o]);
    const $ = X.Children.toArray(a),
      K = $.length && um($[$.length - 1], ["ListItemSecondaryAction"]),
      Z = ue({}, r, {
        alignItems: i,
        autoFocus: o,
        button: s,
        dense: H.dense,
        disabled: S,
        disableGutters: _,
        disablePadding: w,
        divider: T,
        hasSecondaryAction: K,
        selected: R,
      }),
      Y = PU(Z),
      re = ri(W, t),
      G = P.root || d.Root || IU,
      te = D.root || m.root || {},
      F = ue({ className: Zt(Y.root, te.className, u), disabled: S }, O);
    let V = c || "li";
    return (
      s &&
        ((F.component = c || "div"),
        (F.focusVisibleClassName = Zt(fh.focusVisible, M)),
        (V = rw)),
      K
        ? ((V = !F.component && !c ? "div" : V),
          g === "li" &&
            (V === "li"
              ? (V = "div")
              : F.component === "li" && (F.component = "div")),
          Q.jsx(Ul.Provider, {
            value: H,
            children: Q.jsxs(
              LU,
              ue(
                {
                  as: g,
                  className: Zt(Y.container, y),
                  ref: re,
                  ownerState: Z,
                },
                U,
                {
                  children: [
                    Q.jsx(
                      G,
                      ue(
                        {},
                        te,
                        !Ch(G) && {
                          as: V,
                          ownerState: ue({}, Z, te.ownerState),
                        },
                        F,
                        { children: $ }
                      )
                    ),
                    $.pop(),
                  ],
                }
              )
            ),
          }))
        : Q.jsx(Ul.Provider, {
            value: H,
            children: Q.jsxs(
              G,
              ue(
                {},
                te,
                { as: V, ref: re },
                !Ch(G) && { ownerState: ue({}, Z, te.ownerState) },
                F,
                { children: [$, A && Q.jsx(iA, { children: A })] }
              )
            ),
          })
    );
  });
function DU(n) {
  return Fn("MuiListItemIcon", n);
}
const rE = Ln("MuiListItemIcon", ["root", "alignItemsFlexStart"]),
  kU = ["className"],
  OU = (n) => {
    const { alignItems: e, classes: t } = n;
    return Bn(
      { root: ["root", e === "flex-start" && "alignItemsFlexStart"] },
      DU,
      t
    );
  },
  NU = jt("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [e.root, t.alignItems === "flex-start" && e.alignItemsFlexStart];
    },
  })(({ theme: n, ownerState: e }) =>
    ue(
      {
        minWidth: 56,
        color: (n.vars || n).palette.action.active,
        flexShrink: 0,
        display: "inline-flex",
      },
      e.alignItems === "flex-start" && { marginTop: 8 }
    )
  ),
  Uc = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiListItemIcon" }),
      { className: i } = r,
      o = It(r, kU),
      s = X.useContext(Ul),
      a = ue({}, r, { alignItems: s.alignItems }),
      u = OU(a);
    return Q.jsx(
      NU,
      ue({ className: Zt(u.root, i), ownerState: a, ref: t }, o)
    );
  });
function UU(n) {
  return Fn("MuiListItemText", n);
}
const O0 = Ln("MuiListItemText", [
    "root",
    "multiline",
    "dense",
    "inset",
    "primary",
    "secondary",
  ]),
  FU = [
    "children",
    "className",
    "disableTypography",
    "inset",
    "primary",
    "primaryTypographyProps",
    "secondary",
    "secondaryTypographyProps",
  ],
  BU = (n) => {
    const { classes: e, inset: t, primary: r, secondary: i, dense: o } = n;
    return Bn(
      {
        root: ["root", t && "inset", o && "dense", r && i && "multiline"],
        primary: ["primary"],
        secondary: ["secondary"],
      },
      UU,
      e
    );
  },
  zU = jt("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`& .${O0.primary}`]: e.primary },
        { [`& .${O0.secondary}`]: e.secondary },
        e.root,
        t.inset && e.inset,
        t.primary && t.secondary && e.multiline,
        t.dense && e.dense,
      ];
    },
  })(({ ownerState: n }) =>
    ue(
      { flex: "1 1 auto", minWidth: 0, marginTop: 4, marginBottom: 4 },
      n.primary && n.secondary && { marginTop: 6, marginBottom: 6 },
      n.inset && { paddingLeft: 56 }
    )
  ),
  Fc = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiListItemText" }),
      {
        children: i,
        className: o,
        disableTypography: s = !1,
        inset: a = !1,
        primary: u,
        primaryTypographyProps: c,
        secondary: d,
        secondaryTypographyProps: m,
      } = r,
      g = It(r, FU),
      { dense: y } = X.useContext(Ul);
    let x = u ?? i,
      S = d;
    const _ = ue({}, r, {
        disableTypography: s,
        inset: a,
        primary: !!x,
        secondary: !!S,
        dense: y,
      }),
      w = BU(_);
    return (
      x != null &&
        x.type !== vn &&
        !s &&
        (x = Q.jsx(
          vn,
          ue(
            {
              variant: y ? "body2" : "body1",
              className: w.primary,
              component: c != null && c.variant ? void 0 : "span",
              display: "block",
            },
            c,
            { children: x }
          )
        )),
      S != null &&
        S.type !== vn &&
        !s &&
        (S = Q.jsx(
          vn,
          ue(
            {
              variant: "body2",
              className: w.secondary,
              color: "text.secondary",
              display: "block",
            },
            m,
            { children: S }
          )
        )),
      Q.jsxs(
        zU,
        ue({ className: Zt(w.root, o), ownerState: _, ref: t }, g, {
          children: [x, S],
        })
      )
    );
  }),
  HU = [
    "actions",
    "autoFocus",
    "autoFocusItem",
    "children",
    "className",
    "disabledItemsFocusable",
    "disableListWrap",
    "onKeyDown",
    "variant",
  ];
function M_(n, e, t) {
  return n === e
    ? n.firstChild
    : e && e.nextElementSibling
    ? e.nextElementSibling
    : t
    ? null
    : n.firstChild;
}
function iE(n, e, t) {
  return n === e
    ? t
      ? n.firstChild
      : n.lastChild
    : e && e.previousElementSibling
    ? e.previousElementSibling
    : t
    ? null
    : n.lastChild;
}
function oA(n, e) {
  if (e === void 0) return !0;
  let t = n.innerText;
  return (
    t === void 0 && (t = n.textContent),
    (t = t.trim().toLowerCase()),
    t.length === 0
      ? !1
      : e.repeating
      ? t[0] === e.keys[0]
      : t.indexOf(e.keys.join("")) === 0
  );
}
function Op(n, e, t, r, i, o) {
  let s = !1,
    a = i(n, e, e ? t : !1);
  for (; a; ) {
    if (a === n.firstChild) {
      if (s) return !1;
      s = !0;
    }
    const u = r ? !1 : a.disabled || a.getAttribute("aria-disabled") === "true";
    if (!a.hasAttribute("tabindex") || !oA(a, o) || u) a = i(n, a, t);
    else return a.focus(), !0;
  }
  return !1;
}
const VU = X.forwardRef(function (e, t) {
  const {
      actions: r,
      autoFocus: i = !1,
      autoFocusItem: o = !1,
      children: s,
      className: a,
      disabledItemsFocusable: u = !1,
      disableListWrap: c = !1,
      onKeyDown: d,
      variant: m = "selectedMenu",
    } = e,
    g = It(e, HU),
    y = X.useRef(null),
    x = X.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null,
    });
  ha(() => {
    i && y.current.focus();
  }, [i]),
    X.useImperativeHandle(
      r,
      () => ({
        adjustStyleForScrollbar: (M, { direction: A }) => {
          const R = !y.current.style.width;
          if (M.clientHeight < y.current.clientHeight && R) {
            const D = `${GC(zo(M))}px`;
            (y.current.style[A === "rtl" ? "paddingLeft" : "paddingRight"] = D),
              (y.current.style.width = `calc(100% + ${D})`);
          }
          return y.current;
        },
      }),
      []
    );
  const S = (M) => {
      const A = y.current,
        R = M.key,
        D = zo(A).activeElement;
      if (R === "ArrowDown") M.preventDefault(), Op(A, D, c, u, M_);
      else if (R === "ArrowUp") M.preventDefault(), Op(A, D, c, u, iE);
      else if (R === "Home") M.preventDefault(), Op(A, null, c, u, M_);
      else if (R === "End") M.preventDefault(), Op(A, null, c, u, iE);
      else if (R.length === 1) {
        const P = x.current,
          U = R.toLowerCase(),
          O = performance.now();
        P.keys.length > 0 &&
          (O - P.lastTime > 500
            ? ((P.keys = []), (P.repeating = !0), (P.previousKeyMatched = !0))
            : P.repeating && U !== P.keys[0] && (P.repeating = !1)),
          (P.lastTime = O),
          P.keys.push(U);
        const L = D && !P.repeating && oA(D, P);
        P.previousKeyMatched && (L || Op(A, D, !1, u, M_, P))
          ? M.preventDefault()
          : (P.previousKeyMatched = !1);
      }
      d && d(M);
    },
    _ = ri(y, t);
  let w = -1;
  X.Children.forEach(s, (M, A) => {
    if (!X.isValidElement(M)) {
      w === A && ((w += 1), w >= s.length && (w = -1));
      return;
    }
    M.props.disabled ||
      (((m === "selectedMenu" && M.props.selected) || w === -1) && (w = A)),
      w === A &&
        (M.props.disabled ||
          M.props.muiSkipListHighlight ||
          M.type.muiSkipListHighlight) &&
        ((w += 1), w >= s.length && (w = -1));
  });
  const T = X.Children.map(s, (M, A) => {
    if (A === w) {
      const R = {};
      return (
        o && (R.autoFocus = !0),
        M.props.tabIndex === void 0 && m === "selectedMenu" && (R.tabIndex = 0),
        X.cloneElement(M, R)
      );
    }
    return M;
  });
  return Q.jsx(
    rA,
    ue(
      {
        role: "menu",
        ref: _,
        className: a,
        onKeyDown: S,
        tabIndex: i ? 0 : -1,
      },
      g,
      { children: T }
    )
  );
});
function WU(n) {
  return Fn("MuiPopover", n);
}
Ln("MuiPopover", ["root", "paper"]);
const GU = ["onEntering"],
  jU = [
    "action",
    "anchorEl",
    "anchorOrigin",
    "anchorPosition",
    "anchorReference",
    "children",
    "className",
    "container",
    "elevation",
    "marginThreshold",
    "open",
    "PaperProps",
    "slots",
    "slotProps",
    "transformOrigin",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps",
    "disableScrollLock",
  ],
  $U = ["slotProps"];
function oE(n, e) {
  let t = 0;
  return (
    typeof e == "number"
      ? (t = e)
      : e === "center"
      ? (t = n.height / 2)
      : e === "bottom" && (t = n.height),
    t
  );
}
function sE(n, e) {
  let t = 0;
  return (
    typeof e == "number"
      ? (t = e)
      : e === "center"
      ? (t = n.width / 2)
      : e === "right" && (t = n.width),
    t
  );
}
function aE(n) {
  return [n.horizontal, n.vertical]
    .map((e) => (typeof e == "number" ? `${e}px` : e))
    .join(" ");
}
function E_(n) {
  return typeof n == "function" ? n() : n;
}
const XU = (n) => {
    const { classes: e } = n;
    return Bn({ root: ["root"], paper: ["paper"] }, WU, e);
  },
  YU = jt(HN, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  sA = jt(lf, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (n, e) => e.paper,
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0,
  }),
  qU = X.forwardRef(function (e, t) {
    var r, i, o;
    const s = Yn({ props: e, name: "MuiPopover" }),
      {
        action: a,
        anchorEl: u,
        anchorOrigin: c = { vertical: "top", horizontal: "left" },
        anchorPosition: d,
        anchorReference: m = "anchorEl",
        children: g,
        className: y,
        container: x,
        elevation: S = 8,
        marginThreshold: _ = 16,
        open: w,
        PaperProps: T = {},
        slots: M,
        slotProps: A,
        transformOrigin: R = { vertical: "top", horizontal: "left" },
        TransitionComponent: D = nA,
        transitionDuration: P = "auto",
        TransitionProps: { onEntering: U } = {},
        disableScrollLock: O = !1,
      } = s,
      L = It(s.TransitionProps, GU),
      H = It(s, jU),
      W = (r = A == null ? void 0 : A.paper) != null ? r : T,
      $ = X.useRef(),
      K = ri($, W.ref),
      Z = ue({}, s, {
        anchorOrigin: c,
        anchorReference: m,
        elevation: S,
        marginThreshold: _,
        externalPaperSlotProps: W,
        transformOrigin: R,
        TransitionComponent: D,
        transitionDuration: P,
        TransitionProps: L,
      }),
      Y = XU(Z),
      re = X.useCallback(() => {
        if (m === "anchorPosition") return d;
        const we = E_(u),
          Oe = (
            we && we.nodeType === 1 ? we : zo($.current).body
          ).getBoundingClientRect();
        return {
          top: Oe.top + oE(Oe, c.vertical),
          left: Oe.left + sE(Oe, c.horizontal),
        };
      }, [u, c.horizontal, c.vertical, d, m]),
      G = X.useCallback(
        (we) => ({
          vertical: oE(we, R.vertical),
          horizontal: sE(we, R.horizontal),
        }),
        [R.horizontal, R.vertical]
      ),
      te = X.useCallback(
        (we) => {
          const Ae = { width: we.offsetWidth, height: we.offsetHeight },
            Oe = G(Ae);
          if (m === "none")
            return { top: null, left: null, transformOrigin: aE(Oe) };
          const Ie = re();
          let rt = Ie.top - Oe.vertical,
            De = Ie.left - Oe.horizontal;
          const Xe = rt + Ae.height,
            ee = De + Ae.width,
            B = qu(E_(u)),
            ve = B.innerHeight - _,
            Se = B.innerWidth - _;
          if (_ !== null && rt < _) {
            const _e = rt - _;
            (rt -= _e), (Oe.vertical += _e);
          } else if (_ !== null && Xe > ve) {
            const _e = Xe - ve;
            (rt -= _e), (Oe.vertical += _e);
          }
          if (_ !== null && De < _) {
            const _e = De - _;
            (De -= _e), (Oe.horizontal += _e);
          } else if (ee > Se) {
            const _e = ee - Se;
            (De -= _e), (Oe.horizontal += _e);
          }
          return {
            top: `${Math.round(rt)}px`,
            left: `${Math.round(De)}px`,
            transformOrigin: aE(Oe),
          };
        },
        [u, m, re, G, _]
      ),
      [F, V] = X.useState(w),
      ne = X.useCallback(() => {
        const we = $.current;
        if (!we) return;
        const Ae = te(we);
        Ae.top !== null && (we.style.top = Ae.top),
          Ae.left !== null && (we.style.left = Ae.left),
          (we.style.transformOrigin = Ae.transformOrigin),
          V(!0);
      }, [te]);
    X.useEffect(
      () => (
        O && window.addEventListener("scroll", ne),
        () => window.removeEventListener("scroll", ne)
      ),
      [u, O, ne]
    );
    const ae = (we, Ae) => {
        U && U(we, Ae), ne();
      },
      J = () => {
        V(!1);
      };
    X.useEffect(() => {
      w && ne();
    }),
      X.useImperativeHandle(
        a,
        () =>
          w
            ? {
                updatePosition: () => {
                  ne();
                },
              }
            : null,
        [w, ne]
      ),
      X.useEffect(() => {
        if (!w) return;
        const we = KS(() => {
            ne();
          }),
          Ae = qu(u);
        return (
          Ae.addEventListener("resize", we),
          () => {
            we.clear(), Ae.removeEventListener("resize", we);
          }
        );
      }, [u, w, ne]);
    let se = P;
    P === "auto" && !D.muiSupportAuto && (se = void 0);
    const de = x || (u ? zo(E_(u)).body : void 0),
      le = (i = M == null ? void 0 : M.root) != null ? i : YU,
      fe = (o = M == null ? void 0 : M.paper) != null ? o : sA,
      Me = Ah({
        elementType: fe,
        externalSlotProps: ue({}, W, {
          style: F ? W.style : ue({}, W.style, { opacity: 0 }),
        }),
        additionalProps: { elevation: S, ref: K },
        ownerState: Z,
        className: Zt(Y.paper, W == null ? void 0 : W.className),
      }),
      ge = Ah({
        elementType: le,
        externalSlotProps: (A == null ? void 0 : A.root) || {},
        externalForwardedProps: H,
        additionalProps: {
          ref: t,
          slotProps: { backdrop: { invisible: !0 } },
          container: de,
          open: w,
        },
        ownerState: Z,
        className: Zt(Y.root, y),
      }),
      { slotProps: xe } = ge,
      j = It(ge, $U);
    return Q.jsx(
      le,
      ue({}, j, !Ch(le) && { slotProps: xe, disableScrollLock: O }, {
        children: Q.jsx(
          D,
          ue(
            { appear: !0, in: w, onEntering: ae, onExited: J, timeout: se },
            L,
            { children: Q.jsx(fe, ue({}, Me, { children: g })) }
          )
        ),
      })
    );
  });
function KU(n) {
  return Fn("MuiMenu", n);
}
Ln("MuiMenu", ["root", "paper", "list"]);
const ZU = ["onEntering"],
  JU = [
    "autoFocus",
    "children",
    "className",
    "disableAutoFocusItem",
    "MenuListProps",
    "onClose",
    "open",
    "PaperProps",
    "PopoverClasses",
    "transitionDuration",
    "TransitionProps",
    "variant",
    "slots",
    "slotProps",
  ],
  QU = { vertical: "top", horizontal: "right" },
  eF = { vertical: "top", horizontal: "left" },
  tF = (n) => {
    const { classes: e } = n;
    return Bn({ root: ["root"], paper: ["paper"], list: ["list"] }, KU, e);
  },
  nF = jt(qU, {
    shouldForwardProp: (n) => Os(n) || n === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  rF = jt(sA, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (n, e) => e.paper,
  })({ maxHeight: "calc(100% - 96px)", WebkitOverflowScrolling: "touch" }),
  iF = jt(VU, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (n, e) => e.list,
  })({ outline: 0 }),
  oF = X.forwardRef(function (e, t) {
    var r, i;
    const o = Yn({ props: e, name: "MuiMenu" }),
      {
        autoFocus: s = !0,
        children: a,
        className: u,
        disableAutoFocusItem: c = !1,
        MenuListProps: d = {},
        onClose: m,
        open: g,
        PaperProps: y = {},
        PopoverClasses: x,
        transitionDuration: S = "auto",
        TransitionProps: { onEntering: _ } = {},
        variant: w = "selectedMenu",
        slots: T = {},
        slotProps: M = {},
      } = o,
      A = It(o.TransitionProps, ZU),
      R = It(o, JU),
      D = ek(),
      P = ue({}, o, {
        autoFocus: s,
        disableAutoFocusItem: c,
        MenuListProps: d,
        onEntering: _,
        PaperProps: y,
        transitionDuration: S,
        TransitionProps: A,
        variant: w,
      }),
      U = tF(P),
      O = s && !c && g,
      L = X.useRef(null),
      H = (G, te) => {
        L.current &&
          L.current.adjustStyleForScrollbar(G, {
            direction: D ? "rtl" : "ltr",
          }),
          _ && _(G, te);
      },
      W = (G) => {
        G.key === "Tab" && (G.preventDefault(), m && m(G, "tabKeyDown"));
      };
    let $ = -1;
    X.Children.map(a, (G, te) => {
      X.isValidElement(G) &&
        (G.props.disabled ||
          (((w === "selectedMenu" && G.props.selected) || $ === -1) &&
            ($ = te)));
    });
    const K = (r = T.paper) != null ? r : rF,
      Z = (i = M.paper) != null ? i : y,
      Y = Ah({
        elementType: T.root,
        externalSlotProps: M.root,
        ownerState: P,
        className: [U.root, u],
      }),
      re = Ah({
        elementType: K,
        externalSlotProps: Z,
        ownerState: P,
        className: U.paper,
      });
    return Q.jsx(
      nF,
      ue(
        {
          onClose: m,
          anchorOrigin: {
            vertical: "bottom",
            horizontal: D ? "right" : "left",
          },
          transformOrigin: D ? QU : eF,
          slots: { paper: K, root: T.root },
          slotProps: { root: Y, paper: re },
          open: g,
          ref: t,
          transitionDuration: S,
          TransitionProps: ue({ onEntering: H }, A),
          ownerState: P,
        },
        R,
        {
          classes: x,
          children: Q.jsx(
            iF,
            ue(
              {
                onKeyDown: W,
                actions: L,
                autoFocus: s && ($ === -1 || c),
                autoFocusItem: O,
                variant: w,
              },
              d,
              { className: Zt(U.list, d.className), children: a }
            )
          ),
        }
      )
    );
  });
function sF(n) {
  return Fn("MuiMenuItem", n);
}
const Np = Ln("MuiMenuItem", [
    "root",
    "focusVisible",
    "dense",
    "disabled",
    "divider",
    "gutters",
    "selected",
  ]),
  aF = [
    "autoFocus",
    "component",
    "dense",
    "divider",
    "disableGutters",
    "focusVisibleClassName",
    "role",
    "tabIndex",
    "className",
  ],
  lF = (n, e) => {
    const { ownerState: t } = n;
    return [
      e.root,
      t.dense && e.dense,
      t.divider && e.divider,
      !t.disableGutters && e.gutters,
    ];
  },
  uF = (n) => {
    const {
        disabled: e,
        dense: t,
        divider: r,
        disableGutters: i,
        selected: o,
        classes: s,
      } = n,
      u = Bn(
        {
          root: [
            "root",
            t && "dense",
            e && "disabled",
            !i && "gutters",
            r && "divider",
            o && "selected",
          ],
        },
        sF,
        s
      );
    return ue({}, s, u);
  },
  cF = jt(rw, {
    shouldForwardProp: (n) => Os(n) || n === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: lF,
  })(({ theme: n, ownerState: e }) =>
    ue(
      {},
      n.typography.body1,
      {
        display: "flex",
        justifyContent: "flex-start",
        alignItems: "center",
        position: "relative",
        textDecoration: "none",
        minHeight: 48,
        paddingTop: 6,
        paddingBottom: 6,
        boxSizing: "border-box",
        whiteSpace: "nowrap",
      },
      !e.disableGutters && { paddingLeft: 16, paddingRight: 16 },
      e.divider && {
        borderBottom: `1px solid ${(n.vars || n).palette.divider}`,
        backgroundClip: "padding-box",
      },
      {
        "&:hover": {
          textDecoration: "none",
          backgroundColor: (n.vars || n).palette.action.hover,
          "@media (hover: none)": { backgroundColor: "transparent" },
        },
        [`&.${Np.selected}`]: {
          backgroundColor: n.vars
            ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
            : Bi.alpha(
                n.palette.primary.main,
                n.palette.action.selectedOpacity
              ),
          [`&.${Np.focusVisible}`]: {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.focusOpacity}))`
              : Bi.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity +
                    n.palette.action.focusOpacity
                ),
          },
        },
        [`&.${Np.selected}:hover`]: {
          backgroundColor: n.vars
            ? `rgba(${n.vars.palette.primary.mainChannel} / calc(${n.vars.palette.action.selectedOpacity} + ${n.vars.palette.action.hoverOpacity}))`
            : Bi.alpha(
                n.palette.primary.main,
                n.palette.action.selectedOpacity + n.palette.action.hoverOpacity
              ),
          "@media (hover: none)": {
            backgroundColor: n.vars
              ? `rgba(${n.vars.palette.primary.mainChannel} / ${n.vars.palette.action.selectedOpacity})`
              : Bi.alpha(
                  n.palette.primary.main,
                  n.palette.action.selectedOpacity
                ),
          },
        },
        [`&.${Np.focusVisible}`]: {
          backgroundColor: (n.vars || n).palette.action.focus,
        },
        [`&.${Np.disabled}`]: {
          opacity: (n.vars || n).palette.action.disabledOpacity,
        },
        [`& + .${eE.root}`]: {
          marginTop: n.spacing(1),
          marginBottom: n.spacing(1),
        },
        [`& + .${eE.inset}`]: { marginLeft: 52 },
        [`& .${O0.root}`]: { marginTop: 0, marginBottom: 0 },
        [`& .${O0.inset}`]: { paddingLeft: 36 },
        [`& .${rE.root}`]: { minWidth: 36 },
      },
      !e.dense && { [n.breakpoints.up("sm")]: { minHeight: "auto" } },
      e.dense &&
        ue(
          { minHeight: 32, paddingTop: 4, paddingBottom: 4 },
          n.typography.body2,
          { [`& .${rE.root} svg`]: { fontSize: "1.25rem" } }
        )
    )
  ),
  Up = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiMenuItem" }),
      {
        autoFocus: i = !1,
        component: o = "li",
        dense: s = !1,
        divider: a = !1,
        disableGutters: u = !1,
        focusVisibleClassName: c,
        role: d = "menuitem",
        tabIndex: m,
        className: g,
      } = r,
      y = It(r, aF),
      x = X.useContext(Ul),
      S = X.useMemo(
        () => ({ dense: s || x.dense || !1, disableGutters: u }),
        [x.dense, s, u]
      ),
      _ = X.useRef(null);
    ha(() => {
      i && _.current && _.current.focus();
    }, [i]);
    const w = ue({}, r, { dense: S.dense, divider: a, disableGutters: u }),
      T = uF(r),
      M = ri(_, t);
    let A;
    return (
      r.disabled || (A = m !== void 0 ? m : -1),
      Q.jsx(Ul.Provider, {
        value: S,
        children: Q.jsx(
          cF,
          ue(
            {
              ref: M,
              role: d,
              tabIndex: A,
              component: o,
              focusVisibleClassName: Zt(T.focusVisible, c),
              className: Zt(T.root, g),
            },
            y,
            { ownerState: w, classes: T }
          )
        ),
      })
    );
  });
function fF(n) {
  return Fn("MuiNativeSelect", n);
}
const lw = Ln("MuiNativeSelect", [
    "root",
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
  ]),
  dF = [
    "className",
    "disabled",
    "error",
    "IconComponent",
    "inputRef",
    "variant",
  ],
  hF = (n) => {
    const {
        classes: e,
        variant: t,
        disabled: r,
        multiple: i,
        open: o,
        error: s,
      } = n,
      a = {
        select: ["select", t, r && "disabled", i && "multiple", s && "error"],
        icon: ["icon", `icon${an(t)}`, o && "iconOpen", r && "disabled"],
      };
    return Bn(a, fF, e);
  },
  aA = ({ ownerState: n, theme: e }) =>
    ue(
      {
        MozAppearance: "none",
        WebkitAppearance: "none",
        userSelect: "none",
        borderRadius: 0,
        cursor: "pointer",
        "&:focus": ue(
          {},
          e.vars
            ? {
                backgroundColor: `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.05)`,
              }
            : {
                backgroundColor:
                  e.palette.mode === "light"
                    ? "rgba(0, 0, 0, 0.05)"
                    : "rgba(255, 255, 255, 0.05)",
              },
          { borderRadius: 0 }
        ),
        "&::-ms-expand": { display: "none" },
        [`&.${lw.disabled}`]: { cursor: "default" },
        "&[multiple]": { height: "auto" },
        "&:not([multiple]) option, &:not([multiple]) optgroup": {
          backgroundColor: (e.vars || e).palette.background.paper,
        },
        "&&&": { paddingRight: 24, minWidth: 16 },
      },
      n.variant === "filled" && { "&&&": { paddingRight: 32 } },
      n.variant === "outlined" && {
        borderRadius: (e.vars || e).shape.borderRadius,
        "&:focus": { borderRadius: (e.vars || e).shape.borderRadius },
        "&&&": { paddingRight: 32 },
      }
    ),
  pF = jt("select", {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: Os,
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.select,
        e[t.variant],
        t.error && e.error,
        { [`&.${lw.multiple}`]: e.multiple },
      ];
    },
  })(aA),
  lA = ({ ownerState: n, theme: e }) =>
    ue(
      {
        position: "absolute",
        right: 0,
        top: "calc(50% - .5em)",
        pointerEvents: "none",
        color: (e.vars || e).palette.action.active,
        [`&.${lw.disabled}`]: { color: (e.vars || e).palette.action.disabled },
      },
      n.open && { transform: "rotate(180deg)" },
      n.variant === "filled" && { right: 7 },
      n.variant === "outlined" && { right: 7 }
    ),
  mF = jt("svg", {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.icon,
        t.variant && e[`icon${an(t.variant)}`],
        t.open && e.iconOpen,
      ];
    },
  })(lA),
  gF = X.forwardRef(function (e, t) {
    const {
        className: r,
        disabled: i,
        error: o,
        IconComponent: s,
        inputRef: a,
        variant: u = "standard",
      } = e,
      c = It(e, dF),
      d = ue({}, e, { disabled: i, variant: u, error: o }),
      m = hF(d);
    return Q.jsxs(X.Fragment, {
      children: [
        Q.jsx(
          pF,
          ue(
            {
              ownerState: d,
              className: Zt(m.select, r),
              disabled: i,
              ref: a || t,
            },
            c
          )
        ),
        e.multiple
          ? null
          : Q.jsx(mF, { as: s, ownerState: d, className: m.icon }),
      ],
    });
  });
var lE;
const vF = ["children", "classes", "className", "label", "notched"],
  yF = jt("fieldset", { shouldForwardProp: Os })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
  }),
  xF = jt("legend", { shouldForwardProp: Os })(({ ownerState: n, theme: e }) =>
    ue(
      { float: "unset", width: "auto", overflow: "hidden" },
      !n.withLabel && {
        padding: 0,
        lineHeight: "11px",
        transition: e.transitions.create("width", {
          duration: 150,
          easing: e.transitions.easing.easeOut,
        }),
      },
      n.withLabel &&
        ue(
          {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: 0.01,
            transition: e.transitions.create("max-width", {
              duration: 50,
              easing: e.transitions.easing.easeOut,
            }),
            whiteSpace: "nowrap",
            "& > span": {
              paddingLeft: 5,
              paddingRight: 5,
              display: "inline-block",
              opacity: 0,
              visibility: "visible",
            },
          },
          n.notched && {
            maxWidth: "100%",
            transition: e.transitions.create("max-width", {
              duration: 100,
              easing: e.transitions.easing.easeOut,
              delay: 50,
            }),
          }
        )
    )
  );
function _F(n) {
  const { className: e, label: t, notched: r } = n,
    i = It(n, vF),
    o = t != null && t !== "",
    s = ue({}, n, { notched: r, withLabel: o });
  return Q.jsx(
    yF,
    ue({ "aria-hidden": !0, className: e, ownerState: s }, i, {
      children: Q.jsx(xF, {
        ownerState: s,
        children: o
          ? Q.jsx("span", { children: t })
          : lE ||
            (lE = Q.jsx("span", { className: "notranslate", children: "" })),
      }),
    })
  );
}
const SF = [
    "components",
    "fullWidth",
    "inputComponent",
    "label",
    "multiline",
    "notched",
    "slots",
    "type",
  ],
  wF = (n) => {
    const { classes: e } = n,
      r = Bn(
        {
          root: ["root"],
          notchedOutline: ["notchedOutline"],
          input: ["input"],
        },
        QO,
        e
      );
    return ue({}, e, r);
  },
  bF = jt(Hy, {
    shouldForwardProp: (n) => Os(n) || n === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: By,
  })(({ theme: n, ownerState: e }) => {
    const t =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.23)"
        : "rgba(255, 255, 255, 0.23)";
    return ue(
      {
        position: "relative",
        borderRadius: (n.vars || n).shape.borderRadius,
        [`&:hover .${Lu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.text.primary,
        },
        "@media (hover: none)": {
          [`&:hover .${Lu.notchedOutline}`]: {
            borderColor: n.vars
              ? `rgba(${n.vars.palette.common.onBackgroundChannel} / 0.23)`
              : t,
          },
        },
        [`&.${Lu.focused} .${Lu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette[e.color].main,
          borderWidth: 2,
        },
        [`&.${Lu.error} .${Lu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.error.main,
        },
        [`&.${Lu.disabled} .${Lu.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.action.disabled,
        },
      },
      e.startAdornment && { paddingLeft: 14 },
      e.endAdornment && { paddingRight: 14 },
      e.multiline &&
        ue(
          { padding: "16.5px 14px" },
          e.size === "small" && { padding: "8.5px 14px" }
        )
    );
  }),
  MF = jt(_F, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (n, e) => e.notchedOutline,
  })(({ theme: n }) => {
    const e =
      n.palette.mode === "light"
        ? "rgba(0, 0, 0, 0.23)"
        : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: n.vars
        ? `rgba(${n.vars.palette.common.onBackgroundChannel} / 0.23)`
        : e,
    };
  }),
  EF = jt(Vy, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: zy,
  })(({ theme: n, ownerState: e }) =>
    ue(
      { padding: "16.5px 14px" },
      !n.vars && {
        "&:-webkit-autofill": {
          WebkitBoxShadow:
            n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
          WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
          caretColor: n.palette.mode === "light" ? null : "#fff",
          borderRadius: "inherit",
        },
      },
      n.vars && {
        "&:-webkit-autofill": { borderRadius: "inherit" },
        [n.getColorSchemeSelector("dark")]: {
          "&:-webkit-autofill": {
            WebkitBoxShadow: "0 0 0 100px #266798 inset",
            WebkitTextFillColor: "#fff",
            caretColor: "#fff",
          },
        },
      },
      e.size === "small" && { padding: "8.5px 14px" },
      e.multiline && { padding: 0 },
      e.startAdornment && { paddingLeft: 0 },
      e.endAdornment && { paddingRight: 0 }
    )
  ),
  uw = X.forwardRef(function (e, t) {
    var r, i, o, s, a;
    const u = Yn({ props: e, name: "MuiOutlinedInput" }),
      {
        components: c = {},
        fullWidth: d = !1,
        inputComponent: m = "input",
        label: g,
        multiline: y = !1,
        notched: x,
        slots: S = {},
        type: _ = "text",
      } = u,
      w = It(u, SF),
      T = wF(u),
      M = zh(),
      A = Bh({
        props: u,
        muiFormControl: M,
        states: [
          "color",
          "disabled",
          "error",
          "focused",
          "hiddenLabel",
          "size",
          "required",
        ],
      }),
      R = ue({}, u, {
        color: A.color || "primary",
        disabled: A.disabled,
        error: A.error,
        focused: A.focused,
        formControl: M,
        fullWidth: d,
        hiddenLabel: A.hiddenLabel,
        multiline: y,
        size: A.size,
        type: _,
      }),
      D = (r = (i = S.root) != null ? i : c.Root) != null ? r : bF,
      P = (o = (s = S.input) != null ? s : c.Input) != null ? o : EF;
    return Q.jsx(
      ow,
      ue(
        {
          slots: { root: D, input: P },
          renderSuffix: (U) =>
            Q.jsx(MF, {
              ownerState: R,
              className: T.notchedOutline,
              label:
                g != null && g !== "" && A.required
                  ? a || (a = Q.jsxs(X.Fragment, { children: [g, "", "*"] }))
                  : g,
              notched:
                typeof x < "u"
                  ? x
                  : !!(U.startAdornment || U.filled || U.focused),
            }),
          fullWidth: d,
          inputComponent: m,
          multiline: y,
          ref: t,
          type: _,
        },
        w,
        { classes: ue({}, T, { notchedOutline: null }) }
      )
    );
  });
uw.muiName = "Input";
function TF(n) {
  return Fn("MuiSelect", n);
}
const Fp = Ln("MuiSelect", [
  "root",
  "select",
  "multiple",
  "filled",
  "outlined",
  "standard",
  "disabled",
  "focused",
  "icon",
  "iconOpen",
  "iconFilled",
  "iconOutlined",
  "iconStandard",
  "nativeInput",
  "error",
]);
var uE;
const CF = [
    "aria-describedby",
    "aria-label",
    "autoFocus",
    "autoWidth",
    "children",
    "className",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "displayEmpty",
    "error",
    "IconComponent",
    "inputRef",
    "labelId",
    "MenuProps",
    "multiple",
    "name",
    "onBlur",
    "onChange",
    "onClose",
    "onFocus",
    "onOpen",
    "open",
    "readOnly",
    "renderValue",
    "SelectDisplayProps",
    "tabIndex",
    "type",
    "value",
    "variant",
  ],
  AF = jt("div", {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        { [`&.${Fp.select}`]: e.select },
        { [`&.${Fp.select}`]: e[t.variant] },
        { [`&.${Fp.error}`]: e.error },
        { [`&.${Fp.multiple}`]: e.multiple },
      ];
    },
  })(aA, {
    [`&.${Fp.select}`]: {
      height: "auto",
      minHeight: "1.4375em",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
    },
  }),
  RF = jt("svg", {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (n, e) => {
      const { ownerState: t } = n;
      return [
        e.icon,
        t.variant && e[`icon${an(t.variant)}`],
        t.open && e.iconOpen,
      ];
    },
  })(lA),
  PF = jt("input", {
    shouldForwardProp: (n) => ZC(n) && n !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (n, e) => e.nativeInput,
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box",
  });
function cE(n, e) {
  return typeof e == "object" && e !== null ? n === e : String(n) === String(e);
}
function IF(n) {
  return n == null || (typeof n == "string" && !n.trim());
}
const LF = (n) => {
    const {
        classes: e,
        variant: t,
        disabled: r,
        multiple: i,
        open: o,
        error: s,
      } = n,
      a = {
        select: ["select", t, r && "disabled", i && "multiple", s && "error"],
        icon: ["icon", `icon${an(t)}`, o && "iconOpen", r && "disabled"],
        nativeInput: ["nativeInput"],
      };
    return Bn(a, TF, e);
  },
  DF = X.forwardRef(function (e, t) {
    var r;
    const {
        "aria-describedby": i,
        "aria-label": o,
        autoFocus: s,
        autoWidth: a,
        children: u,
        className: c,
        defaultOpen: d,
        defaultValue: m,
        disabled: g,
        displayEmpty: y,
        error: x = !1,
        IconComponent: S,
        inputRef: _,
        labelId: w,
        MenuProps: T = {},
        multiple: M,
        name: A,
        onBlur: R,
        onChange: D,
        onClose: P,
        onFocus: U,
        onOpen: O,
        open: L,
        readOnly: H,
        renderValue: W,
        SelectDisplayProps: $ = {},
        tabIndex: K,
        value: Z,
        variant: Y = "standard",
      } = e,
      re = It(e, CF),
      [G, te] = K1({ controlled: Z, default: m, name: "Select" }),
      [F, V] = K1({ controlled: L, default: d, name: "Select" }),
      ne = X.useRef(null),
      ae = X.useRef(null),
      [J, se] = X.useState(null),
      { current: de } = X.useRef(L != null),
      [le, fe] = X.useState(),
      Me = ri(t, _),
      ge = X.useCallback(($e) => {
        (ae.current = $e), $e && se($e);
      }, []),
      xe = J == null ? void 0 : J.parentNode;
    X.useImperativeHandle(
      Me,
      () => ({
        focus: () => {
          ae.current.focus();
        },
        node: ne.current,
        value: G,
      }),
      [G]
    ),
      X.useEffect(() => {
        d &&
          F &&
          J &&
          !de &&
          (fe(a ? null : xe.clientWidth), ae.current.focus());
      }, [J, a]),
      X.useEffect(() => {
        s && ae.current.focus();
      }, [s]),
      X.useEffect(() => {
        if (!w) return;
        const $e = zo(ae.current).getElementById(w);
        if ($e) {
          const qe = () => {
            getSelection().isCollapsed && ae.current.focus();
          };
          return (
            $e.addEventListener("click", qe),
            () => {
              $e.removeEventListener("click", qe);
            }
          );
        }
      }, [w]);
    const j = ($e, qe) => {
        $e ? O && O(qe) : P && P(qe),
          de || (fe(a ? null : xe.clientWidth), V($e));
      },
      we = ($e) => {
        $e.button === 0 && ($e.preventDefault(), ae.current.focus(), j(!0, $e));
      },
      Ae = ($e) => {
        j(!1, $e);
      },
      Oe = X.Children.toArray(u),
      Ie = ($e) => {
        const qe = Oe.find((et) => et.props.value === $e.target.value);
        qe !== void 0 && (te(qe.props.value), D && D($e, qe));
      },
      rt = ($e) => (qe) => {
        let et;
        if (qe.currentTarget.hasAttribute("tabindex")) {
          if (M) {
            et = Array.isArray(G) ? G.slice() : [];
            const he = G.indexOf($e.props.value);
            he === -1 ? et.push($e.props.value) : et.splice(he, 1);
          } else et = $e.props.value;
          if (
            ($e.props.onClick && $e.props.onClick(qe), G !== et && (te(et), D))
          ) {
            const he = qe.nativeEvent || qe,
              Je = new he.constructor(he.type, he);
            Object.defineProperty(Je, "target", {
              writable: !0,
              value: { value: et, name: A },
            }),
              D(Je, $e);
          }
          M || j(!1, qe);
        }
      },
      De = ($e) => {
        H ||
          ([" ", "ArrowUp", "ArrowDown", "Enter"].indexOf($e.key) !== -1 &&
            ($e.preventDefault(), j(!0, $e)));
      },
      Xe = J !== null && F,
      ee = ($e) => {
        !Xe &&
          R &&
          (Object.defineProperty($e, "target", {
            writable: !0,
            value: { value: G, name: A },
          }),
          R($e));
      };
    delete re["aria-invalid"];
    let B, ve;
    const Se = [];
    let _e = !1;
    (k0({ value: G }) || y) && (W ? (B = W(G)) : (_e = !0));
    const Te = Oe.map(($e) => {
      if (!X.isValidElement($e)) return null;
      let qe;
      if (M) {
        if (!Array.isArray(G)) throw new Error(Bl(2));
        (qe = G.some((et) => cE(et, $e.props.value))),
          qe && _e && Se.push($e.props.children);
      } else (qe = cE(G, $e.props.value)), qe && _e && (ve = $e.props.children);
      return X.cloneElement($e, {
        "aria-selected": qe ? "true" : "false",
        onClick: rt($e),
        onKeyUp: (et) => {
          et.key === " " && et.preventDefault(),
            $e.props.onKeyUp && $e.props.onKeyUp(et);
        },
        role: "option",
        selected: qe,
        value: void 0,
        "data-value": $e.props.value,
      });
    });
    _e &&
      (M
        ? Se.length === 0
          ? (B = null)
          : (B = Se.reduce(
              ($e, qe, et) => (
                $e.push(qe), et < Se.length - 1 && $e.push(", "), $e
              ),
              []
            ))
        : (B = ve));
    let at = le;
    !a && de && J && (at = xe.clientWidth);
    let Fe;
    typeof K < "u" ? (Fe = K) : (Fe = g ? null : 0);
    const Be = $.id || (A ? `mui-component-select-${A}` : void 0),
      Ge = ue({}, e, { variant: Y, value: G, open: Xe, error: x }),
      Ye = LF(Ge),
      nt = ue({}, T.PaperProps, (r = T.slotProps) == null ? void 0 : r.paper),
      xt = ZS();
    return Q.jsxs(X.Fragment, {
      children: [
        Q.jsx(
          AF,
          ue(
            {
              ref: ge,
              tabIndex: Fe,
              role: "combobox",
              "aria-controls": xt,
              "aria-disabled": g ? "true" : void 0,
              "aria-expanded": Xe ? "true" : "false",
              "aria-haspopup": "listbox",
              "aria-label": o,
              "aria-labelledby": [w, Be].filter(Boolean).join(" ") || void 0,
              "aria-describedby": i,
              onKeyDown: De,
              onMouseDown: g || H ? null : we,
              onBlur: ee,
              onFocus: U,
            },
            $,
            {
              ownerState: Ge,
              className: Zt($.className, Ye.select, c),
              id: Be,
              children: IF(B)
                ? uE ||
                  (uE = Q.jsx("span", {
                    className: "notranslate",
                    children: "",
                  }))
                : B,
            }
          )
        ),
        Q.jsx(
          PF,
          ue(
            {
              "aria-invalid": x,
              value: Array.isArray(G) ? G.join(",") : G,
              name: A,
              ref: ne,
              "aria-hidden": !0,
              onChange: Ie,
              tabIndex: -1,
              disabled: g,
              className: Ye.nativeInput,
              autoFocus: s,
              ownerState: Ge,
            },
            re
          )
        ),
        Q.jsx(RF, { as: S, className: Ye.icon, ownerState: Ge }),
        Q.jsx(
          oF,
          ue(
            {
              id: `menu-${A || ""}`,
              anchorEl: xe,
              open: Xe,
              onClose: Ae,
              anchorOrigin: { vertical: "bottom", horizontal: "center" },
              transformOrigin: { vertical: "top", horizontal: "center" },
            },
            T,
            {
              MenuListProps: ue(
                {
                  "aria-labelledby": w,
                  role: "listbox",
                  "aria-multiselectable": M ? "true" : void 0,
                  disableListWrap: !0,
                  id: xt,
                },
                T.MenuListProps
              ),
              slotProps: ue({}, T.slotProps, {
                paper: ue({}, nt, {
                  style: ue({ minWidth: at }, nt != null ? nt.style : null),
                }),
              }),
              children: Te,
            }
          )
        ),
      ],
    });
  }),
  kF = [
    "autoWidth",
    "children",
    "classes",
    "className",
    "defaultOpen",
    "displayEmpty",
    "IconComponent",
    "id",
    "input",
    "inputProps",
    "label",
    "labelId",
    "MenuProps",
    "multiple",
    "native",
    "onClose",
    "onOpen",
    "open",
    "renderValue",
    "SelectDisplayProps",
    "variant",
  ],
  OF = ["root"],
  NF = (n) => {
    const { classes: e } = n;
    return e;
  },
  cw = {
    name: "MuiSelect",
    overridesResolver: (n, e) => e.root,
    shouldForwardProp: (n) => Os(n) && n !== "variant",
    slot: "Root",
  },
  UF = jt(aw, cw)(""),
  FF = jt(uw, cw)(""),
  BF = jt(sw, cw)(""),
  uf = X.forwardRef(function (e, t) {
    const r = Yn({ name: "MuiSelect", props: e }),
      {
        autoWidth: i = !1,
        children: o,
        classes: s = {},
        className: a,
        defaultOpen: u = !1,
        displayEmpty: c = !1,
        IconComponent: d = tN,
        id: m,
        input: g,
        inputProps: y,
        label: x,
        labelId: S,
        MenuProps: _,
        multiple: w = !1,
        native: T = !1,
        onClose: M,
        onOpen: A,
        open: R,
        renderValue: D,
        SelectDisplayProps: P,
        variant: U = "outlined",
      } = r,
      O = It(r, kF),
      L = T ? gF : DF,
      H = zh(),
      W = Bh({ props: r, muiFormControl: H, states: ["variant", "error"] }),
      $ = W.variant || U,
      K = ue({}, r, { variant: $, classes: s }),
      Z = NF(K),
      Y = It(Z, OF),
      re =
        g ||
        {
          standard: Q.jsx(UF, { ownerState: K }),
          outlined: Q.jsx(FF, { label: x, ownerState: K }),
          filled: Q.jsx(BF, { ownerState: K }),
        }[$],
      G = ri(t, re.ref);
    return Q.jsx(X.Fragment, {
      children: X.cloneElement(
        re,
        ue(
          {
            inputComponent: L,
            inputProps: ue(
              {
                children: o,
                error: W.error,
                IconComponent: d,
                variant: $,
                type: void 0,
                multiple: w,
              },
              T
                ? { id: m }
                : {
                    autoWidth: i,
                    defaultOpen: u,
                    displayEmpty: c,
                    labelId: S,
                    MenuProps: _,
                    onClose: M,
                    onOpen: A,
                    open: R,
                    renderValue: D,
                    SelectDisplayProps: ue({ id: m }, P),
                  },
              y,
              { classes: y ? ni(Y, y.classes) : Y },
              g ? g.props.inputProps : {}
            ),
          },
          ((w && T) || c) && $ === "outlined" ? { notched: !0 } : {},
          { ref: G, className: Zt(re.props.className, a, Z.root) },
          !g && { variant: $ },
          O
        )
      ),
    });
  });
uf.muiName = "Select";
function zF(n) {
  return Fn("MuiTextField", n);
}
Ln("MuiTextField", ["root"]);
const HF = [
    "autoComplete",
    "autoFocus",
    "children",
    "className",
    "color",
    "defaultValue",
    "disabled",
    "error",
    "FormHelperTextProps",
    "fullWidth",
    "helperText",
    "id",
    "InputLabelProps",
    "inputProps",
    "InputProps",
    "inputRef",
    "label",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "placeholder",
    "required",
    "rows",
    "select",
    "SelectProps",
    "type",
    "value",
    "variant",
  ],
  VF = { standard: aw, filled: sw, outlined: uw },
  WF = (n) => {
    const { classes: e } = n;
    return Bn({ root: ["root"] }, zF, e);
  },
  GF = jt(tf, {
    name: "MuiTextField",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })({}),
  jF = X.forwardRef(function (e, t) {
    const r = Yn({ props: e, name: "MuiTextField" }),
      {
        autoComplete: i,
        autoFocus: o = !1,
        children: s,
        className: a,
        color: u = "primary",
        defaultValue: c,
        disabled: d = !1,
        error: m = !1,
        FormHelperTextProps: g,
        fullWidth: y = !1,
        helperText: x,
        id: S,
        InputLabelProps: _,
        inputProps: w,
        InputProps: T,
        inputRef: M,
        label: A,
        maxRows: R,
        minRows: D,
        multiline: P = !1,
        name: U,
        onBlur: O,
        onChange: L,
        onFocus: H,
        placeholder: W,
        required: $ = !1,
        rows: K,
        select: Z = !1,
        SelectProps: Y,
        type: re,
        value: G,
        variant: te = "outlined",
      } = r,
      F = It(r, HF),
      V = ue({}, r, {
        autoFocus: o,
        color: u,
        disabled: d,
        error: m,
        fullWidth: y,
        multiline: P,
        required: $,
        select: Z,
        variant: te,
      }),
      ne = WF(V),
      ae = {};
    te === "outlined" &&
      (_ && typeof _.shrink < "u" && (ae.notched = _.shrink), (ae.label = A)),
      Z &&
        ((!Y || !Y.native) && (ae.id = void 0),
        (ae["aria-describedby"] = void 0));
    const J = ZS(S),
      se = x && J ? `${J}-helper-text` : void 0,
      de = A && J ? `${J}-label` : void 0,
      le = VF[te],
      fe = Q.jsx(
        le,
        ue(
          {
            "aria-describedby": se,
            autoComplete: i,
            autoFocus: o,
            defaultValue: c,
            fullWidth: y,
            multiline: P,
            name: U,
            rows: K,
            maxRows: R,
            minRows: D,
            type: re,
            value: G,
            id: J,
            inputRef: M,
            onBlur: O,
            onChange: L,
            onFocus: H,
            placeholder: W,
            inputProps: w,
          },
          ae,
          T
        )
      );
    return Q.jsxs(
      GF,
      ue(
        {
          className: Zt(ne.root, a),
          disabled: d,
          error: m,
          fullWidth: y,
          ref: t,
          required: $,
          color: u,
          variant: te,
          ownerState: V,
        },
        F,
        {
          children: [
            A != null &&
              A !== "" &&
              Q.jsx(ch, ue({ htmlFor: J, id: de }, _, { children: A })),
            Z
              ? Q.jsx(
                  uf,
                  ue(
                    {
                      "aria-describedby": se,
                      id: J,
                      labelId: de,
                      value: G,
                      input: fe,
                    },
                    Y,
                    { children: s }
                  )
                )
              : fe,
            x && Q.jsx(eU, ue({ id: se }, g, { children: x })),
          ],
        }
      )
    );
  });
function fa(n) {
  for (
    var e = arguments.length, t = Array(e > 1 ? e - 1 : 0), r = 1;
    r < e;
    r++
  )
    t[r - 1] = arguments[r];
  throw Error(
    "[Immer] minified error nr: " +
      n +
      (t.length
        ? " " +
          t
            .map(function (i) {
              return "'" + i + "'";
            })
            .join(",")
        : "") +
      ". Find the full error at: https://bit.ly/3cXEKWf"
  );
}
function Ku(n) {
  return !!n && !!n[lr];
}
function zl(n) {
  var e;
  return (
    !!n &&
    ((function (t) {
      if (!t || typeof t != "object") return !1;
      var r = Object.getPrototypeOf(t);
      if (r === null) return !0;
      var i = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
      return (
        i === Object ||
        (typeof i == "function" && Function.toString.call(i) === e4)
      );
    })(n) ||
      Array.isArray(n) ||
      !!n[vE] ||
      !!(!((e = n.constructor) === null || e === void 0) && e[vE]) ||
      fw(n) ||
      dw(n))
  );
}
function Tf(n, e, t) {
  t === void 0 && (t = !1),
    Hh(n) === 0
      ? (t ? Object.keys : bh)(n).forEach(function (r) {
          (t && typeof r == "symbol") || e(r, n[r], n);
        })
      : n.forEach(function (r, i) {
          return e(i, r, n);
        });
}
function Hh(n) {
  var e = n[lr];
  return e
    ? e.i > 3
      ? e.i - 4
      : e.i
    : Array.isArray(n)
    ? 1
    : fw(n)
    ? 2
    : dw(n)
    ? 3
    : 0;
}
function wh(n, e) {
  return Hh(n) === 2 ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e);
}
function $F(n, e) {
  return Hh(n) === 2 ? n.get(e) : n[e];
}
function uA(n, e, t) {
  var r = Hh(n);
  r === 2 ? n.set(e, t) : r === 3 ? n.add(t) : (n[e] = t);
}
function cA(n, e) {
  return n === e ? n !== 0 || 1 / n == 1 / e : n != n && e != e;
}
function fw(n) {
  return JF && n instanceof Map;
}
function dw(n) {
  return QF && n instanceof Set;
}
function nf(n) {
  return n.o || n.t;
}
function hw(n) {
  if (Array.isArray(n)) return Array.prototype.slice.call(n);
  var e = dA(n);
  delete e[lr];
  for (var t = bh(e), r = 0; r < t.length; r++) {
    var i = t[r],
      o = e[i];
    o.writable === !1 && ((o.writable = !0), (o.configurable = !0)),
      (o.get || o.set) &&
        (e[i] = {
          configurable: !0,
          writable: !0,
          enumerable: o.enumerable,
          value: n[i],
        });
  }
  return Object.create(Object.getPrototypeOf(n), e);
}
function pw(n, e) {
  return (
    e === void 0 && (e = !1),
    mw(n) ||
      Ku(n) ||
      !zl(n) ||
      (Hh(n) > 1 && (n.set = n.add = n.clear = n.delete = XF),
      Object.freeze(n),
      e &&
        Tf(
          n,
          function (t, r) {
            return pw(r, !0);
          },
          !0
        )),
    n
  );
}
function XF() {
  fa(2);
}
function mw(n) {
  return n == null || typeof n != "object" || Object.isFrozen(n);
}
function Ka(n) {
  var e = sS[n];
  return e || fa(18, n), e;
}
function YF(n, e) {
  sS[n] || (sS[n] = e);
}
function rS() {
  return Im;
}
function T_(n, e) {
  e && (Ka("Patches"), (n.u = []), (n.s = []), (n.v = e));
}
function N0(n) {
  iS(n), n.p.forEach(qF), (n.p = null);
}
function iS(n) {
  n === Im && (Im = n.l);
}
function fE(n) {
  return (Im = { p: [], l: Im, h: n, m: !0, _: 0 });
}
function qF(n) {
  var e = n[lr];
  e.i === 0 || e.i === 1 ? e.j() : (e.g = !0);
}
function C_(n, e) {
  e._ = e.p.length;
  var t = e.p[0],
    r = n !== void 0 && n !== t;
  return (
    e.h.O || Ka("ES5").S(e, n, r),
    r
      ? (t[lr].P && (N0(e), fa(4)),
        zl(n) && ((n = U0(e, n)), e.l || F0(e, n)),
        e.u && Ka("Patches").M(t[lr].t, n, e.u, e.s))
      : (n = U0(e, t, [])),
    N0(e),
    e.u && e.v(e.u, e.s),
    n !== fA ? n : void 0
  );
}
function U0(n, e, t) {
  if (mw(e)) return e;
  var r = e[lr];
  if (!r)
    return (
      Tf(
        e,
        function (a, u) {
          return dE(n, r, e, a, u, t);
        },
        !0
      ),
      e
    );
  if (r.A !== n) return e;
  if (!r.P) return F0(n, r.t, !0), r.t;
  if (!r.I) {
    (r.I = !0), r.A._--;
    var i = r.i === 4 || r.i === 5 ? (r.o = hw(r.k)) : r.o,
      o = i,
      s = !1;
    r.i === 3 && ((o = new Set(i)), i.clear(), (s = !0)),
      Tf(o, function (a, u) {
        return dE(n, r, i, a, u, t, s);
      }),
      F0(n, i, !1),
      t && n.u && Ka("Patches").N(r, t, n.u, n.s);
  }
  return r.o;
}
function dE(n, e, t, r, i, o, s) {
  if (Ku(i)) {
    var a = U0(n, i, o && e && e.i !== 3 && !wh(e.R, r) ? o.concat(r) : void 0);
    if ((uA(t, r, a), !Ku(a))) return;
    n.m = !1;
  } else s && t.add(i);
  if (zl(i) && !mw(i)) {
    if (!n.h.D && n._ < 1) return;
    U0(n, i), (e && e.A.l) || F0(n, i);
  }
}
function F0(n, e, t) {
  t === void 0 && (t = !1), !n.l && n.h.D && n.m && pw(e, t);
}
function A_(n, e) {
  var t = n[lr];
  return (t ? nf(t) : n)[e];
}
function hE(n, e) {
  if (e in n)
    for (var t = Object.getPrototypeOf(n); t; ) {
      var r = Object.getOwnPropertyDescriptor(t, e);
      if (r) return r;
      t = Object.getPrototypeOf(t);
    }
}
function Vu(n) {
  n.P || ((n.P = !0), n.l && Vu(n.l));
}
function R_(n) {
  n.o || (n.o = hw(n.t));
}
function oS(n, e, t) {
  var r = fw(e)
    ? Ka("MapSet").F(e, t)
    : dw(e)
    ? Ka("MapSet").T(e, t)
    : n.O
    ? (function (i, o) {
        var s = Array.isArray(i),
          a = {
            i: s ? 1 : 0,
            A: o ? o.A : rS(),
            P: !1,
            I: !1,
            R: {},
            l: o,
            t: i,
            k: null,
            o: null,
            j: null,
            C: !1,
          },
          u = a,
          c = Lm;
        s && ((u = [a]), (c = im));
        var d = Proxy.revocable(u, c),
          m = d.revoke,
          g = d.proxy;
        return (a.k = g), (a.j = m), g;
      })(e, t)
    : Ka("ES5").J(e, t);
  return (t ? t.A : rS()).p.push(r), r;
}
function KF(n) {
  return (
    Ku(n) || fa(22, n),
    (function e(t) {
      if (!zl(t)) return t;
      var r,
        i = t[lr],
        o = Hh(t);
      if (i) {
        if (!i.P && (i.i < 4 || !Ka("ES5").K(i))) return i.t;
        (i.I = !0), (r = pE(t, o)), (i.I = !1);
      } else r = pE(t, o);
      return (
        Tf(r, function (s, a) {
          (i && $F(i.t, s) === a) || uA(r, s, e(a));
        }),
        o === 3 ? new Set(r) : r
      );
    })(n)
  );
}
function pE(n, e) {
  switch (e) {
    case 2:
      return new Map(n);
    case 3:
      return Array.from(n);
  }
  return hw(n);
}
function ZF() {
  function n(o, s) {
    var a = i[o];
    return (
      a
        ? (a.enumerable = s)
        : (i[o] = a =
            {
              configurable: !0,
              enumerable: s,
              get: function () {
                var u = this[lr];
                return Lm.get(u, o);
              },
              set: function (u) {
                var c = this[lr];
                Lm.set(c, o, u);
              },
            }),
      a
    );
  }
  function e(o) {
    for (var s = o.length - 1; s >= 0; s--) {
      var a = o[s][lr];
      if (!a.P)
        switch (a.i) {
          case 5:
            r(a) && Vu(a);
            break;
          case 4:
            t(a) && Vu(a);
        }
    }
  }
  function t(o) {
    for (var s = o.t, a = o.k, u = bh(a), c = u.length - 1; c >= 0; c--) {
      var d = u[c];
      if (d !== lr) {
        var m = s[d];
        if (m === void 0 && !wh(s, d)) return !0;
        var g = a[d],
          y = g && g[lr];
        if (y ? y.t !== m : !cA(g, m)) return !0;
      }
    }
    var x = !!s[lr];
    return u.length !== bh(s).length + (x ? 0 : 1);
  }
  function r(o) {
    var s = o.k;
    if (s.length !== o.t.length) return !0;
    var a = Object.getOwnPropertyDescriptor(s, s.length - 1);
    if (a && !a.get) return !0;
    for (var u = 0; u < s.length; u++) if (!s.hasOwnProperty(u)) return !0;
    return !1;
  }
  var i = {};
  YF("ES5", {
    J: function (o, s) {
      var a = Array.isArray(o),
        u = (function (d, m) {
          if (d) {
            for (var g = Array(m.length), y = 0; y < m.length; y++)
              Object.defineProperty(g, "" + y, n(y, !0));
            return g;
          }
          var x = dA(m);
          delete x[lr];
          for (var S = bh(x), _ = 0; _ < S.length; _++) {
            var w = S[_];
            x[w] = n(w, d || !!x[w].enumerable);
          }
          return Object.create(Object.getPrototypeOf(m), x);
        })(a, o),
        c = {
          i: a ? 5 : 4,
          A: s ? s.A : rS(),
          P: !1,
          I: !1,
          R: {},
          l: s,
          t: o,
          k: u,
          o: null,
          g: !1,
          C: !1,
        };
      return Object.defineProperty(u, lr, { value: c, writable: !0 }), u;
    },
    S: function (o, s, a) {
      a
        ? Ku(s) && s[lr].A === o && e(o.p)
        : (o.u &&
            (function u(c) {
              if (c && typeof c == "object") {
                var d = c[lr];
                if (d) {
                  var m = d.t,
                    g = d.k,
                    y = d.R,
                    x = d.i;
                  if (x === 4)
                    Tf(g, function (M) {
                      M !== lr &&
                        (m[M] !== void 0 || wh(m, M)
                          ? y[M] || u(g[M])
                          : ((y[M] = !0), Vu(d)));
                    }),
                      Tf(m, function (M) {
                        g[M] !== void 0 || wh(g, M) || ((y[M] = !1), Vu(d));
                      });
                  else if (x === 5) {
                    if ((r(d) && (Vu(d), (y.length = !0)), g.length < m.length))
                      for (var S = g.length; S < m.length; S++) y[S] = !1;
                    else for (var _ = m.length; _ < g.length; _++) y[_] = !0;
                    for (
                      var w = Math.min(g.length, m.length), T = 0;
                      T < w;
                      T++
                    )
                      g.hasOwnProperty(T) || (y[T] = !0),
                        y[T] === void 0 && u(g[T]);
                  }
                }
              }
            })(o.p[0]),
          e(o.p));
    },
    K: function (o) {
      return o.i === 4 ? t(o) : r(o);
    },
  });
}
var mE,
  Im,
  gw = typeof Symbol < "u" && typeof Symbol("x") == "symbol",
  JF = typeof Map < "u",
  QF = typeof Set < "u",
  gE = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u",
  fA = gw
    ? Symbol.for("immer-nothing")
    : (((mE = {})["immer-nothing"] = !0), mE),
  vE = gw ? Symbol.for("immer-draftable") : "__$immer_draftable",
  lr = gw ? Symbol.for("immer-state") : "__$immer_state",
  e4 = "" + Object.prototype.constructor,
  bh =
    typeof Reflect < "u" && Reflect.ownKeys
      ? Reflect.ownKeys
      : Object.getOwnPropertySymbols !== void 0
      ? function (n) {
          return Object.getOwnPropertyNames(n).concat(
            Object.getOwnPropertySymbols(n)
          );
        }
      : Object.getOwnPropertyNames,
  dA =
    Object.getOwnPropertyDescriptors ||
    function (n) {
      var e = {};
      return (
        bh(n).forEach(function (t) {
          e[t] = Object.getOwnPropertyDescriptor(n, t);
        }),
        e
      );
    },
  sS = {},
  Lm = {
    get: function (n, e) {
      if (e === lr) return n;
      var t = nf(n);
      if (!wh(t, e))
        return (function (i, o, s) {
          var a,
            u = hE(o, s);
          return u
            ? "value" in u
              ? u.value
              : (a = u.get) === null || a === void 0
              ? void 0
              : a.call(i.k)
            : void 0;
        })(n, t, e);
      var r = t[e];
      return n.I || !zl(r)
        ? r
        : r === A_(n.t, e)
        ? (R_(n), (n.o[e] = oS(n.A.h, r, n)))
        : r;
    },
    has: function (n, e) {
      return e in nf(n);
    },
    ownKeys: function (n) {
      return Reflect.ownKeys(nf(n));
    },
    set: function (n, e, t) {
      var r = hE(nf(n), e);
      if (r != null && r.set) return r.set.call(n.k, t), !0;
      if (!n.P) {
        var i = A_(nf(n), e),
          o = i == null ? void 0 : i[lr];
        if (o && o.t === t) return (n.o[e] = t), (n.R[e] = !1), !0;
        if (cA(t, i) && (t !== void 0 || wh(n.t, e))) return !0;
        R_(n), Vu(n);
      }
      return (
        (n.o[e] === t && (t !== void 0 || e in n.o)) ||
          (Number.isNaN(t) && Number.isNaN(n.o[e])) ||
          ((n.o[e] = t), (n.R[e] = !0)),
        !0
      );
    },
    deleteProperty: function (n, e) {
      return (
        A_(n.t, e) !== void 0 || e in n.t
          ? ((n.R[e] = !1), R_(n), Vu(n))
          : delete n.R[e],
        n.o && delete n.o[e],
        !0
      );
    },
    getOwnPropertyDescriptor: function (n, e) {
      var t = nf(n),
        r = Reflect.getOwnPropertyDescriptor(t, e);
      return (
        r && {
          writable: !0,
          configurable: n.i !== 1 || e !== "length",
          enumerable: r.enumerable,
          value: t[e],
        }
      );
    },
    defineProperty: function () {
      fa(11);
    },
    getPrototypeOf: function (n) {
      return Object.getPrototypeOf(n.t);
    },
    setPrototypeOf: function () {
      fa(12);
    },
  },
  im = {};
Tf(Lm, function (n, e) {
  im[n] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
}),
  (im.deleteProperty = function (n, e) {
    return im.set.call(this, n, e, void 0);
  }),
  (im.set = function (n, e, t) {
    return Lm.set.call(this, n[0], e, t, n[0]);
  });
var t4 = (function () {
    function n(t) {
      var r = this;
      (this.O = gE),
        (this.D = !0),
        (this.produce = function (i, o, s) {
          if (typeof i == "function" && typeof o != "function") {
            var a = o;
            o = i;
            var u = r;
            return function (S) {
              var _ = this;
              S === void 0 && (S = a);
              for (
                var w = arguments.length, T = Array(w > 1 ? w - 1 : 0), M = 1;
                M < w;
                M++
              )
                T[M - 1] = arguments[M];
              return u.produce(S, function (A) {
                var R;
                return (R = o).call.apply(R, [_, A].concat(T));
              });
            };
          }
          var c;
          if (
            (typeof o != "function" && fa(6),
            s !== void 0 && typeof s != "function" && fa(7),
            zl(i))
          ) {
            var d = fE(r),
              m = oS(r, i, void 0),
              g = !0;
            try {
              (c = o(m)), (g = !1);
            } finally {
              g ? N0(d) : iS(d);
            }
            return typeof Promise < "u" && c instanceof Promise
              ? c.then(
                  function (S) {
                    return T_(d, s), C_(S, d);
                  },
                  function (S) {
                    throw (N0(d), S);
                  }
                )
              : (T_(d, s), C_(c, d));
          }
          if (!i || typeof i != "object") {
            if (
              ((c = o(i)) === void 0 && (c = i),
              c === fA && (c = void 0),
              r.D && pw(c, !0),
              s)
            ) {
              var y = [],
                x = [];
              Ka("Patches").M(i, c, y, x), s(y, x);
            }
            return c;
          }
          fa(21, i);
        }),
        (this.produceWithPatches = function (i, o) {
          if (typeof i == "function")
            return function (c) {
              for (
                var d = arguments.length, m = Array(d > 1 ? d - 1 : 0), g = 1;
                g < d;
                g++
              )
                m[g - 1] = arguments[g];
              return r.produceWithPatches(c, function (y) {
                return i.apply(void 0, [y].concat(m));
              });
            };
          var s,
            a,
            u = r.produce(i, o, function (c, d) {
              (s = c), (a = d);
            });
          return typeof Promise < "u" && u instanceof Promise
            ? u.then(function (c) {
                return [c, s, a];
              })
            : [u, s, a];
        }),
        typeof (t == null ? void 0 : t.useProxies) == "boolean" &&
          this.setUseProxies(t.useProxies),
        typeof (t == null ? void 0 : t.autoFreeze) == "boolean" &&
          this.setAutoFreeze(t.autoFreeze);
    }
    var e = n.prototype;
    return (
      (e.createDraft = function (t) {
        zl(t) || fa(8), Ku(t) && (t = KF(t));
        var r = fE(this),
          i = oS(this, t, void 0);
        return (i[lr].C = !0), iS(r), i;
      }),
      (e.finishDraft = function (t, r) {
        var i = t && t[lr],
          o = i.A;
        return T_(o, r), C_(void 0, o);
      }),
      (e.setAutoFreeze = function (t) {
        this.D = t;
      }),
      (e.setUseProxies = function (t) {
        t && !gE && fa(20), (this.O = t);
      }),
      (e.applyPatches = function (t, r) {
        var i;
        for (i = r.length - 1; i >= 0; i--) {
          var o = r[i];
          if (o.path.length === 0 && o.op === "replace") {
            t = o.value;
            break;
          }
        }
        i > -1 && (r = r.slice(i + 1));
        var s = Ka("Patches").$;
        return Ku(t)
          ? s(t, r)
          : this.produce(t, function (a) {
              return s(a, r);
            });
      }),
      n
    );
  })(),
  cs = new t4(),
  hA = cs.produce;
cs.produceWithPatches.bind(cs);
cs.setAutoFreeze.bind(cs);
cs.setUseProxies.bind(cs);
cs.applyPatches.bind(cs);
cs.createDraft.bind(cs);
cs.finishDraft.bind(cs);
function n4(n, e, t) {
  return (
    (e = YC(e)) in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function yE(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable;
      })),
      t.push.apply(t, r);
  }
  return t;
}
function xE(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? yE(Object(t), !0).forEach(function (r) {
          n4(n, r, t[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : yE(Object(t)).forEach(function (r) {
          Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
        });
  }
  return n;
}
function to(n) {
  return (
    "Minified Redux error #" +
    n +
    "; visit https://redux.js.org/Errors?code=" +
    n +
    " for the full message or use the non-minified dev environment for full errors. "
  );
}
var _E = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })(),
  P_ = function () {
    return Math.random().toString(36).substring(7).split("").join(".");
  },
  B0 = {
    INIT: "@@redux/INIT" + P_(),
    REPLACE: "@@redux/REPLACE" + P_(),
    PROBE_UNKNOWN_ACTION: function () {
      return "@@redux/PROBE_UNKNOWN_ACTION" + P_();
    },
  };
function r4(n) {
  if (typeof n != "object" || n === null) return !1;
  for (var e = n; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(n) === e;
}
function pA(n, e, t) {
  var r;
  if (
    (typeof e == "function" && typeof t == "function") ||
    (typeof t == "function" && typeof arguments[3] == "function")
  )
    throw new Error(to(0));
  if (
    (typeof e == "function" && typeof t > "u" && ((t = e), (e = void 0)),
    typeof t < "u")
  ) {
    if (typeof t != "function") throw new Error(to(1));
    return t(pA)(n, e);
  }
  if (typeof n != "function") throw new Error(to(2));
  var i = n,
    o = e,
    s = [],
    a = s,
    u = !1;
  function c() {
    a === s && (a = s.slice());
  }
  function d() {
    if (u) throw new Error(to(3));
    return o;
  }
  function m(S) {
    if (typeof S != "function") throw new Error(to(4));
    if (u) throw new Error(to(5));
    var _ = !0;
    return (
      c(),
      a.push(S),
      function () {
        if (_) {
          if (u) throw new Error(to(6));
          (_ = !1), c();
          var T = a.indexOf(S);
          a.splice(T, 1), (s = null);
        }
      }
    );
  }
  function g(S) {
    if (!r4(S)) throw new Error(to(7));
    if (typeof S.type > "u") throw new Error(to(8));
    if (u) throw new Error(to(9));
    try {
      (u = !0), (o = i(o, S));
    } finally {
      u = !1;
    }
    for (var _ = (s = a), w = 0; w < _.length; w++) {
      var T = _[w];
      T();
    }
    return S;
  }
  function y(S) {
    if (typeof S != "function") throw new Error(to(10));
    (i = S), g({ type: B0.REPLACE });
  }
  function x() {
    var S,
      _ = m;
    return (
      (S = {
        subscribe: function (T) {
          if (typeof T != "object" || T === null) throw new Error(to(11));
          function M() {
            T.next && T.next(d());
          }
          M();
          var A = _(M);
          return { unsubscribe: A };
        },
      }),
      (S[_E] = function () {
        return this;
      }),
      S
    );
  }
  return (
    g({ type: B0.INIT }),
    (r = { dispatch: g, subscribe: m, getState: d, replaceReducer: y }),
    (r[_E] = x),
    r
  );
}
function i4(n) {
  Object.keys(n).forEach(function (e) {
    var t = n[e],
      r = t(void 0, { type: B0.INIT });
    if (typeof r > "u") throw new Error(to(12));
    if (typeof t(void 0, { type: B0.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(to(13));
  });
}
function o4(n) {
  for (var e = Object.keys(n), t = {}, r = 0; r < e.length; r++) {
    var i = e[r];
    typeof n[i] == "function" && (t[i] = n[i]);
  }
  var o = Object.keys(t),
    s;
  try {
    i4(t);
  } catch (a) {
    s = a;
  }
  return function (u, c) {
    if ((u === void 0 && (u = {}), s)) throw s;
    for (var d = !1, m = {}, g = 0; g < o.length; g++) {
      var y = o[g],
        x = t[y],
        S = u[y],
        _ = x(S, c);
      if (typeof _ > "u") throw (c && c.type, new Error(to(14)));
      (m[y] = _), (d = d || _ !== S);
    }
    return (d = d || o.length !== Object.keys(u).length), d ? m : u;
  };
}
function z0() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return e.length === 0
    ? function (r) {
        return r;
      }
    : e.length === 1
    ? e[0]
    : e.reduce(function (r, i) {
        return function () {
          return r(i.apply(void 0, arguments));
        };
      });
}
function s4() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return function (r) {
    return function () {
      var i = r.apply(void 0, arguments),
        o = function () {
          throw new Error(to(15));
        },
        s = {
          getState: i.getState,
          dispatch: function () {
            return o.apply(void 0, arguments);
          },
        },
        a = e.map(function (u) {
          return u(s);
        });
      return (
        (o = z0.apply(void 0, a)(i.dispatch)),
        xE(xE({}, i), {}, { dispatch: o })
      );
    };
  };
}
function mA(n) {
  var e = function (r) {
    var i = r.dispatch,
      o = r.getState;
    return function (s) {
      return function (a) {
        return typeof a == "function" ? a(i, o, n) : s(a);
      };
    };
  };
  return e;
}
var aS = mA();
aS.withExtraArgument = mA;
var gA = (function () {
    var n = function (e, t) {
      return (
        (n =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
          }),
        n(e, t)
      );
    };
    return function (e, t) {
      if (typeof t != "function" && t !== null)
        throw new TypeError(
          "Class extends value " + String(t) + " is not a constructor or null"
        );
      n(e, t);
      function r() {
        this.constructor = e;
      }
      e.prototype =
        t === null ? Object.create(t) : ((r.prototype = t.prototype), new r());
    };
  })(),
  a4 = function (n, e) {
    var t = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      s;
    return (
      (s = { next: a(0), throw: a(1), return: a(2) }),
      typeof Symbol == "function" &&
        (s[Symbol.iterator] = function () {
          return this;
        }),
      s
    );
    function a(c) {
      return function (d) {
        return u([c, d]);
      };
    }
    function u(c) {
      if (r) throw new TypeError("Generator is already executing.");
      for (; t; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                c[0] & 2
                  ? i.return
                  : c[0]
                  ? i.throw || ((o = i.return) && o.call(i), 0)
                  : i.next) &&
              !(o = o.call(i, c[1])).done)
          )
            return o;
          switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
            case 0:
            case 1:
              o = c;
              break;
            case 4:
              return t.label++, { value: c[1], done: !1 };
            case 5:
              t.label++, (i = c[1]), (c = [0]);
              continue;
            case 7:
              (c = t.ops.pop()), t.trys.pop();
              continue;
            default:
              if (
                ((o = t.trys),
                !(o = o.length > 0 && o[o.length - 1]) &&
                  (c[0] === 6 || c[0] === 2))
              ) {
                t = 0;
                continue;
              }
              if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                t.label = c[1];
                break;
              }
              if (c[0] === 6 && t.label < o[1]) {
                (t.label = o[1]), (o = c);
                break;
              }
              if (o && t.label < o[2]) {
                (t.label = o[2]), t.ops.push(c);
                break;
              }
              o[2] && t.ops.pop(), t.trys.pop();
              continue;
          }
          c = e.call(n, t);
        } catch (d) {
          (c = [6, d]), (i = 0);
        } finally {
          r = o = 0;
        }
      if (c[0] & 5) throw c[1];
      return { value: c[0] ? c[1] : void 0, done: !0 };
    }
  },
  Ph = function (n, e) {
    for (var t = 0, r = e.length, i = n.length; t < r; t++, i++) n[i] = e[t];
    return n;
  },
  l4 = Object.defineProperty,
  u4 = Object.defineProperties,
  c4 = Object.getOwnPropertyDescriptors,
  SE = Object.getOwnPropertySymbols,
  f4 = Object.prototype.hasOwnProperty,
  d4 = Object.prototype.propertyIsEnumerable,
  wE = function (n, e, t) {
    return e in n
      ? l4(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t);
  },
  ju = function (n, e) {
    for (var t in e || (e = {})) f4.call(e, t) && wE(n, t, e[t]);
    if (SE)
      for (var r = 0, i = SE(e); r < i.length; r++) {
        var t = i[r];
        d4.call(e, t) && wE(n, t, e[t]);
      }
    return n;
  },
  I_ = function (n, e) {
    return u4(n, c4(e));
  },
  h4 = function (n, e, t) {
    return new Promise(function (r, i) {
      var o = function (u) {
          try {
            a(t.next(u));
          } catch (c) {
            i(c);
          }
        },
        s = function (u) {
          try {
            a(t.throw(u));
          } catch (c) {
            i(c);
          }
        },
        a = function (u) {
          return u.done ? r(u.value) : Promise.resolve(u.value).then(o, s);
        };
      a((t = t.apply(n, e)).next());
    });
  },
  p4 =
    typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == "object"
              ? z0
              : z0.apply(null, arguments);
        };
function m4(n) {
  if (typeof n != "object" || n === null) return !1;
  var e = Object.getPrototypeOf(n);
  if (e === null) return !0;
  for (var t = e; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return e === t;
}
function $u(n, e) {
  function t() {
    for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
    if (e) {
      var o = e.apply(void 0, r);
      if (!o) throw new Error("prepareAction did not return an object");
      return ju(
        ju({ type: n, payload: o.payload }, "meta" in o && { meta: o.meta }),
        "error" in o && { error: o.error }
      );
    }
    return { type: n, payload: r[0] };
  }
  return (
    (t.toString = function () {
      return "" + n;
    }),
    (t.type = n),
    (t.match = function (r) {
      return r.type === n;
    }),
    t
  );
}
var g4 = (function (n) {
    gA(e, n);
    function e() {
      for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
      var i = n.apply(this, t) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return n.prototype.concat.apply(this, t);
      }),
      (e.prototype.prepend = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return t.length === 1 && Array.isArray(t[0])
          ? new (e.bind.apply(e, Ph([void 0], t[0].concat(this))))()
          : new (e.bind.apply(e, Ph([void 0], t.concat(this))))();
      }),
      e
    );
  })(Array),
  v4 = (function (n) {
    gA(e, n);
    function e() {
      for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
      var i = n.apply(this, t) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return n.prototype.concat.apply(this, t);
      }),
      (e.prototype.prepend = function () {
        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
        return t.length === 1 && Array.isArray(t[0])
          ? new (e.bind.apply(e, Ph([void 0], t[0].concat(this))))()
          : new (e.bind.apply(e, Ph([void 0], t.concat(this))))();
      }),
      e
    );
  })(Array);
function lS(n) {
  return zl(n) ? hA(n, function () {}) : n;
}
function y4(n) {
  return typeof n == "boolean";
}
function x4() {
  return function (e) {
    return _4(e);
  };
}
function _4(n) {
  n === void 0 && (n = {});
  var e = n.thunk,
    t = e === void 0 ? !0 : e;
  n.immutableCheck, n.serializableCheck, n.actionCreatorCheck;
  var r = new g4();
  return (
    t && (y4(t) ? r.push(aS) : r.push(aS.withExtraArgument(t.extraArgument))), r
  );
}
function S4(n) {
  var e = x4(),
    t = n || {},
    r = t.reducer,
    i = r === void 0 ? void 0 : r,
    o = t.middleware,
    s = o === void 0 ? e() : o,
    a = t.devTools,
    u = a === void 0 ? !0 : a,
    c = t.preloadedState,
    d = c === void 0 ? void 0 : c,
    m = t.enhancers,
    g = m === void 0 ? void 0 : m,
    y;
  if (typeof i == "function") y = i;
  else if (m4(i)) y = o4(i);
  else
    throw new Error(
      '"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'
    );
  var x = s;
  typeof x == "function" && (x = x(e));
  var S = s4.apply(void 0, x),
    _ = z0;
  u && (_ = p4(ju({ trace: !1 }, typeof u == "object" && u)));
  var w = new v4(S),
    T = w;
  Array.isArray(g) ? (T = Ph([S], g)) : typeof g == "function" && (T = g(w));
  var M = _.apply(void 0, T);
  return pA(y, d, M);
}
function vA(n) {
  var e = {},
    t = [],
    r,
    i = {
      addCase: function (o, s) {
        var a = typeof o == "string" ? o : o.type;
        if (!a)
          throw new Error(
            "`builder.addCase` cannot be called with an empty action type"
          );
        if (a in e)
          throw new Error(
            "`builder.addCase` cannot be called with two reducers for the same action type"
          );
        return (e[a] = s), i;
      },
      addMatcher: function (o, s) {
        return t.push({ matcher: o, reducer: s }), i;
      },
      addDefaultCase: function (o) {
        return (r = o), i;
      },
    };
  return n(i), [e, t, r];
}
function w4(n) {
  return typeof n == "function";
}
function b4(n, e, t, r) {
  t === void 0 && (t = []);
  var i = typeof e == "function" ? vA(e) : [e, t, r],
    o = i[0],
    s = i[1],
    a = i[2],
    u;
  if (w4(n))
    u = function () {
      return lS(n());
    };
  else {
    var c = lS(n);
    u = function () {
      return c;
    };
  }
  function d(m, g) {
    m === void 0 && (m = u());
    var y = Ph(
      [o[g.type]],
      s
        .filter(function (x) {
          var S = x.matcher;
          return S(g);
        })
        .map(function (x) {
          var S = x.reducer;
          return S;
        })
    );
    return (
      y.filter(function (x) {
        return !!x;
      }).length === 0 && (y = [a]),
      y.reduce(function (x, S) {
        if (S)
          if (Ku(x)) {
            var _ = x,
              w = S(_, g);
            return w === void 0 ? x : w;
          } else {
            if (zl(x))
              return hA(x, function (T) {
                return S(T, g);
              });
            var w = S(x, g);
            if (w === void 0) {
              if (x === null) return x;
              throw Error(
                "A case reducer on a non-draftable value must not return undefined"
              );
            }
            return w;
          }
        return x;
      }, m)
    );
  }
  return (d.getInitialState = u), d;
}
function M4(n, e) {
  return n + "/" + e;
}
function E4(n) {
  var e = n.name,
    t =
      typeof n.initialState == "function" ? n.initialState : lS(n.initialState),
    r = n.reducers || {},
    i = Object.keys(r),
    o = {},
    s = {},
    a = {};
  i.forEach(function (d) {
    var m = r[d],
      g = M4(e, d),
      y,
      x;
    "reducer" in m ? ((y = m.reducer), (x = m.prepare)) : (y = m),
      (o[d] = y),
      (s[g] = y),
      (a[d] = x ? $u(g, x) : $u(g));
  });
  function u() {
    var d =
        typeof n.extraReducers == "function"
          ? vA(n.extraReducers)
          : [n.extraReducers],
      m = d[0],
      g = m === void 0 ? {} : m,
      y = d[1],
      x = y === void 0 ? [] : y,
      S = d[2],
      _ = S === void 0 ? void 0 : S,
      w = ju(ju({}, g), s);
    return b4(t, function (T) {
      for (var M in w) T.addCase(M, w[M]);
      for (var A = 0, R = x; A < R.length; A++) {
        var D = R[A];
        T.addMatcher(D.matcher, D.reducer);
      }
      _ && T.addDefaultCase(_);
    });
  }
  var c;
  return {
    name: e,
    reducer: function (d, m) {
      return c || (c = u()), c(d, m);
    },
    actions: a,
    caseReducers: o,
    getInitialState: function () {
      return c || (c = u()), c.getInitialState();
    },
  };
}
var T4 = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  C4 = function (n) {
    n === void 0 && (n = 21);
    for (var e = "", t = n; t--; ) e += T4[(Math.random() * 64) | 0];
    return e;
  },
  A4 = ["name", "message", "stack", "code"],
  L_ = (function () {
    function n(e, t) {
      (this.payload = e), (this.meta = t);
    }
    return n;
  })(),
  bE = (function () {
    function n(e, t) {
      (this.payload = e), (this.meta = t);
    }
    return n;
  })(),
  R4 = function (n) {
    if (typeof n == "object" && n !== null) {
      for (var e = {}, t = 0, r = A4; t < r.length; t++) {
        var i = r[t];
        typeof n[i] == "string" && (e[i] = n[i]);
      }
      return e;
    }
    return { message: String(n) };
  };
(function () {
  function n(e, t, r) {
    var i = $u(e + "/fulfilled", function (c, d, m, g) {
        return {
          payload: c,
          meta: I_(ju({}, g || {}), {
            arg: m,
            requestId: d,
            requestStatus: "fulfilled",
          }),
        };
      }),
      o = $u(e + "/pending", function (c, d, m) {
        return {
          payload: void 0,
          meta: I_(ju({}, m || {}), {
            arg: d,
            requestId: c,
            requestStatus: "pending",
          }),
        };
      }),
      s = $u(e + "/rejected", function (c, d, m, g, y) {
        return {
          payload: g,
          error: ((r && r.serializeError) || R4)(c || "Rejected"),
          meta: I_(ju({}, y || {}), {
            arg: m,
            requestId: d,
            rejectedWithValue: !!g,
            requestStatus: "rejected",
            aborted: (c == null ? void 0 : c.name) === "AbortError",
            condition: (c == null ? void 0 : c.name) === "ConditionError",
          }),
        };
      }),
      a =
        typeof AbortController < "u"
          ? AbortController
          : (function () {
              function c() {
                this.signal = {
                  aborted: !1,
                  addEventListener: function () {},
                  dispatchEvent: function () {
                    return !1;
                  },
                  onabort: function () {},
                  removeEventListener: function () {},
                  reason: void 0,
                  throwIfAborted: function () {},
                };
              }
              return (c.prototype.abort = function () {}), c;
            })();
    function u(c) {
      return function (d, m, g) {
        var y = r != null && r.idGenerator ? r.idGenerator(c) : C4(),
          x = new a(),
          S;
        function _(T) {
          (S = T), x.abort();
        }
        var w = (function () {
          return h4(this, null, function () {
            var T, M, A, R, D, P, U;
            return a4(this, function (O) {
              switch (O.label) {
                case 0:
                  return (
                    O.trys.push([0, 4, , 5]),
                    (R =
                      (T = r == null ? void 0 : r.condition) == null
                        ? void 0
                        : T.call(r, c, { getState: m, extra: g })),
                    I4(R) ? [4, R] : [3, 2]
                  );
                case 1:
                  (R = O.sent()), (O.label = 2);
                case 2:
                  if (R === !1 || x.signal.aborted)
                    throw {
                      name: "ConditionError",
                      message:
                        "Aborted due to condition callback returning false.",
                    };
                  return (
                    (D = new Promise(function (L, H) {
                      return x.signal.addEventListener("abort", function () {
                        return H({
                          name: "AbortError",
                          message: S || "Aborted",
                        });
                      });
                    })),
                    d(
                      o(
                        y,
                        c,
                        (M = r == null ? void 0 : r.getPendingMeta) == null
                          ? void 0
                          : M.call(
                              r,
                              { requestId: y, arg: c },
                              { getState: m, extra: g }
                            )
                      )
                    ),
                    [
                      4,
                      Promise.race([
                        D,
                        Promise.resolve(
                          t(c, {
                            dispatch: d,
                            getState: m,
                            extra: g,
                            requestId: y,
                            signal: x.signal,
                            abort: _,
                            rejectWithValue: function (L, H) {
                              return new L_(L, H);
                            },
                            fulfillWithValue: function (L, H) {
                              return new bE(L, H);
                            },
                          })
                        ).then(function (L) {
                          if (L instanceof L_) throw L;
                          return L instanceof bE
                            ? i(L.payload, y, c, L.meta)
                            : i(L, y, c);
                        }),
                      ]),
                    ]
                  );
                case 3:
                  return (A = O.sent()), [3, 5];
                case 4:
                  return (
                    (P = O.sent()),
                    (A =
                      P instanceof L_
                        ? s(null, y, c, P.payload, P.meta)
                        : s(P, y, c)),
                    [3, 5]
                  );
                case 5:
                  return (
                    (U =
                      r &&
                      !r.dispatchConditionRejection &&
                      s.match(A) &&
                      A.meta.condition),
                    U || d(A),
                    [2, A]
                  );
              }
            });
          });
        })();
        return Object.assign(w, {
          abort: _,
          requestId: y,
          arg: c,
          unwrap: function () {
            return w.then(P4);
          },
        });
      };
    }
    return Object.assign(u, {
      pending: o,
      rejected: s,
      fulfilled: i,
      typePrefix: e,
    });
  }
  return (
    (n.withTypes = function () {
      return n;
    }),
    n
  );
})();
function P4(n) {
  if (n.meta && n.meta.rejectedWithValue) throw n.payload;
  if (n.error) throw n.error;
  return n.payload;
}
function I4(n) {
  return n !== null && typeof n == "object" && typeof n.then == "function";
}
var vw = "listenerMiddleware";
$u(vw + "/add");
$u(vw + "/removeAll");
$u(vw + "/remove");
var ME;
typeof queueMicrotask == "function" &&
  queueMicrotask.bind(
    typeof window < "u" ? window : typeof global < "u" ? global : globalThis
  );
ZF();
const L4 = {
    sender: null,
    receiver: null,
    tnxData: null,
    encryptedData: null,
    validator: null,
    validatorName: "",
    phase: "idle",
    transactionProgress: 0,
    deploying: !1,
    contractAnimation: !1,
    contractHash: null,
    contractDeployed: !1,
    smartContract: !1,
    winner: !1,
    initialContract: `// SPDX-License-Identifier: MIT
  pragma solidity ^0.8.0;
  
  contract PredictionBet {
      struct Bet {
          address player1;
          address player2;
          string question;
          string answer1; // player1's choice
          string answer2; // player2's choice
          uint256 amount;
          bool completed;
          address winner;
      }
  
      Bet public currentBet;
  
      uint256 public constant BET_AMOUNT = 100 wei;
  
      function createBet(
          address _player2,
          string memory _question,
          string memory _answer1,
          string memory _answer2
      ) external {
          require(_player2 != msg.sender, "Players must be different");
  
          currentBet = Bet({
              player1: msg.sender,
              player2: _player2,
              question: _question,
              answer1: _answer1,
              answer2: _answer2,
              amount: BET_AMOUNT,
              completed: false,
              winner: address(0)
          });
      }
  
      function declareWinner(address _winner) external {
          require(!currentBet.completed, "Already completed");
          require(
              _winner == currentBet.player1 || _winner == currentBet.player2,
              "Winner must be one of the players"
          );
  
          currentBet.completed = true;
          currentBet.winner = _winner;
      }
  }
  `,
    contractCode: `// SPDX-License-Identifier: MIT
  pragma solidity ^0.8.0;
  
  contract PredictionBet {
      struct Bet {
          address player1;
          address player2;
          string question;
          string answer1; // player1's choice
          string answer2; // player2's choice
          uint256 amount;
          bool completed;
          address winner;
      }
  
      Bet public currentBet;
  
      uint256 public constant BET_AMOUNT = 100 wei;
  
      function createBet(
          address _player2,
          string memory _question,
          string memory _answer1,
          string memory _answer2
      ) external {
          require(_player2 != msg.sender, "Players must be different");
  
          currentBet = Bet({
              player1: msg.sender,
              player2: _player2,
              question: _question,
              answer1: _answer1,
              answer2: _answer2,
              amount: BET_AMOUNT,
              completed: false,
              winner: address(0)
          });
      }
  
      function declareWinner(address _winner) external {
          require(!currentBet.completed, "Already completed");
          require(
              _winner == currentBet.player1 || _winner == currentBet.player2,
              "Winner must be one of the players"
          );
  
          currentBet.completed = true;
          currentBet.winner = _winner;
      }
  }
  `,
    showNetwork: !1,
  },
  yA = E4({
    name: "simulation",
    initialState: L4,
    reducers: {
      setSender: (n, e) => {
        (n.sender = e.payload), (n.validator = null);
      },
      setEncryptedData: (n, e) => {
        n.encryptedData = e.payload;
      },
      setReceiver: (n, e) => {
        (n.receiver = e.payload), (n.validator = null);
      },
      setTnxData: (n, e) => {
        n.tnxData = e.payload;
      },
      setValidator: (n, e) => {
        n.validator = e.payload;
      },
      startTransaction: (n) => {
        (n.phase = "transaction"), (n.transactionProgress = 0);
      },
      updateTransactionProgress: (n, e) => {
        n.transactionProgress = e.payload;
      },
      startValidation: (n) => {
        n.phase = "validation";
      },
      startBroadcast: (n) => {
        n.phase = "broadcast";
      },
      completeSimulation: (n) => {
        n.phase = "complete";
      },
      resetSimulation: (n) => {
        (n.sender = null),
          (n.receiver = null),
          (n.validator = null),
          (n.encryptedData = null),
          (n.tnxData = null),
          (n.phase = "idle"),
          (n.transactionProgress = 0);
      },
      startContractAnimation: (n, e) => {
        (n.contractAnimation = !0),
          (n.deploying = !0),
          (n.contractHash = e.payload);
      },
      endContractAnimation: (n) => {
        (n.contractAnimation = !1),
          (n.deploying = !1),
          (n.contractDeployed = !0);
      },
      showSmartContract: (n) => {
        n.smartContract = !0;
      },
      setBetGameWinner: (n, e) => {
        n.winner = e.payload;
      },
      setContractCode: (n, e) => {
        n.contractCode = e.payload;
      },
      showBlockchainNetwork: (n) => {
        n.showNetwork = !0;
      },
    },
  }),
  {
    showBlockchainNetwork: D4,
    startContractAnimation: k4,
    setBetGameWinner: EE,
    showSmartContract: O4,
    endContractAnimation: N4,
    setSender: D_,
    setReceiver: k_,
    setValidator: uS,
    startTransaction: U4,
    updateTransactionProgress: O_,
    startValidation: F4,
    startBroadcast: B4,
    completeSimulation: z4,
  } = yA.actions,
  H4 = yA.reducer,
  xA = S4({ reducer: { simulation: H4 } });
Array.from({ length: 10 }, (n, e) => ({ id: e, name: `User ${e + 1}` }));
function V4() {
  const n = OS(),
    {
      sender: e,
      receiver: t,
      validator: r,
      phase: i,
      showNetwork: o,
      contractDeployed: s,
      contractHash: a,
      smartContract: u,
      winner: c,
      initialContract: d,
    } = Qu((fe) => fe.simulation),
    [m, g] = X.useState(""),
    [y, x] = X.useState(""),
    [S, _] = X.useState(""),
    [w, T] = X.useState(""),
    [M, A] = X.useState(""),
    [R, D] = X.useState(""),
    [P, U] = X.useState(Boolean),
    [O, L] = X.useState(""),
    [H, W] = X.useState(""),
    [$, K] = X.useState(""),
    [Z, Y] = X.useState(!1),
    [re, G] = X.useState(""),
    [te, F] = X.useState(!0),
    [V, ne] = X.useState(!1),
    [ae, J] = X.useState(d);
  X.useEffect(() => {
    console.log("DEPLOYING CONTRACT", s), console.log("CONTRACT hash ", a);
  }, [s, a]),
    X.useEffect(() => {
      r !== null && ne(!0);
    }, [r]),
    X.useEffect(() => {
      n(uS(null));
    }, [i === "complete"]),
    X.useEffect(() => {
      s &&
        setTimeout(() => {
          Y(!0);
        }, 800);
    }, [s]);
  const se = () => {
      F(!1), e !== null && t !== null && r !== null && (n(U4()), n(uS(r)));
    },
    de = () => {
      n(D4()),
        U(!0),
        setTimeout(() => {
          const Me = `0x${Math.random().toString(36).substring(2, 10)}`;
          n(k4(Me));
        }, 2e3),
        setTimeout(() => {
          n(N4()), U(!1);
        }, 9e3);
    },
    le = () => {
      U(!0),
        setTimeout(() => {
          n(O4()), U(!1);
        }, 3e3);
    };
  return Q.jsxs(fn, {
    sx: {
      width: "100%",
      height: "100%",
      bgcolor: "#f5f5f5",
      p: { xs: 1.5, sm: 2 },
      pt: 4,
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: 3,
      overflowY: "auto",
      maxHeight: "100vh",
      ...(o === !1 && {
        justifyContent: "center",
        alignItems: "center",
        pt: 0,
      }),
    },
    children: [
      Q.jsx(fn, {
        sx: { width: "100%", maxWidth: 600, mb: 3 },
        children: Q.jsxs(lf, {
          elevation: 4,
          sx: {
            p: 3,
            borderRadius: 3,
            bgcolor: "#e8f5e9",
            border: "1px solid #c8e6c9",
          },
          children: [
            Q.jsx(vn, {
              variant: "h6",
              sx: {
                fontWeight: 700,
                mb: 2,
                color: "#1b5e20",
                textAlign: "center",
              },
              children: "Smart Contract Creation & Deployment Simulation",
            }),
            Q.jsx(vn, {
              variant: "body2",
              sx: { lineHeight: 1.8, fontWeight: 500, textAlign: "center" },
              color: "text.secondary",
              children:
                "Follow the steps below to create, deploy, and interact with the smart contract.",
            }),
            Q.jsxs(fn, {
              sx: {
                mt: 2,
                width: "100%",
                py: 1,
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
              },
              children: [
                Q.jsx(vn, {
                  variant: "h6",
                  sx: {
                    fontWeight: 600,
                    mb: 2,
                    textAlign: "center",
                    color: "text.primary",
                  },
                  children: "Step 1: Create Smart Contract",
                }),
                Q.jsx(vn, {
                  variant: "body2",
                  color: "text.secondary",
                  sx: { mb: 3, lineHeight: 1.6, maxWidth: 360, mx: "auto" },
                  children:
                    "Initialize the smart contract by generating the contract code before deployment.",
                }),
                Q.jsx(cm, {
                  disabled: u || P,
                  variant: "contained",
                  color: u || P ? "secondary" : "primary",
                  size: "large",
                  onClick: le,
                  sx: {
                    borderRadius: 3,
                    textTransform: "none",
                    fontWeight: 600,
                    px: 6,
                    py: 1.5,
                    boxShadow: 3,
                    "&:hover": { boxShadow: 6 },
                  },
                  children: P
                    ? "Creating Smart Contract..."
                    : "Create Smart Contract",
                }),
              ],
            }),
            u &&
              Q.jsxs(fn, {
                sx: {
                  mt: 3,
                  width: "100%",
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                },
                children: [
                  Q.jsx(vn, {
                    sx: { fontWeight: 600, mb: 1, textAlign: "center" },
                    children: "Step 2: Deploy Smart Contract",
                  }),
                  Q.jsx(vn, {
                    variant: "body2",
                    color: "text.secondary",
                    sx: { mb: 2, lineHeight: 1.6, maxWidth: 360, mx: "auto" },
                    children:
                      "Deploy the smart contract to the blockchain network to make it active and ready for transactions.",
                  }),
                  Q.jsx(fn, {
                    sx: {
                      display: "flex",
                      justifyContent: "center",
                      width: "100%",
                    },
                    children: Q.jsx(cm, {
                      disabled: ae !== d || s,
                      variant: "contained",
                      color: ae !== d || s ? "secondary" : "primary",
                      onClick: de,
                      sx: {
                        borderRadius: 2,
                        textTransform: "none",
                        fontWeight: 600,
                      },
                      children: P ? "Deploying..." : "Deploy",
                    }),
                  }),
                ],
              }),
            V &&
              Q.jsxs(fn, {
                sx: {
                  mt: 3,
                  width: "100%",
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                },
                children: [
                  Q.jsx(vn, {
                    sx: { fontWeight: 600, mb: 1, textAlign: "center" },
                    children: "Step 3: Initiate Transaction",
                  }),
                  Q.jsx(vn, {
                    variant: "body2",
                    sx: { mb: 2, lineHeight: 1.6, maxWidth: 360, mx: "auto" },
                    color: "text.secondary",
                    children:
                      "Send the reward amount to the winning participant.",
                  }),
                  Q.jsx(fn, {
                    sx: {
                      display: "flex",
                      justifyContent: "center",
                      width: "100%",
                    },
                    children: Q.jsx(cm, {
                      disabled: !s || !te,
                      variant: "contained",
                      color: "primary",
                      onClick: se,
                      sx: {
                        borderRadius: 2,
                        textTransform: "none",
                        fontWeight: 600,
                      },
                      children: "Initiate Transaction",
                    }),
                  }),
                ],
              }),
          ],
        }),
      }),
      Z &&
        Q.jsxs(fn, {
          sx: {
            p: 3,
            mb: 2,
            bgcolor: "#fff8e1",
            border: "1px solid #ffe0b2",
            borderRadius: 2,
            boxShadow: 1,
          },
          children: [
            Q.jsx(vn, {
              variant: "h5",
              sx: {
                fontWeight: 700,
                mb: 2,
                color: "#ff6f00",
                textAlign: "center",
              },
              children: "Introducing the Bet Game ",
            }),
            Q.jsx(vn, {
              variant: "body1",
              sx: {
                lineHeight: 1.7,
                whiteSpace: "pre-line",
                fontFamily: "Roboto, monospace",
                color: "#4e342e",
                mb: 2,
                textAlign: "center",
              },
              children: `We introduce a bet game to showcase transactions under a deployed smart contract.

Two players pick a question and select unique answers. When the Play button is clicked, one answer is randomly chosen. The selected player wins, and the reward is automatically transferred from the loser to the winner according to the smart contract.`,
            }),
          ],
        }),
    ],
  });
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const og = "167",
  rf = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  of = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  _A = 0,
  cS = 1,
  SA = 2,
  W4 = 3,
  wA = 0,
  Wy = 1,
  hm = 2,
  la = 3,
  el = 0,
  ro = 1,
  Ps = 2,
  Fl = 0,
  yf = 1,
  fS = 2,
  dS = 3,
  hS = 4,
  bA = 5,
  Wu = 100,
  MA = 101,
  EA = 102,
  TA = 103,
  CA = 104,
  AA = 200,
  RA = 201,
  PA = 202,
  IA = 203,
  H0 = 204,
  V0 = 205,
  LA = 206,
  DA = 207,
  kA = 208,
  OA = 209,
  NA = 210,
  UA = 211,
  FA = 212,
  BA = 213,
  zA = 214,
  HA = 0,
  VA = 1,
  WA = 2,
  Dm = 3,
  GA = 4,
  jA = 5,
  $A = 6,
  XA = 7,
  sg = 0,
  YA = 1,
  qA = 2,
  Za = 0,
  KA = 1,
  ZA = 2,
  JA = 3,
  yw = 4,
  QA = 5,
  eR = 6,
  tR = 7,
  pS = "attached",
  nR = "detached",
  Gy = 300,
  Hl = 301,
  Zu = 302,
  km = 303,
  Om = 304,
  Vh = 306,
  Nm = 1e3,
  Ls = 1001,
  Um = 1002,
  wi = 1003,
  xw = 1004,
  G4 = 1004,
  ph = 1005,
  j4 = 1005,
  Cr = 1006,
  pm = 1007,
  $4 = 1007,
  Xa = 1008,
  X4 = 1008,
  pa = 1009,
  _w = 1010,
  Sw = 1011,
  Ih = 1012,
  jy = 1013,
  Vl = 1014,
  Bo = 1015,
  Wh = 1016,
  $y = 1017,
  Xy = 1018,
  Cf = 1020,
  ww = 35902,
  bw = 1021,
  Mw = 1022,
  no = 1023,
  Ew = 1024,
  Tw = 1025,
  xf = 1026,
  Af = 1027,
  Yy = 1028,
  ag = 1029,
  Cw = 1030,
  qy = 1031,
  Y4 = 1032,
  Ky = 1033,
  mm = 33776,
  gm = 33777,
  vm = 33778,
  ym = 33779,
  W0 = 35840,
  G0 = 35841,
  j0 = 35842,
  $0 = 35843,
  X0 = 36196,
  Y0 = 37492,
  q0 = 37496,
  K0 = 37808,
  Z0 = 37809,
  J0 = 37810,
  Q0 = 37811,
  ey = 37812,
  ty = 37813,
  ny = 37814,
  ry = 37815,
  iy = 37816,
  oy = 37817,
  sy = 37818,
  ay = 37819,
  ly = 37820,
  uy = 37821,
  xm = 36492,
  cy = 36494,
  fy = 36495,
  Aw = 36283,
  dy = 36284,
  hy = 36285,
  py = 36286,
  rR = 2200,
  iR = 2201,
  oR = 2202,
  Fm = 2300,
  my = 2301,
  b0 = 2302,
  hf = 2400,
  pf = 2401,
  Bm = 2402,
  Zy = 2500,
  Rw = 2501,
  q4 = 0,
  K4 = 1,
  Z4 = 2,
  sR = 3200,
  Pw = 3201,
  J4 = 3202,
  Q4 = 3203,
  ec = 0,
  aR = 1,
  kl = "",
  As = "srgb",
  jl = "srgb-linear",
  Jy = "display-p3",
  lg = "display-p3-linear",
  zm = "linear",
  Jn = "srgb",
  Hm = "rec709",
  Vm = "p3",
  eB = 0,
  sf = 7680,
  tB = 7681,
  nB = 7682,
  rB = 7683,
  iB = 34055,
  oB = 34056,
  sB = 5386,
  aB = 512,
  lB = 513,
  uB = 514,
  cB = 515,
  fB = 516,
  dB = 517,
  hB = 518,
  mS = 519,
  lR = 512,
  uR = 513,
  cR = 514,
  Iw = 515,
  fR = 516,
  dR = 517,
  hR = 518,
  pR = 519,
  Wm = 35044,
  pB = 35048,
  mB = 35040,
  gB = 35045,
  vB = 35049,
  yB = 35041,
  xB = 35046,
  _B = 35050,
  SB = 35042,
  wB = "100",
  gS = "300 es",
  Ya = 2e3,
  Gm = 2001;
let $l = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
};
const Ki = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let TE = 1234567;
const _f = Math.PI / 180,
  Lh = 180 / Math.PI;
function us() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Ki[n & 255] +
    Ki[(n >> 8) & 255] +
    Ki[(n >> 16) & 255] +
    Ki[(n >> 24) & 255] +
    "-" +
    Ki[e & 255] +
    Ki[(e >> 8) & 255] +
    "-" +
    Ki[((e >> 16) & 15) | 64] +
    Ki[(e >> 24) & 255] +
    "-" +
    Ki[(t & 63) | 128] +
    Ki[(t >> 8) & 255] +
    "-" +
    Ki[(t >> 16) & 255] +
    Ki[(t >> 24) & 255] +
    Ki[r & 255] +
    Ki[(r >> 8) & 255] +
    Ki[(r >> 16) & 255] +
    Ki[(r >> 24) & 255]
  ).toLowerCase();
}
function Tr(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function Lw(n, e) {
  return ((n % e) + e) % e;
}
function bB(n, e, t, r, i) {
  return r + ((n - e) * (i - r)) / (t - e);
}
function MB(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function _m(n, e, t) {
  return (1 - t) * n + t * e;
}
function EB(n, e, t, r) {
  return _m(n, e, 1 - Math.exp(-t * r));
}
function TB(n, e = 1) {
  return e - Math.abs(Lw(n, e * 2) - e);
}
function CB(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function AB(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function RB(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function PB(n, e) {
  return n + Math.random() * (e - n);
}
function IB(n) {
  return n * (0.5 - Math.random());
}
function LB(n) {
  n !== void 0 && (TE = n);
  let e = (TE += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function DB(n) {
  return n * _f;
}
function kB(n) {
  return n * Lh;
}
function OB(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function NB(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function UB(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function FB(n, e, t, r, i) {
  const o = Math.cos,
    s = Math.sin,
    a = o(t / 2),
    u = s(t / 2),
    c = o((e + r) / 2),
    d = s((e + r) / 2),
    m = o((e - r) / 2),
    g = s((e - r) / 2),
    y = o((r - e) / 2),
    x = s((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(a * d, u * m, u * g, a * c);
      break;
    case "YZY":
      n.set(u * g, a * d, u * m, a * c);
      break;
    case "ZXZ":
      n.set(u * m, u * g, a * d, a * c);
      break;
    case "XZX":
      n.set(a * d, u * x, u * y, a * c);
      break;
    case "YXY":
      n.set(u * y, a * d, u * x, a * c);
      break;
    case "ZYZ":
      n.set(u * x, u * y, a * d, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function xo(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function on(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const mR = {
  DEG2RAD: _f,
  RAD2DEG: Lh,
  generateUUID: us,
  clamp: Tr,
  euclideanModulo: Lw,
  mapLinear: bB,
  inverseLerp: MB,
  lerp: _m,
  damp: EB,
  pingpong: TB,
  smoothstep: CB,
  smootherstep: AB,
  randInt: RB,
  randFloat: PB,
  randFloatSpread: IB,
  seededRandom: LB,
  degToRad: DB,
  radToDeg: kB,
  isPowerOfTwo: OB,
  ceilPowerOfTwo: NB,
  floorPowerOfTwo: UB,
  setQuaternionFromProperEuler: FB,
  normalize: on,
  denormalize: xo,
};
class tt {
  constructor(e = 0, t = 0) {
    (tt.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * r + i[6]),
      (this.y = i[1] * t + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Tr(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      o = this.x - e.x,
      s = this.y - e.y;
    return (this.x = o * r - s * i + e.x), (this.y = o * i + s * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class en {
  constructor(e, t, r, i, o, s, a, u, c) {
    (en.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, o, s, a, u, c);
  }
  set(e, t, r, i, o, s, a, u, c) {
    const d = this.elements;
    return (
      (d[0] = e),
      (d[1] = i),
      (d[2] = a),
      (d[3] = t),
      (d[4] = o),
      (d[5] = u),
      (d[6] = r),
      (d[7] = s),
      (d[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      o = this.elements,
      s = r[0],
      a = r[3],
      u = r[6],
      c = r[1],
      d = r[4],
      m = r[7],
      g = r[2],
      y = r[5],
      x = r[8],
      S = i[0],
      _ = i[3],
      w = i[6],
      T = i[1],
      M = i[4],
      A = i[7],
      R = i[2],
      D = i[5],
      P = i[8];
    return (
      (o[0] = s * S + a * T + u * R),
      (o[3] = s * _ + a * M + u * D),
      (o[6] = s * w + a * A + u * P),
      (o[1] = c * S + d * T + m * R),
      (o[4] = c * _ + d * M + m * D),
      (o[7] = c * w + d * A + m * P),
      (o[2] = g * S + y * T + x * R),
      (o[5] = g * _ + y * M + x * D),
      (o[8] = g * w + y * A + x * P),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      a = e[5],
      u = e[6],
      c = e[7],
      d = e[8];
    return (
      t * s * d - t * a * c - r * o * d + r * a * u + i * o * c - i * s * u
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      a = e[5],
      u = e[6],
      c = e[7],
      d = e[8],
      m = d * s - a * c,
      g = a * u - d * o,
      y = c * o - s * u,
      x = t * m + r * g + i * y;
    if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / x;
    return (
      (e[0] = m * S),
      (e[1] = (i * c - d * r) * S),
      (e[2] = (a * r - i * s) * S),
      (e[3] = g * S),
      (e[4] = (d * t - i * u) * S),
      (e[5] = (i * o - a * t) * S),
      (e[6] = y * S),
      (e[7] = (r * u - c * t) * S),
      (e[8] = (s * t - r * o) * S),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, i, o, s, a) {
    const u = Math.cos(o),
      c = Math.sin(o);
    return (
      this.set(
        r * u,
        r * c,
        -r * (u * s + c * a) + s + e,
        -i * c,
        i * u,
        -i * (-c * s + u * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(N_.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(N_.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(N_.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const N_ = new en();
function gR(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const BB = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function mh(n, e) {
  return new BB[n](e);
}
function jm(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function vR() {
  const n = jm("canvas");
  return (n.style.display = "block"), n;
}
const CE = {};
function Mh(n) {
  n in CE || ((CE[n] = !0), console.warn(n));
}
function zB(n, e, t) {
  return new Promise(function (r, i) {
    function o() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          i();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(o, t);
          break;
        default:
          r();
      }
    }
    setTimeout(o, t);
  });
}
const AE = new en().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  RE = new en().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  Bp = {
    [jl]: {
      transfer: zm,
      primaries: Hm,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (n) => n,
      fromReference: (n) => n,
    },
    [As]: {
      transfer: Jn,
      primaries: Hm,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (n) => n.convertSRGBToLinear(),
      fromReference: (n) => n.convertLinearToSRGB(),
    },
    [lg]: {
      transfer: zm,
      primaries: Vm,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (n) => n.applyMatrix3(RE),
      fromReference: (n) => n.applyMatrix3(AE),
    },
    [Jy]: {
      transfer: Jn,
      primaries: Vm,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (n) => n.convertSRGBToLinear().applyMatrix3(RE),
      fromReference: (n) => n.applyMatrix3(AE).convertLinearToSRGB(),
    },
  },
  HB = new Set([jl, lg]),
  Sn = {
    enabled: !0,
    _workingColorSpace: jl,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(n) {
      if (!HB.has(n))
        throw new Error(`Unsupported working color space, "${n}".`);
      this._workingColorSpace = n;
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const r = Bp[e].toReference,
        i = Bp[t].fromReference;
      return i(r(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this._workingColorSpace);
    },
    getPrimaries: function (n) {
      return Bp[n].primaries;
    },
    getTransfer: function (n) {
      return n === kl ? zm : Bp[n].transfer;
    },
    getLuminanceCoefficients: function (n, e = this._workingColorSpace) {
      return n.fromArray(Bp[e].luminanceCoefficients);
    },
  };
function Eh(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function U_(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let Fd;
class yR {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Fd === void 0 && (Fd = jm("canvas")),
        (Fd.width = e.width),
        (Fd.height = e.height);
      const r = Fd.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (t = Fd);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = jm("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        o = i.data;
      for (let s = 0; s < o.length; s++) o[s] = Eh(o[s] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(Eh(t[r] / 255) * 255))
          : (t[r] = Eh(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let VB = 0;
class mf {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: VB++ }),
      (this.uuid = us()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let s = 0, a = i.length; s < a; s++)
          i[s].isDataTexture ? o.push(F_(i[s].image)) : o.push(F_(i[s]));
      } else o = F_(i);
      r.url = o;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function F_(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? yR.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let WB = 0;
class er extends $l {
  constructor(
    e = er.DEFAULT_IMAGE,
    t = er.DEFAULT_MAPPING,
    r = Ls,
    i = Ls,
    o = Cr,
    s = Xa,
    a = no,
    u = pa,
    c = er.DEFAULT_ANISOTROPY,
    d = kl
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: WB++ }),
      (this.uuid = us()),
      (this.name = ""),
      (this.source = new mf(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = o),
      (this.minFilter = s),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = u),
      (this.offset = new tt(0, 0)),
      (this.repeat = new tt(1, 1)),
      (this.center = new tt(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new en()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = d),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Gy) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Nm:
          e.x = e.x - Math.floor(e.x);
          break;
        case Ls:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Um:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Nm:
          e.y = e.y - Math.floor(e.y);
          break;
        case Ls:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Um:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
er.DEFAULT_IMAGE = null;
er.DEFAULT_MAPPING = Gy;
er.DEFAULT_ANISOTROPY = 1;
class dn {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (dn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = this.w,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * r + s[8] * i + s[12] * o),
      (this.y = s[1] * t + s[5] * r + s[9] * i + s[13] * o),
      (this.z = s[2] * t + s[6] * r + s[10] * i + s[14] * o),
      (this.w = s[3] * t + s[7] * r + s[11] * i + s[15] * o),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, o;
    const u = e.elements,
      c = u[0],
      d = u[4],
      m = u[8],
      g = u[1],
      y = u[5],
      x = u[9],
      S = u[2],
      _ = u[6],
      w = u[10];
    if (
      Math.abs(d - g) < 0.01 &&
      Math.abs(m - S) < 0.01 &&
      Math.abs(x - _) < 0.01
    ) {
      if (
        Math.abs(d + g) < 0.1 &&
        Math.abs(m + S) < 0.1 &&
        Math.abs(x + _) < 0.1 &&
        Math.abs(c + y + w - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const M = (c + 1) / 2,
        A = (y + 1) / 2,
        R = (w + 1) / 2,
        D = (d + g) / 4,
        P = (m + S) / 4,
        U = (x + _) / 4;
      return (
        M > A && M > R
          ? M < 0.01
            ? ((r = 0), (i = 0.707106781), (o = 0.707106781))
            : ((r = Math.sqrt(M)), (i = D / r), (o = P / r))
          : A > R
          ? A < 0.01
            ? ((r = 0.707106781), (i = 0), (o = 0.707106781))
            : ((i = Math.sqrt(A)), (r = D / i), (o = U / i))
          : R < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (o = 0))
          : ((o = Math.sqrt(R)), (r = P / o), (i = U / o)),
        this.set(r, i, o, t),
        this
      );
    }
    let T = Math.sqrt(
      (_ - x) * (_ - x) + (m - S) * (m - S) + (g - d) * (g - d)
    );
    return (
      Math.abs(T) < 0.001 && (T = 1),
      (this.x = (_ - x) / T),
      (this.y = (m - S) / T),
      (this.z = (g - d) / T),
      (this.w = Math.acos((c + y + w - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class xR extends $l {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new dn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new dn(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    r = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Cr,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      r
    );
    const o = new er(
      i,
      r.mapping,
      r.wrapS,
      r.wrapT,
      r.magFilter,
      r.minFilter,
      r.format,
      r.type,
      r.anisotropy,
      r.colorSpace
    );
    (o.flipY = !1),
      (o.generateMipmaps = r.generateMipmaps),
      (o.internalFormat = r.internalFormat),
      (this.textures = []);
    const s = r.count;
    for (let a = 0; a < s; a++)
      (this.textures[a] = o.clone()),
        (this.textures[a].isRenderTargetTexture = !0);
    (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.resolveDepthBuffer = r.resolveDepthBuffer),
      (this.resolveStencilBuffer = r.resolveStencilBuffer),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      (this.width = e), (this.height = t), (this.depth = r);
      for (let i = 0, o = this.textures.length; i < o; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let r = 0, i = e.textures.length; r < i; r++)
      (this.textures[r] = e.textures[r].clone()),
        (this.textures[r].isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new mf(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ma extends xR {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), (this.isWebGLRenderTarget = !0);
  }
}
class Qy extends er {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = wi),
      (this.minFilter = wi),
      (this.wrapR = Ls),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class GB extends ma {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new Qy(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Dw extends er {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = wi),
      (this.minFilter = wi),
      (this.wrapR = Ls),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class jB extends ma {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new Dw(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class io {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, t, r, i, o, s, a) {
    let u = r[i + 0],
      c = r[i + 1],
      d = r[i + 2],
      m = r[i + 3];
    const g = o[s + 0],
      y = o[s + 1],
      x = o[s + 2],
      S = o[s + 3];
    if (a === 0) {
      (e[t + 0] = u), (e[t + 1] = c), (e[t + 2] = d), (e[t + 3] = m);
      return;
    }
    if (a === 1) {
      (e[t + 0] = g), (e[t + 1] = y), (e[t + 2] = x), (e[t + 3] = S);
      return;
    }
    if (m !== S || u !== g || c !== y || d !== x) {
      let _ = 1 - a;
      const w = u * g + c * y + d * x + m * S,
        T = w >= 0 ? 1 : -1,
        M = 1 - w * w;
      if (M > Number.EPSILON) {
        const R = Math.sqrt(M),
          D = Math.atan2(R, w * T);
        (_ = Math.sin(_ * D) / R), (a = Math.sin(a * D) / R);
      }
      const A = a * T;
      if (
        ((u = u * _ + g * A),
        (c = c * _ + y * A),
        (d = d * _ + x * A),
        (m = m * _ + S * A),
        _ === 1 - a)
      ) {
        const R = 1 / Math.sqrt(u * u + c * c + d * d + m * m);
        (u *= R), (c *= R), (d *= R), (m *= R);
      }
    }
    (e[t] = u), (e[t + 1] = c), (e[t + 2] = d), (e[t + 3] = m);
  }
  static multiplyQuaternionsFlat(e, t, r, i, o, s) {
    const a = r[i],
      u = r[i + 1],
      c = r[i + 2],
      d = r[i + 3],
      m = o[s],
      g = o[s + 1],
      y = o[s + 2],
      x = o[s + 3];
    return (
      (e[t] = a * x + d * m + u * y - c * g),
      (e[t + 1] = u * x + d * g + c * m - a * y),
      (e[t + 2] = c * x + d * y + a * g - u * m),
      (e[t + 3] = d * x - a * m - u * g - c * y),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._order,
      a = Math.cos,
      u = Math.sin,
      c = a(r / 2),
      d = a(i / 2),
      m = a(o / 2),
      g = u(r / 2),
      y = u(i / 2),
      x = u(o / 2);
    switch (s) {
      case "XYZ":
        (this._x = g * d * m + c * y * x),
          (this._y = c * y * m - g * d * x),
          (this._z = c * d * x + g * y * m),
          (this._w = c * d * m - g * y * x);
        break;
      case "YXZ":
        (this._x = g * d * m + c * y * x),
          (this._y = c * y * m - g * d * x),
          (this._z = c * d * x - g * y * m),
          (this._w = c * d * m + g * y * x);
        break;
      case "ZXY":
        (this._x = g * d * m - c * y * x),
          (this._y = c * y * m + g * d * x),
          (this._z = c * d * x + g * y * m),
          (this._w = c * d * m - g * y * x);
        break;
      case "ZYX":
        (this._x = g * d * m - c * y * x),
          (this._y = c * y * m + g * d * x),
          (this._z = c * d * x - g * y * m),
          (this._w = c * d * m + g * y * x);
        break;
      case "YZX":
        (this._x = g * d * m + c * y * x),
          (this._y = c * y * m + g * d * x),
          (this._z = c * d * x - g * y * m),
          (this._w = c * d * m - g * y * x);
        break;
      case "XZY":
        (this._x = g * d * m - c * y * x),
          (this._y = c * y * m - g * d * x),
          (this._z = c * d * x + g * y * m),
          (this._w = c * d * m + g * y * x);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      i = t[4],
      o = t[8],
      s = t[1],
      a = t[5],
      u = t[9],
      c = t[2],
      d = t[6],
      m = t[10],
      g = r + a + m;
    if (g > 0) {
      const y = 0.5 / Math.sqrt(g + 1);
      (this._w = 0.25 / y),
        (this._x = (d - u) * y),
        (this._y = (o - c) * y),
        (this._z = (s - i) * y);
    } else if (r > a && r > m) {
      const y = 2 * Math.sqrt(1 + r - a - m);
      (this._w = (d - u) / y),
        (this._x = 0.25 * y),
        (this._y = (i + s) / y),
        (this._z = (o + c) / y);
    } else if (a > m) {
      const y = 2 * Math.sqrt(1 + a - r - m);
      (this._w = (o - c) / y),
        (this._x = (i + s) / y),
        (this._y = 0.25 * y),
        (this._z = (u + d) / y);
    } else {
      const y = 2 * Math.sqrt(1 + m - r - a);
      (this._w = (s - i) / y),
        (this._x = (o + c) / y),
        (this._y = (u + d) / y),
        (this._z = 0.25 * y);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Tr(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._w,
      a = t._x,
      u = t._y,
      c = t._z,
      d = t._w;
    return (
      (this._x = r * d + s * a + i * c - o * u),
      (this._y = i * d + s * u + o * a - r * c),
      (this._z = o * d + s * c + r * u - i * a),
      (this._w = s * d - r * a - i * u - o * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      o = this._z,
      s = this._w;
    let a = s * e._w + r * e._x + i * e._y + o * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = s), (this._x = r), (this._y = i), (this._z = o), this;
    const u = 1 - a * a;
    if (u <= Number.EPSILON) {
      const y = 1 - t;
      return (
        (this._w = y * s + t * this._w),
        (this._x = y * r + t * this._x),
        (this._y = y * i + t * this._y),
        (this._z = y * o + t * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(u),
      d = Math.atan2(c, a),
      m = Math.sin((1 - t) * d) / c,
      g = Math.sin(t * d) / c;
    return (
      (this._w = s * m + this._w * g),
      (this._x = r * m + this._x * g),
      (this._y = i * m + this._y * g),
      (this._z = o * m + this._z * g),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      r = Math.random(),
      i = Math.sqrt(1 - r),
      o = Math.sqrt(r);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      o * Math.sin(t),
      o * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class oe {
  constructor(e = 0, t = 0, r = 0) {
    (oe.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(PE.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(PE.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[3] * r + o[6] * i),
      (this.y = o[1] * t + o[4] * r + o[7] * i),
      (this.z = o[2] * t + o[5] * r + o[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements,
      s = 1 / (o[3] * t + o[7] * r + o[11] * i + o[15]);
    return (
      (this.x = (o[0] * t + o[4] * r + o[8] * i + o[12]) * s),
      (this.y = (o[1] * t + o[5] * r + o[9] * i + o[13]) * s),
      (this.z = (o[2] * t + o[6] * r + o[10] * i + o[14]) * s),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.x,
      s = e.y,
      a = e.z,
      u = e.w,
      c = 2 * (s * i - a * r),
      d = 2 * (a * t - o * i),
      m = 2 * (o * r - s * t);
    return (
      (this.x = t + u * c + s * m - a * d),
      (this.y = r + u * d + a * c - o * m),
      (this.z = i + u * m + o * d - s * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * r + o[8] * i),
      (this.y = o[1] * t + o[5] * r + o[9] * i),
      (this.z = o[2] * t + o[6] * r + o[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = t.x,
      a = t.y,
      u = t.z;
    return (
      (this.x = i * u - o * a),
      (this.y = o * s - r * u),
      (this.z = r * a - i * s),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return B_.copy(this).projectOnVector(e), this.sub(B_);
  }
  reflect(e) {
    return this.sub(B_.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Tr(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      r = Math.sqrt(1 - t * t);
    return (
      (this.x = r * Math.cos(e)), (this.y = t), (this.z = r * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const B_ = new oe(),
  PE = new io();
class ci {
  constructor(
    e = new oe(1 / 0, 1 / 0, 1 / 0),
    t = new oe(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(oa.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(oa.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = oa.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const o = r.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let s = 0, a = o.count; s < a; s++)
          e.isMesh === !0
            ? e.getVertexPosition(s, oa)
            : oa.fromBufferAttribute(o, s),
            oa.applyMatrix4(e.matrixWorld),
            this.expandByPoint(oa);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            yv.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            yv.copy(r.boundingBox)),
          yv.applyMatrix4(e.matrixWorld),
          this.union(yv);
    }
    const i = e.children;
    for (let o = 0, s = i.length; o < s; o++) this.expandByObject(i[o], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, oa),
      oa.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(zp),
      xv.subVectors(this.max, zp),
      Bd.subVectors(e.a, zp),
      zd.subVectors(e.b, zp),
      Hd.subVectors(e.c, zp),
      Du.subVectors(zd, Bd),
      ku.subVectors(Hd, zd),
      Bc.subVectors(Bd, Hd);
    let t = [
      0,
      -Du.z,
      Du.y,
      0,
      -ku.z,
      ku.y,
      0,
      -Bc.z,
      Bc.y,
      Du.z,
      0,
      -Du.x,
      ku.z,
      0,
      -ku.x,
      Bc.z,
      0,
      -Bc.x,
      -Du.y,
      Du.x,
      0,
      -ku.y,
      ku.x,
      0,
      -Bc.y,
      Bc.x,
      0,
    ];
    return !z_(t, Bd, zd, Hd, xv) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !z_(t, Bd, zd, Hd, xv))
      ? !1
      : (_v.crossVectors(Du, ku),
        (t = [_v.x, _v.y, _v.z]),
        z_(t, Bd, zd, Hd, xv));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, oa).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(oa).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Tl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Tl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Tl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Tl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Tl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Tl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Tl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Tl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Tl),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Tl = [
    new oe(),
    new oe(),
    new oe(),
    new oe(),
    new oe(),
    new oe(),
    new oe(),
    new oe(),
  ],
  oa = new oe(),
  yv = new ci(),
  Bd = new oe(),
  zd = new oe(),
  Hd = new oe(),
  Du = new oe(),
  ku = new oe(),
  Bc = new oe(),
  zp = new oe(),
  xv = new oe(),
  _v = new oe(),
  zc = new oe();
function z_(n, e, t, r, i) {
  for (let o = 0, s = n.length - 3; o <= s; o += 3) {
    zc.fromArray(n, o);
    const a =
        i.x * Math.abs(zc.x) + i.y * Math.abs(zc.y) + i.z * Math.abs(zc.z),
      u = e.dot(zc),
      c = t.dot(zc),
      d = r.dot(zc);
    if (Math.max(-Math.max(u, c, d), Math.min(u, c, d)) > a) return !1;
  }
  return !0;
}
const $B = new ci(),
  Hp = new oe(),
  H_ = new oe();
class fi {
  constructor(e = new oe(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : $B.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let o = 0, s = e.length; o < s; o++)
      i = Math.max(i, r.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Hp.subVectors(e, this.center);
    const t = Hp.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(Hp, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (H_.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Hp.copy(e.center).add(H_)),
            this.expandByPoint(Hp.copy(e.center).sub(H_))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Cl = new oe(),
  V_ = new oe(),
  Sv = new oe(),
  Ou = new oe(),
  W_ = new oe(),
  wv = new oe(),
  G_ = new oe();
class Df {
  constructor(e = new oe(), t = new oe(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Cl)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Cl.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Cl.copy(this.origin).addScaledVector(this.direction, t),
        Cl.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    V_.copy(e).add(t).multiplyScalar(0.5),
      Sv.copy(t).sub(e).normalize(),
      Ou.copy(this.origin).sub(V_);
    const o = e.distanceTo(t) * 0.5,
      s = -this.direction.dot(Sv),
      a = Ou.dot(this.direction),
      u = -Ou.dot(Sv),
      c = Ou.lengthSq(),
      d = Math.abs(1 - s * s);
    let m, g, y, x;
    if (d > 0)
      if (((m = s * u - a), (g = s * a - u), (x = o * d), m >= 0))
        if (g >= -x)
          if (g <= x) {
            const S = 1 / d;
            (m *= S),
              (g *= S),
              (y = m * (m + s * g + 2 * a) + g * (s * m + g + 2 * u) + c);
          } else
            (g = o),
              (m = Math.max(0, -(s * g + a))),
              (y = -m * m + g * (g + 2 * u) + c);
        else
          (g = -o),
            (m = Math.max(0, -(s * g + a))),
            (y = -m * m + g * (g + 2 * u) + c);
      else
        g <= -x
          ? ((m = Math.max(0, -(-s * o + a))),
            (g = m > 0 ? -o : Math.min(Math.max(-o, -u), o)),
            (y = -m * m + g * (g + 2 * u) + c))
          : g <= x
          ? ((m = 0),
            (g = Math.min(Math.max(-o, -u), o)),
            (y = g * (g + 2 * u) + c))
          : ((m = Math.max(0, -(s * o + a))),
            (g = m > 0 ? o : Math.min(Math.max(-o, -u), o)),
            (y = -m * m + g * (g + 2 * u) + c));
    else
      (g = s > 0 ? -o : o),
        (m = Math.max(0, -(s * g + a))),
        (y = -m * m + g * (g + 2 * u) + c);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, m),
      i && i.copy(V_).addScaledVector(Sv, g),
      y
    );
  }
  intersectSphere(e, t) {
    Cl.subVectors(e.center, this.origin);
    const r = Cl.dot(this.direction),
      i = Cl.dot(Cl) - r * r,
      o = e.radius * e.radius;
    if (i > o) return null;
    const s = Math.sqrt(o - i),
      a = r - s,
      u = r + s;
    return u < 0 ? null : a < 0 ? this.at(u, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, o, s, a, u;
    const c = 1 / this.direction.x,
      d = 1 / this.direction.y,
      m = 1 / this.direction.z,
      g = this.origin;
    return (
      c >= 0
        ? ((r = (e.min.x - g.x) * c), (i = (e.max.x - g.x) * c))
        : ((r = (e.max.x - g.x) * c), (i = (e.min.x - g.x) * c)),
      d >= 0
        ? ((o = (e.min.y - g.y) * d), (s = (e.max.y - g.y) * d))
        : ((o = (e.max.y - g.y) * d), (s = (e.min.y - g.y) * d)),
      r > s ||
      o > i ||
      ((o > r || isNaN(r)) && (r = o),
      (s < i || isNaN(i)) && (i = s),
      m >= 0
        ? ((a = (e.min.z - g.z) * m), (u = (e.max.z - g.z) * m))
        : ((a = (e.max.z - g.z) * m), (u = (e.min.z - g.z) * m)),
      r > u || a > i) ||
      ((a > r || r !== r) && (r = a), (u < i || i !== i) && (i = u), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Cl) !== null;
  }
  intersectTriangle(e, t, r, i, o) {
    W_.subVectors(t, e), wv.subVectors(r, e), G_.crossVectors(W_, wv);
    let s = this.direction.dot(G_),
      a;
    if (s > 0) {
      if (i) return null;
      a = 1;
    } else if (s < 0) (a = -1), (s = -s);
    else return null;
    Ou.subVectors(this.origin, e);
    const u = a * this.direction.dot(wv.crossVectors(Ou, wv));
    if (u < 0) return null;
    const c = a * this.direction.dot(W_.cross(Ou));
    if (c < 0 || u + c > s) return null;
    const d = -a * Ou.dot(G_);
    return d < 0 ? null : this.at(d / s, o);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Gt {
  constructor(e, t, r, i, o, s, a, u, c, d, m, g, y, x, S, _) {
    (Gt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, o, s, a, u, c, d, m, g, y, x, S, _);
  }
  set(e, t, r, i, o, s, a, u, c, d, m, g, y, x, S, _) {
    const w = this.elements;
    return (
      (w[0] = e),
      (w[4] = t),
      (w[8] = r),
      (w[12] = i),
      (w[1] = o),
      (w[5] = s),
      (w[9] = a),
      (w[13] = u),
      (w[2] = c),
      (w[6] = d),
      (w[10] = m),
      (w[14] = g),
      (w[3] = y),
      (w[7] = x),
      (w[11] = S),
      (w[15] = _),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Gt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      i = 1 / Vd.setFromMatrixColumn(e, 0).length(),
      o = 1 / Vd.setFromMatrixColumn(e, 1).length(),
      s = 1 / Vd.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * i),
      (t[1] = r[1] * i),
      (t[2] = r[2] * i),
      (t[3] = 0),
      (t[4] = r[4] * o),
      (t[5] = r[5] * o),
      (t[6] = r[6] * o),
      (t[7] = 0),
      (t[8] = r[8] * s),
      (t[9] = r[9] * s),
      (t[10] = r[10] * s),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      o = e.z,
      s = Math.cos(r),
      a = Math.sin(r),
      u = Math.cos(i),
      c = Math.sin(i),
      d = Math.cos(o),
      m = Math.sin(o);
    if (e.order === "XYZ") {
      const g = s * d,
        y = s * m,
        x = a * d,
        S = a * m;
      (t[0] = u * d),
        (t[4] = -u * m),
        (t[8] = c),
        (t[1] = y + x * c),
        (t[5] = g - S * c),
        (t[9] = -a * u),
        (t[2] = S - g * c),
        (t[6] = x + y * c),
        (t[10] = s * u);
    } else if (e.order === "YXZ") {
      const g = u * d,
        y = u * m,
        x = c * d,
        S = c * m;
      (t[0] = g + S * a),
        (t[4] = x * a - y),
        (t[8] = s * c),
        (t[1] = s * m),
        (t[5] = s * d),
        (t[9] = -a),
        (t[2] = y * a - x),
        (t[6] = S + g * a),
        (t[10] = s * u);
    } else if (e.order === "ZXY") {
      const g = u * d,
        y = u * m,
        x = c * d,
        S = c * m;
      (t[0] = g - S * a),
        (t[4] = -s * m),
        (t[8] = x + y * a),
        (t[1] = y + x * a),
        (t[5] = s * d),
        (t[9] = S - g * a),
        (t[2] = -s * c),
        (t[6] = a),
        (t[10] = s * u);
    } else if (e.order === "ZYX") {
      const g = s * d,
        y = s * m,
        x = a * d,
        S = a * m;
      (t[0] = u * d),
        (t[4] = x * c - y),
        (t[8] = g * c + S),
        (t[1] = u * m),
        (t[5] = S * c + g),
        (t[9] = y * c - x),
        (t[2] = -c),
        (t[6] = a * u),
        (t[10] = s * u);
    } else if (e.order === "YZX") {
      const g = s * u,
        y = s * c,
        x = a * u,
        S = a * c;
      (t[0] = u * d),
        (t[4] = S - g * m),
        (t[8] = x * m + y),
        (t[1] = m),
        (t[5] = s * d),
        (t[9] = -a * d),
        (t[2] = -c * d),
        (t[6] = y * m + x),
        (t[10] = g - S * m);
    } else if (e.order === "XZY") {
      const g = s * u,
        y = s * c,
        x = a * u,
        S = a * c;
      (t[0] = u * d),
        (t[4] = -m),
        (t[8] = c * d),
        (t[1] = g * m + S),
        (t[5] = s * d),
        (t[9] = y * m - x),
        (t[2] = x * m - y),
        (t[6] = a * d),
        (t[10] = S * m + g);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(XB, e, YB);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return (
      rs.subVectors(e, t),
      rs.lengthSq() === 0 && (rs.z = 1),
      rs.normalize(),
      Nu.crossVectors(r, rs),
      Nu.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (rs.x += 1e-4) : (rs.z += 1e-4),
        rs.normalize(),
        Nu.crossVectors(r, rs)),
      Nu.normalize(),
      bv.crossVectors(rs, Nu),
      (i[0] = Nu.x),
      (i[4] = bv.x),
      (i[8] = rs.x),
      (i[1] = Nu.y),
      (i[5] = bv.y),
      (i[9] = rs.y),
      (i[2] = Nu.z),
      (i[6] = bv.z),
      (i[10] = rs.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      o = this.elements,
      s = r[0],
      a = r[4],
      u = r[8],
      c = r[12],
      d = r[1],
      m = r[5],
      g = r[9],
      y = r[13],
      x = r[2],
      S = r[6],
      _ = r[10],
      w = r[14],
      T = r[3],
      M = r[7],
      A = r[11],
      R = r[15],
      D = i[0],
      P = i[4],
      U = i[8],
      O = i[12],
      L = i[1],
      H = i[5],
      W = i[9],
      $ = i[13],
      K = i[2],
      Z = i[6],
      Y = i[10],
      re = i[14],
      G = i[3],
      te = i[7],
      F = i[11],
      V = i[15];
    return (
      (o[0] = s * D + a * L + u * K + c * G),
      (o[4] = s * P + a * H + u * Z + c * te),
      (o[8] = s * U + a * W + u * Y + c * F),
      (o[12] = s * O + a * $ + u * re + c * V),
      (o[1] = d * D + m * L + g * K + y * G),
      (o[5] = d * P + m * H + g * Z + y * te),
      (o[9] = d * U + m * W + g * Y + y * F),
      (o[13] = d * O + m * $ + g * re + y * V),
      (o[2] = x * D + S * L + _ * K + w * G),
      (o[6] = x * P + S * H + _ * Z + w * te),
      (o[10] = x * U + S * W + _ * Y + w * F),
      (o[14] = x * O + S * $ + _ * re + w * V),
      (o[3] = T * D + M * L + A * K + R * G),
      (o[7] = T * P + M * H + A * Z + R * te),
      (o[11] = T * U + M * W + A * Y + R * F),
      (o[15] = T * O + M * $ + A * re + R * V),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      i = e[8],
      o = e[12],
      s = e[1],
      a = e[5],
      u = e[9],
      c = e[13],
      d = e[2],
      m = e[6],
      g = e[10],
      y = e[14],
      x = e[3],
      S = e[7],
      _ = e[11],
      w = e[15];
    return (
      x *
        (+o * u * m -
          i * c * m -
          o * a * g +
          r * c * g +
          i * a * y -
          r * u * y) +
      S *
        (+t * u * y -
          t * c * g +
          o * s * g -
          i * s * y +
          i * c * d -
          o * u * d) +
      _ *
        (+t * c * m -
          t * a * y -
          o * s * m +
          r * s * y +
          o * a * d -
          r * c * d) +
      w *
        (-i * a * d - t * u * m + t * a * g + i * s * m - r * s * g + r * u * d)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      a = e[5],
      u = e[6],
      c = e[7],
      d = e[8],
      m = e[9],
      g = e[10],
      y = e[11],
      x = e[12],
      S = e[13],
      _ = e[14],
      w = e[15],
      T = m * _ * c - S * g * c + S * u * y - a * _ * y - m * u * w + a * g * w,
      M = x * g * c - d * _ * c - x * u * y + s * _ * y + d * u * w - s * g * w,
      A = d * S * c - x * m * c + x * a * y - s * S * y - d * a * w + s * m * w,
      R = x * m * u - d * S * u - x * a * g + s * S * g + d * a * _ - s * m * _,
      D = t * T + r * M + i * A + o * R;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / D;
    return (
      (e[0] = T * P),
      (e[1] =
        (S * g * o -
          m * _ * o -
          S * i * y +
          r * _ * y +
          m * i * w -
          r * g * w) *
        P),
      (e[2] =
        (a * _ * o -
          S * u * o +
          S * i * c -
          r * _ * c -
          a * i * w +
          r * u * w) *
        P),
      (e[3] =
        (m * u * o -
          a * g * o -
          m * i * c +
          r * g * c +
          a * i * y -
          r * u * y) *
        P),
      (e[4] = M * P),
      (e[5] =
        (d * _ * o -
          x * g * o +
          x * i * y -
          t * _ * y -
          d * i * w +
          t * g * w) *
        P),
      (e[6] =
        (x * u * o -
          s * _ * o -
          x * i * c +
          t * _ * c +
          s * i * w -
          t * u * w) *
        P),
      (e[7] =
        (s * g * o -
          d * u * o +
          d * i * c -
          t * g * c -
          s * i * y +
          t * u * y) *
        P),
      (e[8] = A * P),
      (e[9] =
        (x * m * o -
          d * S * o -
          x * r * y +
          t * S * y +
          d * r * w -
          t * m * w) *
        P),
      (e[10] =
        (s * S * o -
          x * a * o +
          x * r * c -
          t * S * c -
          s * r * w +
          t * a * w) *
        P),
      (e[11] =
        (d * a * o -
          s * m * o -
          d * r * c +
          t * m * c +
          s * r * y -
          t * a * y) *
        P),
      (e[12] = R * P),
      (e[13] =
        (d * S * i -
          x * m * i +
          x * r * g -
          t * S * g -
          d * r * _ +
          t * m * _) *
        P),
      (e[14] =
        (x * a * i -
          s * S * i -
          x * r * u +
          t * S * u +
          s * r * _ -
          t * a * _) *
        P),
      (e[15] =
        (s * m * i -
          d * a * i +
          d * r * u -
          t * m * u -
          s * r * g +
          t * a * g) *
        P),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      o = e.z;
    return (
      (t[0] *= r),
      (t[4] *= i),
      (t[8] *= o),
      (t[1] *= r),
      (t[5] *= i),
      (t[9] *= o),
      (t[2] *= r),
      (t[6] *= i),
      (t[10] *= o),
      (t[3] *= r),
      (t[7] *= i),
      (t[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      o = 1 - r,
      s = e.x,
      a = e.y,
      u = e.z,
      c = o * s,
      d = o * a;
    return (
      this.set(
        c * s + r,
        c * a - i * u,
        c * u + i * a,
        0,
        c * a + i * u,
        d * a + r,
        d * u - i * s,
        0,
        c * u - i * a,
        d * u + i * s,
        o * u * u + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, i, o, s) {
    return this.set(1, r, o, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const i = this.elements,
      o = t._x,
      s = t._y,
      a = t._z,
      u = t._w,
      c = o + o,
      d = s + s,
      m = a + a,
      g = o * c,
      y = o * d,
      x = o * m,
      S = s * d,
      _ = s * m,
      w = a * m,
      T = u * c,
      M = u * d,
      A = u * m,
      R = r.x,
      D = r.y,
      P = r.z;
    return (
      (i[0] = (1 - (S + w)) * R),
      (i[1] = (y + A) * R),
      (i[2] = (x - M) * R),
      (i[3] = 0),
      (i[4] = (y - A) * D),
      (i[5] = (1 - (g + w)) * D),
      (i[6] = (_ + T) * D),
      (i[7] = 0),
      (i[8] = (x + M) * P),
      (i[9] = (_ - T) * P),
      (i[10] = (1 - (g + S)) * P),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const i = this.elements;
    let o = Vd.set(i[0], i[1], i[2]).length();
    const s = Vd.set(i[4], i[5], i[6]).length(),
      a = Vd.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      sa.copy(this);
    const c = 1 / o,
      d = 1 / s,
      m = 1 / a;
    return (
      (sa.elements[0] *= c),
      (sa.elements[1] *= c),
      (sa.elements[2] *= c),
      (sa.elements[4] *= d),
      (sa.elements[5] *= d),
      (sa.elements[6] *= d),
      (sa.elements[8] *= m),
      (sa.elements[9] *= m),
      (sa.elements[10] *= m),
      t.setFromRotationMatrix(sa),
      (r.x = o),
      (r.y = s),
      (r.z = a),
      this
    );
  }
  makePerspective(e, t, r, i, o, s, a = Ya) {
    const u = this.elements,
      c = (2 * o) / (t - e),
      d = (2 * o) / (r - i),
      m = (t + e) / (t - e),
      g = (r + i) / (r - i);
    let y, x;
    if (a === Ya) (y = -(s + o) / (s - o)), (x = (-2 * s * o) / (s - o));
    else if (a === Gm) (y = -s / (s - o)), (x = (-s * o) / (s - o));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (u[0] = c),
      (u[4] = 0),
      (u[8] = m),
      (u[12] = 0),
      (u[1] = 0),
      (u[5] = d),
      (u[9] = g),
      (u[13] = 0),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = y),
      (u[14] = x),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = -1),
      (u[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, i, o, s, a = Ya) {
    const u = this.elements,
      c = 1 / (t - e),
      d = 1 / (r - i),
      m = 1 / (s - o),
      g = (t + e) * c,
      y = (r + i) * d;
    let x, S;
    if (a === Ya) (x = (s + o) * m), (S = -2 * m);
    else if (a === Gm) (x = o * m), (S = -1 * m);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (u[0] = 2 * c),
      (u[4] = 0),
      (u[8] = 0),
      (u[12] = -g),
      (u[1] = 0),
      (u[5] = 2 * d),
      (u[9] = 0),
      (u[13] = -y),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = S),
      (u[14] = -x),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = 0),
      (u[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const Vd = new oe(),
  sa = new Gt(),
  XB = new oe(0, 0, 0),
  YB = new oe(1, 1, 1),
  Nu = new oe(),
  bv = new oe(),
  rs = new oe(),
  IE = new Gt(),
  LE = new io();
class fs {
  constructor(e = 0, t = 0, r = 0, i = fs.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements,
      o = i[0],
      s = i[4],
      a = i[8],
      u = i[1],
      c = i[5],
      d = i[9],
      m = i[2],
      g = i[6],
      y = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Tr(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-d, y)), (this._z = Math.atan2(-s, o)))
            : ((this._x = Math.atan2(g, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Tr(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(a, y)), (this._z = Math.atan2(u, c)))
            : ((this._y = Math.atan2(-m, o)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Tr(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._y = Math.atan2(-m, y)), (this._z = Math.atan2(-s, c)))
            : ((this._y = 0), (this._z = Math.atan2(u, o)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Tr(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._x = Math.atan2(g, y)), (this._z = Math.atan2(u, o)))
            : ((this._x = 0), (this._z = Math.atan2(-s, c)));
        break;
      case "YZX":
        (this._z = Math.asin(Tr(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-d, c)), (this._y = Math.atan2(-m, o)))
            : ((this._x = 0), (this._y = Math.atan2(a, y)));
        break;
      case "XZY":
        (this._z = Math.asin(-Tr(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(g, c)), (this._y = Math.atan2(a, o)))
            : ((this._x = Math.atan2(-d, y)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      IE.makeRotationFromQuaternion(e), this.setFromRotationMatrix(IE, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return LE.setFromEuler(this), this.setFromQuaternion(LE, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
fs.DEFAULT_ORDER = "XYZ";
class Sf {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let qB = 0;
const DE = new oe(),
  Wd = new io(),
  Al = new Gt(),
  Mv = new oe(),
  Vp = new oe(),
  KB = new oe(),
  ZB = new io(),
  kE = new oe(1, 0, 0),
  OE = new oe(0, 1, 0),
  NE = new oe(0, 0, 1),
  UE = { type: "added" },
  JB = { type: "removed" },
  Gd = { type: "childadded", child: null },
  j_ = { type: "childremoved", child: null };
class wn extends $l {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: qB++ }),
      (this.uuid = us()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = wn.DEFAULT_UP.clone());
    const e = new oe(),
      t = new fs(),
      r = new io(),
      i = new oe(1, 1, 1);
    function o() {
      r.setFromEuler(t, !1);
    }
    function s() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(o),
      r._onChange(s),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Gt() },
        normalMatrix: { value: new en() },
      }),
      (this.matrix = new Gt()),
      (this.matrixWorld = new Gt()),
      (this.matrixAutoUpdate = wn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Sf()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Wd.setFromAxisAngle(e, t), this.quaternion.multiply(Wd), this;
  }
  rotateOnWorldAxis(e, t) {
    return Wd.setFromAxisAngle(e, t), this.quaternion.premultiply(Wd), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(kE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(OE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(NE, e);
  }
  translateOnAxis(e, t) {
    return (
      DE.copy(e).applyQuaternion(this.quaternion),
      this.position.add(DE.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(kE, e);
  }
  translateY(e) {
    return this.translateOnAxis(OE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(NE, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Al.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? Mv.copy(e) : Mv.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Vp.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Al.lookAt(Vp, Mv, this.up)
        : Al.lookAt(Mv, Vp, this.up),
      this.quaternion.setFromRotationMatrix(Al),
      i &&
        (Al.extractRotation(i.matrixWorld),
        Wd.setFromRotationMatrix(Al),
        this.quaternion.premultiply(Wd.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(UE),
            (Gd.child = e),
            this.dispatchEvent(Gd),
            (Gd.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(JB),
        (j_.child = e),
        this.dispatchEvent(j_),
        (j_.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Al.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Al.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Al),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(UE),
      (Gd.child = e),
      this.dispatchEvent(Gd),
      (Gd.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const s = this.children[r].getObjectByProperty(e, t);
      if (s !== void 0) return s;
    }
  }
  getObjectsByProperty(e, t, r = []) {
    this[e] === t && r.push(this);
    const i = this.children;
    for (let o = 0, s = i.length; o < s; o++)
      i[o].getObjectsByProperty(e, t, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Vp, e, KB), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Vp, ZB, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const i = this.children;
      for (let o = 0, s = i.length; o < s; o++) i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function o(a, u) {
      return a[u.uuid] === void 0 && (a[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const u = a.shapes;
        if (Array.isArray(u))
          for (let c = 0, d = u.length; c < d; c++) {
            const m = u[c];
            o(e.shapes, m);
          }
        else o(e.shapes, u);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          a.push(o(e.materials, this.material[u]));
        i.material = a;
      } else i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const u = this.animations[a];
        i.animations.push(o(e.animations, u));
      }
    }
    if (t) {
      const a = s(e.geometries),
        u = s(e.materials),
        c = s(e.textures),
        d = s(e.images),
        m = s(e.shapes),
        g = s(e.skeletons),
        y = s(e.animations),
        x = s(e.nodes);
      a.length > 0 && (r.geometries = a),
        u.length > 0 && (r.materials = u),
        c.length > 0 && (r.textures = c),
        d.length > 0 && (r.images = d),
        m.length > 0 && (r.shapes = m),
        g.length > 0 && (r.skeletons = g),
        y.length > 0 && (r.animations = y),
        x.length > 0 && (r.nodes = x);
    }
    return (r.object = i), r;
    function s(a) {
      const u = [];
      for (const c in a) {
        const d = a[c];
        delete d.metadata, u.push(d);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
wn.DEFAULT_UP = new oe(0, 1, 0);
wn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const aa = new oe(),
  Rl = new oe(),
  $_ = new oe(),
  Pl = new oe(),
  jd = new oe(),
  $d = new oe(),
  FE = new oe(),
  X_ = new oe(),
  Y_ = new oe(),
  q_ = new oe();
class ss {
  constructor(e = new oe(), t = new oe(), r = new oe()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), aa.subVectors(e, t), i.cross(aa);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, o) {
    aa.subVectors(i, t), Rl.subVectors(r, t), $_.subVectors(e, t);
    const s = aa.dot(aa),
      a = aa.dot(Rl),
      u = aa.dot($_),
      c = Rl.dot(Rl),
      d = Rl.dot($_),
      m = s * c - a * a;
    if (m === 0) return o.set(0, 0, 0), null;
    const g = 1 / m,
      y = (c * u - a * d) * g,
      x = (s * d - a * u) * g;
    return o.set(1 - y - x, x, y);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, Pl) === null
      ? !1
      : Pl.x >= 0 && Pl.y >= 0 && Pl.x + Pl.y <= 1;
  }
  static getInterpolation(e, t, r, i, o, s, a, u) {
    return this.getBarycoord(e, t, r, i, Pl) === null
      ? ((u.x = 0),
        (u.y = 0),
        "z" in u && (u.z = 0),
        "w" in u && (u.w = 0),
        null)
      : (u.setScalar(0),
        u.addScaledVector(o, Pl.x),
        u.addScaledVector(s, Pl.y),
        u.addScaledVector(a, Pl.z),
        u);
  }
  static isFrontFacing(e, t, r, i) {
    return aa.subVectors(r, t), Rl.subVectors(e, t), aa.cross(Rl).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      aa.subVectors(this.c, this.b),
      Rl.subVectors(this.a, this.b),
      aa.cross(Rl).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ss.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ss.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, r, i, o) {
    return ss.getInterpolation(e, this.a, this.b, this.c, t, r, i, o);
  }
  containsPoint(e) {
    return ss.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ss.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      i = this.b,
      o = this.c;
    let s, a;
    jd.subVectors(i, r), $d.subVectors(o, r), X_.subVectors(e, r);
    const u = jd.dot(X_),
      c = $d.dot(X_);
    if (u <= 0 && c <= 0) return t.copy(r);
    Y_.subVectors(e, i);
    const d = jd.dot(Y_),
      m = $d.dot(Y_);
    if (d >= 0 && m <= d) return t.copy(i);
    const g = u * m - d * c;
    if (g <= 0 && u >= 0 && d <= 0)
      return (s = u / (u - d)), t.copy(r).addScaledVector(jd, s);
    q_.subVectors(e, o);
    const y = jd.dot(q_),
      x = $d.dot(q_);
    if (x >= 0 && y <= x) return t.copy(o);
    const S = y * c - u * x;
    if (S <= 0 && c >= 0 && x <= 0)
      return (a = c / (c - x)), t.copy(r).addScaledVector($d, a);
    const _ = d * x - y * m;
    if (_ <= 0 && m - d >= 0 && y - x >= 0)
      return (
        FE.subVectors(o, i),
        (a = (m - d) / (m - d + (y - x))),
        t.copy(i).addScaledVector(FE, a)
      );
    const w = 1 / (_ + S + g);
    return (
      (s = S * w),
      (a = g * w),
      t.copy(r).addScaledVector(jd, s).addScaledVector($d, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const _R = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Uu = { h: 0, s: 0, l: 0 },
  Ev = { h: 0, s: 0, l: 0 };
function K_(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class St {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = As) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Sn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, r, i = Sn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      Sn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, r, i = Sn.workingColorSpace) {
    if (((e = Lw(e, 1)), (t = Tr(t, 0, 1)), (r = Tr(r, 0, 1)), t === 0))
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        s = 2 * r - o;
      (this.r = K_(s, o, e + 1 / 3)),
        (this.g = K_(s, o, e)),
        (this.b = K_(s, o, e - 1 / 3));
    }
    return Sn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = As) {
    function r(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let o;
      const s = i[1],
        a = i[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (
            (o =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(255, parseInt(o[1], 10)) / 255,
                Math.min(255, parseInt(o[2], 10)) / 255,
                Math.min(255, parseInt(o[3], 10)) / 255,
                t
              )
            );
          if (
            (o =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(100, parseInt(o[1], 10)) / 100,
                Math.min(100, parseInt(o[2], 10)) / 100,
                Math.min(100, parseInt(o[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(o[4]),
              this.setHSL(
                parseFloat(o[1]) / 360,
                parseFloat(o[2]) / 100,
                parseFloat(o[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = i[1],
        s = o.length;
      if (s === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (s === 6) return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = As) {
    const r = _R[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Eh(e.r)), (this.g = Eh(e.g)), (this.b = Eh(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = U_(e.r)), (this.g = U_(e.g)), (this.b = U_(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = As) {
    return (
      Sn.fromWorkingColorSpace(Zi.copy(this), e),
      Math.round(Tr(Zi.r * 255, 0, 255)) * 65536 +
        Math.round(Tr(Zi.g * 255, 0, 255)) * 256 +
        Math.round(Tr(Zi.b * 255, 0, 255))
    );
  }
  getHexString(e = As) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Sn.workingColorSpace) {
    Sn.fromWorkingColorSpace(Zi.copy(this), t);
    const r = Zi.r,
      i = Zi.g,
      o = Zi.b,
      s = Math.max(r, i, o),
      a = Math.min(r, i, o);
    let u, c;
    const d = (a + s) / 2;
    if (a === s) (u = 0), (c = 0);
    else {
      const m = s - a;
      switch (((c = d <= 0.5 ? m / (s + a) : m / (2 - s - a)), s)) {
        case r:
          u = (i - o) / m + (i < o ? 6 : 0);
          break;
        case i:
          u = (o - r) / m + 2;
          break;
        case o:
          u = (r - i) / m + 4;
          break;
      }
      u /= 6;
    }
    return (e.h = u), (e.s = c), (e.l = d), e;
  }
  getRGB(e, t = Sn.workingColorSpace) {
    return (
      Sn.fromWorkingColorSpace(Zi.copy(this), t),
      (e.r = Zi.r),
      (e.g = Zi.g),
      (e.b = Zi.b),
      e
    );
  }
  getStyle(e = As) {
    Sn.fromWorkingColorSpace(Zi.copy(this), e);
    const t = Zi.r,
      r = Zi.g,
      i = Zi.b;
    return e !== As
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(Uu), this.setHSL(Uu.h + e, Uu.s + t, Uu.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Uu), e.getHSL(Ev);
    const r = _m(Uu.h, Ev.h, t),
      i = _m(Uu.s, Ev.s, t),
      o = _m(Uu.l, Ev.l, t);
    return this.setHSL(r, i, o), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      i = this.b,
      o = e.elements;
    return (
      (this.r = o[0] * t + o[3] * r + o[6] * i),
      (this.g = o[1] * t + o[4] * r + o[7] * i),
      (this.b = o[2] * t + o[5] * r + o[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Zi = new St();
St.NAMES = _R;
let QB = 0;
class zi extends $l {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: QB++ }),
      (this.uuid = us()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = yf),
      (this.side = el),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = H0),
      (this.blendDst = V0),
      (this.blendEquation = Wu),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new St(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Dm),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = mS),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = sf),
      (this.stencilZFail = sf),
      (this.stencilZPass = sf),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (r.dispersion = this.dispersion),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (r.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== yf && (r.blending = this.blending),
      this.side !== el && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== H0 && (r.blendSrc = this.blendSrc),
      this.blendDst !== V0 && (r.blendDst = this.blendDst),
      this.blendEquation !== Wu && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== Dm && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== mS && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== sf && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== sf && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== sf && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(o) {
      const s = [];
      for (const a in o) {
        const u = o[a];
        delete u.metadata, s.push(u);
      }
      return s;
    }
    if (t) {
      const o = i(e.textures),
        s = i(e.images);
      o.length > 0 && (r.textures = o), s.length > 0 && (r.images = s);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let o = 0; o !== i; ++o) r[o] = t[o].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
  onBeforeRender() {
    console.warn("Material: onBeforeRender() has been removed.");
  }
}
class Xl extends zi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new fs()),
      (this.combine = sg),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Ol = ez();
function ez() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const c = u - 127;
    c < -27
      ? ((r[u] = 0), (r[u | 256] = 32768), (i[u] = 24), (i[u | 256] = 24))
      : c < -14
      ? ((r[u] = 1024 >> (-c - 14)),
        (r[u | 256] = (1024 >> (-c - 14)) | 32768),
        (i[u] = -c - 1),
        (i[u | 256] = -c - 1))
      : c <= 15
      ? ((r[u] = (c + 15) << 10),
        (r[u | 256] = ((c + 15) << 10) | 32768),
        (i[u] = 13),
        (i[u | 256] = 13))
      : c < 128
      ? ((r[u] = 31744), (r[u | 256] = 64512), (i[u] = 24), (i[u | 256] = 24))
      : ((r[u] = 31744), (r[u | 256] = 64512), (i[u] = 13), (i[u | 256] = 13));
  }
  const o = new Uint32Array(2048),
    s = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let c = u << 13,
      d = 0;
    for (; (c & 8388608) === 0; ) (c <<= 1), (d -= 8388608);
    (c &= -8388609), (d += 947912704), (o[u] = c | d);
  }
  for (let u = 1024; u < 2048; ++u) o[u] = 939524096 + ((u - 1024) << 13);
  for (let u = 1; u < 31; ++u) s[u] = u << 23;
  (s[31] = 1199570944), (s[32] = 2147483648);
  for (let u = 33; u < 63; ++u) s[u] = 2147483648 + ((u - 32) << 23);
  s[63] = 3347054592;
  for (let u = 1; u < 64; ++u) u !== 32 && (a[u] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: s,
    offsetTable: a,
  };
}
function Fo(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = Tr(n, -65504, 65504)),
    (Ol.floatView[0] = n);
  const e = Ol.uint32View[0],
    t = (e >> 23) & 511;
  return Ol.baseTable[t] + ((e & 8388607) >> Ol.shiftTable[t]);
}
function om(n) {
  const e = n >> 10;
  return (
    (Ol.uint32View[0] =
      Ol.mantissaTable[Ol.offsetTable[e] + (n & 1023)] + Ol.exponentTable[e]),
    Ol.floatView[0]
  );
}
const tz = { toHalfFloat: Fo, fromHalfFloat: om },
  ei = new oe(),
  Tv = new tt();
class Gn {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = Wm),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = Bo),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      Mh(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        Tv.fromBufferAttribute(this, t),
          Tv.applyMatrix3(e),
          this.setXY(t, Tv.x, Tv.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        ei.fromBufferAttribute(this, t),
          ei.applyMatrix3(e),
          this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      ei.fromBufferAttribute(this, t),
        ei.applyMatrix4(e),
        this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      ei.fromBufferAttribute(this, t),
        ei.applyNormalMatrix(e),
        this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      ei.fromBufferAttribute(this, t),
        ei.transformDirection(e),
        this.setXYZ(t, ei.x, ei.y, ei.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = xo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = on(r, this.array)),
      (this.array[e * this.itemSize + t] = r),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = on(t, this.array)), (r = on(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array)),
        (o = on(o, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Wm && (e.usage = this.usage),
      e
    );
  }
}
class nz extends Gn {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class rz extends Gn {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class iz extends Gn {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class oz extends Gn {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class kw extends Gn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class sz extends Gn {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class Ow extends Gn {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class az extends Gn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = om(this.array[e * this.itemSize]);
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize] = Fo(t)),
      this
    );
  }
  getY(e) {
    let t = om(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 1] = Fo(t)),
      this
    );
  }
  getZ(e) {
    let t = om(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 2] = Fo(t)),
      this
    );
  }
  getW(e) {
    let t = om(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 3] = Fo(t)),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = on(t, this.array)), (r = on(r, this.array))),
      (this.array[e + 0] = Fo(t)),
      (this.array[e + 1] = Fo(r)),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array))),
      (this.array[e + 0] = Fo(t)),
      (this.array[e + 1] = Fo(r)),
      (this.array[e + 2] = Fo(i)),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array)),
        (o = on(o, this.array))),
      (this.array[e + 0] = Fo(t)),
      (this.array[e + 1] = Fo(r)),
      (this.array[e + 2] = Fo(i)),
      (this.array[e + 3] = Fo(o)),
      this
    );
  }
}
class Pt extends Gn {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let lz = 0;
const Ts = new Gt(),
  Z_ = new wn(),
  Xd = new oe(),
  is = new ci(),
  Wp = new ci(),
  Si = new oe();
class sn extends $l {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: lz++ }),
      (this.uuid = us()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (gR(e) ? Ow : kw)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new en().getNormalMatrix(e);
      r.applyNormalMatrix(o), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Ts.makeRotationFromQuaternion(e), this.applyMatrix4(Ts), this;
  }
  rotateX(e) {
    return Ts.makeRotationX(e), this.applyMatrix4(Ts), this;
  }
  rotateY(e) {
    return Ts.makeRotationY(e), this.applyMatrix4(Ts), this;
  }
  rotateZ(e) {
    return Ts.makeRotationZ(e), this.applyMatrix4(Ts), this;
  }
  translate(e, t, r) {
    return Ts.makeTranslation(e, t, r), this.applyMatrix4(Ts), this;
  }
  scale(e, t, r) {
    return Ts.makeScale(e, t, r), this.applyMatrix4(Ts), this;
  }
  lookAt(e) {
    return Z_.lookAt(e), Z_.updateMatrix(), this.applyMatrix4(Z_.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Xd).negate(),
      this.translate(Xd.x, Xd.y, Xd.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const o = e[r];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new Pt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ci());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new oe(-1 / 0, -1 / 0, -1 / 0),
          new oe(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, i = t.length; r < i; r++) {
          const o = t[r];
          is.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Si.addVectors(this.boundingBox.min, is.min),
                this.boundingBox.expandByPoint(Si),
                Si.addVectors(this.boundingBox.max, is.max),
                this.boundingBox.expandByPoint(Si))
              : (this.boundingBox.expandByPoint(is.min),
                this.boundingBox.expandByPoint(is.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new oe(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((is.setFromBufferAttribute(e), t))
        for (let o = 0, s = t.length; o < s; o++) {
          const a = t[o];
          Wp.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Si.addVectors(is.min, Wp.min),
                is.expandByPoint(Si),
                Si.addVectors(is.max, Wp.max),
                is.expandByPoint(Si))
              : (is.expandByPoint(Wp.min), is.expandByPoint(Wp.max));
        }
      is.getCenter(r);
      let i = 0;
      for (let o = 0, s = e.count; o < s; o++)
        Si.fromBufferAttribute(e, o),
          (i = Math.max(i, r.distanceToSquared(Si)));
      if (t)
        for (let o = 0, s = t.length; o < s; o++) {
          const a = t[o],
            u = this.morphTargetsRelative;
          for (let c = 0, d = a.count; c < d; c++)
            Si.fromBufferAttribute(a, c),
              u && (Xd.fromBufferAttribute(e, c), Si.add(Xd)),
              (i = Math.max(i, r.distanceToSquared(Si)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = t.position,
      i = t.normal,
      o = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Gn(new Float32Array(4 * r.count), 4));
    const s = this.getAttribute("tangent"),
      a = [],
      u = [];
    for (let U = 0; U < r.count; U++) (a[U] = new oe()), (u[U] = new oe());
    const c = new oe(),
      d = new oe(),
      m = new oe(),
      g = new tt(),
      y = new tt(),
      x = new tt(),
      S = new oe(),
      _ = new oe();
    function w(U, O, L) {
      c.fromBufferAttribute(r, U),
        d.fromBufferAttribute(r, O),
        m.fromBufferAttribute(r, L),
        g.fromBufferAttribute(o, U),
        y.fromBufferAttribute(o, O),
        x.fromBufferAttribute(o, L),
        d.sub(c),
        m.sub(c),
        y.sub(g),
        x.sub(g);
      const H = 1 / (y.x * x.y - x.x * y.y);
      isFinite(H) &&
        (S.copy(d)
          .multiplyScalar(x.y)
          .addScaledVector(m, -y.y)
          .multiplyScalar(H),
        _.copy(m)
          .multiplyScalar(y.x)
          .addScaledVector(d, -x.x)
          .multiplyScalar(H),
        a[U].add(S),
        a[O].add(S),
        a[L].add(S),
        u[U].add(_),
        u[O].add(_),
        u[L].add(_));
    }
    let T = this.groups;
    T.length === 0 && (T = [{ start: 0, count: e.count }]);
    for (let U = 0, O = T.length; U < O; ++U) {
      const L = T[U],
        H = L.start,
        W = L.count;
      for (let $ = H, K = H + W; $ < K; $ += 3)
        w(e.getX($ + 0), e.getX($ + 1), e.getX($ + 2));
    }
    const M = new oe(),
      A = new oe(),
      R = new oe(),
      D = new oe();
    function P(U) {
      R.fromBufferAttribute(i, U), D.copy(R);
      const O = a[U];
      M.copy(O),
        M.sub(R.multiplyScalar(R.dot(O))).normalize(),
        A.crossVectors(D, O);
      const H = A.dot(u[U]) < 0 ? -1 : 1;
      s.setXYZW(U, M.x, M.y, M.z, H);
    }
    for (let U = 0, O = T.length; U < O; ++U) {
      const L = T[U],
        H = L.start,
        W = L.count;
      for (let $ = H, K = H + W; $ < K; $ += 3)
        P(e.getX($ + 0)), P(e.getX($ + 1)), P(e.getX($ + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new Gn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let g = 0, y = r.count; g < y; g++) r.setXYZ(g, 0, 0, 0);
      const i = new oe(),
        o = new oe(),
        s = new oe(),
        a = new oe(),
        u = new oe(),
        c = new oe(),
        d = new oe(),
        m = new oe();
      if (e)
        for (let g = 0, y = e.count; g < y; g += 3) {
          const x = e.getX(g + 0),
            S = e.getX(g + 1),
            _ = e.getX(g + 2);
          i.fromBufferAttribute(t, x),
            o.fromBufferAttribute(t, S),
            s.fromBufferAttribute(t, _),
            d.subVectors(s, o),
            m.subVectors(i, o),
            d.cross(m),
            a.fromBufferAttribute(r, x),
            u.fromBufferAttribute(r, S),
            c.fromBufferAttribute(r, _),
            a.add(d),
            u.add(d),
            c.add(d),
            r.setXYZ(x, a.x, a.y, a.z),
            r.setXYZ(S, u.x, u.y, u.z),
            r.setXYZ(_, c.x, c.y, c.z);
        }
      else
        for (let g = 0, y = t.count; g < y; g += 3)
          i.fromBufferAttribute(t, g + 0),
            o.fromBufferAttribute(t, g + 1),
            s.fromBufferAttribute(t, g + 2),
            d.subVectors(s, o),
            m.subVectors(i, o),
            d.cross(m),
            r.setXYZ(g + 0, d.x, d.y, d.z),
            r.setXYZ(g + 1, d.x, d.y, d.z),
            r.setXYZ(g + 2, d.x, d.y, d.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      Si.fromBufferAttribute(e, t),
        Si.normalize(),
        e.setXYZ(t, Si.x, Si.y, Si.z);
  }
  toNonIndexed() {
    function e(a, u) {
      const c = a.array,
        d = a.itemSize,
        m = a.normalized,
        g = new c.constructor(u.length * d);
      let y = 0,
        x = 0;
      for (let S = 0, _ = u.length; S < _; S++) {
        a.isInterleavedBufferAttribute
          ? (y = u[S] * a.data.stride + a.offset)
          : (y = u[S] * d);
        for (let w = 0; w < d; w++) g[x++] = c[y++];
      }
      return new Gn(g, d, m);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new sn(),
      r = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const u = i[a],
        c = e(u, r);
      t.setAttribute(a, c);
    }
    const o = this.morphAttributes;
    for (const a in o) {
      const u = [],
        c = o[a];
      for (let d = 0, m = c.length; d < m; d++) {
        const g = c[d],
          y = e(g, r);
        u.push(y);
      }
      t.morphAttributes[a] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let a = 0, u = s.length; a < u; a++) {
      const c = s[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const u = this.parameters;
      for (const c in u) u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const u in r) {
      const c = r[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u],
        d = [];
      for (let m = 0, g = c.length; m < g; m++) {
        const y = c[m];
        d.push(y.toJSON(e.data));
      }
      d.length > 0 && ((i[u] = d), (o = !0));
    }
    o &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const d = i[c];
      this.setAttribute(c, d.clone(t));
    }
    const o = e.morphAttributes;
    for (const c in o) {
      const d = [],
        m = o[c];
      for (let g = 0, y = m.length; g < y; g++) d.push(m[g].clone(t));
      this.morphAttributes[c] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const s = e.groups;
    for (let c = 0, d = s.length; c < d; c++) {
      const m = s[c];
      this.addGroup(m.start, m.count, m.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const u = e.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const BE = new Gt(),
  Hc = new Df(),
  Cv = new fi(),
  zE = new oe(),
  Yd = new oe(),
  qd = new oe(),
  Kd = new oe(),
  J_ = new oe(),
  Av = new oe(),
  Rv = new tt(),
  Pv = new tt(),
  Iv = new tt(),
  HE = new oe(),
  VE = new oe(),
  WE = new oe(),
  Lv = new oe(),
  Dv = new oe();
class ur extends wn {
  constructor(e = new sn(), t = new Xl()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const a = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      i = r.attributes.position,
      o = r.morphAttributes.position,
      s = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (o && a) {
      Av.set(0, 0, 0);
      for (let u = 0, c = o.length; u < c; u++) {
        const d = a[u],
          m = o[u];
        d !== 0 &&
          (J_.fromBufferAttribute(m, e),
          s ? Av.addScaledVector(J_, d) : Av.addScaledVector(J_.sub(t), d));
      }
      t.add(Av);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.material,
      o = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Cv.copy(r.boundingSphere),
      Cv.applyMatrix4(o),
      Hc.copy(e.ray).recast(e.near),
      !(
        Cv.containsPoint(Hc.origin) === !1 &&
        (Hc.intersectSphere(Cv, zE) === null ||
          Hc.origin.distanceToSquared(zE) > (e.far - e.near) ** 2)
      ) &&
        (BE.copy(o).invert(),
        Hc.copy(e.ray).applyMatrix4(BE),
        !(r.boundingBox !== null && Hc.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, t, Hc)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const o = this.geometry,
      s = this.material,
      a = o.index,
      u = o.attributes.position,
      c = o.attributes.uv,
      d = o.attributes.uv1,
      m = o.attributes.normal,
      g = o.groups,
      y = o.drawRange;
    if (a !== null)
      if (Array.isArray(s))
        for (let x = 0, S = g.length; x < S; x++) {
          const _ = g[x],
            w = s[_.materialIndex],
            T = Math.max(_.start, y.start),
            M = Math.min(
              a.count,
              Math.min(_.start + _.count, y.start + y.count)
            );
          for (let A = T, R = M; A < R; A += 3) {
            const D = a.getX(A),
              P = a.getX(A + 1),
              U = a.getX(A + 2);
            (i = kv(this, w, e, r, c, d, m, D, P, U)),
              i &&
                ((i.faceIndex = Math.floor(A / 3)),
                (i.face.materialIndex = _.materialIndex),
                t.push(i));
          }
        }
      else {
        const x = Math.max(0, y.start),
          S = Math.min(a.count, y.start + y.count);
        for (let _ = x, w = S; _ < w; _ += 3) {
          const T = a.getX(_),
            M = a.getX(_ + 1),
            A = a.getX(_ + 2);
          (i = kv(this, s, e, r, c, d, m, T, M, A)),
            i && ((i.faceIndex = Math.floor(_ / 3)), t.push(i));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(s))
        for (let x = 0, S = g.length; x < S; x++) {
          const _ = g[x],
            w = s[_.materialIndex],
            T = Math.max(_.start, y.start),
            M = Math.min(
              u.count,
              Math.min(_.start + _.count, y.start + y.count)
            );
          for (let A = T, R = M; A < R; A += 3) {
            const D = A,
              P = A + 1,
              U = A + 2;
            (i = kv(this, w, e, r, c, d, m, D, P, U)),
              i &&
                ((i.faceIndex = Math.floor(A / 3)),
                (i.face.materialIndex = _.materialIndex),
                t.push(i));
          }
        }
      else {
        const x = Math.max(0, y.start),
          S = Math.min(u.count, y.start + y.count);
        for (let _ = x, w = S; _ < w; _ += 3) {
          const T = _,
            M = _ + 1,
            A = _ + 2;
          (i = kv(this, s, e, r, c, d, m, T, M, A)),
            i && ((i.faceIndex = Math.floor(_ / 3)), t.push(i));
        }
      }
  }
}
function uz(n, e, t, r, i, o, s, a) {
  let u;
  if (
    (e.side === ro
      ? (u = r.intersectTriangle(s, o, i, !0, a))
      : (u = r.intersectTriangle(i, o, s, e.side === el, a)),
    u === null)
  )
    return null;
  Dv.copy(a), Dv.applyMatrix4(n.matrixWorld);
  const c = t.ray.origin.distanceTo(Dv);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: Dv.clone(), object: n };
}
function kv(n, e, t, r, i, o, s, a, u, c) {
  n.getVertexPosition(a, Yd),
    n.getVertexPosition(u, qd),
    n.getVertexPosition(c, Kd);
  const d = uz(n, e, t, r, Yd, qd, Kd, Lv);
  if (d) {
    i &&
      (Rv.fromBufferAttribute(i, a),
      Pv.fromBufferAttribute(i, u),
      Iv.fromBufferAttribute(i, c),
      (d.uv = ss.getInterpolation(Lv, Yd, qd, Kd, Rv, Pv, Iv, new tt()))),
      o &&
        (Rv.fromBufferAttribute(o, a),
        Pv.fromBufferAttribute(o, u),
        Iv.fromBufferAttribute(o, c),
        (d.uv1 = ss.getInterpolation(Lv, Yd, qd, Kd, Rv, Pv, Iv, new tt()))),
      s &&
        (HE.fromBufferAttribute(s, a),
        VE.fromBufferAttribute(s, u),
        WE.fromBufferAttribute(s, c),
        (d.normal = ss.getInterpolation(Lv, Yd, qd, Kd, HE, VE, WE, new oe())),
        d.normal.dot(r.direction) > 0 && d.normal.multiplyScalar(-1));
    const m = { a, b: u, c, normal: new oe(), materialIndex: 0 };
    ss.getNormal(Yd, qd, Kd, m.normal), (d.face = m);
  }
  return d;
}
class kf extends sn {
  constructor(e = 1, t = 1, r = 1, i = 1, o = 1, s = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: o,
        depthSegments: s,
      });
    const a = this;
    (i = Math.floor(i)), (o = Math.floor(o)), (s = Math.floor(s));
    const u = [],
      c = [],
      d = [],
      m = [];
    let g = 0,
      y = 0;
    x("z", "y", "x", -1, -1, r, t, e, s, o, 0),
      x("z", "y", "x", 1, -1, r, t, -e, s, o, 1),
      x("x", "z", "y", 1, 1, e, r, t, i, s, 2),
      x("x", "z", "y", 1, -1, e, r, -t, i, s, 3),
      x("x", "y", "z", 1, -1, e, t, r, i, o, 4),
      x("x", "y", "z", -1, -1, e, t, -r, i, o, 5),
      this.setIndex(u),
      this.setAttribute("position", new Pt(c, 3)),
      this.setAttribute("normal", new Pt(d, 3)),
      this.setAttribute("uv", new Pt(m, 2));
    function x(S, _, w, T, M, A, R, D, P, U, O) {
      const L = A / P,
        H = R / U,
        W = A / 2,
        $ = R / 2,
        K = D / 2,
        Z = P + 1,
        Y = U + 1;
      let re = 0,
        G = 0;
      const te = new oe();
      for (let F = 0; F < Y; F++) {
        const V = F * H - $;
        for (let ne = 0; ne < Z; ne++) {
          const ae = ne * L - W;
          (te[S] = ae * T),
            (te[_] = V * M),
            (te[w] = K),
            c.push(te.x, te.y, te.z),
            (te[S] = 0),
            (te[_] = 0),
            (te[w] = D > 0 ? 1 : -1),
            d.push(te.x, te.y, te.z),
            m.push(ne / P),
            m.push(1 - F / U),
            (re += 1);
        }
      }
      for (let F = 0; F < U; F++)
        for (let V = 0; V < P; V++) {
          const ne = g + V + Z * F,
            ae = g + V + Z * (F + 1),
            J = g + (V + 1) + Z * (F + 1),
            se = g + (V + 1) + Z * F;
          u.push(ne, ae, se), u.push(ae, J, se), (G += 6);
        }
      a.addGroup(y, G, O), (y += G), (g += re);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new kf(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Dh(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = i.clone())
        : Array.isArray(i)
        ? (e[t][r] = i.slice())
        : (e[t][r] = i);
    }
  }
  return e;
}
function yo(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = Dh(n[t]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function cz(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function SR(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : Sn.workingColorSpace;
}
const $m = { clone: Dh, merge: yo };
var fz = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  dz = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ds extends zi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = fz),
      (this.fragmentShader = dz),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Dh(e.uniforms)),
      (this.uniformsGroups = cz(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const s = this.uniforms[i].value;
      s && s.isTexture
        ? (t.uniforms[i] = { type: "t", value: s.toJSON(e).uuid })
        : s && s.isColor
        ? (t.uniforms[i] = { type: "c", value: s.getHex() })
        : s && s.isVector2
        ? (t.uniforms[i] = { type: "v2", value: s.toArray() })
        : s && s.isVector3
        ? (t.uniforms[i] = { type: "v3", value: s.toArray() })
        : s && s.isVector4
        ? (t.uniforms[i] = { type: "v4", value: s.toArray() })
        : s && s.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: s.toArray() })
        : s && s.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: s.toArray() })
        : (t.uniforms[i] = { value: s });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class ug extends wn {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Gt()),
      (this.projectionMatrix = new Gt()),
      (this.projectionMatrixInverse = new Gt()),
      (this.coordinateSystem = Ya);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Fu = new oe(),
  GE = new tt(),
  jE = new tt();
class Nr extends ug {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Lh * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(_f * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Lh * 2 * Math.atan(Math.tan(_f * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, r) {
    Fu.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Fu.x, Fu.y).multiplyScalar(-e / Fu.z),
      Fu.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      r.set(Fu.x, Fu.y).multiplyScalar(-e / Fu.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, GE, jE), t.subVectors(jE, GE);
  }
  setViewOffset(e, t, r, i, o, s) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(_f * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      i = this.aspect * r,
      o = -0.5 * i;
    const s = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = s.fullWidth,
        c = s.fullHeight;
      (o += (s.offsetX * i) / u),
        (t -= (s.offsetY * r) / c),
        (i *= s.width / u),
        (r *= s.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (o += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        o,
        o + i,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Zd = -90,
  Jd = 1;
class wR extends wn {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Nr(Zd, Jd, e, t);
    (i.layers = this.layers), this.add(i);
    const o = new Nr(Zd, Jd, e, t);
    (o.layers = this.layers), this.add(o);
    const s = new Nr(Zd, Jd, e, t);
    (s.layers = this.layers), this.add(s);
    const a = new Nr(Zd, Jd, e, t);
    (a.layers = this.layers), this.add(a);
    const u = new Nr(Zd, Jd, e, t);
    (u.layers = this.layers), this.add(u);
    const c = new Nr(Zd, Jd, e, t);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, i, o, s, a, u] = t;
    for (const c of t) this.remove(c);
    if (e === Ya)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, -1);
    else if (e === Gm)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [o, s, a, u, c, d] = this.children,
      m = e.getRenderTarget(),
      g = e.getActiveCubeFace(),
      y = e.getActiveMipmapLevel(),
      x = e.xr.enabled;
    e.xr.enabled = !1;
    const S = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(t, o),
      e.setRenderTarget(r, 1, i),
      e.render(t, s),
      e.setRenderTarget(r, 2, i),
      e.render(t, a),
      e.setRenderTarget(r, 3, i),
      e.render(t, u),
      e.setRenderTarget(r, 4, i),
      e.render(t, c),
      (r.texture.generateMipmaps = S),
      e.setRenderTarget(r, 5, i),
      e.render(t, d),
      e.setRenderTarget(m, g, y),
      (e.xr.enabled = x),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class cg extends er {
  constructor(e, t, r, i, o, s, a, u, c, d) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Hl),
      super(e, t, r, i, o, s, a, u, c, d),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class bR extends ma {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    (this.texture = new cg(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Cr);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new kf(5, 5, 5),
      o = new Ds({
        name: "CubemapFromEquirect",
        uniforms: Dh(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: ro,
        blending: Fl,
      });
    o.uniforms.tEquirect.value = t;
    const s = new ur(i, o),
      a = t.minFilter;
    return (
      t.minFilter === Xa && (t.minFilter = Cr),
      new wR(1, 10, this).update(e, s),
      (t.minFilter = a),
      s.geometry.dispose(),
      s.material.dispose(),
      this
    );
  }
  clear(e, t, r, i) {
    const o = e.getRenderTarget();
    for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, r, i);
    e.setRenderTarget(o);
  }
}
const Q_ = new oe(),
  hz = new oe(),
  pz = new en();
class Ll {
  constructor(e = new oe(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = Q_.subVectors(r, t).cross(hz.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(Q_),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(r, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || pz.getNormalMatrix(e),
      i = this.coplanarPoint(Q_).applyMatrix4(e),
      o = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Vc = new fi(),
  Ov = new oe();
class fg {
  constructor(
    e = new Ll(),
    t = new Ll(),
    r = new Ll(),
    i = new Ll(),
    o = new Ll(),
    s = new Ll()
  ) {
    this.planes = [e, t, r, i, o, s];
  }
  set(e, t, r, i, o, s) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(r),
      a[3].copy(i),
      a[4].copy(o),
      a[5].copy(s),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ya) {
    const r = this.planes,
      i = e.elements,
      o = i[0],
      s = i[1],
      a = i[2],
      u = i[3],
      c = i[4],
      d = i[5],
      m = i[6],
      g = i[7],
      y = i[8],
      x = i[9],
      S = i[10],
      _ = i[11],
      w = i[12],
      T = i[13],
      M = i[14],
      A = i[15];
    if (
      (r[0].setComponents(u - o, g - c, _ - y, A - w).normalize(),
      r[1].setComponents(u + o, g + c, _ + y, A + w).normalize(),
      r[2].setComponents(u + s, g + d, _ + x, A + T).normalize(),
      r[3].setComponents(u - s, g - d, _ - x, A - T).normalize(),
      r[4].setComponents(u - a, g - m, _ - S, A - M).normalize(),
      t === Ya)
    )
      r[5].setComponents(u + a, g + m, _ + S, A + M).normalize();
    else if (t === Gm) r[5].setComponents(a, m, S, M).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Vc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Vc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Vc);
  }
  intersectsSprite(e) {
    return (
      Vc.center.set(0, 0, 0),
      (Vc.radius = 0.7071067811865476),
      Vc.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Vc)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      i = -e.radius;
    for (let o = 0; o < 6; o++) if (t[o].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (
        ((Ov.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Ov.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Ov.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Ov) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function MR() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function i(o, s) {
    t(o, s), (r = n.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (o) {
      t = o;
    },
    setContext: function (o) {
      n = o;
    },
  };
}
function mz(n) {
  const e = new WeakMap();
  function t(a, u) {
    const c = a.array,
      d = a.usage,
      m = c.byteLength,
      g = n.createBuffer();
    n.bindBuffer(u, g), n.bufferData(u, c, d), a.onUploadCallback();
    let y;
    if (c instanceof Float32Array) y = n.FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (y = n.HALF_FLOAT) : (y = n.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) y = n.SHORT;
    else if (c instanceof Uint32Array) y = n.UNSIGNED_INT;
    else if (c instanceof Int32Array) y = n.INT;
    else if (c instanceof Int8Array) y = n.BYTE;
    else if (c instanceof Uint8Array) y = n.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) y = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: g,
      type: y,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: m,
    };
  }
  function r(a, u, c) {
    const d = u.array,
      m = u._updateRange,
      g = u.updateRanges;
    if (
      (n.bindBuffer(c, a),
      m.count === -1 && g.length === 0 && n.bufferSubData(c, 0, d),
      g.length !== 0)
    ) {
      for (let y = 0, x = g.length; y < x; y++) {
        const S = g[y];
        n.bufferSubData(c, S.start * d.BYTES_PER_ELEMENT, d, S.start, S.count);
      }
      u.clearUpdateRanges();
    }
    m.count !== -1 &&
      (n.bufferSubData(c, m.offset * d.BYTES_PER_ELEMENT, d, m.offset, m.count),
      (m.count = -1)),
      u.onUploadCallback();
  }
  function i(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function o(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const u = e.get(a);
    u && (n.deleteBuffer(u.buffer), e.delete(a));
  }
  function s(a, u) {
    if (
      (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)
    ) {
      const d = e.get(a);
      (!d || d.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    const c = e.get(a);
    if (c === void 0) e.set(a, t(a, u));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      r(c.buffer, a, u), (c.version = a.version);
    }
  }
  return { get: i, remove: o, update: s };
}
class Yl extends sn {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: i,
      });
    const o = e / 2,
      s = t / 2,
      a = Math.floor(r),
      u = Math.floor(i),
      c = a + 1,
      d = u + 1,
      m = e / a,
      g = t / u,
      y = [],
      x = [],
      S = [],
      _ = [];
    for (let w = 0; w < d; w++) {
      const T = w * g - s;
      for (let M = 0; M < c; M++) {
        const A = M * m - o;
        x.push(A, -T, 0), S.push(0, 0, 1), _.push(M / a), _.push(1 - w / u);
      }
    }
    for (let w = 0; w < u; w++)
      for (let T = 0; T < a; T++) {
        const M = T + c * w,
          A = T + c * (w + 1),
          R = T + 1 + c * (w + 1),
          D = T + 1 + c * w;
        y.push(M, A, D), y.push(A, R, D);
      }
    this.setIndex(y),
      this.setAttribute("position", new Pt(x, 3)),
      this.setAttribute("normal", new Pt(S, 3)),
      this.setAttribute("uv", new Pt(_, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var gz = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  vz = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  yz = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  xz = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  _z = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  Sz = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  wz = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  bz = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  Mz = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  Ez = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  Tz = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  Cz = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Az = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  Rz = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  Pz = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Iz = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  Lz = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  Dz = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  kz = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Oz = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Nz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  Uz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  Fz = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  Bz = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  zz = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Hz = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  Vz = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Wz = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  Gz = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  jz = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  $z = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  Xz = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  Yz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  qz = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  Kz = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  Zz = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  Jz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  Qz = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  e5 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  t5 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  n5 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  r5 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  i5 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  o5 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  s5 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  a5 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  l5 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  u5 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  c5 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  f5 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  d5 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  h5 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  p5 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  m5 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  g5 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  v5 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  y5 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  x5 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  _5 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  S5 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  w5 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  b5 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  M5 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  E5 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  T5 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  C5 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  A5 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  R5 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  P5 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  I5 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  L5 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  D5 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  k5 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  O5 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  N5 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  U5 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  F5 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  B5 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  z5 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  H5 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  V5 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  W5 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  G5 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  j5 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  $5 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  X5 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  Y5 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  q5 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  K5 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  Z5 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  J5 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  Q5 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  e6 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  t6 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  n6 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  r6 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  i6 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  o6 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  s6 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  a6 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  l6 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  u6 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  c6 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  f6 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  d6 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  h6 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  p6 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const m6 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  g6 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  v6 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  y6 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  x6 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  _6 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  S6 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  w6 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  b6 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  M6 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  E6 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  T6 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  C6 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  A6 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  R6 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  P6 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  I6 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  L6 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  D6 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  k6 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  O6 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  N6 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  U6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  F6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  B6 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  z6 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  H6 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  V6 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  W6 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  G6 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  j6 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  $6 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  X6 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Y6 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  rn = {
    alphahash_fragment: gz,
    alphahash_pars_fragment: vz,
    alphamap_fragment: yz,
    alphamap_pars_fragment: xz,
    alphatest_fragment: _z,
    alphatest_pars_fragment: Sz,
    aomap_fragment: wz,
    aomap_pars_fragment: bz,
    batching_pars_vertex: Mz,
    batching_vertex: Ez,
    begin_vertex: Tz,
    beginnormal_vertex: Cz,
    bsdfs: Az,
    iridescence_fragment: Rz,
    bumpmap_pars_fragment: Pz,
    clipping_planes_fragment: Iz,
    clipping_planes_pars_fragment: Lz,
    clipping_planes_pars_vertex: Dz,
    clipping_planes_vertex: kz,
    color_fragment: Oz,
    color_pars_fragment: Nz,
    color_pars_vertex: Uz,
    color_vertex: Fz,
    common: Bz,
    cube_uv_reflection_fragment: zz,
    defaultnormal_vertex: Hz,
    displacementmap_pars_vertex: Vz,
    displacementmap_vertex: Wz,
    emissivemap_fragment: Gz,
    emissivemap_pars_fragment: jz,
    colorspace_fragment: $z,
    colorspace_pars_fragment: Xz,
    envmap_fragment: Yz,
    envmap_common_pars_fragment: qz,
    envmap_pars_fragment: Kz,
    envmap_pars_vertex: Zz,
    envmap_physical_pars_fragment: l5,
    envmap_vertex: Jz,
    fog_vertex: Qz,
    fog_pars_vertex: e5,
    fog_fragment: t5,
    fog_pars_fragment: n5,
    gradientmap_pars_fragment: r5,
    lightmap_pars_fragment: i5,
    lights_lambert_fragment: o5,
    lights_lambert_pars_fragment: s5,
    lights_pars_begin: a5,
    lights_toon_fragment: u5,
    lights_toon_pars_fragment: c5,
    lights_phong_fragment: f5,
    lights_phong_pars_fragment: d5,
    lights_physical_fragment: h5,
    lights_physical_pars_fragment: p5,
    lights_fragment_begin: m5,
    lights_fragment_maps: g5,
    lights_fragment_end: v5,
    logdepthbuf_fragment: y5,
    logdepthbuf_pars_fragment: x5,
    logdepthbuf_pars_vertex: _5,
    logdepthbuf_vertex: S5,
    map_fragment: w5,
    map_pars_fragment: b5,
    map_particle_fragment: M5,
    map_particle_pars_fragment: E5,
    metalnessmap_fragment: T5,
    metalnessmap_pars_fragment: C5,
    morphinstance_vertex: A5,
    morphcolor_vertex: R5,
    morphnormal_vertex: P5,
    morphtarget_pars_vertex: I5,
    morphtarget_vertex: L5,
    normal_fragment_begin: D5,
    normal_fragment_maps: k5,
    normal_pars_fragment: O5,
    normal_pars_vertex: N5,
    normal_vertex: U5,
    normalmap_pars_fragment: F5,
    clearcoat_normal_fragment_begin: B5,
    clearcoat_normal_fragment_maps: z5,
    clearcoat_pars_fragment: H5,
    iridescence_pars_fragment: V5,
    opaque_fragment: W5,
    packing: G5,
    premultiplied_alpha_fragment: j5,
    project_vertex: $5,
    dithering_fragment: X5,
    dithering_pars_fragment: Y5,
    roughnessmap_fragment: q5,
    roughnessmap_pars_fragment: K5,
    shadowmap_pars_fragment: Z5,
    shadowmap_pars_vertex: J5,
    shadowmap_vertex: Q5,
    shadowmask_pars_fragment: e6,
    skinbase_vertex: t6,
    skinning_pars_vertex: n6,
    skinning_vertex: r6,
    skinnormal_vertex: i6,
    specularmap_fragment: o6,
    specularmap_pars_fragment: s6,
    tonemapping_fragment: a6,
    tonemapping_pars_fragment: l6,
    transmission_fragment: u6,
    transmission_pars_fragment: c6,
    uv_pars_fragment: f6,
    uv_pars_vertex: d6,
    uv_vertex: h6,
    worldpos_vertex: p6,
    background_vert: m6,
    background_frag: g6,
    backgroundCube_vert: v6,
    backgroundCube_frag: y6,
    cube_vert: x6,
    cube_frag: _6,
    depth_vert: S6,
    depth_frag: w6,
    distanceRGBA_vert: b6,
    distanceRGBA_frag: M6,
    equirect_vert: E6,
    equirect_frag: T6,
    linedashed_vert: C6,
    linedashed_frag: A6,
    meshbasic_vert: R6,
    meshbasic_frag: P6,
    meshlambert_vert: I6,
    meshlambert_frag: L6,
    meshmatcap_vert: D6,
    meshmatcap_frag: k6,
    meshnormal_vert: O6,
    meshnormal_frag: N6,
    meshphong_vert: U6,
    meshphong_frag: F6,
    meshphysical_vert: B6,
    meshphysical_frag: z6,
    meshtoon_vert: H6,
    meshtoon_frag: V6,
    points_vert: W6,
    points_frag: G6,
    shadow_vert: j6,
    shadow_frag: $6,
    sprite_vert: X6,
    sprite_frag: Y6,
  },
  vt = {
    common: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new en() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new en() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new en() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new en() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new en() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new en() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new en() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new en() },
      normalScale: { value: new tt(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new en() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new en() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new en() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new en() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new St(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new en() },
      alphaTest: { value: 0 },
      uvTransform: { value: new en() },
    },
    sprite: {
      diffuse: { value: new St(16777215) },
      opacity: { value: 1 },
      center: { value: new tt(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new en() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new en() },
      alphaTest: { value: 0 },
    },
  },
  ca = {
    basic: {
      uniforms: yo([
        vt.common,
        vt.specularmap,
        vt.envmap,
        vt.aomap,
        vt.lightmap,
        vt.fog,
      ]),
      vertexShader: rn.meshbasic_vert,
      fragmentShader: rn.meshbasic_frag,
    },
    lambert: {
      uniforms: yo([
        vt.common,
        vt.specularmap,
        vt.envmap,
        vt.aomap,
        vt.lightmap,
        vt.emissivemap,
        vt.bumpmap,
        vt.normalmap,
        vt.displacementmap,
        vt.fog,
        vt.lights,
        { emissive: { value: new St(0) } },
      ]),
      vertexShader: rn.meshlambert_vert,
      fragmentShader: rn.meshlambert_frag,
    },
    phong: {
      uniforms: yo([
        vt.common,
        vt.specularmap,
        vt.envmap,
        vt.aomap,
        vt.lightmap,
        vt.emissivemap,
        vt.bumpmap,
        vt.normalmap,
        vt.displacementmap,
        vt.fog,
        vt.lights,
        {
          emissive: { value: new St(0) },
          specular: { value: new St(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: rn.meshphong_vert,
      fragmentShader: rn.meshphong_frag,
    },
    standard: {
      uniforms: yo([
        vt.common,
        vt.envmap,
        vt.aomap,
        vt.lightmap,
        vt.emissivemap,
        vt.bumpmap,
        vt.normalmap,
        vt.displacementmap,
        vt.roughnessmap,
        vt.metalnessmap,
        vt.fog,
        vt.lights,
        {
          emissive: { value: new St(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: rn.meshphysical_vert,
      fragmentShader: rn.meshphysical_frag,
    },
    toon: {
      uniforms: yo([
        vt.common,
        vt.aomap,
        vt.lightmap,
        vt.emissivemap,
        vt.bumpmap,
        vt.normalmap,
        vt.displacementmap,
        vt.gradientmap,
        vt.fog,
        vt.lights,
        { emissive: { value: new St(0) } },
      ]),
      vertexShader: rn.meshtoon_vert,
      fragmentShader: rn.meshtoon_frag,
    },
    matcap: {
      uniforms: yo([
        vt.common,
        vt.bumpmap,
        vt.normalmap,
        vt.displacementmap,
        vt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: rn.meshmatcap_vert,
      fragmentShader: rn.meshmatcap_frag,
    },
    points: {
      uniforms: yo([vt.points, vt.fog]),
      vertexShader: rn.points_vert,
      fragmentShader: rn.points_frag,
    },
    dashed: {
      uniforms: yo([
        vt.common,
        vt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: rn.linedashed_vert,
      fragmentShader: rn.linedashed_frag,
    },
    depth: {
      uniforms: yo([vt.common, vt.displacementmap]),
      vertexShader: rn.depth_vert,
      fragmentShader: rn.depth_frag,
    },
    normal: {
      uniforms: yo([
        vt.common,
        vt.bumpmap,
        vt.normalmap,
        vt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: rn.meshnormal_vert,
      fragmentShader: rn.meshnormal_frag,
    },
    sprite: {
      uniforms: yo([vt.sprite, vt.fog]),
      vertexShader: rn.sprite_vert,
      fragmentShader: rn.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new en() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: rn.background_vert,
      fragmentShader: rn.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new en() },
      },
      vertexShader: rn.backgroundCube_vert,
      fragmentShader: rn.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: rn.cube_vert,
      fragmentShader: rn.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: rn.equirect_vert,
      fragmentShader: rn.equirect_frag,
    },
    distanceRGBA: {
      uniforms: yo([
        vt.common,
        vt.displacementmap,
        {
          referencePosition: { value: new oe() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: rn.distanceRGBA_vert,
      fragmentShader: rn.distanceRGBA_frag,
    },
    shadow: {
      uniforms: yo([
        vt.lights,
        vt.fog,
        { color: { value: new St(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: rn.shadow_vert,
      fragmentShader: rn.shadow_frag,
    },
  };
ca.physical = {
  uniforms: yo([
    ca.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new en() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new en() },
      clearcoatNormalScale: { value: new tt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new en() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new en() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new en() },
      sheen: { value: 0 },
      sheenColor: { value: new St(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new en() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new en() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new en() },
      transmissionSamplerSize: { value: new tt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new en() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new St(0) },
      specularColor: { value: new St(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new en() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new en() },
      anisotropyVector: { value: new tt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new en() },
    },
  ]),
  vertexShader: rn.meshphysical_vert,
  fragmentShader: rn.meshphysical_frag,
};
const Nv = { r: 0, b: 0, g: 0 },
  Wc = new fs(),
  q6 = new Gt();
function K6(n, e, t, r, i, o, s) {
  const a = new St(0);
  let u = o === !0 ? 0 : 1,
    c,
    d,
    m = null,
    g = 0,
    y = null;
  function x(T) {
    let M = T.isScene === !0 ? T.background : null;
    return (
      M && M.isTexture && (M = (T.backgroundBlurriness > 0 ? t : e).get(M)), M
    );
  }
  function S(T) {
    let M = !1;
    const A = x(T);
    A === null ? w(a, u) : A && A.isColor && (w(A, 1), (M = !0));
    const R = n.xr.getEnvironmentBlendMode();
    R === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, s)
      : R === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, s),
      (n.autoClear || M) &&
        (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  function _(T, M) {
    const A = x(M);
    A && (A.isCubeTexture || A.mapping === Vh)
      ? (d === void 0 &&
          ((d = new ur(
            new kf(1, 1, 1),
            new Ds({
              name: "BackgroundCubeMaterial",
              uniforms: Dh(ca.backgroundCube.uniforms),
              vertexShader: ca.backgroundCube.vertexShader,
              fragmentShader: ca.backgroundCube.fragmentShader,
              side: ro,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          d.geometry.deleteAttribute("normal"),
          d.geometry.deleteAttribute("uv"),
          (d.onBeforeRender = function (R, D, P) {
            this.matrixWorld.copyPosition(P.matrixWorld);
          }),
          Object.defineProperty(d.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(d)),
        Wc.copy(M.backgroundRotation),
        (Wc.x *= -1),
        (Wc.y *= -1),
        (Wc.z *= -1),
        A.isCubeTexture &&
          A.isRenderTargetTexture === !1 &&
          ((Wc.y *= -1), (Wc.z *= -1)),
        (d.material.uniforms.envMap.value = A),
        (d.material.uniforms.flipEnvMap.value =
          A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1),
        (d.material.uniforms.backgroundBlurriness.value =
          M.backgroundBlurriness),
        (d.material.uniforms.backgroundIntensity.value = M.backgroundIntensity),
        d.material.uniforms.backgroundRotation.value.setFromMatrix4(
          q6.makeRotationFromEuler(Wc)
        ),
        (d.material.toneMapped = Sn.getTransfer(A.colorSpace) !== Jn),
        (m !== A || g !== A.version || y !== n.toneMapping) &&
          ((d.material.needsUpdate = !0),
          (m = A),
          (g = A.version),
          (y = n.toneMapping)),
        d.layers.enableAll(),
        T.unshift(d, d.geometry, d.material, 0, 0, null))
      : A &&
        A.isTexture &&
        (c === void 0 &&
          ((c = new ur(
            new Yl(2, 2),
            new Ds({
              name: "BackgroundMaterial",
              uniforms: Dh(ca.background.uniforms),
              vertexShader: ca.background.vertexShader,
              fragmentShader: ca.background.fragmentShader,
              side: el,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(c)),
        (c.material.uniforms.t2D.value = A),
        (c.material.uniforms.backgroundIntensity.value = M.backgroundIntensity),
        (c.material.toneMapped = Sn.getTransfer(A.colorSpace) !== Jn),
        A.matrixAutoUpdate === !0 && A.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(A.matrix),
        (m !== A || g !== A.version || y !== n.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (m = A),
          (g = A.version),
          (y = n.toneMapping)),
        c.layers.enableAll(),
        T.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function w(T, M) {
    T.getRGB(Nv, SR(n)), r.buffers.color.setClear(Nv.r, Nv.g, Nv.b, M, s);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (T, M = 1) {
      a.set(T), (u = M), w(a, u);
    },
    getClearAlpha: function () {
      return u;
    },
    setClearAlpha: function (T) {
      (u = T), w(a, u);
    },
    render: S,
    addToRenderList: _,
  };
}
function Z6(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    r = {},
    i = g(null);
  let o = i,
    s = !1;
  function a(L, H, W, $, K) {
    let Z = !1;
    const Y = m($, W, H);
    o !== Y && ((o = Y), c(o.object)),
      (Z = y(L, $, W, K)),
      Z && x(L, $, W, K),
      K !== null && e.update(K, n.ELEMENT_ARRAY_BUFFER),
      (Z || s) &&
        ((s = !1),
        A(L, H, W, $),
        K !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(K).buffer));
  }
  function u() {
    return n.createVertexArray();
  }
  function c(L) {
    return n.bindVertexArray(L);
  }
  function d(L) {
    return n.deleteVertexArray(L);
  }
  function m(L, H, W) {
    const $ = W.wireframe === !0;
    let K = r[L.id];
    K === void 0 && ((K = {}), (r[L.id] = K));
    let Z = K[H.id];
    Z === void 0 && ((Z = {}), (K[H.id] = Z));
    let Y = Z[$];
    return Y === void 0 && ((Y = g(u())), (Z[$] = Y)), Y;
  }
  function g(L) {
    const H = [],
      W = [],
      $ = [];
    for (let K = 0; K < t; K++) (H[K] = 0), (W[K] = 0), ($[K] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: H,
      enabledAttributes: W,
      attributeDivisors: $,
      object: L,
      attributes: {},
      index: null,
    };
  }
  function y(L, H, W, $) {
    const K = o.attributes,
      Z = H.attributes;
    let Y = 0;
    const re = W.getAttributes();
    for (const G in re)
      if (re[G].location >= 0) {
        const F = K[G];
        let V = Z[G];
        if (
          (V === void 0 &&
            (G === "instanceMatrix" &&
              L.instanceMatrix &&
              (V = L.instanceMatrix),
            G === "instanceColor" && L.instanceColor && (V = L.instanceColor)),
          F === void 0 || F.attribute !== V || (V && F.data !== V.data))
        )
          return !0;
        Y++;
      }
    return o.attributesNum !== Y || o.index !== $;
  }
  function x(L, H, W, $) {
    const K = {},
      Z = H.attributes;
    let Y = 0;
    const re = W.getAttributes();
    for (const G in re)
      if (re[G].location >= 0) {
        let F = Z[G];
        F === void 0 &&
          (G === "instanceMatrix" && L.instanceMatrix && (F = L.instanceMatrix),
          G === "instanceColor" && L.instanceColor && (F = L.instanceColor));
        const V = {};
        (V.attribute = F), F && F.data && (V.data = F.data), (K[G] = V), Y++;
      }
    (o.attributes = K), (o.attributesNum = Y), (o.index = $);
  }
  function S() {
    const L = o.newAttributes;
    for (let H = 0, W = L.length; H < W; H++) L[H] = 0;
  }
  function _(L) {
    w(L, 0);
  }
  function w(L, H) {
    const W = o.newAttributes,
      $ = o.enabledAttributes,
      K = o.attributeDivisors;
    (W[L] = 1),
      $[L] === 0 && (n.enableVertexAttribArray(L), ($[L] = 1)),
      K[L] !== H && (n.vertexAttribDivisor(L, H), (K[L] = H));
  }
  function T() {
    const L = o.newAttributes,
      H = o.enabledAttributes;
    for (let W = 0, $ = H.length; W < $; W++)
      H[W] !== L[W] && (n.disableVertexAttribArray(W), (H[W] = 0));
  }
  function M(L, H, W, $, K, Z, Y) {
    Y === !0
      ? n.vertexAttribIPointer(L, H, W, K, Z)
      : n.vertexAttribPointer(L, H, W, $, K, Z);
  }
  function A(L, H, W, $) {
    S();
    const K = $.attributes,
      Z = W.getAttributes(),
      Y = H.defaultAttributeValues;
    for (const re in Z) {
      const G = Z[re];
      if (G.location >= 0) {
        let te = K[re];
        if (
          (te === void 0 &&
            (re === "instanceMatrix" &&
              L.instanceMatrix &&
              (te = L.instanceMatrix),
            re === "instanceColor" &&
              L.instanceColor &&
              (te = L.instanceColor)),
          te !== void 0)
        ) {
          const F = te.normalized,
            V = te.itemSize,
            ne = e.get(te);
          if (ne === void 0) continue;
          const ae = ne.buffer,
            J = ne.type,
            se = ne.bytesPerElement,
            de = J === n.INT || J === n.UNSIGNED_INT || te.gpuType === jy;
          if (te.isInterleavedBufferAttribute) {
            const le = te.data,
              fe = le.stride,
              Me = te.offset;
            if (le.isInstancedInterleavedBuffer) {
              for (let ge = 0; ge < G.locationSize; ge++)
                w(G.location + ge, le.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = le.meshPerAttribute * le.count);
            } else
              for (let ge = 0; ge < G.locationSize; ge++) _(G.location + ge);
            n.bindBuffer(n.ARRAY_BUFFER, ae);
            for (let ge = 0; ge < G.locationSize; ge++)
              M(
                G.location + ge,
                V / G.locationSize,
                J,
                F,
                fe * se,
                (Me + (V / G.locationSize) * ge) * se,
                de
              );
          } else {
            if (te.isInstancedBufferAttribute) {
              for (let le = 0; le < G.locationSize; le++)
                w(G.location + le, te.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = te.meshPerAttribute * te.count);
            } else
              for (let le = 0; le < G.locationSize; le++) _(G.location + le);
            n.bindBuffer(n.ARRAY_BUFFER, ae);
            for (let le = 0; le < G.locationSize; le++)
              M(
                G.location + le,
                V / G.locationSize,
                J,
                F,
                V * se,
                (V / G.locationSize) * le * se,
                de
              );
          }
        } else if (Y !== void 0) {
          const F = Y[re];
          if (F !== void 0)
            switch (F.length) {
              case 2:
                n.vertexAttrib2fv(G.location, F);
                break;
              case 3:
                n.vertexAttrib3fv(G.location, F);
                break;
              case 4:
                n.vertexAttrib4fv(G.location, F);
                break;
              default:
                n.vertexAttrib1fv(G.location, F);
            }
        }
      }
    }
    T();
  }
  function R() {
    U();
    for (const L in r) {
      const H = r[L];
      for (const W in H) {
        const $ = H[W];
        for (const K in $) d($[K].object), delete $[K];
        delete H[W];
      }
      delete r[L];
    }
  }
  function D(L) {
    if (r[L.id] === void 0) return;
    const H = r[L.id];
    for (const W in H) {
      const $ = H[W];
      for (const K in $) d($[K].object), delete $[K];
      delete H[W];
    }
    delete r[L.id];
  }
  function P(L) {
    for (const H in r) {
      const W = r[H];
      if (W[L.id] === void 0) continue;
      const $ = W[L.id];
      for (const K in $) d($[K].object), delete $[K];
      delete W[L.id];
    }
  }
  function U() {
    O(), (s = !0), o !== i && ((o = i), c(o.object));
  }
  function O() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: a,
    reset: U,
    resetDefaultState: O,
    dispose: R,
    releaseStatesOfGeometry: D,
    releaseStatesOfProgram: P,
    initAttributes: S,
    enableAttribute: _,
    disableUnusedAttributes: T,
  };
}
function J6(n, e, t) {
  let r;
  function i(c) {
    r = c;
  }
  function o(c, d) {
    n.drawArrays(r, c, d), t.update(d, r, 1);
  }
  function s(c, d, m) {
    m !== 0 && (n.drawArraysInstanced(r, c, d, m), t.update(d, r, m));
  }
  function a(c, d, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, c, 0, d, 0, m);
    let y = 0;
    for (let x = 0; x < m; x++) y += d[x];
    t.update(y, r, 1);
  }
  function u(c, d, m, g) {
    if (m === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null) for (let x = 0; x < c.length; x++) s(c[x], d[x], g[x]);
    else {
      y.multiDrawArraysInstancedWEBGL(r, c, 0, d, 0, g, 0, m);
      let x = 0;
      for (let S = 0; S < m; S++) x += d[S];
      for (let S = 0; S < g.length; S++) t.update(x, r, g[S]);
    }
  }
  (this.setMode = i),
    (this.render = o),
    (this.renderInstances = s),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = u);
}
function Q6(n, e, t, r) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const D = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(D) {
    return !(
      D !== no &&
      r.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(D) {
    const P =
      D === Wh &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      D !== pa &&
      r.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      D !== Bo &&
      !P
    );
  }
  function u(D) {
    if (D === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      D = "mediump";
    }
    return D === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const d = u(c);
  d !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      d,
      "instead."
    ),
    (c = d));
  const m = t.logarithmicDepthBuffer === !0,
    g = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    y = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    x = n.getParameter(n.MAX_TEXTURE_SIZE),
    S = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    _ = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    w = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    T = n.getParameter(n.MAX_VARYING_VECTORS),
    M = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    A = y > 0,
    R = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: o,
    getMaxPrecision: u,
    textureFormatReadable: s,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: m,
    maxTextures: g,
    maxVertexTextures: y,
    maxTextureSize: x,
    maxCubemapSize: S,
    maxAttributes: _,
    maxVertexUniforms: w,
    maxVaryings: T,
    maxFragmentUniforms: M,
    vertexTextures: A,
    maxSamples: R,
  };
}
function eH(n) {
  const e = this;
  let t = null,
    r = 0,
    i = !1,
    o = !1;
  const s = new Ll(),
    a = new en(),
    u = { value: null, needsUpdate: !1 };
  (this.uniform = u),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (m, g) {
      const y = m.length !== 0 || g || r !== 0 || i;
      return (i = g), (r = m.length), y;
    }),
    (this.beginShadows = function () {
      (o = !0), d(null);
    }),
    (this.endShadows = function () {
      o = !1;
    }),
    (this.setGlobalState = function (m, g) {
      t = d(m, g, 0);
    }),
    (this.setState = function (m, g, y) {
      const x = m.clippingPlanes,
        S = m.clipIntersection,
        _ = m.clipShadows,
        w = n.get(m);
      if (!i || x === null || x.length === 0 || (o && !_)) o ? d(null) : c();
      else {
        const T = o ? 0 : r,
          M = T * 4;
        let A = w.clippingState || null;
        (u.value = A), (A = d(x, g, M, y));
        for (let R = 0; R !== M; ++R) A[R] = t[R];
        (w.clippingState = A),
          (this.numIntersection = S ? this.numPlanes : 0),
          (this.numPlanes += T);
      }
    });
  function c() {
    u.value !== t && ((u.value = t), (u.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function d(m, g, y, x) {
    const S = m !== null ? m.length : 0;
    let _ = null;
    if (S !== 0) {
      if (((_ = u.value), x !== !0 || _ === null)) {
        const w = y + S * 4,
          T = g.matrixWorldInverse;
        a.getNormalMatrix(T),
          (_ === null || _.length < w) && (_ = new Float32Array(w));
        for (let M = 0, A = y; M !== S; ++M, A += 4)
          s.copy(m[M]).applyMatrix4(T, a),
            s.normal.toArray(_, A),
            (_[A + 3] = s.constant);
      }
      (u.value = _), (u.needsUpdate = !0);
    }
    return (e.numPlanes = S), (e.numIntersection = 0), _;
  }
}
function tH(n) {
  let e = new WeakMap();
  function t(s, a) {
    return a === km ? (s.mapping = Hl) : a === Om && (s.mapping = Zu), s;
  }
  function r(s) {
    if (s && s.isTexture) {
      const a = s.mapping;
      if (a === km || a === Om)
        if (e.has(s)) {
          const u = e.get(s).texture;
          return t(u, s.mapping);
        } else {
          const u = s.image;
          if (u && u.height > 0) {
            const c = new bR(u.height);
            return (
              c.fromEquirectangularTexture(n, s),
              e.set(s, c),
              s.addEventListener("dispose", i),
              t(c.texture, s.mapping)
            );
          } else return null;
        }
    }
    return s;
  }
  function i(s) {
    const a = s.target;
    a.removeEventListener("dispose", i);
    const u = e.get(a);
    u !== void 0 && (e.delete(a), u.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: r, dispose: o };
}
class Xu extends ug {
  constructor(e = -1, t = 1, r = 1, i = -1, o = 0.1, s = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = i),
      (this.near = o),
      (this.far = s),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, i, o, s) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let o = r - e,
      s = r + e,
      a = i + t,
      u = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += c * this.view.offsetX),
        (s = o + c * this.view.width),
        (a -= d * this.view.offsetY),
        (u = a - d * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      o,
      s,
      a,
      u,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const gh = 4,
  $E = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  cf = 20,
  e1 = new Xu(),
  XE = new St();
let t1 = null,
  n1 = 0,
  r1 = 0,
  i1 = !1;
const af = (1 + Math.sqrt(5)) / 2,
  Qd = 1 / af,
  YE = [
    new oe(-af, Qd, 0),
    new oe(af, Qd, 0),
    new oe(-Qd, 0, af),
    new oe(Qd, 0, af),
    new oe(0, af, -Qd),
    new oe(0, af, Qd),
    new oe(-1, 1, -1),
    new oe(1, 1, -1),
    new oe(-1, 1, 1),
    new oe(1, 1, 1),
  ];
class vS {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    (t1 = this._renderer.getRenderTarget()),
      (n1 = this._renderer.getActiveCubeFace()),
      (r1 = this._renderer.getActiveMipmapLevel()),
      (i1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const o = this._allocateTargets();
    return (
      (o.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, o),
      t > 0 && this._blur(o, 0, 0, t),
      this._applyPMREM(o),
      this._cleanup(o),
      o
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = ZE()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = KE()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(t1, n1, r1),
      (this._renderer.xr.enabled = i1),
      (e.scissorTest = !1),
      Uv(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Hl || e.mapping === Zu
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (t1 = this._renderer.getRenderTarget()),
      (n1 = this._renderer.getActiveCubeFace()),
      (r1 = this._renderer.getActiveMipmapLevel()),
      (i1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: Cr,
        minFilter: Cr,
        generateMipmaps: !1,
        type: Wh,
        format: no,
        colorSpace: jl,
        depthBuffer: !1,
      },
      i = qE(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = qE(e, t, r));
      const { _lodMax: o } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = nH(o)),
        (this._blurMaterial = rH(o, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new ur(this._lodPlanes[0], e);
    this._renderer.compile(t, e1);
  }
  _sceneToCubeUV(e, t, r, i) {
    const a = new Nr(90, 1, t, r),
      u = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      d = this._renderer,
      m = d.autoClear,
      g = d.toneMapping;
    d.getClearColor(XE), (d.toneMapping = Za), (d.autoClear = !1);
    const y = new Xl({
        name: "PMREM.Background",
        side: ro,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new ur(new kf(), y);
    let S = !1;
    const _ = e.background;
    _
      ? _.isColor && (y.color.copy(_), (e.background = null), (S = !0))
      : (y.color.copy(XE), (S = !0));
    for (let w = 0; w < 6; w++) {
      const T = w % 3;
      T === 0
        ? (a.up.set(0, u[w], 0), a.lookAt(c[w], 0, 0))
        : T === 1
        ? (a.up.set(0, 0, u[w]), a.lookAt(0, c[w], 0))
        : (a.up.set(0, u[w], 0), a.lookAt(0, 0, c[w]));
      const M = this._cubeSize;
      Uv(i, T * M, w > 2 ? M : 0, M, M),
        d.setRenderTarget(i),
        S && d.render(x, a),
        d.render(e, a);
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (d.toneMapping = g),
      (d.autoClear = m),
      (e.background = _);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      i = e.mapping === Hl || e.mapping === Zu;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = ZE()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = KE());
    const o = i ? this._cubemapMaterial : this._equirectMaterial,
      s = new ur(this._lodPlanes[0], o),
      a = o.uniforms;
    a.envMap.value = e;
    const u = this._cubeSize;
    Uv(t, 0, 0, 3 * u, 2 * u), r.setRenderTarget(t), r.render(s, e1);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const s = Math.sqrt(
          this._sigmas[o] * this._sigmas[o] -
            this._sigmas[o - 1] * this._sigmas[o - 1]
        ),
        a = YE[(i - o - 1) % YE.length];
      this._blur(e, o - 1, o, s, a);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, o) {
    const s = this._pingPongRenderTarget;
    this._halfBlur(e, s, t, r, i, "latitudinal", o),
      this._halfBlur(s, e, r, r, i, "longitudinal", o);
  }
  _halfBlur(e, t, r, i, o, s, a) {
    const u = this._renderer,
      c = this._blurMaterial;
    s !== "latitudinal" &&
      s !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const d = 3,
      m = new ur(this._lodPlanes[i], c),
      g = c.uniforms,
      y = this._sizeLods[r] - 1,
      x = isFinite(o) ? Math.PI / (2 * y) : (2 * Math.PI) / (2 * cf - 1),
      S = o / x,
      _ = isFinite(o) ? 1 + Math.floor(d * S) : cf;
    _ > cf &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${cf}`
      );
    const w = [];
    let T = 0;
    for (let P = 0; P < cf; ++P) {
      const U = P / S,
        O = Math.exp((-U * U) / 2);
      w.push(O), P === 0 ? (T += O) : P < _ && (T += 2 * O);
    }
    for (let P = 0; P < w.length; P++) w[P] = w[P] / T;
    (g.envMap.value = e.texture),
      (g.samples.value = _),
      (g.weights.value = w),
      (g.latitudinal.value = s === "latitudinal"),
      a && (g.poleAxis.value = a);
    const { _lodMax: M } = this;
    (g.dTheta.value = x), (g.mipInt.value = M - r);
    const A = this._sizeLods[i],
      R = 3 * A * (i > M - gh ? i - M + gh : 0),
      D = 4 * (this._cubeSize - A);
    Uv(t, R, D, 3 * A, 2 * A), u.setRenderTarget(t), u.render(m, e1);
  }
}
function nH(n) {
  const e = [],
    t = [],
    r = [];
  let i = n;
  const o = n - gh + 1 + $E.length;
  for (let s = 0; s < o; s++) {
    const a = Math.pow(2, i);
    t.push(a);
    let u = 1 / a;
    s > n - gh ? (u = $E[s - n + gh - 1]) : s === 0 && (u = 0), r.push(u);
    const c = 1 / (a - 2),
      d = -c,
      m = 1 + c,
      g = [d, d, m, d, m, m, d, d, m, m, d, m],
      y = 6,
      x = 6,
      S = 3,
      _ = 2,
      w = 1,
      T = new Float32Array(S * x * y),
      M = new Float32Array(_ * x * y),
      A = new Float32Array(w * x * y);
    for (let D = 0; D < y; D++) {
      const P = ((D % 3) * 2) / 3 - 1,
        U = D > 2 ? 0 : -1,
        O = [
          P,
          U,
          0,
          P + 2 / 3,
          U,
          0,
          P + 2 / 3,
          U + 1,
          0,
          P,
          U,
          0,
          P + 2 / 3,
          U + 1,
          0,
          P,
          U + 1,
          0,
        ];
      T.set(O, S * x * D), M.set(g, _ * x * D);
      const L = [D, D, D, D, D, D];
      A.set(L, w * x * D);
    }
    const R = new sn();
    R.setAttribute("position", new Gn(T, S)),
      R.setAttribute("uv", new Gn(M, _)),
      R.setAttribute("faceIndex", new Gn(A, w)),
      e.push(R),
      i > gh && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function qE(n, e, t) {
  const r = new ma(n, e, t);
  return (
    (r.texture.mapping = Vh),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function Uv(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function rH(n, e, t) {
  const r = new Float32Array(cf),
    i = new oe(0, 1, 0);
  return new Ds({
    name: "SphericalGaussianBlur",
    defines: {
      n: cf,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Nw(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Fl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function KE() {
  return new Ds({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Nw(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Fl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ZE() {
  return new Ds({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Nw(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Fl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Nw() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function iH(n) {
  let e = new WeakMap(),
    t = null;
  function r(a) {
    if (a && a.isTexture) {
      const u = a.mapping,
        c = u === km || u === Om,
        d = u === Hl || u === Zu;
      if (c || d) {
        let m = e.get(a);
        const g = m !== void 0 ? m.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== g)
          return (
            t === null && (t = new vS(n)),
            (m = c ? t.fromEquirectangular(a, m) : t.fromCubemap(a, m)),
            (m.texture.pmremVersion = a.pmremVersion),
            e.set(a, m),
            m.texture
          );
        if (m !== void 0) return m.texture;
        {
          const y = a.image;
          return (c && y && y.height > 0) || (d && y && i(y))
            ? (t === null && (t = new vS(n)),
              (m = c ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (m.texture.pmremVersion = a.pmremVersion),
              e.set(a, m),
              a.addEventListener("dispose", o),
              m.texture)
            : null;
        }
      }
    }
    return a;
  }
  function i(a) {
    let u = 0;
    const c = 6;
    for (let d = 0; d < c; d++) a[d] !== void 0 && u++;
    return u === c;
  }
  function o(a) {
    const u = a.target;
    u.removeEventListener("dispose", o);
    const c = e.get(u);
    c !== void 0 && (e.delete(u), c.dispose());
  }
  function s() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: s };
}
function oH(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (r) {
      const i = t(r);
      return (
        i === null &&
          Mh("THREE.WebGLRenderer: " + r + " extension not supported."),
        i
      );
    },
  };
}
function sH(n, e, t, r) {
  const i = {},
    o = new WeakMap();
  function s(m) {
    const g = m.target;
    g.index !== null && e.remove(g.index);
    for (const x in g.attributes) e.remove(g.attributes[x]);
    for (const x in g.morphAttributes) {
      const S = g.morphAttributes[x];
      for (let _ = 0, w = S.length; _ < w; _++) e.remove(S[_]);
    }
    g.removeEventListener("dispose", s), delete i[g.id];
    const y = o.get(g);
    y && (e.remove(y), o.delete(g)),
      r.releaseStatesOfGeometry(g),
      g.isInstancedBufferGeometry === !0 && delete g._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(m, g) {
    return (
      i[g.id] === !0 ||
        (g.addEventListener("dispose", s),
        (i[g.id] = !0),
        t.memory.geometries++),
      g
    );
  }
  function u(m) {
    const g = m.attributes;
    for (const x in g) e.update(g[x], n.ARRAY_BUFFER);
    const y = m.morphAttributes;
    for (const x in y) {
      const S = y[x];
      for (let _ = 0, w = S.length; _ < w; _++) e.update(S[_], n.ARRAY_BUFFER);
    }
  }
  function c(m) {
    const g = [],
      y = m.index,
      x = m.attributes.position;
    let S = 0;
    if (y !== null) {
      const T = y.array;
      S = y.version;
      for (let M = 0, A = T.length; M < A; M += 3) {
        const R = T[M + 0],
          D = T[M + 1],
          P = T[M + 2];
        g.push(R, D, D, P, P, R);
      }
    } else if (x !== void 0) {
      const T = x.array;
      S = x.version;
      for (let M = 0, A = T.length / 3 - 1; M < A; M += 3) {
        const R = M + 0,
          D = M + 1,
          P = M + 2;
        g.push(R, D, D, P, P, R);
      }
    } else return;
    const _ = new (gR(g) ? Ow : kw)(g, 1);
    _.version = S;
    const w = o.get(m);
    w && e.remove(w), o.set(m, _);
  }
  function d(m) {
    const g = o.get(m);
    if (g) {
      const y = m.index;
      y !== null && g.version < y.version && c(m);
    } else c(m);
    return o.get(m);
  }
  return { get: a, update: u, getWireframeAttribute: d };
}
function aH(n, e, t) {
  let r;
  function i(g) {
    r = g;
  }
  let o, s;
  function a(g) {
    (o = g.type), (s = g.bytesPerElement);
  }
  function u(g, y) {
    n.drawElements(r, y, o, g * s), t.update(y, r, 1);
  }
  function c(g, y, x) {
    x !== 0 && (n.drawElementsInstanced(r, y, o, g * s, x), t.update(y, r, x));
  }
  function d(g, y, x) {
    if (x === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, y, 0, o, g, 0, x);
    let _ = 0;
    for (let w = 0; w < x; w++) _ += y[w];
    t.update(_, r, 1);
  }
  function m(g, y, x, S) {
    if (x === 0) return;
    const _ = e.get("WEBGL_multi_draw");
    if (_ === null) for (let w = 0; w < g.length; w++) c(g[w] / s, y[w], S[w]);
    else {
      _.multiDrawElementsInstancedWEBGL(r, y, 0, o, g, 0, S, 0, x);
      let w = 0;
      for (let T = 0; T < x; T++) w += y[T];
      for (let T = 0; T < S.length; T++) t.update(w, r, S[T]);
    }
  }
  (this.setMode = i),
    (this.setIndex = a),
    (this.render = u),
    (this.renderInstances = c),
    (this.renderMultiDraw = d),
    (this.renderMultiDrawInstances = m);
}
function lH(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(o, s, a) {
    switch ((t.calls++, s)) {
      case n.TRIANGLES:
        t.triangles += a * (o / 3);
        break;
      case n.LINES:
        t.lines += a * (o / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (o - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * o;
        break;
      case n.POINTS:
        t.points += a * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function uH(n, e, t) {
  const r = new WeakMap(),
    i = new dn();
  function o(s, a, u) {
    const c = s.morphTargetInfluences,
      d =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      m = d !== void 0 ? d.length : 0;
    let g = r.get(a);
    if (g === void 0 || g.count !== m) {
      let L = function () {
        U.dispose(), r.delete(a), a.removeEventListener("dispose", L);
      };
      var y = L;
      g !== void 0 && g.texture.dispose();
      const x = a.morphAttributes.position !== void 0,
        S = a.morphAttributes.normal !== void 0,
        _ = a.morphAttributes.color !== void 0,
        w = a.morphAttributes.position || [],
        T = a.morphAttributes.normal || [],
        M = a.morphAttributes.color || [];
      let A = 0;
      x === !0 && (A = 1), S === !0 && (A = 2), _ === !0 && (A = 3);
      let R = a.attributes.position.count * A,
        D = 1;
      R > e.maxTextureSize &&
        ((D = Math.ceil(R / e.maxTextureSize)), (R = e.maxTextureSize));
      const P = new Float32Array(R * D * 4 * m),
        U = new Qy(P, R, D, m);
      (U.type = Bo), (U.needsUpdate = !0);
      const O = A * 4;
      for (let H = 0; H < m; H++) {
        const W = w[H],
          $ = T[H],
          K = M[H],
          Z = R * D * 4 * H;
        for (let Y = 0; Y < W.count; Y++) {
          const re = Y * O;
          x === !0 &&
            (i.fromBufferAttribute(W, Y),
            (P[Z + re + 0] = i.x),
            (P[Z + re + 1] = i.y),
            (P[Z + re + 2] = i.z),
            (P[Z + re + 3] = 0)),
            S === !0 &&
              (i.fromBufferAttribute($, Y),
              (P[Z + re + 4] = i.x),
              (P[Z + re + 5] = i.y),
              (P[Z + re + 6] = i.z),
              (P[Z + re + 7] = 0)),
            _ === !0 &&
              (i.fromBufferAttribute(K, Y),
              (P[Z + re + 8] = i.x),
              (P[Z + re + 9] = i.y),
              (P[Z + re + 10] = i.z),
              (P[Z + re + 11] = K.itemSize === 4 ? i.w : 1));
        }
      }
      (g = { count: m, texture: U, size: new tt(R, D) }),
        r.set(a, g),
        a.addEventListener("dispose", L);
    }
    if (s.isInstancedMesh === !0 && s.morphTexture !== null)
      u.getUniforms().setValue(n, "morphTexture", s.morphTexture, t);
    else {
      let x = 0;
      for (let _ = 0; _ < c.length; _++) x += c[_];
      const S = a.morphTargetsRelative ? 1 : 1 - x;
      u.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
        u.getUniforms().setValue(n, "morphTargetInfluences", c);
    }
    u.getUniforms().setValue(n, "morphTargetsTexture", g.texture, t),
      u.getUniforms().setValue(n, "morphTargetsTextureSize", g.size);
  }
  return { update: o };
}
function cH(n, e, t, r) {
  let i = new WeakMap();
  function o(u) {
    const c = r.render.frame,
      d = u.geometry,
      m = e.get(u, d);
    if (
      (i.get(m) !== c && (e.update(m), i.set(m, c)),
      u.isInstancedMesh &&
        (u.hasEventListener("dispose", a) === !1 &&
          u.addEventListener("dispose", a),
        i.get(u) !== c &&
          (t.update(u.instanceMatrix, n.ARRAY_BUFFER),
          u.instanceColor !== null && t.update(u.instanceColor, n.ARRAY_BUFFER),
          i.set(u, c))),
      u.isSkinnedMesh)
    ) {
      const g = u.skeleton;
      i.get(g) !== c && (g.update(), i.set(g, c));
    }
    return m;
  }
  function s() {
    i = new WeakMap();
  }
  function a(u) {
    const c = u.target;
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: o, dispose: s };
}
class Uw extends er {
  constructor(e, t, r, i, o, s, a, u, c, d = xf) {
    if (d !== xf && d !== Af)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && d === xf && (r = Vl),
      r === void 0 && d === Af && (r = Cf),
      super(null, i, o, s, a, u, d, r, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : wi),
      (this.minFilter = u !== void 0 ? u : wi),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const ER = new er(),
  JE = new Uw(1, 1),
  TR = new Qy(),
  CR = new Dw(),
  AR = new cg(),
  QE = [],
  eT = [],
  tT = new Float32Array(16),
  nT = new Float32Array(9),
  rT = new Float32Array(4);
function Gh(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let o = QE[i];
  if ((o === void 0 && ((o = new Float32Array(i)), (QE[i] = o)), e !== 0)) {
    r.toArray(o, 0);
    for (let s = 1, a = 0; s !== e; ++s) (a += t), n[s].toArray(o, a);
  }
  return o;
}
function di(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function hi(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function ex(n, e) {
  let t = eT[e];
  t === void 0 && ((t = new Int32Array(e)), (eT[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function fH(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function dH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (di(t, e)) return;
    n.uniform2fv(this.addr, e), hi(t, e);
  }
}
function hH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (di(t, e)) return;
    n.uniform3fv(this.addr, e), hi(t, e);
  }
}
function pH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (di(t, e)) return;
    n.uniform4fv(this.addr, e), hi(t, e);
  }
}
function mH(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (di(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), hi(t, e);
  } else {
    if (di(t, r)) return;
    rT.set(r), n.uniformMatrix2fv(this.addr, !1, rT), hi(t, r);
  }
}
function gH(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (di(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), hi(t, e);
  } else {
    if (di(t, r)) return;
    nT.set(r), n.uniformMatrix3fv(this.addr, !1, nT), hi(t, r);
  }
}
function vH(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (di(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), hi(t, e);
  } else {
    if (di(t, r)) return;
    tT.set(r), n.uniformMatrix4fv(this.addr, !1, tT), hi(t, r);
  }
}
function yH(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function xH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (di(t, e)) return;
    n.uniform2iv(this.addr, e), hi(t, e);
  }
}
function _H(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (di(t, e)) return;
    n.uniform3iv(this.addr, e), hi(t, e);
  }
}
function SH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (di(t, e)) return;
    n.uniform4iv(this.addr, e), hi(t, e);
  }
}
function wH(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function bH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (di(t, e)) return;
    n.uniform2uiv(this.addr, e), hi(t, e);
  }
}
function MH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (di(t, e)) return;
    n.uniform3uiv(this.addr, e), hi(t, e);
  }
}
function EH(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (di(t, e)) return;
    n.uniform4uiv(this.addr, e), hi(t, e);
  }
}
function TH(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i));
  let o;
  this.type === n.SAMPLER_2D_SHADOW
    ? ((JE.compareFunction = Iw), (o = JE))
    : (o = ER),
    t.setTexture2D(e || o, i);
}
function CH(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture3D(e || CR, i);
}
function AH(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTextureCube(e || AR, i);
}
function RH(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2DArray(e || TR, i);
}
function PH(n) {
  switch (n) {
    case 5126:
      return fH;
    case 35664:
      return dH;
    case 35665:
      return hH;
    case 35666:
      return pH;
    case 35674:
      return mH;
    case 35675:
      return gH;
    case 35676:
      return vH;
    case 5124:
    case 35670:
      return yH;
    case 35667:
    case 35671:
      return xH;
    case 35668:
    case 35672:
      return _H;
    case 35669:
    case 35673:
      return SH;
    case 5125:
      return wH;
    case 36294:
      return bH;
    case 36295:
      return MH;
    case 36296:
      return EH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return TH;
    case 35679:
    case 36299:
    case 36307:
      return CH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return AH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return RH;
  }
}
function IH(n, e) {
  n.uniform1fv(this.addr, e);
}
function LH(n, e) {
  const t = Gh(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function DH(n, e) {
  const t = Gh(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function kH(n, e) {
  const t = Gh(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function OH(n, e) {
  const t = Gh(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function NH(n, e) {
  const t = Gh(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function UH(n, e) {
  const t = Gh(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function FH(n, e) {
  n.uniform1iv(this.addr, e);
}
function BH(n, e) {
  n.uniform2iv(this.addr, e);
}
function zH(n, e) {
  n.uniform3iv(this.addr, e);
}
function HH(n, e) {
  n.uniform4iv(this.addr, e);
}
function VH(n, e) {
  n.uniform1uiv(this.addr, e);
}
function WH(n, e) {
  n.uniform2uiv(this.addr, e);
}
function GH(n, e) {
  n.uniform3uiv(this.addr, e);
}
function jH(n, e) {
  n.uniform4uiv(this.addr, e);
}
function $H(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = ex(t, i);
  di(r, o) || (n.uniform1iv(this.addr, o), hi(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture2D(e[s] || ER, o[s]);
}
function XH(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = ex(t, i);
  di(r, o) || (n.uniform1iv(this.addr, o), hi(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture3D(e[s] || CR, o[s]);
}
function YH(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = ex(t, i);
  di(r, o) || (n.uniform1iv(this.addr, o), hi(r, o));
  for (let s = 0; s !== i; ++s) t.setTextureCube(e[s] || AR, o[s]);
}
function qH(n, e, t) {
  const r = this.cache,
    i = e.length,
    o = ex(t, i);
  di(r, o) || (n.uniform1iv(this.addr, o), hi(r, o));
  for (let s = 0; s !== i; ++s) t.setTexture2DArray(e[s] || TR, o[s]);
}
function KH(n) {
  switch (n) {
    case 5126:
      return IH;
    case 35664:
      return LH;
    case 35665:
      return DH;
    case 35666:
      return kH;
    case 35674:
      return OH;
    case 35675:
      return NH;
    case 35676:
      return UH;
    case 5124:
    case 35670:
      return FH;
    case 35667:
    case 35671:
      return BH;
    case 35668:
    case 35672:
      return zH;
    case 35669:
    case 35673:
      return HH;
    case 5125:
      return VH;
    case 36294:
      return WH;
    case 36295:
      return GH;
    case 36296:
      return jH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return $H;
    case 35679:
    case 36299:
    case 36307:
      return XH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return YH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return qH;
  }
}
class ZH {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = PH(t.type));
  }
}
class JH {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = KH(t.type));
  }
}
class QH {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let o = 0, s = i.length; o !== s; ++o) {
      const a = i[o];
      a.setValue(e, t[a.id], r);
    }
  }
}
const o1 = /(\w+)(\])?(\[|\.)?/g;
function iT(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function eV(n, e, t) {
  const r = n.name,
    i = r.length;
  for (o1.lastIndex = 0; ; ) {
    const o = o1.exec(r),
      s = o1.lastIndex;
    let a = o[1];
    const u = o[2] === "]",
      c = o[3];
    if ((u && (a = a | 0), c === void 0 || (c === "[" && s + 2 === i))) {
      iT(t, c === void 0 ? new ZH(a, n, e) : new JH(a, n, e));
      break;
    } else {
      let m = t.map[a];
      m === void 0 && ((m = new QH(a)), iT(t, m)), (t = m);
    }
  }
}
class M0 {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const o = e.getActiveUniform(t, i),
        s = e.getUniformLocation(t, o.name);
      eV(o, s, this);
    }
  }
  setValue(e, t, r, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let o = 0, s = t.length; o !== s; ++o) {
      const a = t[o],
        u = r[a.id];
      u.needsUpdate !== !1 && a.setValue(e, u.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const s = e[i];
      s.id in t && r.push(s);
    }
    return r;
  }
}
function oT(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
const tV = 37297;
let nV = 0;
function rV(n, e) {
  const t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    o = Math.min(e + 6, t.length);
  for (let s = i; s < o; s++) {
    const a = s + 1;
    r.push(`${a === e ? ">" : " "} ${a}: ${t[s]}`);
  }
  return r.join(`
`);
}
function iV(n) {
  const e = Sn.getPrimaries(Sn.workingColorSpace),
    t = Sn.getPrimaries(n);
  let r;
  switch (
    (e === t
      ? (r = "")
      : e === Vm && t === Hm
      ? (r = "LinearDisplayP3ToLinearSRGB")
      : e === Hm && t === Vm && (r = "LinearSRGBToLinearDisplayP3"),
    n)
  ) {
    case jl:
    case lg:
      return [r, "LinearTransferOETF"];
    case As:
    case Jy:
      return [r, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [r, "LinearTransferOETF"]
      );
  }
}
function sT(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const s = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      rV(n.getShaderSource(e), s)
    );
  } else return i;
}
function oV(n, e) {
  const t = iV(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function sV(n, e) {
  let t;
  switch (e) {
    case KA:
      t = "Linear";
      break;
    case ZA:
      t = "Reinhard";
      break;
    case JA:
      t = "OptimizedCineon";
      break;
    case yw:
      t = "ACESFilmic";
      break;
    case eR:
      t = "AgX";
      break;
    case tR:
      t = "Neutral";
      break;
    case QA:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const Fv = new oe();
function aV() {
  Sn.getLuminanceCoefficients(Fv);
  const n = Fv.x.toFixed(4),
    e = Fv.y.toFixed(4),
    t = Fv.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function lV(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(sm).join(`
`);
}
function uV(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function cV(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const o = n.getActiveAttrib(e, i),
      s = o.name;
    let a = 1;
    o.type === n.FLOAT_MAT2 && (a = 2),
      o.type === n.FLOAT_MAT3 && (a = 3),
      o.type === n.FLOAT_MAT4 && (a = 4),
      (t[s] = {
        type: o.type,
        location: n.getAttribLocation(e, s),
        locationSize: a,
      });
  }
  return t;
}
function sm(n) {
  return n !== "";
}
function aT(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function lT(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const fV = /^[ \t]*#include +<([\w\d./]+)>/gm;
function yS(n) {
  return n.replace(fV, hV);
}
const dV = new Map();
function hV(n, e) {
  let t = rn[e];
  if (t === void 0) {
    const r = dV.get(e);
    if (r !== void 0)
      (t = rn[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return yS(t);
}
const pV =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function uT(n) {
  return n.replace(pV, mV);
}
function mV(n, e, t, r) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function cT(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function gV(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Wy
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === hm
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === la && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function vV(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Hl:
      case Zu:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Vh:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function yV(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Zu:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function xV(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case sg:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case YA:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case qA:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function _V(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function SV(n, e, t, r) {
  const i = n.getContext(),
    o = t.defines;
  let s = t.vertexShader,
    a = t.fragmentShader;
  const u = gV(t),
    c = vV(t),
    d = yV(t),
    m = xV(t),
    g = _V(t),
    y = lV(t),
    x = uV(o),
    S = i.createProgram();
  let _,
    w,
    T = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((_ = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
      ].filter(sm).join(`
`)),
      _.length > 0 &&
        (_ += `
`),
      (w = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
      ].filter(sm).join(`
`)),
      w.length > 0 &&
        (w += `
`))
    : ((_ = [
        cT(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + d : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(sm).join(`
`)),
      (w = [
        cT(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + d : "",
        t.envMap ? "#define " + m : "",
        g ? "#define CUBEUV_TEXEL_WIDTH " + g.texelWidth : "",
        g ? "#define CUBEUV_TEXEL_HEIGHT " + g.texelHeight : "",
        g ? "#define CUBEUV_MAX_MIP " + g.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Za ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Za ? rn.tonemapping_pars_fragment : "",
        t.toneMapping !== Za ? sV("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        rn.colorspace_pars_fragment,
        oV("linearToOutputTexel", t.outputColorSpace),
        aV(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(sm).join(`
`))),
    (s = yS(s)),
    (s = aT(s, t)),
    (s = lT(s, t)),
    (a = yS(a)),
    (a = aT(a, t)),
    (a = lT(a, t)),
    (s = uT(s)),
    (a = uT(a)),
    t.isRawShaderMaterial !== !0 &&
      ((T = `#version 300 es
`),
      (_ =
        [
          y,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        _),
      (w =
        [
          "#define varying in",
          t.glslVersion === gS
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === gS ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        w));
  const M = T + _ + s,
    A = T + w + a,
    R = oT(i, i.VERTEX_SHADER, M),
    D = oT(i, i.FRAGMENT_SHADER, A);
  i.attachShader(S, R),
    i.attachShader(S, D),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(S, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(S, 0, "position"),
    i.linkProgram(S);
  function P(H) {
    if (n.debug.checkShaderErrors) {
      const W = i.getProgramInfoLog(S).trim(),
        $ = i.getShaderInfoLog(R).trim(),
        K = i.getShaderInfoLog(D).trim();
      let Z = !0,
        Y = !0;
      if (i.getProgramParameter(S, i.LINK_STATUS) === !1)
        if (((Z = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(i, S, R, D);
        else {
          const re = sT(i, R, "vertex"),
            G = sT(i, D, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(S, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              H.name +
              `
Material Type: ` +
              H.type +
              `

Program Info Log: ` +
              W +
              `
` +
              re +
              `
` +
              G
          );
        }
      else
        W !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", W)
          : ($ === "" || K === "") && (Y = !1);
      Y &&
        (H.diagnostics = {
          runnable: Z,
          programLog: W,
          vertexShader: { log: $, prefix: _ },
          fragmentShader: { log: K, prefix: w },
        });
    }
    i.deleteShader(R), i.deleteShader(D), (U = new M0(i, S)), (O = cV(i, S));
  }
  let U;
  this.getUniforms = function () {
    return U === void 0 && P(this), U;
  };
  let O;
  this.getAttributes = function () {
    return O === void 0 && P(this), O;
  };
  let L = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return L === !1 && (L = i.getProgramParameter(S, tV)), L;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(S),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = nV++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = S),
    (this.vertexShader = R),
    (this.fragmentShader = D),
    this
  );
}
let wV = 0;
class bV {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(t),
      o = this._getShaderStage(r),
      s = this._getShaderCacheForMaterial(e);
    return (
      s.has(i) === !1 && (s.add(i), i.usedTimes++),
      s.has(o) === !1 && (s.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new MV(e)), t.set(e, r)), r;
  }
}
class MV {
  constructor(e) {
    (this.id = wV++), (this.code = e), (this.usedTimes = 0);
  }
}
function EV(n, e, t, r, i, o, s) {
  const a = new Sf(),
    u = new bV(),
    c = new Set(),
    d = [],
    m = i.logarithmicDepthBuffer,
    g = i.vertexTextures;
  let y = i.precision;
  const x = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function S(O) {
    return c.add(O), O === 0 ? "uv" : `uv${O}`;
  }
  function _(O, L, H, W, $) {
    const K = W.fog,
      Z = $.geometry,
      Y = O.isMeshStandardMaterial ? W.environment : null,
      re = (O.isMeshStandardMaterial ? t : e).get(O.envMap || Y),
      G = re && re.mapping === Vh ? re.image.height : null,
      te = x[O.type];
    O.precision !== null &&
      ((y = i.getMaxPrecision(O.precision)),
      y !== O.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          O.precision,
          "not supported, using",
          y,
          "instead."
        ));
    const F =
        Z.morphAttributes.position ||
        Z.morphAttributes.normal ||
        Z.morphAttributes.color,
      V = F !== void 0 ? F.length : 0;
    let ne = 0;
    Z.morphAttributes.position !== void 0 && (ne = 1),
      Z.morphAttributes.normal !== void 0 && (ne = 2),
      Z.morphAttributes.color !== void 0 && (ne = 3);
    let ae, J, se, de;
    if (te) {
      const ht = ca[te];
      (ae = ht.vertexShader), (J = ht.fragmentShader);
    } else
      (ae = O.vertexShader),
        (J = O.fragmentShader),
        u.update(O),
        (se = u.getVertexShaderID(O)),
        (de = u.getFragmentShaderID(O));
    const le = n.getRenderTarget(),
      fe = $.isInstancedMesh === !0,
      Me = $.isBatchedMesh === !0,
      ge = !!O.map,
      xe = !!O.matcap,
      j = !!re,
      we = !!O.aoMap,
      Ae = !!O.lightMap,
      Oe = !!O.bumpMap,
      Ie = !!O.normalMap,
      rt = !!O.displacementMap,
      De = !!O.emissiveMap,
      Xe = !!O.metalnessMap,
      ee = !!O.roughnessMap,
      B = O.anisotropy > 0,
      ve = O.clearcoat > 0,
      Se = O.dispersion > 0,
      _e = O.iridescence > 0,
      Te = O.sheen > 0,
      at = O.transmission > 0,
      Fe = B && !!O.anisotropyMap,
      Be = ve && !!O.clearcoatMap,
      Ge = ve && !!O.clearcoatNormalMap,
      Ye = ve && !!O.clearcoatRoughnessMap,
      nt = _e && !!O.iridescenceMap,
      xt = _e && !!O.iridescenceThicknessMap,
      $e = Te && !!O.sheenColorMap,
      qe = Te && !!O.sheenRoughnessMap,
      et = !!O.specularMap,
      he = !!O.specularColorMap,
      Je = !!O.specularIntensityMap,
      me = at && !!O.transmissionMap,
      Ve = at && !!O.thicknessMap,
      Re = !!O.gradientMap,
      Ue = !!O.alphaMap,
      it = O.alphaTest > 0,
      mt = !!O.alphaHash,
      gt = !!O.extensions;
    let Nt = Za;
    O.toneMapped &&
      (le === null || le.isXRRenderTarget === !0) &&
      (Nt = n.toneMapping);
    const Ut = {
      shaderID: te,
      shaderType: O.type,
      shaderName: O.name,
      vertexShader: ae,
      fragmentShader: J,
      defines: O.defines,
      customVertexShaderID: se,
      customFragmentShaderID: de,
      isRawShaderMaterial: O.isRawShaderMaterial === !0,
      glslVersion: O.glslVersion,
      precision: y,
      batching: Me,
      batchingColor: Me && $._colorsTexture !== null,
      instancing: fe,
      instancingColor: fe && $.instanceColor !== null,
      instancingMorph: fe && $.morphTexture !== null,
      supportsVertexTextures: g,
      outputColorSpace:
        le === null
          ? n.outputColorSpace
          : le.isXRRenderTarget === !0
          ? le.texture.colorSpace
          : jl,
      alphaToCoverage: !!O.alphaToCoverage,
      map: ge,
      matcap: xe,
      envMap: j,
      envMapMode: j && re.mapping,
      envMapCubeUVHeight: G,
      aoMap: we,
      lightMap: Ae,
      bumpMap: Oe,
      normalMap: Ie,
      displacementMap: g && rt,
      emissiveMap: De,
      normalMapObjectSpace: Ie && O.normalMapType === aR,
      normalMapTangentSpace: Ie && O.normalMapType === ec,
      metalnessMap: Xe,
      roughnessMap: ee,
      anisotropy: B,
      anisotropyMap: Fe,
      clearcoat: ve,
      clearcoatMap: Be,
      clearcoatNormalMap: Ge,
      clearcoatRoughnessMap: Ye,
      dispersion: Se,
      iridescence: _e,
      iridescenceMap: nt,
      iridescenceThicknessMap: xt,
      sheen: Te,
      sheenColorMap: $e,
      sheenRoughnessMap: qe,
      specularMap: et,
      specularColorMap: he,
      specularIntensityMap: Je,
      transmission: at,
      transmissionMap: me,
      thicknessMap: Ve,
      gradientMap: Re,
      opaque:
        O.transparent === !1 && O.blending === yf && O.alphaToCoverage === !1,
      alphaMap: Ue,
      alphaTest: it,
      alphaHash: mt,
      combine: O.combine,
      mapUv: ge && S(O.map.channel),
      aoMapUv: we && S(O.aoMap.channel),
      lightMapUv: Ae && S(O.lightMap.channel),
      bumpMapUv: Oe && S(O.bumpMap.channel),
      normalMapUv: Ie && S(O.normalMap.channel),
      displacementMapUv: rt && S(O.displacementMap.channel),
      emissiveMapUv: De && S(O.emissiveMap.channel),
      metalnessMapUv: Xe && S(O.metalnessMap.channel),
      roughnessMapUv: ee && S(O.roughnessMap.channel),
      anisotropyMapUv: Fe && S(O.anisotropyMap.channel),
      clearcoatMapUv: Be && S(O.clearcoatMap.channel),
      clearcoatNormalMapUv: Ge && S(O.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ye && S(O.clearcoatRoughnessMap.channel),
      iridescenceMapUv: nt && S(O.iridescenceMap.channel),
      iridescenceThicknessMapUv: xt && S(O.iridescenceThicknessMap.channel),
      sheenColorMapUv: $e && S(O.sheenColorMap.channel),
      sheenRoughnessMapUv: qe && S(O.sheenRoughnessMap.channel),
      specularMapUv: et && S(O.specularMap.channel),
      specularColorMapUv: he && S(O.specularColorMap.channel),
      specularIntensityMapUv: Je && S(O.specularIntensityMap.channel),
      transmissionMapUv: me && S(O.transmissionMap.channel),
      thicknessMapUv: Ve && S(O.thicknessMap.channel),
      alphaMapUv: Ue && S(O.alphaMap.channel),
      vertexTangents: !!Z.attributes.tangent && (Ie || B),
      vertexColors: O.vertexColors,
      vertexAlphas:
        O.vertexColors === !0 &&
        !!Z.attributes.color &&
        Z.attributes.color.itemSize === 4,
      pointsUvs: $.isPoints === !0 && !!Z.attributes.uv && (ge || Ue),
      fog: !!K,
      useFog: O.fog === !0,
      fogExp2: !!K && K.isFogExp2,
      flatShading: O.flatShading === !0,
      sizeAttenuation: O.sizeAttenuation === !0,
      logarithmicDepthBuffer: m,
      skinning: $.isSkinnedMesh === !0,
      morphTargets: Z.morphAttributes.position !== void 0,
      morphNormals: Z.morphAttributes.normal !== void 0,
      morphColors: Z.morphAttributes.color !== void 0,
      morphTargetsCount: V,
      morphTextureStride: ne,
      numDirLights: L.directional.length,
      numPointLights: L.point.length,
      numSpotLights: L.spot.length,
      numSpotLightMaps: L.spotLightMap.length,
      numRectAreaLights: L.rectArea.length,
      numHemiLights: L.hemi.length,
      numDirLightShadows: L.directionalShadowMap.length,
      numPointLightShadows: L.pointShadowMap.length,
      numSpotLightShadows: L.spotShadowMap.length,
      numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
      numLightProbes: L.numLightProbes,
      numClippingPlanes: s.numPlanes,
      numClipIntersection: s.numIntersection,
      dithering: O.dithering,
      shadowMapEnabled: n.shadowMap.enabled && H.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: Nt,
      decodeVideoTexture:
        ge &&
        O.map.isVideoTexture === !0 &&
        Sn.getTransfer(O.map.colorSpace) === Jn,
      premultipliedAlpha: O.premultipliedAlpha,
      doubleSided: O.side === Ps,
      flipSided: O.side === ro,
      useDepthPacking: O.depthPacking >= 0,
      depthPacking: O.depthPacking || 0,
      index0AttributeName: O.index0AttributeName,
      extensionClipCullDistance:
        gt &&
        O.extensions.clipCullDistance === !0 &&
        r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((gt && O.extensions.multiDraw === !0) || Me) &&
        r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: O.customProgramCacheKey(),
    };
    return (
      (Ut.vertexUv1s = c.has(1)),
      (Ut.vertexUv2s = c.has(2)),
      (Ut.vertexUv3s = c.has(3)),
      c.clear(),
      Ut
    );
  }
  function w(O) {
    const L = [];
    if (
      (O.shaderID
        ? L.push(O.shaderID)
        : (L.push(O.customVertexShaderID), L.push(O.customFragmentShaderID)),
      O.defines !== void 0)
    )
      for (const H in O.defines) L.push(H), L.push(O.defines[H]);
    return (
      O.isRawShaderMaterial === !1 &&
        (T(L, O), M(L, O), L.push(n.outputColorSpace)),
      L.push(O.customProgramCacheKey),
      L.join()
    );
  }
  function T(O, L) {
    O.push(L.precision),
      O.push(L.outputColorSpace),
      O.push(L.envMapMode),
      O.push(L.envMapCubeUVHeight),
      O.push(L.mapUv),
      O.push(L.alphaMapUv),
      O.push(L.lightMapUv),
      O.push(L.aoMapUv),
      O.push(L.bumpMapUv),
      O.push(L.normalMapUv),
      O.push(L.displacementMapUv),
      O.push(L.emissiveMapUv),
      O.push(L.metalnessMapUv),
      O.push(L.roughnessMapUv),
      O.push(L.anisotropyMapUv),
      O.push(L.clearcoatMapUv),
      O.push(L.clearcoatNormalMapUv),
      O.push(L.clearcoatRoughnessMapUv),
      O.push(L.iridescenceMapUv),
      O.push(L.iridescenceThicknessMapUv),
      O.push(L.sheenColorMapUv),
      O.push(L.sheenRoughnessMapUv),
      O.push(L.specularMapUv),
      O.push(L.specularColorMapUv),
      O.push(L.specularIntensityMapUv),
      O.push(L.transmissionMapUv),
      O.push(L.thicknessMapUv),
      O.push(L.combine),
      O.push(L.fogExp2),
      O.push(L.sizeAttenuation),
      O.push(L.morphTargetsCount),
      O.push(L.morphAttributeCount),
      O.push(L.numDirLights),
      O.push(L.numPointLights),
      O.push(L.numSpotLights),
      O.push(L.numSpotLightMaps),
      O.push(L.numHemiLights),
      O.push(L.numRectAreaLights),
      O.push(L.numDirLightShadows),
      O.push(L.numPointLightShadows),
      O.push(L.numSpotLightShadows),
      O.push(L.numSpotLightShadowsWithMaps),
      O.push(L.numLightProbes),
      O.push(L.shadowMapType),
      O.push(L.toneMapping),
      O.push(L.numClippingPlanes),
      O.push(L.numClipIntersection),
      O.push(L.depthPacking);
  }
  function M(O, L) {
    a.disableAll(),
      L.supportsVertexTextures && a.enable(0),
      L.instancing && a.enable(1),
      L.instancingColor && a.enable(2),
      L.instancingMorph && a.enable(3),
      L.matcap && a.enable(4),
      L.envMap && a.enable(5),
      L.normalMapObjectSpace && a.enable(6),
      L.normalMapTangentSpace && a.enable(7),
      L.clearcoat && a.enable(8),
      L.iridescence && a.enable(9),
      L.alphaTest && a.enable(10),
      L.vertexColors && a.enable(11),
      L.vertexAlphas && a.enable(12),
      L.vertexUv1s && a.enable(13),
      L.vertexUv2s && a.enable(14),
      L.vertexUv3s && a.enable(15),
      L.vertexTangents && a.enable(16),
      L.anisotropy && a.enable(17),
      L.alphaHash && a.enable(18),
      L.batching && a.enable(19),
      L.dispersion && a.enable(20),
      L.batchingColor && a.enable(21),
      O.push(a.mask),
      a.disableAll(),
      L.fog && a.enable(0),
      L.useFog && a.enable(1),
      L.flatShading && a.enable(2),
      L.logarithmicDepthBuffer && a.enable(3),
      L.skinning && a.enable(4),
      L.morphTargets && a.enable(5),
      L.morphNormals && a.enable(6),
      L.morphColors && a.enable(7),
      L.premultipliedAlpha && a.enable(8),
      L.shadowMapEnabled && a.enable(9),
      L.doubleSided && a.enable(10),
      L.flipSided && a.enable(11),
      L.useDepthPacking && a.enable(12),
      L.dithering && a.enable(13),
      L.transmission && a.enable(14),
      L.sheen && a.enable(15),
      L.opaque && a.enable(16),
      L.pointsUvs && a.enable(17),
      L.decodeVideoTexture && a.enable(18),
      L.alphaToCoverage && a.enable(19),
      O.push(a.mask);
  }
  function A(O) {
    const L = x[O.type];
    let H;
    if (L) {
      const W = ca[L];
      H = $m.clone(W.uniforms);
    } else H = O.uniforms;
    return H;
  }
  function R(O, L) {
    let H;
    for (let W = 0, $ = d.length; W < $; W++) {
      const K = d[W];
      if (K.cacheKey === L) {
        (H = K), ++H.usedTimes;
        break;
      }
    }
    return H === void 0 && ((H = new SV(n, L, O, o)), d.push(H)), H;
  }
  function D(O) {
    if (--O.usedTimes === 0) {
      const L = d.indexOf(O);
      (d[L] = d[d.length - 1]), d.pop(), O.destroy();
    }
  }
  function P(O) {
    u.remove(O);
  }
  function U() {
    u.dispose();
  }
  return {
    getParameters: _,
    getProgramCacheKey: w,
    getUniforms: A,
    acquireProgram: R,
    releaseProgram: D,
    releaseShaderCache: P,
    programs: d,
    dispose: U,
  };
}
function TV() {
  let n = new WeakMap();
  function e(o) {
    let s = n.get(o);
    return s === void 0 && ((s = {}), n.set(o, s)), s;
  }
  function t(o) {
    n.delete(o);
  }
  function r(o, s, a) {
    n.get(o)[s] = a;
  }
  function i() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: r, dispose: i };
}
function CV(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function fT(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function dT() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    i = [];
  function o() {
    (e = 0), (t.length = 0), (r.length = 0), (i.length = 0);
  }
  function s(m, g, y, x, S, _) {
    let w = n[e];
    return (
      w === void 0
        ? ((w = {
            id: m.id,
            object: m,
            geometry: g,
            material: y,
            groupOrder: x,
            renderOrder: m.renderOrder,
            z: S,
            group: _,
          }),
          (n[e] = w))
        : ((w.id = m.id),
          (w.object = m),
          (w.geometry = g),
          (w.material = y),
          (w.groupOrder = x),
          (w.renderOrder = m.renderOrder),
          (w.z = S),
          (w.group = _)),
      e++,
      w
    );
  }
  function a(m, g, y, x, S, _) {
    const w = s(m, g, y, x, S, _);
    y.transmission > 0
      ? r.push(w)
      : y.transparent === !0
      ? i.push(w)
      : t.push(w);
  }
  function u(m, g, y, x, S, _) {
    const w = s(m, g, y, x, S, _);
    y.transmission > 0
      ? r.unshift(w)
      : y.transparent === !0
      ? i.unshift(w)
      : t.unshift(w);
  }
  function c(m, g) {
    t.length > 1 && t.sort(m || CV),
      r.length > 1 && r.sort(g || fT),
      i.length > 1 && i.sort(g || fT);
  }
  function d() {
    for (let m = e, g = n.length; m < g; m++) {
      const y = n[m];
      if (y.id === null) break;
      (y.id = null),
        (y.object = null),
        (y.geometry = null),
        (y.material = null),
        (y.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: o,
    push: a,
    unshift: u,
    finish: d,
    sort: c,
  };
}
function AV() {
  let n = new WeakMap();
  function e(r, i) {
    const o = n.get(r);
    let s;
    return (
      o === void 0
        ? ((s = new dT()), n.set(r, [s]))
        : i >= o.length
        ? ((s = new dT()), o.push(s))
        : (s = o[i]),
      s
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function RV() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new oe(), color: new St() };
          break;
        case "SpotLight":
          t = {
            position: new oe(),
            direction: new oe(),
            color: new St(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new oe(), color: new St(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = {
            direction: new oe(),
            skyColor: new St(),
            groundColor: new St(),
          };
          break;
        case "RectAreaLight":
          t = {
            color: new St(),
            position: new oe(),
            halfWidth: new oe(),
            halfHeight: new oe(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function PV() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new tt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let IV = 0;
function LV(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function DV(n) {
  const e = new RV(),
    t = PV(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) r.probe.push(new oe());
  const i = new oe(),
    o = new Gt(),
    s = new Gt();
  function a(c) {
    let d = 0,
      m = 0,
      g = 0;
    for (let O = 0; O < 9; O++) r.probe[O].set(0, 0, 0);
    let y = 0,
      x = 0,
      S = 0,
      _ = 0,
      w = 0,
      T = 0,
      M = 0,
      A = 0,
      R = 0,
      D = 0,
      P = 0;
    c.sort(LV);
    for (let O = 0, L = c.length; O < L; O++) {
      const H = c[O],
        W = H.color,
        $ = H.intensity,
        K = H.distance,
        Z = H.shadow && H.shadow.map ? H.shadow.map.texture : null;
      if (H.isAmbientLight) (d += W.r * $), (m += W.g * $), (g += W.b * $);
      else if (H.isLightProbe) {
        for (let Y = 0; Y < 9; Y++)
          r.probe[Y].addScaledVector(H.sh.coefficients[Y], $);
        P++;
      } else if (H.isDirectionalLight) {
        const Y = e.get(H);
        if ((Y.color.copy(H.color).multiplyScalar(H.intensity), H.castShadow)) {
          const re = H.shadow,
            G = t.get(H);
          (G.shadowIntensity = re.intensity),
            (G.shadowBias = re.bias),
            (G.shadowNormalBias = re.normalBias),
            (G.shadowRadius = re.radius),
            (G.shadowMapSize = re.mapSize),
            (r.directionalShadow[y] = G),
            (r.directionalShadowMap[y] = Z),
            (r.directionalShadowMatrix[y] = H.shadow.matrix),
            T++;
        }
        (r.directional[y] = Y), y++;
      } else if (H.isSpotLight) {
        const Y = e.get(H);
        Y.position.setFromMatrixPosition(H.matrixWorld),
          Y.color.copy(W).multiplyScalar($),
          (Y.distance = K),
          (Y.coneCos = Math.cos(H.angle)),
          (Y.penumbraCos = Math.cos(H.angle * (1 - H.penumbra))),
          (Y.decay = H.decay),
          (r.spot[S] = Y);
        const re = H.shadow;
        if (
          (H.map &&
            ((r.spotLightMap[R] = H.map),
            R++,
            re.updateMatrices(H),
            H.castShadow && D++),
          (r.spotLightMatrix[S] = re.matrix),
          H.castShadow)
        ) {
          const G = t.get(H);
          (G.shadowIntensity = re.intensity),
            (G.shadowBias = re.bias),
            (G.shadowNormalBias = re.normalBias),
            (G.shadowRadius = re.radius),
            (G.shadowMapSize = re.mapSize),
            (r.spotShadow[S] = G),
            (r.spotShadowMap[S] = Z),
            A++;
        }
        S++;
      } else if (H.isRectAreaLight) {
        const Y = e.get(H);
        Y.color.copy(W).multiplyScalar($),
          Y.halfWidth.set(H.width * 0.5, 0, 0),
          Y.halfHeight.set(0, H.height * 0.5, 0),
          (r.rectArea[_] = Y),
          _++;
      } else if (H.isPointLight) {
        const Y = e.get(H);
        if (
          (Y.color.copy(H.color).multiplyScalar(H.intensity),
          (Y.distance = H.distance),
          (Y.decay = H.decay),
          H.castShadow)
        ) {
          const re = H.shadow,
            G = t.get(H);
          (G.shadowIntensity = re.intensity),
            (G.shadowBias = re.bias),
            (G.shadowNormalBias = re.normalBias),
            (G.shadowRadius = re.radius),
            (G.shadowMapSize = re.mapSize),
            (G.shadowCameraNear = re.camera.near),
            (G.shadowCameraFar = re.camera.far),
            (r.pointShadow[x] = G),
            (r.pointShadowMap[x] = Z),
            (r.pointShadowMatrix[x] = H.shadow.matrix),
            M++;
        }
        (r.point[x] = Y), x++;
      } else if (H.isHemisphereLight) {
        const Y = e.get(H);
        Y.skyColor.copy(H.color).multiplyScalar($),
          Y.groundColor.copy(H.groundColor).multiplyScalar($),
          (r.hemi[w] = Y),
          w++;
      }
    }
    _ > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = vt.LTC_FLOAT_1), (r.rectAreaLTC2 = vt.LTC_FLOAT_2))
        : ((r.rectAreaLTC1 = vt.LTC_HALF_1), (r.rectAreaLTC2 = vt.LTC_HALF_2))),
      (r.ambient[0] = d),
      (r.ambient[1] = m),
      (r.ambient[2] = g);
    const U = r.hash;
    (U.directionalLength !== y ||
      U.pointLength !== x ||
      U.spotLength !== S ||
      U.rectAreaLength !== _ ||
      U.hemiLength !== w ||
      U.numDirectionalShadows !== T ||
      U.numPointShadows !== M ||
      U.numSpotShadows !== A ||
      U.numSpotMaps !== R ||
      U.numLightProbes !== P) &&
      ((r.directional.length = y),
      (r.spot.length = S),
      (r.rectArea.length = _),
      (r.point.length = x),
      (r.hemi.length = w),
      (r.directionalShadow.length = T),
      (r.directionalShadowMap.length = T),
      (r.pointShadow.length = M),
      (r.pointShadowMap.length = M),
      (r.spotShadow.length = A),
      (r.spotShadowMap.length = A),
      (r.directionalShadowMatrix.length = T),
      (r.pointShadowMatrix.length = M),
      (r.spotLightMatrix.length = A + R - D),
      (r.spotLightMap.length = R),
      (r.numSpotLightShadowsWithMaps = D),
      (r.numLightProbes = P),
      (U.directionalLength = y),
      (U.pointLength = x),
      (U.spotLength = S),
      (U.rectAreaLength = _),
      (U.hemiLength = w),
      (U.numDirectionalShadows = T),
      (U.numPointShadows = M),
      (U.numSpotShadows = A),
      (U.numSpotMaps = R),
      (U.numLightProbes = P),
      (r.version = IV++));
  }
  function u(c, d) {
    let m = 0,
      g = 0,
      y = 0,
      x = 0,
      S = 0;
    const _ = d.matrixWorldInverse;
    for (let w = 0, T = c.length; w < T; w++) {
      const M = c[w];
      if (M.isDirectionalLight) {
        const A = r.directional[m];
        A.direction.setFromMatrixPosition(M.matrixWorld),
          i.setFromMatrixPosition(M.target.matrixWorld),
          A.direction.sub(i),
          A.direction.transformDirection(_),
          m++;
      } else if (M.isSpotLight) {
        const A = r.spot[y];
        A.position.setFromMatrixPosition(M.matrixWorld),
          A.position.applyMatrix4(_),
          A.direction.setFromMatrixPosition(M.matrixWorld),
          i.setFromMatrixPosition(M.target.matrixWorld),
          A.direction.sub(i),
          A.direction.transformDirection(_),
          y++;
      } else if (M.isRectAreaLight) {
        const A = r.rectArea[x];
        A.position.setFromMatrixPosition(M.matrixWorld),
          A.position.applyMatrix4(_),
          s.identity(),
          o.copy(M.matrixWorld),
          o.premultiply(_),
          s.extractRotation(o),
          A.halfWidth.set(M.width * 0.5, 0, 0),
          A.halfHeight.set(0, M.height * 0.5, 0),
          A.halfWidth.applyMatrix4(s),
          A.halfHeight.applyMatrix4(s),
          x++;
      } else if (M.isPointLight) {
        const A = r.point[g];
        A.position.setFromMatrixPosition(M.matrixWorld),
          A.position.applyMatrix4(_),
          g++;
      } else if (M.isHemisphereLight) {
        const A = r.hemi[S];
        A.direction.setFromMatrixPosition(M.matrixWorld),
          A.direction.transformDirection(_),
          S++;
      }
    }
  }
  return { setup: a, setupView: u, state: r };
}
function hT(n) {
  const e = new DV(n),
    t = [],
    r = [];
  function i(d) {
    (c.camera = d), (t.length = 0), (r.length = 0);
  }
  function o(d) {
    t.push(d);
  }
  function s(d) {
    r.push(d);
  }
  function a() {
    e.setup(t);
  }
  function u(d) {
    e.setupView(t, d);
  }
  const c = {
    lightsArray: t,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: c,
    setupLights: a,
    setupLightsView: u,
    pushLight: o,
    pushShadow: s,
  };
}
function kV(n) {
  let e = new WeakMap();
  function t(i, o = 0) {
    const s = e.get(i);
    let a;
    return (
      s === void 0
        ? ((a = new hT(n)), e.set(i, [a]))
        : o >= s.length
        ? ((a = new hT(n)), s.push(a))
        : (a = s[o]),
      a
    );
  }
  function r() {
    e = new WeakMap();
  }
  return { get: t, dispose: r };
}
class tx extends zi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = sR),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class nx extends zi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const OV = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  NV = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function UV(n, e, t) {
  let r = new fg();
  const i = new tt(),
    o = new tt(),
    s = new dn(),
    a = new tx({ depthPacking: Pw }),
    u = new nx(),
    c = {},
    d = t.maxTextureSize,
    m = { [el]: ro, [ro]: el, [Ps]: Ps },
    g = new Ds({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new tt() },
        radius: { value: 4 },
      },
      vertexShader: OV,
      fragmentShader: NV,
    }),
    y = g.clone();
  y.defines.HORIZONTAL_PASS = 1;
  const x = new sn();
  x.setAttribute(
    "position",
    new Gn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const S = new ur(x, g),
    _ = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Wy);
  let w = this.type;
  this.render = function (D, P, U) {
    if (
      _.enabled === !1 ||
      (_.autoUpdate === !1 && _.needsUpdate === !1) ||
      D.length === 0
    )
      return;
    const O = n.getRenderTarget(),
      L = n.getActiveCubeFace(),
      H = n.getActiveMipmapLevel(),
      W = n.state;
    W.setBlending(Fl),
      W.buffers.color.setClear(1, 1, 1, 1),
      W.buffers.depth.setTest(!0),
      W.setScissorTest(!1);
    const $ = w !== la && this.type === la,
      K = w === la && this.type !== la;
    for (let Z = 0, Y = D.length; Z < Y; Z++) {
      const re = D[Z],
        G = re.shadow;
      if (G === void 0) {
        console.warn("THREE.WebGLShadowMap:", re, "has no shadow.");
        continue;
      }
      if (G.autoUpdate === !1 && G.needsUpdate === !1) continue;
      i.copy(G.mapSize);
      const te = G.getFrameExtents();
      if (
        (i.multiply(te),
        o.copy(G.mapSize),
        (i.x > d || i.y > d) &&
          (i.x > d &&
            ((o.x = Math.floor(d / te.x)),
            (i.x = o.x * te.x),
            (G.mapSize.x = o.x)),
          i.y > d &&
            ((o.y = Math.floor(d / te.y)),
            (i.y = o.y * te.y),
            (G.mapSize.y = o.y))),
        G.map === null || $ === !0 || K === !0)
      ) {
        const V = this.type !== la ? { minFilter: wi, magFilter: wi } : {};
        G.map !== null && G.map.dispose(),
          (G.map = new ma(i.x, i.y, V)),
          (G.map.texture.name = re.name + ".shadowMap"),
          G.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(G.map), n.clear();
      const F = G.getViewportCount();
      for (let V = 0; V < F; V++) {
        const ne = G.getViewport(V);
        s.set(o.x * ne.x, o.y * ne.y, o.x * ne.z, o.y * ne.w),
          W.viewport(s),
          G.updateMatrices(re, V),
          (r = G.getFrustum()),
          A(P, U, G.camera, re, this.type);
      }
      G.isPointLightShadow !== !0 && this.type === la && T(G, U),
        (G.needsUpdate = !1);
    }
    (w = this.type), (_.needsUpdate = !1), n.setRenderTarget(O, L, H);
  };
  function T(D, P) {
    const U = e.update(S);
    g.defines.VSM_SAMPLES !== D.blurSamples &&
      ((g.defines.VSM_SAMPLES = D.blurSamples),
      (y.defines.VSM_SAMPLES = D.blurSamples),
      (g.needsUpdate = !0),
      (y.needsUpdate = !0)),
      D.mapPass === null && (D.mapPass = new ma(i.x, i.y)),
      (g.uniforms.shadow_pass.value = D.map.texture),
      (g.uniforms.resolution.value = D.mapSize),
      (g.uniforms.radius.value = D.radius),
      n.setRenderTarget(D.mapPass),
      n.clear(),
      n.renderBufferDirect(P, null, U, g, S, null),
      (y.uniforms.shadow_pass.value = D.mapPass.texture),
      (y.uniforms.resolution.value = D.mapSize),
      (y.uniforms.radius.value = D.radius),
      n.setRenderTarget(D.map),
      n.clear(),
      n.renderBufferDirect(P, null, U, y, S, null);
  }
  function M(D, P, U, O) {
    let L = null;
    const H =
      U.isPointLight === !0 ? D.customDistanceMaterial : D.customDepthMaterial;
    if (H !== void 0) L = H;
    else if (
      ((L = U.isPointLight === !0 ? u : a),
      (n.localClippingEnabled &&
        P.clipShadows === !0 &&
        Array.isArray(P.clippingPlanes) &&
        P.clippingPlanes.length !== 0) ||
        (P.displacementMap && P.displacementScale !== 0) ||
        (P.alphaMap && P.alphaTest > 0) ||
        (P.map && P.alphaTest > 0))
    ) {
      const W = L.uuid,
        $ = P.uuid;
      let K = c[W];
      K === void 0 && ((K = {}), (c[W] = K));
      let Z = K[$];
      Z === void 0 &&
        ((Z = L.clone()), (K[$] = Z), P.addEventListener("dispose", R)),
        (L = Z);
    }
    if (
      ((L.visible = P.visible),
      (L.wireframe = P.wireframe),
      O === la
        ? (L.side = P.shadowSide !== null ? P.shadowSide : P.side)
        : (L.side = P.shadowSide !== null ? P.shadowSide : m[P.side]),
      (L.alphaMap = P.alphaMap),
      (L.alphaTest = P.alphaTest),
      (L.map = P.map),
      (L.clipShadows = P.clipShadows),
      (L.clippingPlanes = P.clippingPlanes),
      (L.clipIntersection = P.clipIntersection),
      (L.displacementMap = P.displacementMap),
      (L.displacementScale = P.displacementScale),
      (L.displacementBias = P.displacementBias),
      (L.wireframeLinewidth = P.wireframeLinewidth),
      (L.linewidth = P.linewidth),
      U.isPointLight === !0 && L.isMeshDistanceMaterial === !0)
    ) {
      const W = n.properties.get(L);
      W.light = U;
    }
    return L;
  }
  function A(D, P, U, O, L) {
    if (D.visible === !1) return;
    if (
      D.layers.test(P.layers) &&
      (D.isMesh || D.isLine || D.isPoints) &&
      (D.castShadow || (D.receiveShadow && L === la)) &&
      (!D.frustumCulled || r.intersectsObject(D))
    ) {
      D.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, D.matrixWorld);
      const $ = e.update(D),
        K = D.material;
      if (Array.isArray(K)) {
        const Z = $.groups;
        for (let Y = 0, re = Z.length; Y < re; Y++) {
          const G = Z[Y],
            te = K[G.materialIndex];
          if (te && te.visible) {
            const F = M(D, te, O, L);
            D.onBeforeShadow(n, D, P, U, $, F, G),
              n.renderBufferDirect(U, null, $, F, D, G),
              D.onAfterShadow(n, D, P, U, $, F, G);
          }
        }
      } else if (K.visible) {
        const Z = M(D, K, O, L);
        D.onBeforeShadow(n, D, P, U, $, Z, null),
          n.renderBufferDirect(U, null, $, Z, D, null),
          D.onAfterShadow(n, D, P, U, $, Z, null);
      }
    }
    const W = D.children;
    for (let $ = 0, K = W.length; $ < K; $++) A(W[$], P, U, O, L);
  }
  function R(D) {
    D.target.removeEventListener("dispose", R);
    for (const U in c) {
      const O = c[U],
        L = D.target.uuid;
      L in O && (O[L].dispose(), delete O[L]);
    }
  }
}
function FV(n) {
  function e() {
    let me = !1;
    const Ve = new dn();
    let Re = null;
    const Ue = new dn(0, 0, 0, 0);
    return {
      setMask: function (it) {
        Re !== it && !me && (n.colorMask(it, it, it, it), (Re = it));
      },
      setLocked: function (it) {
        me = it;
      },
      setClear: function (it, mt, gt, Nt, Ut) {
        Ut === !0 && ((it *= Nt), (mt *= Nt), (gt *= Nt)),
          Ve.set(it, mt, gt, Nt),
          Ue.equals(Ve) === !1 && (n.clearColor(it, mt, gt, Nt), Ue.copy(Ve));
      },
      reset: function () {
        (me = !1), (Re = null), Ue.set(-1, 0, 0, 0);
      },
    };
  }
  function t() {
    let me = !1,
      Ve = null,
      Re = null,
      Ue = null;
    return {
      setTest: function (it) {
        it ? de(n.DEPTH_TEST) : le(n.DEPTH_TEST);
      },
      setMask: function (it) {
        Ve !== it && !me && (n.depthMask(it), (Ve = it));
      },
      setFunc: function (it) {
        if (Re !== it) {
          switch (it) {
            case HA:
              n.depthFunc(n.NEVER);
              break;
            case VA:
              n.depthFunc(n.ALWAYS);
              break;
            case WA:
              n.depthFunc(n.LESS);
              break;
            case Dm:
              n.depthFunc(n.LEQUAL);
              break;
            case GA:
              n.depthFunc(n.EQUAL);
              break;
            case jA:
              n.depthFunc(n.GEQUAL);
              break;
            case $A:
              n.depthFunc(n.GREATER);
              break;
            case XA:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Re = it;
        }
      },
      setLocked: function (it) {
        me = it;
      },
      setClear: function (it) {
        Ue !== it && (n.clearDepth(it), (Ue = it));
      },
      reset: function () {
        (me = !1), (Ve = null), (Re = null), (Ue = null);
      },
    };
  }
  function r() {
    let me = !1,
      Ve = null,
      Re = null,
      Ue = null,
      it = null,
      mt = null,
      gt = null,
      Nt = null,
      Ut = null;
    return {
      setTest: function (ht) {
        me || (ht ? de(n.STENCIL_TEST) : le(n.STENCIL_TEST));
      },
      setMask: function (ht) {
        Ve !== ht && !me && (n.stencilMask(ht), (Ve = ht));
      },
      setFunc: function (ht, $t, un) {
        (Re !== ht || Ue !== $t || it !== un) &&
          (n.stencilFunc(ht, $t, un), (Re = ht), (Ue = $t), (it = un));
      },
      setOp: function (ht, $t, un) {
        (mt !== ht || gt !== $t || Nt !== un) &&
          (n.stencilOp(ht, $t, un), (mt = ht), (gt = $t), (Nt = un));
      },
      setLocked: function (ht) {
        me = ht;
      },
      setClear: function (ht) {
        Ut !== ht && (n.clearStencil(ht), (Ut = ht));
      },
      reset: function () {
        (me = !1),
          (Ve = null),
          (Re = null),
          (Ue = null),
          (it = null),
          (mt = null),
          (gt = null),
          (Nt = null),
          (Ut = null);
      },
    };
  }
  const i = new e(),
    o = new t(),
    s = new r(),
    a = new WeakMap(),
    u = new WeakMap();
  let c = {},
    d = {},
    m = new WeakMap(),
    g = [],
    y = null,
    x = !1,
    S = null,
    _ = null,
    w = null,
    T = null,
    M = null,
    A = null,
    R = null,
    D = new St(0, 0, 0),
    P = 0,
    U = !1,
    O = null,
    L = null,
    H = null,
    W = null,
    $ = null;
  const K = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Z = !1,
    Y = 0;
  const re = n.getParameter(n.VERSION);
  re.indexOf("WebGL") !== -1
    ? ((Y = parseFloat(/^WebGL (\d)/.exec(re)[1])), (Z = Y >= 1))
    : re.indexOf("OpenGL ES") !== -1 &&
      ((Y = parseFloat(/^OpenGL ES (\d)/.exec(re)[1])), (Z = Y >= 2));
  let G = null,
    te = {};
  const F = n.getParameter(n.SCISSOR_BOX),
    V = n.getParameter(n.VIEWPORT),
    ne = new dn().fromArray(F),
    ae = new dn().fromArray(V);
  function J(me, Ve, Re, Ue) {
    const it = new Uint8Array(4),
      mt = n.createTexture();
    n.bindTexture(me, mt),
      n.texParameteri(me, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(me, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let gt = 0; gt < Re; gt++)
      me === n.TEXTURE_3D || me === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(Ve, 0, n.RGBA, 1, 1, Ue, 0, n.RGBA, n.UNSIGNED_BYTE, it)
        : n.texImage2D(
            Ve + gt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            it
          );
    return mt;
  }
  const se = {};
  (se[n.TEXTURE_2D] = J(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (se[n.TEXTURE_CUBE_MAP] = J(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (se[n.TEXTURE_2D_ARRAY] = J(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (se[n.TEXTURE_3D] = J(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    i.setClear(0, 0, 0, 1),
    o.setClear(1),
    s.setClear(0),
    de(n.DEPTH_TEST),
    o.setFunc(Dm),
    Oe(!1),
    Ie(cS),
    de(n.CULL_FACE),
    we(Fl);
  function de(me) {
    c[me] !== !0 && (n.enable(me), (c[me] = !0));
  }
  function le(me) {
    c[me] !== !1 && (n.disable(me), (c[me] = !1));
  }
  function fe(me, Ve) {
    return d[me] !== Ve
      ? (n.bindFramebuffer(me, Ve),
        (d[me] = Ve),
        me === n.DRAW_FRAMEBUFFER && (d[n.FRAMEBUFFER] = Ve),
        me === n.FRAMEBUFFER && (d[n.DRAW_FRAMEBUFFER] = Ve),
        !0)
      : !1;
  }
  function Me(me, Ve) {
    let Re = g,
      Ue = !1;
    if (me) {
      (Re = m.get(Ve)), Re === void 0 && ((Re = []), m.set(Ve, Re));
      const it = me.textures;
      if (Re.length !== it.length || Re[0] !== n.COLOR_ATTACHMENT0) {
        for (let mt = 0, gt = it.length; mt < gt; mt++)
          Re[mt] = n.COLOR_ATTACHMENT0 + mt;
        (Re.length = it.length), (Ue = !0);
      }
    } else Re[0] !== n.BACK && ((Re[0] = n.BACK), (Ue = !0));
    Ue && n.drawBuffers(Re);
  }
  function ge(me) {
    return y !== me ? (n.useProgram(me), (y = me), !0) : !1;
  }
  const xe = {
    [Wu]: n.FUNC_ADD,
    [MA]: n.FUNC_SUBTRACT,
    [EA]: n.FUNC_REVERSE_SUBTRACT,
  };
  (xe[TA] = n.MIN), (xe[CA] = n.MAX);
  const j = {
    [AA]: n.ZERO,
    [RA]: n.ONE,
    [PA]: n.SRC_COLOR,
    [H0]: n.SRC_ALPHA,
    [NA]: n.SRC_ALPHA_SATURATE,
    [kA]: n.DST_COLOR,
    [LA]: n.DST_ALPHA,
    [IA]: n.ONE_MINUS_SRC_COLOR,
    [V0]: n.ONE_MINUS_SRC_ALPHA,
    [OA]: n.ONE_MINUS_DST_COLOR,
    [DA]: n.ONE_MINUS_DST_ALPHA,
    [UA]: n.CONSTANT_COLOR,
    [FA]: n.ONE_MINUS_CONSTANT_COLOR,
    [BA]: n.CONSTANT_ALPHA,
    [zA]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function we(me, Ve, Re, Ue, it, mt, gt, Nt, Ut, ht) {
    if (me === Fl) {
      x === !0 && (le(n.BLEND), (x = !1));
      return;
    }
    if ((x === !1 && (de(n.BLEND), (x = !0)), me !== bA)) {
      if (me !== S || ht !== U) {
        if (
          ((_ !== Wu || M !== Wu) &&
            (n.blendEquation(n.FUNC_ADD), (_ = Wu), (M = Wu)),
          ht)
        )
          switch (me) {
            case yf:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case fS:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case dS:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case hS:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", me);
              break;
          }
        else
          switch (me) {
            case yf:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case fS:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case dS:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case hS:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", me);
              break;
          }
        (w = null),
          (T = null),
          (A = null),
          (R = null),
          D.set(0, 0, 0),
          (P = 0),
          (S = me),
          (U = ht);
      }
      return;
    }
    (it = it || Ve),
      (mt = mt || Re),
      (gt = gt || Ue),
      (Ve !== _ || it !== M) &&
        (n.blendEquationSeparate(xe[Ve], xe[it]), (_ = Ve), (M = it)),
      (Re !== w || Ue !== T || mt !== A || gt !== R) &&
        (n.blendFuncSeparate(j[Re], j[Ue], j[mt], j[gt]),
        (w = Re),
        (T = Ue),
        (A = mt),
        (R = gt)),
      (Nt.equals(D) === !1 || Ut !== P) &&
        (n.blendColor(Nt.r, Nt.g, Nt.b, Ut), D.copy(Nt), (P = Ut)),
      (S = me),
      (U = !1);
  }
  function Ae(me, Ve) {
    me.side === Ps ? le(n.CULL_FACE) : de(n.CULL_FACE);
    let Re = me.side === ro;
    Ve && (Re = !Re),
      Oe(Re),
      me.blending === yf && me.transparent === !1
        ? we(Fl)
        : we(
            me.blending,
            me.blendEquation,
            me.blendSrc,
            me.blendDst,
            me.blendEquationAlpha,
            me.blendSrcAlpha,
            me.blendDstAlpha,
            me.blendColor,
            me.blendAlpha,
            me.premultipliedAlpha
          ),
      o.setFunc(me.depthFunc),
      o.setTest(me.depthTest),
      o.setMask(me.depthWrite),
      i.setMask(me.colorWrite);
    const Ue = me.stencilWrite;
    s.setTest(Ue),
      Ue &&
        (s.setMask(me.stencilWriteMask),
        s.setFunc(me.stencilFunc, me.stencilRef, me.stencilFuncMask),
        s.setOp(me.stencilFail, me.stencilZFail, me.stencilZPass)),
      De(me.polygonOffset, me.polygonOffsetFactor, me.polygonOffsetUnits),
      me.alphaToCoverage === !0
        ? de(n.SAMPLE_ALPHA_TO_COVERAGE)
        : le(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Oe(me) {
    O !== me && (me ? n.frontFace(n.CW) : n.frontFace(n.CCW), (O = me));
  }
  function Ie(me) {
    me !== _A
      ? (de(n.CULL_FACE),
        me !== L &&
          (me === cS
            ? n.cullFace(n.BACK)
            : me === SA
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : le(n.CULL_FACE),
      (L = me);
  }
  function rt(me) {
    me !== H && (Z && n.lineWidth(me), (H = me));
  }
  function De(me, Ve, Re) {
    me
      ? (de(n.POLYGON_OFFSET_FILL),
        (W !== Ve || $ !== Re) && (n.polygonOffset(Ve, Re), (W = Ve), ($ = Re)))
      : le(n.POLYGON_OFFSET_FILL);
  }
  function Xe(me) {
    me ? de(n.SCISSOR_TEST) : le(n.SCISSOR_TEST);
  }
  function ee(me) {
    me === void 0 && (me = n.TEXTURE0 + K - 1),
      G !== me && (n.activeTexture(me), (G = me));
  }
  function B(me, Ve, Re) {
    Re === void 0 && (G === null ? (Re = n.TEXTURE0 + K - 1) : (Re = G));
    let Ue = te[Re];
    Ue === void 0 && ((Ue = { type: void 0, texture: void 0 }), (te[Re] = Ue)),
      (Ue.type !== me || Ue.texture !== Ve) &&
        (G !== Re && (n.activeTexture(Re), (G = Re)),
        n.bindTexture(me, Ve || se[me]),
        (Ue.type = me),
        (Ue.texture = Ve));
  }
  function ve() {
    const me = te[G];
    me !== void 0 &&
      me.type !== void 0 &&
      (n.bindTexture(me.type, null), (me.type = void 0), (me.texture = void 0));
  }
  function Se() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function _e() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Te() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function at() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Fe() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Be() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Ge() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function Ye() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function nt() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function xt() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (me) {
      console.error("THREE.WebGLState:", me);
    }
  }
  function $e(me) {
    ne.equals(me) === !1 && (n.scissor(me.x, me.y, me.z, me.w), ne.copy(me));
  }
  function qe(me) {
    ae.equals(me) === !1 && (n.viewport(me.x, me.y, me.z, me.w), ae.copy(me));
  }
  function et(me, Ve) {
    let Re = u.get(Ve);
    Re === void 0 && ((Re = new WeakMap()), u.set(Ve, Re));
    let Ue = Re.get(me);
    Ue === void 0 &&
      ((Ue = n.getUniformBlockIndex(Ve, me.name)), Re.set(me, Ue));
  }
  function he(me, Ve) {
    const Ue = u.get(Ve).get(me);
    a.get(Ve) !== Ue &&
      (n.uniformBlockBinding(Ve, Ue, me.__bindingPointIndex), a.set(Ve, Ue));
  }
  function Je() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (c = {}),
      (G = null),
      (te = {}),
      (d = {}),
      (m = new WeakMap()),
      (g = []),
      (y = null),
      (x = !1),
      (S = null),
      (_ = null),
      (w = null),
      (T = null),
      (M = null),
      (A = null),
      (R = null),
      (D = new St(0, 0, 0)),
      (P = 0),
      (U = !1),
      (O = null),
      (L = null),
      (H = null),
      (W = null),
      ($ = null),
      ne.set(0, 0, n.canvas.width, n.canvas.height),
      ae.set(0, 0, n.canvas.width, n.canvas.height),
      i.reset(),
      o.reset(),
      s.reset();
  }
  return {
    buffers: { color: i, depth: o, stencil: s },
    enable: de,
    disable: le,
    bindFramebuffer: fe,
    drawBuffers: Me,
    useProgram: ge,
    setBlending: we,
    setMaterial: Ae,
    setFlipSided: Oe,
    setCullFace: Ie,
    setLineWidth: rt,
    setPolygonOffset: De,
    setScissorTest: Xe,
    activeTexture: ee,
    bindTexture: B,
    unbindTexture: ve,
    compressedTexImage2D: Se,
    compressedTexImage3D: _e,
    texImage2D: nt,
    texImage3D: xt,
    updateUBOMapping: et,
    uniformBlockBinding: he,
    texStorage2D: Ge,
    texStorage3D: Ye,
    texSubImage2D: Te,
    texSubImage3D: at,
    compressedTexSubImage2D: Fe,
    compressedTexSubImage3D: Be,
    scissor: $e,
    viewport: qe,
    reset: Je,
  };
}
function BV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  );
}
function zV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  );
}
function HV(n) {
  return (
    (n.repeat.x = 1), (n.repeat.y = 1), (n.offset.x = 0), (n.offset.y = 0), n
  );
}
function xS(n, e, t, r) {
  const i = VV(r);
  switch (t) {
    case bw:
      return n * e;
    case Ew:
      return n * e;
    case Tw:
      return n * e * 2;
    case Yy:
      return ((n * e) / i.components) * i.byteLength;
    case ag:
      return ((n * e) / i.components) * i.byteLength;
    case Cw:
      return ((n * e * 2) / i.components) * i.byteLength;
    case qy:
      return ((n * e * 2) / i.components) * i.byteLength;
    case Mw:
      return ((n * e * 3) / i.components) * i.byteLength;
    case no:
      return ((n * e * 4) / i.components) * i.byteLength;
    case Ky:
      return ((n * e * 4) / i.components) * i.byteLength;
    case mm:
    case gm:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case vm:
    case ym:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case G0:
    case $0:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case W0:
    case j0:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case X0:
    case Y0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case q0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case K0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Z0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case J0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Q0:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case ey:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case ty:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case ny:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case ry:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case iy:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case oy:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case sy:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case ay:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case ly:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case uy:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case xm:
    case cy:
    case fy:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case Aw:
    case dy:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case hy:
    case py:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function VV(n) {
  switch (n) {
    case pa:
    case _w:
      return { byteLength: 1, components: 1 };
    case Ih:
    case Sw:
    case Wh:
      return { byteLength: 2, components: 1 };
    case $y:
    case Xy:
      return { byteLength: 2, components: 4 };
    case Vl:
    case jy:
    case Bo:
      return { byteLength: 4, components: 1 };
    case ww:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
const WV = { contain: BV, cover: zV, fill: HV, getByteLength: xS };
function GV(n, e, t, r, i, o, s) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    u =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new tt(),
    d = new WeakMap();
  let m;
  const g = new WeakMap();
  let y = !1;
  try {
    y =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(ee, B) {
    return y ? new OffscreenCanvas(ee, B) : jm("canvas");
  }
  function S(ee, B, ve) {
    let Se = 1;
    const _e = Xe(ee);
    if (
      ((_e.width > ve || _e.height > ve) &&
        (Se = ve / Math.max(_e.width, _e.height)),
      Se < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && ee instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && ee instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && ee instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && ee instanceof VideoFrame)
      ) {
        const Te = Math.floor(Se * _e.width),
          at = Math.floor(Se * _e.height);
        m === void 0 && (m = x(Te, at));
        const Fe = B ? x(Te, at) : m;
        return (
          (Fe.width = Te),
          (Fe.height = at),
          Fe.getContext("2d").drawImage(ee, 0, 0, Te, at),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              _e.width +
              "x" +
              _e.height +
              ") to (" +
              Te +
              "x" +
              at +
              ")."
          ),
          Fe
        );
      } else
        return (
          "data" in ee &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                _e.width +
                "x" +
                _e.height +
                ")."
            ),
          ee
        );
    return ee;
  }
  function _(ee) {
    return ee.generateMipmaps && ee.minFilter !== wi && ee.minFilter !== Cr;
  }
  function w(ee) {
    n.generateMipmap(ee);
  }
  function T(ee, B, ve, Se, _e = !1) {
    if (ee !== null) {
      if (n[ee] !== void 0) return n[ee];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          ee +
          "'"
      );
    }
    let Te = B;
    if (
      (B === n.RED &&
        (ve === n.FLOAT && (Te = n.R32F),
        ve === n.HALF_FLOAT && (Te = n.R16F),
        ve === n.UNSIGNED_BYTE && (Te = n.R8)),
      B === n.RED_INTEGER &&
        (ve === n.UNSIGNED_BYTE && (Te = n.R8UI),
        ve === n.UNSIGNED_SHORT && (Te = n.R16UI),
        ve === n.UNSIGNED_INT && (Te = n.R32UI),
        ve === n.BYTE && (Te = n.R8I),
        ve === n.SHORT && (Te = n.R16I),
        ve === n.INT && (Te = n.R32I)),
      B === n.RG &&
        (ve === n.FLOAT && (Te = n.RG32F),
        ve === n.HALF_FLOAT && (Te = n.RG16F),
        ve === n.UNSIGNED_BYTE && (Te = n.RG8)),
      B === n.RG_INTEGER &&
        (ve === n.UNSIGNED_BYTE && (Te = n.RG8UI),
        ve === n.UNSIGNED_SHORT && (Te = n.RG16UI),
        ve === n.UNSIGNED_INT && (Te = n.RG32UI),
        ve === n.BYTE && (Te = n.RG8I),
        ve === n.SHORT && (Te = n.RG16I),
        ve === n.INT && (Te = n.RG32I)),
      B === n.RGB && ve === n.UNSIGNED_INT_5_9_9_9_REV && (Te = n.RGB9_E5),
      B === n.RGBA)
    ) {
      const at = _e ? zm : Sn.getTransfer(Se);
      ve === n.FLOAT && (Te = n.RGBA32F),
        ve === n.HALF_FLOAT && (Te = n.RGBA16F),
        ve === n.UNSIGNED_BYTE && (Te = at === Jn ? n.SRGB8_ALPHA8 : n.RGBA8),
        ve === n.UNSIGNED_SHORT_4_4_4_4 && (Te = n.RGBA4),
        ve === n.UNSIGNED_SHORT_5_5_5_1 && (Te = n.RGB5_A1);
    }
    return (
      (Te === n.R16F ||
        Te === n.R32F ||
        Te === n.RG16F ||
        Te === n.RG32F ||
        Te === n.RGBA16F ||
        Te === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Te
    );
  }
  function M(ee, B) {
    let ve;
    return (
      ee
        ? B === null || B === Vl || B === Cf
          ? (ve = n.DEPTH24_STENCIL8)
          : B === Bo
          ? (ve = n.DEPTH32F_STENCIL8)
          : B === Ih &&
            ((ve = n.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : B === null || B === Vl || B === Cf
        ? (ve = n.DEPTH_COMPONENT24)
        : B === Bo
        ? (ve = n.DEPTH_COMPONENT32F)
        : B === Ih && (ve = n.DEPTH_COMPONENT16),
      ve
    );
  }
  function A(ee, B) {
    return _(ee) === !0 ||
      (ee.isFramebufferTexture && ee.minFilter !== wi && ee.minFilter !== Cr)
      ? Math.log2(Math.max(B.width, B.height)) + 1
      : ee.mipmaps !== void 0 && ee.mipmaps.length > 0
      ? ee.mipmaps.length
      : ee.isCompressedTexture && Array.isArray(ee.image)
      ? B.mipmaps.length
      : 1;
  }
  function R(ee) {
    const B = ee.target;
    B.removeEventListener("dispose", R), P(B), B.isVideoTexture && d.delete(B);
  }
  function D(ee) {
    const B = ee.target;
    B.removeEventListener("dispose", D), O(B);
  }
  function P(ee) {
    const B = r.get(ee);
    if (B.__webglInit === void 0) return;
    const ve = ee.source,
      Se = g.get(ve);
    if (Se) {
      const _e = Se[B.__cacheKey];
      _e.usedTimes--,
        _e.usedTimes === 0 && U(ee),
        Object.keys(Se).length === 0 && g.delete(ve);
    }
    r.remove(ee);
  }
  function U(ee) {
    const B = r.get(ee);
    n.deleteTexture(B.__webglTexture);
    const ve = ee.source,
      Se = g.get(ve);
    delete Se[B.__cacheKey], s.memory.textures--;
  }
  function O(ee) {
    const B = r.get(ee);
    if (
      (ee.depthTexture && ee.depthTexture.dispose(), ee.isWebGLCubeRenderTarget)
    )
      for (let Se = 0; Se < 6; Se++) {
        if (Array.isArray(B.__webglFramebuffer[Se]))
          for (let _e = 0; _e < B.__webglFramebuffer[Se].length; _e++)
            n.deleteFramebuffer(B.__webglFramebuffer[Se][_e]);
        else n.deleteFramebuffer(B.__webglFramebuffer[Se]);
        B.__webglDepthbuffer && n.deleteRenderbuffer(B.__webglDepthbuffer[Se]);
      }
    else {
      if (Array.isArray(B.__webglFramebuffer))
        for (let Se = 0; Se < B.__webglFramebuffer.length; Se++)
          n.deleteFramebuffer(B.__webglFramebuffer[Se]);
      else n.deleteFramebuffer(B.__webglFramebuffer);
      if (
        (B.__webglDepthbuffer && n.deleteRenderbuffer(B.__webglDepthbuffer),
        B.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(B.__webglMultisampledFramebuffer),
        B.__webglColorRenderbuffer)
      )
        for (let Se = 0; Se < B.__webglColorRenderbuffer.length; Se++)
          B.__webglColorRenderbuffer[Se] &&
            n.deleteRenderbuffer(B.__webglColorRenderbuffer[Se]);
      B.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(B.__webglDepthRenderbuffer);
    }
    const ve = ee.textures;
    for (let Se = 0, _e = ve.length; Se < _e; Se++) {
      const Te = r.get(ve[Se]);
      Te.__webglTexture &&
        (n.deleteTexture(Te.__webglTexture), s.memory.textures--),
        r.remove(ve[Se]);
    }
    r.remove(ee);
  }
  let L = 0;
  function H() {
    L = 0;
  }
  function W() {
    const ee = L;
    return (
      ee >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            ee +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (L += 1),
      ee
    );
  }
  function $(ee) {
    const B = [];
    return (
      B.push(ee.wrapS),
      B.push(ee.wrapT),
      B.push(ee.wrapR || 0),
      B.push(ee.magFilter),
      B.push(ee.minFilter),
      B.push(ee.anisotropy),
      B.push(ee.internalFormat),
      B.push(ee.format),
      B.push(ee.type),
      B.push(ee.generateMipmaps),
      B.push(ee.premultiplyAlpha),
      B.push(ee.flipY),
      B.push(ee.unpackAlignment),
      B.push(ee.colorSpace),
      B.join()
    );
  }
  function K(ee, B) {
    const ve = r.get(ee);
    if (
      (ee.isVideoTexture && rt(ee),
      ee.isRenderTargetTexture === !1 &&
        ee.version > 0 &&
        ve.__version !== ee.version)
    ) {
      const Se = ee.image;
      if (Se === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Se.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        ae(ve, ee, B);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, ve.__webglTexture, n.TEXTURE0 + B);
  }
  function Z(ee, B) {
    const ve = r.get(ee);
    if (ee.version > 0 && ve.__version !== ee.version) {
      ae(ve, ee, B);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, ve.__webglTexture, n.TEXTURE0 + B);
  }
  function Y(ee, B) {
    const ve = r.get(ee);
    if (ee.version > 0 && ve.__version !== ee.version) {
      ae(ve, ee, B);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, ve.__webglTexture, n.TEXTURE0 + B);
  }
  function re(ee, B) {
    const ve = r.get(ee);
    if (ee.version > 0 && ve.__version !== ee.version) {
      J(ve, ee, B);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, ve.__webglTexture, n.TEXTURE0 + B);
  }
  const G = { [Nm]: n.REPEAT, [Ls]: n.CLAMP_TO_EDGE, [Um]: n.MIRRORED_REPEAT },
    te = {
      [wi]: n.NEAREST,
      [xw]: n.NEAREST_MIPMAP_NEAREST,
      [ph]: n.NEAREST_MIPMAP_LINEAR,
      [Cr]: n.LINEAR,
      [pm]: n.LINEAR_MIPMAP_NEAREST,
      [Xa]: n.LINEAR_MIPMAP_LINEAR,
    },
    F = {
      [lR]: n.NEVER,
      [pR]: n.ALWAYS,
      [uR]: n.LESS,
      [Iw]: n.LEQUAL,
      [cR]: n.EQUAL,
      [hR]: n.GEQUAL,
      [fR]: n.GREATER,
      [dR]: n.NOTEQUAL,
    };
  function V(ee, B) {
    if (
      (B.type === Bo &&
        e.has("OES_texture_float_linear") === !1 &&
        (B.magFilter === Cr ||
          B.magFilter === pm ||
          B.magFilter === ph ||
          B.magFilter === Xa ||
          B.minFilter === Cr ||
          B.minFilter === pm ||
          B.minFilter === ph ||
          B.minFilter === Xa) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      n.texParameteri(ee, n.TEXTURE_WRAP_S, G[B.wrapS]),
      n.texParameteri(ee, n.TEXTURE_WRAP_T, G[B.wrapT]),
      (ee === n.TEXTURE_3D || ee === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(ee, n.TEXTURE_WRAP_R, G[B.wrapR]),
      n.texParameteri(ee, n.TEXTURE_MAG_FILTER, te[B.magFilter]),
      n.texParameteri(ee, n.TEXTURE_MIN_FILTER, te[B.minFilter]),
      B.compareFunction &&
        (n.texParameteri(ee, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(ee, n.TEXTURE_COMPARE_FUNC, F[B.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        B.magFilter === wi ||
        (B.minFilter !== ph && B.minFilter !== Xa) ||
        (B.type === Bo && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (B.anisotropy > 1 || r.get(B).__currentAnisotropy) {
        const ve = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(
          ee,
          ve.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(B.anisotropy, i.getMaxAnisotropy())
        ),
          (r.get(B).__currentAnisotropy = B.anisotropy);
      }
    }
  }
  function ne(ee, B) {
    let ve = !1;
    ee.__webglInit === void 0 &&
      ((ee.__webglInit = !0), B.addEventListener("dispose", R));
    const Se = B.source;
    let _e = g.get(Se);
    _e === void 0 && ((_e = {}), g.set(Se, _e));
    const Te = $(B);
    if (Te !== ee.__cacheKey) {
      _e[Te] === void 0 &&
        ((_e[Te] = { texture: n.createTexture(), usedTimes: 0 }),
        s.memory.textures++,
        (ve = !0)),
        _e[Te].usedTimes++;
      const at = _e[ee.__cacheKey];
      at !== void 0 &&
        (_e[ee.__cacheKey].usedTimes--, at.usedTimes === 0 && U(B)),
        (ee.__cacheKey = Te),
        (ee.__webglTexture = _e[Te].texture);
    }
    return ve;
  }
  function ae(ee, B, ve) {
    let Se = n.TEXTURE_2D;
    (B.isDataArrayTexture || B.isCompressedArrayTexture) &&
      (Se = n.TEXTURE_2D_ARRAY),
      B.isData3DTexture && (Se = n.TEXTURE_3D);
    const _e = ne(ee, B),
      Te = B.source;
    t.bindTexture(Se, ee.__webglTexture, n.TEXTURE0 + ve);
    const at = r.get(Te);
    if (Te.version !== at.__version || _e === !0) {
      t.activeTexture(n.TEXTURE0 + ve);
      const Fe = Sn.getPrimaries(Sn.workingColorSpace),
        Be = B.colorSpace === kl ? null : Sn.getPrimaries(B.colorSpace),
        Ge =
          B.colorSpace === kl || Fe === Be ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, B.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, B.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ge);
      let Ye = S(B.image, !1, i.maxTextureSize);
      Ye = De(B, Ye);
      const nt = o.convert(B.format, B.colorSpace),
        xt = o.convert(B.type);
      let $e = T(B.internalFormat, nt, xt, B.colorSpace, B.isVideoTexture);
      V(Se, B);
      let qe;
      const et = B.mipmaps,
        he = B.isVideoTexture !== !0,
        Je = at.__version === void 0 || _e === !0,
        me = Te.dataReady,
        Ve = A(B, Ye);
      if (B.isDepthTexture)
        ($e = M(B.format === Af, B.type)),
          Je &&
            (he
              ? t.texStorage2D(n.TEXTURE_2D, 1, $e, Ye.width, Ye.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  $e,
                  Ye.width,
                  Ye.height,
                  0,
                  nt,
                  xt,
                  null
                ));
      else if (B.isDataTexture)
        if (et.length > 0) {
          he &&
            Je &&
            t.texStorage2D(n.TEXTURE_2D, Ve, $e, et[0].width, et[0].height);
          for (let Re = 0, Ue = et.length; Re < Ue; Re++)
            (qe = et[Re]),
              he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    nt,
                    xt,
                    qe.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    0,
                    nt,
                    xt,
                    qe.data
                  );
          B.generateMipmaps = !1;
        } else
          he
            ? (Je && t.texStorage2D(n.TEXTURE_2D, Ve, $e, Ye.width, Ye.height),
              me &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Ye.width,
                  Ye.height,
                  nt,
                  xt,
                  Ye.data
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                $e,
                Ye.width,
                Ye.height,
                0,
                nt,
                xt,
                Ye.data
              );
      else if (B.isCompressedTexture)
        if (B.isCompressedArrayTexture) {
          he &&
            Je &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Ve,
              $e,
              et[0].width,
              et[0].height,
              Ye.depth
            );
          for (let Re = 0, Ue = et.length; Re < Ue; Re++)
            if (((qe = et[Re]), B.format !== no))
              if (nt !== null)
                if (he) {
                  if (me)
                    if (B.layerUpdates.size > 0) {
                      const it = xS(qe.width, qe.height, B.format, B.type);
                      for (const mt of B.layerUpdates) {
                        const gt = qe.data.subarray(
                          (mt * it) / qe.data.BYTES_PER_ELEMENT,
                          ((mt + 1) * it) / qe.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Re,
                          0,
                          0,
                          mt,
                          qe.width,
                          qe.height,
                          1,
                          nt,
                          gt,
                          0,
                          0
                        );
                      }
                      B.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Re,
                        0,
                        0,
                        0,
                        qe.width,
                        qe.height,
                        Ye.depth,
                        nt,
                        qe.data,
                        0,
                        0
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    0,
                    qe.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              he
                ? me &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    0,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    nt,
                    xt,
                    qe.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    Ye.depth,
                    0,
                    nt,
                    xt,
                    qe.data
                  );
        } else {
          he &&
            Je &&
            t.texStorage2D(n.TEXTURE_2D, Ve, $e, et[0].width, et[0].height);
          for (let Re = 0, Ue = et.length; Re < Ue; Re++)
            (qe = et[Re]),
              B.format !== no
                ? nt !== null
                  ? he
                    ? me &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Re,
                        0,
                        0,
                        qe.width,
                        qe.height,
                        nt,
                        qe.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Re,
                        $e,
                        qe.width,
                        qe.height,
                        0,
                        qe.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    nt,
                    xt,
                    qe.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Re,
                    $e,
                    qe.width,
                    qe.height,
                    0,
                    nt,
                    xt,
                    qe.data
                  );
        }
      else if (B.isDataArrayTexture)
        if (he) {
          if (
            (Je &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Ve,
                $e,
                Ye.width,
                Ye.height,
                Ye.depth
              ),
            me)
          )
            if (B.layerUpdates.size > 0) {
              const Re = xS(Ye.width, Ye.height, B.format, B.type);
              for (const Ue of B.layerUpdates) {
                const it = Ye.data.subarray(
                  (Ue * Re) / Ye.data.BYTES_PER_ELEMENT,
                  ((Ue + 1) * Re) / Ye.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Ue,
                  Ye.width,
                  Ye.height,
                  1,
                  nt,
                  xt,
                  it
                );
              }
              B.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ye.width,
                Ye.height,
                Ye.depth,
                nt,
                xt,
                Ye.data
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            $e,
            Ye.width,
            Ye.height,
            Ye.depth,
            0,
            nt,
            xt,
            Ye.data
          );
      else if (B.isData3DTexture)
        he
          ? (Je &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Ve,
                $e,
                Ye.width,
                Ye.height,
                Ye.depth
              ),
            me &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ye.width,
                Ye.height,
                Ye.depth,
                nt,
                xt,
                Ye.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              $e,
              Ye.width,
              Ye.height,
              Ye.depth,
              0,
              nt,
              xt,
              Ye.data
            );
      else if (B.isFramebufferTexture) {
        if (Je)
          if (he) t.texStorage2D(n.TEXTURE_2D, Ve, $e, Ye.width, Ye.height);
          else {
            let Re = Ye.width,
              Ue = Ye.height;
            for (let it = 0; it < Ve; it++)
              t.texImage2D(n.TEXTURE_2D, it, $e, Re, Ue, 0, nt, xt, null),
                (Re >>= 1),
                (Ue >>= 1);
          }
      } else if (et.length > 0) {
        if (he && Je) {
          const Re = Xe(et[0]);
          t.texStorage2D(n.TEXTURE_2D, Ve, $e, Re.width, Re.height);
        }
        for (let Re = 0, Ue = et.length; Re < Ue; Re++)
          (qe = et[Re]),
            he
              ? me && t.texSubImage2D(n.TEXTURE_2D, Re, 0, 0, nt, xt, qe)
              : t.texImage2D(n.TEXTURE_2D, Re, $e, nt, xt, qe);
        B.generateMipmaps = !1;
      } else if (he) {
        if (Je) {
          const Re = Xe(Ye);
          t.texStorage2D(n.TEXTURE_2D, Ve, $e, Re.width, Re.height);
        }
        me && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, nt, xt, Ye);
      } else t.texImage2D(n.TEXTURE_2D, 0, $e, nt, xt, Ye);
      _(B) && w(Se), (at.__version = Te.version), B.onUpdate && B.onUpdate(B);
    }
    ee.__version = B.version;
  }
  function J(ee, B, ve) {
    if (B.image.length !== 6) return;
    const Se = ne(ee, B),
      _e = B.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, ee.__webglTexture, n.TEXTURE0 + ve);
    const Te = r.get(_e);
    if (_e.version !== Te.__version || Se === !0) {
      t.activeTexture(n.TEXTURE0 + ve);
      const at = Sn.getPrimaries(Sn.workingColorSpace),
        Fe = B.colorSpace === kl ? null : Sn.getPrimaries(B.colorSpace),
        Be =
          B.colorSpace === kl || at === Fe ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, B.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, B.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Be);
      const Ge = B.isCompressedTexture || B.image[0].isCompressedTexture,
        Ye = B.image[0] && B.image[0].isDataTexture,
        nt = [];
      for (let Ue = 0; Ue < 6; Ue++)
        !Ge && !Ye
          ? (nt[Ue] = S(B.image[Ue], !0, i.maxCubemapSize))
          : (nt[Ue] = Ye ? B.image[Ue].image : B.image[Ue]),
          (nt[Ue] = De(B, nt[Ue]));
      const xt = nt[0],
        $e = o.convert(B.format, B.colorSpace),
        qe = o.convert(B.type),
        et = T(B.internalFormat, $e, qe, B.colorSpace),
        he = B.isVideoTexture !== !0,
        Je = Te.__version === void 0 || Se === !0,
        me = _e.dataReady;
      let Ve = A(B, xt);
      V(n.TEXTURE_CUBE_MAP, B);
      let Re;
      if (Ge) {
        he &&
          Je &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ve, et, xt.width, xt.height);
        for (let Ue = 0; Ue < 6; Ue++) {
          Re = nt[Ue].mipmaps;
          for (let it = 0; it < Re.length; it++) {
            const mt = Re[it];
            B.format !== no
              ? $e !== null
                ? he
                  ? me &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                      it,
                      0,
                      0,
                      mt.width,
                      mt.height,
                      $e,
                      mt.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                      it,
                      et,
                      mt.width,
                      mt.height,
                      0,
                      mt.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : he
              ? me &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  it,
                  0,
                  0,
                  mt.width,
                  mt.height,
                  $e,
                  qe,
                  mt.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  it,
                  et,
                  mt.width,
                  mt.height,
                  0,
                  $e,
                  qe,
                  mt.data
                );
          }
        }
      } else {
        if (((Re = B.mipmaps), he && Je)) {
          Re.length > 0 && Ve++;
          const Ue = Xe(nt[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ve, et, Ue.width, Ue.height);
        }
        for (let Ue = 0; Ue < 6; Ue++)
          if (Ye) {
            he
              ? me &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  0,
                  0,
                  nt[Ue].width,
                  nt[Ue].height,
                  $e,
                  qe,
                  nt[Ue].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  et,
                  nt[Ue].width,
                  nt[Ue].height,
                  0,
                  $e,
                  qe,
                  nt[Ue].data
                );
            for (let it = 0; it < Re.length; it++) {
              const gt = Re[it].image[Ue].image;
              he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    0,
                    0,
                    gt.width,
                    gt.height,
                    $e,
                    qe,
                    gt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    et,
                    gt.width,
                    gt.height,
                    0,
                    $e,
                    qe,
                    gt.data
                  );
            }
          } else {
            he
              ? me &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  0,
                  0,
                  $e,
                  qe,
                  nt[Ue]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                  0,
                  et,
                  $e,
                  qe,
                  nt[Ue]
                );
            for (let it = 0; it < Re.length; it++) {
              const mt = Re[it];
              he
                ? me &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    0,
                    0,
                    $e,
                    qe,
                    mt.image[Ue]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
                    it + 1,
                    et,
                    $e,
                    qe,
                    mt.image[Ue]
                  );
            }
          }
      }
      _(B) && w(n.TEXTURE_CUBE_MAP),
        (Te.__version = _e.version),
        B.onUpdate && B.onUpdate(B);
    }
    ee.__version = B.version;
  }
  function se(ee, B, ve, Se, _e, Te) {
    const at = o.convert(ve.format, ve.colorSpace),
      Fe = o.convert(ve.type),
      Be = T(ve.internalFormat, at, Fe, ve.colorSpace);
    if (!r.get(B).__hasExternalTextures) {
      const Ye = Math.max(1, B.width >> Te),
        nt = Math.max(1, B.height >> Te);
      _e === n.TEXTURE_3D || _e === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(_e, Te, Be, Ye, nt, B.depth, 0, at, Fe, null)
        : t.texImage2D(_e, Te, Be, Ye, nt, 0, at, Fe, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, ee),
      Ie(B)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            Se,
            _e,
            r.get(ve).__webglTexture,
            0,
            Oe(B)
          )
        : (_e === n.TEXTURE_2D ||
            (_e >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              _e <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            Se,
            _e,
            r.get(ve).__webglTexture,
            Te
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function de(ee, B, ve) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, ee), B.depthBuffer)) {
      const Se = B.depthTexture,
        _e = Se && Se.isDepthTexture ? Se.type : null,
        Te = M(B.stencilBuffer, _e),
        at = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Fe = Oe(B);
      Ie(B)
        ? a.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Fe,
            Te,
            B.width,
            B.height
          )
        : ve
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Fe,
            Te,
            B.width,
            B.height
          )
        : n.renderbufferStorage(n.RENDERBUFFER, Te, B.width, B.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, at, n.RENDERBUFFER, ee);
    } else {
      const Se = B.textures;
      for (let _e = 0; _e < Se.length; _e++) {
        const Te = Se[_e],
          at = o.convert(Te.format, Te.colorSpace),
          Fe = o.convert(Te.type),
          Be = T(Te.internalFormat, at, Fe, Te.colorSpace),
          Ge = Oe(B);
        ve && Ie(B) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Ge,
              Be,
              B.width,
              B.height
            )
          : Ie(B)
          ? a.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              Ge,
              Be,
              B.width,
              B.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, Be, B.width, B.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function le(ee, B) {
    if (B && B.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, ee),
      !(B.depthTexture && B.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(B.depthTexture).__webglTexture ||
      B.depthTexture.image.width !== B.width ||
      B.depthTexture.image.height !== B.height) &&
      ((B.depthTexture.image.width = B.width),
      (B.depthTexture.image.height = B.height),
      (B.depthTexture.needsUpdate = !0)),
      K(B.depthTexture, 0);
    const Se = r.get(B.depthTexture).__webglTexture,
      _e = Oe(B);
    if (B.depthTexture.format === xf)
      Ie(B)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0,
            _e
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0
          );
    else if (B.depthTexture.format === Af)
      Ie(B)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0,
            _e
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Se,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function fe(ee) {
    const B = r.get(ee),
      ve = ee.isWebGLCubeRenderTarget === !0;
    if (ee.depthTexture && !B.__autoAllocateDepthBuffer) {
      if (ve)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      le(B.__webglFramebuffer, ee);
    } else if (ve) {
      B.__webglDepthbuffer = [];
      for (let Se = 0; Se < 6; Se++)
        t.bindFramebuffer(n.FRAMEBUFFER, B.__webglFramebuffer[Se]),
          (B.__webglDepthbuffer[Se] = n.createRenderbuffer()),
          de(B.__webglDepthbuffer[Se], ee, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, B.__webglFramebuffer),
        (B.__webglDepthbuffer = n.createRenderbuffer()),
        de(B.__webglDepthbuffer, ee, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Me(ee, B, ve) {
    const Se = r.get(ee);
    B !== void 0 &&
      se(
        Se.__webglFramebuffer,
        ee,
        ee.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      ve !== void 0 && fe(ee);
  }
  function ge(ee) {
    const B = ee.texture,
      ve = r.get(ee),
      Se = r.get(B);
    ee.addEventListener("dispose", D);
    const _e = ee.textures,
      Te = ee.isWebGLCubeRenderTarget === !0,
      at = _e.length > 1;
    if (
      (at ||
        (Se.__webglTexture === void 0 &&
          (Se.__webglTexture = n.createTexture()),
        (Se.__version = B.version),
        s.memory.textures++),
      Te)
    ) {
      ve.__webglFramebuffer = [];
      for (let Fe = 0; Fe < 6; Fe++)
        if (B.mipmaps && B.mipmaps.length > 0) {
          ve.__webglFramebuffer[Fe] = [];
          for (let Be = 0; Be < B.mipmaps.length; Be++)
            ve.__webglFramebuffer[Fe][Be] = n.createFramebuffer();
        } else ve.__webglFramebuffer[Fe] = n.createFramebuffer();
    } else {
      if (B.mipmaps && B.mipmaps.length > 0) {
        ve.__webglFramebuffer = [];
        for (let Fe = 0; Fe < B.mipmaps.length; Fe++)
          ve.__webglFramebuffer[Fe] = n.createFramebuffer();
      } else ve.__webglFramebuffer = n.createFramebuffer();
      if (at)
        for (let Fe = 0, Be = _e.length; Fe < Be; Fe++) {
          const Ge = r.get(_e[Fe]);
          Ge.__webglTexture === void 0 &&
            ((Ge.__webglTexture = n.createTexture()), s.memory.textures++);
        }
      if (ee.samples > 0 && Ie(ee) === !1) {
        (ve.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (ve.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, ve.__webglMultisampledFramebuffer);
        for (let Fe = 0; Fe < _e.length; Fe++) {
          const Be = _e[Fe];
          (ve.__webglColorRenderbuffer[Fe] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, ve.__webglColorRenderbuffer[Fe]);
          const Ge = o.convert(Be.format, Be.colorSpace),
            Ye = o.convert(Be.type),
            nt = T(
              Be.internalFormat,
              Ge,
              Ye,
              Be.colorSpace,
              ee.isXRRenderTarget === !0
            ),
            xt = Oe(ee);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            xt,
            nt,
            ee.width,
            ee.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Fe,
              n.RENDERBUFFER,
              ve.__webglColorRenderbuffer[Fe]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          ee.depthBuffer &&
            ((ve.__webglDepthRenderbuffer = n.createRenderbuffer()),
            de(ve.__webglDepthRenderbuffer, ee, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (Te) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, Se.__webglTexture),
        V(n.TEXTURE_CUBE_MAP, B);
      for (let Fe = 0; Fe < 6; Fe++)
        if (B.mipmaps && B.mipmaps.length > 0)
          for (let Be = 0; Be < B.mipmaps.length; Be++)
            se(
              ve.__webglFramebuffer[Fe][Be],
              ee,
              B,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe,
              Be
            );
        else
          se(
            ve.__webglFramebuffer[Fe],
            ee,
            B,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe,
            0
          );
      _(B) && w(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (at) {
      for (let Fe = 0, Be = _e.length; Fe < Be; Fe++) {
        const Ge = _e[Fe],
          Ye = r.get(Ge);
        t.bindTexture(n.TEXTURE_2D, Ye.__webglTexture),
          V(n.TEXTURE_2D, Ge),
          se(
            ve.__webglFramebuffer,
            ee,
            Ge,
            n.COLOR_ATTACHMENT0 + Fe,
            n.TEXTURE_2D,
            0
          ),
          _(Ge) && w(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Fe = n.TEXTURE_2D;
      if (
        ((ee.isWebGL3DRenderTarget || ee.isWebGLArrayRenderTarget) &&
          (Fe = ee.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Fe, Se.__webglTexture),
        V(Fe, B),
        B.mipmaps && B.mipmaps.length > 0)
      )
        for (let Be = 0; Be < B.mipmaps.length; Be++)
          se(ve.__webglFramebuffer[Be], ee, B, n.COLOR_ATTACHMENT0, Fe, Be);
      else se(ve.__webglFramebuffer, ee, B, n.COLOR_ATTACHMENT0, Fe, 0);
      _(B) && w(Fe), t.unbindTexture();
    }
    ee.depthBuffer && fe(ee);
  }
  function xe(ee) {
    const B = ee.textures;
    for (let ve = 0, Se = B.length; ve < Se; ve++) {
      const _e = B[ve];
      if (_(_e)) {
        const Te = ee.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          at = r.get(_e).__webglTexture;
        t.bindTexture(Te, at), w(Te), t.unbindTexture();
      }
    }
  }
  const j = [],
    we = [];
  function Ae(ee) {
    if (ee.samples > 0) {
      if (Ie(ee) === !1) {
        const B = ee.textures,
          ve = ee.width,
          Se = ee.height;
        let _e = n.COLOR_BUFFER_BIT;
        const Te = ee.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          at = r.get(ee),
          Fe = B.length > 1;
        if (Fe)
          for (let Be = 0; Be < B.length; Be++)
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          at.__webglMultisampledFramebuffer
        ),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, at.__webglFramebuffer);
        for (let Be = 0; Be < B.length; Be++) {
          if (
            (ee.resolveDepthBuffer &&
              (ee.depthBuffer && (_e |= n.DEPTH_BUFFER_BIT),
              ee.stencilBuffer &&
                ee.resolveStencilBuffer &&
                (_e |= n.STENCIL_BUFFER_BIT)),
            Fe)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              at.__webglColorRenderbuffer[Be]
            );
            const Ge = r.get(B[Be]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              Ge,
              0
            );
          }
          n.blitFramebuffer(0, 0, ve, Se, 0, 0, ve, Se, _e, n.NEAREST),
            u === !0 &&
              ((j.length = 0),
              (we.length = 0),
              j.push(n.COLOR_ATTACHMENT0 + Be),
              ee.depthBuffer &&
                ee.resolveDepthBuffer === !1 &&
                (j.push(Te),
                we.push(Te),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, we)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, j));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Fe)
        )
          for (let Be = 0; Be < B.length; Be++) {
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.RENDERBUFFER,
                at.__webglColorRenderbuffer[Be]
              );
            const Ge = r.get(B[Be]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, at.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Be,
                n.TEXTURE_2D,
                Ge,
                0
              );
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          at.__webglMultisampledFramebuffer
        );
      } else if (ee.depthBuffer && ee.resolveDepthBuffer === !1 && u) {
        const B = ee.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [B]);
      }
    }
  }
  function Oe(ee) {
    return Math.min(i.maxSamples, ee.samples);
  }
  function Ie(ee) {
    const B = r.get(ee);
    return (
      ee.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      B.__useRenderToTexture !== !1
    );
  }
  function rt(ee) {
    const B = s.render.frame;
    d.get(ee) !== B && (d.set(ee, B), ee.update());
  }
  function De(ee, B) {
    const ve = ee.colorSpace,
      Se = ee.format,
      _e = ee.type;
    return (
      ee.isCompressedTexture === !0 ||
        ee.isVideoTexture === !0 ||
        (ve !== jl &&
          ve !== kl &&
          (Sn.getTransfer(ve) === Jn
            ? (Se !== no || _e !== pa) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ve
              ))),
      B
    );
  }
  function Xe(ee) {
    return (
      typeof HTMLImageElement < "u" && ee instanceof HTMLImageElement
        ? ((c.width = ee.naturalWidth || ee.width),
          (c.height = ee.naturalHeight || ee.height))
        : typeof VideoFrame < "u" && ee instanceof VideoFrame
        ? ((c.width = ee.displayWidth), (c.height = ee.displayHeight))
        : ((c.width = ee.width), (c.height = ee.height)),
      c
    );
  }
  (this.allocateTextureUnit = W),
    (this.resetTextureUnits = H),
    (this.setTexture2D = K),
    (this.setTexture2DArray = Z),
    (this.setTexture3D = Y),
    (this.setTextureCube = re),
    (this.rebindTextures = Me),
    (this.setupRenderTarget = ge),
    (this.updateRenderTargetMipmap = xe),
    (this.updateMultisampleRenderTarget = Ae),
    (this.setupDepthRenderbuffer = fe),
    (this.setupFrameBufferTexture = se),
    (this.useMultisampledRTT = Ie);
}
function RR(n, e) {
  function t(r, i = kl) {
    let o;
    const s = Sn.getTransfer(i);
    if (r === pa) return n.UNSIGNED_BYTE;
    if (r === $y) return n.UNSIGNED_SHORT_4_4_4_4;
    if (r === Xy) return n.UNSIGNED_SHORT_5_5_5_1;
    if (r === ww) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (r === _w) return n.BYTE;
    if (r === Sw) return n.SHORT;
    if (r === Ih) return n.UNSIGNED_SHORT;
    if (r === jy) return n.INT;
    if (r === Vl) return n.UNSIGNED_INT;
    if (r === Bo) return n.FLOAT;
    if (r === Wh) return n.HALF_FLOAT;
    if (r === bw) return n.ALPHA;
    if (r === Mw) return n.RGB;
    if (r === no) return n.RGBA;
    if (r === Ew) return n.LUMINANCE;
    if (r === Tw) return n.LUMINANCE_ALPHA;
    if (r === xf) return n.DEPTH_COMPONENT;
    if (r === Af) return n.DEPTH_STENCIL;
    if (r === Yy) return n.RED;
    if (r === ag) return n.RED_INTEGER;
    if (r === Cw) return n.RG;
    if (r === qy) return n.RG_INTEGER;
    if (r === Ky) return n.RGBA_INTEGER;
    if (r === mm || r === gm || r === vm || r === ym)
      if (s === Jn)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (r === mm) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === gm) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === vm) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === ym) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (r === mm) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === gm) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === vm) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === ym) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === W0 || r === G0 || r === j0 || r === $0)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (r === W0) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === G0) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === j0) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === $0) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === X0 || r === Y0 || r === q0)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (r === X0 || r === Y0)
          return s === Jn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === q0)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === K0 ||
      r === Z0 ||
      r === J0 ||
      r === Q0 ||
      r === ey ||
      r === ty ||
      r === ny ||
      r === ry ||
      r === iy ||
      r === oy ||
      r === sy ||
      r === ay ||
      r === ly ||
      r === uy
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (r === K0)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === Z0)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === J0)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === Q0)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === ey)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === ty)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === ny)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === ry)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === iy)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === oy)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === sy)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === ay)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === ly)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === uy)
          return s === Jn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === xm || r === cy || r === fy)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (r === xm)
          return s === Jn
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === cy) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === fy) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (r === Aw || r === dy || r === hy || r === py)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (r === xm) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === dy) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === hy) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === py) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === Cf ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null;
  }
  return { convert: t };
}
class PR extends Nr {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class vh extends wn {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const jV = { type: "move" };
class s1 {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new vh()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new vh()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new oe()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new oe())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new vh()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new oe()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new oe())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let i = null,
      o = null,
      s = null;
    const a = this._targetRay,
      u = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        s = !0;
        for (const S of e.hand.values()) {
          const _ = t.getJointPose(S, r),
            w = this._getHandJoint(c, S);
          _ !== null &&
            (w.matrix.fromArray(_.transform.matrix),
            w.matrix.decompose(w.position, w.rotation, w.scale),
            (w.matrixWorldNeedsUpdate = !0),
            (w.jointRadius = _.radius)),
            (w.visible = _ !== null);
        }
        const d = c.joints["index-finger-tip"],
          m = c.joints["thumb-tip"],
          g = d.position.distanceTo(m.position),
          y = 0.02,
          x = 0.005;
        c.inputState.pinching && g > y + x
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            g <= y - x &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        u !== null &&
          e.gripSpace &&
          ((o = t.getPose(e.gripSpace, r)),
          o !== null &&
            (u.matrix.fromArray(o.transform.matrix),
            u.matrix.decompose(u.position, u.rotation, u.scale),
            (u.matrixWorldNeedsUpdate = !0),
            o.linearVelocity
              ? ((u.hasLinearVelocity = !0),
                u.linearVelocity.copy(o.linearVelocity))
              : (u.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((u.hasAngularVelocity = !0),
                u.angularVelocity.copy(o.angularVelocity))
              : (u.hasAngularVelocity = !1)));
      a !== null &&
        ((i = t.getPose(e.targetRaySpace, r)),
        i === null && o !== null && (i = o),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(jV)));
    }
    return (
      a !== null && (a.visible = i !== null),
      u !== null && (u.visible = o !== null),
      c !== null && (c.visible = s !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new vh();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
const $V = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  XV = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class YV {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, r) {
    if (this.texture === null) {
      const i = new er(),
        o = e.properties.get(i);
      (o.__webglTexture = t.texture),
        (t.depthNear != r.depthNear || t.depthFar != r.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        r = new Ds({
          vertexShader: $V,
          fragmentShader: XV,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new ur(new Yl(20, 20), r);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class qV extends $l {
  constructor(e, t) {
    super();
    const r = this;
    let i = null,
      o = 1,
      s = null,
      a = "local-floor",
      u = 1,
      c = null,
      d = null,
      m = null,
      g = null,
      y = null,
      x = null;
    const S = new YV(),
      _ = t.getContextAttributes();
    let w = null,
      T = null;
    const M = [],
      A = [],
      R = new tt();
    let D = null;
    const P = new Nr();
    P.layers.enable(1), (P.viewport = new dn());
    const U = new Nr();
    U.layers.enable(2), (U.viewport = new dn());
    const O = [P, U],
      L = new PR();
    L.layers.enable(1), L.layers.enable(2);
    let H = null,
      W = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (J) {
        let se = M[J];
        return (
          se === void 0 && ((se = new s1()), (M[J] = se)),
          se.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (J) {
        let se = M[J];
        return (
          se === void 0 && ((se = new s1()), (M[J] = se)), se.getGripSpace()
        );
      }),
      (this.getHand = function (J) {
        let se = M[J];
        return (
          se === void 0 && ((se = new s1()), (M[J] = se)), se.getHandSpace()
        );
      });
    function $(J) {
      const se = A.indexOf(J.inputSource);
      if (se === -1) return;
      const de = M[se];
      de !== void 0 &&
        (de.update(J.inputSource, J.frame, c || s),
        de.dispatchEvent({ type: J.type, data: J.inputSource }));
    }
    function K() {
      i.removeEventListener("select", $),
        i.removeEventListener("selectstart", $),
        i.removeEventListener("selectend", $),
        i.removeEventListener("squeeze", $),
        i.removeEventListener("squeezestart", $),
        i.removeEventListener("squeezeend", $),
        i.removeEventListener("end", K),
        i.removeEventListener("inputsourceschange", Z);
      for (let J = 0; J < M.length; J++) {
        const se = A[J];
        se !== null && ((A[J] = null), M[J].disconnect(se));
      }
      (H = null),
        (W = null),
        S.reset(),
        e.setRenderTarget(w),
        (y = null),
        (g = null),
        (m = null),
        (i = null),
        (T = null),
        ae.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(D),
        e.setSize(R.width, R.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (J) {
      (o = J),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (J) {
        (a = J),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || s;
      }),
      (this.setReferenceSpace = function (J) {
        c = J;
      }),
      (this.getBaseLayer = function () {
        return g !== null ? g : y;
      }),
      (this.getBinding = function () {
        return m;
      }),
      (this.getFrame = function () {
        return x;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (J) {
        if (((i = J), i !== null)) {
          if (
            ((w = e.getRenderTarget()),
            i.addEventListener("select", $),
            i.addEventListener("selectstart", $),
            i.addEventListener("selectend", $),
            i.addEventListener("squeeze", $),
            i.addEventListener("squeezestart", $),
            i.addEventListener("squeezeend", $),
            i.addEventListener("end", K),
            i.addEventListener("inputsourceschange", Z),
            _.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (D = e.getPixelRatio()),
            e.getSize(R),
            i.renderState.layers === void 0)
          ) {
            const se = {
              antialias: _.antialias,
              alpha: !0,
              depth: _.depth,
              stencil: _.stencil,
              framebufferScaleFactor: o,
            };
            (y = new XRWebGLLayer(i, t, se)),
              i.updateRenderState({ baseLayer: y }),
              e.setPixelRatio(1),
              e.setSize(y.framebufferWidth, y.framebufferHeight, !1),
              (T = new ma(y.framebufferWidth, y.framebufferHeight, {
                format: no,
                type: pa,
                colorSpace: e.outputColorSpace,
                stencilBuffer: _.stencil,
              }));
          } else {
            let se = null,
              de = null,
              le = null;
            _.depth &&
              ((le = _.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (se = _.stencil ? Af : xf),
              (de = _.stencil ? Cf : Vl));
            const fe = {
              colorFormat: t.RGBA8,
              depthFormat: le,
              scaleFactor: o,
            };
            (m = new XRWebGLBinding(i, t)),
              (g = m.createProjectionLayer(fe)),
              i.updateRenderState({ layers: [g] }),
              e.setPixelRatio(1),
              e.setSize(g.textureWidth, g.textureHeight, !1),
              (T = new ma(g.textureWidth, g.textureHeight, {
                format: no,
                type: pa,
                depthTexture: new Uw(
                  g.textureWidth,
                  g.textureHeight,
                  de,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  se
                ),
                stencilBuffer: _.stencil,
                colorSpace: e.outputColorSpace,
                samples: _.antialias ? 4 : 0,
                resolveDepthBuffer: g.ignoreDepthValues === !1,
              }));
          }
          (T.isXRRenderTarget = !0),
            this.setFoveation(u),
            (c = null),
            (s = await i.requestReferenceSpace(a)),
            ae.setContext(i),
            ae.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return S.getDepthTexture();
      });
    function Z(J) {
      for (let se = 0; se < J.removed.length; se++) {
        const de = J.removed[se],
          le = A.indexOf(de);
        le >= 0 && ((A[le] = null), M[le].disconnect(de));
      }
      for (let se = 0; se < J.added.length; se++) {
        const de = J.added[se];
        let le = A.indexOf(de);
        if (le === -1) {
          for (let Me = 0; Me < M.length; Me++)
            if (Me >= A.length) {
              A.push(de), (le = Me);
              break;
            } else if (A[Me] === null) {
              (A[Me] = de), (le = Me);
              break;
            }
          if (le === -1) break;
        }
        const fe = M[le];
        fe && fe.connect(de);
      }
    }
    const Y = new oe(),
      re = new oe();
    function G(J, se, de) {
      Y.setFromMatrixPosition(se.matrixWorld),
        re.setFromMatrixPosition(de.matrixWorld);
      const le = Y.distanceTo(re),
        fe = se.projectionMatrix.elements,
        Me = de.projectionMatrix.elements,
        ge = fe[14] / (fe[10] - 1),
        xe = fe[14] / (fe[10] + 1),
        j = (fe[9] + 1) / fe[5],
        we = (fe[9] - 1) / fe[5],
        Ae = (fe[8] - 1) / fe[0],
        Oe = (Me[8] + 1) / Me[0],
        Ie = ge * Ae,
        rt = ge * Oe,
        De = le / (-Ae + Oe),
        Xe = De * -Ae;
      se.matrixWorld.decompose(J.position, J.quaternion, J.scale),
        J.translateX(Xe),
        J.translateZ(De),
        J.matrixWorld.compose(J.position, J.quaternion, J.scale),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
      const ee = ge + De,
        B = xe + De,
        ve = Ie - Xe,
        Se = rt + (le - Xe),
        _e = ((j * xe) / B) * ee,
        Te = ((we * xe) / B) * ee;
      J.projectionMatrix.makePerspective(ve, Se, _e, Te, ee, B),
        J.projectionMatrixInverse.copy(J.projectionMatrix).invert();
    }
    function te(J, se) {
      se === null
        ? J.matrixWorld.copy(J.matrix)
        : J.matrixWorld.multiplyMatrices(se.matrixWorld, J.matrix),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
    }
    this.updateCamera = function (J) {
      if (i === null) return;
      S.texture !== null && ((J.near = S.depthNear), (J.far = S.depthFar)),
        (L.near = U.near = P.near = J.near),
        (L.far = U.far = P.far = J.far),
        (H !== L.near || W !== L.far) &&
          (i.updateRenderState({ depthNear: L.near, depthFar: L.far }),
          (H = L.near),
          (W = L.far),
          (P.near = H),
          (P.far = W),
          (U.near = H),
          (U.far = W),
          P.updateProjectionMatrix(),
          U.updateProjectionMatrix(),
          J.updateProjectionMatrix());
      const se = J.parent,
        de = L.cameras;
      te(L, se);
      for (let le = 0; le < de.length; le++) te(de[le], se);
      de.length === 2
        ? G(L, P, U)
        : L.projectionMatrix.copy(P.projectionMatrix),
        F(J, L, se);
    };
    function F(J, se, de) {
      de === null
        ? J.matrix.copy(se.matrixWorld)
        : (J.matrix.copy(de.matrixWorld),
          J.matrix.invert(),
          J.matrix.multiply(se.matrixWorld)),
        J.matrix.decompose(J.position, J.quaternion, J.scale),
        J.updateMatrixWorld(!0),
        J.projectionMatrix.copy(se.projectionMatrix),
        J.projectionMatrixInverse.copy(se.projectionMatrixInverse),
        J.isPerspectiveCamera &&
          ((J.fov = Lh * 2 * Math.atan(1 / J.projectionMatrix.elements[5])),
          (J.zoom = 1));
    }
    (this.getCamera = function () {
      return L;
    }),
      (this.getFoveation = function () {
        if (!(g === null && y === null)) return u;
      }),
      (this.setFoveation = function (J) {
        (u = J),
          g !== null && (g.fixedFoveation = J),
          y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = J);
      }),
      (this.hasDepthSensing = function () {
        return S.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return S.getMesh(L);
      });
    let V = null;
    function ne(J, se) {
      if (((d = se.getViewerPose(c || s)), (x = se), d !== null)) {
        const de = d.views;
        y !== null &&
          (e.setRenderTargetFramebuffer(T, y.framebuffer),
          e.setRenderTarget(T));
        let le = !1;
        de.length !== L.cameras.length && ((L.cameras.length = 0), (le = !0));
        for (let Me = 0; Me < de.length; Me++) {
          const ge = de[Me];
          let xe = null;
          if (y !== null) xe = y.getViewport(ge);
          else {
            const we = m.getViewSubImage(g, ge);
            (xe = we.viewport),
              Me === 0 &&
                (e.setRenderTargetTextures(
                  T,
                  we.colorTexture,
                  g.ignoreDepthValues ? void 0 : we.depthStencilTexture
                ),
                e.setRenderTarget(T));
          }
          let j = O[Me];
          j === void 0 &&
            ((j = new Nr()),
            j.layers.enable(Me),
            (j.viewport = new dn()),
            (O[Me] = j)),
            j.matrix.fromArray(ge.transform.matrix),
            j.matrix.decompose(j.position, j.quaternion, j.scale),
            j.projectionMatrix.fromArray(ge.projectionMatrix),
            j.projectionMatrixInverse.copy(j.projectionMatrix).invert(),
            j.viewport.set(xe.x, xe.y, xe.width, xe.height),
            Me === 0 &&
              (L.matrix.copy(j.matrix),
              L.matrix.decompose(L.position, L.quaternion, L.scale)),
            le === !0 && L.cameras.push(j);
        }
        const fe = i.enabledFeatures;
        if (fe && fe.includes("depth-sensing")) {
          const Me = m.getDepthInformation(de[0]);
          Me && Me.isValid && Me.texture && S.init(e, Me, i.renderState);
        }
      }
      for (let de = 0; de < M.length; de++) {
        const le = A[de],
          fe = M[de];
        le !== null && fe !== void 0 && fe.update(le, se, c || s);
      }
      V && V(J, se),
        se.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: se }),
        (x = null);
    }
    const ae = new MR();
    ae.setAnimationLoop(ne),
      (this.setAnimationLoop = function (J) {
        V = J;
      }),
      (this.dispose = function () {});
  }
}
const Gc = new fs(),
  KV = new Gt();
function ZV(n, e) {
  function t(_, w) {
    _.matrixAutoUpdate === !0 && _.updateMatrix(), w.value.copy(_.matrix);
  }
  function r(_, w) {
    w.color.getRGB(_.fogColor.value, SR(n)),
      w.isFog
        ? ((_.fogNear.value = w.near), (_.fogFar.value = w.far))
        : w.isFogExp2 && (_.fogDensity.value = w.density);
  }
  function i(_, w, T, M, A) {
    w.isMeshBasicMaterial || w.isMeshLambertMaterial
      ? o(_, w)
      : w.isMeshToonMaterial
      ? (o(_, w), m(_, w))
      : w.isMeshPhongMaterial
      ? (o(_, w), d(_, w))
      : w.isMeshStandardMaterial
      ? (o(_, w), g(_, w), w.isMeshPhysicalMaterial && y(_, w, A))
      : w.isMeshMatcapMaterial
      ? (o(_, w), x(_, w))
      : w.isMeshDepthMaterial
      ? o(_, w)
      : w.isMeshDistanceMaterial
      ? (o(_, w), S(_, w))
      : w.isMeshNormalMaterial
      ? o(_, w)
      : w.isLineBasicMaterial
      ? (s(_, w), w.isLineDashedMaterial && a(_, w))
      : w.isPointsMaterial
      ? u(_, w, T, M)
      : w.isSpriteMaterial
      ? c(_, w)
      : w.isShadowMaterial
      ? (_.color.value.copy(w.color), (_.opacity.value = w.opacity))
      : w.isShaderMaterial && (w.uniformsNeedUpdate = !1);
  }
  function o(_, w) {
    (_.opacity.value = w.opacity),
      w.color && _.diffuse.value.copy(w.color),
      w.emissive &&
        _.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity),
      w.map && ((_.map.value = w.map), t(w.map, _.mapTransform)),
      w.alphaMap &&
        ((_.alphaMap.value = w.alphaMap), t(w.alphaMap, _.alphaMapTransform)),
      w.bumpMap &&
        ((_.bumpMap.value = w.bumpMap),
        t(w.bumpMap, _.bumpMapTransform),
        (_.bumpScale.value = w.bumpScale),
        w.side === ro && (_.bumpScale.value *= -1)),
      w.normalMap &&
        ((_.normalMap.value = w.normalMap),
        t(w.normalMap, _.normalMapTransform),
        _.normalScale.value.copy(w.normalScale),
        w.side === ro && _.normalScale.value.negate()),
      w.displacementMap &&
        ((_.displacementMap.value = w.displacementMap),
        t(w.displacementMap, _.displacementMapTransform),
        (_.displacementScale.value = w.displacementScale),
        (_.displacementBias.value = w.displacementBias)),
      w.emissiveMap &&
        ((_.emissiveMap.value = w.emissiveMap),
        t(w.emissiveMap, _.emissiveMapTransform)),
      w.specularMap &&
        ((_.specularMap.value = w.specularMap),
        t(w.specularMap, _.specularMapTransform)),
      w.alphaTest > 0 && (_.alphaTest.value = w.alphaTest);
    const T = e.get(w),
      M = T.envMap,
      A = T.envMapRotation;
    M &&
      ((_.envMap.value = M),
      Gc.copy(A),
      (Gc.x *= -1),
      (Gc.y *= -1),
      (Gc.z *= -1),
      M.isCubeTexture &&
        M.isRenderTargetTexture === !1 &&
        ((Gc.y *= -1), (Gc.z *= -1)),
      _.envMapRotation.value.setFromMatrix4(KV.makeRotationFromEuler(Gc)),
      (_.flipEnvMap.value =
        M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1),
      (_.reflectivity.value = w.reflectivity),
      (_.ior.value = w.ior),
      (_.refractionRatio.value = w.refractionRatio)),
      w.lightMap &&
        ((_.lightMap.value = w.lightMap),
        (_.lightMapIntensity.value = w.lightMapIntensity),
        t(w.lightMap, _.lightMapTransform)),
      w.aoMap &&
        ((_.aoMap.value = w.aoMap),
        (_.aoMapIntensity.value = w.aoMapIntensity),
        t(w.aoMap, _.aoMapTransform));
  }
  function s(_, w) {
    _.diffuse.value.copy(w.color),
      (_.opacity.value = w.opacity),
      w.map && ((_.map.value = w.map), t(w.map, _.mapTransform));
  }
  function a(_, w) {
    (_.dashSize.value = w.dashSize),
      (_.totalSize.value = w.dashSize + w.gapSize),
      (_.scale.value = w.scale);
  }
  function u(_, w, T, M) {
    _.diffuse.value.copy(w.color),
      (_.opacity.value = w.opacity),
      (_.size.value = w.size * T),
      (_.scale.value = M * 0.5),
      w.map && ((_.map.value = w.map), t(w.map, _.uvTransform)),
      w.alphaMap &&
        ((_.alphaMap.value = w.alphaMap), t(w.alphaMap, _.alphaMapTransform)),
      w.alphaTest > 0 && (_.alphaTest.value = w.alphaTest);
  }
  function c(_, w) {
    _.diffuse.value.copy(w.color),
      (_.opacity.value = w.opacity),
      (_.rotation.value = w.rotation),
      w.map && ((_.map.value = w.map), t(w.map, _.mapTransform)),
      w.alphaMap &&
        ((_.alphaMap.value = w.alphaMap), t(w.alphaMap, _.alphaMapTransform)),
      w.alphaTest > 0 && (_.alphaTest.value = w.alphaTest);
  }
  function d(_, w) {
    _.specular.value.copy(w.specular),
      (_.shininess.value = Math.max(w.shininess, 1e-4));
  }
  function m(_, w) {
    w.gradientMap && (_.gradientMap.value = w.gradientMap);
  }
  function g(_, w) {
    (_.metalness.value = w.metalness),
      w.metalnessMap &&
        ((_.metalnessMap.value = w.metalnessMap),
        t(w.metalnessMap, _.metalnessMapTransform)),
      (_.roughness.value = w.roughness),
      w.roughnessMap &&
        ((_.roughnessMap.value = w.roughnessMap),
        t(w.roughnessMap, _.roughnessMapTransform)),
      w.envMap && (_.envMapIntensity.value = w.envMapIntensity);
  }
  function y(_, w, T) {
    (_.ior.value = w.ior),
      w.sheen > 0 &&
        (_.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen),
        (_.sheenRoughness.value = w.sheenRoughness),
        w.sheenColorMap &&
          ((_.sheenColorMap.value = w.sheenColorMap),
          t(w.sheenColorMap, _.sheenColorMapTransform)),
        w.sheenRoughnessMap &&
          ((_.sheenRoughnessMap.value = w.sheenRoughnessMap),
          t(w.sheenRoughnessMap, _.sheenRoughnessMapTransform))),
      w.clearcoat > 0 &&
        ((_.clearcoat.value = w.clearcoat),
        (_.clearcoatRoughness.value = w.clearcoatRoughness),
        w.clearcoatMap &&
          ((_.clearcoatMap.value = w.clearcoatMap),
          t(w.clearcoatMap, _.clearcoatMapTransform)),
        w.clearcoatRoughnessMap &&
          ((_.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap),
          t(w.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)),
        w.clearcoatNormalMap &&
          ((_.clearcoatNormalMap.value = w.clearcoatNormalMap),
          t(w.clearcoatNormalMap, _.clearcoatNormalMapTransform),
          _.clearcoatNormalScale.value.copy(w.clearcoatNormalScale),
          w.side === ro && _.clearcoatNormalScale.value.negate())),
      w.dispersion > 0 && (_.dispersion.value = w.dispersion),
      w.iridescence > 0 &&
        ((_.iridescence.value = w.iridescence),
        (_.iridescenceIOR.value = w.iridescenceIOR),
        (_.iridescenceThicknessMinimum.value = w.iridescenceThicknessRange[0]),
        (_.iridescenceThicknessMaximum.value = w.iridescenceThicknessRange[1]),
        w.iridescenceMap &&
          ((_.iridescenceMap.value = w.iridescenceMap),
          t(w.iridescenceMap, _.iridescenceMapTransform)),
        w.iridescenceThicknessMap &&
          ((_.iridescenceThicknessMap.value = w.iridescenceThicknessMap),
          t(w.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))),
      w.transmission > 0 &&
        ((_.transmission.value = w.transmission),
        (_.transmissionSamplerMap.value = T.texture),
        _.transmissionSamplerSize.value.set(T.width, T.height),
        w.transmissionMap &&
          ((_.transmissionMap.value = w.transmissionMap),
          t(w.transmissionMap, _.transmissionMapTransform)),
        (_.thickness.value = w.thickness),
        w.thicknessMap &&
          ((_.thicknessMap.value = w.thicknessMap),
          t(w.thicknessMap, _.thicknessMapTransform)),
        (_.attenuationDistance.value = w.attenuationDistance),
        _.attenuationColor.value.copy(w.attenuationColor)),
      w.anisotropy > 0 &&
        (_.anisotropyVector.value.set(
          w.anisotropy * Math.cos(w.anisotropyRotation),
          w.anisotropy * Math.sin(w.anisotropyRotation)
        ),
        w.anisotropyMap &&
          ((_.anisotropyMap.value = w.anisotropyMap),
          t(w.anisotropyMap, _.anisotropyMapTransform))),
      (_.specularIntensity.value = w.specularIntensity),
      _.specularColor.value.copy(w.specularColor),
      w.specularColorMap &&
        ((_.specularColorMap.value = w.specularColorMap),
        t(w.specularColorMap, _.specularColorMapTransform)),
      w.specularIntensityMap &&
        ((_.specularIntensityMap.value = w.specularIntensityMap),
        t(w.specularIntensityMap, _.specularIntensityMapTransform));
  }
  function x(_, w) {
    w.matcap && (_.matcap.value = w.matcap);
  }
  function S(_, w) {
    const T = e.get(w).light;
    _.referencePosition.value.setFromMatrixPosition(T.matrixWorld),
      (_.nearDistance.value = T.shadow.camera.near),
      (_.farDistance.value = T.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function JV(n, e, t, r) {
  let i = {},
    o = {},
    s = [];
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(T, M) {
    const A = M.program;
    r.uniformBlockBinding(T, A);
  }
  function c(T, M) {
    let A = i[T.id];
    A === void 0 &&
      (x(T), (A = d(T)), (i[T.id] = A), T.addEventListener("dispose", _));
    const R = M.program;
    r.updateUBOMapping(T, R);
    const D = e.render.frame;
    o[T.id] !== D && (g(T), (o[T.id] = D));
  }
  function d(T) {
    const M = m();
    T.__bindingPointIndex = M;
    const A = n.createBuffer(),
      R = T.__size,
      D = T.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, A),
      n.bufferData(n.UNIFORM_BUFFER, R, D),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, M, A),
      A
    );
  }
  function m() {
    for (let T = 0; T < a; T++) if (s.indexOf(T) === -1) return s.push(T), T;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function g(T) {
    const M = i[T.id],
      A = T.uniforms,
      R = T.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, M);
    for (let D = 0, P = A.length; D < P; D++) {
      const U = Array.isArray(A[D]) ? A[D] : [A[D]];
      for (let O = 0, L = U.length; O < L; O++) {
        const H = U[O];
        if (y(H, D, O, R) === !0) {
          const W = H.__offset,
            $ = Array.isArray(H.value) ? H.value : [H.value];
          let K = 0;
          for (let Z = 0; Z < $.length; Z++) {
            const Y = $[Z],
              re = S(Y);
            typeof Y == "number" || typeof Y == "boolean"
              ? ((H.__data[0] = Y),
                n.bufferSubData(n.UNIFORM_BUFFER, W + K, H.__data))
              : Y.isMatrix3
              ? ((H.__data[0] = Y.elements[0]),
                (H.__data[1] = Y.elements[1]),
                (H.__data[2] = Y.elements[2]),
                (H.__data[3] = 0),
                (H.__data[4] = Y.elements[3]),
                (H.__data[5] = Y.elements[4]),
                (H.__data[6] = Y.elements[5]),
                (H.__data[7] = 0),
                (H.__data[8] = Y.elements[6]),
                (H.__data[9] = Y.elements[7]),
                (H.__data[10] = Y.elements[8]),
                (H.__data[11] = 0))
              : (Y.toArray(H.__data, K),
                (K += re.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, W, H.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function y(T, M, A, R) {
    const D = T.value,
      P = M + "_" + A;
    if (R[P] === void 0)
      return (
        typeof D == "number" || typeof D == "boolean"
          ? (R[P] = D)
          : (R[P] = D.clone()),
        !0
      );
    {
      const U = R[P];
      if (typeof D == "number" || typeof D == "boolean") {
        if (U !== D) return (R[P] = D), !0;
      } else if (U.equals(D) === !1) return U.copy(D), !0;
    }
    return !1;
  }
  function x(T) {
    const M = T.uniforms;
    let A = 0;
    const R = 16;
    for (let P = 0, U = M.length; P < U; P++) {
      const O = Array.isArray(M[P]) ? M[P] : [M[P]];
      for (let L = 0, H = O.length; L < H; L++) {
        const W = O[L],
          $ = Array.isArray(W.value) ? W.value : [W.value];
        for (let K = 0, Z = $.length; K < Z; K++) {
          const Y = $[K],
            re = S(Y),
            G = A % R,
            te = G % re.boundary,
            F = G + te;
          (A += te),
            F !== 0 && R - F < re.storage && (A += R - F),
            (W.__data = new Float32Array(
              re.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (W.__offset = A),
            (A += re.storage);
        }
      }
    }
    const D = A % R;
    return D > 0 && (A += R - D), (T.__size = A), (T.__cache = {}), this;
  }
  function S(T) {
    const M = { boundary: 0, storage: 0 };
    return (
      typeof T == "number" || typeof T == "boolean"
        ? ((M.boundary = 4), (M.storage = 4))
        : T.isVector2
        ? ((M.boundary = 8), (M.storage = 8))
        : T.isVector3 || T.isColor
        ? ((M.boundary = 16), (M.storage = 12))
        : T.isVector4
        ? ((M.boundary = 16), (M.storage = 16))
        : T.isMatrix3
        ? ((M.boundary = 48), (M.storage = 48))
        : T.isMatrix4
        ? ((M.boundary = 64), (M.storage = 64))
        : T.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            T
          ),
      M
    );
  }
  function _(T) {
    const M = T.target;
    M.removeEventListener("dispose", _);
    const A = s.indexOf(M.__bindingPointIndex);
    s.splice(A, 1), n.deleteBuffer(i[M.id]), delete i[M.id], delete o[M.id];
  }
  function w() {
    for (const T in i) n.deleteBuffer(i[T]);
    (s = []), (i = {}), (o = {});
  }
  return { bind: u, update: c, dispose: w };
}
class IR {
  constructor(e = {}) {
    const {
      canvas: t = vR(),
      context: r = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: s = !1,
      antialias: a = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: m = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let g;
    if (r !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        r instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      g = r.getContextAttributes().alpha;
    } else g = s;
    const y = new Uint32Array(4),
      x = new Int32Array(4);
    let S = null,
      _ = null;
    const w = [],
      T = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = As),
      (this.toneMapping = Za),
      (this.toneMappingExposure = 1);
    const M = this;
    let A = !1,
      R = 0,
      D = 0,
      P = null,
      U = -1,
      O = null;
    const L = new dn(),
      H = new dn();
    let W = null;
    const $ = new St(0);
    let K = 0,
      Z = t.width,
      Y = t.height,
      re = 1,
      G = null,
      te = null;
    const F = new dn(0, 0, Z, Y),
      V = new dn(0, 0, Z, Y);
    let ne = !1;
    const ae = new fg();
    let J = !1,
      se = !1;
    const de = new Gt(),
      le = new oe(),
      fe = new dn(),
      Me = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let ge = !1;
    function xe() {
      return P === null ? re : 1;
    }
    let j = r;
    function we(ie, Ce) {
      return t.getContext(ie, Ce);
    }
    try {
      const ie = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: a,
        premultipliedAlpha: u,
        preserveDrawingBuffer: c,
        powerPreference: d,
        failIfMajorPerformanceCaveat: m,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${og}`),
        t.addEventListener("webglcontextlost", Re, !1),
        t.addEventListener("webglcontextrestored", Ue, !1),
        t.addEventListener("webglcontextcreationerror", it, !1),
        j === null)
      ) {
        const Ce = "webgl2";
        if (((j = we(Ce, ie)), j === null))
          throw we(Ce)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (ie) {
      throw (console.error("THREE.WebGLRenderer: " + ie.message), ie);
    }
    let Ae,
      Oe,
      Ie,
      rt,
      De,
      Xe,
      ee,
      B,
      ve,
      Se,
      _e,
      Te,
      at,
      Fe,
      Be,
      Ge,
      Ye,
      nt,
      xt,
      $e,
      qe,
      et,
      he,
      Je;
    function me() {
      (Ae = new oH(j)),
        Ae.init(),
        (et = new RR(j, Ae)),
        (Oe = new Q6(j, Ae, e, et)),
        (Ie = new FV(j)),
        (rt = new lH(j)),
        (De = new TV()),
        (Xe = new GV(j, Ae, Ie, De, Oe, et, rt)),
        (ee = new tH(M)),
        (B = new iH(M)),
        (ve = new mz(j)),
        (he = new Z6(j, ve)),
        (Se = new sH(j, ve, rt, he)),
        (_e = new cH(j, Se, ve, rt)),
        (xt = new uH(j, Oe, Xe)),
        (Ge = new eH(De)),
        (Te = new EV(M, ee, B, Ae, Oe, he, Ge)),
        (at = new ZV(M, De)),
        (Fe = new AV()),
        (Be = new kV(Ae)),
        (nt = new K6(M, ee, B, Ie, _e, g, u)),
        (Ye = new UV(M, _e, Oe)),
        (Je = new JV(j, rt, Oe, Ie)),
        ($e = new J6(j, Ae, rt)),
        (qe = new aH(j, Ae, rt)),
        (rt.programs = Te.programs),
        (M.capabilities = Oe),
        (M.extensions = Ae),
        (M.properties = De),
        (M.renderLists = Fe),
        (M.shadowMap = Ye),
        (M.state = Ie),
        (M.info = rt);
    }
    me();
    const Ve = new qV(M, j);
    (this.xr = Ve),
      (this.getContext = function () {
        return j;
      }),
      (this.getContextAttributes = function () {
        return j.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const ie = Ae.get("WEBGL_lose_context");
        ie && ie.loseContext();
      }),
      (this.forceContextRestore = function () {
        const ie = Ae.get("WEBGL_lose_context");
        ie && ie.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return re;
      }),
      (this.setPixelRatio = function (ie) {
        ie !== void 0 && ((re = ie), this.setSize(Z, Y, !1));
      }),
      (this.getSize = function (ie) {
        return ie.set(Z, Y);
      }),
      (this.setSize = function (ie, Ce, ze = !0) {
        if (Ve.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Z = ie),
          (Y = Ce),
          (t.width = Math.floor(ie * re)),
          (t.height = Math.floor(Ce * re)),
          ze === !0 &&
            ((t.style.width = ie + "px"), (t.style.height = Ce + "px")),
          this.setViewport(0, 0, ie, Ce);
      }),
      (this.getDrawingBufferSize = function (ie) {
        return ie.set(Z * re, Y * re).floor();
      }),
      (this.setDrawingBufferSize = function (ie, Ce, ze) {
        (Z = ie),
          (Y = Ce),
          (re = ze),
          (t.width = Math.floor(ie * ze)),
          (t.height = Math.floor(Ce * ze)),
          this.setViewport(0, 0, ie, Ce);
      }),
      (this.getCurrentViewport = function (ie) {
        return ie.copy(L);
      }),
      (this.getViewport = function (ie) {
        return ie.copy(F);
      }),
      (this.setViewport = function (ie, Ce, ze, We) {
        ie.isVector4 ? F.set(ie.x, ie.y, ie.z, ie.w) : F.set(ie, Ce, ze, We),
          Ie.viewport(L.copy(F).multiplyScalar(re).round());
      }),
      (this.getScissor = function (ie) {
        return ie.copy(V);
      }),
      (this.setScissor = function (ie, Ce, ze, We) {
        ie.isVector4 ? V.set(ie.x, ie.y, ie.z, ie.w) : V.set(ie, Ce, ze, We),
          Ie.scissor(H.copy(V).multiplyScalar(re).round());
      }),
      (this.getScissorTest = function () {
        return ne;
      }),
      (this.setScissorTest = function (ie) {
        Ie.setScissorTest((ne = ie));
      }),
      (this.setOpaqueSort = function (ie) {
        G = ie;
      }),
      (this.setTransparentSort = function (ie) {
        te = ie;
      }),
      (this.getClearColor = function (ie) {
        return ie.copy(nt.getClearColor());
      }),
      (this.setClearColor = function () {
        nt.setClearColor.apply(nt, arguments);
      }),
      (this.getClearAlpha = function () {
        return nt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        nt.setClearAlpha.apply(nt, arguments);
      }),
      (this.clear = function (ie = !0, Ce = !0, ze = !0) {
        let We = 0;
        if (ie) {
          let Le = !1;
          if (P !== null) {
            const ut = P.texture.format;
            Le = ut === Ky || ut === qy || ut === ag;
          }
          if (Le) {
            const ut = P.texture.type,
              yt =
                ut === pa ||
                ut === Vl ||
                ut === Ih ||
                ut === Cf ||
                ut === $y ||
                ut === Xy,
              Et = nt.getClearColor(),
              Ke = nt.getClearAlpha(),
              kt = Et.r,
              Ft = Et.g,
              At = Et.b;
            yt
              ? ((y[0] = kt),
                (y[1] = Ft),
                (y[2] = At),
                (y[3] = Ke),
                j.clearBufferuiv(j.COLOR, 0, y))
              : ((x[0] = kt),
                (x[1] = Ft),
                (x[2] = At),
                (x[3] = Ke),
                j.clearBufferiv(j.COLOR, 0, x));
          } else We |= j.COLOR_BUFFER_BIT;
        }
        Ce && (We |= j.DEPTH_BUFFER_BIT),
          ze &&
            ((We |= j.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          j.clear(We);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Re, !1),
          t.removeEventListener("webglcontextrestored", Ue, !1),
          t.removeEventListener("webglcontextcreationerror", it, !1),
          Fe.dispose(),
          Be.dispose(),
          De.dispose(),
          ee.dispose(),
          B.dispose(),
          _e.dispose(),
          he.dispose(),
          Je.dispose(),
          Te.dispose(),
          Ve.dispose(),
          Ve.removeEventListener("sessionstart", un),
          Ve.removeEventListener("sessionend", bn),
          yn.stop();
      });
    function Re(ie) {
      ie.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (A = !0);
    }
    function Ue() {
      console.log("THREE.WebGLRenderer: Context Restored."), (A = !1);
      const ie = rt.autoReset,
        Ce = Ye.enabled,
        ze = Ye.autoUpdate,
        We = Ye.needsUpdate,
        Le = Ye.type;
      me(),
        (rt.autoReset = ie),
        (Ye.enabled = Ce),
        (Ye.autoUpdate = ze),
        (Ye.needsUpdate = We),
        (Ye.type = Le);
    }
    function it(ie) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        ie.statusMessage
      );
    }
    function mt(ie) {
      const Ce = ie.target;
      Ce.removeEventListener("dispose", mt), gt(Ce);
    }
    function gt(ie) {
      Nt(ie), De.remove(ie);
    }
    function Nt(ie) {
      const Ce = De.get(ie).programs;
      Ce !== void 0 &&
        (Ce.forEach(function (ze) {
          Te.releaseProgram(ze);
        }),
        ie.isShaderMaterial && Te.releaseShaderCache(ie));
    }
    this.renderBufferDirect = function (ie, Ce, ze, We, Le, ut) {
      Ce === null && (Ce = Me);
      const yt = Le.isMesh && Le.matrixWorld.determinant() < 0,
        Et = ql(ie, Ce, ze, We, Le);
      Ie.setMaterial(We, yt);
      let Ke = ze.index,
        kt = 1;
      if (We.wireframe === !0) {
        if (((Ke = Se.getWireframeAttribute(ze)), Ke === void 0)) return;
        kt = 2;
      }
      const Ft = ze.drawRange,
        At = ze.attributes.position;
      let tn = Ft.start * kt,
        An = (Ft.start + Ft.count) * kt;
      ut !== null &&
        ((tn = Math.max(tn, ut.start * kt)),
        (An = Math.min(An, (ut.start + ut.count) * kt))),
        Ke !== null
          ? ((tn = Math.max(tn, 0)), (An = Math.min(An, Ke.count)))
          : At != null &&
            ((tn = Math.max(tn, 0)), (An = Math.min(An, At.count)));
      const pn = An - tn;
      if (pn < 0 || pn === 1 / 0) return;
      he.setup(Le, We, Et, ze, Ke);
      let Mn,
        wt = $e;
      if (
        (Ke !== null && ((Mn = ve.get(Ke)), (wt = qe), wt.setIndex(Mn)),
        Le.isMesh)
      )
        We.wireframe === !0
          ? (Ie.setLineWidth(We.wireframeLinewidth * xe()), wt.setMode(j.LINES))
          : wt.setMode(j.TRIANGLES);
      else if (Le.isLine) {
        let dt = We.linewidth;
        dt === void 0 && (dt = 1),
          Ie.setLineWidth(dt * xe()),
          Le.isLineSegments
            ? wt.setMode(j.LINES)
            : Le.isLineLoop
            ? wt.setMode(j.LINE_LOOP)
            : wt.setMode(j.LINE_STRIP);
      } else
        Le.isPoints
          ? wt.setMode(j.POINTS)
          : Le.isSprite && wt.setMode(j.TRIANGLES);
      if (Le.isBatchedMesh)
        if (Le._multiDrawInstances !== null)
          wt.renderMultiDrawInstances(
            Le._multiDrawStarts,
            Le._multiDrawCounts,
            Le._multiDrawCount,
            Le._multiDrawInstances
          );
        else if (Ae.get("WEBGL_multi_draw"))
          wt.renderMultiDraw(
            Le._multiDrawStarts,
            Le._multiDrawCounts,
            Le._multiDrawCount
          );
        else {
          const dt = Le._multiDrawStarts,
            Jt = Le._multiDrawCounts,
            zt = Le._multiDrawCount,
            En = Ke ? ve.get(Ke).bytesPerElement : 1,
            ii = De.get(We).currentProgram.getUniforms();
          for (let Rn = 0; Rn < zt; Rn++)
            ii.setValue(j, "_gl_DrawID", Rn), wt.render(dt[Rn] / En, Jt[Rn]);
        }
      else if (Le.isInstancedMesh) wt.renderInstances(tn, pn, Le.count);
      else if (ze.isInstancedBufferGeometry) {
        const dt =
            ze._maxInstanceCount !== void 0 ? ze._maxInstanceCount : 1 / 0,
          Jt = Math.min(ze.instanceCount, dt);
        wt.renderInstances(tn, pn, Jt);
      } else wt.render(tn, pn);
    };
    function Ut(ie, Ce, ze) {
      ie.transparent === !0 && ie.side === Ps && ie.forceSinglePass === !1
        ? ((ie.side = ro),
          (ie.needsUpdate = !0),
          Br(ie, Ce, ze),
          (ie.side = el),
          (ie.needsUpdate = !0),
          Br(ie, Ce, ze),
          (ie.side = Ps))
        : Br(ie, Ce, ze);
    }
    (this.compile = function (ie, Ce, ze = null) {
      ze === null && (ze = ie),
        (_ = Be.get(ze)),
        _.init(Ce),
        T.push(_),
        ze.traverseVisible(function (Le) {
          Le.isLight &&
            Le.layers.test(Ce.layers) &&
            (_.pushLight(Le), Le.castShadow && _.pushShadow(Le));
        }),
        ie !== ze &&
          ie.traverseVisible(function (Le) {
            Le.isLight &&
              Le.layers.test(Ce.layers) &&
              (_.pushLight(Le), Le.castShadow && _.pushShadow(Le));
          }),
        _.setupLights();
      const We = new Set();
      return (
        ie.traverse(function (Le) {
          const ut = Le.material;
          if (ut)
            if (Array.isArray(ut))
              for (let yt = 0; yt < ut.length; yt++) {
                const Et = ut[yt];
                Ut(Et, ze, Le), We.add(Et);
              }
            else Ut(ut, ze, Le), We.add(ut);
        }),
        T.pop(),
        (_ = null),
        We
      );
    }),
      (this.compileAsync = function (ie, Ce, ze = null) {
        const We = this.compile(ie, Ce, ze);
        return new Promise((Le) => {
          function ut() {
            if (
              (We.forEach(function (yt) {
                De.get(yt).currentProgram.isReady() && We.delete(yt);
              }),
              We.size === 0)
            ) {
              Le(ie);
              return;
            }
            setTimeout(ut, 10);
          }
          Ae.get("KHR_parallel_shader_compile") !== null
            ? ut()
            : setTimeout(ut, 10);
        });
      });
    let ht = null;
    function $t(ie) {
      ht && ht(ie);
    }
    function un() {
      yn.stop();
    }
    function bn() {
      yn.start();
    }
    const yn = new MR();
    yn.setAnimationLoop($t),
      typeof self < "u" && yn.setContext(self),
      (this.setAnimationLoop = function (ie) {
        (ht = ie),
          Ve.setAnimationLoop(ie),
          ie === null ? yn.stop() : yn.start();
      }),
      Ve.addEventListener("sessionstart", un),
      Ve.addEventListener("sessionend", bn),
      (this.render = function (ie, Ce) {
        if (Ce !== void 0 && Ce.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (A === !0) return;
        if (
          (ie.matrixWorldAutoUpdate === !0 && ie.updateMatrixWorld(),
          Ce.parent === null &&
            Ce.matrixWorldAutoUpdate === !0 &&
            Ce.updateMatrixWorld(),
          Ve.enabled === !0 &&
            Ve.isPresenting === !0 &&
            (Ve.cameraAutoUpdate === !0 && Ve.updateCamera(Ce),
            (Ce = Ve.getCamera())),
          ie.isScene === !0 && ie.onBeforeRender(M, ie, Ce, P),
          (_ = Be.get(ie, T.length)),
          _.init(Ce),
          T.push(_),
          de.multiplyMatrices(Ce.projectionMatrix, Ce.matrixWorldInverse),
          ae.setFromProjectionMatrix(de),
          (se = this.localClippingEnabled),
          (J = Ge.init(this.clippingPlanes, se)),
          (S = Fe.get(ie, w.length)),
          S.init(),
          w.push(S),
          Ve.enabled === !0 && Ve.isPresenting === !0)
        ) {
          const ut = M.xr.getDepthSensingMesh();
          ut !== null && cr(ut, Ce, -1 / 0, M.sortObjects);
        }
        cr(ie, Ce, 0, M.sortObjects),
          S.finish(),
          M.sortObjects === !0 && S.sort(G, te),
          (ge =
            Ve.enabled === !1 ||
            Ve.isPresenting === !1 ||
            Ve.hasDepthSensing() === !1),
          ge && nt.addToRenderList(S, ie),
          this.info.render.frame++,
          J === !0 && Ge.beginShadows();
        const ze = _.state.shadowsArray;
        Ye.render(ze, ie, Ce),
          J === !0 && Ge.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const We = S.opaque,
          Le = S.transmissive;
        if ((_.setupLights(), Ce.isArrayCamera)) {
          const ut = Ce.cameras;
          if (Le.length > 0)
            for (let yt = 0, Et = ut.length; yt < Et; yt++) {
              const Ke = ut[yt];
              yr(We, Le, ie, Ke);
            }
          ge && nt.render(ie);
          for (let yt = 0, Et = ut.length; yt < Et; yt++) {
            const Ke = ut[yt];
            Hi(S, ie, Ke, Ke.viewport);
          }
        } else
          Le.length > 0 && yr(We, Le, ie, Ce),
            ge && nt.render(ie),
            Hi(S, ie, Ce);
        P !== null &&
          (Xe.updateMultisampleRenderTarget(P), Xe.updateRenderTargetMipmap(P)),
          ie.isScene === !0 && ie.onAfterRender(M, ie, Ce),
          he.resetDefaultState(),
          (U = -1),
          (O = null),
          T.pop(),
          T.length > 0
            ? ((_ = T[T.length - 1]),
              J === !0 && Ge.setGlobalState(M.clippingPlanes, _.state.camera))
            : (_ = null),
          w.pop(),
          w.length > 0 ? (S = w[w.length - 1]) : (S = null);
      });
    function cr(ie, Ce, ze, We) {
      if (ie.visible === !1) return;
      if (ie.layers.test(Ce.layers)) {
        if (ie.isGroup) ze = ie.renderOrder;
        else if (ie.isLOD) ie.autoUpdate === !0 && ie.update(Ce);
        else if (ie.isLight) _.pushLight(ie), ie.castShadow && _.pushShadow(ie);
        else if (ie.isSprite) {
          if (!ie.frustumCulled || ae.intersectsSprite(ie)) {
            We && fe.setFromMatrixPosition(ie.matrixWorld).applyMatrix4(de);
            const yt = _e.update(ie),
              Et = ie.material;
            Et.visible && S.push(ie, yt, Et, ze, fe.z, null);
          }
        } else if (
          (ie.isMesh || ie.isLine || ie.isPoints) &&
          (!ie.frustumCulled || ae.intersectsObject(ie))
        ) {
          const yt = _e.update(ie),
            Et = ie.material;
          if (
            (We &&
              (ie.boundingSphere !== void 0
                ? (ie.boundingSphere === null && ie.computeBoundingSphere(),
                  fe.copy(ie.boundingSphere.center))
                : (yt.boundingSphere === null && yt.computeBoundingSphere(),
                  fe.copy(yt.boundingSphere.center)),
              fe.applyMatrix4(ie.matrixWorld).applyMatrix4(de)),
            Array.isArray(Et))
          ) {
            const Ke = yt.groups;
            for (let kt = 0, Ft = Ke.length; kt < Ft; kt++) {
              const At = Ke[kt],
                tn = Et[At.materialIndex];
              tn && tn.visible && S.push(ie, yt, tn, ze, fe.z, At);
            }
          } else Et.visible && S.push(ie, yt, Et, ze, fe.z, null);
        }
      }
      const ut = ie.children;
      for (let yt = 0, Et = ut.length; yt < Et; yt++) cr(ut[yt], Ce, ze, We);
    }
    function Hi(ie, Ce, ze, We) {
      const Le = ie.opaque,
        ut = ie.transmissive,
        yt = ie.transparent;
      _.setupLightsView(ze),
        J === !0 && Ge.setGlobalState(M.clippingPlanes, ze),
        We && Ie.viewport(L.copy(We)),
        Le.length > 0 && Fr(Le, Ce, ze),
        ut.length > 0 && Fr(ut, Ce, ze),
        yt.length > 0 && Fr(yt, Ce, ze),
        Ie.buffers.depth.setTest(!0),
        Ie.buffers.depth.setMask(!0),
        Ie.buffers.color.setMask(!0),
        Ie.setPolygonOffset(!1);
    }
    function yr(ie, Ce, ze, We) {
      if ((ze.isScene === !0 ? ze.overrideMaterial : null) !== null) return;
      _.state.transmissionRenderTarget[We.id] === void 0 &&
        (_.state.transmissionRenderTarget[We.id] = new ma(1, 1, {
          generateMipmaps: !0,
          type:
            Ae.has("EXT_color_buffer_half_float") ||
            Ae.has("EXT_color_buffer_float")
              ? Wh
              : pa,
          minFilter: Xa,
          samples: 4,
          stencilBuffer: o,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Sn.workingColorSpace,
        }));
      const ut = _.state.transmissionRenderTarget[We.id],
        yt = We.viewport || L;
      ut.setSize(yt.z, yt.w);
      const Et = M.getRenderTarget();
      M.setRenderTarget(ut),
        M.getClearColor($),
        (K = M.getClearAlpha()),
        K < 1 && M.setClearColor(16777215, 0.5),
        M.clear(),
        ge && nt.render(ze);
      const Ke = M.toneMapping;
      M.toneMapping = Za;
      const kt = We.viewport;
      if (
        (We.viewport !== void 0 && (We.viewport = void 0),
        _.setupLightsView(We),
        J === !0 && Ge.setGlobalState(M.clippingPlanes, We),
        Fr(ie, ze, We),
        Xe.updateMultisampleRenderTarget(ut),
        Xe.updateRenderTargetMipmap(ut),
        Ae.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let Ft = !1;
        for (let At = 0, tn = Ce.length; At < tn; At++) {
          const An = Ce[At],
            pn = An.object,
            Mn = An.geometry,
            wt = An.material,
            dt = An.group;
          if (wt.side === Ps && pn.layers.test(We.layers)) {
            const Jt = wt.side;
            (wt.side = ro),
              (wt.needsUpdate = !0),
              Ar(pn, ze, We, Mn, wt, dt),
              (wt.side = Jt),
              (wt.needsUpdate = !0),
              (Ft = !0);
          }
        }
        Ft === !0 &&
          (Xe.updateMultisampleRenderTarget(ut),
          Xe.updateRenderTargetMipmap(ut));
      }
      M.setRenderTarget(Et),
        M.setClearColor($, K),
        kt !== void 0 && (We.viewport = kt),
        (M.toneMapping = Ke);
    }
    function Fr(ie, Ce, ze) {
      const We = Ce.isScene === !0 ? Ce.overrideMaterial : null;
      for (let Le = 0, ut = ie.length; Le < ut; Le++) {
        const yt = ie[Le],
          Et = yt.object,
          Ke = yt.geometry,
          kt = We === null ? yt.material : We,
          Ft = yt.group;
        Et.layers.test(ze.layers) && Ar(Et, Ce, ze, Ke, kt, Ft);
      }
    }
    function Ar(ie, Ce, ze, We, Le, ut) {
      ie.onBeforeRender(M, Ce, ze, We, Le, ut),
        ie.modelViewMatrix.multiplyMatrices(
          ze.matrixWorldInverse,
          ie.matrixWorld
        ),
        ie.normalMatrix.getNormalMatrix(ie.modelViewMatrix),
        Le.transparent === !0 && Le.side === Ps && Le.forceSinglePass === !1
          ? ((Le.side = ro),
            (Le.needsUpdate = !0),
            M.renderBufferDirect(ze, Ce, We, Le, ie, ut),
            (Le.side = el),
            (Le.needsUpdate = !0),
            M.renderBufferDirect(ze, Ce, We, Le, ie, ut),
            (Le.side = Ps))
          : M.renderBufferDirect(ze, Ce, We, Le, ie, ut),
        ie.onAfterRender(M, Ce, ze, We, Le, ut);
    }
    function Br(ie, Ce, ze) {
      Ce.isScene !== !0 && (Ce = Me);
      const We = De.get(ie),
        Le = _.state.lights,
        ut = _.state.shadowsArray,
        yt = Le.state.version,
        Et = Te.getParameters(ie, Le.state, ut, Ce, ze),
        Ke = Te.getProgramCacheKey(Et);
      let kt = We.programs;
      (We.environment = ie.isMeshStandardMaterial ? Ce.environment : null),
        (We.fog = Ce.fog),
        (We.envMap = (ie.isMeshStandardMaterial ? B : ee).get(
          ie.envMap || We.environment
        )),
        (We.envMapRotation =
          We.environment !== null && ie.envMap === null
            ? Ce.environmentRotation
            : ie.envMapRotation),
        kt === void 0 &&
          (ie.addEventListener("dispose", mt),
          (kt = new Map()),
          (We.programs = kt));
      let Ft = kt.get(Ke);
      if (Ft !== void 0) {
        if (We.currentProgram === Ft && We.lightsStateVersion === yt)
          return So(ie, Et), Ft;
      } else
        (Et.uniforms = Te.getUniforms(ie)),
          ie.onBeforeCompile(Et, M),
          (Ft = Te.acquireProgram(Et, Ke)),
          kt.set(Ke, Ft),
          (We.uniforms = Et.uniforms);
      const At = We.uniforms;
      return (
        ((!ie.isShaderMaterial && !ie.isRawShaderMaterial) ||
          ie.clipping === !0) &&
          (At.clippingPlanes = Ge.uniform),
        So(ie, Et),
        (We.needsLights = Kl(ie)),
        (We.lightsStateVersion = yt),
        We.needsLights &&
          ((At.ambientLightColor.value = Le.state.ambient),
          (At.lightProbe.value = Le.state.probe),
          (At.directionalLights.value = Le.state.directional),
          (At.directionalLightShadows.value = Le.state.directionalShadow),
          (At.spotLights.value = Le.state.spot),
          (At.spotLightShadows.value = Le.state.spotShadow),
          (At.rectAreaLights.value = Le.state.rectArea),
          (At.ltc_1.value = Le.state.rectAreaLTC1),
          (At.ltc_2.value = Le.state.rectAreaLTC2),
          (At.pointLights.value = Le.state.point),
          (At.pointLightShadows.value = Le.state.pointShadow),
          (At.hemisphereLights.value = Le.state.hemi),
          (At.directionalShadowMap.value = Le.state.directionalShadowMap),
          (At.directionalShadowMatrix.value = Le.state.directionalShadowMatrix),
          (At.spotShadowMap.value = Le.state.spotShadowMap),
          (At.spotLightMatrix.value = Le.state.spotLightMatrix),
          (At.spotLightMap.value = Le.state.spotLightMap),
          (At.pointShadowMap.value = Le.state.pointShadowMap),
          (At.pointShadowMatrix.value = Le.state.pointShadowMatrix)),
        (We.currentProgram = Ft),
        (We.uniformsList = null),
        Ft
      );
    }
    function xr(ie) {
      if (ie.uniformsList === null) {
        const Ce = ie.currentProgram.getUniforms();
        ie.uniformsList = M0.seqWithValue(Ce.seq, ie.uniforms);
      }
      return ie.uniformsList;
    }
    function So(ie, Ce) {
      const ze = De.get(ie);
      (ze.outputColorSpace = Ce.outputColorSpace),
        (ze.batching = Ce.batching),
        (ze.batchingColor = Ce.batchingColor),
        (ze.instancing = Ce.instancing),
        (ze.instancingColor = Ce.instancingColor),
        (ze.instancingMorph = Ce.instancingMorph),
        (ze.skinning = Ce.skinning),
        (ze.morphTargets = Ce.morphTargets),
        (ze.morphNormals = Ce.morphNormals),
        (ze.morphColors = Ce.morphColors),
        (ze.morphTargetsCount = Ce.morphTargetsCount),
        (ze.numClippingPlanes = Ce.numClippingPlanes),
        (ze.numIntersection = Ce.numClipIntersection),
        (ze.vertexAlphas = Ce.vertexAlphas),
        (ze.vertexTangents = Ce.vertexTangents),
        (ze.toneMapping = Ce.toneMapping);
    }
    function ql(ie, Ce, ze, We, Le) {
      Ce.isScene !== !0 && (Ce = Me), Xe.resetTextureUnits();
      const ut = Ce.fog,
        yt = We.isMeshStandardMaterial ? Ce.environment : null,
        Et =
          P === null
            ? M.outputColorSpace
            : P.isXRRenderTarget === !0
            ? P.texture.colorSpace
            : jl,
        Ke = (We.isMeshStandardMaterial ? B : ee).get(We.envMap || yt),
        kt =
          We.vertexColors === !0 &&
          !!ze.attributes.color &&
          ze.attributes.color.itemSize === 4,
        Ft = !!ze.attributes.tangent && (!!We.normalMap || We.anisotropy > 0),
        At = !!ze.morphAttributes.position,
        tn = !!ze.morphAttributes.normal,
        An = !!ze.morphAttributes.color;
      let pn = Za;
      We.toneMapped &&
        (P === null || P.isXRRenderTarget === !0) &&
        (pn = M.toneMapping);
      const Mn =
          ze.morphAttributes.position ||
          ze.morphAttributes.normal ||
          ze.morphAttributes.color,
        wt = Mn !== void 0 ? Mn.length : 0,
        dt = De.get(We),
        Jt = _.state.lights;
      if (J === !0 && (se === !0 || ie !== O)) {
        const fr = ie === O && We.id === U;
        Ge.setState(We, ie, fr);
      }
      let zt = !1;
      We.version === dt.__version
        ? ((dt.needsLights && dt.lightsStateVersion !== Jt.state.version) ||
            dt.outputColorSpace !== Et ||
            (Le.isBatchedMesh && dt.batching === !1) ||
            (!Le.isBatchedMesh && dt.batching === !0) ||
            (Le.isBatchedMesh &&
              dt.batchingColor === !0 &&
              Le.colorTexture === null) ||
            (Le.isBatchedMesh &&
              dt.batchingColor === !1 &&
              Le.colorTexture !== null) ||
            (Le.isInstancedMesh && dt.instancing === !1) ||
            (!Le.isInstancedMesh && dt.instancing === !0) ||
            (Le.isSkinnedMesh && dt.skinning === !1) ||
            (!Le.isSkinnedMesh && dt.skinning === !0) ||
            (Le.isInstancedMesh &&
              dt.instancingColor === !0 &&
              Le.instanceColor === null) ||
            (Le.isInstancedMesh &&
              dt.instancingColor === !1 &&
              Le.instanceColor !== null) ||
            (Le.isInstancedMesh &&
              dt.instancingMorph === !0 &&
              Le.morphTexture === null) ||
            (Le.isInstancedMesh &&
              dt.instancingMorph === !1 &&
              Le.morphTexture !== null) ||
            dt.envMap !== Ke ||
            (We.fog === !0 && dt.fog !== ut) ||
            (dt.numClippingPlanes !== void 0 &&
              (dt.numClippingPlanes !== Ge.numPlanes ||
                dt.numIntersection !== Ge.numIntersection)) ||
            dt.vertexAlphas !== kt ||
            dt.vertexTangents !== Ft ||
            dt.morphTargets !== At ||
            dt.morphNormals !== tn ||
            dt.morphColors !== An ||
            dt.toneMapping !== pn ||
            dt.morphTargetsCount !== wt) &&
          (zt = !0)
        : ((zt = !0), (dt.__version = We.version));
      let En = dt.currentProgram;
      zt === !0 && (En = Br(We, Ce, Le));
      let ii = !1,
        Rn = !1,
        jn = !1;
      const cn = En.getUniforms(),
        zr = dt.uniforms;
      if (
        (Ie.useProgram(En.program) && ((ii = !0), (Rn = !0), (jn = !0)),
        We.id !== U && ((U = We.id), (Rn = !0)),
        ii || O !== ie)
      ) {
        cn.setValue(j, "projectionMatrix", ie.projectionMatrix),
          cn.setValue(j, "viewMatrix", ie.matrixWorldInverse);
        const fr = cn.map.cameraPosition;
        fr !== void 0 &&
          fr.setValue(j, le.setFromMatrixPosition(ie.matrixWorld)),
          Oe.logarithmicDepthBuffer &&
            cn.setValue(
              j,
              "logDepthBufFC",
              2 / (Math.log(ie.far + 1) / Math.LN2)
            ),
          (We.isMeshPhongMaterial ||
            We.isMeshToonMaterial ||
            We.isMeshLambertMaterial ||
            We.isMeshBasicMaterial ||
            We.isMeshStandardMaterial ||
            We.isShaderMaterial) &&
            cn.setValue(j, "isOrthographic", ie.isOrthographicCamera === !0),
          O !== ie && ((O = ie), (Rn = !0), (jn = !0));
      }
      if (Le.isSkinnedMesh) {
        cn.setOptional(j, Le, "bindMatrix"),
          cn.setOptional(j, Le, "bindMatrixInverse");
        const fr = Le.skeleton;
        fr &&
          (fr.boneTexture === null && fr.computeBoneTexture(),
          cn.setValue(j, "boneTexture", fr.boneTexture, Xe));
      }
      Le.isBatchedMesh &&
        (cn.setOptional(j, Le, "batchingTexture"),
        cn.setValue(j, "batchingTexture", Le._matricesTexture, Xe),
        cn.setOptional(j, Le, "batchingIdTexture"),
        cn.setValue(j, "batchingIdTexture", Le._indirectTexture, Xe),
        cn.setOptional(j, Le, "batchingColorTexture"),
        Le._colorsTexture !== null &&
          cn.setValue(j, "batchingColorTexture", Le._colorsTexture, Xe));
      const ds = ze.morphAttributes;
      if (
        ((ds.position !== void 0 ||
          ds.normal !== void 0 ||
          ds.color !== void 0) &&
          xt.update(Le, ze, En),
        (Rn || dt.receiveShadow !== Le.receiveShadow) &&
          ((dt.receiveShadow = Le.receiveShadow),
          cn.setValue(j, "receiveShadow", Le.receiveShadow)),
        We.isMeshGouraudMaterial &&
          We.envMap !== null &&
          ((zr.envMap.value = Ke),
          (zr.flipEnvMap.value =
            Ke.isCubeTexture && Ke.isRenderTargetTexture === !1 ? -1 : 1)),
        We.isMeshStandardMaterial &&
          We.envMap === null &&
          Ce.environment !== null &&
          (zr.envMapIntensity.value = Ce.environmentIntensity),
        Rn &&
          (cn.setValue(j, "toneMappingExposure", M.toneMappingExposure),
          dt.needsLights && oo(zr, jn),
          ut && We.fog === !0 && at.refreshFogUniforms(zr, ut),
          at.refreshMaterialUniforms(
            zr,
            We,
            re,
            Y,
            _.state.transmissionRenderTarget[ie.id]
          ),
          M0.upload(j, xr(dt), zr, Xe)),
        We.isShaderMaterial &&
          We.uniformsNeedUpdate === !0 &&
          (M0.upload(j, xr(dt), zr, Xe), (We.uniformsNeedUpdate = !1)),
        We.isSpriteMaterial && cn.setValue(j, "center", Le.center),
        cn.setValue(j, "modelViewMatrix", Le.modelViewMatrix),
        cn.setValue(j, "normalMatrix", Le.normalMatrix),
        cn.setValue(j, "modelMatrix", Le.matrixWorld),
        We.isShaderMaterial || We.isRawShaderMaterial)
      ) {
        const fr = We.uniformsGroups;
        for (let Rr = 0, pi = fr.length; Rr < pi; Rr++) {
          const Wo = fr[Rr];
          Je.update(Wo, En), Je.bind(Wo, En);
        }
      }
      return En;
    }
    function oo(ie, Ce) {
      (ie.ambientLightColor.needsUpdate = Ce),
        (ie.lightProbe.needsUpdate = Ce),
        (ie.directionalLights.needsUpdate = Ce),
        (ie.directionalLightShadows.needsUpdate = Ce),
        (ie.pointLights.needsUpdate = Ce),
        (ie.pointLightShadows.needsUpdate = Ce),
        (ie.spotLights.needsUpdate = Ce),
        (ie.spotLightShadows.needsUpdate = Ce),
        (ie.rectAreaLights.needsUpdate = Ce),
        (ie.hemisphereLights.needsUpdate = Ce);
    }
    function Kl(ie) {
      return (
        ie.isMeshLambertMaterial ||
        ie.isMeshToonMaterial ||
        ie.isMeshPhongMaterial ||
        ie.isMeshStandardMaterial ||
        ie.isShadowMaterial ||
        (ie.isShaderMaterial && ie.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return R;
    }),
      (this.getActiveMipmapLevel = function () {
        return D;
      }),
      (this.getRenderTarget = function () {
        return P;
      }),
      (this.setRenderTargetTextures = function (ie, Ce, ze) {
        (De.get(ie.texture).__webglTexture = Ce),
          (De.get(ie.depthTexture).__webglTexture = ze);
        const We = De.get(ie);
        (We.__hasExternalTextures = !0),
          (We.__autoAllocateDepthBuffer = ze === void 0),
          We.__autoAllocateDepthBuffer ||
            (Ae.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (We.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (ie, Ce) {
        const ze = De.get(ie);
        (ze.__webglFramebuffer = Ce),
          (ze.__useDefaultFramebuffer = Ce === void 0);
      }),
      (this.setRenderTarget = function (ie, Ce = 0, ze = 0) {
        (P = ie), (R = Ce), (D = ze);
        let We = !0,
          Le = null,
          ut = !1,
          yt = !1;
        if (ie) {
          const Ke = De.get(ie);
          Ke.__useDefaultFramebuffer !== void 0
            ? (Ie.bindFramebuffer(j.FRAMEBUFFER, null), (We = !1))
            : Ke.__webglFramebuffer === void 0
            ? Xe.setupRenderTarget(ie)
            : Ke.__hasExternalTextures &&
              Xe.rebindTextures(
                ie,
                De.get(ie.texture).__webglTexture,
                De.get(ie.depthTexture).__webglTexture
              );
          const kt = ie.texture;
          (kt.isData3DTexture ||
            kt.isDataArrayTexture ||
            kt.isCompressedArrayTexture) &&
            (yt = !0);
          const Ft = De.get(ie).__webglFramebuffer;
          ie.isWebGLCubeRenderTarget
            ? (Array.isArray(Ft[Ce]) ? (Le = Ft[Ce][ze]) : (Le = Ft[Ce]),
              (ut = !0))
            : ie.samples > 0 && Xe.useMultisampledRTT(ie) === !1
            ? (Le = De.get(ie).__webglMultisampledFramebuffer)
            : Array.isArray(Ft)
            ? (Le = Ft[ze])
            : (Le = Ft),
            L.copy(ie.viewport),
            H.copy(ie.scissor),
            (W = ie.scissorTest);
        } else
          L.copy(F).multiplyScalar(re).floor(),
            H.copy(V).multiplyScalar(re).floor(),
            (W = ne);
        if (
          (Ie.bindFramebuffer(j.FRAMEBUFFER, Le) &&
            We &&
            Ie.drawBuffers(ie, Le),
          Ie.viewport(L),
          Ie.scissor(H),
          Ie.setScissorTest(W),
          ut)
        ) {
          const Ke = De.get(ie.texture);
          j.framebufferTexture2D(
            j.FRAMEBUFFER,
            j.COLOR_ATTACHMENT0,
            j.TEXTURE_CUBE_MAP_POSITIVE_X + Ce,
            Ke.__webglTexture,
            ze
          );
        } else if (yt) {
          const Ke = De.get(ie.texture),
            kt = Ce || 0;
          j.framebufferTextureLayer(
            j.FRAMEBUFFER,
            j.COLOR_ATTACHMENT0,
            Ke.__webglTexture,
            ze || 0,
            kt
          );
        }
        U = -1;
      }),
      (this.readRenderTargetPixels = function (ie, Ce, ze, We, Le, ut, yt) {
        if (!(ie && ie.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Et = De.get(ie).__webglFramebuffer;
        if (
          (ie.isWebGLCubeRenderTarget && yt !== void 0 && (Et = Et[yt]), Et)
        ) {
          Ie.bindFramebuffer(j.FRAMEBUFFER, Et);
          try {
            const Ke = ie.texture,
              kt = Ke.format,
              Ft = Ke.type;
            if (!Oe.textureFormatReadable(kt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!Oe.textureTypeReadable(Ft)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            Ce >= 0 &&
              Ce <= ie.width - We &&
              ze >= 0 &&
              ze <= ie.height - Le &&
              j.readPixels(Ce, ze, We, Le, et.convert(kt), et.convert(Ft), ut);
          } finally {
            const Ke = P !== null ? De.get(P).__webglFramebuffer : null;
            Ie.bindFramebuffer(j.FRAMEBUFFER, Ke);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        ie,
        Ce,
        ze,
        We,
        Le,
        ut,
        yt
      ) {
        if (!(ie && ie.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let Et = De.get(ie).__webglFramebuffer;
        if (
          (ie.isWebGLCubeRenderTarget && yt !== void 0 && (Et = Et[yt]), Et)
        ) {
          Ie.bindFramebuffer(j.FRAMEBUFFER, Et);
          try {
            const Ke = ie.texture,
              kt = Ke.format,
              Ft = Ke.type;
            if (!Oe.textureFormatReadable(kt))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!Oe.textureTypeReadable(Ft))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            if (
              Ce >= 0 &&
              Ce <= ie.width - We &&
              ze >= 0 &&
              ze <= ie.height - Le
            ) {
              const At = j.createBuffer();
              j.bindBuffer(j.PIXEL_PACK_BUFFER, At),
                j.bufferData(j.PIXEL_PACK_BUFFER, ut.byteLength, j.STREAM_READ),
                j.readPixels(Ce, ze, We, Le, et.convert(kt), et.convert(Ft), 0),
                j.flush();
              const tn = j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE, 0);
              await zB(j, tn, 4);
              try {
                j.bindBuffer(j.PIXEL_PACK_BUFFER, At),
                  j.getBufferSubData(j.PIXEL_PACK_BUFFER, 0, ut);
              } finally {
                j.deleteBuffer(At), j.deleteSync(tn);
              }
              return ut;
            }
          } finally {
            const Ke = P !== null ? De.get(P).__webglFramebuffer : null;
            Ie.bindFramebuffer(j.FRAMEBUFFER, Ke);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (ie, Ce = null, ze = 0) {
        ie.isTexture !== !0 &&
          (Mh(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          (Ce = arguments[0] || null),
          (ie = arguments[1]));
        const We = Math.pow(2, -ze),
          Le = Math.floor(ie.image.width * We),
          ut = Math.floor(ie.image.height * We),
          yt = Ce !== null ? Ce.x : 0,
          Et = Ce !== null ? Ce.y : 0;
        Xe.setTexture2D(ie, 0),
          j.copyTexSubImage2D(j.TEXTURE_2D, ze, 0, 0, yt, Et, Le, ut),
          Ie.unbindTexture();
      }),
      (this.copyTextureToTexture = function (
        ie,
        Ce,
        ze = null,
        We = null,
        Le = 0
      ) {
        ie.isTexture !== !0 &&
          (Mh(
            "WebGLRenderer: copyTextureToTexture function signature has changed."
          ),
          (We = arguments[0] || null),
          (ie = arguments[1]),
          (Ce = arguments[2]),
          (Le = arguments[3] || 0),
          (ze = null));
        let ut, yt, Et, Ke, kt, Ft;
        ze !== null
          ? ((ut = ze.max.x - ze.min.x),
            (yt = ze.max.y - ze.min.y),
            (Et = ze.min.x),
            (Ke = ze.min.y))
          : ((ut = ie.image.width), (yt = ie.image.height), (Et = 0), (Ke = 0)),
          We !== null ? ((kt = We.x), (Ft = We.y)) : ((kt = 0), (Ft = 0));
        const At = et.convert(Ce.format),
          tn = et.convert(Ce.type);
        Xe.setTexture2D(Ce, 0),
          j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, Ce.flipY),
          j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ce.premultiplyAlpha),
          j.pixelStorei(j.UNPACK_ALIGNMENT, Ce.unpackAlignment);
        const An = j.getParameter(j.UNPACK_ROW_LENGTH),
          pn = j.getParameter(j.UNPACK_IMAGE_HEIGHT),
          Mn = j.getParameter(j.UNPACK_SKIP_PIXELS),
          wt = j.getParameter(j.UNPACK_SKIP_ROWS),
          dt = j.getParameter(j.UNPACK_SKIP_IMAGES),
          Jt = ie.isCompressedTexture ? ie.mipmaps[Le] : ie.image;
        j.pixelStorei(j.UNPACK_ROW_LENGTH, Jt.width),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, Jt.height),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, Et),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, Ke),
          ie.isDataTexture
            ? j.texSubImage2D(j.TEXTURE_2D, Le, kt, Ft, ut, yt, At, tn, Jt.data)
            : ie.isCompressedTexture
            ? j.compressedTexSubImage2D(
                j.TEXTURE_2D,
                Le,
                kt,
                Ft,
                Jt.width,
                Jt.height,
                At,
                Jt.data
              )
            : j.texSubImage2D(j.TEXTURE_2D, Le, kt, Ft, ut, yt, At, tn, Jt),
          j.pixelStorei(j.UNPACK_ROW_LENGTH, An),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, pn),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, Mn),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, wt),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, dt),
          Le === 0 && Ce.generateMipmaps && j.generateMipmap(j.TEXTURE_2D),
          Ie.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (
        ie,
        Ce,
        ze = null,
        We = null,
        Le = 0
      ) {
        ie.isTexture !== !0 &&
          (Mh(
            "WebGLRenderer: copyTextureToTexture3D function signature has changed."
          ),
          (ze = arguments[0] || null),
          (We = arguments[1] || null),
          (ie = arguments[2]),
          (Ce = arguments[3]),
          (Le = arguments[4] || 0));
        let ut, yt, Et, Ke, kt, Ft, At, tn, An;
        const pn = ie.isCompressedTexture ? ie.mipmaps[Le] : ie.image;
        ze !== null
          ? ((ut = ze.max.x - ze.min.x),
            (yt = ze.max.y - ze.min.y),
            (Et = ze.max.z - ze.min.z),
            (Ke = ze.min.x),
            (kt = ze.min.y),
            (Ft = ze.min.z))
          : ((ut = pn.width),
            (yt = pn.height),
            (Et = pn.depth),
            (Ke = 0),
            (kt = 0),
            (Ft = 0)),
          We !== null
            ? ((At = We.x), (tn = We.y), (An = We.z))
            : ((At = 0), (tn = 0), (An = 0));
        const Mn = et.convert(Ce.format),
          wt = et.convert(Ce.type);
        let dt;
        if (Ce.isData3DTexture) Xe.setTexture3D(Ce, 0), (dt = j.TEXTURE_3D);
        else if (Ce.isDataArrayTexture || Ce.isCompressedArrayTexture)
          Xe.setTexture2DArray(Ce, 0), (dt = j.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, Ce.flipY),
          j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ce.premultiplyAlpha),
          j.pixelStorei(j.UNPACK_ALIGNMENT, Ce.unpackAlignment);
        const Jt = j.getParameter(j.UNPACK_ROW_LENGTH),
          zt = j.getParameter(j.UNPACK_IMAGE_HEIGHT),
          En = j.getParameter(j.UNPACK_SKIP_PIXELS),
          ii = j.getParameter(j.UNPACK_SKIP_ROWS),
          Rn = j.getParameter(j.UNPACK_SKIP_IMAGES);
        j.pixelStorei(j.UNPACK_ROW_LENGTH, pn.width),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, pn.height),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, Ke),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, kt),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, Ft),
          ie.isDataTexture || ie.isData3DTexture
            ? j.texSubImage3D(dt, Le, At, tn, An, ut, yt, Et, Mn, wt, pn.data)
            : Ce.isCompressedArrayTexture
            ? j.compressedTexSubImage3D(
                dt,
                Le,
                At,
                tn,
                An,
                ut,
                yt,
                Et,
                Mn,
                pn.data
              )
            : j.texSubImage3D(dt, Le, At, tn, An, ut, yt, Et, Mn, wt, pn),
          j.pixelStorei(j.UNPACK_ROW_LENGTH, Jt),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, zt),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, En),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, ii),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, Rn),
          Le === 0 && Ce.generateMipmaps && j.generateMipmap(dt),
          Ie.unbindTexture();
      }),
      (this.initRenderTarget = function (ie) {
        De.get(ie).__webglFramebuffer === void 0 && Xe.setupRenderTarget(ie);
      }),
      (this.initTexture = function (ie) {
        ie.isCubeTexture
          ? Xe.setTextureCube(ie, 0)
          : ie.isData3DTexture
          ? Xe.setTexture3D(ie, 0)
          : ie.isDataArrayTexture || ie.isCompressedArrayTexture
          ? Xe.setTexture2DArray(ie, 0)
          : Xe.setTexture2D(ie, 0),
          Ie.unbindTexture();
      }),
      (this.resetState = function () {
        (R = 0), (D = 0), (P = null), Ie.reset(), he.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Ya;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = e === Jy ? "display-p3" : "srgb"),
      (t.unpackColorSpace =
        Sn.workingColorSpace === lg ? "display-p3" : "srgb");
  }
}
class rx {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new St(e)),
      (this.density = t);
  }
  clone() {
    return new rx(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class ix {
  constructor(e, t = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new St(e)),
      (this.near = t),
      (this.far = r);
  }
  clone() {
    return new ix(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
let gy = class extends wn {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new fs()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new fs()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
};
class ox {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Wm),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = us());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      Mh(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.stride), (r *= t.stride);
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = us()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = us()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const vo = new oe();
class as {
  constructor(e, t, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      vo.fromBufferAttribute(this, t),
        vo.applyMatrix4(e),
        this.setXYZ(t, vo.x, vo.y, vo.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      vo.fromBufferAttribute(this, t),
        vo.applyNormalMatrix(e),
        this.setXYZ(t, vo.x, vo.y, vo.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      vo.fromBufferAttribute(this, t),
        vo.transformDirection(e),
        this.setXYZ(t, vo.x, vo.y, vo.z);
    return this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (r = xo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = on(r, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = r),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = xo(t, this.array)), t;
  }
  setXY(e, t, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = on(t, this.array)), (r = on(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = on(t, this.array)),
        (r = on(r, this.array)),
        (i = on(i, this.array)),
        (o = on(o, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return new Gn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new as(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class Fw extends zi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let eh;
const Gp = new oe(),
  th = new oe(),
  nh = new oe(),
  rh = new tt(),
  jp = new tt(),
  LR = new Gt(),
  Bv = new oe(),
  $p = new oe(),
  zv = new oe(),
  pT = new tt(),
  a1 = new tt(),
  mT = new tt();
class DR extends wn {
  constructor(e = new Fw()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), eh === void 0)
    ) {
      eh = new sn();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new ox(t, 5);
      eh.setIndex([0, 1, 2, 0, 2, 3]),
        eh.setAttribute("position", new as(r, 3, 0, !1)),
        eh.setAttribute("uv", new as(r, 2, 3, !1));
    }
    (this.geometry = eh), (this.material = e), (this.center = new tt(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      th.setFromMatrixScale(this.matrixWorld),
      LR.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      nh.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        th.multiplyScalar(-nh.z);
    const r = this.material.rotation;
    let i, o;
    r !== 0 && ((o = Math.cos(r)), (i = Math.sin(r)));
    const s = this.center;
    Hv(Bv.set(-0.5, -0.5, 0), nh, s, th, i, o),
      Hv($p.set(0.5, -0.5, 0), nh, s, th, i, o),
      Hv(zv.set(0.5, 0.5, 0), nh, s, th, i, o),
      pT.set(0, 0),
      a1.set(1, 0),
      mT.set(1, 1);
    let a = e.ray.intersectTriangle(Bv, $p, zv, !1, Gp);
    if (
      a === null &&
      (Hv($p.set(-0.5, 0.5, 0), nh, s, th, i, o),
      a1.set(0, 1),
      (a = e.ray.intersectTriangle(Bv, zv, $p, !1, Gp)),
      a === null)
    )
      return;
    const u = e.ray.origin.distanceTo(Gp);
    u < e.near ||
      u > e.far ||
      t.push({
        distance: u,
        point: Gp.clone(),
        uv: ss.getInterpolation(Gp, Bv, $p, zv, pT, a1, mT, new tt()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Hv(n, e, t, r, i, o) {
  rh.subVectors(n, t).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((jp.x = o * rh.x - i * rh.y), (jp.y = i * rh.x + o * rh.y))
      : jp.copy(rh),
    n.copy(e),
    (n.x += jp.x),
    (n.y += jp.y),
    n.applyMatrix4(LR);
}
const Vv = new oe(),
  gT = new oe();
class kR extends wn {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(t < i[o].distance); o++);
    return (
      i.splice(o, 0, { distance: t, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), e < o)) break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Vv.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(Vv);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Vv.setFromMatrixPosition(e.matrixWorld),
        gT.setFromMatrixPosition(this.matrixWorld);
      const r = Vv.distanceTo(gT) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), r >= s))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < o; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const r = this.levels;
    for (let i = 0, o = r.length; i < o; i++) {
      const s = r[i];
      t.object.levels.push({
        object: s.object.uuid,
        distance: s.distance,
        hysteresis: s.hysteresis,
      });
    }
    return t;
  }
}
const vT = new oe(),
  yT = new dn(),
  xT = new dn(),
  QV = new oe(),
  _T = new Gt(),
  Wv = new oe(),
  l1 = new fi(),
  ST = new Gt(),
  u1 = new Df();
class OR extends ur {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = pS),
      (this.bindMatrix = new Gt()),
      (this.bindMatrixInverse = new Gt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new ci()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, Wv), this.boundingBox.expandByPoint(Wv);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new fi()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, Wv), this.boundingSphere.expandByPoint(Wv);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      l1.copy(this.boundingSphere),
      l1.applyMatrix4(i),
      e.ray.intersectsSphere(l1) !== !1 &&
        (ST.copy(i).invert(),
        u1.copy(e.ray).applyMatrix4(ST),
        !(
          this.boundingBox !== null && u1.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, u1)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new dn(),
      t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0),
        t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === pS
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === nR
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton,
      i = this.geometry;
    yT.fromBufferAttribute(i.attributes.skinIndex, e),
      xT.fromBufferAttribute(i.attributes.skinWeight, e),
      vT.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const s = xT.getComponent(o);
      if (s !== 0) {
        const a = yT.getComponent(o);
        _T.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
          t.addScaledVector(QV.copy(vT).applyMatrix4(_T), s);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Bw extends wn {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Ja extends er {
  constructor(e = null, t = 1, r = 1, i, o, s, a, u, c = wi, d = wi, m, g) {
    super(null, s, a, u, c, d, i, o, m, g),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const wT = new Gt(),
  e8 = new Gt();
class sx {
  constructor(e = [], t = []) {
    (this.uuid = us()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new Gt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Gt();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let o = 0, s = e.length; o < s; o++) {
      const a = e[o] ? e[o].matrixWorld : e8;
      wT.multiplyMatrices(a, t[o]), wT.toArray(r, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new sx(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new Ja(t, e, e, no, Bo);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const o = e.bones[r];
      let s = t[o];
      s === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", o),
        (s = new Bw())),
        this.bones.push(s),
        this.boneInverses.push(new Gt().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      r = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const s = t[i];
      e.bones.push(s.uuid);
      const a = r[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Rf extends Gn {
  constructor(e, t, r, i = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ih = new Gt(),
  bT = new Gt(),
  Gv = [],
  MT = new ci(),
  t8 = new Gt(),
  Xp = new ur(),
  Yp = new fi();
class NR extends ur {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Rf(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, t8);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new ci()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, ih),
        MT.copy(e.boundingBox).applyMatrix4(ih),
        this.boundingBox.union(MT);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new fi()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, ih),
        Yp.copy(e.boundingSphere).applyMatrix4(ih),
        this.boundingSphere.union(Yp);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      o = r.length + 1,
      s = e * o + 1;
    for (let a = 0; a < r.length; a++) r[a] = i[s + a];
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((Xp.geometry = this.geometry),
      (Xp.material = this.material),
      Xp.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Yp.copy(this.boundingSphere),
        Yp.applyMatrix4(r),
        e.ray.intersectsSphere(Yp) !== !1))
    )
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, ih),
          bT.multiplyMatrices(r, ih),
          (Xp.matrixWorld = bT),
          Xp.raycast(e, Gv);
        for (let s = 0, a = Gv.length; s < a; s++) {
          const u = Gv[s];
          (u.instanceId = o), (u.object = this), t.push(u);
        }
        Gv.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Rf(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = r.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Ja(
        new Float32Array(i * this.count),
        i,
        this.count,
        Yy,
        Bo
      ));
    const o = this.morphTexture.source.data.data;
    let s = 0;
    for (let c = 0; c < r.length; c++) s += r[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - s,
      u = i * e;
    (o[u] = a), o.set(r, u + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
function n8(n, e) {
  return n.z - e.z;
}
function r8(n, e) {
  return e.z - n.z;
}
class i8 {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, r) {
    const i = this.pool,
      o = this.list;
    this.index >= i.length &&
      i.push({ start: -1, count: -1, z: -1, index: -1 });
    const s = i[this.index];
    o.push(s),
      this.index++,
      (s.start = e.start),
      (s.count = e.count),
      (s.z = t),
      (s.index = r);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Bu = new Gt(),
  c1 = new Gt(),
  o8 = new Gt(),
  s8 = new St(1, 1, 1),
  ET = new Gt(),
  f1 = new fg(),
  jv = new ci(),
  jc = new fi(),
  qp = new oe(),
  TT = new oe(),
  a8 = new oe(),
  d1 = new i8(),
  Ji = new ur(),
  $v = [];
function l8(n, e, t = 0) {
  const r = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const i = n.count;
    for (let o = 0; o < i; o++)
      for (let s = 0; s < r; s++)
        e.setComponent(o + t, s, n.getComponent(o, s));
  } else e.array.set(n.array, t * r);
  e.needsUpdate = !0;
}
class UR extends ur {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  constructor(e, t, r = t * 2, i) {
    super(new sn(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawInfo = []),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._bounds = []),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = r),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      r = new Ja(t, e, e, no, Bo);
    this._matricesTexture = r;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      r = new Ja(t, e, e, ag, Vl);
    this._indirectTexture = r;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxIndexCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      r = new Ja(t, e, e, no, Bo);
    (r.colorSpace = Sn.workingColorSpace), (this._colorsTexture = r);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      r = this._maxVertexCount,
      i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const s = e.getAttribute(o),
          { array: a, itemSize: u, normalized: c } = s,
          d = new a.constructor(r * u),
          m = new Gn(d, u, c);
        t.setAttribute(o, m);
      }
      if (e.getIndex() !== null) {
        const o = r > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new Gn(o, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in t.attributes) {
      if (!e.hasAttribute(r))
        throw new Error(
          `BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        o = t.getAttribute(r);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ci());
    const e = this._geometryCount,
      t = this.boundingBox,
      r = this._drawInfo;
    t.makeEmpty();
    for (let i = 0; i < e; i++) {
      if (r[i].active === !1) continue;
      const o = r[i].geometryIndex;
      this.getMatrixAt(i, Bu),
        this.getBoundingBoxAt(o, jv).applyMatrix4(Bu),
        t.union(jv);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fi());
    const e = this.boundingSphere,
      t = this._drawInfo;
    e.makeEmpty();
    for (let r = 0, i = t.length; r < i; r++) {
      if (t[r].active === !1) continue;
      const o = t[r].geometryIndex;
      this.getMatrixAt(r, Bu),
        this.getBoundingSphereAt(o, jc).applyMatrix4(Bu),
        e.union(jc);
    }
  }
  addInstance(e) {
    if (this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    this._drawInfo.push({ visible: !0, active: !0, geometryIndex: e });
    const t = this._drawInfo.length - 1,
      r = this._matricesTexture,
      i = r.image.data;
    o8.toArray(i, t * 16), (r.needsUpdate = !0);
    const o = this._colorsTexture;
    return o && (s8.toArray(o.image.data, t * 4), (o.needsUpdate = !0)), t;
  }
  addGeometry(e, t = -1, r = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._drawInfo.length >= this._maxInstanceCount)
    )
      throw new Error("BatchedMesh: Maximum item count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let o = null;
    const s = this._reservedRanges,
      a = this._drawRanges,
      u = this._bounds;
    this._geometryCount !== 0 && (o = s[s.length - 1]),
      t === -1
        ? (i.vertexCount = e.getAttribute("position").count)
        : (i.vertexCount = t),
      o === null
        ? (i.vertexStart = 0)
        : (i.vertexStart = o.vertexStart + o.vertexCount);
    const c = e.getIndex(),
      d = c !== null;
    if (
      (d &&
        (r === -1 ? (i.indexCount = c.count) : (i.indexCount = r),
        o === null
          ? (i.indexStart = 0)
          : (i.indexStart = o.indexStart + o.indexCount)),
      (i.indexStart !== -1 &&
        i.indexStart + i.indexCount > this._maxIndexCount) ||
        i.vertexStart + i.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const m = this._geometryCount;
    return (
      this._geometryCount++,
      s.push(i),
      a.push({ start: d ? i.indexStart : i.vertexStart, count: -1 }),
      u.push({
        boxInitialized: !1,
        box: new ci(),
        sphereInitialized: !1,
        sphere: new fi(),
      }),
      this.setGeometryAt(m, e),
      m
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const r = this.geometry,
      i = r.getIndex() !== null,
      o = r.getIndex(),
      s = t.getIndex(),
      a = this._reservedRanges[e];
    if (
      (i && s.count > a.indexCount) ||
      t.attributes.position.count > a.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const u = a.vertexStart,
      c = a.vertexCount;
    for (const y in r.attributes) {
      const x = t.getAttribute(y),
        S = r.getAttribute(y);
      l8(x, S, u);
      const _ = x.itemSize;
      for (let w = x.count, T = c; w < T; w++) {
        const M = u + w;
        for (let A = 0; A < _; A++) S.setComponent(M, A, 0);
      }
      (S.needsUpdate = !0), S.addUpdateRange(u * _, c * _);
    }
    if (i) {
      const y = a.indexStart;
      for (let x = 0; x < s.count; x++) o.setX(y + x, u + s.getX(x));
      for (let x = s.count, S = a.indexCount; x < S; x++) o.setX(y + x, u);
      (o.needsUpdate = !0), o.addUpdateRange(y, a.indexCount);
    }
    const d = this._bounds[e];
    t.boundingBox !== null
      ? (d.box.copy(t.boundingBox), (d.boxInitialized = !0))
      : (d.boxInitialized = !1),
      t.boundingSphere !== null
        ? (d.sphere.copy(t.boundingSphere), (d.sphereInitialized = !0))
        : (d.sphereInitialized = !1);
    const m = this._drawRanges[e],
      g = t.getAttribute("position");
    return (m.count = i ? s.count : g.count), (this._visibilityChanged = !0), e;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this._bounds[e],
      i = r.box,
      o = this.geometry;
    if (r.boxInitialized === !1) {
      i.makeEmpty();
      const s = o.index,
        a = o.attributes.position,
        u = this._drawRanges[e];
      for (let c = u.start, d = u.start + u.count; c < d; c++) {
        let m = c;
        s && (m = s.getX(m)), i.expandByPoint(qp.fromBufferAttribute(a, m));
      }
      r.boxInitialized = !0;
    }
    return t.copy(i), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this._bounds[e],
      i = r.sphere,
      o = this.geometry;
    if (r.sphereInitialized === !1) {
      i.makeEmpty(), this.getBoundingBoxAt(e, jv), jv.getCenter(i.center);
      const s = o.index,
        a = o.attributes.position,
        u = this._drawRanges[e];
      let c = 0;
      for (let d = u.start, m = u.start + u.count; d < m; d++) {
        let g = d;
        s && (g = s.getX(g)),
          qp.fromBufferAttribute(a, g),
          (c = Math.max(c, i.center.distanceToSquared(qp)));
      }
      (i.radius = Math.sqrt(c)), (r.sphereInitialized = !0);
    }
    return t.copy(i), t;
  }
  setMatrixAt(e, t) {
    const r = this._drawInfo,
      i = this._matricesTexture,
      o = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1
      ? this
      : (t.toArray(o, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    const r = this._drawInfo,
      i = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1 ? null : t.fromArray(i, e * 16);
  }
  setColorAt(e, t) {
    this._colorsTexture === null && this._initColorsTexture();
    const r = this._colorsTexture,
      i = this._colorsTexture.image.data,
      o = this._drawInfo;
    return e >= o.length || o[e].active === !1
      ? this
      : (t.toArray(i, e * 4), (r.needsUpdate = !0), this);
  }
  getColorAt(e, t) {
    const r = this._colorsTexture.image.data,
      i = this._drawInfo;
    return e >= i.length || i[e].active === !1 ? null : t.fromArray(r, e * 4);
  }
  setVisibleAt(e, t) {
    const r = this._drawInfo;
    return e >= r.length || r[e].active === !1 || r[e].visible === t
      ? this
      : ((r[e].visible = t), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const t = this._drawInfo;
    return e >= t.length || t[e].active === !1 ? !1 : t[e].visible;
  }
  raycast(e, t) {
    const r = this._drawInfo,
      i = this._drawRanges,
      o = this.matrixWorld,
      s = this.geometry;
    (Ji.material = this.material),
      (Ji.geometry.index = s.index),
      (Ji.geometry.attributes = s.attributes),
      Ji.geometry.boundingBox === null && (Ji.geometry.boundingBox = new ci()),
      Ji.geometry.boundingSphere === null &&
        (Ji.geometry.boundingSphere = new fi());
    for (let a = 0, u = r.length; a < u; a++) {
      if (!r[a].visible || !r[a].active) continue;
      const c = r[a].geometryIndex,
        d = i[c];
      Ji.geometry.setDrawRange(d.start, d.count),
        this.getMatrixAt(a, Ji.matrixWorld).premultiply(o),
        this.getBoundingBoxAt(c, Ji.geometry.boundingBox),
        this.getBoundingSphereAt(c, Ji.geometry.boundingSphere),
        Ji.raycast(e, $v);
      for (let m = 0, g = $v.length; m < g; m++) {
        const y = $v[m];
        (y.object = this), (y.batchId = a), t.push(y);
      }
      $v.length = 0;
    }
    (Ji.material = null),
      (Ji.geometry.index = null),
      (Ji.geometry.attributes = {}),
      Ji.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
      (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
      (this._drawInfo = e._drawInfo.map((t) => ({ ...t }))),
      (this._bounds = e._bounds.map((t) => ({
        boxInitialized: t.boxInitialized,
        box: t.box.clone(),
        sphereInitialized: t.sphereInitialized,
        sphere: t.sphere.clone(),
      }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, t, r, i, o) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const s = i.getIndex(),
      a = s === null ? 1 : s.array.BYTES_PER_ELEMENT,
      u = this._drawInfo,
      c = this._multiDrawStarts,
      d = this._multiDrawCounts,
      m = this._drawRanges,
      g = this.perObjectFrustumCulled,
      y = this._indirectTexture,
      x = y.image.data;
    g &&
      (ET.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse).multiply(
        this.matrixWorld
      ),
      f1.setFromProjectionMatrix(ET, e.coordinateSystem));
    let S = 0;
    if (this.sortObjects) {
      c1.copy(this.matrixWorld).invert(),
        qp.setFromMatrixPosition(r.matrixWorld).applyMatrix4(c1),
        TT.set(0, 0, -1)
          .transformDirection(r.matrixWorld)
          .transformDirection(c1);
      for (let T = 0, M = u.length; T < M; T++)
        if (u[T].visible && u[T].active) {
          const A = u[T].geometryIndex;
          this.getMatrixAt(T, Bu),
            this.getBoundingSphereAt(A, jc).applyMatrix4(Bu);
          let R = !1;
          if ((g && (R = !f1.intersectsSphere(jc)), !R)) {
            const D = a8.subVectors(jc.center, qp).dot(TT);
            d1.push(m[A], D, T);
          }
        }
      const _ = d1.list,
        w = this.customSort;
      w === null ? _.sort(o.transparent ? r8 : n8) : w.call(this, _, r);
      for (let T = 0, M = _.length; T < M; T++) {
        const A = _[T];
        (c[S] = A.start * a), (d[S] = A.count), (x[S] = A.index), S++;
      }
      d1.reset();
    } else
      for (let _ = 0, w = u.length; _ < w; _++)
        if (u[_].visible && u[_].active) {
          const T = u[_].geometryIndex;
          let M = !1;
          if (
            (g &&
              (this.getMatrixAt(_, Bu),
              this.getBoundingSphereAt(T, jc).applyMatrix4(Bu),
              (M = !f1.intersectsSphere(jc))),
            !M)
          ) {
            const A = m[T];
            (c[S] = A.start * a), (d[S] = A.count), (x[S] = _), S++;
          }
        }
    (y.needsUpdate = !0),
      (this._multiDrawCount = S),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, r, i, o, s) {
    this.onBeforeRender(e, null, i, o, s);
  }
}
class _o extends zi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const vy = new oe(),
  yy = new oe(),
  CT = new Gt(),
  Kp = new Df(),
  Xv = new fi(),
  h1 = new oe(),
  AT = new oe();
let Ju = class extends wn {
  constructor(e = new sn(), t = new _o()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let i = 1, o = t.count; i < o; i++)
        vy.fromBufferAttribute(t, i - 1),
          yy.fromBufferAttribute(t, i),
          (r[i] = r[i - 1]),
          (r[i] += vy.distanceTo(yy));
      e.setAttribute("lineDistance", new Pt(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Line.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Xv.copy(r.boundingSphere),
      Xv.applyMatrix4(i),
      (Xv.radius += o),
      e.ray.intersectsSphere(Xv) === !1)
    )
      return;
    CT.copy(i).invert(), Kp.copy(e.ray).applyMatrix4(CT);
    const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = a * a,
      c = this.isLineSegments ? 2 : 1,
      d = r.index,
      g = r.attributes.position;
    if (d !== null) {
      const y = Math.max(0, s.start),
        x = Math.min(d.count, s.start + s.count);
      for (let S = y, _ = x - 1; S < _; S += c) {
        const w = d.getX(S),
          T = d.getX(S + 1),
          M = Yv(this, e, Kp, u, w, T);
        M && t.push(M);
      }
      if (this.isLineLoop) {
        const S = d.getX(x - 1),
          _ = d.getX(y),
          w = Yv(this, e, Kp, u, S, _);
        w && t.push(w);
      }
    } else {
      const y = Math.max(0, s.start),
        x = Math.min(g.count, s.start + s.count);
      for (let S = y, _ = x - 1; S < _; S += c) {
        const w = Yv(this, e, Kp, u, S, S + 1);
        w && t.push(w);
      }
      if (this.isLineLoop) {
        const S = Yv(this, e, Kp, u, x - 1, y);
        S && t.push(S);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const a = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
};
function Yv(n, e, t, r, i, o) {
  const s = n.geometry.attributes.position;
  if (
    (vy.fromBufferAttribute(s, i),
    yy.fromBufferAttribute(s, o),
    t.distanceSqToSegment(vy, yy, h1, AT) > r)
  )
    return;
  h1.applyMatrix4(n.matrixWorld);
  const u = e.ray.origin.distanceTo(h1);
  if (!(u < e.near || u > e.far))
    return {
      distance: u,
      point: AT.clone().applyMatrix4(n.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: n,
    };
}
const RT = new oe(),
  PT = new oe();
class nl extends Ju {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        RT.fromBufferAttribute(t, i),
          PT.fromBufferAttribute(t, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + RT.distanceTo(PT));
      e.setAttribute("lineDistance", new Pt(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class FR extends Ju {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class zw extends zi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const IT = new Gt(),
  _S = new Df(),
  qv = new fi(),
  Kv = new oe();
class BR extends wn {
  constructor(e = new sn(), t = new zw()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Points.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      qv.copy(r.boundingSphere),
      qv.applyMatrix4(i),
      (qv.radius += o),
      e.ray.intersectsSphere(qv) === !1)
    )
      return;
    IT.copy(i).invert(), _S.copy(e.ray).applyMatrix4(IT);
    const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = a * a,
      c = r.index,
      m = r.attributes.position;
    if (c !== null) {
      const g = Math.max(0, s.start),
        y = Math.min(c.count, s.start + s.count);
      for (let x = g, S = y; x < S; x++) {
        const _ = c.getX(x);
        Kv.fromBufferAttribute(m, _), LT(Kv, _, u, i, e, t, this);
      }
    } else {
      const g = Math.max(0, s.start),
        y = Math.min(m.count, s.start + s.count);
      for (let x = g, S = y; x < S; x++)
        Kv.fromBufferAttribute(m, x), LT(Kv, x, u, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const a = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
}
function LT(n, e, t, r, i, o, s) {
  const a = _S.distanceSqToPoint(n);
  if (a < t) {
    const u = new oe();
    _S.closestPointToPoint(n, u), u.applyMatrix4(r);
    const c = i.ray.origin.distanceTo(u);
    if (c < i.near || c > i.far) return;
    o.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: u,
      index: e,
      face: null,
      object: s,
    });
  }
}
class u8 extends er {
  constructor(e, t, r, i, o, s, a, u, c) {
    super(e, t, r, i, o, s, a, u, c),
      (this.isVideoTexture = !0),
      (this.minFilter = s !== void 0 ? s : Cr),
      (this.magFilter = o !== void 0 ? o : Cr),
      (this.generateMipmaps = !1);
    const d = this;
    function m() {
      (d.needsUpdate = !0), e.requestVideoFrameCallback(m);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(m);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class c8 extends er {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = wi),
      (this.minFilter = wi),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class ax extends er {
  constructor(e, t, r, i, o, s, a, u, c, d, m, g) {
    super(null, s, a, u, c, d, i, o, m, g),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class f8 extends ax {
  constructor(e, t, r, i, o, s) {
    super(e, t, r, o, s),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = Ls),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class d8 extends ax {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, Hl),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class h8 extends er {
  constructor(e, t, r, i, o, s, a, u, c) {
    super(e, t, r, i, o, s, a, u, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class ga {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      i = this.getPoint(0),
      o = 0;
    t.push(0);
    for (let s = 1; s <= e; s++)
      (r = this.getPoint(s / e)), (o += r.distanceTo(i)), t.push(o), (i = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const o = r.length;
    let s;
    t ? (s = t) : (s = e * r[o - 1]);
    let a = 0,
      u = o - 1,
      c;
    for (; a <= u; )
      if (((i = Math.floor(a + (u - a) / 2)), (c = r[i] - s), c < 0)) a = i + 1;
      else if (c > 0) u = i - 1;
      else {
        u = i;
        break;
      }
    if (((i = u), r[i] === s)) return i / (o - 1);
    const d = r[i],
      g = r[i + 1] - d,
      y = (s - d) / g;
    return (i + y) / (o - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const s = this.getPoint(i),
      a = this.getPoint(o),
      u = t || (s.isVector2 ? new tt() : new oe());
    return u.copy(a).sub(s).normalize(), u;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new oe(),
      i = [],
      o = [],
      s = [],
      a = new oe(),
      u = new Gt();
    for (let y = 0; y <= e; y++) {
      const x = y / e;
      i[y] = this.getTangentAt(x, new oe());
    }
    (o[0] = new oe()), (s[0] = new oe());
    let c = Number.MAX_VALUE;
    const d = Math.abs(i[0].x),
      m = Math.abs(i[0].y),
      g = Math.abs(i[0].z);
    d <= c && ((c = d), r.set(1, 0, 0)),
      m <= c && ((c = m), r.set(0, 1, 0)),
      g <= c && r.set(0, 0, 1),
      a.crossVectors(i[0], r).normalize(),
      o[0].crossVectors(i[0], a),
      s[0].crossVectors(i[0], o[0]);
    for (let y = 1; y <= e; y++) {
      if (
        ((o[y] = o[y - 1].clone()),
        (s[y] = s[y - 1].clone()),
        a.crossVectors(i[y - 1], i[y]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const x = Math.acos(Tr(i[y - 1].dot(i[y]), -1, 1));
        o[y].applyMatrix4(u.makeRotationAxis(a, x));
      }
      s[y].crossVectors(i[y], o[y]);
    }
    if (t === !0) {
      let y = Math.acos(Tr(o[0].dot(o[e]), -1, 1));
      (y /= e), i[0].dot(a.crossVectors(o[0], o[e])) > 0 && (y = -y);
      for (let x = 1; x <= e; x++)
        o[x].applyMatrix4(u.makeRotationAxis(i[x], y * x)),
          s[x].crossVectors(i[x], o[x]);
    }
    return { tangents: i, normals: o, binormals: s };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class lx extends ga {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    i = 1,
    o = 0,
    s = Math.PI * 2,
    a = !1,
    u = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = o),
      (this.aEndAngle = s),
      (this.aClockwise = a),
      (this.aRotation = u);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const s = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (s ? (o = 0) : (o = i)),
      this.aClockwise === !0 && !s && (o === i ? (o = -i) : (o = o - i));
    const a = this.aStartAngle + e * o;
    let u = this.aX + this.xRadius * Math.cos(a),
      c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation),
        m = Math.sin(this.aRotation),
        g = u - this.aX,
        y = c - this.aY;
      (u = g * d - y * m + this.aX), (c = g * m + y * d + this.aY);
    }
    return r.set(u, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class zR extends lx {
  constructor(e, t, r, i, o, s) {
    super(e, t, r, r, i, o, s),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function Hw() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function i(o, s, a, u) {
    (n = o),
      (e = a),
      (t = -3 * o + 3 * s - 2 * a - u),
      (r = 2 * o - 2 * s + a + u);
  }
  return {
    initCatmullRom: function (o, s, a, u, c) {
      i(s, a, c * (a - o), c * (u - s));
    },
    initNonuniformCatmullRom: function (o, s, a, u, c, d, m) {
      let g = (s - o) / c - (a - o) / (c + d) + (a - s) / d,
        y = (a - s) / d - (u - s) / (d + m) + (u - a) / m;
      (g *= d), (y *= d), i(s, a, g, y);
    },
    calc: function (o) {
      const s = o * o,
        a = s * o;
      return n + e * o + t * s + r * a;
    },
  };
}
const Zv = new oe(),
  p1 = new Hw(),
  m1 = new Hw(),
  g1 = new Hw();
class HR extends ga {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, t = new oe()) {
    const r = t,
      i = this.points,
      o = i.length,
      s = (o - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(s),
      u = s - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / o) + 1) * o)
      : u === 0 && a === o - 1 && ((a = o - 2), (u = 1));
    let c, d;
    this.closed || a > 0
      ? (c = i[(a - 1) % o])
      : (Zv.subVectors(i[0], i[1]).add(i[0]), (c = Zv));
    const m = i[a % o],
      g = i[(a + 1) % o];
    if (
      (this.closed || a + 2 < o
        ? (d = i[(a + 2) % o])
        : (Zv.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), (d = Zv)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const y = this.curveType === "chordal" ? 0.5 : 0.25;
      let x = Math.pow(c.distanceToSquared(m), y),
        S = Math.pow(m.distanceToSquared(g), y),
        _ = Math.pow(g.distanceToSquared(d), y);
      S < 1e-4 && (S = 1),
        x < 1e-4 && (x = S),
        _ < 1e-4 && (_ = S),
        p1.initNonuniformCatmullRom(c.x, m.x, g.x, d.x, x, S, _),
        m1.initNonuniformCatmullRom(c.y, m.y, g.y, d.y, x, S, _),
        g1.initNonuniformCatmullRom(c.z, m.z, g.z, d.z, x, S, _);
    } else
      this.curveType === "catmullrom" &&
        (p1.initCatmullRom(c.x, m.x, g.x, d.x, this.tension),
        m1.initCatmullRom(c.y, m.y, g.y, d.y, this.tension),
        g1.initCatmullRom(c.z, m.z, g.z, d.z, this.tension));
    return r.set(p1.calc(u), m1.calc(u), g1.calc(u)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new oe().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function DT(n, e, t, r, i) {
  const o = (r - e) * 0.5,
    s = (i - t) * 0.5,
    a = n * n,
    u = n * a;
  return (
    (2 * t - 2 * r + o + s) * u + (-3 * t + 3 * r - 2 * o - s) * a + o * n + t
  );
}
function p8(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function m8(n, e) {
  return 2 * (1 - n) * n * e;
}
function g8(n, e) {
  return n * n * e;
}
function Sm(n, e, t, r) {
  return p8(n, e) + m8(n, t) + g8(n, r);
}
function v8(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function y8(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function x8(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function _8(n, e) {
  return n * n * n * e;
}
function wm(n, e, t, r, i) {
  return v8(n, e) + y8(n, t) + x8(n, r) + _8(n, i);
}
class Vw extends ga {
  constructor(e = new tt(), t = new tt(), r = new tt(), i = new tt()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      a = this.v3;
    return r.set(wm(e, i.x, o.x, s.x, a.x), wm(e, i.y, o.y, s.y, a.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class VR extends ga {
  constructor(e = new oe(), t = new oe(), r = new oe(), i = new oe()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new oe()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      a = this.v3;
    return (
      r.set(
        wm(e, i.x, o.x, s.x, a.x),
        wm(e, i.y, o.y, s.y, a.y),
        wm(e, i.z, o.z, s.z, a.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Ww extends ga {
  constructor(e = new tt(), t = new tt()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new tt()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new tt()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class WR extends ga {
  constructor(e = new oe(), t = new oe()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new oe()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new oe()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class Gw extends ga {
  constructor(e = new tt(), t = new tt(), r = new tt()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return r.set(Sm(e, i.x, o.x, s.x), Sm(e, i.y, o.y, s.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class jw extends ga {
  constructor(e = new oe(), t = new oe(), r = new oe()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new oe()) {
    const r = t,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return (
      r.set(Sm(e, i.x, o.x, s.x), Sm(e, i.y, o.y, s.y), Sm(e, i.z, o.z, s.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class $w extends ga {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new tt()) {
    const r = t,
      i = this.points,
      o = (i.length - 1) * e,
      s = Math.floor(o),
      a = o - s,
      u = i[s === 0 ? s : s - 1],
      c = i[s],
      d = i[s > i.length - 2 ? i.length - 1 : s + 1],
      m = i[s > i.length - 3 ? i.length - 1 : s + 2];
    return r.set(DT(a, u.x, c.x, d.x, m.x), DT(a, u.y, c.y, d.y, m.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new tt().fromArray(i));
    }
    return this;
  }
}
var xy = Object.freeze({
  __proto__: null,
  ArcCurve: zR,
  CatmullRomCurve3: HR,
  CubicBezierCurve: Vw,
  CubicBezierCurve3: VR,
  EllipseCurve: lx,
  LineCurve: Ww,
  LineCurve3: WR,
  QuadraticBezierCurve: Gw,
  QuadraticBezierCurve3: jw,
  SplineCurve: $w,
});
class GR extends ga {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new xy[r](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= r) {
        const s = i[o] - r,
          a = this.curves[o],
          u = a.getLength(),
          c = u === 0 ? 0 : 1 - s / u;
        return a.getPointAt(c, t);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const s = o[i],
        a = s.isEllipseCurve
          ? e * 2
          : s.isLineCurve || s.isLineCurve3
          ? 1
          : s.isSplineCurve
          ? e * s.points.length
          : e,
        u = s.getPoints(a);
      for (let c = 0; c < u.length; c++) {
        const d = u[c];
        (r && r.equals(d)) || (t.push(d), (r = d));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new xy[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Xm extends GR {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new tt()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new Ww(this.currentPoint.clone(), new tt(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const o = new Gw(this.currentPoint.clone(), new tt(e, t), new tt(r, i));
    return this.curves.push(o), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, s) {
    const a = new Vw(
      this.currentPoint.clone(),
      new tt(e, t),
      new tt(r, i),
      new tt(o, s)
    );
    return this.curves.push(a), this.currentPoint.set(o, s), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new $w(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, o, s) {
    const a = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absarc(e + a, t + u, r, i, o, s), this;
  }
  absarc(e, t, r, i, o, s) {
    return this.absellipse(e, t, r, r, i, o, s), this;
  }
  ellipse(e, t, r, i, o, s, a, u) {
    const c = this.currentPoint.x,
      d = this.currentPoint.y;
    return this.absellipse(e + c, t + d, r, i, o, s, a, u), this;
  }
  absellipse(e, t, r, i, o, s, a, u) {
    const c = new lx(e, t, r, i, o, s, a, u);
    if (this.curves.length > 0) {
      const m = c.getPoint(0);
      m.equals(this.currentPoint) || this.lineTo(m.x, m.y);
    }
    this.curves.push(c);
    const d = c.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class dg extends sn {
  constructor(
    e = [new tt(0, -0.5), new tt(0.5, 0), new tt(0, 0.5)],
    t = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }),
      (t = Math.floor(t)),
      (i = Tr(i, 0, Math.PI * 2));
    const o = [],
      s = [],
      a = [],
      u = [],
      c = [],
      d = 1 / t,
      m = new oe(),
      g = new tt(),
      y = new oe(),
      x = new oe(),
      S = new oe();
    let _ = 0,
      w = 0;
    for (let T = 0; T <= e.length - 1; T++)
      switch (T) {
        case 0:
          (_ = e[T + 1].x - e[T].x),
            (w = e[T + 1].y - e[T].y),
            (y.x = w * 1),
            (y.y = -_),
            (y.z = w * 0),
            S.copy(y),
            y.normalize(),
            u.push(y.x, y.y, y.z);
          break;
        case e.length - 1:
          u.push(S.x, S.y, S.z);
          break;
        default:
          (_ = e[T + 1].x - e[T].x),
            (w = e[T + 1].y - e[T].y),
            (y.x = w * 1),
            (y.y = -_),
            (y.z = w * 0),
            x.copy(y),
            (y.x += S.x),
            (y.y += S.y),
            (y.z += S.z),
            y.normalize(),
            u.push(y.x, y.y, y.z),
            S.copy(x);
      }
    for (let T = 0; T <= t; T++) {
      const M = r + T * d * i,
        A = Math.sin(M),
        R = Math.cos(M);
      for (let D = 0; D <= e.length - 1; D++) {
        (m.x = e[D].x * A),
          (m.y = e[D].y),
          (m.z = e[D].x * R),
          s.push(m.x, m.y, m.z),
          (g.x = T / t),
          (g.y = D / (e.length - 1)),
          a.push(g.x, g.y);
        const P = u[3 * D + 0] * A,
          U = u[3 * D + 1],
          O = u[3 * D + 0] * R;
        c.push(P, U, O);
      }
    }
    for (let T = 0; T < t; T++)
      for (let M = 0; M < e.length - 1; M++) {
        const A = M + T * e.length,
          R = A,
          D = A + e.length,
          P = A + e.length + 1,
          U = A + 1;
        o.push(R, D, U), o.push(P, U, D);
      }
    this.setIndex(o),
      this.setAttribute("position", new Pt(s, 3)),
      this.setAttribute("uv", new Pt(a, 2)),
      this.setAttribute("normal", new Pt(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new dg(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class ux extends dg {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const o = new Xm();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      o.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(o.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new ux(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class cx extends sn {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: r,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const o = [],
      s = [],
      a = [],
      u = [],
      c = new oe(),
      d = new tt();
    s.push(0, 0, 0), a.push(0, 0, 1), u.push(0.5, 0.5);
    for (let m = 0, g = 3; m <= t; m++, g += 3) {
      const y = r + (m / t) * i;
      (c.x = e * Math.cos(y)),
        (c.y = e * Math.sin(y)),
        s.push(c.x, c.y, c.z),
        a.push(0, 0, 1),
        (d.x = (s[g] / e + 1) / 2),
        (d.y = (s[g + 1] / e + 1) / 2),
        u.push(d.x, d.y);
    }
    for (let m = 1; m <= t; m++) o.push(m, m + 1, 0);
    this.setIndex(o),
      this.setAttribute("position", new Pt(s, 3)),
      this.setAttribute("normal", new Pt(a, 3)),
      this.setAttribute("uv", new Pt(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new cx(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class jh extends sn {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    i = 32,
    o = 1,
    s = !1,
    a = 0,
    u = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: i,
        heightSegments: o,
        openEnded: s,
        thetaStart: a,
        thetaLength: u,
      });
    const c = this;
    (i = Math.floor(i)), (o = Math.floor(o));
    const d = [],
      m = [],
      g = [],
      y = [];
    let x = 0;
    const S = [],
      _ = r / 2;
    let w = 0;
    T(),
      s === !1 && (e > 0 && M(!0), t > 0 && M(!1)),
      this.setIndex(d),
      this.setAttribute("position", new Pt(m, 3)),
      this.setAttribute("normal", new Pt(g, 3)),
      this.setAttribute("uv", new Pt(y, 2));
    function T() {
      const A = new oe(),
        R = new oe();
      let D = 0;
      const P = (t - e) / r;
      for (let U = 0; U <= o; U++) {
        const O = [],
          L = U / o,
          H = L * (t - e) + e;
        for (let W = 0; W <= i; W++) {
          const $ = W / i,
            K = $ * u + a,
            Z = Math.sin(K),
            Y = Math.cos(K);
          (R.x = H * Z),
            (R.y = -L * r + _),
            (R.z = H * Y),
            m.push(R.x, R.y, R.z),
            A.set(Z, P, Y).normalize(),
            g.push(A.x, A.y, A.z),
            y.push($, 1 - L),
            O.push(x++);
        }
        S.push(O);
      }
      for (let U = 0; U < i; U++)
        for (let O = 0; O < o; O++) {
          const L = S[O][U],
            H = S[O + 1][U],
            W = S[O + 1][U + 1],
            $ = S[O][U + 1];
          d.push(L, H, $), d.push(H, W, $), (D += 6);
        }
      c.addGroup(w, D, 0), (w += D);
    }
    function M(A) {
      const R = x,
        D = new tt(),
        P = new oe();
      let U = 0;
      const O = A === !0 ? e : t,
        L = A === !0 ? 1 : -1;
      for (let W = 1; W <= i; W++)
        m.push(0, _ * L, 0), g.push(0, L, 0), y.push(0.5, 0.5), x++;
      const H = x;
      for (let W = 0; W <= i; W++) {
        const K = (W / i) * u + a,
          Z = Math.cos(K),
          Y = Math.sin(K);
        (P.x = O * Y),
          (P.y = _ * L),
          (P.z = O * Z),
          m.push(P.x, P.y, P.z),
          g.push(0, L, 0),
          (D.x = Z * 0.5 + 0.5),
          (D.y = Y * 0.5 * L + 0.5),
          y.push(D.x, D.y),
          x++;
      }
      for (let W = 0; W < i; W++) {
        const $ = R + W,
          K = H + W;
        A === !0 ? d.push(K, K + 1, $) : d.push(K + 1, K, $), (U += 3);
      }
      c.addGroup(w, U, A === !0 ? 1 : 2), (w += U);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new jh(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class fx extends jh {
  constructor(e = 1, t = 1, r = 32, i = 1, o = !1, s = 0, a = Math.PI * 2) {
    super(0, e, t, r, i, o, s, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: i,
        openEnded: o,
        thetaStart: s,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new fx(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class tc extends sn {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: i });
    const o = [],
      s = [];
    a(i),
      c(r),
      d(),
      this.setAttribute("position", new Pt(o, 3)),
      this.setAttribute("normal", new Pt(o.slice(), 3)),
      this.setAttribute("uv", new Pt(s, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(T) {
      const M = new oe(),
        A = new oe(),
        R = new oe();
      for (let D = 0; D < t.length; D += 3)
        y(t[D + 0], M), y(t[D + 1], A), y(t[D + 2], R), u(M, A, R, T);
    }
    function u(T, M, A, R) {
      const D = R + 1,
        P = [];
      for (let U = 0; U <= D; U++) {
        P[U] = [];
        const O = T.clone().lerp(A, U / D),
          L = M.clone().lerp(A, U / D),
          H = D - U;
        for (let W = 0; W <= H; W++)
          W === 0 && U === D
            ? (P[U][W] = O)
            : (P[U][W] = O.clone().lerp(L, W / H));
      }
      for (let U = 0; U < D; U++)
        for (let O = 0; O < 2 * (D - U) - 1; O++) {
          const L = Math.floor(O / 2);
          O % 2 === 0
            ? (g(P[U][L + 1]), g(P[U + 1][L]), g(P[U][L]))
            : (g(P[U][L + 1]), g(P[U + 1][L + 1]), g(P[U + 1][L]));
        }
    }
    function c(T) {
      const M = new oe();
      for (let A = 0; A < o.length; A += 3)
        (M.x = o[A + 0]),
          (M.y = o[A + 1]),
          (M.z = o[A + 2]),
          M.normalize().multiplyScalar(T),
          (o[A + 0] = M.x),
          (o[A + 1] = M.y),
          (o[A + 2] = M.z);
    }
    function d() {
      const T = new oe();
      for (let M = 0; M < o.length; M += 3) {
        (T.x = o[M + 0]), (T.y = o[M + 1]), (T.z = o[M + 2]);
        const A = _(T) / 2 / Math.PI + 0.5,
          R = w(T) / Math.PI + 0.5;
        s.push(A, 1 - R);
      }
      x(), m();
    }
    function m() {
      for (let T = 0; T < s.length; T += 6) {
        const M = s[T + 0],
          A = s[T + 2],
          R = s[T + 4],
          D = Math.max(M, A, R),
          P = Math.min(M, A, R);
        D > 0.9 &&
          P < 0.1 &&
          (M < 0.2 && (s[T + 0] += 1),
          A < 0.2 && (s[T + 2] += 1),
          R < 0.2 && (s[T + 4] += 1));
      }
    }
    function g(T) {
      o.push(T.x, T.y, T.z);
    }
    function y(T, M) {
      const A = T * 3;
      (M.x = e[A + 0]), (M.y = e[A + 1]), (M.z = e[A + 2]);
    }
    function x() {
      const T = new oe(),
        M = new oe(),
        A = new oe(),
        R = new oe(),
        D = new tt(),
        P = new tt(),
        U = new tt();
      for (let O = 0, L = 0; O < o.length; O += 9, L += 6) {
        T.set(o[O + 0], o[O + 1], o[O + 2]),
          M.set(o[O + 3], o[O + 4], o[O + 5]),
          A.set(o[O + 6], o[O + 7], o[O + 8]),
          D.set(s[L + 0], s[L + 1]),
          P.set(s[L + 2], s[L + 3]),
          U.set(s[L + 4], s[L + 5]),
          R.copy(T).add(M).add(A).divideScalar(3);
        const H = _(R);
        S(D, L + 0, T, H), S(P, L + 2, M, H), S(U, L + 4, A, H);
      }
    }
    function S(T, M, A, R) {
      R < 0 && T.x === 1 && (s[M] = T.x - 1),
        A.x === 0 && A.z === 0 && (s[M] = R / 2 / Math.PI + 0.5);
    }
    function _(T) {
      return Math.atan2(T.z, -T.x);
    }
    function w(T) {
      return Math.atan2(-T.y, Math.sqrt(T.x * T.x + T.z * T.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new tc(e.vertices, e.indices, e.radius, e.details);
  }
}
class dx extends tc {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      o = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      s = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(o, s, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new dx(e.radius, e.detail);
  }
}
const Jv = new oe(),
  Qv = new oe(),
  v1 = new oe(),
  e0 = new ss();
class jR extends sn {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        o = Math.cos(_f * t),
        s = e.getIndex(),
        a = e.getAttribute("position"),
        u = s ? s.count : a.count,
        c = [0, 0, 0],
        d = ["a", "b", "c"],
        m = new Array(3),
        g = {},
        y = [];
      for (let x = 0; x < u; x += 3) {
        s
          ? ((c[0] = s.getX(x)), (c[1] = s.getX(x + 1)), (c[2] = s.getX(x + 2)))
          : ((c[0] = x), (c[1] = x + 1), (c[2] = x + 2));
        const { a: S, b: _, c: w } = e0;
        if (
          (S.fromBufferAttribute(a, c[0]),
          _.fromBufferAttribute(a, c[1]),
          w.fromBufferAttribute(a, c[2]),
          e0.getNormal(v1),
          (m[0] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${Math.round(
            S.z * i
          )}`),
          (m[1] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(
            _.z * i
          )}`),
          (m[2] = `${Math.round(w.x * i)},${Math.round(w.y * i)},${Math.round(
            w.z * i
          )}`),
          !(m[0] === m[1] || m[1] === m[2] || m[2] === m[0]))
        )
          for (let T = 0; T < 3; T++) {
            const M = (T + 1) % 3,
              A = m[T],
              R = m[M],
              D = e0[d[T]],
              P = e0[d[M]],
              U = `${A}_${R}`,
              O = `${R}_${A}`;
            O in g && g[O]
              ? (v1.dot(g[O].normal) <= o &&
                  (y.push(D.x, D.y, D.z), y.push(P.x, P.y, P.z)),
                (g[O] = null))
              : U in g ||
                (g[U] = { index0: c[T], index1: c[M], normal: v1.clone() });
          }
      }
      for (const x in g)
        if (g[x]) {
          const { index0: S, index1: _ } = g[x];
          Jv.fromBufferAttribute(a, S),
            Qv.fromBufferAttribute(a, _),
            y.push(Jv.x, Jv.y, Jv.z),
            y.push(Qv.x, Qv.y, Qv.z);
        }
      this.setAttribute("position", new Pt(y, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class wf extends Xm {
  constructor(e) {
    super(e), (this.uuid = us()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new Xm().fromJSON(i));
    }
    return this;
  }
}
const S8 = {
  triangulate: function (n, e, t = 2) {
    const r = e && e.length,
      i = r ? e[0] * t : n.length;
    let o = $R(n, 0, i, t, !0);
    const s = [];
    if (!o || o.next === o.prev) return s;
    let a, u, c, d, m, g, y;
    if ((r && (o = T8(n, e, o, t)), n.length > 80 * t)) {
      (a = c = n[0]), (u = d = n[1]);
      for (let x = t; x < i; x += t)
        (m = n[x]),
          (g = n[x + 1]),
          m < a && (a = m),
          g < u && (u = g),
          m > c && (c = m),
          g > d && (d = g);
      (y = Math.max(c - a, d - u)), (y = y !== 0 ? 32767 / y : 0);
    }
    return Ym(o, s, t, a, u, y, 0), s;
  },
};
function $R(n, e, t, r, i) {
  let o, s;
  if (i === U8(n, e, t, r) > 0)
    for (o = e; o < t; o += r) s = kT(o, n[o], n[o + 1], s);
  else for (o = t - r; o >= e; o -= r) s = kT(o, n[o], n[o + 1], s);
  return s && hx(s, s.next) && (Km(s), (s = s.next)), s;
}
function Pf(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1), !t.steiner && (hx(t, t.next) || vr(t.prev, t, t.next) === 0))
    ) {
      if ((Km(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function Ym(n, e, t, r, i, o, s) {
  if (!n) return;
  !s && o && I8(n, r, i, o);
  let a = n,
    u,
    c;
  for (; n.prev !== n.next; ) {
    if (((u = n.prev), (c = n.next), o ? b8(n, r, i, o) : w8(n))) {
      e.push((u.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((c.i / t) | 0),
        Km(n),
        (n = c.next),
        (a = c.next);
      continue;
    }
    if (((n = c), n === a)) {
      s
        ? s === 1
          ? ((n = M8(Pf(n), e, t)), Ym(n, e, t, r, i, o, 2))
          : s === 2 && E8(n, e, t, r, i, o)
        : Ym(Pf(n), e, t, r, i, o, 1);
      break;
    }
  }
}
function w8(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (vr(e, t, r) >= 0) return !1;
  const i = e.x,
    o = t.x,
    s = r.x,
    a = e.y,
    u = t.y,
    c = r.y,
    d = i < o ? (i < s ? i : s) : o < s ? o : s,
    m = a < u ? (a < c ? a : c) : u < c ? u : c,
    g = i > o ? (i > s ? i : s) : o > s ? o : s,
    y = a > u ? (a > c ? a : c) : u > c ? u : c;
  let x = r.next;
  for (; x !== e; ) {
    if (
      x.x >= d &&
      x.x <= g &&
      x.y >= m &&
      x.y <= y &&
      yh(i, a, o, u, s, c, x.x, x.y) &&
      vr(x.prev, x, x.next) >= 0
    )
      return !1;
    x = x.next;
  }
  return !0;
}
function b8(n, e, t, r) {
  const i = n.prev,
    o = n,
    s = n.next;
  if (vr(i, o, s) >= 0) return !1;
  const a = i.x,
    u = o.x,
    c = s.x,
    d = i.y,
    m = o.y,
    g = s.y,
    y = a < u ? (a < c ? a : c) : u < c ? u : c,
    x = d < m ? (d < g ? d : g) : m < g ? m : g,
    S = a > u ? (a > c ? a : c) : u > c ? u : c,
    _ = d > m ? (d > g ? d : g) : m > g ? m : g,
    w = SS(y, x, e, t, r),
    T = SS(S, _, e, t, r);
  let M = n.prevZ,
    A = n.nextZ;
  for (; M && M.z >= w && A && A.z <= T; ) {
    if (
      (M.x >= y &&
        M.x <= S &&
        M.y >= x &&
        M.y <= _ &&
        M !== i &&
        M !== s &&
        yh(a, d, u, m, c, g, M.x, M.y) &&
        vr(M.prev, M, M.next) >= 0) ||
      ((M = M.prevZ),
      A.x >= y &&
        A.x <= S &&
        A.y >= x &&
        A.y <= _ &&
        A !== i &&
        A !== s &&
        yh(a, d, u, m, c, g, A.x, A.y) &&
        vr(A.prev, A, A.next) >= 0)
    )
      return !1;
    A = A.nextZ;
  }
  for (; M && M.z >= w; ) {
    if (
      M.x >= y &&
      M.x <= S &&
      M.y >= x &&
      M.y <= _ &&
      M !== i &&
      M !== s &&
      yh(a, d, u, m, c, g, M.x, M.y) &&
      vr(M.prev, M, M.next) >= 0
    )
      return !1;
    M = M.prevZ;
  }
  for (; A && A.z <= T; ) {
    if (
      A.x >= y &&
      A.x <= S &&
      A.y >= x &&
      A.y <= _ &&
      A !== i &&
      A !== s &&
      yh(a, d, u, m, c, g, A.x, A.y) &&
      vr(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.nextZ;
  }
  return !0;
}
function M8(n, e, t) {
  let r = n;
  do {
    const i = r.prev,
      o = r.next.next;
    !hx(i, o) &&
      XR(i, r, r.next, o) &&
      qm(i, o) &&
      qm(o, i) &&
      (e.push((i.i / t) | 0),
      e.push((r.i / t) | 0),
      e.push((o.i / t) | 0),
      Km(r),
      Km(r.next),
      (r = n = o)),
      (r = r.next);
  } while (r !== n);
  return Pf(r);
}
function E8(n, e, t, r, i, o) {
  let s = n;
  do {
    let a = s.next.next;
    for (; a !== s.prev; ) {
      if (s.i !== a.i && k8(s, a)) {
        let u = YR(s, a);
        (s = Pf(s, s.next)),
          (u = Pf(u, u.next)),
          Ym(s, e, t, r, i, o, 0),
          Ym(u, e, t, r, i, o, 0);
        return;
      }
      a = a.next;
    }
    s = s.next;
  } while (s !== n);
}
function T8(n, e, t, r) {
  const i = [];
  let o, s, a, u, c;
  for (o = 0, s = e.length; o < s; o++)
    (a = e[o] * r),
      (u = o < s - 1 ? e[o + 1] * r : n.length),
      (c = $R(n, a, u, r, !1)),
      c === c.next && (c.steiner = !0),
      i.push(D8(c));
  for (i.sort(C8), o = 0; o < i.length; o++) t = A8(i[o], t);
  return t;
}
function C8(n, e) {
  return n.x - e.x;
}
function A8(n, e) {
  const t = R8(n, e);
  if (!t) return e;
  const r = YR(t, n);
  return Pf(r, r.next), Pf(t, t.next);
}
function R8(n, e) {
  let t = e,
    r = -1 / 0,
    i;
  const o = n.x,
    s = n.y;
  do {
    if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
      const g = t.x + ((s - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        g <= o &&
        g > r &&
        ((r = g), (i = t.x < t.next.x ? t : t.next), g === o)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const a = i,
    u = i.x,
    c = i.y;
  let d = 1 / 0,
    m;
  t = i;
  do
    o >= t.x &&
      t.x >= u &&
      o !== t.x &&
      yh(s < c ? o : r, s, u, c, s < c ? r : o, s, t.x, t.y) &&
      ((m = Math.abs(s - t.y) / (o - t.x)),
      qm(t, n) &&
        (m < d || (m === d && (t.x > i.x || (t.x === i.x && P8(i, t))))) &&
        ((i = t), (d = m))),
      (t = t.next);
  while (t !== a);
  return i;
}
function P8(n, e) {
  return vr(n.prev, n, e.prev) < 0 && vr(e.next, n, n.next) < 0;
}
function I8(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = SS(i.x, i.y, e, t, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== n);
  (i.prevZ.nextZ = null), (i.prevZ = null), L8(i);
}
function L8(n) {
  let e,
    t,
    r,
    i,
    o,
    s,
    a,
    u,
    c = 1;
  do {
    for (t = n, n = null, o = null, s = 0; t; ) {
      for (s++, r = t, a = 0, e = 0; e < c && (a++, (r = r.nextZ), !!r); e++);
      for (u = c; a > 0 || (u > 0 && r); )
        a !== 0 && (u === 0 || !r || t.z <= r.z)
          ? ((i = t), (t = t.nextZ), a--)
          : ((i = r), (r = r.nextZ), u--),
          o ? (o.nextZ = i) : (n = i),
          (i.prevZ = o),
          (o = i);
      t = r;
    }
    (o.nextZ = null), (c *= 2);
  } while (s > 1);
  return n;
}
function SS(n, e, t, r, i) {
  return (
    (n = ((n - t) * i) | 0),
    (e = ((e - r) * i) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function D8(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function yh(n, e, t, r, i, o, s, a) {
  return (
    (i - s) * (e - a) >= (n - s) * (o - a) &&
    (n - s) * (r - a) >= (t - s) * (e - a) &&
    (t - s) * (o - a) >= (i - s) * (r - a)
  );
}
function k8(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !O8(n, e) &&
    ((qm(n, e) &&
      qm(e, n) &&
      N8(n, e) &&
      (vr(n.prev, n, e.prev) || vr(n, e.prev, e))) ||
      (hx(n, e) && vr(n.prev, n, n.next) > 0 && vr(e.prev, e, e.next) > 0))
  );
}
function vr(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function hx(n, e) {
  return n.x === e.x && n.y === e.y;
}
function XR(n, e, t, r) {
  const i = n0(vr(n, e, t)),
    o = n0(vr(n, e, r)),
    s = n0(vr(t, r, n)),
    a = n0(vr(t, r, e));
  return !!(
    (i !== o && s !== a) ||
    (i === 0 && t0(n, t, e)) ||
    (o === 0 && t0(n, r, e)) ||
    (s === 0 && t0(t, n, r)) ||
    (a === 0 && t0(t, e, r))
  );
}
function t0(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function n0(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function O8(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      XR(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function qm(n, e) {
  return vr(n.prev, n, n.next) < 0
    ? vr(n, e, n.next) >= 0 && vr(n, n.prev, e) >= 0
    : vr(n, e, n.prev) < 0 || vr(n, n.next, e) < 0;
}
function N8(n, e) {
  let t = n,
    r = !1;
  const i = (n.x + e.x) / 2,
    o = (n.y + e.y) / 2;
  do
    t.y > o != t.next.y > o &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (o - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function YR(n, e) {
  const t = new wS(n.i, n.x, n.y),
    r = new wS(e.i, e.x, e.y),
    i = n.next,
    o = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = i),
    (i.prev = t),
    (r.next = t),
    (t.prev = r),
    (o.next = r),
    (r.prev = o),
    r
  );
}
function kT(n, e, t, r) {
  const i = new wS(n, e, t);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Km(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function wS(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function U8(n, e, t, r) {
  let i = 0;
  for (let o = e, s = t - r; o < t; o += r)
    (i += (n[s] - n[o]) * (n[o + 1] + n[s + 1])), (s = o);
  return i;
}
class Qa {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, o = 0; o < t; i = o++)
      r += e[i].x * e[o].y - e[o].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Qa.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      i = [],
      o = [];
    OT(e), NT(r, e);
    let s = e.length;
    t.forEach(OT);
    for (let u = 0; u < t.length; u++)
      i.push(s), (s += t[u].length), NT(r, t[u]);
    const a = S8.triangulate(r, i);
    for (let u = 0; u < a.length; u += 3) o.push(a.slice(u, u + 3));
    return o;
  }
}
function OT(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function NT(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class px extends sn {
  constructor(
    e = new wf([
      new tt(0.5, 0.5),
      new tt(-0.5, 0.5),
      new tt(-0.5, -0.5),
      new tt(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      o = [];
    for (let a = 0, u = e.length; a < u; a++) {
      const c = e[a];
      s(c);
    }
    this.setAttribute("position", new Pt(i, 3)),
      this.setAttribute("uv", new Pt(o, 2)),
      this.computeVertexNormals();
    function s(a) {
      const u = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        d = t.steps !== void 0 ? t.steps : 1,
        m = t.depth !== void 0 ? t.depth : 1;
      let g = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        y = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        x = t.bevelSize !== void 0 ? t.bevelSize : y - 0.1,
        S = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        _ = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const w = t.extrudePath,
        T = t.UVGenerator !== void 0 ? t.UVGenerator : F8;
      let M,
        A = !1,
        R,
        D,
        P,
        U;
      w &&
        ((M = w.getSpacedPoints(d)),
        (A = !0),
        (g = !1),
        (R = w.computeFrenetFrames(d, !1)),
        (D = new oe()),
        (P = new oe()),
        (U = new oe())),
        g || ((_ = 0), (y = 0), (x = 0), (S = 0));
      const O = a.extractPoints(c);
      let L = O.shape;
      const H = O.holes;
      if (!Qa.isClockWise(L)) {
        L = L.reverse();
        for (let j = 0, we = H.length; j < we; j++) {
          const Ae = H[j];
          Qa.isClockWise(Ae) && (H[j] = Ae.reverse());
        }
      }
      const $ = Qa.triangulateShape(L, H),
        K = L;
      for (let j = 0, we = H.length; j < we; j++) {
        const Ae = H[j];
        L = L.concat(Ae);
      }
      function Z(j, we, Ae) {
        return (
          we || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          j.clone().addScaledVector(we, Ae)
        );
      }
      const Y = L.length,
        re = $.length;
      function G(j, we, Ae) {
        let Oe, Ie, rt;
        const De = j.x - we.x,
          Xe = j.y - we.y,
          ee = Ae.x - j.x,
          B = Ae.y - j.y,
          ve = De * De + Xe * Xe,
          Se = De * B - Xe * ee;
        if (Math.abs(Se) > Number.EPSILON) {
          const _e = Math.sqrt(ve),
            Te = Math.sqrt(ee * ee + B * B),
            at = we.x - Xe / _e,
            Fe = we.y + De / _e,
            Be = Ae.x - B / Te,
            Ge = Ae.y + ee / Te,
            Ye = ((Be - at) * B - (Ge - Fe) * ee) / (De * B - Xe * ee);
          (Oe = at + De * Ye - j.x), (Ie = Fe + Xe * Ye - j.y);
          const nt = Oe * Oe + Ie * Ie;
          if (nt <= 2) return new tt(Oe, Ie);
          rt = Math.sqrt(nt / 2);
        } else {
          let _e = !1;
          De > Number.EPSILON
            ? ee > Number.EPSILON && (_e = !0)
            : De < -Number.EPSILON
            ? ee < -Number.EPSILON && (_e = !0)
            : Math.sign(Xe) === Math.sign(B) && (_e = !0),
            _e
              ? ((Oe = -Xe), (Ie = De), (rt = Math.sqrt(ve)))
              : ((Oe = De), (Ie = Xe), (rt = Math.sqrt(ve / 2)));
        }
        return new tt(Oe / rt, Ie / rt);
      }
      const te = [];
      for (
        let j = 0, we = K.length, Ae = we - 1, Oe = j + 1;
        j < we;
        j++, Ae++, Oe++
      )
        Ae === we && (Ae = 0),
          Oe === we && (Oe = 0),
          (te[j] = G(K[j], K[Ae], K[Oe]));
      const F = [];
      let V,
        ne = te.concat();
      for (let j = 0, we = H.length; j < we; j++) {
        const Ae = H[j];
        V = [];
        for (
          let Oe = 0, Ie = Ae.length, rt = Ie - 1, De = Oe + 1;
          Oe < Ie;
          Oe++, rt++, De++
        )
          rt === Ie && (rt = 0),
            De === Ie && (De = 0),
            (V[Oe] = G(Ae[Oe], Ae[rt], Ae[De]));
        F.push(V), (ne = ne.concat(V));
      }
      for (let j = 0; j < _; j++) {
        const we = j / _,
          Ae = y * Math.cos((we * Math.PI) / 2),
          Oe = x * Math.sin((we * Math.PI) / 2) + S;
        for (let Ie = 0, rt = K.length; Ie < rt; Ie++) {
          const De = Z(K[Ie], te[Ie], Oe);
          le(De.x, De.y, -Ae);
        }
        for (let Ie = 0, rt = H.length; Ie < rt; Ie++) {
          const De = H[Ie];
          V = F[Ie];
          for (let Xe = 0, ee = De.length; Xe < ee; Xe++) {
            const B = Z(De[Xe], V[Xe], Oe);
            le(B.x, B.y, -Ae);
          }
        }
      }
      const ae = x + S;
      for (let j = 0; j < Y; j++) {
        const we = g ? Z(L[j], ne[j], ae) : L[j];
        A
          ? (P.copy(R.normals[0]).multiplyScalar(we.x),
            D.copy(R.binormals[0]).multiplyScalar(we.y),
            U.copy(M[0]).add(P).add(D),
            le(U.x, U.y, U.z))
          : le(we.x, we.y, 0);
      }
      for (let j = 1; j <= d; j++)
        for (let we = 0; we < Y; we++) {
          const Ae = g ? Z(L[we], ne[we], ae) : L[we];
          A
            ? (P.copy(R.normals[j]).multiplyScalar(Ae.x),
              D.copy(R.binormals[j]).multiplyScalar(Ae.y),
              U.copy(M[j]).add(P).add(D),
              le(U.x, U.y, U.z))
            : le(Ae.x, Ae.y, (m / d) * j);
        }
      for (let j = _ - 1; j >= 0; j--) {
        const we = j / _,
          Ae = y * Math.cos((we * Math.PI) / 2),
          Oe = x * Math.sin((we * Math.PI) / 2) + S;
        for (let Ie = 0, rt = K.length; Ie < rt; Ie++) {
          const De = Z(K[Ie], te[Ie], Oe);
          le(De.x, De.y, m + Ae);
        }
        for (let Ie = 0, rt = H.length; Ie < rt; Ie++) {
          const De = H[Ie];
          V = F[Ie];
          for (let Xe = 0, ee = De.length; Xe < ee; Xe++) {
            const B = Z(De[Xe], V[Xe], Oe);
            A
              ? le(B.x, B.y + M[d - 1].y, M[d - 1].x + Ae)
              : le(B.x, B.y, m + Ae);
          }
        }
      }
      J(), se();
      function J() {
        const j = i.length / 3;
        if (g) {
          let we = 0,
            Ae = Y * we;
          for (let Oe = 0; Oe < re; Oe++) {
            const Ie = $[Oe];
            fe(Ie[2] + Ae, Ie[1] + Ae, Ie[0] + Ae);
          }
          (we = d + _ * 2), (Ae = Y * we);
          for (let Oe = 0; Oe < re; Oe++) {
            const Ie = $[Oe];
            fe(Ie[0] + Ae, Ie[1] + Ae, Ie[2] + Ae);
          }
        } else {
          for (let we = 0; we < re; we++) {
            const Ae = $[we];
            fe(Ae[2], Ae[1], Ae[0]);
          }
          for (let we = 0; we < re; we++) {
            const Ae = $[we];
            fe(Ae[0] + Y * d, Ae[1] + Y * d, Ae[2] + Y * d);
          }
        }
        r.addGroup(j, i.length / 3 - j, 0);
      }
      function se() {
        const j = i.length / 3;
        let we = 0;
        de(K, we), (we += K.length);
        for (let Ae = 0, Oe = H.length; Ae < Oe; Ae++) {
          const Ie = H[Ae];
          de(Ie, we), (we += Ie.length);
        }
        r.addGroup(j, i.length / 3 - j, 1);
      }
      function de(j, we) {
        let Ae = j.length;
        for (; --Ae >= 0; ) {
          const Oe = Ae;
          let Ie = Ae - 1;
          Ie < 0 && (Ie = j.length - 1);
          for (let rt = 0, De = d + _ * 2; rt < De; rt++) {
            const Xe = Y * rt,
              ee = Y * (rt + 1),
              B = we + Oe + Xe,
              ve = we + Ie + Xe,
              Se = we + Ie + ee,
              _e = we + Oe + ee;
            Me(B, ve, Se, _e);
          }
        }
      }
      function le(j, we, Ae) {
        u.push(j), u.push(we), u.push(Ae);
      }
      function fe(j, we, Ae) {
        ge(j), ge(we), ge(Ae);
        const Oe = i.length / 3,
          Ie = T.generateTopUV(r, i, Oe - 3, Oe - 2, Oe - 1);
        xe(Ie[0]), xe(Ie[1]), xe(Ie[2]);
      }
      function Me(j, we, Ae, Oe) {
        ge(j), ge(we), ge(Oe), ge(we), ge(Ae), ge(Oe);
        const Ie = i.length / 3,
          rt = T.generateSideWallUV(r, i, Ie - 6, Ie - 3, Ie - 2, Ie - 1);
        xe(rt[0]), xe(rt[1]), xe(rt[3]), xe(rt[1]), xe(rt[2]), xe(rt[3]);
      }
      function ge(j) {
        i.push(u[j * 3 + 0]), i.push(u[j * 3 + 1]), i.push(u[j * 3 + 2]);
      }
      function xe(j) {
        o.push(j.x), o.push(j.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return B8(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let o = 0, s = e.shapes.length; o < s; o++) {
      const a = t[e.shapes[o]];
      r.push(a);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new xy[i.type]().fromJSON(i)),
      new px(r, e.options)
    );
  }
}
const F8 = {
  generateTopUV: function (n, e, t, r, i) {
    const o = e[t * 3],
      s = e[t * 3 + 1],
      a = e[r * 3],
      u = e[r * 3 + 1],
      c = e[i * 3],
      d = e[i * 3 + 1];
    return [new tt(o, s), new tt(a, u), new tt(c, d)];
  },
  generateSideWallUV: function (n, e, t, r, i, o) {
    const s = e[t * 3],
      a = e[t * 3 + 1],
      u = e[t * 3 + 2],
      c = e[r * 3],
      d = e[r * 3 + 1],
      m = e[r * 3 + 2],
      g = e[i * 3],
      y = e[i * 3 + 1],
      x = e[i * 3 + 2],
      S = e[o * 3],
      _ = e[o * 3 + 1],
      w = e[o * 3 + 2];
    return Math.abs(a - d) < Math.abs(s - c)
      ? [new tt(s, 1 - u), new tt(c, 1 - m), new tt(g, 1 - x), new tt(S, 1 - w)]
      : [
          new tt(a, 1 - u),
          new tt(d, 1 - m),
          new tt(y, 1 - x),
          new tt(_, 1 - w),
        ];
  },
};
function B8(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      t.shapes.push(o.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class mx extends tc {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      o = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, o, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new mx(e.radius, e.detail);
  }
}
class hg extends tc {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new hg(e.radius, e.detail);
  }
}
class gx extends sn {
  constructor(e = 0.5, t = 1, r = 32, i = 1, o = 0, s = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: o,
        thetaLength: s,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const a = [],
      u = [],
      c = [],
      d = [];
    let m = e;
    const g = (t - e) / i,
      y = new oe(),
      x = new tt();
    for (let S = 0; S <= i; S++) {
      for (let _ = 0; _ <= r; _++) {
        const w = o + (_ / r) * s;
        (y.x = m * Math.cos(w)),
          (y.y = m * Math.sin(w)),
          u.push(y.x, y.y, y.z),
          c.push(0, 0, 1),
          (x.x = (y.x / t + 1) / 2),
          (x.y = (y.y / t + 1) / 2),
          d.push(x.x, x.y);
      }
      m += g;
    }
    for (let S = 0; S < i; S++) {
      const _ = S * (r + 1);
      for (let w = 0; w < r; w++) {
        const T = w + _,
          M = T,
          A = T + r + 1,
          R = T + r + 2,
          D = T + 1;
        a.push(M, A, D), a.push(A, R, D);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new Pt(u, 3)),
      this.setAttribute("normal", new Pt(c, 3)),
      this.setAttribute("uv", new Pt(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new gx(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class vx extends sn {
  constructor(
    e = new wf([new tt(0, 0.5), new tt(-0.5, -0.5), new tt(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const r = [],
      i = [],
      o = [],
      s = [];
    let a = 0,
      u = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let d = 0; d < e.length; d++)
        c(e[d]), this.addGroup(a, u, d), (a += u), (u = 0);
    this.setIndex(r),
      this.setAttribute("position", new Pt(i, 3)),
      this.setAttribute("normal", new Pt(o, 3)),
      this.setAttribute("uv", new Pt(s, 2));
    function c(d) {
      const m = i.length / 3,
        g = d.extractPoints(t);
      let y = g.shape;
      const x = g.holes;
      Qa.isClockWise(y) === !1 && (y = y.reverse());
      for (let _ = 0, w = x.length; _ < w; _++) {
        const T = x[_];
        Qa.isClockWise(T) === !0 && (x[_] = T.reverse());
      }
      const S = Qa.triangulateShape(y, x);
      for (let _ = 0, w = x.length; _ < w; _++) {
        const T = x[_];
        y = y.concat(T);
      }
      for (let _ = 0, w = y.length; _ < w; _++) {
        const T = y[_];
        i.push(T.x, T.y, 0), o.push(0, 0, 1), s.push(T.x, T.y);
      }
      for (let _ = 0, w = S.length; _ < w; _++) {
        const T = S[_],
          M = T[0] + m,
          A = T[1] + m,
          R = T[2] + m;
        r.push(M, A, R), (u += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return z8(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const s = t[e.shapes[i]];
      r.push(s);
    }
    return new vx(r, e.curveSegments);
  }
}
function z8(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class pg extends sn {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    i = 0,
    o = Math.PI * 2,
    s = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: i,
        phiLength: o,
        thetaStart: s,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const u = Math.min(s + a, Math.PI);
    let c = 0;
    const d = [],
      m = new oe(),
      g = new oe(),
      y = [],
      x = [],
      S = [],
      _ = [];
    for (let w = 0; w <= r; w++) {
      const T = [],
        M = w / r;
      let A = 0;
      w === 0 && s === 0
        ? (A = 0.5 / t)
        : w === r && u === Math.PI && (A = -0.5 / t);
      for (let R = 0; R <= t; R++) {
        const D = R / t;
        (m.x = -e * Math.cos(i + D * o) * Math.sin(s + M * a)),
          (m.y = e * Math.cos(s + M * a)),
          (m.z = e * Math.sin(i + D * o) * Math.sin(s + M * a)),
          x.push(m.x, m.y, m.z),
          g.copy(m).normalize(),
          S.push(g.x, g.y, g.z),
          _.push(D + A, 1 - M),
          T.push(c++);
      }
      d.push(T);
    }
    for (let w = 0; w < r; w++)
      for (let T = 0; T < t; T++) {
        const M = d[w][T + 1],
          A = d[w][T],
          R = d[w + 1][T],
          D = d[w + 1][T + 1];
        (w !== 0 || s > 0) && y.push(M, A, D),
          (w !== r - 1 || u < Math.PI) && y.push(A, R, D);
      }
    this.setIndex(y),
      this.setAttribute("position", new Pt(x, 3)),
      this.setAttribute("normal", new Pt(S, 3)),
      this.setAttribute("uv", new Pt(_, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new pg(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class yx extends tc {
  constructor(e = 1, t = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new yx(e.radius, e.detail);
  }
}
class xx extends sn {
  constructor(e = 1, t = 0.4, r = 12, i = 48, o = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: i,
        arc: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const s = [],
      a = [],
      u = [],
      c = [],
      d = new oe(),
      m = new oe(),
      g = new oe();
    for (let y = 0; y <= r; y++)
      for (let x = 0; x <= i; x++) {
        const S = (x / i) * o,
          _ = (y / r) * Math.PI * 2;
        (m.x = (e + t * Math.cos(_)) * Math.cos(S)),
          (m.y = (e + t * Math.cos(_)) * Math.sin(S)),
          (m.z = t * Math.sin(_)),
          a.push(m.x, m.y, m.z),
          (d.x = e * Math.cos(S)),
          (d.y = e * Math.sin(S)),
          g.subVectors(m, d).normalize(),
          u.push(g.x, g.y, g.z),
          c.push(x / i),
          c.push(y / r);
      }
    for (let y = 1; y <= r; y++)
      for (let x = 1; x <= i; x++) {
        const S = (i + 1) * y + x - 1,
          _ = (i + 1) * (y - 1) + x - 1,
          w = (i + 1) * (y - 1) + x,
          T = (i + 1) * y + x;
        s.push(S, _, T), s.push(_, w, T);
      }
    this.setIndex(s),
      this.setAttribute("position", new Pt(a, 3)),
      this.setAttribute("normal", new Pt(u, 3)),
      this.setAttribute("uv", new Pt(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new xx(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class _x extends sn {
  constructor(e = 1, t = 0.4, r = 64, i = 8, o = 2, s = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: r,
        radialSegments: i,
        p: o,
        q: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const a = [],
      u = [],
      c = [],
      d = [],
      m = new oe(),
      g = new oe(),
      y = new oe(),
      x = new oe(),
      S = new oe(),
      _ = new oe(),
      w = new oe();
    for (let M = 0; M <= r; ++M) {
      const A = (M / r) * o * Math.PI * 2;
      T(A, o, s, e, y),
        T(A + 0.01, o, s, e, x),
        _.subVectors(x, y),
        w.addVectors(x, y),
        S.crossVectors(_, w),
        w.crossVectors(S, _),
        S.normalize(),
        w.normalize();
      for (let R = 0; R <= i; ++R) {
        const D = (R / i) * Math.PI * 2,
          P = -t * Math.cos(D),
          U = t * Math.sin(D);
        (m.x = y.x + (P * w.x + U * S.x)),
          (m.y = y.y + (P * w.y + U * S.y)),
          (m.z = y.z + (P * w.z + U * S.z)),
          u.push(m.x, m.y, m.z),
          g.subVectors(m, y).normalize(),
          c.push(g.x, g.y, g.z),
          d.push(M / r),
          d.push(R / i);
      }
    }
    for (let M = 1; M <= r; M++)
      for (let A = 1; A <= i; A++) {
        const R = (i + 1) * (M - 1) + (A - 1),
          D = (i + 1) * M + (A - 1),
          P = (i + 1) * M + A,
          U = (i + 1) * (M - 1) + A;
        a.push(R, D, U), a.push(D, P, U);
      }
    this.setIndex(a),
      this.setAttribute("position", new Pt(u, 3)),
      this.setAttribute("normal", new Pt(c, 3)),
      this.setAttribute("uv", new Pt(d, 2));
    function T(M, A, R, D, P) {
      const U = Math.cos(M),
        O = Math.sin(M),
        L = (R / A) * M,
        H = Math.cos(L);
      (P.x = D * (2 + H) * 0.5 * U),
        (P.y = D * (2 + H) * O * 0.5),
        (P.z = D * Math.sin(L) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new _x(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class Sx extends sn {
  constructor(
    e = new jw(new oe(-1, -1, 0), new oe(-1, 1, 0), new oe(1, 1, 0)),
    t = 64,
    r = 1,
    i = 8,
    o = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: i,
        closed: o,
      });
    const s = e.computeFrenetFrames(t, o);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals);
    const a = new oe(),
      u = new oe(),
      c = new tt();
    let d = new oe();
    const m = [],
      g = [],
      y = [],
      x = [];
    S(),
      this.setIndex(x),
      this.setAttribute("position", new Pt(m, 3)),
      this.setAttribute("normal", new Pt(g, 3)),
      this.setAttribute("uv", new Pt(y, 2));
    function S() {
      for (let M = 0; M < t; M++) _(M);
      _(o === !1 ? t : 0), T(), w();
    }
    function _(M) {
      d = e.getPointAt(M / t, d);
      const A = s.normals[M],
        R = s.binormals[M];
      for (let D = 0; D <= i; D++) {
        const P = (D / i) * Math.PI * 2,
          U = Math.sin(P),
          O = -Math.cos(P);
        (u.x = O * A.x + U * R.x),
          (u.y = O * A.y + U * R.y),
          (u.z = O * A.z + U * R.z),
          u.normalize(),
          g.push(u.x, u.y, u.z),
          (a.x = d.x + r * u.x),
          (a.y = d.y + r * u.y),
          (a.z = d.z + r * u.z),
          m.push(a.x, a.y, a.z);
      }
    }
    function w() {
      for (let M = 1; M <= t; M++)
        for (let A = 1; A <= i; A++) {
          const R = (i + 1) * (M - 1) + (A - 1),
            D = (i + 1) * M + (A - 1),
            P = (i + 1) * M + A,
            U = (i + 1) * (M - 1) + A;
          x.push(R, D, U), x.push(D, P, U);
        }
    }
    function T() {
      for (let M = 0; M <= t; M++)
        for (let A = 0; A <= i; A++)
          (c.x = M / t), (c.y = A / i), y.push(c.x, c.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new Sx(
      new xy[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class Xw extends sn {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        r = new Set(),
        i = new oe(),
        o = new oe();
      if (e.index !== null) {
        const s = e.attributes.position,
          a = e.index;
        let u = e.groups;
        u.length === 0 &&
          (u = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, d = u.length; c < d; ++c) {
          const m = u[c],
            g = m.start,
            y = m.count;
          for (let x = g, S = g + y; x < S; x += 3)
            for (let _ = 0; _ < 3; _++) {
              const w = a.getX(x + _),
                T = a.getX(x + ((_ + 1) % 3));
              i.fromBufferAttribute(s, w),
                o.fromBufferAttribute(s, T),
                UT(i, o, r) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const s = e.attributes.position;
        for (let a = 0, u = s.count / 3; a < u; a++)
          for (let c = 0; c < 3; c++) {
            const d = 3 * a + c,
              m = 3 * a + ((c + 1) % 3);
            i.fromBufferAttribute(s, d),
              o.fromBufferAttribute(s, m),
              UT(i, o, r) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new Pt(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function UT(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var FT = Object.freeze({
  __proto__: null,
  BoxGeometry: kf,
  CapsuleGeometry: ux,
  CircleGeometry: cx,
  ConeGeometry: fx,
  CylinderGeometry: jh,
  DodecahedronGeometry: dx,
  EdgesGeometry: jR,
  ExtrudeGeometry: px,
  IcosahedronGeometry: mx,
  LatheGeometry: dg,
  OctahedronGeometry: hg,
  PlaneGeometry: Yl,
  PolyhedronGeometry: tc,
  RingGeometry: gx,
  ShapeGeometry: vx,
  SphereGeometry: pg,
  TetrahedronGeometry: yx,
  TorusGeometry: xx,
  TorusKnotGeometry: _x,
  TubeGeometry: Sx,
  WireframeGeometry: Xw,
});
class qR extends zi {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new St(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class KR extends Ds {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class Yw extends zi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new St(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ec),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new fs()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ZR extends Yw {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new tt(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Tr((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new St(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new St(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new St(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class JR extends zi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new St(16777215)),
      (this.specular = new St(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ec),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new fs()),
      (this.combine = sg),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class QR extends zi {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ec),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class eP extends zi {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ec),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class tP extends zi {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new St(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new St(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ec),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new fs()),
      (this.combine = sg),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class nP extends zi {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new St(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ec),
      (this.normalScale = new tt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class rP extends _o {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function gf(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function iP(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function oP(n) {
  function e(i, o) {
    return n[i] - n[o];
  }
  const t = n.length,
    r = new Array(t);
  for (let i = 0; i !== t; ++i) r[i] = i;
  return r.sort(e), r;
}
function bS(n, e, t) {
  const r = n.length,
    i = new n.constructor(r);
  for (let o = 0, s = 0; s !== r; ++o) {
    const a = t[o] * e;
    for (let u = 0; u !== e; ++u) i[s++] = n[a + u];
  }
  return i;
}
function qw(n, e, t, r) {
  let i = 1,
    o = n[0];
  for (; o !== void 0 && o[r] === void 0; ) o = n[i++];
  if (o === void 0) return;
  let s = o[r];
  if (s !== void 0)
    if (Array.isArray(s))
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), t.push.apply(t, s)),
          (o = n[i++]);
      while (o !== void 0);
    else if (s.toArray !== void 0)
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), s.toArray(t, t.length)),
          (o = n[i++]);
      while (o !== void 0);
    else
      do (s = o[r]), s !== void 0 && (e.push(o.time), t.push(s)), (o = n[i++]);
      while (o !== void 0);
}
function H8(n, e, t, r, i = 30) {
  const o = n.clone();
  o.name = e;
  const s = [];
  for (let u = 0; u < o.tracks.length; ++u) {
    const c = o.tracks[u],
      d = c.getValueSize(),
      m = [],
      g = [];
    for (let y = 0; y < c.times.length; ++y) {
      const x = c.times[y] * i;
      if (!(x < t || x >= r)) {
        m.push(c.times[y]);
        for (let S = 0; S < d; ++S) g.push(c.values[y * d + S]);
      }
    }
    m.length !== 0 &&
      ((c.times = gf(m, c.times.constructor)),
      (c.values = gf(g, c.values.constructor)),
      s.push(c));
  }
  o.tracks = s;
  let a = 1 / 0;
  for (let u = 0; u < o.tracks.length; ++u)
    a > o.tracks[u].times[0] && (a = o.tracks[u].times[0]);
  for (let u = 0; u < o.tracks.length; ++u) o.tracks[u].shift(-1 * a);
  return o.resetDuration(), o;
}
function V8(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length,
    o = e / r;
  for (let s = 0; s < i; ++s) {
    const a = t.tracks[s],
      u = a.ValueTypeName;
    if (u === "bool" || u === "string") continue;
    const c = n.tracks.find(function (w) {
      return w.name === a.name && w.ValueTypeName === u;
    });
    if (c === void 0) continue;
    let d = 0;
    const m = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (d = m / 3);
    let g = 0;
    const y = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (g = y / 3);
    const x = a.times.length - 1;
    let S;
    if (o <= a.times[0]) {
      const w = d,
        T = m - d;
      S = a.values.slice(w, T);
    } else if (o >= a.times[x]) {
      const w = x * m + d,
        T = w + m - d;
      S = a.values.slice(w, T);
    } else {
      const w = a.createInterpolant(),
        T = d,
        M = m - d;
      w.evaluate(o), (S = w.resultBuffer.slice(T, M));
    }
    u === "quaternion" &&
      new io().fromArray(S).normalize().conjugate().toArray(S);
    const _ = c.times.length;
    for (let w = 0; w < _; ++w) {
      const T = w * y + g;
      if (u === "quaternion")
        io.multiplyQuaternionsFlat(c.values, T, S, 0, c.values, T);
      else {
        const M = y - g * 2;
        for (let A = 0; A < M; ++A) c.values[T + A] -= S[A];
      }
    }
  }
  return (n.blendMode = Rw), n;
}
const W8 = {
  convertArray: gf,
  isTypedArray: iP,
  getKeyframeOrder: oP,
  sortedArray: bS,
  flattenJSON: qw,
  subclip: H8,
  makeClipAdditive: V8,
};
class mg {
  constructor(e, t, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(r)),
      (this.sampleValues = t),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex,
      i = t[r],
      o = t[r - 1];
    e: {
      t: {
        let s;
        n: {
          r: if (!(e < i)) {
            for (let a = r + 2; ; ) {
              if (i === void 0) {
                if (e < o) break r;
                return (
                  (r = t.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === a) break;
              if (((o = i), (i = t[++r]), e < i)) break t;
            }
            s = t.length;
            break n;
          }
          if (!(e >= o)) {
            const a = t[1];
            e < a && ((r = 2), (o = a));
            for (let u = r - 2; ; ) {
              if (o === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === u) break;
              if (((i = o), (o = t[--r - 1]), e >= o)) break t;
            }
            (s = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < s; ) {
          const a = (r + s) >>> 1;
          e < t[a] ? (s = a) : (r = a + 1);
        }
        if (((i = t[r]), (o = t[r - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = t.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, o, i);
    }
    return this.interpolate_(r, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      o = e * i;
    for (let s = 0; s !== i; ++s) t[s] = r[o + s];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class sP extends mg {
  constructor(e, t, r, i) {
    super(e, t, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: hf, endingEnd: hf });
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let o = e - 2,
      s = e + 1,
      a = i[o],
      u = i[s];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case pf:
          (o = e), (a = 2 * t - r);
          break;
        case Bm:
          (o = i.length - 2), (a = t + i[o] - i[o + 1]);
          break;
        default:
          (o = e), (a = r);
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case pf:
          (s = e), (u = 2 * r - t);
          break;
        case Bm:
          (s = 1), (u = r + i[1] - i[0]);
          break;
        default:
          (s = e - 1), (u = t);
      }
    const c = (r - t) * 0.5,
      d = this.valueSize;
    (this._weightPrev = c / (t - a)),
      (this._weightNext = c / (u - r)),
      (this._offsetPrev = o * d),
      (this._offsetNext = s * d);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      u = e * a,
      c = u - a,
      d = this._offsetPrev,
      m = this._offsetNext,
      g = this._weightPrev,
      y = this._weightNext,
      x = (r - t) / (i - t),
      S = x * x,
      _ = S * x,
      w = -g * _ + 2 * g * S - g * x,
      T = (1 + g) * _ + (-1.5 - 2 * g) * S + (-0.5 + g) * x + 1,
      M = (-1 - y) * _ + (1.5 + y) * S + 0.5 * x,
      A = y * _ - y * S;
    for (let R = 0; R !== a; ++R)
      o[R] = w * s[d + R] + T * s[c + R] + M * s[u + R] + A * s[m + R];
    return o;
  }
}
class Kw extends mg {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      u = e * a,
      c = u - a,
      d = (r - t) / (i - t),
      m = 1 - d;
    for (let g = 0; g !== a; ++g) o[g] = s[c + g] * m + s[u + g] * d;
    return o;
  }
}
class aP extends mg {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class va {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = gf(t, this.TimeBufferType)),
      (this.values = gf(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON) r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: gf(e.times, Array),
        values: gf(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new aP(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Kw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new sP(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Fm:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case my:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case b0:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Fm;
      case this.InterpolantFactoryMethodLinear:
        return my;
      case this.InterpolantFactoryMethodSmooth:
        return b0;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times,
      i = r.length;
    let o = 0,
      s = i - 1;
    for (; o !== i && r[o] < e; ) ++o;
    for (; s !== -1 && r[s] > t; ) --s;
    if ((++s, o !== 0 || s !== i)) {
      o >= s && ((s = Math.max(s, 1)), (o = s - 1));
      const a = this.getValueSize();
      (this.times = r.slice(o, s)),
        (this.values = this.values.slice(o * a, s * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      o = r.length;
    o === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let s = null;
    for (let a = 0; a !== o; a++) {
      const u = r[a];
      if (typeof u == "number" && isNaN(u)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          u
        ),
          (e = !1);
        break;
      }
      if (s !== null && s > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, u, s),
          (e = !1);
        break;
      }
      s = u;
    }
    if (i !== void 0 && iP(i))
      for (let a = 0, u = i.length; a !== u; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === b0,
      o = e.length - 1;
    let s = 1;
    for (let a = 1; a < o; ++a) {
      let u = !1;
      const c = e[a],
        d = e[a + 1];
      if (c !== d && (a !== 1 || c !== e[0]))
        if (i) u = !0;
        else {
          const m = a * r,
            g = m - r,
            y = m + r;
          for (let x = 0; x !== r; ++x) {
            const S = t[m + x];
            if (S !== t[g + x] || S !== t[y + x]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (a !== s) {
          e[s] = e[a];
          const m = a * r,
            g = s * r;
          for (let y = 0; y !== r; ++y) t[g + y] = t[m + y];
        }
        ++s;
      }
    }
    if (o > 0) {
      e[s] = e[o];
      for (let a = o * r, u = s * r, c = 0; c !== r; ++c) t[u + c] = t[a + c];
      ++s;
    }
    return (
      s !== e.length
        ? ((this.times = e.slice(0, s)), (this.values = t.slice(0, s * r)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
va.prototype.TimeBufferType = Float32Array;
va.prototype.ValueBufferType = Float32Array;
va.prototype.DefaultInterpolation = my;
class Of extends va {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
Of.prototype.ValueTypeName = "bool";
Of.prototype.ValueBufferType = Array;
Of.prototype.DefaultInterpolation = Fm;
Of.prototype.InterpolantFactoryMethodLinear = void 0;
Of.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zw extends va {}
Zw.prototype.ValueTypeName = "color";
class Zm extends va {}
Zm.prototype.ValueTypeName = "number";
class lP extends mg {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      u = (r - t) / (i - t);
    let c = e * a;
    for (let d = c + a; c !== d; c += 4) io.slerpFlat(o, 0, s, c - a, s, c, u);
    return o;
  }
}
class gg extends va {
  InterpolantFactoryMethodLinear(e) {
    return new lP(this.times, this.values, this.getValueSize(), e);
  }
}
gg.prototype.ValueTypeName = "quaternion";
gg.prototype.InterpolantFactoryMethodSmooth = void 0;
class Nf extends va {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
Nf.prototype.ValueTypeName = "string";
Nf.prototype.ValueBufferType = Array;
Nf.prototype.DefaultInterpolation = Fm;
Nf.prototype.InterpolantFactoryMethodLinear = void 0;
Nf.prototype.InterpolantFactoryMethodSmooth = void 0;
class Jm extends va {}
Jm.prototype.ValueTypeName = "vector";
class Qm {
  constructor(e = "", t = -1, r = [], i = Zy) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = us()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let s = 0, a = r.length; s !== a; ++s) t.push(j8(r[s]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const t = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let o = 0, s = r.length; o !== s; ++o) t.push(va.toJSON(r[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const o = t.length,
      s = [];
    for (let a = 0; a < o; a++) {
      let u = [],
        c = [];
      u.push((a + o - 1) % o, a, (a + 1) % o), c.push(0, 1, 0);
      const d = oP(u);
      (u = bS(u, 1, d)),
        (c = bS(c, 1, d)),
        !i && u[0] === 0 && (u.push(o), c.push(c[0])),
        s.push(
          new Zm(".morphTargetInfluences[" + t[a].name + "]", u, c).scale(1 / r)
        );
    }
    return new this(e, -1, s);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, u = e.length; a < u; a++) {
      const c = e[a],
        d = c.name.match(o);
      if (d && d.length > 1) {
        const m = d[1];
        let g = i[m];
        g || (i[m] = g = []), g.push(c);
      }
    }
    const s = [];
    for (const a in i)
      s.push(this.CreateFromMorphTargetSequence(a, i[a], t, r));
    return s;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (m, g, y, x, S) {
        if (y.length !== 0) {
          const _ = [],
            w = [];
          qw(y, _, w, x), _.length !== 0 && S.push(new m(g, _, w));
        }
      },
      i = [],
      o = e.name || "default",
      s = e.fps || 30,
      a = e.blendMode;
    let u = e.length || -1;
    const c = e.hierarchy || [];
    for (let m = 0; m < c.length; m++) {
      const g = c[m].keys;
      if (!(!g || g.length === 0))
        if (g[0].morphTargets) {
          const y = {};
          let x;
          for (x = 0; x < g.length; x++)
            if (g[x].morphTargets)
              for (let S = 0; S < g[x].morphTargets.length; S++)
                y[g[x].morphTargets[S]] = -1;
          for (const S in y) {
            const _ = [],
              w = [];
            for (let T = 0; T !== g[x].morphTargets.length; ++T) {
              const M = g[x];
              _.push(M.time), w.push(M.morphTarget === S ? 1 : 0);
            }
            i.push(new Zm(".morphTargetInfluence[" + S + "]", _, w));
          }
          u = y.length * s;
        } else {
          const y = ".bones[" + t[m].name + "]";
          r(Jm, y + ".position", g, "pos", i),
            r(gg, y + ".quaternion", g, "rot", i),
            r(Jm, y + ".scale", g, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(o, u, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const o = this.tracks[r];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function G8(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Zm;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Jm;
    case "color":
      return Zw;
    case "quaternion":
      return gg;
    case "bool":
    case "boolean":
      return Of;
    case "string":
      return Nf;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function j8(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = G8(n.type);
  if (n.times === void 0) {
    const t = [],
      r = [];
    qw(n.keys, t, r, "value"), (n.times = t), (n.values = r);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Nl = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class Jw {
  constructor(e, t, r) {
    const i = this;
    let o = !1,
      s = 0,
      a = 0,
      u;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (d) {
        a++, o === !1 && i.onStart !== void 0 && i.onStart(d, s, a), (o = !0);
      }),
      (this.itemEnd = function (d) {
        s++,
          i.onProgress !== void 0 && i.onProgress(d, s, a),
          s === a && ((o = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (d) {
        i.onError !== void 0 && i.onError(d);
      }),
      (this.resolveURL = function (d) {
        return u ? u(d) : d;
      }),
      (this.setURLModifier = function (d) {
        return (u = d), this;
      }),
      (this.addHandler = function (d, m) {
        return c.push(d, m), this;
      }),
      (this.removeHandler = function (d) {
        const m = c.indexOf(d);
        return m !== -1 && c.splice(m, 2), this;
      }),
      (this.getHandler = function (d) {
        for (let m = 0, g = c.length; m < g; m += 2) {
          const y = c[m],
            x = c[m + 1];
          if ((y.global && (y.lastIndex = 0), y.test(d))) return x;
        }
        return null;
      });
  }
}
const uP = new Jw();
class Vo {
  constructor(e) {
    (this.manager = e !== void 0 ? e : uP),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, o) {
      r.load(e, i, t, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
Vo.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Il = {};
class $8 extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Wl extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = Nl.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (Il[e] !== void 0) {
      Il[e].push({ onLoad: t, onProgress: r, onError: i });
      return;
    }
    (Il[e] = []), Il[e].push({ onLoad: t, onProgress: r, onError: i });
    const s = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      u = this.responseType;
    fetch(s)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const d = Il[e],
            m = c.body.getReader(),
            g = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
            y = g ? parseInt(g) : 0,
            x = y !== 0;
          let S = 0;
          const _ = new ReadableStream({
            start(w) {
              T();
              function T() {
                m.read().then(
                  ({ done: M, value: A }) => {
                    if (M) w.close();
                    else {
                      S += A.byteLength;
                      const R = new ProgressEvent("progress", {
                        lengthComputable: x,
                        loaded: S,
                        total: y,
                      });
                      for (let D = 0, P = d.length; D < P; D++) {
                        const U = d[D];
                        U.onProgress && U.onProgress(R);
                      }
                      w.enqueue(A), T();
                    }
                  },
                  (M) => {
                    w.error(M);
                  }
                );
              }
            },
          });
          return new Response(_);
        } else
          throw new $8(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (u) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((d) => new DOMParser().parseFromString(d, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const m = /charset="?([^;"\s]*)"?/i.exec(a),
                g = m && m[1] ? m[1].toLowerCase() : void 0,
                y = new TextDecoder(g);
              return c.arrayBuffer().then((x) => y.decode(x));
            }
        }
      })
      .then((c) => {
        Nl.add(e, c);
        const d = Il[e];
        delete Il[e];
        for (let m = 0, g = d.length; m < g; m++) {
          const y = d[m];
          y.onLoad && y.onLoad(c);
        }
      })
      .catch((c) => {
        const d = Il[e];
        if (d === void 0) throw (this.manager.itemError(e), c);
        delete Il[e];
        for (let m = 0, g = d.length; m < g; m++) {
          const y = d[m];
          y.onError && y.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class X8 extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Wl(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (a) {
          try {
            t(o.parse(JSON.parse(a)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = Qm.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class Y8 extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = [],
      a = new ax(),
      u = new Wl(this.manager);
    u.setPath(this.path),
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(o.withCredentials);
    let c = 0;
    function d(m) {
      u.load(
        e[m],
        function (g) {
          const y = o.parse(g, !0);
          (s[m] = {
            width: y.width,
            height: y.height,
            format: y.format,
            mipmaps: y.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (y.mipmapCount === 1 && (a.minFilter = Cr),
              (a.image = s),
              (a.format = y.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let m = 0, g = e.length; m < g; ++m) d(m);
    else
      u.load(
        e,
        function (m) {
          const g = o.parse(m, !0);
          if (g.isCubemap) {
            const y = g.mipmaps.length / g.mipmapCount;
            for (let x = 0; x < y; x++) {
              s[x] = { mipmaps: [] };
              for (let S = 0; S < g.mipmapCount; S++)
                s[x].mipmaps.push(g.mipmaps[x * g.mipmapCount + S]),
                  (s[x].format = g.format),
                  (s[x].width = g.width),
                  (s[x].height = g.height);
            }
            a.image = s;
          } else
            (a.image.width = g.width),
              (a.image.height = g.height),
              (a.mipmaps = g.mipmaps);
          g.mipmapCount === 1 && (a.minFilter = Cr),
            (a.format = g.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        r,
        i
      );
    return a;
  }
}
class eg extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Nl.get(e);
    if (s !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    const a = jm("img");
    function u() {
      d(), Nl.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function c(m) {
      d(), i && i(m), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function d() {
      a.removeEventListener("load", u, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", u, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class q8 extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new cg();
    o.colorSpace = As;
    const s = new eg(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let a = 0;
    function u(c) {
      s.load(
        e[c],
        function (d) {
          (o.images[c] = d), a++, a === 6 && ((o.needsUpdate = !0), t && t(o));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < e.length; ++c) u(c);
    return o;
  }
}
class K8 extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Ja(),
      a = new Wl(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (u) {
          let c;
          try {
            c = o.parse(u);
          } catch (d) {
            if (i !== void 0) i(d);
            else {
              console.error(d);
              return;
            }
          }
          c.image !== void 0
            ? (s.image = c.image)
            : c.data !== void 0 &&
              ((s.image.width = c.width),
              (s.image.height = c.height),
              (s.image.data = c.data)),
            (s.wrapS = c.wrapS !== void 0 ? c.wrapS : Ls),
            (s.wrapT = c.wrapT !== void 0 ? c.wrapT : Ls),
            (s.magFilter = c.magFilter !== void 0 ? c.magFilter : Cr),
            (s.minFilter = c.minFilter !== void 0 ? c.minFilter : Cr),
            (s.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0 && (s.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (s.flipY = c.flipY),
            c.format !== void 0 && (s.format = c.format),
            c.type !== void 0 && (s.type = c.type),
            c.mipmaps !== void 0 &&
              ((s.mipmaps = c.mipmaps), (s.minFilter = Xa)),
            c.mipmapCount === 1 && (s.minFilter = Cr),
            c.generateMipmaps !== void 0 &&
              (s.generateMipmaps = c.generateMipmaps),
            (s.needsUpdate = !0),
            t && t(s, c);
        },
        r,
        i
      ),
      s
    );
  }
}
class wx extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new er(),
      s = new eg(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (a) {
          (o.image = a), (o.needsUpdate = !0), t !== void 0 && t(o);
        },
        r,
        i
      ),
      o
    );
  }
}
class nc extends wn {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new St(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class cP extends nc {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(wn.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new St(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const y1 = new Gt(),
  BT = new oe(),
  zT = new oe();
class Qw {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new tt(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Gt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new fg()),
      (this._frameExtents = new tt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new dn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    BT.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(BT),
      zT.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(zT),
      t.updateMatrixWorld(),
      y1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(y1),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(y1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class Z8 extends Qw {
  constructor() {
    super(new Nr(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      r = Lh * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      o = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || o !== t.far) &&
      ((t.fov = r), (t.aspect = i), (t.far = o), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class fP extends nc {
  constructor(e, t, r = 0, i = Math.PI / 3, o = 0, s = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(wn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new wn()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = o),
      (this.decay = s),
      (this.map = null),
      (this.shadow = new Z8());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const HT = new Gt(),
  Zp = new oe(),
  x1 = new oe();
class J8 extends Qw {
  constructor() {
    super(new Nr(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new tt(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new dn(2, 1, 1, 1),
        new dn(0, 1, 1, 1),
        new dn(3, 1, 1, 1),
        new dn(1, 1, 1, 1),
        new dn(3, 0, 1, 1),
        new dn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new oe(1, 0, 0),
        new oe(-1, 0, 0),
        new oe(0, 0, 1),
        new oe(0, 0, -1),
        new oe(0, 1, 0),
        new oe(0, -1, 0),
      ]),
      (this._cubeUps = [
        new oe(0, 1, 0),
        new oe(0, 1, 0),
        new oe(0, 1, 0),
        new oe(0, 1, 0),
        new oe(0, 0, 1),
        new oe(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      i = this.matrix,
      o = e.distance || r.far;
    o !== r.far && ((r.far = o), r.updateProjectionMatrix()),
      Zp.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(Zp),
      x1.copy(r.position),
      x1.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(x1),
      r.updateMatrixWorld(),
      i.makeTranslation(-Zp.x, -Zp.y, -Zp.z),
      HT.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(HT);
  }
}
class dP extends nc {
  constructor(e, t, r = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new J8());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Q8 extends Qw {
  constructor() {
    super(new Xu(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class hP extends nc {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(wn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new wn()),
      (this.shadow = new Q8());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class pP extends nc {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class mP extends nc {
  constructor(e, t, r = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class gP {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new oe());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      t.copy(s[0]).multiplyScalar(0.282095),
      t.addScaledVector(s[1], 0.488603 * i),
      t.addScaledVector(s[2], 0.488603 * o),
      t.addScaledVector(s[3], 0.488603 * r),
      t.addScaledVector(s[4], 1.092548 * (r * i)),
      t.addScaledVector(s[5], 1.092548 * (i * o)),
      t.addScaledVector(s[6], 0.315392 * (3 * o * o - 1)),
      t.addScaledVector(s[7], 1.092548 * (r * o)),
      t.addScaledVector(s[8], 0.546274 * (r * r - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      t.copy(s[0]).multiplyScalar(0.886227),
      t.addScaledVector(s[1], 2 * 0.511664 * i),
      t.addScaledVector(s[2], 2 * 0.511664 * o),
      t.addScaledVector(s[3], 2 * 0.511664 * r),
      t.addScaledVector(s[4], 2 * 0.429043 * r * i),
      t.addScaledVector(s[5], 2 * 0.429043 * i * o),
      t.addScaledVector(s[6], 0.743125 * o * o - 0.247708),
      t.addScaledVector(s[7], 2 * 0.429043 * r * o),
      t.addScaledVector(s[8], 0.429043 * (r * r - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x,
      i = e.y,
      o = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * o),
      (t[3] = 0.488603 * r),
      (t[4] = 1.092548 * r * i),
      (t[5] = 1.092548 * i * o),
      (t[6] = 0.315392 * (3 * o * o - 1)),
      (t[7] = 1.092548 * r * o),
      (t[8] = 0.546274 * (r * r - i * i));
  }
}
class vP extends nc {
  constructor(e = new gP(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class bx extends Vo {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, r, i) {
    const o = this,
      s = new Wl(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (a) {
          try {
            t(o.parse(JSON.parse(a)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function r(o) {
      return (
        t[o] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", o),
        t[o]
      );
    }
    const i = bx.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new St().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const o in e.uniforms) {
        const s = e.uniforms[o];
        switch (((i.uniforms[o] = {}), s.type)) {
          case "t":
            i.uniforms[o].value = r(s.value);
            break;
          case "c":
            i.uniforms[o].value = new St().setHex(s.value);
            break;
          case "v2":
            i.uniforms[o].value = new tt().fromArray(s.value);
            break;
          case "v3":
            i.uniforms[o].value = new oe().fromArray(s.value);
            break;
          case "v4":
            i.uniforms[o].value = new dn().fromArray(s.value);
            break;
          case "m3":
            i.uniforms[o].value = new en().fromArray(s.value);
            break;
          case "m4":
            i.uniforms[o].value = new Gt().fromArray(s.value);
            break;
          default:
            i.uniforms[o].value = s.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const o in e.extensions) i.extensions[o] = e.extensions[o];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]),
        (i.normalScale = new tt().fromArray(o));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new tt().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: qR,
      SpriteMaterial: Fw,
      RawShaderMaterial: KR,
      ShaderMaterial: Ds,
      PointsMaterial: zw,
      MeshPhysicalMaterial: ZR,
      MeshStandardMaterial: Yw,
      MeshPhongMaterial: JR,
      MeshToonMaterial: QR,
      MeshNormalMaterial: eP,
      MeshLambertMaterial: tP,
      MeshDepthMaterial: tx,
      MeshDistanceMaterial: nx,
      MeshBasicMaterial: Xl,
      MeshMatcapMaterial: nP,
      LineDashedMaterial: rP,
      LineBasicMaterial: _o,
      Material: zi,
    };
    return new t[e]();
  }
}
class MS {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class Mx extends sn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class yP extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Wl(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (a) {
          try {
            t(o.parse(JSON.parse(a)));
          } catch (u) {
            i ? i(u) : console.error(u), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = {},
      r = {};
    function i(y, x) {
      if (t[x] !== void 0) return t[x];
      const _ = y.interleavedBuffers[x],
        w = o(y, _.buffer),
        T = mh(_.type, w),
        M = new ox(T, _.stride);
      return (M.uuid = _.uuid), (t[x] = M), M;
    }
    function o(y, x) {
      if (r[x] !== void 0) return r[x];
      const _ = y.arrayBuffers[x],
        w = new Uint32Array(_).buffer;
      return (r[x] = w), w;
    }
    const s = e.isInstancedBufferGeometry ? new Mx() : new sn(),
      a = e.data.index;
    if (a !== void 0) {
      const y = mh(a.type, a.array);
      s.setIndex(new Gn(y, 1));
    }
    const u = e.data.attributes;
    for (const y in u) {
      const x = u[y];
      let S;
      if (x.isInterleavedBufferAttribute) {
        const _ = i(e.data, x.data);
        S = new as(_, x.itemSize, x.offset, x.normalized);
      } else {
        const _ = mh(x.type, x.array),
          w = x.isInstancedBufferAttribute ? Rf : Gn;
        S = new w(_, x.itemSize, x.normalized);
      }
      x.name !== void 0 && (S.name = x.name),
        x.usage !== void 0 && S.setUsage(x.usage),
        s.setAttribute(y, S);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const y in c) {
        const x = c[y],
          S = [];
        for (let _ = 0, w = x.length; _ < w; _++) {
          const T = x[_];
          let M;
          if (T.isInterleavedBufferAttribute) {
            const A = i(e.data, T.data);
            M = new as(A, T.itemSize, T.offset, T.normalized);
          } else {
            const A = mh(T.type, T.array);
            M = new Gn(A, T.itemSize, T.normalized);
          }
          T.name !== void 0 && (M.name = T.name), S.push(M);
        }
        s.morphAttributes[y] = S;
      }
    e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const m = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (m !== void 0)
      for (let y = 0, x = m.length; y !== x; ++y) {
        const S = m[y];
        s.addGroup(S.start, S.count, S.materialIndex);
      }
    const g = e.data.boundingSphere;
    if (g !== void 0) {
      const y = new oe();
      g.center !== void 0 && y.fromArray(g.center),
        (s.boundingSphere = new fi(y, g.radius));
    }
    return (
      e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s
    );
  }
}
class eW extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = this.path === "" ? MS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || s;
    const a = new Wl(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (u) {
          let c = null;
          try {
            c = JSON.parse(u);
          } catch (m) {
            i !== void 0 && i(m),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                m.message
              );
            return;
          }
          const d = c.metadata;
          if (
            d === void 0 ||
            d.type === void 0 ||
            d.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          o.parse(c, t);
        },
        r,
        i
      );
  }
  async loadAsync(e, t) {
    const r = this,
      i = this.path === "" ? MS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new Wl(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials);
    const s = await o.loadAsync(e, t),
      a = JSON.parse(s),
      u = a.metadata;
    if (
      u === void 0 ||
      u.type === void 0 ||
      u.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(a);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      o = this.parseGeometries(e.geometries, i),
      s = this.parseImages(e.images, function () {
        t !== void 0 && t(c);
      }),
      a = this.parseTextures(e.textures, s),
      u = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, o, u, a, r),
      d = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, d), this.bindLightTargets(c), t !== void 0)) {
      let m = !1;
      for (const g in s)
        if (s[g].data instanceof HTMLImageElement) {
          m = !0;
          break;
        }
      m === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      o = await this.parseImagesAsync(e.images),
      s = this.parseTextures(e.textures, o),
      a = this.parseMaterials(e.materials, s),
      u = this.parseObject(e.object, i, a, s, t),
      c = this.parseSkeletons(e.skeletons, u);
    return this.bindSkeletons(u, c), this.bindLightTargets(u), u;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const o = new wf().fromJSON(e[r]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {},
      i = {};
    if (
      (t.traverse(function (o) {
        o.isBone && (i[o.uuid] = o);
      }),
      e !== void 0)
    )
      for (let o = 0, s = e.length; o < s; o++) {
        const a = new sx().fromJSON(e[o], i);
        r[a.uuid] = a;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new yP();
      for (let o = 0, s = e.length; o < s; o++) {
        let a;
        const u = e[o];
        switch (u.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(u);
            break;
          default:
            u.type in FT
              ? (a = FT[u.type].fromJSON(u, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${u.type}"`
                );
        }
        (a.uuid = u.uuid),
          u.name !== void 0 && (a.name = u.name),
          u.userData !== void 0 && (a.userData = u.userData),
          (r[u.uuid] = a);
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const o = new bx();
      o.setTextures(t);
      for (let s = 0, a = e.length; s < a; s++) {
        const u = e[s];
        r[u.uuid] === void 0 && (r[u.uuid] = o.parse(u)),
          (i[u.uuid] = r[u.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          o = Qm.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this,
      i = {};
    let o;
    function s(u) {
      return (
        r.manager.itemStart(u),
        o.load(
          u,
          function () {
            r.manager.itemEnd(u);
          },
          void 0,
          function () {
            r.manager.itemError(u), r.manager.itemEnd(u);
          }
        )
      );
    }
    function a(u) {
      if (typeof u == "string") {
        const c = u,
          d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : r.resourcePath + c;
        return s(d);
      } else
        return u.data
          ? { data: mh(u.type, u.data), width: u.width, height: u.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const u = new Jw(t);
      (o = new eg(u)), o.setCrossOrigin(this.crossOrigin);
      for (let c = 0, d = e.length; c < d; c++) {
        const m = e[c],
          g = m.url;
        if (Array.isArray(g)) {
          const y = [];
          for (let x = 0, S = g.length; x < S; x++) {
            const _ = g[x],
              w = a(_);
            w !== null &&
              (w instanceof HTMLImageElement
                ? y.push(w)
                : y.push(new Ja(w.data, w.width, w.height)));
          }
          i[m.uuid] = new mf(y);
        } else {
          const y = a(m.url);
          i[m.uuid] = new mf(y);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      r = {};
    let i;
    async function o(s) {
      if (typeof s == "string") {
        const a = s,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await i.loadAsync(u);
      } else
        return s.data
          ? { data: mh(s.type, s.data), width: s.width, height: s.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new eg(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let s = 0, a = e.length; s < a; s++) {
        const u = e[s],
          c = u.url;
        if (Array.isArray(c)) {
          const d = [];
          for (let m = 0, g = c.length; m < g; m++) {
            const y = c[m],
              x = await o(y);
            x !== null &&
              (x instanceof HTMLImageElement
                ? d.push(x)
                : d.push(new Ja(x.data, x.width, x.height)));
          }
          r[u.uuid] = new mf(d);
        } else {
          const d = await o(u.url);
          r[u.uuid] = new mf(d);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(o, s) {
      return typeof o == "number"
        ? o
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            o
          ),
          s[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, s = e.length; o < s; o++) {
        const a = e[o];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const u = t[a.image],
          c = u.data;
        let d;
        Array.isArray(c)
          ? ((d = new cg()), c.length === 6 && (d.needsUpdate = !0))
          : (c && c.data ? (d = new Ja()) : (d = new er()),
            c && (d.needsUpdate = !0)),
          (d.source = u),
          (d.uuid = a.uuid),
          a.name !== void 0 && (d.name = a.name),
          a.mapping !== void 0 && (d.mapping = r(a.mapping, tW)),
          a.channel !== void 0 && (d.channel = a.channel),
          a.offset !== void 0 && d.offset.fromArray(a.offset),
          a.repeat !== void 0 && d.repeat.fromArray(a.repeat),
          a.center !== void 0 && d.center.fromArray(a.center),
          a.rotation !== void 0 && (d.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((d.wrapS = r(a.wrap[0], VT)), (d.wrapT = r(a.wrap[1], VT))),
          a.format !== void 0 && (d.format = a.format),
          a.internalFormat !== void 0 && (d.internalFormat = a.internalFormat),
          a.type !== void 0 && (d.type = a.type),
          a.colorSpace !== void 0 && (d.colorSpace = a.colorSpace),
          a.minFilter !== void 0 && (d.minFilter = r(a.minFilter, WT)),
          a.magFilter !== void 0 && (d.magFilter = r(a.magFilter, WT)),
          a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (d.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (d.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (d.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (d.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (d.compareFunction = a.compareFunction),
          a.userData !== void 0 && (d.userData = a.userData),
          (i[a.uuid] = d);
      }
    return i;
  }
  parseObject(e, t, r, i, o) {
    let s;
    function a(g) {
      return (
        t[g] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", g),
        t[g]
      );
    }
    function u(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const y = [];
          for (let x = 0, S = g.length; x < S; x++) {
            const _ = g[x];
            r[_] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", _),
              y.push(r[_]);
          }
          return y;
        }
        return (
          r[g] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", g),
          r[g]
        );
      }
    }
    function c(g) {
      return (
        i[g] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", g),
        i[g]
      );
    }
    let d, m;
    switch (e.type) {
      case "Scene":
        (s = new gy()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (s.background = new St(e.background))
              : (s.background = c(e.background))),
          e.environment !== void 0 && (s.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (s.fog = new ix(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (s.fog = new rx(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (s.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (s.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (s.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            s.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (s.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            s.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (s = new Nr(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (s.focus = e.focus),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (s = new Xu(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        s = new pP(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (s = new hP(e.color, e.intensity)), (s.target = e.target || "");
        break;
      case "PointLight":
        s = new dP(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        s = new mP(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (s = new fP(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (s.target = e.target || "");
        break;
      case "HemisphereLight":
        s = new cP(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        s = new vP().fromJSON(e);
        break;
      case "SkinnedMesh":
        (d = a(e.geometry)),
          (m = u(e.material)),
          (s = new OR(d, m)),
          e.bindMode !== void 0 && (s.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (s.skeleton = e.skeleton);
        break;
      case "Mesh":
        (d = a(e.geometry)), (m = u(e.material)), (s = new ur(d, m));
        break;
      case "InstancedMesh":
        (d = a(e.geometry)), (m = u(e.material));
        const g = e.count,
          y = e.instanceMatrix,
          x = e.instanceColor;
        (s = new NR(d, m, g)),
          (s.instanceMatrix = new Rf(new Float32Array(y.array), 16)),
          x !== void 0 &&
            (s.instanceColor = new Rf(new Float32Array(x.array), x.itemSize));
        break;
      case "BatchedMesh":
        (d = a(e.geometry)),
          (m = u(e.material)),
          (s = new UR(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            m
          )),
          (s.geometry = d),
          (s.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (s.sortObjects = e.sortObjects),
          (s._drawRanges = e.drawRanges),
          (s._reservedRanges = e.reservedRanges),
          (s._visibility = e.visibility),
          (s._active = e.active),
          (s._bounds = e.bounds.map((S) => {
            const _ = new ci();
            _.min.fromArray(S.boxMin), _.max.fromArray(S.boxMax);
            const w = new fi();
            return (
              (w.radius = S.sphereRadius),
              w.center.fromArray(S.sphereCenter),
              {
                boxInitialized: S.boxInitialized,
                box: _,
                sphereInitialized: S.sphereInitialized,
                sphere: w,
              }
            );
          })),
          (s._maxInstanceCount = e.maxInstanceCount),
          (s._maxVertexCount = e.maxVertexCount),
          (s._maxIndexCount = e.maxIndexCount),
          (s._geometryInitialized = e.geometryInitialized),
          (s._geometryCount = e.geometryCount),
          (s._matricesTexture = c(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (s._colorsTexture = c(e.colorsTexture.uuid));
        break;
      case "LOD":
        s = new kR();
        break;
      case "Line":
        s = new Ju(a(e.geometry), u(e.material));
        break;
      case "LineLoop":
        s = new FR(a(e.geometry), u(e.material));
        break;
      case "LineSegments":
        s = new nl(a(e.geometry), u(e.material));
        break;
      case "PointCloud":
      case "Points":
        s = new BR(a(e.geometry), u(e.material));
        break;
      case "Sprite":
        s = new DR(u(e.material));
        break;
      case "Group":
        s = new vh();
        break;
      case "Bone":
        s = new Bw();
        break;
      default:
        s = new wn();
    }
    if (
      ((s.uuid = e.uuid),
      e.name !== void 0 && (s.name = e.name),
      e.matrix !== void 0
        ? (s.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (s.matrixAutoUpdate = e.matrixAutoUpdate),
          s.matrixAutoUpdate &&
            s.matrix.decompose(s.position, s.quaternion, s.scale))
        : (e.position !== void 0 && s.position.fromArray(e.position),
          e.rotation !== void 0 && s.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && s.scale.fromArray(e.scale)),
      e.up !== void 0 && s.up.fromArray(e.up),
      e.castShadow !== void 0 && (s.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (s.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (s.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          s.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (s.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (s.visible = e.visible),
      e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder),
      e.userData !== void 0 && (s.userData = e.userData),
      e.layers !== void 0 && (s.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const g = e.children;
      for (let y = 0; y < g.length; y++)
        s.add(this.parseObject(g[y], t, r, i, o));
    }
    if (e.animations !== void 0) {
      const g = e.animations;
      for (let y = 0; y < g.length; y++) {
        const x = g[y];
        s.animations.push(o[x]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate);
      const g = e.levels;
      for (let y = 0; y < g.length; y++) {
        const x = g[y],
          S = s.getObjectByProperty("uuid", x.object);
        S !== void 0 && s.addLevel(S, x.distance, x.hysteresis);
      }
    }
    return s;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = t[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const r = t.target,
          i = e.getObjectByProperty("uuid", r);
        i !== void 0 ? (t.target = i) : (t.target = new wn());
      }
    });
  }
}
const tW = {
    UVMapping: Gy,
    CubeReflectionMapping: Hl,
    CubeRefractionMapping: Zu,
    EquirectangularReflectionMapping: km,
    EquirectangularRefractionMapping: Om,
    CubeUVReflectionMapping: Vh,
  },
  VT = {
    RepeatWrapping: Nm,
    ClampToEdgeWrapping: Ls,
    MirroredRepeatWrapping: Um,
  },
  WT = {
    NearestFilter: wi,
    NearestMipmapNearestFilter: xw,
    NearestMipmapLinearFilter: ph,
    LinearFilter: Cr,
    LinearMipmapNearestFilter: pm,
    LinearMipmapLinearFilter: Xa,
  };
class nW extends Vo {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Nl.get(e);
    if (s !== void 0) {
      if ((o.manager.itemStart(e), s.then)) {
        s.then((c) => {
          t && t(c), o.manager.itemEnd(e);
        }).catch((c) => {
          i && i(c);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const u = fetch(e, a)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(o.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (c) {
        return Nl.add(e, c), t && t(c), o.manager.itemEnd(e), c;
      })
      .catch(function (c) {
        i && i(c), Nl.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
      });
    Nl.add(e, u), o.manager.itemStart(e);
  }
}
let r0;
class eb {
  static getContext() {
    return (
      r0 === void 0 &&
        (r0 = new (window.AudioContext || window.webkitAudioContext)()),
      r0
    );
  }
  static setContext(e) {
    r0 = e;
  }
}
class rW extends Vo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this,
      s = new Wl(this.manager);
    s.setResponseType("arraybuffer"),
      s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (u) {
          try {
            const c = u.slice(0);
            eb.getContext()
              .decodeAudioData(c, function (m) {
                t(m);
              })
              .catch(a);
          } catch (c) {
            a(c);
          }
        },
        r,
        i
      );
    function a(u) {
      i ? i(u) : console.error(u), o.manager.itemError(e);
    }
  }
}
const GT = new Gt(),
  jT = new Gt(),
  $c = new Gt();
class iW {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Nr()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Nr()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        $c.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        o = (i * t.near) / t.focus,
        s = (t.near * Math.tan(_f * t.fov * 0.5)) / t.zoom;
      let a, u;
      (jT.elements[12] = -i),
        (GT.elements[12] = i),
        (a = -s * t.aspect + o),
        (u = s * t.aspect + o),
        ($c.elements[0] = (2 * t.near) / (u - a)),
        ($c.elements[8] = (u + a) / (u - a)),
        this.cameraL.projectionMatrix.copy($c),
        (a = -s * t.aspect - o),
        (u = s * t.aspect - o),
        ($c.elements[0] = (2 * t.near) / (u - a)),
        ($c.elements[8] = (u + a) / (u - a)),
        this.cameraR.projectionMatrix.copy($c);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(jT),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(GT);
  }
}
class tb {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = $T()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = $T();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function $T() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Xc = new oe(),
  XT = new io(),
  oW = new oe(),
  Yc = new oe();
class sW extends wn {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = eb.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new tb());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Xc, XT, oW),
      Yc.set(0, 0, -1).applyQuaternion(XT),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Xc.x, i),
        t.positionY.linearRampToValueAtTime(Xc.y, i),
        t.positionZ.linearRampToValueAtTime(Xc.z, i),
        t.forwardX.linearRampToValueAtTime(Yc.x, i),
        t.forwardY.linearRampToValueAtTime(Yc.y, i),
        t.forwardZ.linearRampToValueAtTime(Yc.z, i),
        t.upX.linearRampToValueAtTime(r.x, i),
        t.upY.linearRampToValueAtTime(r.y, i),
        t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(Xc.x, Xc.y, Xc.z),
        t.setOrientation(Yc.x, Yc.y, Yc.z, r.x, r.y, r.z);
  }
}
class xP extends wn {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const qc = new oe(),
  YT = new io(),
  aW = new oe(),
  Kc = new oe();
class lW extends xP {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(qc, YT, aW), Kc.set(0, 0, 1).applyQuaternion(YT);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(qc.x, r),
        t.positionY.linearRampToValueAtTime(qc.y, r),
        t.positionZ.linearRampToValueAtTime(qc.z, r),
        t.orientationX.linearRampToValueAtTime(Kc.x, r),
        t.orientationY.linearRampToValueAtTime(Kc.y, r),
        t.orientationZ.linearRampToValueAtTime(Kc.z, r);
    } else t.setPosition(qc.x, qc.y, qc.z), t.setOrientation(Kc.x, Kc.y, Kc.z);
  }
}
class uW {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++) e += t[r];
    return e / t.length;
  }
}
class _P {
  constructor(e, t, r) {
    (this.binding = e), (this.valueSize = r);
    let i, o, s;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (o = this._slerpAdditive),
          (s = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (o = this._select),
          (s = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (o = this._lerpAdditive),
          (s = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = o),
      (this._setIdentity = s),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const r = this.buffer,
      i = this.valueSize,
      o = e * i + i;
    let s = this.cumulativeWeight;
    if (s === 0) {
      for (let a = 0; a !== i; ++a) r[o + a] = r[a];
      s = t;
    } else {
      s += t;
      const a = t / s;
      this._mixBufferRegion(r, o, 0, a, i);
    }
    this.cumulativeWeight = s;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      r = this.buffer,
      i = e * t + t,
      o = this.cumulativeWeight,
      s = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), o < 1)
    ) {
      const u = t * this._origIndex;
      this._mixBufferRegion(r, i, u, 1 - o, t);
    }
    s > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let u = t, c = t + t; u !== c; ++u)
      if (r[u] !== r[u + t]) {
        a.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(t, i);
    for (let o = r, s = i; o !== s; ++o) t[o] = t[i + (o % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let r = e; r < t; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, o) {
    if (i >= 0.5) for (let s = 0; s !== o; ++s) e[t + s] = e[r + s];
  }
  _slerp(e, t, r, i) {
    io.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, o) {
    const s = this._workIndex * o;
    io.multiplyQuaternionsFlat(e, s, e, t, e, r),
      io.slerpFlat(e, t, e, t, e, s, i);
  }
  _lerp(e, t, r, i, o) {
    const s = 1 - i;
    for (let a = 0; a !== o; ++a) {
      const u = t + a;
      e[u] = e[u] * s + e[r + a] * i;
    }
  }
  _lerpAdditive(e, t, r, i, o) {
    for (let s = 0; s !== o; ++s) {
      const a = t + s;
      e[a] = e[a] + e[r + s] * i;
    }
  }
}
const nb = "\\[\\]\\.:\\/",
  cW = new RegExp("[" + nb + "]", "g"),
  rb = "[^" + nb + "]",
  fW = "[^" + nb.replace("\\.", "") + "]",
  dW = /((?:WC+[\/:])*)/.source.replace("WC", rb),
  hW = /(WCOD+)?/.source.replace("WCOD", fW),
  pW = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", rb),
  mW = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", rb),
  gW = new RegExp("^" + dW + hW + pW + mW + "$"),
  vW = ["material", "materials", "bones", "map"];
class yW {
  constructor(e, t, r) {
    const i = r || _n.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class _n {
  constructor(e, t, r) {
    (this.path = t),
      (this.parsedPath = r || _n.parseTrackName(t)),
      (this.node = _n.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup
      ? new _n.Composite(e, t, r)
      : new _n(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(cW, "");
  }
  static parseTrackName(e) {
    const t = gW.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = r.nodeName.substring(i + 1);
      vW.indexOf(o) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = o));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (o) {
          for (let s = 0; s < o.length; s++) {
            const a = o[s];
            if (a.name === t || a.uuid === t) return a;
            const u = r(a.children);
            if (u) return u;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      r = t.objectName,
      i = t.propertyName;
    let o = t.propertyIndex;
    if (
      (e || ((e = _n.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let c = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let d = 0; d < e.length; d++)
            if (e[d].name === c) {
              c = d;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const s = e[i];
    if (s === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 &&
          (o = e.morphTargetDictionary[o]);
      }
      (u = this.BindingType.ArrayElement),
        (this.resolvedProperty = s),
        (this.propertyIndex = o);
    } else
      s.fromArray !== void 0 && s.toArray !== void 0
        ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
        : Array.isArray(s)
        ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = s))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[u]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[u][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
_n.Composite = yW;
_n.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
_n.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
_n.prototype.GetterByBindingType = [
  _n.prototype._getValue_direct,
  _n.prototype._getValue_array,
  _n.prototype._getValue_arrayElement,
  _n.prototype._getValue_toArray,
];
_n.prototype.SetterByBindingTypeAndVersioning = [
  [
    _n.prototype._setValue_direct,
    _n.prototype._setValue_direct_setNeedsUpdate,
    _n.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    _n.prototype._setValue_array,
    _n.prototype._setValue_array_setNeedsUpdate,
    _n.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    _n.prototype._setValue_arrayElement,
    _n.prototype._setValue_arrayElement_setNeedsUpdate,
    _n.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    _n.prototype._setValue_fromArray,
    _n.prototype._setValue_fromArray_setNeedsUpdate,
    _n.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class xW {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = us()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      o = this._bindings,
      s = o.length;
    let a,
      u = e.length,
      c = this.nCachedObjects_;
    for (let d = 0, m = arguments.length; d !== m; ++d) {
      const g = arguments[d],
        y = g.uuid;
      let x = t[y];
      if (x === void 0) {
        (x = u++), (t[y] = x), e.push(g);
        for (let S = 0, _ = s; S !== _; ++S) o[S].push(new _n(g, r[S], i[S]));
      } else if (x < c) {
        a = e[x];
        const S = --c,
          _ = e[S];
        (t[_.uuid] = x), (e[x] = _), (t[y] = S), (e[S] = g);
        for (let w = 0, T = s; w !== T; ++w) {
          const M = o[w],
            A = M[S];
          let R = M[x];
          (M[x] = A), R === void 0 && (R = new _n(g, r[w], i[w])), (M[S] = R);
        }
      } else
        e[x] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_;
    for (let s = 0, a = arguments.length; s !== a; ++s) {
      const u = arguments[s],
        c = u.uuid,
        d = t[c];
      if (d !== void 0 && d >= o) {
        const m = o++,
          g = e[m];
        (t[g.uuid] = d), (e[d] = g), (t[c] = m), (e[m] = u);
        for (let y = 0, x = i; y !== x; ++y) {
          const S = r[y],
            _ = S[m],
            w = S[d];
          (S[d] = _), (S[m] = w);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_,
      s = e.length;
    for (let a = 0, u = arguments.length; a !== u; ++a) {
      const c = arguments[a],
        d = c.uuid,
        m = t[d];
      if (m !== void 0)
        if ((delete t[d], m < o)) {
          const g = --o,
            y = e[g],
            x = --s,
            S = e[x];
          (t[y.uuid] = m), (e[m] = y), (t[S.uuid] = g), (e[g] = S), e.pop();
          for (let _ = 0, w = i; _ !== w; ++_) {
            const T = r[_],
              M = T[g],
              A = T[x];
            (T[m] = M), (T[g] = A), T.pop();
          }
        } else {
          const g = --s,
            y = e[g];
          g > 0 && (t[y.uuid] = m), (e[m] = y), e.pop();
          for (let x = 0, S = i; x !== S; ++x) {
            const _ = r[x];
            (_[m] = _[g]), _.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const s = this._paths,
      a = this._parsedPaths,
      u = this._objects,
      c = u.length,
      d = this.nCachedObjects_,
      m = new Array(c);
    (i = o.length), (r[e] = i), s.push(e), a.push(t), o.push(m);
    for (let g = d, y = u.length; g !== y; ++g) {
      const x = u[g];
      m[g] = new _n(x, e, t);
    }
    return m;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      r = t[e];
    if (r !== void 0) {
      const i = this._paths,
        o = this._parsedPaths,
        s = this._bindings,
        a = s.length - 1,
        u = s[a],
        c = e[a];
      (t[c] = r),
        (s[r] = u),
        s.pop(),
        (o[r] = o[a]),
        o.pop(),
        (i[r] = i[a]),
        i.pop();
    }
  }
}
class SP {
  constructor(e, t, r = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = r),
      (this.blendMode = i);
    const o = t.tracks,
      s = o.length,
      a = new Array(s),
      u = { endingStart: hf, endingEnd: hf };
    for (let c = 0; c !== s; ++c) {
      const d = o[c].createInterpolant(null);
      (a[c] = d), (d.settings = u);
    }
    (this._interpolantSettings = u),
      (this._interpolants = a),
      (this._propertyBindings = new Array(s)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = iR),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if ((e.fadeOut(t), this.fadeIn(t), r)) {
      const i = this._clip.duration,
        o = e._clip.duration,
        s = o / i,
        a = i / o;
      e.warp(1, s, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer,
      o = i.time,
      s = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const u = a.parameterPositions,
      c = a.sampleValues;
    return (u[0] = o), (u[1] = o + r), (c[0] = e / s), (c[1] = t / s), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const u = (e - o) * r;
      u < 0 || r === 0 ? (t = 0) : ((this._startTime = null), (t = r * u));
    }
    t *= this._updateTimeScale(e);
    const s = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const u = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case Rw:
          for (let d = 0, m = u.length; d !== m; ++d)
            u[d].evaluate(s), c[d].accumulateAdditive(a);
          break;
        case Zy:
        default:
          for (let d = 0, m = u.length; d !== m; ++d)
            u[d].evaluate(s), c[d].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      o = this._loopCount;
    const s = r === oR;
    if (e === 0) return o === -1 ? i : s && (o & 1) === 1 ? t - i : i;
    if (r === rR) {
      o === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (o === -1 &&
          (e >= 0
            ? ((o = 0), this._setEndings(!0, this.repetitions === 0, s))
            : this._setEndings(this.repetitions === 0, !0, s)),
        i >= t || i < 0)
      ) {
        const a = Math.floor(i / t);
        (i -= t * a), (o += Math.abs(a));
        const u = this.repetitions - o;
        if (u <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (u === 1) {
            const c = e < 0;
            this._setEndings(c, !c, s);
          } else this._setEndings(!1, !1, s);
          (this._loopCount = o),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = i;
      if (s && (o & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = pf), (i.endingEnd = pf))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? pf : hf)
          : (i.endingStart = Bm),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? pf : hf) : (i.endingEnd = Bm));
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer,
      o = i.time;
    let s = this._weightInterpolant;
    s === null &&
      ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
    const a = s.parameterPositions,
      u = s.sampleValues;
    return (a[0] = o), (u[0] = t), (a[1] = o + e), (u[1] = r), this;
  }
}
const _W = new Float32Array(1);
class SW extends $l {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      o = i.length,
      s = e._propertyBindings,
      a = e._interpolants,
      u = r.uuid,
      c = this._bindingsByRootAndName;
    let d = c[u];
    d === void 0 && ((d = {}), (c[u] = d));
    for (let m = 0; m !== o; ++m) {
      const g = i[m],
        y = g.name;
      let x = d[y];
      if (x !== void 0) ++x.referenceCount, (s[m] = x);
      else {
        if (((x = s[m]), x !== void 0)) {
          x._cacheIndex === null &&
            (++x.referenceCount, this._addInactiveBinding(x, u, y));
          continue;
        }
        const S = t && t._propertyBindings[m].binding.parsedPath;
        (x = new _P(_n.create(r, y, S), g.ValueTypeName, g.getValueSize())),
          ++x.referenceCount,
          this._addInactiveBinding(x, u, y),
          (s[m] = x);
      }
      a[m].resultBuffer = x.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          o = this._actionsByClip[i];
        this._bindAction(e, o && o.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        --o.useCount === 0 &&
          (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions,
      o = this._actionsByClip;
    let s = o[t];
    if (s === void 0)
      (s = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (o[t] = s);
    else {
      const a = s.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      r = t[t.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (t[i] = r), t.pop(), (e._cacheIndex = null);
    const o = e._clip.uuid,
      s = this._actionsByClip,
      a = s[o],
      u = a.knownActions,
      c = u[u.length - 1],
      d = e._byClipCacheIndex;
    (c._byClipCacheIndex = d),
      (u[d] = c),
      u.pop(),
      (e._byClipCacheIndex = null);
    const m = a.actionByRoot,
      g = (e._localRoot || this._root).uuid;
    delete m[g],
      u.length === 0 && delete s[o],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const o = t[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName,
      o = this._bindings;
    let s = i[t];
    s === void 0 && ((s = {}), (i[t] = s)),
      (s[r] = e),
      (e._cacheIndex = o.length),
      o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      o = r.path,
      s = this._bindingsByRootAndName,
      a = s[i],
      u = t[t.length - 1],
      c = e._cacheIndex;
    (u._cacheIndex = c),
      (t[c] = u),
      t.pop(),
      delete a[o],
      Object.keys(a).length === 0 && delete s[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let r = e[t];
    return (
      r === void 0 &&
        ((r = new Kw(new Float32Array(2), new Float32Array(2), 1, _W)),
        (r.__cacheIndex = t),
        (e[t] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      o = t[i];
    (e.__cacheIndex = i), (t[i] = e), (o.__cacheIndex = r), (t[r] = o);
  }
  clipAction(e, t, r) {
    const i = t || this._root,
      o = i.uuid;
    let s = typeof e == "string" ? Qm.findByName(i, e) : e;
    const a = s !== null ? s.uuid : e,
      u = this._actionsByClip[a];
    let c = null;
    if (
      (r === void 0 && (s !== null ? (r = s.blendMode) : (r = Zy)),
      u !== void 0)
    ) {
      const m = u.actionByRoot[o];
      if (m !== void 0 && m.blendMode === r) return m;
      (c = u.knownActions[0]), s === null && (s = c._clip);
    }
    if (s === null) return null;
    const d = new SP(this, s, t, r);
    return this._bindAction(d, c), this._addInactiveAction(d, a, o), d;
  }
  existingAction(e, t) {
    const r = t || this._root,
      i = r.uuid,
      o = typeof e == "string" ? Qm.findByName(r, e) : e,
      s = o ? o.uuid : e,
      a = this._actionsByClip[s];
    return (a !== void 0 && a.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      o = Math.sign(e),
      s = (this._accuIndex ^= 1);
    for (let c = 0; c !== r; ++c) t[c]._update(i, e, o, s);
    const a = this._bindings,
      u = this._nActiveBindings;
    for (let c = 0; c !== u; ++c) a[c].apply(s);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      o = i[r];
    if (o !== void 0) {
      const s = o.knownActions;
      for (let a = 0, u = s.length; a !== u; ++a) {
        const c = s[a];
        this._deactivateAction(c);
        const d = c._cacheIndex,
          m = t[t.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (m._cacheIndex = d),
          (t[d] = m),
          t.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      r = this._actionsByClip;
    for (const s in r) {
      const a = r[s].actionByRoot,
        u = a[t];
      u !== void 0 &&
        (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const i = this._bindingsByRootAndName,
      o = i[t];
    if (o !== void 0)
      for (const s in o) {
        const a = o[s];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class ib {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new ib(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let wW = 0;
class bW extends $l {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: wW++ }),
      (this.name = ""),
      (this.usage = Wm),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = Array.isArray(t[r]) ? t[r] : [t[r]];
      for (let s = 0; s < o.length; s++) this.uniforms.push(o[s].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _y extends ox {
  constructor(e, t, r = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class MW {
  constructor(e, t, r, i, o) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const qT = new Gt();
class wP {
  constructor(e, t, r = 0, i = 1 / 0) {
    (this.ray = new Df(e, t)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Sf()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      qT.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(qT),
      this
    );
  }
  intersectObject(e, t = !0, r = []) {
    return ES(e, this, r, t), r.sort(KT), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, o = e.length; i < o; i++) ES(e[i], this, r, t);
    return r.sort(KT), r;
  }
}
function KT(n, e) {
  return n.distance - e.distance;
}
function ES(n, e, t, r) {
  let i = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (i = !1),
    i === !0 && r === !0)
  ) {
    const o = n.children;
    for (let s = 0, a = o.length; s < a; s++) ES(o[s], e, t, !0);
  }
}
class TS {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(Tr(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class EW {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ob {
  constructor(e, t, r, i) {
    (ob.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 4; r++) this.elements[r] = e[r + t];
    return this;
  }
  set(e, t, r, i) {
    const o = this.elements;
    return (o[0] = e), (o[2] = t), (o[1] = r), (o[3] = i), this;
  }
}
const ZT = new tt();
class TW {
  constructor(e = new tt(1 / 0, 1 / 0), t = new tt(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = ZT.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ZT).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const JT = new oe(),
  i0 = new oe();
class bP {
  constructor(e = new oe(), t = new oe()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    JT.subVectors(e, this.start), i0.subVectors(this.end, this.start);
    const r = i0.dot(i0);
    let o = i0.dot(JT) / r;
    return t && (o = Tr(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const QT = new oe();
class CW extends wn {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const r = new sn(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let s = 0, a = 1, u = 32; s < u; s++, a++) {
      const c = (s / u) * Math.PI * 2,
        d = (a / u) * Math.PI * 2;
      i.push(Math.cos(c), Math.sin(c), 1, Math.cos(d), Math.sin(d), 1);
    }
    r.setAttribute("position", new Pt(i, 3));
    const o = new _o({ fog: !1, toneMapped: !1 });
    (this.cone = new nl(r, o)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      QT.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(QT),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const zu = new oe(),
  o0 = new Gt(),
  _1 = new Gt();
class AW extends nl {
  constructor(e) {
    const t = MP(e),
      r = new sn(),
      i = [],
      o = [],
      s = new St(0, 0, 1),
      a = new St(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const d = t[c];
      d.parent &&
        d.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        o.push(s.r, s.g, s.b),
        o.push(a.r, a.g, a.b));
    }
    r.setAttribute("position", new Pt(i, 3)),
      r.setAttribute("color", new Pt(o, 3));
    const u = new _o({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, u),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    _1.copy(this.root.matrixWorld).invert();
    for (let o = 0, s = 0; o < t.length; o++) {
      const a = t[o];
      a.parent &&
        a.parent.isBone &&
        (o0.multiplyMatrices(_1, a.matrixWorld),
        zu.setFromMatrixPosition(o0),
        i.setXYZ(s, zu.x, zu.y, zu.z),
        o0.multiplyMatrices(_1, a.parent.matrixWorld),
        zu.setFromMatrixPosition(o0),
        i.setXYZ(s + 1, zu.x, zu.y, zu.z),
        (s += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function MP(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, MP(n.children[t]));
  return e;
}
class RW extends ur {
  constructor(e, t, r) {
    const i = new pg(t, 4, 2),
      o = new Xl({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const PW = new oe(),
  e2 = new St(),
  t2 = new St();
class IW extends wn {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new hg(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new Xl({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"),
      s = new Float32Array(o.count * 3);
    i.setAttribute("color", new Gn(s, 3)),
      this.add(new ur(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      e2.copy(this.light.color), t2.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const o = r < i / 2 ? e2 : t2;
        t.setXYZ(r, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(PW.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class LW extends nl {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    (r = new St(r)), (i = new St(i));
    const o = t / 2,
      s = e / t,
      a = e / 2,
      u = [],
      c = [];
    for (let g = 0, y = 0, x = -a; g <= t; g++, x += s) {
      u.push(-a, 0, x, a, 0, x), u.push(x, 0, -a, x, 0, a);
      const S = g === o ? r : i;
      S.toArray(c, y),
        (y += 3),
        S.toArray(c, y),
        (y += 3),
        S.toArray(c, y),
        (y += 3),
        S.toArray(c, y),
        (y += 3);
    }
    const d = new sn();
    d.setAttribute("position", new Pt(u, 3)),
      d.setAttribute("color", new Pt(c, 3));
    const m = new _o({ vertexColors: !0, toneMapped: !1 });
    super(d, m), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class DW extends nl {
  constructor(e = 10, t = 16, r = 8, i = 64, o = 4473924, s = 8947848) {
    (o = new St(o)), (s = new St(s));
    const a = [],
      u = [];
    if (t > 1)
      for (let m = 0; m < t; m++) {
        const g = (m / t) * (Math.PI * 2),
          y = Math.sin(g) * e,
          x = Math.cos(g) * e;
        a.push(0, 0, 0), a.push(y, 0, x);
        const S = m & 1 ? o : s;
        u.push(S.r, S.g, S.b), u.push(S.r, S.g, S.b);
      }
    for (let m = 0; m < r; m++) {
      const g = m & 1 ? o : s,
        y = e - (e / r) * m;
      for (let x = 0; x < i; x++) {
        let S = (x / i) * (Math.PI * 2),
          _ = Math.sin(S) * y,
          w = Math.cos(S) * y;
        a.push(_, 0, w),
          u.push(g.r, g.g, g.b),
          (S = ((x + 1) / i) * (Math.PI * 2)),
          (_ = Math.sin(S) * y),
          (w = Math.cos(S) * y),
          a.push(_, 0, w),
          u.push(g.r, g.g, g.b);
      }
    }
    const c = new sn();
    c.setAttribute("position", new Pt(a, 3)),
      c.setAttribute("color", new Pt(u, 3));
    const d = new _o({ vertexColors: !0, toneMapped: !1 });
    super(c, d), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const n2 = new oe(),
  s0 = new oe(),
  r2 = new oe();
class kW extends wn {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new sn();
    i.setAttribute(
      "position",
      new Pt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const o = new _o({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Ju(i, o)),
      this.add(this.lightPlane),
      (i = new sn()),
      i.setAttribute("position", new Pt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Ju(i, o)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      n2.setFromMatrixPosition(this.light.matrixWorld),
      s0.setFromMatrixPosition(this.light.target.matrixWorld),
      r2.subVectors(s0, n2),
      this.lightPlane.lookAt(s0),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(s0),
      (this.targetLine.scale.z = r2.length());
  }
}
const a0 = new oe(),
  br = new ug();
class OW extends nl {
  constructor(e) {
    const t = new sn(),
      r = new _o({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      o = [],
      s = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(x, S) {
      u(x), u(S);
    }
    function u(x) {
      i.push(0, 0, 0),
        o.push(0, 0, 0),
        s[x] === void 0 && (s[x] = []),
        s[x].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Pt(i, 3)),
      t.setAttribute("color", new Pt(o, 3)),
      super(t, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = s),
      this.update();
    const c = new St(16755200),
      d = new St(16711680),
      m = new St(43775),
      g = new St(16777215),
      y = new St(3355443);
    this.setColors(c, d, m, g, y);
  }
  setColors(e, t, r, i, o) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, r.r, r.g, r.b),
      a.setXYZ(33, r.r, r.g, r.b),
      a.setXYZ(34, r.r, r.g, r.b),
      a.setXYZ(35, r.r, r.g, r.b),
      a.setXYZ(36, r.r, r.g, r.b),
      a.setXYZ(37, r.r, r.g, r.b),
      a.setXYZ(38, i.r, i.g, i.b),
      a.setXYZ(39, i.r, i.g, i.b),
      a.setXYZ(40, o.r, o.g, o.b),
      a.setXYZ(41, o.r, o.g, o.b),
      a.setXYZ(42, o.r, o.g, o.b),
      a.setXYZ(43, o.r, o.g, o.b),
      a.setXYZ(44, o.r, o.g, o.b),
      a.setXYZ(45, o.r, o.g, o.b),
      a.setXYZ(46, o.r, o.g, o.b),
      a.setXYZ(47, o.r, o.g, o.b),
      a.setXYZ(48, o.r, o.g, o.b),
      a.setXYZ(49, o.r, o.g, o.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      r = 1,
      i = 1;
    br.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Or("c", t, e, br, 0, 0, -1),
      Or("t", t, e, br, 0, 0, 1),
      Or("n1", t, e, br, -1, -1, -1),
      Or("n2", t, e, br, r, -1, -1),
      Or("n3", t, e, br, -1, i, -1),
      Or("n4", t, e, br, r, i, -1),
      Or("f1", t, e, br, -1, -1, 1),
      Or("f2", t, e, br, r, -1, 1),
      Or("f3", t, e, br, -1, i, 1),
      Or("f4", t, e, br, r, i, 1),
      Or("u1", t, e, br, r * 0.7, i * 1.1, -1),
      Or("u2", t, e, br, -1 * 0.7, i * 1.1, -1),
      Or("u3", t, e, br, 0, i * 2, -1),
      Or("cf1", t, e, br, -1, 0, 1),
      Or("cf2", t, e, br, r, 0, 1),
      Or("cf3", t, e, br, 0, -1, 1),
      Or("cf4", t, e, br, 0, i, 1),
      Or("cn1", t, e, br, -1, 0, -1),
      Or("cn2", t, e, br, r, 0, -1),
      Or("cn3", t, e, br, 0, -1, -1),
      Or("cn4", t, e, br, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Or(n, e, t, r, i, o, s) {
  a0.set(i, o, s).unproject(r);
  const a = e[n];
  if (a !== void 0) {
    const u = t.getAttribute("position");
    for (let c = 0, d = a.length; c < d; c++) u.setXYZ(a[c], a0.x, a0.y, a0.z);
  }
}
const l0 = new ci();
class NW extends nl {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      o = new sn();
    o.setIndex(new Gn(r, 1)),
      o.setAttribute("position", new Gn(i, 3)),
      super(o, new _o({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && l0.setFromObject(this.object),
      l0.isEmpty())
    )
      return;
    const t = l0.min,
      r = l0.max,
      i = this.geometry.attributes.position,
      o = i.array;
    (o[0] = r.x),
      (o[1] = r.y),
      (o[2] = r.z),
      (o[3] = t.x),
      (o[4] = r.y),
      (o[5] = r.z),
      (o[6] = t.x),
      (o[7] = t.y),
      (o[8] = r.z),
      (o[9] = r.x),
      (o[10] = t.y),
      (o[11] = r.z),
      (o[12] = r.x),
      (o[13] = r.y),
      (o[14] = t.z),
      (o[15] = t.x),
      (o[16] = r.y),
      (o[17] = t.z),
      (o[18] = t.x),
      (o[19] = t.y),
      (o[20] = t.z),
      (o[21] = r.x),
      (o[22] = t.y),
      (o[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class UW extends nl {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      o = new sn();
    o.setIndex(new Gn(r, 1)),
      o.setAttribute("position", new Pt(i, 3)),
      super(o, new _o({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class FW extends Ju {
  constructor(e, t = 1, r = 16776960) {
    const i = r,
      o = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      s = new sn();
    s.setAttribute("position", new Pt(o, 3)),
      s.computeBoundingSphere(),
      super(s, new _o({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      u = new sn();
    u.setAttribute("position", new Pt(a, 3)),
      u.computeBoundingSphere(),
      this.add(
        new ur(
          u,
          new Xl({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const i2 = new oe();
let u0, S1;
class BW extends wn {
  constructor(
    e = new oe(0, 0, 1),
    t = new oe(0, 0, 0),
    r = 1,
    i = 16776960,
    o = r * 0.2,
    s = o * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      u0 === void 0 &&
        ((u0 = new sn()),
        u0.setAttribute("position", new Pt([0, 0, 0, 0, 1, 0], 3)),
        (S1 = new jh(0, 0.5, 1, 5, 1)),
        S1.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Ju(u0, new _o({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new ur(S1, new Xl({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, o, s);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      i2.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(i2, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, t, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class zW extends nl {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new sn();
    i.setAttribute("position", new Pt(t, 3)),
      i.setAttribute("color", new Pt(r, 3));
    const o = new _o({ vertexColors: !0, toneMapped: !1 });
    super(i, o), (this.type = "AxesHelper");
  }
  setColors(e, t, r) {
    const i = new St(),
      o = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(o, 0),
      i.toArray(o, 3),
      i.set(t),
      i.toArray(o, 6),
      i.toArray(o, 9),
      i.set(r),
      i.toArray(o, 12),
      i.toArray(o, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class HW {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new St()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Xm()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, s) {
    return this.currentPath.bezierCurveTo(e, t, r, i, o, s), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(w) {
      const T = [];
      for (let M = 0, A = w.length; M < A; M++) {
        const R = w[M],
          D = new wf();
        (D.curves = R.curves), T.push(D);
      }
      return T;
    }
    function r(w, T) {
      const M = T.length;
      let A = !1;
      for (let R = M - 1, D = 0; D < M; R = D++) {
        let P = T[R],
          U = T[D],
          O = U.x - P.x,
          L = U.y - P.y;
        if (Math.abs(L) > Number.EPSILON) {
          if (
            (L < 0 && ((P = T[D]), (O = -O), (U = T[R]), (L = -L)),
            w.y < P.y || w.y > U.y)
          )
            continue;
          if (w.y === P.y) {
            if (w.x === P.x) return !0;
          } else {
            const H = L * (w.x - P.x) - O * (w.y - P.y);
            if (H === 0) return !0;
            if (H < 0) continue;
            A = !A;
          }
        } else {
          if (w.y !== P.y) continue;
          if ((U.x <= w.x && w.x <= P.x) || (P.x <= w.x && w.x <= U.x))
            return !0;
        }
      }
      return A;
    }
    const i = Qa.isClockWise,
      o = this.subPaths;
    if (o.length === 0) return [];
    let s, a, u;
    const c = [];
    if (o.length === 1)
      return (a = o[0]), (u = new wf()), (u.curves = a.curves), c.push(u), c;
    let d = !i(o[0].getPoints());
    d = e ? !d : d;
    const m = [],
      g = [];
    let y = [],
      x = 0,
      S;
    (g[x] = void 0), (y[x] = []);
    for (let w = 0, T = o.length; w < T; w++)
      (a = o[w]),
        (S = a.getPoints()),
        (s = i(S)),
        (s = e ? !s : s),
        s
          ? (!d && g[x] && x++,
            (g[x] = { s: new wf(), p: S }),
            (g[x].s.curves = a.curves),
            d && x++,
            (y[x] = []))
          : y[x].push({ h: a, p: S[0] });
    if (!g[0]) return t(o);
    if (g.length > 1) {
      let w = !1,
        T = 0;
      for (let M = 0, A = g.length; M < A; M++) m[M] = [];
      for (let M = 0, A = g.length; M < A; M++) {
        const R = y[M];
        for (let D = 0; D < R.length; D++) {
          const P = R[D];
          let U = !0;
          for (let O = 0; O < g.length; O++)
            r(P.p, g[O].p) &&
              (M !== O && T++, U ? ((U = !1), m[O].push(P)) : (w = !0));
          U && m[M].push(P);
        }
      }
      T > 0 && w === !1 && (y = m);
    }
    let _;
    for (let w = 0, T = g.length; w < T; w++) {
      (u = g[w].s), c.push(u), (_ = y[w]);
      for (let M = 0, A = _.length; M < A; M++) u.holes.push(_[M].h);
    }
    return c;
  }
}
class VW extends ma {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
    ),
      super(e, t, { ...i, count: r }),
      (this.isWebGLMultipleRenderTargets = !0);
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: og } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = og));
const WW = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: yw,
      AddEquation: Wu,
      AddOperation: qA,
      AdditiveAnimationBlendMode: Rw,
      AdditiveBlending: fS,
      AgXToneMapping: eR,
      AlphaFormat: bw,
      AlwaysCompare: pR,
      AlwaysDepth: VA,
      AlwaysStencilFunc: mS,
      AmbientLight: pP,
      AnimationAction: SP,
      AnimationClip: Qm,
      AnimationLoader: X8,
      AnimationMixer: SW,
      AnimationObjectGroup: xW,
      AnimationUtils: W8,
      ArcCurve: zR,
      ArrayCamera: PR,
      ArrowHelper: BW,
      AttachedBindMode: pS,
      Audio: xP,
      AudioAnalyser: uW,
      AudioContext: eb,
      AudioListener: sW,
      AudioLoader: rW,
      AxesHelper: zW,
      BackSide: ro,
      BasicDepthPacking: sR,
      BasicShadowMap: wA,
      BatchedMesh: UR,
      Bone: Bw,
      BooleanKeyframeTrack: Of,
      Box2: TW,
      Box3: ci,
      Box3Helper: UW,
      BoxGeometry: kf,
      BoxHelper: NW,
      BufferAttribute: Gn,
      BufferGeometry: sn,
      BufferGeometryLoader: yP,
      ByteType: _w,
      Cache: Nl,
      Camera: ug,
      CameraHelper: OW,
      CanvasTexture: h8,
      CapsuleGeometry: ux,
      CatmullRomCurve3: HR,
      CineonToneMapping: JA,
      CircleGeometry: cx,
      ClampToEdgeWrapping: Ls,
      Clock: tb,
      Color: St,
      ColorKeyframeTrack: Zw,
      ColorManagement: Sn,
      CompressedArrayTexture: f8,
      CompressedCubeTexture: d8,
      CompressedTexture: ax,
      CompressedTextureLoader: Y8,
      ConeGeometry: fx,
      ConstantAlphaFactor: BA,
      ConstantColorFactor: UA,
      CubeCamera: wR,
      CubeReflectionMapping: Hl,
      CubeRefractionMapping: Zu,
      CubeTexture: cg,
      CubeTextureLoader: q8,
      CubeUVReflectionMapping: Vh,
      CubicBezierCurve: Vw,
      CubicBezierCurve3: VR,
      CubicInterpolant: sP,
      CullFaceBack: cS,
      CullFaceFront: SA,
      CullFaceFrontBack: W4,
      CullFaceNone: _A,
      Curve: ga,
      CurvePath: GR,
      CustomBlending: bA,
      CustomToneMapping: QA,
      CylinderGeometry: jh,
      Cylindrical: EW,
      Data3DTexture: Dw,
      DataArrayTexture: Qy,
      DataTexture: Ja,
      DataTextureLoader: K8,
      DataUtils: tz,
      DecrementStencilOp: rB,
      DecrementWrapStencilOp: oB,
      DefaultLoadingManager: uP,
      DepthFormat: xf,
      DepthStencilFormat: Af,
      DepthTexture: Uw,
      DetachedBindMode: nR,
      DirectionalLight: hP,
      DirectionalLightHelper: kW,
      DiscreteInterpolant: aP,
      DisplayP3ColorSpace: Jy,
      DodecahedronGeometry: dx,
      DoubleSide: Ps,
      DstAlphaFactor: LA,
      DstColorFactor: kA,
      DynamicCopyUsage: _B,
      DynamicDrawUsage: pB,
      DynamicReadUsage: vB,
      EdgesGeometry: jR,
      EllipseCurve: lx,
      EqualCompare: cR,
      EqualDepth: GA,
      EqualStencilFunc: uB,
      EquirectangularReflectionMapping: km,
      EquirectangularRefractionMapping: Om,
      Euler: fs,
      EventDispatcher: $l,
      ExtrudeGeometry: px,
      FileLoader: Wl,
      Float16BufferAttribute: az,
      Float32BufferAttribute: Pt,
      FloatType: Bo,
      Fog: ix,
      FogExp2: rx,
      FramebufferTexture: c8,
      FrontSide: el,
      Frustum: fg,
      GLBufferAttribute: MW,
      GLSL1: wB,
      GLSL3: gS,
      GreaterCompare: fR,
      GreaterDepth: $A,
      GreaterEqualCompare: hR,
      GreaterEqualDepth: jA,
      GreaterEqualStencilFunc: hB,
      GreaterStencilFunc: fB,
      GridHelper: LW,
      Group: vh,
      HalfFloatType: Wh,
      HemisphereLight: cP,
      HemisphereLightHelper: IW,
      IcosahedronGeometry: mx,
      ImageBitmapLoader: nW,
      ImageLoader: eg,
      ImageUtils: yR,
      IncrementStencilOp: nB,
      IncrementWrapStencilOp: iB,
      InstancedBufferAttribute: Rf,
      InstancedBufferGeometry: Mx,
      InstancedInterleavedBuffer: _y,
      InstancedMesh: NR,
      Int16BufferAttribute: oz,
      Int32BufferAttribute: sz,
      Int8BufferAttribute: nz,
      IntType: jy,
      InterleavedBuffer: ox,
      InterleavedBufferAttribute: as,
      Interpolant: mg,
      InterpolateDiscrete: Fm,
      InterpolateLinear: my,
      InterpolateSmooth: b0,
      InvertStencilOp: sB,
      KeepStencilOp: sf,
      KeyframeTrack: va,
      LOD: kR,
      LatheGeometry: dg,
      Layers: Sf,
      LessCompare: uR,
      LessDepth: WA,
      LessEqualCompare: Iw,
      LessEqualDepth: Dm,
      LessEqualStencilFunc: cB,
      LessStencilFunc: lB,
      Light: nc,
      LightProbe: vP,
      Line: Ju,
      Line3: bP,
      LineBasicMaterial: _o,
      LineCurve: Ww,
      LineCurve3: WR,
      LineDashedMaterial: rP,
      LineLoop: FR,
      LineSegments: nl,
      LinearDisplayP3ColorSpace: lg,
      LinearFilter: Cr,
      LinearInterpolant: Kw,
      LinearMipMapLinearFilter: X4,
      LinearMipMapNearestFilter: $4,
      LinearMipmapLinearFilter: Xa,
      LinearMipmapNearestFilter: pm,
      LinearSRGBColorSpace: jl,
      LinearToneMapping: KA,
      LinearTransfer: zm,
      Loader: Vo,
      LoaderUtils: MS,
      LoadingManager: Jw,
      LoopOnce: rR,
      LoopPingPong: oR,
      LoopRepeat: iR,
      LuminanceAlphaFormat: Tw,
      LuminanceFormat: Ew,
      MOUSE: rf,
      Material: zi,
      MaterialLoader: bx,
      MathUtils: mR,
      Matrix2: ob,
      Matrix3: en,
      Matrix4: Gt,
      MaxEquation: CA,
      Mesh: ur,
      MeshBasicMaterial: Xl,
      MeshDepthMaterial: tx,
      MeshDistanceMaterial: nx,
      MeshLambertMaterial: tP,
      MeshMatcapMaterial: nP,
      MeshNormalMaterial: eP,
      MeshPhongMaterial: JR,
      MeshPhysicalMaterial: ZR,
      MeshStandardMaterial: Yw,
      MeshToonMaterial: QR,
      MinEquation: TA,
      MirroredRepeatWrapping: Um,
      MixOperation: YA,
      MultiplyBlending: hS,
      MultiplyOperation: sg,
      NearestFilter: wi,
      NearestMipMapLinearFilter: j4,
      NearestMipMapNearestFilter: G4,
      NearestMipmapLinearFilter: ph,
      NearestMipmapNearestFilter: xw,
      NeutralToneMapping: tR,
      NeverCompare: lR,
      NeverDepth: HA,
      NeverStencilFunc: aB,
      NoBlending: Fl,
      NoColorSpace: kl,
      NoToneMapping: Za,
      NormalAnimationBlendMode: Zy,
      NormalBlending: yf,
      NotEqualCompare: dR,
      NotEqualDepth: XA,
      NotEqualStencilFunc: dB,
      NumberKeyframeTrack: Zm,
      Object3D: wn,
      ObjectLoader: eW,
      ObjectSpaceNormalMap: aR,
      OctahedronGeometry: hg,
      OneFactor: RA,
      OneMinusConstantAlphaFactor: zA,
      OneMinusConstantColorFactor: FA,
      OneMinusDstAlphaFactor: DA,
      OneMinusDstColorFactor: OA,
      OneMinusSrcAlphaFactor: V0,
      OneMinusSrcColorFactor: IA,
      OrthographicCamera: Xu,
      P3Primaries: Vm,
      PCFShadowMap: Wy,
      PCFSoftShadowMap: hm,
      PMREMGenerator: vS,
      Path: Xm,
      PerspectiveCamera: Nr,
      Plane: Ll,
      PlaneGeometry: Yl,
      PlaneHelper: FW,
      PointLight: dP,
      PointLightHelper: RW,
      Points: BR,
      PointsMaterial: zw,
      PolarGridHelper: DW,
      PolyhedronGeometry: tc,
      PositionalAudio: lW,
      PropertyBinding: _n,
      PropertyMixer: _P,
      QuadraticBezierCurve: Gw,
      QuadraticBezierCurve3: jw,
      Quaternion: io,
      QuaternionKeyframeTrack: gg,
      QuaternionLinearInterpolant: lP,
      RED_GREEN_RGTC2_Format: hy,
      RED_RGTC1_Format: Aw,
      REVISION: og,
      RGBADepthPacking: Pw,
      RGBAFormat: no,
      RGBAIntegerFormat: Ky,
      RGBA_ASTC_10x10_Format: ay,
      RGBA_ASTC_10x5_Format: iy,
      RGBA_ASTC_10x6_Format: oy,
      RGBA_ASTC_10x8_Format: sy,
      RGBA_ASTC_12x10_Format: ly,
      RGBA_ASTC_12x12_Format: uy,
      RGBA_ASTC_4x4_Format: K0,
      RGBA_ASTC_5x4_Format: Z0,
      RGBA_ASTC_5x5_Format: J0,
      RGBA_ASTC_6x5_Format: Q0,
      RGBA_ASTC_6x6_Format: ey,
      RGBA_ASTC_8x5_Format: ty,
      RGBA_ASTC_8x6_Format: ny,
      RGBA_ASTC_8x8_Format: ry,
      RGBA_BPTC_Format: xm,
      RGBA_ETC2_EAC_Format: q0,
      RGBA_PVRTC_2BPPV1_Format: $0,
      RGBA_PVRTC_4BPPV1_Format: j0,
      RGBA_S3TC_DXT1_Format: gm,
      RGBA_S3TC_DXT3_Format: vm,
      RGBA_S3TC_DXT5_Format: ym,
      RGBDepthPacking: J4,
      RGBFormat: Mw,
      RGBIntegerFormat: Y4,
      RGB_BPTC_SIGNED_Format: cy,
      RGB_BPTC_UNSIGNED_Format: fy,
      RGB_ETC1_Format: X0,
      RGB_ETC2_Format: Y0,
      RGB_PVRTC_2BPPV1_Format: G0,
      RGB_PVRTC_4BPPV1_Format: W0,
      RGB_S3TC_DXT1_Format: mm,
      RGDepthPacking: Q4,
      RGFormat: Cw,
      RGIntegerFormat: qy,
      RawShaderMaterial: KR,
      Ray: Df,
      Raycaster: wP,
      Rec709Primaries: Hm,
      RectAreaLight: mP,
      RedFormat: Yy,
      RedIntegerFormat: ag,
      ReinhardToneMapping: ZA,
      RenderTarget: xR,
      RepeatWrapping: Nm,
      ReplaceStencilOp: tB,
      ReverseSubtractEquation: EA,
      RingGeometry: gx,
      SIGNED_RED_GREEN_RGTC2_Format: py,
      SIGNED_RED_RGTC1_Format: dy,
      SRGBColorSpace: As,
      SRGBTransfer: Jn,
      Scene: gy,
      ShaderChunk: rn,
      ShaderLib: ca,
      ShaderMaterial: Ds,
      ShadowMaterial: qR,
      Shape: wf,
      ShapeGeometry: vx,
      ShapePath: HW,
      ShapeUtils: Qa,
      ShortType: Sw,
      Skeleton: sx,
      SkeletonHelper: AW,
      SkinnedMesh: OR,
      Source: mf,
      Sphere: fi,
      SphereGeometry: pg,
      Spherical: TS,
      SphericalHarmonics3: gP,
      SplineCurve: $w,
      SpotLight: fP,
      SpotLightHelper: CW,
      Sprite: DR,
      SpriteMaterial: Fw,
      SrcAlphaFactor: H0,
      SrcAlphaSaturateFactor: NA,
      SrcColorFactor: PA,
      StaticCopyUsage: xB,
      StaticDrawUsage: Wm,
      StaticReadUsage: gB,
      StereoCamera: iW,
      StreamCopyUsage: SB,
      StreamDrawUsage: mB,
      StreamReadUsage: yB,
      StringKeyframeTrack: Nf,
      SubtractEquation: MA,
      SubtractiveBlending: dS,
      TOUCH: of,
      TangentSpaceNormalMap: ec,
      TetrahedronGeometry: yx,
      Texture: er,
      TextureLoader: wx,
      TextureUtils: WV,
      TorusGeometry: xx,
      TorusKnotGeometry: _x,
      Triangle: ss,
      TriangleFanDrawMode: Z4,
      TriangleStripDrawMode: K4,
      TrianglesDrawMode: q4,
      TubeGeometry: Sx,
      UVMapping: Gy,
      Uint16BufferAttribute: kw,
      Uint32BufferAttribute: Ow,
      Uint8BufferAttribute: rz,
      Uint8ClampedBufferAttribute: iz,
      Uniform: ib,
      UniformsGroup: bW,
      UniformsLib: vt,
      UniformsUtils: $m,
      UnsignedByteType: pa,
      UnsignedInt248Type: Cf,
      UnsignedInt5999Type: ww,
      UnsignedIntType: Vl,
      UnsignedShort4444Type: $y,
      UnsignedShort5551Type: Xy,
      UnsignedShortType: Ih,
      VSMShadowMap: la,
      Vector2: tt,
      Vector3: oe,
      Vector4: dn,
      VectorKeyframeTrack: Jm,
      VideoTexture: u8,
      WebGL3DRenderTarget: jB,
      WebGLArrayRenderTarget: GB,
      WebGLCoordinateSystem: Ya,
      WebGLCubeRenderTarget: bR,
      WebGLMultipleRenderTargets: VW,
      WebGLRenderTarget: ma,
      WebGLRenderer: IR,
      WebGLUtils: RR,
      WebGPUCoordinateSystem: Gm,
      WireframeGeometry: Xw,
      WrapAroundEnding: Bm,
      ZeroCurvatureEnding: hf,
      ZeroFactor: AA,
      ZeroSlopeEnding: pf,
      ZeroStencilOp: eB,
      createCanvasElement: vR,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var w1 = { exports: {} },
  Hu = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var o2;
function GW() {
  return (
    o2 ||
      ((o2 = 1),
      (Hu.ConcurrentRoot = 1),
      (Hu.ContinuousEventPriority = 4),
      (Hu.DefaultEventPriority = 16),
      (Hu.DiscreteEventPriority = 1),
      (Hu.IdleEventPriority = 536870912),
      (Hu.LegacyRoot = 0)),
    Hu
  );
}
var s2;
function jW() {
  return s2 || ((s2 = 1), (w1.exports = GW())), w1.exports;
}
var xh = jW();
function $W(n) {
  let e;
  const t = new Set(),
    r = (c, d) => {
      const m = typeof c == "function" ? c(e) : c;
      if (m !== e) {
        const g = e;
        (e = d ? m : Object.assign({}, e, m)), t.forEach((y) => y(e, g));
      }
    },
    i = () => e,
    o = (c, d = i, m = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let g = d(e);
      function y() {
        const x = d(e);
        if (!m(g, x)) {
          const S = g;
          c((g = x), S);
        }
      }
      return t.add(y), () => t.delete(y);
    },
    u = {
      setState: r,
      getState: i,
      subscribe: (c, d, m) =>
        d || m ? o(c, d, m) : (t.add(c), () => t.delete(c)),
      destroy: () => t.clear(),
    };
  return (e = n(r, i, u)), u;
}
const XW =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  a2 = XW ? X.useEffect : X.useLayoutEffect;
function YW(n) {
  const e = typeof n == "function" ? $W(n) : n,
    t = (r = e.getState, i = Object.is) => {
      const [, o] = X.useReducer((_) => _ + 1, 0),
        s = e.getState(),
        a = X.useRef(s),
        u = X.useRef(r),
        c = X.useRef(i),
        d = X.useRef(!1),
        m = X.useRef();
      m.current === void 0 && (m.current = r(s));
      let g,
        y = !1;
      (a.current !== s || u.current !== r || c.current !== i || d.current) &&
        ((g = r(s)), (y = !i(m.current, g))),
        a2(() => {
          y && (m.current = g),
            (a.current = s),
            (u.current = r),
            (c.current = i),
            (d.current = !1);
        });
      const x = X.useRef(s);
      a2(() => {
        const _ = () => {
            try {
              const T = e.getState(),
                M = u.current(T);
              c.current(m.current, M) ||
                ((a.current = T), (m.current = M), o());
            } catch {
              (d.current = !0), o();
            }
          },
          w = e.subscribe(_);
        return e.getState() !== x.current && _(), w;
      }, []);
      const S = y ? g : m.current;
      return X.useDebugValue(S), S;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [t, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    t
  );
}
var b1 = { exports: {} },
  M1 = { exports: {} },
  E1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var l2;
function qW() {
  return (
    l2 ||
      ((l2 = 1),
      (function (n) {
        function e(G, te) {
          var F = G.length;
          G.push(te);
          e: for (; 0 < F; ) {
            var V = (F - 1) >>> 1,
              ne = G[V];
            if (0 < i(ne, te)) (G[V] = te), (G[F] = ne), (F = V);
            else break e;
          }
        }
        function t(G) {
          return G.length === 0 ? null : G[0];
        }
        function r(G) {
          if (G.length === 0) return null;
          var te = G[0],
            F = G.pop();
          if (F !== te) {
            G[0] = F;
            e: for (var V = 0, ne = G.length, ae = ne >>> 1; V < ae; ) {
              var J = 2 * (V + 1) - 1,
                se = G[J],
                de = J + 1,
                le = G[de];
              if (0 > i(se, F))
                de < ne && 0 > i(le, se)
                  ? ((G[V] = le), (G[de] = F), (V = de))
                  : ((G[V] = se), (G[J] = F), (V = J));
              else if (de < ne && 0 > i(le, F))
                (G[V] = le), (G[de] = F), (V = de);
              else break e;
            }
          }
          return te;
        }
        function i(G, te) {
          var F = G.sortIndex - te.sortIndex;
          return F !== 0 ? F : G.id - te.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var s = Date,
            a = s.now();
          n.unstable_now = function () {
            return s.now() - a;
          };
        }
        var u = [],
          c = [],
          d = 1,
          m = null,
          g = 3,
          y = !1,
          x = !1,
          S = !1,
          _ = typeof setTimeout == "function" ? setTimeout : null,
          w = typeof clearTimeout == "function" ? clearTimeout : null,
          T = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function M(G) {
          for (var te = t(c); te !== null; ) {
            if (te.callback === null) r(c);
            else if (te.startTime <= G)
              r(c), (te.sortIndex = te.expirationTime), e(u, te);
            else break;
            te = t(c);
          }
        }
        function A(G) {
          if (((S = !1), M(G), !x))
            if (t(u) !== null) (x = !0), Y(R);
            else {
              var te = t(c);
              te !== null && re(A, te.startTime - G);
            }
        }
        function R(G, te) {
          (x = !1), S && ((S = !1), w(U), (U = -1)), (y = !0);
          var F = g;
          try {
            for (
              M(te), m = t(u);
              m !== null && (!(m.expirationTime > te) || (G && !H()));

            ) {
              var V = m.callback;
              if (typeof V == "function") {
                (m.callback = null), (g = m.priorityLevel);
                var ne = V(m.expirationTime <= te);
                (te = n.unstable_now()),
                  typeof ne == "function"
                    ? (m.callback = ne)
                    : m === t(u) && r(u),
                  M(te);
              } else r(u);
              m = t(u);
            }
            if (m !== null) var ae = !0;
            else {
              var J = t(c);
              J !== null && re(A, J.startTime - te), (ae = !1);
            }
            return ae;
          } finally {
            (m = null), (g = F), (y = !1);
          }
        }
        var D = !1,
          P = null,
          U = -1,
          O = 5,
          L = -1;
        function H() {
          return !(n.unstable_now() - L < O);
        }
        function W() {
          if (P !== null) {
            var G = n.unstable_now();
            L = G;
            var te = !0;
            try {
              te = P(!0, G);
            } finally {
              te ? $() : ((D = !1), (P = null));
            }
          } else D = !1;
        }
        var $;
        if (typeof T == "function")
          $ = function () {
            T(W);
          };
        else if (typeof MessageChannel < "u") {
          var K = new MessageChannel(),
            Z = K.port2;
          (K.port1.onmessage = W),
            ($ = function () {
              Z.postMessage(null);
            });
        } else
          $ = function () {
            _(W, 0);
          };
        function Y(G) {
          (P = G), D || ((D = !0), $());
        }
        function re(G, te) {
          U = _(function () {
            G(n.unstable_now());
          }, te);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (G) {
            G.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            x || y || ((x = !0), Y(R));
          }),
          (n.unstable_forceFrameRate = function (G) {
            0 > G || 125 < G
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (O = 0 < G ? Math.floor(1e3 / G) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(u);
          }),
          (n.unstable_next = function (G) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var te = 3;
                break;
              default:
                te = g;
            }
            var F = g;
            g = te;
            try {
              return G();
            } finally {
              g = F;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (G, te) {
            switch (G) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                G = 3;
            }
            var F = g;
            g = G;
            try {
              return te();
            } finally {
              g = F;
            }
          }),
          (n.unstable_scheduleCallback = function (G, te, F) {
            var V = n.unstable_now();
            switch (
              (typeof F == "object" && F !== null
                ? ((F = F.delay),
                  (F = typeof F == "number" && 0 < F ? V + F : V))
                : (F = V),
              G)
            ) {
              case 1:
                var ne = -1;
                break;
              case 2:
                ne = 250;
                break;
              case 5:
                ne = 1073741823;
                break;
              case 4:
                ne = 1e4;
                break;
              default:
                ne = 5e3;
            }
            return (
              (ne = F + ne),
              (G = {
                id: d++,
                callback: te,
                priorityLevel: G,
                startTime: F,
                expirationTime: ne,
                sortIndex: -1,
              }),
              F > V
                ? ((G.sortIndex = F),
                  e(c, G),
                  t(u) === null &&
                    G === t(c) &&
                    (S ? (w(U), (U = -1)) : (S = !0), re(A, F - V)))
                : ((G.sortIndex = ne), e(u, G), x || y || ((x = !0), Y(R))),
              G
            );
          }),
          (n.unstable_shouldYield = H),
          (n.unstable_wrapCallback = function (G) {
            var te = g;
            return function () {
              var F = g;
              g = te;
              try {
                return G.apply(this, arguments);
              } finally {
                g = F;
              }
            };
          });
      })(E1)),
    E1
  );
}
var u2;
function EP() {
  return u2 || ((u2 = 1), (M1.exports = qW())), M1.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var T1, c2;
function KW() {
  return (
    c2 ||
      ((c2 = 1),
      (T1 = function (e) {
        var t = {},
          r = Nh(),
          i = EP(),
          o = Object.assign;
        function s(h) {
          for (
            var p =
                "https://reactjs.org/docs/error-decoder.html?invariant=" + h,
              b = 1;
            b < arguments.length;
            b++
          )
            p += "&args[]=" + encodeURIComponent(arguments[b]);
          return (
            "Minified React error #" +
            h +
            "; visit " +
            p +
            " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
          );
        }
        var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          u = Symbol.for("react.element"),
          c = Symbol.for("react.portal"),
          d = Symbol.for("react.fragment"),
          m = Symbol.for("react.strict_mode"),
          g = Symbol.for("react.profiler"),
          y = Symbol.for("react.provider"),
          x = Symbol.for("react.context"),
          S = Symbol.for("react.forward_ref"),
          _ = Symbol.for("react.suspense"),
          w = Symbol.for("react.suspense_list"),
          T = Symbol.for("react.memo"),
          M = Symbol.for("react.lazy"),
          A = Symbol.for("react.offscreen"),
          R = Symbol.iterator;
        function D(h) {
          return h === null || typeof h != "object"
            ? null
            : ((h = (R && h[R]) || h["@@iterator"]),
              typeof h == "function" ? h : null);
        }
        function P(h) {
          if (h == null) return null;
          if (typeof h == "function") return h.displayName || h.name || null;
          if (typeof h == "string") return h;
          switch (h) {
            case d:
              return "Fragment";
            case c:
              return "Portal";
            case g:
              return "Profiler";
            case m:
              return "StrictMode";
            case _:
              return "Suspense";
            case w:
              return "SuspenseList";
          }
          if (typeof h == "object")
            switch (h.$$typeof) {
              case x:
                return (h.displayName || "Context") + ".Consumer";
              case y:
                return (h._context.displayName || "Context") + ".Provider";
              case S:
                var p = h.render;
                return (
                  (h = h.displayName),
                  h ||
                    ((h = p.displayName || p.name || ""),
                    (h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef")),
                  h
                );
              case T:
                return (
                  (p = h.displayName || null),
                  p !== null ? p : P(h.type) || "Memo"
                );
              case M:
                (p = h._payload), (h = h._init);
                try {
                  return P(h(p));
                } catch {}
            }
          return null;
        }
        function U(h) {
          var p = h.type;
          switch (h.tag) {
            case 24:
              return "Cache";
            case 9:
              return (p.displayName || "Context") + ".Consumer";
            case 10:
              return (p._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return (
                (h = p.render),
                (h = h.displayName || h.name || ""),
                p.displayName ||
                  (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef")
              );
            case 7:
              return "Fragment";
            case 5:
              return p;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return P(p);
            case 8:
              return p === m ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if (typeof p == "function")
                return p.displayName || p.name || null;
              if (typeof p == "string") return p;
          }
          return null;
        }
        function O(h) {
          var p = h,
            b = h;
          if (h.alternate) for (; p.return; ) p = p.return;
          else {
            h = p;
            do
              (p = h), (p.flags & 4098) !== 0 && (b = p.return), (h = p.return);
            while (h);
          }
          return p.tag === 3 ? b : null;
        }
        function L(h) {
          if (O(h) !== h) throw Error(s(188));
        }
        function H(h) {
          var p = h.alternate;
          if (!p) {
            if (((p = O(h)), p === null)) throw Error(s(188));
            return p !== h ? null : h;
          }
          for (var b = h, C = p; ; ) {
            var k = b.return;
            if (k === null) break;
            var z = k.alternate;
            if (z === null) {
              if (((C = k.return), C !== null)) {
                b = C;
                continue;
              }
              break;
            }
            if (k.child === z.child) {
              for (z = k.child; z; ) {
                if (z === b) return L(k), h;
                if (z === C) return L(k), p;
                z = z.sibling;
              }
              throw Error(s(188));
            }
            if (b.return !== C.return) (b = k), (C = z);
            else {
              for (var ce = !1, Ee = k.child; Ee; ) {
                if (Ee === b) {
                  (ce = !0), (b = k), (C = z);
                  break;
                }
                if (Ee === C) {
                  (ce = !0), (C = k), (b = z);
                  break;
                }
                Ee = Ee.sibling;
              }
              if (!ce) {
                for (Ee = z.child; Ee; ) {
                  if (Ee === b) {
                    (ce = !0), (b = z), (C = k);
                    break;
                  }
                  if (Ee === C) {
                    (ce = !0), (C = z), (b = k);
                    break;
                  }
                  Ee = Ee.sibling;
                }
                if (!ce) throw Error(s(189));
              }
            }
            if (b.alternate !== C) throw Error(s(190));
          }
          if (b.tag !== 3) throw Error(s(188));
          return b.stateNode.current === b ? h : p;
        }
        function W(h) {
          return (h = H(h)), h !== null ? $(h) : null;
        }
        function $(h) {
          if (h.tag === 5 || h.tag === 6) return h;
          for (h = h.child; h !== null; ) {
            var p = $(h);
            if (p !== null) return p;
            h = h.sibling;
          }
          return null;
        }
        function K(h) {
          if (h.tag === 5 || h.tag === 6) return h;
          for (h = h.child; h !== null; ) {
            if (h.tag !== 4) {
              var p = K(h);
              if (p !== null) return p;
            }
            h = h.sibling;
          }
          return null;
        }
        var Z = Array.isArray,
          Y = e.getPublicInstance,
          re = e.getRootHostContext,
          G = e.getChildHostContext,
          te = e.prepareForCommit,
          F = e.resetAfterCommit,
          V = e.createInstance,
          ne = e.appendInitialChild,
          ae = e.finalizeInitialChildren,
          J = e.prepareUpdate,
          se = e.shouldSetTextContent,
          de = e.createTextInstance,
          le = e.scheduleTimeout,
          fe = e.cancelTimeout,
          Me = e.noTimeout,
          ge = e.isPrimaryRenderer,
          xe = e.supportsMutation,
          j = e.supportsPersistence,
          we = e.supportsHydration,
          Ae = e.getInstanceFromNode,
          Oe = e.preparePortalMount,
          Ie = e.getCurrentEventPriority,
          rt = e.detachDeletedInstance,
          De = e.supportsMicrotasks,
          Xe = e.scheduleMicrotask,
          ee = e.supportsTestSelectors,
          B = e.findFiberRoot,
          ve = e.getBoundingRect,
          Se = e.getTextContent,
          _e = e.isHiddenSubtree,
          Te = e.matchAccessibilityRole,
          at = e.setFocusIfFocusable,
          Fe = e.setupIntersectionObserver,
          Be = e.appendChild,
          Ge = e.appendChildToContainer,
          Ye = e.commitTextUpdate,
          nt = e.commitMount,
          xt = e.commitUpdate,
          $e = e.insertBefore,
          qe = e.insertInContainerBefore,
          et = e.removeChild,
          he = e.removeChildFromContainer,
          Je = e.resetTextContent,
          me = e.hideInstance,
          Ve = e.hideTextInstance,
          Re = e.unhideInstance,
          Ue = e.unhideTextInstance,
          it = e.clearContainer,
          mt = e.cloneInstance,
          gt = e.createContainerChildSet,
          Nt = e.appendChildToContainerChildSet,
          Ut = e.finalizeContainerChildren,
          ht = e.replaceContainerChildren,
          $t = e.cloneHiddenInstance,
          un = e.cloneHiddenTextInstance,
          bn = e.canHydrateInstance,
          yn = e.canHydrateTextInstance,
          cr = e.canHydrateSuspenseInstance,
          Hi = e.isSuspenseInstancePending,
          yr = e.isSuspenseInstanceFallback,
          Fr = e.registerSuspenseInstanceRetry,
          Ar = e.getNextHydratableSibling,
          Br = e.getFirstHydratableChild,
          xr = e.getFirstHydratableChildWithinContainer,
          So = e.getFirstHydratableChildWithinSuspenseInstance,
          ql = e.hydrateInstance,
          oo = e.hydrateTextInstance,
          Kl = e.hydrateSuspenseInstance,
          ie = e.getNextHydratableInstanceAfterSuspenseInstance,
          Ce = e.commitHydratedContainer,
          ze = e.commitHydratedSuspenseInstance,
          We = e.clearSuspenseBoundary,
          Le = e.clearSuspenseBoundaryFromContainer,
          ut = e.shouldDeleteUnhydratedTailInstances,
          yt = e.didNotMatchHydratedContainerTextInstance,
          Et = e.didNotMatchHydratedTextInstance,
          Ke;
        function kt(h) {
          if (Ke === void 0)
            try {
              throw Error();
            } catch (b) {
              var p = b.stack.trim().match(/\n( *(at )?)/);
              Ke = (p && p[1]) || "";
            }
          return (
            `
` +
            Ke +
            h
          );
        }
        var Ft = !1;
        function At(h, p) {
          if (!h || Ft) return "";
          Ft = !0;
          var b = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (p)
              if (
                ((p = function () {
                  throw Error();
                }),
                Object.defineProperty(p.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(p, []);
                } catch (ct) {
                  var C = ct;
                }
                Reflect.construct(h, [], p);
              } else {
                try {
                  p.call();
                } catch (ct) {
                  C = ct;
                }
                h.call(p.prototype);
              }
            else {
              try {
                throw Error();
              } catch (ct) {
                C = ct;
              }
              h();
            }
          } catch (ct) {
            if (ct && C && typeof ct.stack == "string") {
              for (
                var k = ct.stack.split(`
`),
                  z = C.stack.split(`
`),
                  ce = k.length - 1,
                  Ee = z.length - 1;
                1 <= ce && 0 <= Ee && k[ce] !== z[Ee];

              )
                Ee--;
              for (; 1 <= ce && 0 <= Ee; ce--, Ee--)
                if (k[ce] !== z[Ee]) {
                  if (ce !== 1 || Ee !== 1)
                    do
                      if ((ce--, Ee--, 0 > Ee || k[ce] !== z[Ee])) {
                        var Qe =
                          `
` + k[ce].replace(" at new ", " at ");
                        return (
                          h.displayName &&
                            Qe.includes("<anonymous>") &&
                            (Qe = Qe.replace("<anonymous>", h.displayName)),
                          Qe
                        );
                      }
                    while (1 <= ce && 0 <= Ee);
                  break;
                }
            }
          } finally {
            (Ft = !1), (Error.prepareStackTrace = b);
          }
          return (h = h ? h.displayName || h.name : "") ? kt(h) : "";
        }
        var tn = Object.prototype.hasOwnProperty,
          An = [],
          pn = -1;
        function Mn(h) {
          return { current: h };
        }
        function wt(h) {
          0 > pn || ((h.current = An[pn]), (An[pn] = null), pn--);
        }
        function dt(h, p) {
          pn++, (An[pn] = h.current), (h.current = p);
        }
        var Jt = {},
          zt = Mn(Jt),
          En = Mn(!1),
          ii = Jt;
        function Rn(h, p) {
          var b = h.type.contextTypes;
          if (!b) return Jt;
          var C = h.stateNode;
          if (C && C.__reactInternalMemoizedUnmaskedChildContext === p)
            return C.__reactInternalMemoizedMaskedChildContext;
          var k = {},
            z;
          for (z in b) k[z] = p[z];
          return (
            C &&
              ((h = h.stateNode),
              (h.__reactInternalMemoizedUnmaskedChildContext = p),
              (h.__reactInternalMemoizedMaskedChildContext = k)),
            k
          );
        }
        function jn(h) {
          return (h = h.childContextTypes), h != null;
        }
        function cn() {
          wt(En), wt(zt);
        }
        function zr(h, p, b) {
          if (zt.current !== Jt) throw Error(s(168));
          dt(zt, p), dt(En, b);
        }
        function ds(h, p, b) {
          var C = h.stateNode;
          if (
            ((p = p.childContextTypes), typeof C.getChildContext != "function")
          )
            return b;
          C = C.getChildContext();
          for (var k in C)
            if (!(k in p)) throw Error(s(108, U(h) || "Unknown", k));
          return o({}, b, C);
        }
        function fr(h) {
          return (
            (h =
              ((h = h.stateNode) &&
                h.__reactInternalMemoizedMergedChildContext) ||
              Jt),
            (ii = zt.current),
            dt(zt, h),
            dt(En, En.current),
            !0
          );
        }
        function Rr(h, p, b) {
          var C = h.stateNode;
          if (!C) throw Error(s(169));
          b
            ? ((h = ds(h, p, ii)),
              (C.__reactInternalMemoizedMergedChildContext = h),
              wt(En),
              wt(zt),
              dt(zt, h))
            : wt(En),
            dt(En, b);
        }
        var pi = Math.clz32 ? Math.clz32 : Uf,
          Wo = Math.log,
          Go = Math.LN2;
        function Uf(h) {
          return (h >>>= 0), h === 0 ? 32 : (31 - ((Wo(h) / Go) | 0)) | 0;
        }
        var jo = 64,
          ln = 4194304;
        function hs(h) {
          switch (h & -h) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return h & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return h & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return h;
          }
        }
        function ya(h, p) {
          var b = h.pendingLanes;
          if (b === 0) return 0;
          var C = 0,
            k = h.suspendedLanes,
            z = h.pingedLanes,
            ce = b & 268435455;
          if (ce !== 0) {
            var Ee = ce & ~k;
            Ee !== 0 ? (C = hs(Ee)) : ((z &= ce), z !== 0 && (C = hs(z)));
          } else
            (ce = b & ~k), ce !== 0 ? (C = hs(ce)) : z !== 0 && (C = hs(z));
          if (C === 0) return 0;
          if (
            p !== 0 &&
            p !== C &&
            (p & k) === 0 &&
            ((k = C & -C),
            (z = p & -p),
            k >= z || (k === 16 && (z & 4194240) !== 0))
          )
            return p;
          if (((C & 4) !== 0 && (C |= b & 16), (p = h.entangledLanes), p !== 0))
            for (h = h.entanglements, p &= C; 0 < p; )
              (b = 31 - pi(p)), (k = 1 << b), (C |= h[b]), (p &= ~k);
          return C;
        }
        function Zl(h, p) {
          switch (h) {
            case 1:
            case 2:
            case 4:
              return p + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return p + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function Jl(h, p) {
          for (
            var b = h.suspendedLanes,
              C = h.pingedLanes,
              k = h.expirationTimes,
              z = h.pendingLanes;
            0 < z;

          ) {
            var ce = 31 - pi(z),
              Ee = 1 << ce,
              Qe = k[ce];
            Qe === -1
              ? ((Ee & b) === 0 || (Ee & C) !== 0) && (k[ce] = Zl(Ee, p))
              : Qe <= p && (h.expiredLanes |= Ee),
              (z &= ~Ee);
          }
        }
        function ps(h) {
          return (
            (h = h.pendingLanes & -1073741825),
            h !== 0 ? h : h & 1073741824 ? 1073741824 : 0
          );
        }
        function rl(h) {
          for (var p = [], b = 0; 31 > b; b++) p.push(h);
          return p;
        }
        function wo(h, p, b) {
          (h.pendingLanes |= p),
            p !== 536870912 && ((h.suspendedLanes = 0), (h.pingedLanes = 0)),
            (h = h.eventTimes),
            (p = 31 - pi(p)),
            (h[p] = b);
        }
        function $o(h, p) {
          var b = h.pendingLanes & ~p;
          (h.pendingLanes = p),
            (h.suspendedLanes = 0),
            (h.pingedLanes = 0),
            (h.expiredLanes &= p),
            (h.mutableReadLanes &= p),
            (h.entangledLanes &= p),
            (p = h.entanglements);
          var C = h.eventTimes;
          for (h = h.expirationTimes; 0 < b; ) {
            var k = 31 - pi(b),
              z = 1 << k;
            (p[k] = 0), (C[k] = -1), (h[k] = -1), (b &= ~z);
          }
        }
        function oi(h, p) {
          var b = (h.entangledLanes |= p);
          for (h = h.entanglements; b; ) {
            var C = 31 - pi(b),
              k = 1 << C;
            (k & p) | (h[C] & p) && (h[C] |= p), (b &= ~k);
          }
        }
        var Xt = 0;
        function bo(h) {
          return (
            (h &= -h),
            1 < h ? (4 < h ? ((h & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
          );
        }
        var so = i.unstable_scheduleCallback,
          ms = i.unstable_cancelCallback,
          Mo = i.unstable_shouldYield,
          Ff = i.unstable_requestPaint,
          qn = i.unstable_now,
          Xo = i.unstable_ImmediatePriority,
          Bf = i.unstable_UserBlockingPriority,
          mi = i.unstable_NormalPriority,
          xa = i.unstable_IdlePriority,
          _a = null,
          ao = null;
        function Ns(h) {
          if (ao && typeof ao.onCommitFiberRoot == "function")
            try {
              ao.onCommitFiberRoot(
                _a,
                h,
                void 0,
                (h.current.flags & 128) === 128
              );
            } catch {}
        }
        function Sa(h, p) {
          return (
            (h === p && (h !== 0 || 1 / h === 1 / p)) || (h !== h && p !== p)
          );
        }
        var Hr = typeof Object.is == "function" ? Object.is : Sa,
          Vr = null,
          gs = !1,
          Eo = !1;
        function il(h) {
          Vr === null ? (Vr = [h]) : Vr.push(h);
        }
        function wa(h) {
          (gs = !0), il(h);
        }
        function gi() {
          if (!Eo && Vr !== null) {
            Eo = !0;
            var h = 0,
              p = Xt;
            try {
              var b = Vr;
              for (Xt = 1; h < b.length; h++) {
                var C = b[h];
                do C = C(!0);
                while (C !== null);
              }
              (Vr = null), (gs = !1);
            } catch (k) {
              throw (Vr !== null && (Vr = Vr.slice(h + 1)), so(Xo, gi), k);
            } finally {
              (Xt = p), (Eo = !1);
            }
          }
          return null;
        }
        var ba = a.ReactCurrentBatchConfig;
        function Vi(h, p) {
          if (Hr(h, p)) return !0;
          if (
            typeof h != "object" ||
            h === null ||
            typeof p != "object" ||
            p === null
          )
            return !1;
          var b = Object.keys(h),
            C = Object.keys(p);
          if (b.length !== C.length) return !1;
          for (C = 0; C < b.length; C++) {
            var k = b[C];
            if (!tn.call(p, k) || !Hr(h[k], p[k])) return !1;
          }
          return !0;
        }
        function Us(h) {
          switch (h.tag) {
            case 5:
              return kt(h.type);
            case 16:
              return kt("Lazy");
            case 13:
              return kt("Suspense");
            case 19:
              return kt("SuspenseList");
            case 0:
            case 2:
            case 15:
              return (h = At(h.type, !1)), h;
            case 11:
              return (h = At(h.type.render, !1)), h;
            case 1:
              return (h = At(h.type, !0)), h;
            default:
              return "";
          }
        }
        function Wr(h, p) {
          if (h && h.defaultProps) {
            (p = o({}, p)), (h = h.defaultProps);
            for (var b in h) p[b] === void 0 && (p[b] = h[b]);
            return p;
          }
          return p;
        }
        var Pr = Mn(null),
          Fs = null,
          Wi = null,
          Bs = null;
        function Gr() {
          Bs = Wi = Fs = null;
        }
        function zs(h, p, b) {
          ge
            ? (dt(Pr, p._currentValue), (p._currentValue = b))
            : (dt(Pr, p._currentValue2), (p._currentValue2 = b));
        }
        function _r(h) {
          var p = Pr.current;
          wt(Pr), ge ? (h._currentValue = p) : (h._currentValue2 = p);
        }
        function Ir(h, p, b) {
          for (; h !== null; ) {
            var C = h.alternate;
            if (
              ((h.childLanes & p) !== p
                ? ((h.childLanes |= p), C !== null && (C.childLanes |= p))
                : C !== null && (C.childLanes & p) !== p && (C.childLanes |= p),
              h === b)
            )
              break;
            h = h.return;
          }
        }
        function dr(h, p) {
          (Fs = h),
            (Bs = Wi = null),
            (h = h.dependencies),
            h !== null &&
              h.firstContext !== null &&
              ((h.lanes & p) !== 0 && (Yr = !0), (h.firstContext = null));
        }
        function tr(h) {
          var p = ge ? h._currentValue : h._currentValue2;
          if (Bs !== h)
            if (
              ((h = { context: h, memoizedValue: p, next: null }), Wi === null)
            ) {
              if (Fs === null) throw Error(s(308));
              (Wi = h), (Fs.dependencies = { lanes: 0, firstContext: h });
            } else Wi = Wi.next = h;
          return p;
        }
        var bi = null,
          To = !1;
        function Ql(h) {
          h.updateQueue = {
            baseState: h.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function Xh(h, p) {
          (h = h.updateQueue),
            p.updateQueue === h &&
              (p.updateQueue = {
                baseState: h.baseState,
                firstBaseUpdate: h.firstBaseUpdate,
                lastBaseUpdate: h.lastBaseUpdate,
                shared: h.shared,
                effects: h.effects,
              });
        }
        function Hs(h, p) {
          return {
            eventTime: h,
            lane: p,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function Ma(h, p) {
          var b = h.updateQueue;
          b !== null &&
            ((b = b.shared),
            ir !== null && (h.mode & 1) !== 0 && (nn & 2) === 0
              ? ((h = b.interleaved),
                h === null
                  ? ((p.next = p), bi === null ? (bi = [b]) : bi.push(b))
                  : ((p.next = h.next), (h.next = p)),
                (b.interleaved = p))
              : ((h = b.pending),
                h === null ? (p.next = p) : ((p.next = h.next), (h.next = p)),
                (b.pending = p)));
        }
        function zf(h, p, b) {
          if (
            ((p = p.updateQueue),
            p !== null && ((p = p.shared), (b & 4194240) !== 0))
          ) {
            var C = p.lanes;
            (C &= h.pendingLanes), (b |= C), (p.lanes = b), oi(h, b);
          }
        }
        function Hf(h, p) {
          var b = h.updateQueue,
            C = h.alternate;
          if (C !== null && ((C = C.updateQueue), b === C)) {
            var k = null,
              z = null;
            if (((b = b.firstBaseUpdate), b !== null)) {
              do {
                var ce = {
                  eventTime: b.eventTime,
                  lane: b.lane,
                  tag: b.tag,
                  payload: b.payload,
                  callback: b.callback,
                  next: null,
                };
                z === null ? (k = z = ce) : (z = z.next = ce), (b = b.next);
              } while (b !== null);
              z === null ? (k = z = p) : (z = z.next = p);
            } else k = z = p;
            (b = {
              baseState: C.baseState,
              firstBaseUpdate: k,
              lastBaseUpdate: z,
              shared: C.shared,
              effects: C.effects,
            }),
              (h.updateQueue = b);
            return;
          }
          (h = b.lastBaseUpdate),
            h === null ? (b.firstBaseUpdate = p) : (h.next = p),
            (b.lastBaseUpdate = p);
        }
        function Vf(h, p, b, C) {
          var k = h.updateQueue;
          To = !1;
          var z = k.firstBaseUpdate,
            ce = k.lastBaseUpdate,
            Ee = k.shared.pending;
          if (Ee !== null) {
            k.shared.pending = null;
            var Qe = Ee,
              ct = Qe.next;
            (Qe.next = null),
              ce === null ? (z = ct) : (ce.next = ct),
              (ce = Qe);
            var Tt = h.alternate;
            Tt !== null &&
              ((Tt = Tt.updateQueue),
              (Ee = Tt.lastBaseUpdate),
              Ee !== ce &&
                (Ee === null ? (Tt.firstBaseUpdate = ct) : (Ee.next = ct),
                (Tt.lastBaseUpdate = Qe)));
          }
          if (z !== null) {
            var Kt = k.baseState;
            (ce = 0), (Tt = ct = Qe = null), (Ee = z);
            do {
              var Bt = Ee.lane,
                Un = Ee.eventTime;
              if ((C & Bt) === Bt) {
                Tt !== null &&
                  (Tt = Tt.next =
                    {
                      eventTime: Un,
                      lane: 0,
                      tag: Ee.tag,
                      payload: Ee.payload,
                      callback: Ee.callback,
                      next: null,
                    });
                e: {
                  var bt = h,
                    Tn = Ee;
                  switch (((Bt = p), (Un = b), Tn.tag)) {
                    case 1:
                      if (((bt = Tn.payload), typeof bt == "function")) {
                        Kt = bt.call(Un, Kt, Bt);
                        break e;
                      }
                      Kt = bt;
                      break e;
                    case 3:
                      bt.flags = (bt.flags & -65537) | 128;
                    case 0:
                      if (
                        ((bt = Tn.payload),
                        (Bt =
                          typeof bt == "function" ? bt.call(Un, Kt, Bt) : bt),
                        Bt == null)
                      )
                        break e;
                      Kt = o({}, Kt, Bt);
                      break e;
                    case 2:
                      To = !0;
                  }
                }
                Ee.callback !== null &&
                  Ee.lane !== 0 &&
                  ((h.flags |= 64),
                  (Bt = k.effects),
                  Bt === null ? (k.effects = [Ee]) : Bt.push(Ee));
              } else
                (Un = {
                  eventTime: Un,
                  lane: Bt,
                  tag: Ee.tag,
                  payload: Ee.payload,
                  callback: Ee.callback,
                  next: null,
                }),
                  Tt === null
                    ? ((ct = Tt = Un), (Qe = Kt))
                    : (Tt = Tt.next = Un),
                  (ce |= Bt);
              if (((Ee = Ee.next), Ee === null)) {
                if (((Ee = k.shared.pending), Ee === null)) break;
                (Bt = Ee),
                  (Ee = Bt.next),
                  (Bt.next = null),
                  (k.lastBaseUpdate = Bt),
                  (k.shared.pending = null);
              }
            } while (!0);
            if (
              (Tt === null && (Qe = Kt),
              (k.baseState = Qe),
              (k.firstBaseUpdate = ct),
              (k.lastBaseUpdate = Tt),
              (p = k.shared.interleaved),
              p !== null)
            ) {
              k = p;
              do (ce |= k.lane), (k = k.next);
              while (k !== p);
            } else z === null && (k.shared.lanes = 0);
            (_l |= ce), (h.lanes = ce), (h.memoizedState = Kt);
          }
        }
        function _g(h, p, b) {
          if (((h = p.effects), (p.effects = null), h !== null))
            for (p = 0; p < h.length; p++) {
              var C = h[p],
                k = C.callback;
              if (k !== null) {
                if (((C.callback = null), (C = b), typeof k != "function"))
                  throw Error(s(191, k));
                k.call(C);
              }
            }
        }
        var Sg = new r.Component().refs;
        function Yh(h, p, b, C) {
          (p = h.memoizedState),
            (b = b(C, p)),
            (b = b == null ? p : o({}, p, b)),
            (h.memoizedState = b),
            h.lanes === 0 && (h.updateQueue.baseState = b);
        }
        var Wf = {
          isMounted: function (h) {
            return (h = h._reactInternals) ? O(h) === h : !1;
          },
          enqueueSetState: function (h, p, b) {
            h = h._reactInternals;
            var C = Zr(),
              k = ws(h),
              z = Hs(C, k);
            (z.payload = p),
              b != null && (z.callback = b),
              Ma(h, z),
              (p = Xi(h, k, C)),
              p !== null && zf(p, h, k);
          },
          enqueueReplaceState: function (h, p, b) {
            h = h._reactInternals;
            var C = Zr(),
              k = ws(h),
              z = Hs(C, k);
            (z.tag = 1),
              (z.payload = p),
              b != null && (z.callback = b),
              Ma(h, z),
              (p = Xi(h, k, C)),
              p !== null && zf(p, h, k);
          },
          enqueueForceUpdate: function (h, p) {
            h = h._reactInternals;
            var b = Zr(),
              C = ws(h),
              k = Hs(b, C);
            (k.tag = 2),
              p != null && (k.callback = p),
              Ma(h, k),
              (p = Xi(h, C, b)),
              p !== null && zf(p, h, C);
          },
        };
        function qh(h, p, b, C, k, z, ce) {
          return (
            (h = h.stateNode),
            typeof h.shouldComponentUpdate == "function"
              ? h.shouldComponentUpdate(C, z, ce)
              : p.prototype && p.prototype.isPureReactComponent
              ? !Vi(b, C) || !Vi(k, z)
              : !0
          );
        }
        function wg(h, p, b) {
          var C = !1,
            k = Jt,
            z = p.contextType;
          return (
            typeof z == "object" && z !== null
              ? (z = tr(z))
              : ((k = jn(p) ? ii : zt.current),
                (C = p.contextTypes),
                (z = (C = C != null) ? Rn(h, k) : Jt)),
            (p = new p(b, z)),
            (h.memoizedState =
              p.state !== null && p.state !== void 0 ? p.state : null),
            (p.updater = Wf),
            (h.stateNode = p),
            (p._reactInternals = h),
            C &&
              ((h = h.stateNode),
              (h.__reactInternalMemoizedUnmaskedChildContext = k),
              (h.__reactInternalMemoizedMaskedChildContext = z)),
            p
          );
        }
        function bg(h, p, b, C) {
          (h = p.state),
            typeof p.componentWillReceiveProps == "function" &&
              p.componentWillReceiveProps(b, C),
            typeof p.UNSAFE_componentWillReceiveProps == "function" &&
              p.UNSAFE_componentWillReceiveProps(b, C),
            p.state !== h && Wf.enqueueReplaceState(p, p.state, null);
        }
        function Kh(h, p, b, C) {
          var k = h.stateNode;
          (k.props = b), (k.state = h.memoizedState), (k.refs = Sg), Ql(h);
          var z = p.contextType;
          typeof z == "object" && z !== null
            ? (k.context = tr(z))
            : ((z = jn(p) ? ii : zt.current), (k.context = Rn(h, z))),
            (k.state = h.memoizedState),
            (z = p.getDerivedStateFromProps),
            typeof z == "function" &&
              (Yh(h, p, z, b), (k.state = h.memoizedState)),
            typeof p.getDerivedStateFromProps == "function" ||
              typeof k.getSnapshotBeforeUpdate == "function" ||
              (typeof k.UNSAFE_componentWillMount != "function" &&
                typeof k.componentWillMount != "function") ||
              ((p = k.state),
              typeof k.componentWillMount == "function" &&
                k.componentWillMount(),
              typeof k.UNSAFE_componentWillMount == "function" &&
                k.UNSAFE_componentWillMount(),
              p !== k.state && Wf.enqueueReplaceState(k, k.state, null),
              Vf(h, b, k, C),
              (k.state = h.memoizedState)),
            typeof k.componentDidMount == "function" && (h.flags |= 4194308);
        }
        var eu = [],
          Ea = 0,
          Gf = null,
          jf = 0,
          Co = [],
          lo = 0,
          ol = null,
          Vs = 1,
          Ws = "";
        function sl(h, p) {
          (eu[Ea++] = jf), (eu[Ea++] = Gf), (Gf = h), (jf = p);
        }
        function Mg(h, p, b) {
          (Co[lo++] = Vs), (Co[lo++] = Ws), (Co[lo++] = ol), (ol = h);
          var C = Vs;
          h = Ws;
          var k = 32 - pi(C) - 1;
          (C &= ~(1 << k)), (b += 1);
          var z = 32 - pi(p) + k;
          if (30 < z) {
            var ce = k - (k % 5);
            (z = (C & ((1 << ce) - 1)).toString(32)),
              (C >>= ce),
              (k -= ce),
              (Vs = (1 << (32 - pi(p) + k)) | (b << k) | C),
              (Ws = z + h);
          } else (Vs = (1 << z) | (b << k) | C), (Ws = h);
        }
        function Zh(h) {
          h.return !== null && (sl(h, 1), Mg(h, 1, 0));
        }
        function Jh(h) {
          for (; h === Gf; )
            (Gf = eu[--Ea]), (eu[Ea] = null), (jf = eu[--Ea]), (eu[Ea] = null);
          for (; h === ol; )
            (ol = Co[--lo]),
              (Co[lo] = null),
              (Ws = Co[--lo]),
              (Co[lo] = null),
              (Vs = Co[--lo]),
              (Co[lo] = null);
        }
        var Mi = null,
          si = null,
          Kn = !1,
          tu = !1,
          Ao = null;
        function Qh(h, p) {
          var b = po(5, null, null, 0);
          (b.elementType = "DELETED"),
            (b.stateNode = p),
            (b.return = h),
            (p = h.deletions),
            p === null ? ((h.deletions = [b]), (h.flags |= 16)) : p.push(b);
        }
        function ep(h, p) {
          switch (h.tag) {
            case 5:
              return (
                (p = bn(p, h.type, h.pendingProps)),
                p !== null
                  ? ((h.stateNode = p), (Mi = h), (si = Br(p)), !0)
                  : !1
              );
            case 6:
              return (
                (p = yn(p, h.pendingProps)),
                p !== null ? ((h.stateNode = p), (Mi = h), (si = null), !0) : !1
              );
            case 13:
              if (((p = cr(p)), p !== null)) {
                var b = ol !== null ? { id: Vs, overflow: Ws } : null;
                return (
                  (h.memoizedState = {
                    dehydrated: p,
                    treeContext: b,
                    retryLane: 1073741824,
                  }),
                  (b = po(18, null, null, 0)),
                  (b.stateNode = p),
                  (b.return = h),
                  (h.child = b),
                  (Mi = h),
                  (si = null),
                  !0
                );
              }
              return !1;
            default:
              return !1;
          }
        }
        function $f(h) {
          return (h.mode & 1) !== 0 && (h.flags & 128) === 0;
        }
        function Ta(h) {
          if (Kn) {
            var p = si;
            if (p) {
              var b = p;
              if (!ep(h, p)) {
                if ($f(h)) throw Error(s(418));
                p = Ar(b);
                var C = Mi;
                p && ep(h, p)
                  ? Qh(C, b)
                  : ((h.flags = (h.flags & -4097) | 2), (Kn = !1), (Mi = h));
              }
            } else {
              if ($f(h)) throw Error(s(418));
              (h.flags = (h.flags & -4097) | 2), (Kn = !1), (Mi = h);
            }
          }
        }
        function Eg(h) {
          for (
            h = h.return;
            h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13;

          )
            h = h.return;
          Mi = h;
        }
        function ic(h) {
          if (!we || h !== Mi) return !1;
          if (!Kn) return Eg(h), (Kn = !0), !1;
          if (
            h.tag !== 3 &&
            (h.tag !== 5 || (ut(h.type) && !se(h.type, h.memoizedProps)))
          ) {
            var p = si;
            if (p) {
              if ($f(h)) {
                for (h = si; h; ) h = Ar(h);
                throw Error(s(418));
              }
              for (; p; ) Qh(h, p), (p = Ar(p));
            }
          }
          if ((Eg(h), h.tag === 13)) {
            if (!we) throw Error(s(316));
            if (
              ((h = h.memoizedState),
              (h = h !== null ? h.dehydrated : null),
              !h)
            )
              throw Error(s(317));
            si = ie(h);
          } else si = Mi ? Ar(h.stateNode) : null;
          return !0;
        }
        function nu() {
          we && ((si = Mi = null), (tu = Kn = !1));
        }
        function Xf(h) {
          Ao === null ? (Ao = [h]) : Ao.push(h);
        }
        function ru(h, p, b) {
          if (
            ((h = b.ref),
            h !== null && typeof h != "function" && typeof h != "object")
          ) {
            if (b._owner) {
              if (((b = b._owner), b)) {
                if (b.tag !== 1) throw Error(s(309));
                var C = b.stateNode;
              }
              if (!C) throw Error(s(147, h));
              var k = C,
                z = "" + h;
              return p !== null &&
                p.ref !== null &&
                typeof p.ref == "function" &&
                p.ref._stringRef === z
                ? p.ref
                : ((p = function (ce) {
                    var Ee = k.refs;
                    Ee === Sg && (Ee = k.refs = {}),
                      ce === null ? delete Ee[z] : (Ee[z] = ce);
                  }),
                  (p._stringRef = z),
                  p);
            }
            if (typeof h != "string") throw Error(s(284));
            if (!b._owner) throw Error(s(290, h));
          }
          return h;
        }
        function Ca(h, p) {
          throw (
            ((h = Object.prototype.toString.call(p)),
            Error(
              s(
                31,
                h === "[object Object]"
                  ? "object with keys {" + Object.keys(p).join(", ") + "}"
                  : h
              )
            ))
          );
        }
        function iu(h) {
          var p = h._init;
          return p(h._payload);
        }
        function Tg(h) {
          function p(He, Pe) {
            if (h) {
              var Ze = He.deletions;
              Ze === null
                ? ((He.deletions = [Pe]), (He.flags |= 16))
                : Ze.push(Pe);
            }
          }
          function b(He, Pe) {
            if (!h) return null;
            for (; Pe !== null; ) p(He, Pe), (Pe = Pe.sibling);
            return null;
          }
          function C(He, Pe) {
            for (He = new Map(); Pe !== null; )
              Pe.key !== null ? He.set(Pe.key, Pe) : He.set(Pe.index, Pe),
                (Pe = Pe.sibling);
            return He;
          }
          function k(He, Pe) {
            return (He = ta(He, Pe)), (He.index = 0), (He.sibling = null), He;
          }
          function z(He, Pe, Ze) {
            return (
              (He.index = Ze),
              h
                ? ((Ze = He.alternate),
                  Ze !== null
                    ? ((Ze = Ze.index), Ze < Pe ? ((He.flags |= 2), Pe) : Ze)
                    : ((He.flags |= 2), Pe))
                : ((He.flags |= 1048576), Pe)
            );
          }
          function ce(He) {
            return h && He.alternate === null && (He.flags |= 2), He;
          }
          function Ee(He, Pe, Ze, _t) {
            return Pe === null || Pe.tag !== 6
              ? ((Pe = Ed(Ze, He.mode, _t)), (Pe.return = He), Pe)
              : ((Pe = k(Pe, Ze)), (Pe.return = He), Pe);
          }
          function Qe(He, Pe, Ze, _t) {
            var Lt = Ze.type;
            return Lt === d
              ? Tt(He, Pe, Ze.props.children, _t, Ze.key)
              : Pe !== null &&
                (Pe.elementType === Lt ||
                  (typeof Lt == "object" &&
                    Lt !== null &&
                    Lt.$$typeof === M &&
                    iu(Lt) === Pe.type))
              ? ((_t = k(Pe, Ze.props)),
                (_t.ref = ru(He, Pe, Ze)),
                (_t.return = He),
                _t)
              : ((_t = Cc(Ze.type, Ze.key, Ze.props, null, He.mode, _t)),
                (_t.ref = ru(He, Pe, Ze)),
                (_t.return = He),
                _t);
          }
          function ct(He, Pe, Ze, _t) {
            return Pe === null ||
              Pe.tag !== 4 ||
              Pe.stateNode.containerInfo !== Ze.containerInfo ||
              Pe.stateNode.implementation !== Ze.implementation
              ? ((Pe = Td(Ze, He.mode, _t)), (Pe.return = He), Pe)
              : ((Pe = k(Pe, Ze.children || [])), (Pe.return = He), Pe);
          }
          function Tt(He, Pe, Ze, _t, Lt) {
            return Pe === null || Pe.tag !== 7
              ? ((Pe = Ba(Ze, He.mode, _t, Lt)), (Pe.return = He), Pe)
              : ((Pe = k(Pe, Ze)), (Pe.return = He), Pe);
          }
          function Kt(He, Pe, Ze) {
            if ((typeof Pe == "string" && Pe !== "") || typeof Pe == "number")
              return (Pe = Ed("" + Pe, He.mode, Ze)), (Pe.return = He), Pe;
            if (typeof Pe == "object" && Pe !== null) {
              switch (Pe.$$typeof) {
                case u:
                  return (
                    (Ze = Cc(Pe.type, Pe.key, Pe.props, null, He.mode, Ze)),
                    (Ze.ref = ru(He, null, Pe)),
                    (Ze.return = He),
                    Ze
                  );
                case c:
                  return (Pe = Td(Pe, He.mode, Ze)), (Pe.return = He), Pe;
                case M:
                  var _t = Pe._init;
                  return Kt(He, _t(Pe._payload), Ze);
              }
              if (Z(Pe) || D(Pe))
                return (Pe = Ba(Pe, He.mode, Ze, null)), (Pe.return = He), Pe;
              Ca(He, Pe);
            }
            return null;
          }
          function Bt(He, Pe, Ze, _t) {
            var Lt = Pe !== null ? Pe.key : null;
            if ((typeof Ze == "string" && Ze !== "") || typeof Ze == "number")
              return Lt !== null ? null : Ee(He, Pe, "" + Ze, _t);
            if (typeof Ze == "object" && Ze !== null) {
              switch (Ze.$$typeof) {
                case u:
                  return Ze.key === Lt ? Qe(He, Pe, Ze, _t) : null;
                case c:
                  return Ze.key === Lt ? ct(He, Pe, Ze, _t) : null;
                case M:
                  return (Lt = Ze._init), Bt(He, Pe, Lt(Ze._payload), _t);
              }
              if (Z(Ze) || D(Ze))
                return Lt !== null ? null : Tt(He, Pe, Ze, _t, null);
              Ca(He, Ze);
            }
            return null;
          }
          function Un(He, Pe, Ze, _t, Lt) {
            if ((typeof _t == "string" && _t !== "") || typeof _t == "number")
              return (He = He.get(Ze) || null), Ee(Pe, He, "" + _t, Lt);
            if (typeof _t == "object" && _t !== null) {
              switch (_t.$$typeof) {
                case u:
                  return (
                    (He = He.get(_t.key === null ? Ze : _t.key) || null),
                    Qe(Pe, He, _t, Lt)
                  );
                case c:
                  return (
                    (He = He.get(_t.key === null ? Ze : _t.key) || null),
                    ct(Pe, He, _t, Lt)
                  );
                case M:
                  var Qt = _t._init;
                  return Un(He, Pe, Ze, Qt(_t._payload), Lt);
              }
              if (Z(_t) || D(_t))
                return (He = He.get(Ze) || null), Tt(Pe, He, _t, Lt, null);
              Ca(Pe, _t);
            }
            return null;
          }
          function bt(He, Pe, Ze, _t) {
            for (
              var Lt = null, Qt = null, Yt = Pe, gn = (Pe = 0), Dr = null;
              Yt !== null && gn < Ze.length;
              gn++
            ) {
              Yt.index > gn ? ((Dr = Yt), (Yt = null)) : (Dr = Yt.sibling);
              var mn = Bt(He, Yt, Ze[gn], _t);
              if (mn === null) {
                Yt === null && (Yt = Dr);
                break;
              }
              h && Yt && mn.alternate === null && p(He, Yt),
                (Pe = z(mn, Pe, gn)),
                Qt === null ? (Lt = mn) : (Qt.sibling = mn),
                (Qt = mn),
                (Yt = Dr);
            }
            if (gn === Ze.length) return b(He, Yt), Kn && sl(He, gn), Lt;
            if (Yt === null) {
              for (; gn < Ze.length; gn++)
                (Yt = Kt(He, Ze[gn], _t)),
                  Yt !== null &&
                    ((Pe = z(Yt, Pe, gn)),
                    Qt === null ? (Lt = Yt) : (Qt.sibling = Yt),
                    (Qt = Yt));
              return Kn && sl(He, gn), Lt;
            }
            for (Yt = C(He, Yt); gn < Ze.length; gn++)
              (Dr = Un(Yt, He, gn, Ze[gn], _t)),
                Dr !== null &&
                  (h &&
                    Dr.alternate !== null &&
                    Yt.delete(Dr.key === null ? gn : Dr.key),
                  (Pe = z(Dr, Pe, gn)),
                  Qt === null ? (Lt = Dr) : (Qt.sibling = Dr),
                  (Qt = Dr));
            return (
              h &&
                Yt.forEach(function (bs) {
                  return p(He, bs);
                }),
              Kn && sl(He, gn),
              Lt
            );
          }
          function Tn(He, Pe, Ze, _t) {
            var Lt = D(Ze);
            if (typeof Lt != "function") throw Error(s(150));
            if (((Ze = Lt.call(Ze)), Ze == null)) throw Error(s(151));
            for (
              var Qt = (Lt = null),
                Yt = Pe,
                gn = (Pe = 0),
                Dr = null,
                mn = Ze.next();
              Yt !== null && !mn.done;
              gn++, mn = Ze.next()
            ) {
              Yt.index > gn ? ((Dr = Yt), (Yt = null)) : (Dr = Yt.sibling);
              var bs = Bt(He, Yt, mn.value, _t);
              if (bs === null) {
                Yt === null && (Yt = Dr);
                break;
              }
              h && Yt && bs.alternate === null && p(He, Yt),
                (Pe = z(bs, Pe, gn)),
                Qt === null ? (Lt = bs) : (Qt.sibling = bs),
                (Qt = bs),
                (Yt = Dr);
            }
            if (mn.done) return b(He, Yt), Kn && sl(He, gn), Lt;
            if (Yt === null) {
              for (; !mn.done; gn++, mn = Ze.next())
                (mn = Kt(He, mn.value, _t)),
                  mn !== null &&
                    ((Pe = z(mn, Pe, gn)),
                    Qt === null ? (Lt = mn) : (Qt.sibling = mn),
                    (Qt = mn));
              return Kn && sl(He, gn), Lt;
            }
            for (Yt = C(He, Yt); !mn.done; gn++, mn = Ze.next())
              (mn = Un(Yt, He, gn, mn.value, _t)),
                mn !== null &&
                  (h &&
                    mn.alternate !== null &&
                    Yt.delete(mn.key === null ? gn : mn.key),
                  (Pe = z(mn, Pe, gn)),
                  Qt === null ? (Lt = mn) : (Qt.sibling = mn),
                  (Qt = mn));
            return (
              h &&
                Yt.forEach(function (jg) {
                  return p(He, jg);
                }),
              Kn && sl(He, gn),
              Lt
            );
          }
          function mo(He, Pe, Ze, _t) {
            if (
              (typeof Ze == "object" &&
                Ze !== null &&
                Ze.type === d &&
                Ze.key === null &&
                (Ze = Ze.props.children),
              typeof Ze == "object" && Ze !== null)
            ) {
              switch (Ze.$$typeof) {
                case u:
                  e: {
                    for (var Lt = Ze.key, Qt = Pe; Qt !== null; ) {
                      if (Qt.key === Lt) {
                        if (((Lt = Ze.type), Lt === d)) {
                          if (Qt.tag === 7) {
                            b(He, Qt.sibling),
                              (Pe = k(Qt, Ze.props.children)),
                              (Pe.return = He),
                              (He = Pe);
                            break e;
                          }
                        } else if (
                          Qt.elementType === Lt ||
                          (typeof Lt == "object" &&
                            Lt !== null &&
                            Lt.$$typeof === M &&
                            iu(Lt) === Qt.type)
                        ) {
                          b(He, Qt.sibling),
                            (Pe = k(Qt, Ze.props)),
                            (Pe.ref = ru(He, Qt, Ze)),
                            (Pe.return = He),
                            (He = Pe);
                          break e;
                        }
                        b(He, Qt);
                        break;
                      } else p(He, Qt);
                      Qt = Qt.sibling;
                    }
                    Ze.type === d
                      ? ((Pe = Ba(Ze.props.children, He.mode, _t, Ze.key)),
                        (Pe.return = He),
                        (He = Pe))
                      : ((_t = Cc(
                          Ze.type,
                          Ze.key,
                          Ze.props,
                          null,
                          He.mode,
                          _t
                        )),
                        (_t.ref = ru(He, Pe, Ze)),
                        (_t.return = He),
                        (He = _t));
                  }
                  return ce(He);
                case c:
                  e: {
                    for (Qt = Ze.key; Pe !== null; ) {
                      if (Pe.key === Qt)
                        if (
                          Pe.tag === 4 &&
                          Pe.stateNode.containerInfo === Ze.containerInfo &&
                          Pe.stateNode.implementation === Ze.implementation
                        ) {
                          b(He, Pe.sibling),
                            (Pe = k(Pe, Ze.children || [])),
                            (Pe.return = He),
                            (He = Pe);
                          break e;
                        } else {
                          b(He, Pe);
                          break;
                        }
                      else p(He, Pe);
                      Pe = Pe.sibling;
                    }
                    (Pe = Td(Ze, He.mode, _t)), (Pe.return = He), (He = Pe);
                  }
                  return ce(He);
                case M:
                  return (Qt = Ze._init), mo(He, Pe, Qt(Ze._payload), _t);
              }
              if (Z(Ze)) return bt(He, Pe, Ze, _t);
              if (D(Ze)) return Tn(He, Pe, Ze, _t);
              Ca(He, Ze);
            }
            return (typeof Ze == "string" && Ze !== "") || typeof Ze == "number"
              ? ((Ze = "" + Ze),
                Pe !== null && Pe.tag === 6
                  ? (b(He, Pe.sibling),
                    (Pe = k(Pe, Ze)),
                    (Pe.return = He),
                    (He = Pe))
                  : (b(He, Pe),
                    (Pe = Ed(Ze, He.mode, _t)),
                    (Pe.return = He),
                    (He = Pe)),
                ce(He))
              : b(He, Pe);
          }
          return mo;
        }
        var Gs = Tg(!0),
          Cg = Tg(!1),
          ou = {},
          Gi = Mn(ou),
          al = Mn(ou),
          ll = Mn(ou);
        function Yo(h) {
          if (h === ou) throw Error(s(174));
          return h;
        }
        function Yf(h, p) {
          dt(ll, p), dt(al, h), dt(Gi, ou), (h = re(p)), wt(Gi), dt(Gi, h);
        }
        function su() {
          wt(Gi), wt(al), wt(ll);
        }
        function Ag(h) {
          var p = Yo(ll.current),
            b = Yo(Gi.current);
          (p = G(b, h.type, p)), b !== p && (dt(al, h), dt(Gi, p));
        }
        function tp(h) {
          al.current === h && (wt(Gi), wt(al));
        }
        var nr = Mn(0);
        function qf(h) {
          for (var p = h; p !== null; ) {
            if (p.tag === 13) {
              var b = p.memoizedState;
              if (
                b !== null &&
                ((b = b.dehydrated), b === null || Hi(b) || yr(b))
              )
                return p;
            } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
              if ((p.flags & 128) !== 0) return p;
            } else if (p.child !== null) {
              (p.child.return = p), (p = p.child);
              continue;
            }
            if (p === h) break;
            for (; p.sibling === null; ) {
              if (p.return === null || p.return === h) return null;
              p = p.return;
            }
            (p.sibling.return = p.return), (p = p.sibling);
          }
          return null;
        }
        var uo = [];
        function ul() {
          for (var h = 0; h < uo.length; h++) {
            var p = uo[h];
            ge
              ? (p._workInProgressVersionPrimary = null)
              : (p._workInProgressVersionSecondary = null);
          }
          uo.length = 0;
        }
        var oc = a.ReactCurrentDispatcher,
          co = a.ReactCurrentBatchConfig,
          cl = 0,
          rr = null,
          jr = null,
          $r = null,
          Kf = !1,
          vs = !1,
          fl = 0,
          sc = 0;
        function Xr() {
          throw Error(s(321));
        }
        function Zf(h, p) {
          if (p === null) return !1;
          for (var b = 0; b < p.length && b < h.length; b++)
            if (!Hr(h[b], p[b])) return !1;
          return !0;
        }
        function au(h, p, b, C, k, z) {
          if (
            ((cl = z),
            (rr = p),
            (p.memoizedState = null),
            (p.updateQueue = null),
            (p.lanes = 0),
            (oc.current = h === null || h.memoizedState === null ? ap : lp),
            (h = b(C, k)),
            vs)
          ) {
            z = 0;
            do {
              if (((vs = !1), (fl = 0), 25 <= z)) throw Error(s(301));
              (z += 1),
                ($r = jr = null),
                (p.updateQueue = null),
                (oc.current = up),
                (h = b(C, k));
            } while (vs);
          }
          if (
            ((oc.current = fu),
            (p = jr !== null && jr.next !== null),
            (cl = 0),
            ($r = jr = rr = null),
            (Kf = !1),
            p)
          )
            throw Error(s(300));
          return h;
        }
        function Aa() {
          var h = fl !== 0;
          return (fl = 0), h;
        }
        function qo() {
          var h = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return (
            $r === null ? (rr.memoizedState = $r = h) : ($r = $r.next = h), $r
          );
        }
        function Ko() {
          if (jr === null) {
            var h = rr.alternate;
            h = h !== null ? h.memoizedState : null;
          } else h = jr.next;
          var p = $r === null ? rr.memoizedState : $r.next;
          if (p !== null) ($r = p), (jr = h);
          else {
            if (h === null) throw Error(s(310));
            (jr = h),
              (h = {
                memoizedState: jr.memoizedState,
                baseState: jr.baseState,
                baseQueue: jr.baseQueue,
                queue: jr.queue,
                next: null,
              }),
              $r === null ? (rr.memoizedState = $r = h) : ($r = $r.next = h);
          }
          return $r;
        }
        function ys(h, p) {
          return typeof p == "function" ? p(h) : p;
        }
        function ac(h) {
          var p = Ko(),
            b = p.queue;
          if (b === null) throw Error(s(311));
          b.lastRenderedReducer = h;
          var C = jr,
            k = C.baseQueue,
            z = b.pending;
          if (z !== null) {
            if (k !== null) {
              var ce = k.next;
              (k.next = z.next), (z.next = ce);
            }
            (C.baseQueue = k = z), (b.pending = null);
          }
          if (k !== null) {
            (z = k.next), (C = C.baseState);
            var Ee = (ce = null),
              Qe = null,
              ct = z;
            do {
              var Tt = ct.lane;
              if ((cl & Tt) === Tt)
                Qe !== null &&
                  (Qe = Qe.next =
                    {
                      lane: 0,
                      action: ct.action,
                      hasEagerState: ct.hasEagerState,
                      eagerState: ct.eagerState,
                      next: null,
                    }),
                  (C = ct.hasEagerState ? ct.eagerState : h(C, ct.action));
              else {
                var Kt = {
                  lane: Tt,
                  action: ct.action,
                  hasEagerState: ct.hasEagerState,
                  eagerState: ct.eagerState,
                  next: null,
                };
                Qe === null ? ((Ee = Qe = Kt), (ce = C)) : (Qe = Qe.next = Kt),
                  (rr.lanes |= Tt),
                  (_l |= Tt);
              }
              ct = ct.next;
            } while (ct !== null && ct !== z);
            Qe === null ? (ce = C) : (Qe.next = Ee),
              Hr(C, p.memoizedState) || (Yr = !0),
              (p.memoizedState = C),
              (p.baseState = ce),
              (p.baseQueue = Qe),
              (b.lastRenderedState = C);
          }
          if (((h = b.interleaved), h !== null)) {
            k = h;
            do (z = k.lane), (rr.lanes |= z), (_l |= z), (k = k.next);
            while (k !== h);
          } else k === null && (b.lanes = 0);
          return [p.memoizedState, b.dispatch];
        }
        function lc(h) {
          var p = Ko(),
            b = p.queue;
          if (b === null) throw Error(s(311));
          b.lastRenderedReducer = h;
          var C = b.dispatch,
            k = b.pending,
            z = p.memoizedState;
          if (k !== null) {
            b.pending = null;
            var ce = (k = k.next);
            do (z = h(z, ce.action)), (ce = ce.next);
            while (ce !== k);
            Hr(z, p.memoizedState) || (Yr = !0),
              (p.memoizedState = z),
              p.baseQueue === null && (p.baseState = z),
              (b.lastRenderedState = z);
          }
          return [z, C];
        }
        function np() {}
        function rp(h, p) {
          var b = rr,
            C = Ko(),
            k = p(),
            z = !Hr(C.memoizedState, k);
          if (
            (z && ((C.memoizedState = k), (Yr = !0)),
            (C = C.queue),
            lu(js.bind(null, b, C, h), [h]),
            C.getSnapshot !== p ||
              z ||
              ($r !== null && $r.memoizedState.tag & 1))
          ) {
            if (
              ((b.flags |= 2048),
              cc(9, op.bind(null, b, C, k, p), void 0, null),
              ir === null)
            )
              throw Error(s(349));
            (cl & 30) !== 0 || ip(b, p, k);
          }
          return k;
        }
        function ip(h, p, b) {
          (h.flags |= 16384),
            (h = { getSnapshot: p, value: b }),
            (p = rr.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (rr.updateQueue = p),
                (p.stores = [h]))
              : ((b = p.stores), b === null ? (p.stores = [h]) : b.push(h));
        }
        function op(h, p, b, C) {
          (p.value = b), (p.getSnapshot = C), Jf(p) && Xi(h, 1, -1);
        }
        function js(h, p, b) {
          return b(function () {
            Jf(p) && Xi(h, 1, -1);
          });
        }
        function Jf(h) {
          var p = h.getSnapshot;
          h = h.value;
          try {
            var b = p();
            return !Hr(h, b);
          } catch {
            return !0;
          }
        }
        function uc(h) {
          var p = qo();
          return (
            typeof h == "function" && (h = h()),
            (p.memoizedState = p.baseState = h),
            (h = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: ys,
              lastRenderedState: h,
            }),
            (p.queue = h),
            (h = h.dispatch = Tx.bind(null, rr, h)),
            [p.memoizedState, h]
          );
        }
        function cc(h, p, b, C) {
          return (
            (h = { tag: h, create: p, destroy: b, deps: C, next: null }),
            (p = rr.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (rr.updateQueue = p),
                (p.lastEffect = h.next = h))
              : ((b = p.lastEffect),
                b === null
                  ? (p.lastEffect = h.next = h)
                  : ((C = b.next),
                    (b.next = h),
                    (h.next = C),
                    (p.lastEffect = h))),
            h
          );
        }
        function Rg() {
          return Ko().memoizedState;
        }
        function Ra(h, p, b, C) {
          var k = qo();
          (rr.flags |= h),
            (k.memoizedState = cc(1 | p, b, void 0, C === void 0 ? null : C));
        }
        function Qf(h, p, b, C) {
          var k = Ko();
          C = C === void 0 ? null : C;
          var z = void 0;
          if (jr !== null) {
            var ce = jr.memoizedState;
            if (((z = ce.destroy), C !== null && Zf(C, ce.deps))) {
              k.memoizedState = cc(p, b, z, C);
              return;
            }
          }
          (rr.flags |= h), (k.memoizedState = cc(1 | p, b, z, C));
        }
        function ed(h, p) {
          return Ra(8390656, 8, h, p);
        }
        function lu(h, p) {
          return Qf(2048, 8, h, p);
        }
        function zn(h, p) {
          return Qf(4, 2, h, p);
        }
        function td(h, p) {
          return Qf(4, 4, h, p);
        }
        function fc(h, p) {
          if (typeof p == "function")
            return (
              (h = h()),
              p(h),
              function () {
                p(null);
              }
            );
          if (p != null)
            return (
              (h = h()),
              (p.current = h),
              function () {
                p.current = null;
              }
            );
        }
        function uu(h, p, b) {
          return (
            (b = b != null ? b.concat([h]) : null),
            Qf(4, 4, fc.bind(null, p, h), b)
          );
        }
        function nd() {}
        function rd(h, p) {
          var b = Ko();
          p = p === void 0 ? null : p;
          var C = b.memoizedState;
          return C !== null && p !== null && Zf(p, C[1])
            ? C[0]
            : ((b.memoizedState = [h, p]), h);
        }
        function cu(h, p) {
          var b = Ko();
          p = p === void 0 ? null : p;
          var C = b.memoizedState;
          return C !== null && p !== null && Zf(p, C[1])
            ? C[0]
            : ((h = h()), (b.memoizedState = [h, p]), h);
        }
        function id(h, p) {
          var b = Xt;
          (Xt = b !== 0 && 4 > b ? b : 4), h(!0);
          var C = co.transition;
          co.transition = {};
          try {
            h(!1), p();
          } finally {
            (Xt = b), (co.transition = C);
          }
        }
        function dl() {
          return Ko().memoizedState;
        }
        function Pg(h, p, b) {
          var C = ws(h);
          (b = {
            lane: C,
            action: b,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          }),
            Ig(h)
              ? sp(p, b)
              : (dc(h, p, b),
                (b = Zr()),
                (h = Xi(h, C, b)),
                h !== null && hc(h, p, C));
        }
        function Tx(h, p, b) {
          var C = ws(h),
            k = {
              lane: C,
              action: b,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
          if (Ig(h)) sp(p, k);
          else {
            dc(h, p, k);
            var z = h.alternate;
            if (
              h.lanes === 0 &&
              (z === null || z.lanes === 0) &&
              ((z = p.lastRenderedReducer), z !== null)
            )
              try {
                var ce = p.lastRenderedState,
                  Ee = z(ce, b);
                if (((k.hasEagerState = !0), (k.eagerState = Ee), Hr(Ee, ce)))
                  return;
              } catch {
              } finally {
              }
            (b = Zr()), (h = Xi(h, C, b)), h !== null && hc(h, p, C);
          }
        }
        function Ig(h) {
          var p = h.alternate;
          return h === rr || (p !== null && p === rr);
        }
        function sp(h, p) {
          vs = Kf = !0;
          var b = h.pending;
          b === null ? (p.next = p) : ((p.next = b.next), (b.next = p)),
            (h.pending = p);
        }
        function dc(h, p, b) {
          ir !== null && (h.mode & 1) !== 0 && (nn & 2) === 0
            ? ((h = p.interleaved),
              h === null
                ? ((b.next = b), bi === null ? (bi = [p]) : bi.push(p))
                : ((b.next = h.next), (h.next = b)),
              (p.interleaved = b))
            : ((h = p.pending),
              h === null ? (b.next = b) : ((b.next = h.next), (h.next = b)),
              (p.pending = b));
        }
        function hc(h, p, b) {
          if ((b & 4194240) !== 0) {
            var C = p.lanes;
            (C &= h.pendingLanes), (b |= C), (p.lanes = b), oi(h, b);
          }
        }
        var fu = {
            readContext: tr,
            useCallback: Xr,
            useContext: Xr,
            useEffect: Xr,
            useImperativeHandle: Xr,
            useInsertionEffect: Xr,
            useLayoutEffect: Xr,
            useMemo: Xr,
            useReducer: Xr,
            useRef: Xr,
            useState: Xr,
            useDebugValue: Xr,
            useDeferredValue: Xr,
            useTransition: Xr,
            useMutableSource: Xr,
            useSyncExternalStore: Xr,
            useId: Xr,
            unstable_isNewReconciler: !1,
          },
          ap = {
            readContext: tr,
            useCallback: function (h, p) {
              return (qo().memoizedState = [h, p === void 0 ? null : p]), h;
            },
            useContext: tr,
            useEffect: ed,
            useImperativeHandle: function (h, p, b) {
              return (
                (b = b != null ? b.concat([h]) : null),
                Ra(4194308, 4, fc.bind(null, p, h), b)
              );
            },
            useLayoutEffect: function (h, p) {
              return Ra(4194308, 4, h, p);
            },
            useInsertionEffect: function (h, p) {
              return Ra(4, 2, h, p);
            },
            useMemo: function (h, p) {
              var b = qo();
              return (
                (p = p === void 0 ? null : p),
                (h = h()),
                (b.memoizedState = [h, p]),
                h
              );
            },
            useReducer: function (h, p, b) {
              var C = qo();
              return (
                (p = b !== void 0 ? b(p) : p),
                (C.memoizedState = C.baseState = p),
                (h = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: h,
                  lastRenderedState: p,
                }),
                (C.queue = h),
                (h = h.dispatch = Pg.bind(null, rr, h)),
                [C.memoizedState, h]
              );
            },
            useRef: function (h) {
              var p = qo();
              return (h = { current: h }), (p.memoizedState = h);
            },
            useState: uc,
            useDebugValue: nd,
            useDeferredValue: function (h) {
              var p = uc(h),
                b = p[0],
                C = p[1];
              return (
                ed(
                  function () {
                    var k = co.transition;
                    co.transition = {};
                    try {
                      C(h);
                    } finally {
                      co.transition = k;
                    }
                  },
                  [h]
                ),
                b
              );
            },
            useTransition: function () {
              var h = uc(!1),
                p = h[0];
              return (
                (h = id.bind(null, h[1])), (qo().memoizedState = h), [p, h]
              );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (h, p, b) {
              var C = rr,
                k = qo();
              if (Kn) {
                if (b === void 0) throw Error(s(407));
                b = b();
              } else {
                if (((b = p()), ir === null)) throw Error(s(349));
                (cl & 30) !== 0 || ip(C, p, b);
              }
              k.memoizedState = b;
              var z = { value: b, getSnapshot: p };
              return (
                (k.queue = z),
                ed(js.bind(null, C, z, h), [h]),
                (C.flags |= 2048),
                cc(9, op.bind(null, C, z, b, p), void 0, null),
                b
              );
            },
            useId: function () {
              var h = qo(),
                p = ir.identifierPrefix;
              if (Kn) {
                var b = Ws,
                  C = Vs;
                (b = (C & ~(1 << (32 - pi(C) - 1))).toString(32) + b),
                  (p = ":" + p + "R" + b),
                  (b = fl++),
                  0 < b && (p += "H" + b.toString(32)),
                  (p += ":");
              } else (b = sc++), (p = ":" + p + "r" + b.toString(32) + ":");
              return (h.memoizedState = p);
            },
            unstable_isNewReconciler: !1,
          },
          lp = {
            readContext: tr,
            useCallback: rd,
            useContext: tr,
            useEffect: lu,
            useImperativeHandle: uu,
            useInsertionEffect: zn,
            useLayoutEffect: td,
            useMemo: cu,
            useReducer: ac,
            useRef: Rg,
            useState: function () {
              return ac(ys);
            },
            useDebugValue: nd,
            useDeferredValue: function (h) {
              var p = ac(ys),
                b = p[0],
                C = p[1];
              return (
                lu(
                  function () {
                    var k = co.transition;
                    co.transition = {};
                    try {
                      C(h);
                    } finally {
                      co.transition = k;
                    }
                  },
                  [h]
                ),
                b
              );
            },
            useTransition: function () {
              var h = ac(ys)[0],
                p = Ko().memoizedState;
              return [h, p];
            },
            useMutableSource: np,
            useSyncExternalStore: rp,
            useId: dl,
            unstable_isNewReconciler: !1,
          },
          up = {
            readContext: tr,
            useCallback: rd,
            useContext: tr,
            useEffect: lu,
            useImperativeHandle: uu,
            useInsertionEffect: zn,
            useLayoutEffect: td,
            useMemo: cu,
            useReducer: lc,
            useRef: Rg,
            useState: function () {
              return lc(ys);
            },
            useDebugValue: nd,
            useDeferredValue: function (h) {
              var p = lc(ys),
                b = p[0],
                C = p[1];
              return (
                lu(
                  function () {
                    var k = co.transition;
                    co.transition = {};
                    try {
                      C(h);
                    } finally {
                      co.transition = k;
                    }
                  },
                  [h]
                ),
                b
              );
            },
            useTransition: function () {
              var h = lc(ys)[0],
                p = Ko().memoizedState;
              return [h, p];
            },
            useMutableSource: np,
            useSyncExternalStore: rp,
            useId: dl,
            unstable_isNewReconciler: !1,
          };
        function cp(h, p) {
          try {
            var b = "",
              C = p;
            do (b += Us(C)), (C = C.return);
            while (C);
            var k = b;
          } catch (z) {
            k =
              `
Error generating stack: ` +
              z.message +
              `
` +
              z.stack;
          }
          return { value: h, source: p, stack: k };
        }
        function od(h, p) {
          try {
            console.error(p.value);
          } catch (b) {
            setTimeout(function () {
              throw b;
            });
          }
        }
        var Cx = typeof WeakMap == "function" ? WeakMap : Map;
        function Lg(h, p, b) {
          (b = Hs(-1, b)), (b.tag = 3), (b.payload = { element: null });
          var C = p.value;
          return (
            (b.callback = function () {
              ka || ((ka = !0), (Lo = C)), od(h, p);
            }),
            b
          );
        }
        function sd(h, p, b) {
          (b = Hs(-1, b)), (b.tag = 3);
          var C = h.type.getDerivedStateFromError;
          if (typeof C == "function") {
            var k = p.value;
            (b.payload = function () {
              return C(k);
            }),
              (b.callback = function () {
                od(h, p);
              });
          }
          var z = h.stateNode;
          return (
            z !== null &&
              typeof z.componentDidCatch == "function" &&
              (b.callback = function () {
                od(h, p),
                  typeof C != "function" &&
                    (Do === null ? (Do = new Set([this])) : Do.add(this));
                var ce = p.stack;
                this.componentDidCatch(p.value, {
                  componentStack: ce !== null ? ce : "",
                });
              }),
            b
          );
        }
        function $s(h, p, b) {
          var C = h.pingCache;
          if (C === null) {
            C = h.pingCache = new Cx();
            var k = new Set();
            C.set(p, k);
          } else (k = C.get(p)), k === void 0 && ((k = new Set()), C.set(p, k));
          k.has(b) || (k.add(b), (h = Ng.bind(null, h, p, b)), p.then(h, h));
        }
        function fp(h) {
          do {
            var p;
            if (
              ((p = h.tag === 13) &&
                ((p = h.memoizedState),
                (p = p !== null ? p.dehydrated !== null : !0)),
              p)
            )
              return h;
            h = h.return;
          } while (h !== null);
          return null;
        }
        function hl(h, p, b, C, k) {
          return (h.mode & 1) === 0
            ? (h === p
                ? (h.flags |= 65536)
                : ((h.flags |= 128),
                  (b.flags |= 131072),
                  (b.flags &= -52805),
                  b.tag === 1 &&
                    (b.alternate === null
                      ? (b.tag = 17)
                      : ((p = Hs(-1, 1)), (p.tag = 2), Ma(b, p))),
                  (b.lanes |= 1)),
              h)
            : ((h.flags |= 65536), (h.lanes = k), h);
        }
        function Lr(h) {
          h.flags |= 4;
        }
        function du(h, p) {
          if (h !== null && h.child === p.child) return !0;
          if ((p.flags & 16) !== 0) return !1;
          for (h = p.child; h !== null; ) {
            if ((h.flags & 12854) !== 0 || (h.subtreeFlags & 12854) !== 0)
              return !1;
            h = h.sibling;
          }
          return !0;
        }
        var fo, pl, ad, ld;
        if (xe)
          (fo = function (h, p) {
            for (var b = p.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6) ne(h, b.stateNode);
              else if (b.tag !== 4 && b.child !== null) {
                (b.child.return = b), (b = b.child);
                continue;
              }
              if (b === p) break;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === p) return;
                b = b.return;
              }
              (b.sibling.return = b.return), (b = b.sibling);
            }
          }),
            (pl = function () {}),
            (ad = function (h, p, b, C, k) {
              if (((h = h.memoizedProps), h !== C)) {
                var z = p.stateNode,
                  ce = Yo(Gi.current);
                (b = J(z, b, h, C, k, ce)), (p.updateQueue = b) && Lr(p);
              }
            }),
            (ld = function (h, p, b, C) {
              b !== C && Lr(p);
            });
        else if (j) {
          fo = function (h, p, b, C) {
            for (var k = p.child; k !== null; ) {
              if (k.tag === 5) {
                var z = k.stateNode;
                b && C && (z = $t(z, k.type, k.memoizedProps, k)), ne(h, z);
              } else if (k.tag === 6)
                (z = k.stateNode),
                  b && C && (z = un(z, k.memoizedProps, k)),
                  ne(h, z);
              else if (k.tag !== 4) {
                if (k.tag === 22 && k.memoizedState !== null)
                  (z = k.child), z !== null && (z.return = k), fo(h, k, !0, !0);
                else if (k.child !== null) {
                  (k.child.return = k), (k = k.child);
                  continue;
                }
              }
              if (k === p) break;
              for (; k.sibling === null; ) {
                if (k.return === null || k.return === p) return;
                k = k.return;
              }
              (k.sibling.return = k.return), (k = k.sibling);
            }
          };
          var Pa = function (h, p, b, C) {
            for (var k = p.child; k !== null; ) {
              if (k.tag === 5) {
                var z = k.stateNode;
                b && C && (z = $t(z, k.type, k.memoizedProps, k)), Nt(h, z);
              } else if (k.tag === 6)
                (z = k.stateNode),
                  b && C && (z = un(z, k.memoizedProps, k)),
                  Nt(h, z);
              else if (k.tag !== 4) {
                if (k.tag === 22 && k.memoizedState !== null)
                  (z = k.child), z !== null && (z.return = k), Pa(h, k, !0, !0);
                else if (k.child !== null) {
                  (k.child.return = k), (k = k.child);
                  continue;
                }
              }
              if (k === p) break;
              for (; k.sibling === null; ) {
                if (k.return === null || k.return === p) return;
                k = k.return;
              }
              (k.sibling.return = k.return), (k = k.sibling);
            }
          };
          (pl = function (h, p) {
            var b = p.stateNode;
            if (!du(h, p)) {
              h = b.containerInfo;
              var C = gt(h);
              Pa(C, p, !1, !1), (b.pendingChildren = C), Lr(p), Ut(h, C);
            }
          }),
            (ad = function (h, p, b, C, k) {
              var z = h.stateNode,
                ce = h.memoizedProps;
              if ((h = du(h, p)) && ce === C) p.stateNode = z;
              else {
                var Ee = p.stateNode,
                  Qe = Yo(Gi.current),
                  ct = null;
                ce !== C && (ct = J(Ee, b, ce, C, k, Qe)),
                  h && ct === null
                    ? (p.stateNode = z)
                    : ((z = mt(z, ct, b, ce, C, p, h, Ee)),
                      ae(z, b, C, k, Qe) && Lr(p),
                      (p.stateNode = z),
                      h ? Lr(p) : fo(z, p, !1, !1));
              }
            }),
            (ld = function (h, p, b, C) {
              b !== C
                ? ((h = Yo(ll.current)),
                  (b = Yo(Gi.current)),
                  (p.stateNode = de(C, h, b, p)),
                  Lr(p))
                : (p.stateNode = h.stateNode);
            });
        } else
          (pl = function () {}), (ad = function () {}), (ld = function () {});
        function Xs(h, p) {
          if (!Kn)
            switch (h.tailMode) {
              case "hidden":
                p = h.tail;
                for (var b = null; p !== null; )
                  p.alternate !== null && (b = p), (p = p.sibling);
                b === null ? (h.tail = null) : (b.sibling = null);
                break;
              case "collapsed":
                b = h.tail;
                for (var C = null; b !== null; )
                  b.alternate !== null && (C = b), (b = b.sibling);
                C === null
                  ? p || h.tail === null
                    ? (h.tail = null)
                    : (h.tail.sibling = null)
                  : (C.sibling = null);
            }
        }
        function hr(h) {
          var p = h.alternate !== null && h.alternate.child === h.child,
            b = 0,
            C = 0;
          if (p)
            for (var k = h.child; k !== null; )
              (b |= k.lanes | k.childLanes),
                (C |= k.subtreeFlags & 14680064),
                (C |= k.flags & 14680064),
                (k.return = h),
                (k = k.sibling);
          else
            for (k = h.child; k !== null; )
              (b |= k.lanes | k.childLanes),
                (C |= k.subtreeFlags),
                (C |= k.flags),
                (k.return = h),
                (k = k.sibling);
          return (h.subtreeFlags |= C), (h.childLanes = b), p;
        }
        function ud(h, p, b) {
          var C = p.pendingProps;
          switch ((Jh(p), p.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return hr(p), null;
            case 1:
              return jn(p.type) && cn(), hr(p), null;
            case 3:
              return (
                (C = p.stateNode),
                su(),
                wt(En),
                wt(zt),
                ul(),
                C.pendingContext &&
                  ((C.context = C.pendingContext), (C.pendingContext = null)),
                (h === null || h.child === null) &&
                  (ic(p)
                    ? Lr(p)
                    : h === null ||
                      (h.memoizedState.isDehydrated && (p.flags & 256) === 0) ||
                      ((p.flags |= 1024),
                      Ao !== null && (mr(Ao), (Ao = null)))),
                pl(h, p),
                hr(p),
                null
              );
            case 5:
              tp(p), (b = Yo(ll.current));
              var k = p.type;
              if (h !== null && p.stateNode != null)
                ad(h, p, k, C, b),
                  h.ref !== p.ref && ((p.flags |= 512), (p.flags |= 2097152));
              else {
                if (!C) {
                  if (p.stateNode === null) throw Error(s(166));
                  return hr(p), null;
                }
                if (((h = Yo(Gi.current)), ic(p))) {
                  if (!we) throw Error(s(175));
                  (h = ql(p.stateNode, p.type, p.memoizedProps, b, h, p, !tu)),
                    (p.updateQueue = h),
                    h !== null && Lr(p);
                } else {
                  var z = V(k, C, b, h, p);
                  fo(z, p, !1, !1),
                    (p.stateNode = z),
                    ae(z, k, C, b, h) && Lr(p);
                }
                p.ref !== null && ((p.flags |= 512), (p.flags |= 2097152));
              }
              return hr(p), null;
            case 6:
              if (h && p.stateNode != null) ld(h, p, h.memoizedProps, C);
              else {
                if (typeof C != "string" && p.stateNode === null)
                  throw Error(s(166));
                if (((h = Yo(ll.current)), (b = Yo(Gi.current)), ic(p))) {
                  if (!we) throw Error(s(176));
                  if (
                    ((h = p.stateNode),
                    (C = p.memoizedProps),
                    (b = oo(h, C, p, !tu)) && ((k = Mi), k !== null))
                  )
                    switch (((z = (k.mode & 1) !== 0), k.tag)) {
                      case 3:
                        yt(k.stateNode.containerInfo, h, C, z);
                        break;
                      case 5:
                        Et(k.type, k.memoizedProps, k.stateNode, h, C, z);
                    }
                  b && Lr(p);
                } else p.stateNode = de(C, h, b, p);
              }
              return hr(p), null;
            case 13:
              if (
                (wt(nr),
                (C = p.memoizedState),
                Kn &&
                  si !== null &&
                  (p.mode & 1) !== 0 &&
                  (p.flags & 128) === 0)
              ) {
                for (h = si; h; ) h = Ar(h);
                return nu(), (p.flags |= 98560), p;
              }
              if (C !== null && C.dehydrated !== null) {
                if (((C = ic(p)), h === null)) {
                  if (!C) throw Error(s(318));
                  if (!we) throw Error(s(344));
                  if (
                    ((h = p.memoizedState),
                    (h = h !== null ? h.dehydrated : null),
                    !h)
                  )
                    throw Error(s(317));
                  Kl(h, p);
                } else
                  nu(),
                    (p.flags & 128) === 0 && (p.memoizedState = null),
                    (p.flags |= 4);
                return hr(p), null;
              }
              return (
                Ao !== null && (mr(Ao), (Ao = null)),
                (p.flags & 128) !== 0
                  ? ((p.lanes = b), p)
                  : ((C = C !== null),
                    (b = !1),
                    h === null ? ic(p) : (b = h.memoizedState !== null),
                    C &&
                      !b &&
                      ((p.child.flags |= 8192),
                      (p.mode & 1) !== 0 &&
                        (h === null || (nr.current & 1) !== 0
                          ? Sr === 0 && (Sr = 3)
                          : wc())),
                    p.updateQueue !== null && (p.flags |= 4),
                    hr(p),
                    null)
              );
            case 4:
              return (
                su(),
                pl(h, p),
                h === null && Oe(p.stateNode.containerInfo),
                hr(p),
                null
              );
            case 10:
              return _r(p.type._context), hr(p), null;
            case 17:
              return jn(p.type) && cn(), hr(p), null;
            case 19:
              if ((wt(nr), (k = p.memoizedState), k === null))
                return hr(p), null;
              if (((C = (p.flags & 128) !== 0), (z = k.rendering), z === null))
                if (C) Xs(k, !1);
                else {
                  if (Sr !== 0 || (h !== null && (h.flags & 128) !== 0))
                    for (h = p.child; h !== null; ) {
                      if (((z = qf(h)), z !== null)) {
                        for (
                          p.flags |= 128,
                            Xs(k, !1),
                            h = z.updateQueue,
                            h !== null && ((p.updateQueue = h), (p.flags |= 4)),
                            p.subtreeFlags = 0,
                            h = b,
                            C = p.child;
                          C !== null;

                        )
                          (b = C),
                            (k = h),
                            (b.flags &= 14680066),
                            (z = b.alternate),
                            z === null
                              ? ((b.childLanes = 0),
                                (b.lanes = k),
                                (b.child = null),
                                (b.subtreeFlags = 0),
                                (b.memoizedProps = null),
                                (b.memoizedState = null),
                                (b.updateQueue = null),
                                (b.dependencies = null),
                                (b.stateNode = null))
                              : ((b.childLanes = z.childLanes),
                                (b.lanes = z.lanes),
                                (b.child = z.child),
                                (b.subtreeFlags = 0),
                                (b.deletions = null),
                                (b.memoizedProps = z.memoizedProps),
                                (b.memoizedState = z.memoizedState),
                                (b.updateQueue = z.updateQueue),
                                (b.type = z.type),
                                (k = z.dependencies),
                                (b.dependencies =
                                  k === null
                                    ? null
                                    : {
                                        lanes: k.lanes,
                                        firstContext: k.firstContext,
                                      })),
                            (C = C.sibling);
                        return dt(nr, (nr.current & 1) | 2), p.child;
                      }
                      h = h.sibling;
                    }
                  k.tail !== null &&
                    qn() > Da &&
                    ((p.flags |= 128),
                    (C = !0),
                    Xs(k, !1),
                    (p.lanes = 4194304));
                }
              else {
                if (!C)
                  if (((h = qf(z)), h !== null)) {
                    if (
                      ((p.flags |= 128),
                      (C = !0),
                      (h = h.updateQueue),
                      h !== null && ((p.updateQueue = h), (p.flags |= 4)),
                      Xs(k, !0),
                      k.tail === null &&
                        k.tailMode === "hidden" &&
                        !z.alternate &&
                        !Kn)
                    )
                      return hr(p), null;
                  } else
                    2 * qn() - k.renderingStartTime > Da &&
                      b !== 1073741824 &&
                      ((p.flags |= 128),
                      (C = !0),
                      Xs(k, !1),
                      (p.lanes = 4194304));
                k.isBackwards
                  ? ((z.sibling = p.child), (p.child = z))
                  : ((h = k.last),
                    h !== null ? (h.sibling = z) : (p.child = z),
                    (k.last = z));
              }
              return k.tail !== null
                ? ((p = k.tail),
                  (k.rendering = p),
                  (k.tail = p.sibling),
                  (k.renderingStartTime = qn()),
                  (p.sibling = null),
                  (h = nr.current),
                  dt(nr, C ? (h & 1) | 2 : h & 1),
                  p)
                : (hr(p), null);
            case 22:
            case 23:
              return (
                _p(),
                (C = p.memoizedState !== null),
                h !== null &&
                  (h.memoizedState !== null) !== C &&
                  (p.flags |= 8192),
                C && (p.mode & 1) !== 0
                  ? (Ri & 1073741824) !== 0 &&
                    (hr(p), xe && p.subtreeFlags & 6 && (p.flags |= 8192))
                  : hr(p),
                null
              );
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(s(156, p.tag));
        }
        var dp = a.ReactCurrentOwner,
          Yr = !1;
        function or(h, p, b, C) {
          p.child = h === null ? Cg(p, null, b, C) : Gs(p, h.child, b, C);
        }
        function Hn(h, p, b, C, k) {
          b = b.render;
          var z = p.ref;
          return (
            dr(p, k),
            (C = au(h, p, b, C, z, k)),
            (b = Aa()),
            h !== null && !Yr
              ? ((p.updateQueue = h.updateQueue),
                (p.flags &= -2053),
                (h.lanes &= ~k),
                ji(h, p, k))
              : (Kn && b && Zh(p), (p.flags |= 1), or(h, p, C, k), p.child)
          );
        }
        function Nn(h, p, b, C, k) {
          if (h === null) {
            var z = b.type;
            return typeof z == "function" &&
              !Tc(z) &&
              z.defaultProps === void 0 &&
              b.compare === null &&
              b.defaultProps === void 0
              ? ((p.tag = 15), (p.type = z), Ys(h, p, z, C, k))
              : ((h = Cc(b.type, null, C, p, p.mode, k)),
                (h.ref = p.ref),
                (h.return = p),
                (p.child = h));
          }
          if (((z = h.child), (h.lanes & k) === 0)) {
            var ce = z.memoizedProps;
            if (
              ((b = b.compare),
              (b = b !== null ? b : Vi),
              b(ce, C) && h.ref === p.ref)
            )
              return ji(h, p, k);
          }
          return (
            (p.flags |= 1),
            (h = ta(z, C)),
            (h.ref = p.ref),
            (h.return = p),
            (p.child = h)
          );
        }
        function Ys(h, p, b, C, k) {
          if (h !== null && Vi(h.memoizedProps, C) && h.ref === p.ref)
            if (((Yr = !1), (h.lanes & k) !== 0))
              (h.flags & 131072) !== 0 && (Yr = !0);
            else return (p.lanes = h.lanes), ji(h, p, k);
          return qs(h, p, b, C, k);
        }
        function ai(h, p, b) {
          var C = p.pendingProps,
            k = C.children,
            z = h !== null ? h.memoizedState : null;
          if (C.mode === "hidden")
            if ((p.mode & 1) === 0)
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                dt(ea, Ri),
                (Ri |= b);
            else if ((b & 1073741824) !== 0)
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                (C = z !== null ? z.baseLanes : b),
                dt(ea, Ri),
                (Ri |= C);
            else
              return (
                (h = z !== null ? z.baseLanes | b : b),
                (p.lanes = p.childLanes = 1073741824),
                (p.memoizedState = { baseLanes: h, cachePool: null }),
                (p.updateQueue = null),
                dt(ea, Ri),
                (Ri |= h),
                null
              );
          else
            z !== null
              ? ((C = z.baseLanes | b), (p.memoizedState = null))
              : (C = b),
              dt(ea, Ri),
              (Ri |= C);
          return or(h, p, k, b), p.child;
        }
        function Ei(h, p) {
          var b = p.ref;
          ((h === null && b !== null) || (h !== null && h.ref !== b)) &&
            ((p.flags |= 512), (p.flags |= 2097152));
        }
        function qs(h, p, b, C, k) {
          var z = jn(b) ? ii : zt.current;
          return (
            (z = Rn(p, z)),
            dr(p, k),
            (b = au(h, p, b, C, z, k)),
            (C = Aa()),
            h !== null && !Yr
              ? ((p.updateQueue = h.updateQueue),
                (p.flags &= -2053),
                (h.lanes &= ~k),
                ji(h, p, k))
              : (Kn && C && Zh(p), (p.flags |= 1), or(h, p, b, k), p.child)
          );
        }
        function ml(h, p, b, C, k) {
          if (jn(b)) {
            var z = !0;
            fr(p);
          } else z = !1;
          if ((dr(p, k), p.stateNode === null))
            h !== null &&
              ((h.alternate = null), (p.alternate = null), (p.flags |= 2)),
              wg(p, b, C),
              Kh(p, b, C, k),
              (C = !0);
          else if (h === null) {
            var ce = p.stateNode,
              Ee = p.memoizedProps;
            ce.props = Ee;
            var Qe = ce.context,
              ct = b.contextType;
            typeof ct == "object" && ct !== null
              ? (ct = tr(ct))
              : ((ct = jn(b) ? ii : zt.current), (ct = Rn(p, ct)));
            var Tt = b.getDerivedStateFromProps,
              Kt =
                typeof Tt == "function" ||
                typeof ce.getSnapshotBeforeUpdate == "function";
            Kt ||
              (typeof ce.UNSAFE_componentWillReceiveProps != "function" &&
                typeof ce.componentWillReceiveProps != "function") ||
              ((Ee !== C || Qe !== ct) && bg(p, ce, C, ct)),
              (To = !1);
            var Bt = p.memoizedState;
            (ce.state = Bt),
              Vf(p, C, ce, k),
              (Qe = p.memoizedState),
              Ee !== C || Bt !== Qe || En.current || To
                ? (typeof Tt == "function" &&
                    (Yh(p, b, Tt, C), (Qe = p.memoizedState)),
                  (Ee = To || qh(p, b, Ee, C, Bt, Qe, ct))
                    ? (Kt ||
                        (typeof ce.UNSAFE_componentWillMount != "function" &&
                          typeof ce.componentWillMount != "function") ||
                        (typeof ce.componentWillMount == "function" &&
                          ce.componentWillMount(),
                        typeof ce.UNSAFE_componentWillMount == "function" &&
                          ce.UNSAFE_componentWillMount()),
                      typeof ce.componentDidMount == "function" &&
                        (p.flags |= 4194308))
                    : (typeof ce.componentDidMount == "function" &&
                        (p.flags |= 4194308),
                      (p.memoizedProps = C),
                      (p.memoizedState = Qe)),
                  (ce.props = C),
                  (ce.state = Qe),
                  (ce.context = ct),
                  (C = Ee))
                : (typeof ce.componentDidMount == "function" &&
                    (p.flags |= 4194308),
                  (C = !1));
          } else {
            (ce = p.stateNode),
              Xh(h, p),
              (Ee = p.memoizedProps),
              (ct = p.type === p.elementType ? Ee : Wr(p.type, Ee)),
              (ce.props = ct),
              (Kt = p.pendingProps),
              (Bt = ce.context),
              (Qe = b.contextType),
              typeof Qe == "object" && Qe !== null
                ? (Qe = tr(Qe))
                : ((Qe = jn(b) ? ii : zt.current), (Qe = Rn(p, Qe)));
            var Un = b.getDerivedStateFromProps;
            (Tt =
              typeof Un == "function" ||
              typeof ce.getSnapshotBeforeUpdate == "function") ||
              (typeof ce.UNSAFE_componentWillReceiveProps != "function" &&
                typeof ce.componentWillReceiveProps != "function") ||
              ((Ee !== Kt || Bt !== Qe) && bg(p, ce, C, Qe)),
              (To = !1),
              (Bt = p.memoizedState),
              (ce.state = Bt),
              Vf(p, C, ce, k);
            var bt = p.memoizedState;
            Ee !== Kt || Bt !== bt || En.current || To
              ? (typeof Un == "function" &&
                  (Yh(p, b, Un, C), (bt = p.memoizedState)),
                (ct = To || qh(p, b, ct, C, Bt, bt, Qe) || !1)
                  ? (Tt ||
                      (typeof ce.UNSAFE_componentWillUpdate != "function" &&
                        typeof ce.componentWillUpdate != "function") ||
                      (typeof ce.componentWillUpdate == "function" &&
                        ce.componentWillUpdate(C, bt, Qe),
                      typeof ce.UNSAFE_componentWillUpdate == "function" &&
                        ce.UNSAFE_componentWillUpdate(C, bt, Qe)),
                    typeof ce.componentDidUpdate == "function" &&
                      (p.flags |= 4),
                    typeof ce.getSnapshotBeforeUpdate == "function" &&
                      (p.flags |= 1024))
                  : (typeof ce.componentDidUpdate != "function" ||
                      (Ee === h.memoizedProps && Bt === h.memoizedState) ||
                      (p.flags |= 4),
                    typeof ce.getSnapshotBeforeUpdate != "function" ||
                      (Ee === h.memoizedProps && Bt === h.memoizedState) ||
                      (p.flags |= 1024),
                    (p.memoizedProps = C),
                    (p.memoizedState = bt)),
                (ce.props = C),
                (ce.state = bt),
                (ce.context = Qe),
                (C = ct))
              : (typeof ce.componentDidUpdate != "function" ||
                  (Ee === h.memoizedProps && Bt === h.memoizedState) ||
                  (p.flags |= 4),
                typeof ce.getSnapshotBeforeUpdate != "function" ||
                  (Ee === h.memoizedProps && Bt === h.memoizedState) ||
                  (p.flags |= 1024),
                (C = !1));
          }
          return vi(h, p, b, C, z, k);
        }
        function vi(h, p, b, C, k, z) {
          Ei(h, p);
          var ce = (p.flags & 128) !== 0;
          if (!C && !ce) return k && Rr(p, b, !1), ji(h, p, z);
          (C = p.stateNode), (dp.current = p);
          var Ee =
            ce && typeof b.getDerivedStateFromError != "function"
              ? null
              : C.render();
          return (
            (p.flags |= 1),
            h !== null && ce
              ? ((p.child = Gs(p, h.child, null, z)),
                (p.child = Gs(p, null, Ee, z)))
              : or(h, p, Ee, z),
            (p.memoizedState = C.state),
            k && Rr(p, b, !0),
            p.child
          );
        }
        function pc(h) {
          var p = h.stateNode;
          p.pendingContext
            ? zr(h, p.pendingContext, p.pendingContext !== p.context)
            : p.context && zr(h, p.context, !1),
            Yf(h, p.containerInfo);
        }
        function hp(h, p, b, C, k) {
          return nu(), Xf(k), (p.flags |= 256), or(h, p, b, C), p.child;
        }
        var mc = { dehydrated: null, treeContext: null, retryLane: 0 };
        function gl(h) {
          return { baseLanes: h, cachePool: null };
        }
        function pp(h, p, b) {
          var C = p.pendingProps,
            k = nr.current,
            z = !1,
            ce = (p.flags & 128) !== 0,
            Ee;
          if (
            ((Ee = ce) ||
              (Ee =
                h !== null && h.memoizedState === null ? !1 : (k & 2) !== 0),
            Ee
              ? ((z = !0), (p.flags &= -129))
              : (h === null || h.memoizedState !== null) && (k |= 1),
            dt(nr, k & 1),
            h === null)
          )
            return (
              Ta(p),
              (h = p.memoizedState),
              h !== null && ((h = h.dehydrated), h !== null)
                ? ((p.mode & 1) === 0
                    ? (p.lanes = 1)
                    : yr(h)
                    ? (p.lanes = 8)
                    : (p.lanes = 1073741824),
                  null)
                : ((k = C.children),
                  (h = C.fallback),
                  z
                    ? ((C = p.mode),
                      (z = p.child),
                      (k = { mode: "hidden", children: k }),
                      (C & 1) === 0 && z !== null
                        ? ((z.childLanes = 0), (z.pendingProps = k))
                        : (z = Mu(k, C, 0, null)),
                      (h = Ba(h, C, b, null)),
                      (z.return = p),
                      (h.return = p),
                      (z.sibling = h),
                      (p.child = z),
                      (p.child.memoizedState = gl(b)),
                      (p.memoizedState = mc),
                      h)
                    : Zo(p, k))
            );
          if (((k = h.memoizedState), k !== null)) {
            if (((Ee = k.dehydrated), Ee !== null)) {
              if (ce)
                return p.flags & 256
                  ? ((p.flags &= -257), vc(h, p, b, Error(s(422))))
                  : p.memoizedState !== null
                  ? ((p.child = h.child), (p.flags |= 128), null)
                  : ((z = C.fallback),
                    (k = p.mode),
                    (C = Mu(
                      { mode: "visible", children: C.children },
                      k,
                      0,
                      null
                    )),
                    (z = Ba(z, k, b, null)),
                    (z.flags |= 2),
                    (C.return = p),
                    (z.return = p),
                    (C.sibling = z),
                    (p.child = C),
                    (p.mode & 1) !== 0 && Gs(p, h.child, null, b),
                    (p.child.memoizedState = gl(b)),
                    (p.memoizedState = mc),
                    z);
              if ((p.mode & 1) === 0) p = vc(h, p, b, null);
              else if (yr(Ee)) p = vc(h, p, b, Error(s(419)));
              else if (((C = (b & h.childLanes) !== 0), Yr || C)) {
                if (((C = ir), C !== null)) {
                  switch (b & -b) {
                    case 4:
                      z = 2;
                      break;
                    case 16:
                      z = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      z = 32;
                      break;
                    case 536870912:
                      z = 268435456;
                      break;
                    default:
                      z = 0;
                  }
                  (C = (z & (C.suspendedLanes | b)) !== 0 ? 0 : z),
                    C !== 0 &&
                      C !== k.retryLane &&
                      ((k.retryLane = C), Xi(h, C, -1));
                }
                wc(), (p = vc(h, p, b, Error(s(421))));
              } else
                Hi(Ee)
                  ? ((p.flags |= 128),
                    (p.child = h.child),
                    (p = Ug.bind(null, h)),
                    Fr(Ee, p),
                    (p = null))
                  : ((b = k.treeContext),
                    we &&
                      ((si = So(Ee)),
                      (Mi = p),
                      (Kn = !0),
                      (Ao = null),
                      (tu = !1),
                      b !== null &&
                        ((Co[lo++] = Vs),
                        (Co[lo++] = Ws),
                        (Co[lo++] = ol),
                        (Vs = b.id),
                        (Ws = b.overflow),
                        (ol = p))),
                    (p = Zo(p, p.pendingProps.children)),
                    (p.flags |= 4096));
              return p;
            }
            return z
              ? ((C = cd(h, p, C.children, C.fallback, b)),
                (z = p.child),
                (k = h.child.memoizedState),
                (z.memoizedState =
                  k === null
                    ? gl(b)
                    : { baseLanes: k.baseLanes | b, cachePool: null }),
                (z.childLanes = h.childLanes & ~b),
                (p.memoizedState = mc),
                C)
              : ((b = gc(h, p, C.children, b)), (p.memoizedState = null), b);
          }
          return z
            ? ((C = cd(h, p, C.children, C.fallback, b)),
              (z = p.child),
              (k = h.child.memoizedState),
              (z.memoizedState =
                k === null
                  ? gl(b)
                  : { baseLanes: k.baseLanes | b, cachePool: null }),
              (z.childLanes = h.childLanes & ~b),
              (p.memoizedState = mc),
              C)
            : ((b = gc(h, p, C.children, b)), (p.memoizedState = null), b);
        }
        function Zo(h, p) {
          return (
            (p = Mu({ mode: "visible", children: p }, h.mode, 0, null)),
            (p.return = h),
            (h.child = p)
          );
        }
        function gc(h, p, b, C) {
          var k = h.child;
          return (
            (h = k.sibling),
            (b = ta(k, { mode: "visible", children: b })),
            (p.mode & 1) === 0 && (b.lanes = C),
            (b.return = p),
            (b.sibling = null),
            h !== null &&
              ((C = p.deletions),
              C === null ? ((p.deletions = [h]), (p.flags |= 16)) : C.push(h)),
            (p.child = b)
          );
        }
        function cd(h, p, b, C, k) {
          var z = p.mode;
          h = h.child;
          var ce = h.sibling,
            Ee = { mode: "hidden", children: b };
          return (
            (z & 1) === 0 && p.child !== h
              ? ((b = p.child),
                (b.childLanes = 0),
                (b.pendingProps = Ee),
                (p.deletions = null))
              : ((b = ta(h, Ee)), (b.subtreeFlags = h.subtreeFlags & 14680064)),
            ce !== null
              ? (C = ta(ce, C))
              : ((C = Ba(C, z, k, null)), (C.flags |= 2)),
            (C.return = p),
            (b.return = p),
            (b.sibling = C),
            (p.child = b),
            C
          );
        }
        function vc(h, p, b, C) {
          return (
            C !== null && Xf(C),
            Gs(p, h.child, null, b),
            (h = Zo(p, p.pendingProps.children)),
            (h.flags |= 2),
            (p.memoizedState = null),
            h
          );
        }
        function Dg(h, p, b) {
          h.lanes |= p;
          var C = h.alternate;
          C !== null && (C.lanes |= p), Ir(h.return, p, b);
        }
        function xs(h, p, b, C, k) {
          var z = h.memoizedState;
          z === null
            ? (h.memoizedState = {
                isBackwards: p,
                rendering: null,
                renderingStartTime: 0,
                last: C,
                tail: b,
                tailMode: k,
              })
            : ((z.isBackwards = p),
              (z.rendering = null),
              (z.renderingStartTime = 0),
              (z.last = C),
              (z.tail = b),
              (z.tailMode = k));
        }
        function vl(h, p, b) {
          var C = p.pendingProps,
            k = C.revealOrder,
            z = C.tail;
          if ((or(h, p, C.children, b), (C = nr.current), (C & 2) !== 0))
            (C = (C & 1) | 2), (p.flags |= 128);
          else {
            if (h !== null && (h.flags & 128) !== 0)
              e: for (h = p.child; h !== null; ) {
                if (h.tag === 13) h.memoizedState !== null && Dg(h, b, p);
                else if (h.tag === 19) Dg(h, b, p);
                else if (h.child !== null) {
                  (h.child.return = h), (h = h.child);
                  continue;
                }
                if (h === p) break e;
                for (; h.sibling === null; ) {
                  if (h.return === null || h.return === p) break e;
                  h = h.return;
                }
                (h.sibling.return = h.return), (h = h.sibling);
              }
            C &= 1;
          }
          if ((dt(nr, C), (p.mode & 1) === 0)) p.memoizedState = null;
          else
            switch (k) {
              case "forwards":
                for (b = p.child, k = null; b !== null; )
                  (h = b.alternate),
                    h !== null && qf(h) === null && (k = b),
                    (b = b.sibling);
                (b = k),
                  b === null
                    ? ((k = p.child), (p.child = null))
                    : ((k = b.sibling), (b.sibling = null)),
                  xs(p, !1, k, b, z);
                break;
              case "backwards":
                for (b = null, k = p.child, p.child = null; k !== null; ) {
                  if (((h = k.alternate), h !== null && qf(h) === null)) {
                    p.child = k;
                    break;
                  }
                  (h = k.sibling), (k.sibling = b), (b = k), (k = h);
                }
                xs(p, !0, b, null, z);
                break;
              case "together":
                xs(p, !1, null, null, void 0);
                break;
              default:
                p.memoizedState = null;
            }
          return p.child;
        }
        function ji(h, p, b) {
          if (
            (h !== null && (p.dependencies = h.dependencies),
            (_l |= p.lanes),
            (b & p.childLanes) === 0)
          )
            return null;
          if (h !== null && p.child !== h.child) throw Error(s(153));
          if (p.child !== null) {
            for (
              h = p.child, b = ta(h, h.pendingProps), p.child = b, b.return = p;
              h.sibling !== null;

            )
              (h = h.sibling),
                (b = b.sibling = ta(h, h.pendingProps)),
                (b.return = p);
            b.sibling = null;
          }
          return p.child;
        }
        function fd(h, p, b) {
          switch (p.tag) {
            case 3:
              pc(p), nu();
              break;
            case 5:
              Ag(p);
              break;
            case 1:
              jn(p.type) && fr(p);
              break;
            case 4:
              Yf(p, p.stateNode.containerInfo);
              break;
            case 10:
              zs(p, p.type._context, p.memoizedProps.value);
              break;
            case 13:
              var C = p.memoizedState;
              if (C !== null)
                return C.dehydrated !== null
                  ? (dt(nr, nr.current & 1), (p.flags |= 128), null)
                  : (b & p.child.childLanes) !== 0
                  ? pp(h, p, b)
                  : (dt(nr, nr.current & 1),
                    (h = ji(h, p, b)),
                    h !== null ? h.sibling : null);
              dt(nr, nr.current & 1);
              break;
            case 19:
              if (((C = (b & p.childLanes) !== 0), (h.flags & 128) !== 0)) {
                if (C) return vl(h, p, b);
                p.flags |= 128;
              }
              var k = p.memoizedState;
              if (
                (k !== null &&
                  ((k.rendering = null),
                  (k.tail = null),
                  (k.lastEffect = null)),
                dt(nr, nr.current),
                C)
              )
                break;
              return null;
            case 22:
            case 23:
              return (p.lanes = 0), ai(h, p, b);
          }
          return ji(h, p, b);
        }
        function dd(h, p) {
          switch ((Jh(p), p.tag)) {
            case 1:
              return (
                jn(p.type) && cn(),
                (h = p.flags),
                h & 65536 ? ((p.flags = (h & -65537) | 128), p) : null
              );
            case 3:
              return (
                su(),
                wt(En),
                wt(zt),
                ul(),
                (h = p.flags),
                (h & 65536) !== 0 && (h & 128) === 0
                  ? ((p.flags = (h & -65537) | 128), p)
                  : null
              );
            case 5:
              return tp(p), null;
            case 13:
              if (
                (wt(nr),
                (h = p.memoizedState),
                h !== null && h.dehydrated !== null)
              ) {
                if (p.alternate === null) throw Error(s(340));
                nu();
              }
              return (
                (h = p.flags),
                h & 65536 ? ((p.flags = (h & -65537) | 128), p) : null
              );
            case 19:
              return wt(nr), null;
            case 4:
              return su(), null;
            case 10:
              return _r(p.type._context), null;
            case 22:
            case 23:
              return _p(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Ti = !1,
          qr = !1,
          yl = typeof WeakSet == "function" ? WeakSet : Set,
          pt = null;
        function Ro(h, p) {
          var b = h.ref;
          if (b !== null)
            if (typeof b == "function")
              try {
                b(null);
              } catch (C) {
                Ii(h, p, C);
              }
            else b.current = null;
        }
        function Ks(h, p, b) {
          try {
            b();
          } catch (C) {
            Ii(h, p, C);
          }
        }
        var mp = !1;
        function gp(h, p) {
          for (te(h.containerInfo), pt = p; pt !== null; )
            if (
              ((h = pt),
              (p = h.child),
              (h.subtreeFlags & 1028) !== 0 && p !== null)
            )
              (p.return = h), (pt = p);
            else
              for (; pt !== null; ) {
                h = pt;
                try {
                  var b = h.alternate;
                  if ((h.flags & 1024) !== 0)
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        break;
                      case 1:
                        if (b !== null) {
                          var C = b.memoizedProps,
                            k = b.memoizedState,
                            z = h.stateNode,
                            ce = z.getSnapshotBeforeUpdate(
                              h.elementType === h.type ? C : Wr(h.type, C),
                              k
                            );
                          z.__reactInternalSnapshotBeforeUpdate = ce;
                        }
                        break;
                      case 3:
                        xe && it(h.stateNode.containerInfo);
                        break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                        break;
                      default:
                        throw Error(s(163));
                    }
                } catch (Ee) {
                  Ii(h, h.return, Ee);
                }
                if (((p = h.sibling), p !== null)) {
                  (p.return = h.return), (pt = p);
                  break;
                }
                pt = h.return;
              }
          return (b = mp), (mp = !1), b;
        }
        function Zs(h, p, b) {
          var C = p.updateQueue;
          if (((C = C !== null ? C.lastEffect : null), C !== null)) {
            var k = (C = C.next);
            do {
              if ((k.tag & h) === h) {
                var z = k.destroy;
                (k.destroy = void 0), z !== void 0 && Ks(p, b, z);
              }
              k = k.next;
            } while (k !== C);
          }
        }
        function li(h, p) {
          if (
            ((p = p.updateQueue),
            (p = p !== null ? p.lastEffect : null),
            p !== null)
          ) {
            var b = (p = p.next);
            do {
              if ((b.tag & h) === h) {
                var C = b.create;
                b.destroy = C();
              }
              b = b.next;
            } while (b !== p);
          }
        }
        function Ci(h) {
          var p = h.ref;
          if (p !== null) {
            var b = h.stateNode;
            switch (h.tag) {
              case 5:
                h = Y(b);
                break;
              default:
                h = b;
            }
            typeof p == "function" ? p(h) : (p.current = h);
          }
        }
        function $n(h, p, b) {
          if (ao && typeof ao.onCommitFiberUnmount == "function")
            try {
              ao.onCommitFiberUnmount(_a, p);
            } catch {}
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                ((h = p.updateQueue),
                h !== null && ((h = h.lastEffect), h !== null))
              ) {
                var C = (h = h.next);
                do {
                  var k = C,
                    z = k.destroy;
                  (k = k.tag),
                    z !== void 0 &&
                      ((k & 2) !== 0 || (k & 4) !== 0) &&
                      Ks(p, b, z),
                    (C = C.next);
                } while (C !== h);
              }
              break;
            case 1:
              if (
                (Ro(p, b),
                (h = p.stateNode),
                typeof h.componentWillUnmount == "function")
              )
                try {
                  (h.props = p.memoizedProps),
                    (h.state = p.memoizedState),
                    h.componentWillUnmount();
                } catch (ce) {
                  Ii(p, b, ce);
                }
              break;
            case 5:
              Ro(p, b);
              break;
            case 4:
              xe
                ? xp(h, p, b)
                : j &&
                  j &&
                  ((p = p.stateNode.containerInfo), (b = gt(p)), ht(p, b));
          }
        }
        function Po(h, p, b) {
          for (var C = p; ; )
            if (($n(h, C, b), C.child === null || (xe && C.tag === 4))) {
              if (C === p) break;
              for (; C.sibling === null; ) {
                if (C.return === null || C.return === p) return;
                C = C.return;
              }
              (C.sibling.return = C.return), (C = C.sibling);
            } else (C.child.return = C), (C = C.child);
        }
        function vp(h) {
          var p = h.alternate;
          p !== null && ((h.alternate = null), vp(p)),
            (h.child = null),
            (h.deletions = null),
            (h.sibling = null),
            h.tag === 5 && ((p = h.stateNode), p !== null && rt(p)),
            (h.stateNode = null),
            (h.return = null),
            (h.dependencies = null),
            (h.memoizedProps = null),
            (h.memoizedState = null),
            (h.pendingProps = null),
            (h.stateNode = null),
            (h.updateQueue = null);
        }
        function yp(h) {
          return h.tag === 5 || h.tag === 3 || h.tag === 4;
        }
        function hd(h) {
          e: for (;;) {
            for (; h.sibling === null; ) {
              if (h.return === null || yp(h.return)) return null;
              h = h.return;
            }
            for (
              h.sibling.return = h.return, h = h.sibling;
              h.tag !== 5 && h.tag !== 6 && h.tag !== 18;

            ) {
              if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
              (h.child.return = h), (h = h.child);
            }
            if (!(h.flags & 2)) return h.stateNode;
          }
        }
        function pd(h) {
          if (xe) {
            e: {
              for (var p = h.return; p !== null; ) {
                if (yp(p)) break e;
                p = p.return;
              }
              throw Error(s(160));
            }
            var b = p;
            switch (b.tag) {
              case 5:
                (p = b.stateNode),
                  b.flags & 32 && (Je(p), (b.flags &= -33)),
                  (b = hd(h)),
                  hu(h, b, p);
                break;
              case 3:
              case 4:
                (p = b.stateNode.containerInfo), (b = hd(h)), md(h, b, p);
                break;
              default:
                throw Error(s(161));
            }
          }
        }
        function md(h, p, b) {
          var C = h.tag;
          if (C === 5 || C === 6) (h = h.stateNode), p ? qe(b, h, p) : Ge(b, h);
          else if (C !== 4 && ((h = h.child), h !== null))
            for (md(h, p, b), h = h.sibling; h !== null; )
              md(h, p, b), (h = h.sibling);
        }
        function hu(h, p, b) {
          var C = h.tag;
          if (C === 5 || C === 6) (h = h.stateNode), p ? $e(b, h, p) : Be(b, h);
          else if (C !== 4 && ((h = h.child), h !== null))
            for (hu(h, p, b), h = h.sibling; h !== null; )
              hu(h, p, b), (h = h.sibling);
        }
        function xp(h, p, b) {
          for (var C = p, k = !1, z, ce; ; ) {
            if (!k) {
              k = C.return;
              e: for (;;) {
                if (k === null) throw Error(s(160));
                switch (((z = k.stateNode), k.tag)) {
                  case 5:
                    ce = !1;
                    break e;
                  case 3:
                    (z = z.containerInfo), (ce = !0);
                    break e;
                  case 4:
                    (z = z.containerInfo), (ce = !0);
                    break e;
                }
                k = k.return;
              }
              k = !0;
            }
            if (C.tag === 5 || C.tag === 6)
              Po(h, C, b), ce ? he(z, C.stateNode) : et(z, C.stateNode);
            else if (C.tag === 18) ce ? Le(z, C.stateNode) : We(z, C.stateNode);
            else if (C.tag === 4) {
              if (C.child !== null) {
                (z = C.stateNode.containerInfo),
                  (ce = !0),
                  (C.child.return = C),
                  (C = C.child);
                continue;
              }
            } else if (($n(h, C, b), C.child !== null)) {
              (C.child.return = C), (C = C.child);
              continue;
            }
            if (C === p) break;
            for (; C.sibling === null; ) {
              if (C.return === null || C.return === p) return;
              (C = C.return), C.tag === 4 && (k = !1);
            }
            (C.sibling.return = C.return), (C = C.sibling);
          }
        }
        function Ia(h, p) {
          if (xe) {
            switch (p.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Zs(3, p, p.return), li(3, p), Zs(5, p, p.return);
                return;
              case 1:
                return;
              case 5:
                var b = p.stateNode;
                if (b != null) {
                  var C = p.memoizedProps;
                  h = h !== null ? h.memoizedProps : C;
                  var k = p.type,
                    z = p.updateQueue;
                  (p.updateQueue = null), z !== null && xt(b, z, k, h, C, p);
                }
                return;
              case 6:
                if (p.stateNode === null) throw Error(s(162));
                (b = p.memoizedProps),
                  Ye(p.stateNode, h !== null ? h.memoizedProps : b, b);
                return;
              case 3:
                we &&
                  h !== null &&
                  h.memoizedState.isDehydrated &&
                  Ce(p.stateNode.containerInfo);
                return;
              case 12:
                return;
              case 13:
                pu(p);
                return;
              case 19:
                pu(p);
                return;
              case 17:
                return;
            }
            throw Error(s(163));
          }
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              Zs(3, p, p.return), li(3, p), Zs(5, p, p.return);
              return;
            case 12:
              return;
            case 13:
              pu(p);
              return;
            case 19:
              pu(p);
              return;
            case 3:
              we &&
                h !== null &&
                h.memoizedState.isDehydrated &&
                Ce(p.stateNode.containerInfo);
              break;
            case 22:
            case 23:
              return;
          }
          e: if (j) {
            switch (p.tag) {
              case 1:
              case 5:
              case 6:
                break e;
              case 3:
              case 4:
                (p = p.stateNode), ht(p.containerInfo, p.pendingChildren);
                break e;
            }
            throw Error(s(163));
          }
        }
        function pu(h) {
          var p = h.updateQueue;
          if (p !== null) {
            h.updateQueue = null;
            var b = h.stateNode;
            b === null && (b = h.stateNode = new yl()),
              p.forEach(function (C) {
                var k = Mc.bind(null, h, C);
                b.has(C) || (b.add(C), C.then(k, k));
              });
          }
        }
        function Ax(h, p) {
          for (pt = p; pt !== null; ) {
            p = pt;
            var b = p.deletions;
            if (b !== null)
              for (var C = 0; C < b.length; C++) {
                var k = b[C];
                try {
                  var z = h;
                  xe ? xp(z, k, p) : Po(z, k, p);
                  var ce = k.alternate;
                  ce !== null && (ce.return = null), (k.return = null);
                } catch (Lt) {
                  Ii(k, p, Lt);
                }
              }
            if (((b = p.child), (p.subtreeFlags & 12854) !== 0 && b !== null))
              (b.return = p), (pt = b);
            else
              for (; pt !== null; ) {
                p = pt;
                try {
                  var Ee = p.flags;
                  if ((Ee & 32 && xe && Je(p.stateNode), Ee & 512)) {
                    var Qe = p.alternate;
                    if (Qe !== null) {
                      var ct = Qe.ref;
                      ct !== null &&
                        (typeof ct == "function"
                          ? ct(null)
                          : (ct.current = null));
                    }
                  }
                  if (Ee & 8192)
                    switch (p.tag) {
                      case 13:
                        if (p.memoizedState !== null) {
                          var Tt = p.alternate;
                          (Tt === null || Tt.memoizedState === null) &&
                            (yd = qn());
                        }
                        break;
                      case 22:
                        var Kt = p.memoizedState !== null,
                          Bt = p.alternate,
                          Un = Bt !== null && Bt.memoizedState !== null;
                        if (((b = p), xe)) {
                          e: if (((C = b), (k = Kt), (z = null), xe))
                            for (var bt = C; ; ) {
                              if (bt.tag === 5) {
                                if (z === null) {
                                  z = bt;
                                  var Tn = bt.stateNode;
                                  k
                                    ? me(Tn)
                                    : Re(bt.stateNode, bt.memoizedProps);
                                }
                              } else if (bt.tag === 6) {
                                if (z === null) {
                                  var mo = bt.stateNode;
                                  k ? Ve(mo) : Ue(mo, bt.memoizedProps);
                                }
                              } else if (
                                ((bt.tag !== 22 && bt.tag !== 23) ||
                                  bt.memoizedState === null ||
                                  bt === C) &&
                                bt.child !== null
                              ) {
                                (bt.child.return = bt), (bt = bt.child);
                                continue;
                              }
                              if (bt === C) break;
                              for (; bt.sibling === null; ) {
                                if (bt.return === null || bt.return === C)
                                  break e;
                                z === bt && (z = null), (bt = bt.return);
                              }
                              z === bt && (z = null),
                                (bt.sibling.return = bt.return),
                                (bt = bt.sibling);
                            }
                        }
                        if (Kt && !Un && (b.mode & 1) !== 0) {
                          pt = b;
                          for (var He = b.child; He !== null; ) {
                            for (b = pt = He; pt !== null; ) {
                              C = pt;
                              var Pe = C.child;
                              switch (C.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                  Zs(4, C, C.return);
                                  break;
                                case 1:
                                  Ro(C, C.return);
                                  var Ze = C.stateNode;
                                  if (
                                    typeof Ze.componentWillUnmount == "function"
                                  ) {
                                    var _t = C.return;
                                    try {
                                      (Ze.props = C.memoizedProps),
                                        (Ze.state = C.memoizedState),
                                        Ze.componentWillUnmount();
                                    } catch (Lt) {
                                      Ii(C, _t, Lt);
                                    }
                                  }
                                  break;
                                case 5:
                                  Ro(C, C.return);
                                  break;
                                case 22:
                                  if (C.memoizedState !== null) {
                                    xl(b);
                                    continue;
                                  }
                              }
                              Pe !== null
                                ? ((Pe.return = C), (pt = Pe))
                                : xl(b);
                            }
                            He = He.sibling;
                          }
                        }
                    }
                  switch (Ee & 4102) {
                    case 2:
                      pd(p), (p.flags &= -3);
                      break;
                    case 6:
                      pd(p), (p.flags &= -3), Ia(p.alternate, p);
                      break;
                    case 4096:
                      p.flags &= -4097;
                      break;
                    case 4100:
                      (p.flags &= -4097), Ia(p.alternate, p);
                      break;
                    case 4:
                      Ia(p.alternate, p);
                  }
                } catch (Lt) {
                  Ii(p, p.return, Lt);
                }
                if (((b = p.sibling), b !== null)) {
                  (b.return = p.return), (pt = b);
                  break;
                }
                pt = p.return;
              }
          }
        }
        function Jo(h, p, b) {
          (pt = h), yc(h);
        }
        function yc(h, p, b) {
          for (var C = (h.mode & 1) !== 0; pt !== null; ) {
            var k = pt,
              z = k.child;
            if (k.tag === 22 && C) {
              var ce = k.memoizedState !== null || Ti;
              if (!ce) {
                var Ee = k.alternate,
                  Qe = (Ee !== null && Ee.memoizedState !== null) || qr;
                Ee = Ti;
                var ct = qr;
                if (((Ti = ce), (qr = Qe) && !ct))
                  for (pt = k; pt !== null; )
                    (ce = pt),
                      (Qe = ce.child),
                      ce.tag === 22 && ce.memoizedState !== null
                        ? gd(k)
                        : Qe !== null
                        ? ((Qe.return = ce), (pt = Qe))
                        : gd(k);
                for (; z !== null; ) (pt = z), yc(z), (z = z.sibling);
                (pt = k), (Ti = Ee), (qr = ct);
              }
              xc(h);
            } else
              (k.subtreeFlags & 8772) !== 0 && z !== null
                ? ((z.return = k), (pt = z))
                : xc(h);
          }
        }
        function xc(h) {
          for (; pt !== null; ) {
            var p = pt;
            if ((p.flags & 8772) !== 0) {
              var b = p.alternate;
              try {
                if ((p.flags & 8772) !== 0)
                  switch (p.tag) {
                    case 0:
                    case 11:
                    case 15:
                      qr || li(5, p);
                      break;
                    case 1:
                      var C = p.stateNode;
                      if (p.flags & 4 && !qr)
                        if (b === null) C.componentDidMount();
                        else {
                          var k =
                            p.elementType === p.type
                              ? b.memoizedProps
                              : Wr(p.type, b.memoizedProps);
                          C.componentDidUpdate(
                            k,
                            b.memoizedState,
                            C.__reactInternalSnapshotBeforeUpdate
                          );
                        }
                      var z = p.updateQueue;
                      z !== null && _g(p, z, C);
                      break;
                    case 3:
                      var ce = p.updateQueue;
                      if (ce !== null) {
                        if (((b = null), p.child !== null))
                          switch (p.child.tag) {
                            case 5:
                              b = Y(p.child.stateNode);
                              break;
                            case 1:
                              b = p.child.stateNode;
                          }
                        _g(p, ce, b);
                      }
                      break;
                    case 5:
                      var Ee = p.stateNode;
                      b === null &&
                        p.flags & 4 &&
                        nt(Ee, p.type, p.memoizedProps, p);
                      break;
                    case 6:
                      break;
                    case 4:
                      break;
                    case 12:
                      break;
                    case 13:
                      if (we && p.memoizedState === null) {
                        var Qe = p.alternate;
                        if (Qe !== null) {
                          var ct = Qe.memoizedState;
                          if (ct !== null) {
                            var Tt = ct.dehydrated;
                            Tt !== null && ze(Tt);
                          }
                        }
                      }
                      break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                      break;
                    default:
                      throw Error(s(163));
                  }
                qr || (p.flags & 512 && Ci(p));
              } catch (Kt) {
                Ii(p, p.return, Kt);
              }
            }
            if (p === h) {
              pt = null;
              break;
            }
            if (((b = p.sibling), b !== null)) {
              (b.return = p.return), (pt = b);
              break;
            }
            pt = p.return;
          }
        }
        function xl(h) {
          for (; pt !== null; ) {
            var p = pt;
            if (p === h) {
              pt = null;
              break;
            }
            var b = p.sibling;
            if (b !== null) {
              (b.return = p.return), (pt = b);
              break;
            }
            pt = p.return;
          }
        }
        function gd(h) {
          for (; pt !== null; ) {
            var p = pt;
            try {
              switch (p.tag) {
                case 0:
                case 11:
                case 15:
                  var b = p.return;
                  try {
                    li(4, p);
                  } catch (Qe) {
                    Ii(p, b, Qe);
                  }
                  break;
                case 1:
                  var C = p.stateNode;
                  if (typeof C.componentDidMount == "function") {
                    var k = p.return;
                    try {
                      C.componentDidMount();
                    } catch (Qe) {
                      Ii(p, k, Qe);
                    }
                  }
                  var z = p.return;
                  try {
                    Ci(p);
                  } catch (Qe) {
                    Ii(p, z, Qe);
                  }
                  break;
                case 5:
                  var ce = p.return;
                  try {
                    Ci(p);
                  } catch (Qe) {
                    Ii(p, ce, Qe);
                  }
              }
            } catch (Qe) {
              Ii(p, p.return, Qe);
            }
            if (p === h) {
              pt = null;
              break;
            }
            var Ee = p.sibling;
            if (Ee !== null) {
              (Ee.return = p.return), (pt = Ee);
              break;
            }
            pt = p.return;
          }
        }
        var mu = 0,
          gu = 1,
          vu = 2,
          Js = 3,
          Ai = 4;
        if (typeof Symbol == "function" && Symbol.for) {
          var Qo = Symbol.for;
          (mu = Qo("selector.component")),
            (gu = Qo("selector.has_pseudo_class")),
            (vu = Qo("selector.role")),
            (Js = Qo("selector.test_id")),
            (Ai = Qo("selector.text"));
        }
        function _c(h) {
          var p = Ae(h);
          if (p != null) {
            if (typeof p.memoizedProps["data-testname"] != "string")
              throw Error(s(364));
            return p;
          }
          if (((h = B(h)), h === null)) throw Error(s(362));
          return h.stateNode.current;
        }
        function vd(h, p) {
          switch (p.$$typeof) {
            case mu:
              if (h.type === p.value) return !0;
              break;
            case gu:
              e: {
                (p = p.value), (h = [h, 0]);
                for (var b = 0; b < h.length; ) {
                  var C = h[b++],
                    k = h[b++],
                    z = p[k];
                  if (C.tag !== 5 || !_e(C)) {
                    for (; z != null && vd(C, z); ) k++, (z = p[k]);
                    if (k === p.length) {
                      p = !0;
                      break e;
                    } else
                      for (C = C.child; C !== null; )
                        h.push(C, k), (C = C.sibling);
                  }
                }
                p = !1;
              }
              return p;
            case vu:
              if (h.tag === 5 && Te(h.stateNode, p.value)) return !0;
              break;
            case Ai:
              if (
                (h.tag === 5 || h.tag === 6) &&
                ((h = Se(h)), h !== null && 0 <= h.indexOf(p.value))
              )
                return !0;
              break;
            case Js:
              if (
                h.tag === 5 &&
                ((h = h.memoizedProps["data-testname"]),
                typeof h == "string" &&
                  h.toLowerCase() === p.value.toLowerCase())
              )
                return !0;
              break;
            default:
              throw Error(s(365));
          }
          return !1;
        }
        function es(h) {
          switch (h.$$typeof) {
            case mu:
              return "<" + (P(h.value) || "Unknown") + ">";
            case gu:
              return ":has(" + (es(h) || "") + ")";
            case vu:
              return '[role="' + h.value + '"]';
            case Ai:
              return '"' + h.value + '"';
            case Js:
              return '[data-testname="' + h.value + '"]';
            default:
              throw Error(s(365));
          }
        }
        function Qs(h, p) {
          var b = [];
          h = [h, 0];
          for (var C = 0; C < h.length; ) {
            var k = h[C++],
              z = h[C++],
              ce = p[z];
            if (k.tag !== 5 || !_e(k)) {
              for (; ce != null && vd(k, ce); ) z++, (ce = p[z]);
              if (z === p.length) b.push(k);
              else
                for (k = k.child; k !== null; ) h.push(k, z), (k = k.sibling);
            }
          }
          return b;
        }
        function Sc(h, p) {
          if (!ee) throw Error(s(363));
          (h = _c(h)), (h = Qs(h, p)), (p = []), (h = Array.from(h));
          for (var b = 0; b < h.length; ) {
            var C = h[b++];
            if (C.tag === 5) _e(C) || p.push(C.stateNode);
            else for (C = C.child; C !== null; ) h.push(C), (C = C.sibling);
          }
          return p;
        }
        var kg = Math.ceil,
          Io = a.ReactCurrentDispatcher,
          _s = a.ReactCurrentOwner,
          Zn = a.ReactCurrentBatchConfig,
          nn = 0,
          ir = null,
          pr = null,
          Kr = 0,
          Ri = 0,
          ea = Mn(0),
          Sr = 0,
          yu = null,
          _l = 0,
          xu = 0,
          Sl = 0,
          La = null,
          Pi = null,
          yd = 0,
          Da = 1 / 0;
        function wl() {
          Da = qn() + 500;
        }
        var ka = !1,
          Lo = null,
          Do = null,
          Oa = !1,
          $i = null,
          _u = 0,
          Ss = 0,
          xd = null,
          Su = -1,
          Vn = 0;
        function Zr() {
          return (nn & 6) !== 0 ? qn() : Su !== -1 ? Su : (Su = qn());
        }
        function ws(h) {
          return (h.mode & 1) === 0
            ? 1
            : (nn & 2) !== 0 && Kr !== 0
            ? Kr & -Kr
            : ba.transition !== null
            ? (Vn === 0 &&
                ((h = jo),
                (jo <<= 1),
                (jo & 4194240) === 0 && (jo = 64),
                (Vn = h)),
              Vn)
            : ((h = Xt), h !== 0 ? h : Ie());
        }
        function Xi(h, p, b) {
          if (50 < Ss) throw ((Ss = 0), (xd = null), Error(s(185)));
          var C = bl(h, p);
          return C === null
            ? null
            : (wo(C, p, b),
              ((nn & 2) === 0 || C !== ir) &&
                (C === ir &&
                  ((nn & 2) === 0 && (xu |= p), Sr === 4 && ts(C, Kr)),
                yi(C, b),
                p === 1 &&
                  nn === 0 &&
                  (h.mode & 1) === 0 &&
                  (wl(), gs && gi())),
              C);
        }
        function bl(h, p) {
          h.lanes |= p;
          var b = h.alternate;
          for (b !== null && (b.lanes |= p), b = h, h = h.return; h !== null; )
            (h.childLanes |= p),
              (b = h.alternate),
              b !== null && (b.childLanes |= p),
              (b = h),
              (h = h.return);
          return b.tag === 3 ? b.stateNode : null;
        }
        function yi(h, p) {
          var b = h.callbackNode;
          Jl(h, p);
          var C = ya(h, h === ir ? Kr : 0);
          if (C === 0)
            b !== null && ms(b),
              (h.callbackNode = null),
              (h.callbackPriority = 0);
          else if (((p = C & -C), h.callbackPriority !== p)) {
            if ((b != null && ms(b), p === 1))
              h.tag === 0 ? wa(wu.bind(null, h)) : il(wu.bind(null, h)),
                De
                  ? Xe(function () {
                      nn === 0 && gi();
                    })
                  : so(Xo, gi),
                (b = null);
            else {
              switch (bo(C)) {
                case 1:
                  b = Xo;
                  break;
                case 4:
                  b = Bf;
                  break;
                case 16:
                  b = mi;
                  break;
                case 536870912:
                  b = xa;
                  break;
                default:
                  b = mi;
              }
              b = Ec(b, Na.bind(null, h));
            }
            (h.callbackPriority = p), (h.callbackNode = b);
          }
        }
        function Na(h, p) {
          if (((Su = -1), (Vn = 0), (nn & 6) !== 0)) throw Error(s(327));
          var b = h.callbackNode;
          if (Fa() && h.callbackNode !== b) return null;
          var C = ya(h, h === ir ? Kr : 0);
          if (C === 0) return null;
          if ((C & 30) !== 0 || (C & h.expiredLanes) !== 0 || p) p = ho(h, C);
          else {
            p = C;
            var k = nn;
            nn |= 2;
            var z = Sd();
            (ir !== h || Kr !== p) && (wl(), sr(h, p));
            do
              try {
                bc();
                break;
              } catch (Ee) {
                _d(h, Ee);
              }
            while (!0);
            Gr(),
              (Io.current = z),
              (nn = k),
              pr !== null ? (p = 0) : ((ir = null), (Kr = 0), (p = Sr));
          }
          if (p !== 0) {
            if (
              (p === 2 && ((k = ps(h)), k !== 0 && ((C = k), (p = Xn(h, k)))),
              p === 1)
            )
              throw ((b = yu), sr(h, 0), ts(h, C), yi(h, qn()), b);
            if (p === 6) ts(h, C);
            else {
              if (
                ((k = h.current.alternate),
                (C & 30) === 0 &&
                  !Jr(k) &&
                  ((p = ho(h, C)),
                  p === 2 &&
                    ((z = ps(h)), z !== 0 && ((C = z), (p = Xn(h, z)))),
                  p === 1))
              )
                throw ((b = yu), sr(h, 0), ts(h, C), yi(h, qn()), b);
              switch (((h.finishedWork = k), (h.finishedLanes = C), p)) {
                case 0:
                case 1:
                  throw Error(s(345));
                case 2:
                  Ua(h, Pi);
                  break;
                case 3:
                  if (
                    (ts(h, C),
                    (C & 130023424) === C && ((p = yd + 500 - qn()), 10 < p))
                  ) {
                    if (ya(h, 0) !== 0) break;
                    if (((k = h.suspendedLanes), (k & C) !== C)) {
                      Zr(), (h.pingedLanes |= h.suspendedLanes & k);
                      break;
                    }
                    h.timeoutHandle = le(Ua.bind(null, h, Pi), p);
                    break;
                  }
                  Ua(h, Pi);
                  break;
                case 4:
                  if ((ts(h, C), (C & 4194240) === C)) break;
                  for (p = h.eventTimes, k = -1; 0 < C; ) {
                    var ce = 31 - pi(C);
                    (z = 1 << ce), (ce = p[ce]), ce > k && (k = ce), (C &= ~z);
                  }
                  if (
                    ((C = k),
                    (C = qn() - C),
                    (C =
                      (120 > C
                        ? 120
                        : 480 > C
                        ? 480
                        : 1080 > C
                        ? 1080
                        : 1920 > C
                        ? 1920
                        : 3e3 > C
                        ? 3e3
                        : 4320 > C
                        ? 4320
                        : 1960 * kg(C / 1960)) - C),
                    10 < C)
                  ) {
                    h.timeoutHandle = le(Ua.bind(null, h, Pi), C);
                    break;
                  }
                  Ua(h, Pi);
                  break;
                case 5:
                  Ua(h, Pi);
                  break;
                default:
                  throw Error(s(329));
              }
            }
          }
          return yi(h, qn()), h.callbackNode === b ? Na.bind(null, h) : null;
        }
        function Xn(h, p) {
          var b = La;
          return (
            h.current.memoizedState.isDehydrated && (sr(h, p).flags |= 256),
            (h = ho(h, p)),
            h !== 2 && ((p = Pi), (Pi = b), p !== null && mr(p)),
            h
          );
        }
        function mr(h) {
          Pi === null ? (Pi = h) : Pi.push.apply(Pi, h);
        }
        function Jr(h) {
          for (var p = h; ; ) {
            if (p.flags & 16384) {
              var b = p.updateQueue;
              if (b !== null && ((b = b.stores), b !== null))
                for (var C = 0; C < b.length; C++) {
                  var k = b[C],
                    z = k.getSnapshot;
                  k = k.value;
                  try {
                    if (!Hr(z(), k)) return !1;
                  } catch {
                    return !1;
                  }
                }
            }
            if (((b = p.child), p.subtreeFlags & 16384 && b !== null))
              (b.return = p), (p = b);
            else {
              if (p === h) break;
              for (; p.sibling === null; ) {
                if (p.return === null || p.return === h) return !0;
                p = p.return;
              }
              (p.sibling.return = p.return), (p = p.sibling);
            }
          }
          return !0;
        }
        function ts(h, p) {
          for (
            p &= ~Sl,
              p &= ~xu,
              h.suspendedLanes |= p,
              h.pingedLanes &= ~p,
              h = h.expirationTimes;
            0 < p;

          ) {
            var b = 31 - pi(p),
              C = 1 << b;
            (h[b] = -1), (p &= ~C);
          }
        }
        function wu(h) {
          if ((nn & 6) !== 0) throw Error(s(327));
          Fa();
          var p = ya(h, 0);
          if ((p & 1) === 0) return yi(h, qn()), null;
          var b = ho(h, p);
          if (h.tag !== 0 && b === 2) {
            var C = ps(h);
            C !== 0 && ((p = C), (b = Xn(h, C)));
          }
          if (b === 1) throw ((b = yu), sr(h, 0), ts(h, p), yi(h, qn()), b);
          if (b === 6) throw Error(s(345));
          return (
            (h.finishedWork = h.current.alternate),
            (h.finishedLanes = p),
            Ua(h, Pi),
            yi(h, qn()),
            null
          );
        }
        function bu(h) {
          $i !== null && $i.tag === 0 && (nn & 6) === 0 && Fa();
          var p = nn;
          nn |= 1;
          var b = Zn.transition,
            C = Xt;
          try {
            if (((Zn.transition = null), (Xt = 1), h)) return h();
          } finally {
            (Xt = C), (Zn.transition = b), (nn = p), (nn & 6) === 0 && gi();
          }
        }
        function _p() {
          (Ri = ea.current), wt(ea);
        }
        function sr(h, p) {
          (h.finishedWork = null), (h.finishedLanes = 0);
          var b = h.timeoutHandle;
          if ((b !== Me && ((h.timeoutHandle = Me), fe(b)), pr !== null))
            for (b = pr.return; b !== null; ) {
              var C = b;
              switch ((Jh(C), C.tag)) {
                case 1:
                  (C = C.type.childContextTypes), C != null && cn();
                  break;
                case 3:
                  su(), wt(En), wt(zt), ul();
                  break;
                case 5:
                  tp(C);
                  break;
                case 4:
                  su();
                  break;
                case 13:
                  wt(nr);
                  break;
                case 19:
                  wt(nr);
                  break;
                case 10:
                  _r(C.type._context);
                  break;
                case 22:
                case 23:
                  _p();
              }
              b = b.return;
            }
          if (
            ((ir = h),
            (pr = h = ta(h.current, null)),
            (Kr = Ri = p),
            (Sr = 0),
            (yu = null),
            (Sl = xu = _l = 0),
            (Pi = La = null),
            bi !== null)
          ) {
            for (p = 0; p < bi.length; p++)
              if (((b = bi[p]), (C = b.interleaved), C !== null)) {
                b.interleaved = null;
                var k = C.next,
                  z = b.pending;
                if (z !== null) {
                  var ce = z.next;
                  (z.next = k), (C.next = ce);
                }
                b.pending = C;
              }
            bi = null;
          }
          return h;
        }
        function _d(h, p) {
          do {
            var b = pr;
            try {
              if ((Gr(), (oc.current = fu), Kf)) {
                for (var C = rr.memoizedState; C !== null; ) {
                  var k = C.queue;
                  k !== null && (k.pending = null), (C = C.next);
                }
                Kf = !1;
              }
              if (
                ((cl = 0),
                ($r = jr = rr = null),
                (vs = !1),
                (fl = 0),
                (_s.current = null),
                b === null || b.return === null)
              ) {
                (Sr = 1), (yu = p), (pr = null);
                break;
              }
              e: {
                var z = h,
                  ce = b.return,
                  Ee = b,
                  Qe = p;
                if (
                  ((p = Kr),
                  (Ee.flags |= 32768),
                  Qe !== null &&
                    typeof Qe == "object" &&
                    typeof Qe.then == "function")
                ) {
                  var ct = Qe,
                    Tt = Ee,
                    Kt = Tt.tag;
                  if (
                    (Tt.mode & 1) === 0 &&
                    (Kt === 0 || Kt === 11 || Kt === 15)
                  ) {
                    var Bt = Tt.alternate;
                    Bt
                      ? ((Tt.updateQueue = Bt.updateQueue),
                        (Tt.memoizedState = Bt.memoizedState),
                        (Tt.lanes = Bt.lanes))
                      : ((Tt.updateQueue = null), (Tt.memoizedState = null));
                  }
                  var Un = fp(ce);
                  if (Un !== null) {
                    (Un.flags &= -257),
                      hl(Un, ce, Ee, z, p),
                      Un.mode & 1 && $s(z, ct, p),
                      (p = Un),
                      (Qe = ct);
                    var bt = p.updateQueue;
                    if (bt === null) {
                      var Tn = new Set();
                      Tn.add(Qe), (p.updateQueue = Tn);
                    } else bt.add(Qe);
                    break e;
                  } else {
                    if ((p & 1) === 0) {
                      $s(z, ct, p), wc();
                      break e;
                    }
                    Qe = Error(s(426));
                  }
                } else if (Kn && Ee.mode & 1) {
                  var mo = fp(ce);
                  if (mo !== null) {
                    (mo.flags & 65536) === 0 && (mo.flags |= 256),
                      hl(mo, ce, Ee, z, p),
                      Xf(Qe);
                    break e;
                  }
                }
                (z = Qe),
                  Sr !== 4 && (Sr = 2),
                  La === null ? (La = [z]) : La.push(z),
                  (Qe = cp(Qe, Ee)),
                  (Ee = ce);
                do {
                  switch (Ee.tag) {
                    case 3:
                      (Ee.flags |= 65536), (p &= -p), (Ee.lanes |= p);
                      var He = Lg(Ee, Qe, p);
                      Hf(Ee, He);
                      break e;
                    case 1:
                      z = Qe;
                      var Pe = Ee.type,
                        Ze = Ee.stateNode;
                      if (
                        (Ee.flags & 128) === 0 &&
                        (typeof Pe.getDerivedStateFromError == "function" ||
                          (Ze !== null &&
                            typeof Ze.componentDidCatch == "function" &&
                            (Do === null || !Do.has(Ze))))
                      ) {
                        (Ee.flags |= 65536), (p &= -p), (Ee.lanes |= p);
                        var _t = sd(Ee, z, p);
                        Hf(Ee, _t);
                        break e;
                      }
                  }
                  Ee = Ee.return;
                } while (Ee !== null);
              }
              bd(b);
            } catch (Lt) {
              (p = Lt), pr === b && b !== null && (pr = b = b.return);
              continue;
            }
            break;
          } while (!0);
        }
        function Sd() {
          var h = Io.current;
          return (Io.current = fu), h === null ? fu : h;
        }
        function wc() {
          (Sr === 0 || Sr === 3 || Sr === 2) && (Sr = 4),
            ir === null ||
              ((_l & 268435455) === 0 && (xu & 268435455) === 0) ||
              ts(ir, Kr);
        }
        function ho(h, p) {
          var b = nn;
          nn |= 2;
          var C = Sd();
          (ir === h && Kr === p) || sr(h, p);
          do
            try {
              ko();
              break;
            } catch (k) {
              _d(h, k);
            }
          while (!0);
          if ((Gr(), (nn = b), (Io.current = C), pr !== null))
            throw Error(s(261));
          return (ir = null), (Kr = 0), Sr;
        }
        function ko() {
          for (; pr !== null; ) wd(pr);
        }
        function bc() {
          for (; pr !== null && !Mo(); ) wd(pr);
        }
        function wd(h) {
          var p = bp(h.alternate, h, Ri);
          (h.memoizedProps = h.pendingProps),
            p === null ? bd(h) : (pr = p),
            (_s.current = null);
        }
        function bd(h) {
          var p = h;
          do {
            var b = p.alternate;
            if (((h = p.return), (p.flags & 32768) === 0)) {
              if (((b = ud(b, p, Ri)), b !== null)) {
                pr = b;
                return;
              }
            } else {
              if (((b = dd(b, p)), b !== null)) {
                (b.flags &= 32767), (pr = b);
                return;
              }
              if (h !== null)
                (h.flags |= 32768), (h.subtreeFlags = 0), (h.deletions = null);
              else {
                (Sr = 6), (pr = null);
                return;
              }
            }
            if (((p = p.sibling), p !== null)) {
              pr = p;
              return;
            }
            pr = p = h;
          } while (p !== null);
          Sr === 0 && (Sr = 5);
        }
        function Ua(h, p) {
          var b = Xt,
            C = Zn.transition;
          try {
            (Zn.transition = null), (Xt = 1), Og(h, p, b);
          } finally {
            (Zn.transition = C), (Xt = b);
          }
          return null;
        }
        function Og(h, p, b) {
          do Fa();
          while ($i !== null);
          if ((nn & 6) !== 0) throw Error(s(327));
          var C = h.finishedWork,
            k = h.finishedLanes;
          if (C === null) return null;
          if (((h.finishedWork = null), (h.finishedLanes = 0), C === h.current))
            throw Error(s(177));
          (h.callbackNode = null), (h.callbackPriority = 0);
          var z = C.lanes | C.childLanes;
          if (
            ($o(h, z),
            h === ir && ((pr = ir = null), (Kr = 0)),
            ((C.subtreeFlags & 2064) === 0 && (C.flags & 2064) === 0) ||
              Oa ||
              ((Oa = !0),
              Ec(mi, function () {
                return Fa(), null;
              })),
            (z = (C.flags & 15990) !== 0),
            (C.subtreeFlags & 15990) !== 0 || z)
          ) {
            (z = Zn.transition), (Zn.transition = null);
            var ce = Xt;
            Xt = 1;
            var Ee = nn;
            (nn |= 4),
              (_s.current = null),
              gp(h, C),
              Ax(h, C),
              F(h.containerInfo),
              (h.current = C),
              Jo(C),
              Ff(),
              (nn = Ee),
              (Xt = ce),
              (Zn.transition = z);
          } else h.current = C;
          if (
            (Oa && ((Oa = !1), ($i = h), (_u = k)),
            (z = h.pendingLanes),
            z === 0 && (Do = null),
            Ns(C.stateNode),
            yi(h, qn()),
            p !== null)
          )
            for (b = h.onRecoverableError, C = 0; C < p.length; C++) b(p[C]);
          if (ka) throw ((ka = !1), (h = Lo), (Lo = null), h);
          return (
            (_u & 1) !== 0 && h.tag !== 0 && Fa(),
            (z = h.pendingLanes),
            (z & 1) !== 0 ? (h === xd ? Ss++ : ((Ss = 0), (xd = h))) : (Ss = 0),
            gi(),
            null
          );
        }
        function Fa() {
          if ($i !== null) {
            var h = bo(_u),
              p = Zn.transition,
              b = Xt;
            try {
              if (((Zn.transition = null), (Xt = 16 > h ? 16 : h), $i === null))
                var C = !1;
              else {
                if (((h = $i), ($i = null), (_u = 0), (nn & 6) !== 0))
                  throw Error(s(331));
                var k = nn;
                for (nn |= 4, pt = h.current; pt !== null; ) {
                  var z = pt,
                    ce = z.child;
                  if ((pt.flags & 16) !== 0) {
                    var Ee = z.deletions;
                    if (Ee !== null) {
                      for (var Qe = 0; Qe < Ee.length; Qe++) {
                        var ct = Ee[Qe];
                        for (pt = ct; pt !== null; ) {
                          var Tt = pt;
                          switch (Tt.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Zs(8, Tt, z);
                          }
                          var Kt = Tt.child;
                          if (Kt !== null) (Kt.return = Tt), (pt = Kt);
                          else
                            for (; pt !== null; ) {
                              Tt = pt;
                              var Bt = Tt.sibling,
                                Un = Tt.return;
                              if ((vp(Tt), Tt === ct)) {
                                pt = null;
                                break;
                              }
                              if (Bt !== null) {
                                (Bt.return = Un), (pt = Bt);
                                break;
                              }
                              pt = Un;
                            }
                        }
                      }
                      var bt = z.alternate;
                      if (bt !== null) {
                        var Tn = bt.child;
                        if (Tn !== null) {
                          bt.child = null;
                          do {
                            var mo = Tn.sibling;
                            (Tn.sibling = null), (Tn = mo);
                          } while (Tn !== null);
                        }
                      }
                      pt = z;
                    }
                  }
                  if ((z.subtreeFlags & 2064) !== 0 && ce !== null)
                    (ce.return = z), (pt = ce);
                  else
                    e: for (; pt !== null; ) {
                      if (((z = pt), (z.flags & 2048) !== 0))
                        switch (z.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Zs(9, z, z.return);
                        }
                      var He = z.sibling;
                      if (He !== null) {
                        (He.return = z.return), (pt = He);
                        break e;
                      }
                      pt = z.return;
                    }
                }
                var Pe = h.current;
                for (pt = Pe; pt !== null; ) {
                  ce = pt;
                  var Ze = ce.child;
                  if ((ce.subtreeFlags & 2064) !== 0 && Ze !== null)
                    (Ze.return = ce), (pt = Ze);
                  else
                    e: for (ce = Pe; pt !== null; ) {
                      if (((Ee = pt), (Ee.flags & 2048) !== 0))
                        try {
                          switch (Ee.tag) {
                            case 0:
                            case 11:
                            case 15:
                              li(9, Ee);
                          }
                        } catch (Lt) {
                          Ii(Ee, Ee.return, Lt);
                        }
                      if (Ee === ce) {
                        pt = null;
                        break e;
                      }
                      var _t = Ee.sibling;
                      if (_t !== null) {
                        (_t.return = Ee.return), (pt = _t);
                        break e;
                      }
                      pt = Ee.return;
                    }
                }
                if (
                  ((nn = k),
                  gi(),
                  ao && typeof ao.onPostCommitFiberRoot == "function")
                )
                  try {
                    ao.onPostCommitFiberRoot(_a, h);
                  } catch {}
                C = !0;
              }
              return C;
            } finally {
              (Xt = b), (Zn.transition = p);
            }
          }
          return !1;
        }
        function Sp(h, p, b) {
          (p = cp(b, p)),
            (p = Lg(h, p, 1)),
            Ma(h, p),
            (p = Zr()),
            (h = bl(h, 1)),
            h !== null && (wo(h, 1, p), yi(h, p));
        }
        function Ii(h, p, b) {
          if (h.tag === 3) Sp(h, h, b);
          else
            for (; p !== null; ) {
              if (p.tag === 3) {
                Sp(p, h, b);
                break;
              } else if (p.tag === 1) {
                var C = p.stateNode;
                if (
                  typeof p.type.getDerivedStateFromError == "function" ||
                  (typeof C.componentDidCatch == "function" &&
                    (Do === null || !Do.has(C)))
                ) {
                  (h = cp(b, h)),
                    (h = sd(p, h, 1)),
                    Ma(p, h),
                    (h = Zr()),
                    (p = bl(p, 1)),
                    p !== null && (wo(p, 1, h), yi(p, h));
                  break;
                }
              }
              p = p.return;
            }
        }
        function Ng(h, p, b) {
          var C = h.pingCache;
          C !== null && C.delete(p),
            (p = Zr()),
            (h.pingedLanes |= h.suspendedLanes & b),
            ir === h &&
              (Kr & b) === b &&
              (Sr === 4 ||
              (Sr === 3 && (Kr & 130023424) === Kr && 500 > qn() - yd)
                ? sr(h, 0)
                : (Sl |= b)),
            yi(h, p);
        }
        function wp(h, p) {
          p === 0 &&
            ((h.mode & 1) === 0
              ? (p = 1)
              : ((p = ln),
                (ln <<= 1),
                (ln & 130023424) === 0 && (ln = 4194304)));
          var b = Zr();
          (h = bl(h, p)), h !== null && (wo(h, p, b), yi(h, b));
        }
        function Ug(h) {
          var p = h.memoizedState,
            b = 0;
          p !== null && (b = p.retryLane), wp(h, b);
        }
        function Mc(h, p) {
          var b = 0;
          switch (h.tag) {
            case 13:
              var C = h.stateNode,
                k = h.memoizedState;
              k !== null && (b = k.retryLane);
              break;
            case 19:
              C = h.stateNode;
              break;
            default:
              throw Error(s(314));
          }
          C !== null && C.delete(p), wp(h, b);
        }
        var bp;
        bp = function (h, p, b) {
          if (h !== null)
            if (h.memoizedProps !== p.pendingProps || En.current) Yr = !0;
            else {
              if ((h.lanes & b) === 0 && (p.flags & 128) === 0)
                return (Yr = !1), fd(h, p, b);
              Yr = (h.flags & 131072) !== 0;
            }
          else (Yr = !1), Kn && (p.flags & 1048576) !== 0 && Mg(p, jf, p.index);
          switch (((p.lanes = 0), p.tag)) {
            case 2:
              var C = p.type;
              h !== null &&
                ((h.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (h = p.pendingProps);
              var k = Rn(p, zt.current);
              dr(p, b), (k = au(null, p, C, h, k, b));
              var z = Aa();
              return (
                (p.flags |= 1),
                typeof k == "object" &&
                k !== null &&
                typeof k.render == "function" &&
                k.$$typeof === void 0
                  ? ((p.tag = 1),
                    (p.memoizedState = null),
                    (p.updateQueue = null),
                    jn(C) ? ((z = !0), fr(p)) : (z = !1),
                    (p.memoizedState =
                      k.state !== null && k.state !== void 0 ? k.state : null),
                    Ql(p),
                    (k.updater = Wf),
                    (p.stateNode = k),
                    (k._reactInternals = p),
                    Kh(p, C, h, b),
                    (p = vi(null, p, C, !0, z, b)))
                  : ((p.tag = 0),
                    Kn && z && Zh(p),
                    or(null, p, k, b),
                    (p = p.child)),
                p
              );
            case 16:
              C = p.elementType;
              e: {
                switch (
                  (h !== null &&
                    ((h.alternate = null),
                    (p.alternate = null),
                    (p.flags |= 2)),
                  (h = p.pendingProps),
                  (k = C._init),
                  (C = k(C._payload)),
                  (p.type = C),
                  (k = p.tag = Fg(C)),
                  (h = Wr(C, h)),
                  k)
                ) {
                  case 0:
                    p = qs(null, p, C, h, b);
                    break e;
                  case 1:
                    p = ml(null, p, C, h, b);
                    break e;
                  case 11:
                    p = Hn(null, p, C, h, b);
                    break e;
                  case 14:
                    p = Nn(null, p, C, Wr(C.type, h), b);
                    break e;
                }
                throw Error(s(306, C, ""));
              }
              return p;
            case 0:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Wr(C, k)),
                qs(h, p, C, k, b)
              );
            case 1:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Wr(C, k)),
                ml(h, p, C, k, b)
              );
            case 3:
              e: {
                if ((pc(p), h === null)) throw Error(s(387));
                (C = p.pendingProps),
                  (z = p.memoizedState),
                  (k = z.element),
                  Xh(h, p),
                  Vf(p, C, null, b);
                var ce = p.memoizedState;
                if (((C = ce.element), we && z.isDehydrated))
                  if (
                    ((z = {
                      element: C,
                      isDehydrated: !1,
                      cache: ce.cache,
                      transitions: ce.transitions,
                    }),
                    (p.updateQueue.baseState = z),
                    (p.memoizedState = z),
                    p.flags & 256)
                  ) {
                    (k = Error(s(423))), (p = hp(h, p, C, b, k));
                    break e;
                  } else if (C !== k) {
                    (k = Error(s(424))), (p = hp(h, p, C, b, k));
                    break e;
                  } else
                    for (
                      we &&
                        ((si = xr(p.stateNode.containerInfo)),
                        (Mi = p),
                        (Kn = !0),
                        (Ao = null),
                        (tu = !1)),
                        b = Cg(p, null, C, b),
                        p.child = b;
                      b;

                    )
                      (b.flags = (b.flags & -3) | 4096), (b = b.sibling);
                else {
                  if ((nu(), C === k)) {
                    p = ji(h, p, b);
                    break e;
                  }
                  or(h, p, C, b);
                }
                p = p.child;
              }
              return p;
            case 5:
              return (
                Ag(p),
                h === null && Ta(p),
                (C = p.type),
                (k = p.pendingProps),
                (z = h !== null ? h.memoizedProps : null),
                (ce = k.children),
                se(C, k)
                  ? (ce = null)
                  : z !== null && se(C, z) && (p.flags |= 32),
                Ei(h, p),
                or(h, p, ce, b),
                p.child
              );
            case 6:
              return h === null && Ta(p), null;
            case 13:
              return pp(h, p, b);
            case 4:
              return (
                Yf(p, p.stateNode.containerInfo),
                (C = p.pendingProps),
                h === null ? (p.child = Gs(p, null, C, b)) : or(h, p, C, b),
                p.child
              );
            case 11:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Wr(C, k)),
                Hn(h, p, C, k, b)
              );
            case 7:
              return or(h, p, p.pendingProps, b), p.child;
            case 8:
              return or(h, p, p.pendingProps.children, b), p.child;
            case 12:
              return or(h, p, p.pendingProps.children, b), p.child;
            case 10:
              e: {
                if (
                  ((C = p.type._context),
                  (k = p.pendingProps),
                  (z = p.memoizedProps),
                  (ce = k.value),
                  zs(p, C, ce),
                  z !== null)
                )
                  if (Hr(z.value, ce)) {
                    if (z.children === k.children && !En.current) {
                      p = ji(h, p, b);
                      break e;
                    }
                  } else
                    for (
                      z = p.child, z !== null && (z.return = p);
                      z !== null;

                    ) {
                      var Ee = z.dependencies;
                      if (Ee !== null) {
                        ce = z.child;
                        for (var Qe = Ee.firstContext; Qe !== null; ) {
                          if (Qe.context === C) {
                            if (z.tag === 1) {
                              (Qe = Hs(-1, b & -b)), (Qe.tag = 2);
                              var ct = z.updateQueue;
                              if (ct !== null) {
                                ct = ct.shared;
                                var Tt = ct.pending;
                                Tt === null
                                  ? (Qe.next = Qe)
                                  : ((Qe.next = Tt.next), (Tt.next = Qe)),
                                  (ct.pending = Qe);
                              }
                            }
                            (z.lanes |= b),
                              (Qe = z.alternate),
                              Qe !== null && (Qe.lanes |= b),
                              Ir(z.return, b, p),
                              (Ee.lanes |= b);
                            break;
                          }
                          Qe = Qe.next;
                        }
                      } else if (z.tag === 10)
                        ce = z.type === p.type ? null : z.child;
                      else if (z.tag === 18) {
                        if (((ce = z.return), ce === null)) throw Error(s(341));
                        (ce.lanes |= b),
                          (Ee = ce.alternate),
                          Ee !== null && (Ee.lanes |= b),
                          Ir(ce, b, p),
                          (ce = z.sibling);
                      } else ce = z.child;
                      if (ce !== null) ce.return = z;
                      else
                        for (ce = z; ce !== null; ) {
                          if (ce === p) {
                            ce = null;
                            break;
                          }
                          if (((z = ce.sibling), z !== null)) {
                            (z.return = ce.return), (ce = z);
                            break;
                          }
                          ce = ce.return;
                        }
                      z = ce;
                    }
                or(h, p, k.children, b), (p = p.child);
              }
              return p;
            case 9:
              return (
                (k = p.type),
                (C = p.pendingProps.children),
                dr(p, b),
                (k = tr(k)),
                (C = C(k)),
                (p.flags |= 1),
                or(h, p, C, b),
                p.child
              );
            case 14:
              return (
                (C = p.type),
                (k = Wr(C, p.pendingProps)),
                (k = Wr(C.type, k)),
                Nn(h, p, C, k, b)
              );
            case 15:
              return Ys(h, p, p.type, p.pendingProps, b);
            case 17:
              return (
                (C = p.type),
                (k = p.pendingProps),
                (k = p.elementType === C ? k : Wr(C, k)),
                h !== null &&
                  ((h.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (p.tag = 1),
                jn(C) ? ((h = !0), fr(p)) : (h = !1),
                dr(p, b),
                wg(p, C, k),
                Kh(p, C, k, b),
                vi(null, p, C, !0, h, b)
              );
            case 19:
              return vl(h, p, b);
            case 22:
              return ai(h, p, b);
          }
          throw Error(s(156, p.tag));
        };
        function Ec(h, p) {
          return so(h, p);
        }
        function Md(h, p, b, C) {
          (this.tag = h),
            (this.key = b),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = p),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = C),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function po(h, p, b, C) {
          return new Md(h, p, b, C);
        }
        function Tc(h) {
          return (h = h.prototype), !(!h || !h.isReactComponent);
        }
        function Fg(h) {
          if (typeof h == "function") return Tc(h) ? 1 : 0;
          if (h != null) {
            if (((h = h.$$typeof), h === S)) return 11;
            if (h === T) return 14;
          }
          return 2;
        }
        function ta(h, p) {
          var b = h.alternate;
          return (
            b === null
              ? ((b = po(h.tag, p, h.key, h.mode)),
                (b.elementType = h.elementType),
                (b.type = h.type),
                (b.stateNode = h.stateNode),
                (b.alternate = h),
                (h.alternate = b))
              : ((b.pendingProps = p),
                (b.type = h.type),
                (b.flags = 0),
                (b.subtreeFlags = 0),
                (b.deletions = null)),
            (b.flags = h.flags & 14680064),
            (b.childLanes = h.childLanes),
            (b.lanes = h.lanes),
            (b.child = h.child),
            (b.memoizedProps = h.memoizedProps),
            (b.memoizedState = h.memoizedState),
            (b.updateQueue = h.updateQueue),
            (p = h.dependencies),
            (b.dependencies =
              p === null
                ? null
                : { lanes: p.lanes, firstContext: p.firstContext }),
            (b.sibling = h.sibling),
            (b.index = h.index),
            (b.ref = h.ref),
            b
          );
        }
        function Cc(h, p, b, C, k, z) {
          var ce = 2;
          if (((C = h), typeof h == "function")) Tc(h) && (ce = 1);
          else if (typeof h == "string") ce = 5;
          else
            e: switch (h) {
              case d:
                return Ba(b.children, k, z, p);
              case m:
                (ce = 8), (k |= 8);
                break;
              case g:
                return (
                  (h = po(12, b, p, k | 2)),
                  (h.elementType = g),
                  (h.lanes = z),
                  h
                );
              case _:
                return (
                  (h = po(13, b, p, k)), (h.elementType = _), (h.lanes = z), h
                );
              case w:
                return (
                  (h = po(19, b, p, k)), (h.elementType = w), (h.lanes = z), h
                );
              case A:
                return Mu(b, k, z, p);
              default:
                if (typeof h == "object" && h !== null)
                  switch (h.$$typeof) {
                    case y:
                      ce = 10;
                      break e;
                    case x:
                      ce = 9;
                      break e;
                    case S:
                      ce = 11;
                      break e;
                    case T:
                      ce = 14;
                      break e;
                    case M:
                      (ce = 16), (C = null);
                      break e;
                  }
                throw Error(s(130, h == null ? h : typeof h, ""));
            }
          return (
            (p = po(ce, b, p, k)),
            (p.elementType = h),
            (p.type = C),
            (p.lanes = z),
            p
          );
        }
        function Ba(h, p, b, C) {
          return (h = po(7, h, C, p)), (h.lanes = b), h;
        }
        function Mu(h, p, b, C) {
          return (
            (h = po(22, h, C, p)),
            (h.elementType = A),
            (h.lanes = b),
            (h.stateNode = {}),
            h
          );
        }
        function Ed(h, p, b) {
          return (h = po(6, h, null, p)), (h.lanes = b), h;
        }
        function Td(h, p, b) {
          return (
            (p = po(4, h.children !== null ? h.children : [], h.key, p)),
            (p.lanes = b),
            (p.stateNode = {
              containerInfo: h.containerInfo,
              pendingChildren: null,
              implementation: h.implementation,
            }),
            p
          );
        }
        function Bg(h, p, b, C, k) {
          (this.tag = p),
            (this.containerInfo = h),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = Me),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = rl(0)),
            (this.expirationTimes = rl(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = rl(0)),
            (this.identifierPrefix = C),
            (this.onRecoverableError = k),
            we && (this.mutableSourceEagerHydrationData = null);
        }
        function zg(h, p, b, C, k, z, ce, Ee, Qe) {
          return (
            (h = new Bg(h, p, b, Ee, Qe)),
            p === 1 ? ((p = 1), z === !0 && (p |= 8)) : (p = 0),
            (z = po(3, null, null, p)),
            (h.current = z),
            (z.stateNode = h),
            (z.memoizedState = {
              element: C,
              isDehydrated: b,
              cache: null,
              transitions: null,
            }),
            Ql(z),
            h
          );
        }
        function Mp(h) {
          if (!h) return Jt;
          h = h._reactInternals;
          e: {
            if (O(h) !== h || h.tag !== 1) throw Error(s(170));
            var p = h;
            do {
              switch (p.tag) {
                case 3:
                  p = p.stateNode.context;
                  break e;
                case 1:
                  if (jn(p.type)) {
                    p = p.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              p = p.return;
            } while (p !== null);
            throw Error(s(171));
          }
          if (h.tag === 1) {
            var b = h.type;
            if (jn(b)) return ds(h, b, p);
          }
          return p;
        }
        function Hg(h) {
          var p = h._reactInternals;
          if (p === void 0)
            throw typeof h.render == "function"
              ? Error(s(188))
              : ((h = Object.keys(h).join(",")), Error(s(268, h)));
          return (h = W(p)), h === null ? null : h.stateNode;
        }
        function Vg(h, p) {
          if (((h = h.memoizedState), h !== null && h.dehydrated !== null)) {
            var b = h.retryLane;
            h.retryLane = b !== 0 && b < p ? b : p;
          }
        }
        function Cd(h, p) {
          Vg(h, p), (h = h.alternate) && Vg(h, p);
        }
        function Wg(h) {
          return (h = W(h)), h === null ? null : h.stateNode;
        }
        function Gg() {
          return null;
        }
        return (
          (t.attemptContinuousHydration = function (h) {
            if (h.tag === 13) {
              var p = Zr();
              Xi(h, 134217728, p), Cd(h, 134217728);
            }
          }),
          (t.attemptHydrationAtCurrentPriority = function (h) {
            if (h.tag === 13) {
              var p = Zr(),
                b = ws(h);
              Xi(h, b, p), Cd(h, b);
            }
          }),
          (t.attemptSynchronousHydration = function (h) {
            switch (h.tag) {
              case 3:
                var p = h.stateNode;
                if (p.current.memoizedState.isDehydrated) {
                  var b = hs(p.pendingLanes);
                  b !== 0 &&
                    (oi(p, b | 1), yi(p, qn()), (nn & 6) === 0 && (wl(), gi()));
                }
                break;
              case 13:
                var C = Zr();
                bu(function () {
                  return Xi(h, 1, C);
                }),
                  Cd(h, 1);
            }
          }),
          (t.batchedUpdates = function (h, p) {
            var b = nn;
            nn |= 1;
            try {
              return h(p);
            } finally {
              (nn = b), nn === 0 && (wl(), gs && gi());
            }
          }),
          (t.createComponentSelector = function (h) {
            return { $$typeof: mu, value: h };
          }),
          (t.createContainer = function (h, p, b, C, k, z, ce) {
            return zg(h, p, !1, null, b, C, k, z, ce);
          }),
          (t.createHasPseudoClassSelector = function (h) {
            return { $$typeof: gu, value: h };
          }),
          (t.createHydrationContainer = function (
            h,
            p,
            b,
            C,
            k,
            z,
            ce,
            Ee,
            Qe
          ) {
            return (
              (h = zg(b, C, !0, h, k, z, ce, Ee, Qe)),
              (h.context = Mp(null)),
              (b = h.current),
              (C = Zr()),
              (k = ws(b)),
              (z = Hs(C, k)),
              (z.callback = p ?? null),
              Ma(b, z),
              (h.current.lanes = k),
              wo(h, k, C),
              yi(h, C),
              h
            );
          }),
          (t.createPortal = function (h, p, b) {
            var C =
              3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : null;
            return {
              $$typeof: c,
              key: C == null ? null : "" + C,
              children: h,
              containerInfo: p,
              implementation: b,
            };
          }),
          (t.createRoleSelector = function (h) {
            return { $$typeof: vu, value: h };
          }),
          (t.createTestNameSelector = function (h) {
            return { $$typeof: Js, value: h };
          }),
          (t.createTextSelector = function (h) {
            return { $$typeof: Ai, value: h };
          }),
          (t.deferredUpdates = function (h) {
            var p = Xt,
              b = Zn.transition;
            try {
              return (Zn.transition = null), (Xt = 16), h();
            } finally {
              (Xt = p), (Zn.transition = b);
            }
          }),
          (t.discreteUpdates = function (h, p, b, C, k) {
            var z = Xt,
              ce = Zn.transition;
            try {
              return (Zn.transition = null), (Xt = 1), h(p, b, C, k);
            } finally {
              (Xt = z), (Zn.transition = ce), nn === 0 && wl();
            }
          }),
          (t.findAllNodes = Sc),
          (t.findBoundingRects = function (h, p) {
            if (!ee) throw Error(s(363));
            (p = Sc(h, p)), (h = []);
            for (var b = 0; b < p.length; b++) h.push(ve(p[b]));
            for (p = h.length - 1; 0 < p; p--) {
              b = h[p];
              for (
                var C = b.x,
                  k = C + b.width,
                  z = b.y,
                  ce = z + b.height,
                  Ee = p - 1;
                0 <= Ee;
                Ee--
              )
                if (p !== Ee) {
                  var Qe = h[Ee],
                    ct = Qe.x,
                    Tt = ct + Qe.width,
                    Kt = Qe.y,
                    Bt = Kt + Qe.height;
                  if (C >= ct && z >= Kt && k <= Tt && ce <= Bt) {
                    h.splice(p, 1);
                    break;
                  } else if (
                    C !== ct ||
                    b.width !== Qe.width ||
                    Bt < z ||
                    Kt > ce
                  ) {
                    if (
                      !(z !== Kt || b.height !== Qe.height || Tt < C || ct > k)
                    ) {
                      ct > C && ((Qe.width += ct - C), (Qe.x = C)),
                        Tt < k && (Qe.width = k - ct),
                        h.splice(p, 1);
                      break;
                    }
                  } else {
                    Kt > z && ((Qe.height += Kt - z), (Qe.y = z)),
                      Bt < ce && (Qe.height = ce - Kt),
                      h.splice(p, 1);
                    break;
                  }
                }
            }
            return h;
          }),
          (t.findHostInstance = Hg),
          (t.findHostInstanceWithNoPortals = function (h) {
            return (
              (h = H(h)),
              (h = h !== null ? K(h) : null),
              h === null ? null : h.stateNode
            );
          }),
          (t.findHostInstanceWithWarning = function (h) {
            return Hg(h);
          }),
          (t.flushControlled = function (h) {
            var p = nn;
            nn |= 1;
            var b = Zn.transition,
              C = Xt;
            try {
              (Zn.transition = null), (Xt = 1), h();
            } finally {
              (Xt = C), (Zn.transition = b), (nn = p), nn === 0 && (wl(), gi());
            }
          }),
          (t.flushPassiveEffects = Fa),
          (t.flushSync = bu),
          (t.focusWithin = function (h, p) {
            if (!ee) throw Error(s(363));
            for (
              h = _c(h), p = Qs(h, p), p = Array.from(p), h = 0;
              h < p.length;

            ) {
              var b = p[h++];
              if (!_e(b)) {
                if (b.tag === 5 && at(b.stateNode)) return !0;
                for (b = b.child; b !== null; ) p.push(b), (b = b.sibling);
              }
            }
            return !1;
          }),
          (t.getCurrentUpdatePriority = function () {
            return Xt;
          }),
          (t.getFindAllNodesFailureDescription = function (h, p) {
            if (!ee) throw Error(s(363));
            var b = 0,
              C = [];
            h = [_c(h), 0];
            for (var k = 0; k < h.length; ) {
              var z = h[k++],
                ce = h[k++],
                Ee = p[ce];
              if (
                (z.tag !== 5 || !_e(z)) &&
                (vd(z, Ee) && (C.push(es(Ee)), ce++, ce > b && (b = ce)),
                ce < p.length)
              )
                for (z = z.child; z !== null; ) h.push(z, ce), (z = z.sibling);
            }
            if (b < p.length) {
              for (h = []; b < p.length; b++) h.push(es(p[b]));
              return (
                `findAllNodes was able to match part of the selector:
  ` +
                (C.join(" > ") +
                  `

No matching component was found for:
  `) +
                h.join(" > ")
              );
            }
            return null;
          }),
          (t.getPublicRootInstance = function (h) {
            if (((h = h.current), !h.child)) return null;
            switch (h.child.tag) {
              case 5:
                return Y(h.child.stateNode);
              default:
                return h.child.stateNode;
            }
          }),
          (t.injectIntoDevTools = function (h) {
            if (
              ((h = {
                bundleType: h.bundleType,
                version: h.version,
                rendererPackageName: h.rendererPackageName,
                rendererConfig: h.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: a.ReactCurrentDispatcher,
                findHostInstanceByFiber: Wg,
                findFiberByHostInstance: h.findFiberByHostInstance || Gg,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329",
              }),
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            )
              h = !1;
            else {
              var p = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (p.isDisabled || !p.supportsFiber) h = !0;
              else {
                try {
                  (_a = p.inject(h)), (ao = p);
                } catch {}
                h = !!p.checkDCE;
              }
            }
            return h;
          }),
          (t.isAlreadyRendering = function () {
            return !1;
          }),
          (t.observeVisibleRects = function (h, p, b, C) {
            if (!ee) throw Error(s(363));
            h = Sc(h, p);
            var k = Fe(h, b, C).disconnect;
            return {
              disconnect: function () {
                k();
              },
            };
          }),
          (t.registerMutableSourceForHydration = function (h, p) {
            var b = p._getVersion;
            (b = b(p._source)),
              h.mutableSourceEagerHydrationData == null
                ? (h.mutableSourceEagerHydrationData = [p, b])
                : h.mutableSourceEagerHydrationData.push(p, b);
          }),
          (t.runWithPriority = function (h, p) {
            var b = Xt;
            try {
              return (Xt = h), p();
            } finally {
              Xt = b;
            }
          }),
          (t.shouldError = function () {
            return null;
          }),
          (t.shouldSuspend = function () {
            return !1;
          }),
          (t.updateContainer = function (h, p, b, C) {
            var k = p.current,
              z = Zr(),
              ce = ws(k);
            return (
              (b = Mp(b)),
              p.context === null ? (p.context = b) : (p.pendingContext = b),
              (p = Hs(z, ce)),
              (p.payload = { element: h }),
              (C = C === void 0 ? null : C),
              C !== null && (p.callback = C),
              Ma(k, p),
              (h = Xi(k, ce, z)),
              h !== null && zf(h, k, ce),
              ce
            );
          }),
          t
        );
      })),
    T1
  );
}
var f2;
function ZW() {
  return f2 || ((f2 = 1), (b1.exports = KW())), b1.exports;
}
var JW = ZW();
const QW = Oh(JW);
var d2 = EP();
const eG = (n) => typeof n == "object" && typeof n.then == "function",
  vf = [];
function TP(n, e, t = (r, i) => r === i) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const r = n.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!t(n[i], e[i])) return !1;
  return !0;
}
function CP(n, e = null, t = !1, r = {}) {
  e === null && (e = [n]);
  for (const o of vf)
    if (TP(e, o.keys, o.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(o, "error")) throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (o.timeout && clearTimeout(o.timeout),
            (o.timeout = setTimeout(o.remove, r.lifespan))),
          o.response
        );
      if (!t) throw o.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const o = vf.indexOf(i);
      o !== -1 && vf.splice(o, 1);
    },
    promise: (eG(n) ? n : n(...e))
      .then((o) => {
        (i.response = o),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((o) => (i.error = o)),
  };
  if ((vf.push(i), !t)) throw i.promise;
}
const AP = (n, e, t) => CP(n, e, !1, t),
  tG = (n, e, t) => void CP(n, e, !0, t),
  nG = (n) => {
    if (n === void 0 || n.length === 0) vf.splice(0, vf.length);
    else {
      const e = vf.find((t) => TP(n, t.keys, t.equal));
      e && e.remove();
    }
  },
  sb = {},
  rG = (n) => void Object.assign(sb, n);
function iG(n, e) {
  function t(d, { args: m = [], attach: g, ...y }, x) {
    let S = `${d[0].toUpperCase()}${d.slice(1)}`,
      _;
    if (d === "primitive") {
      if (y.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const w = y.object;
      _ = dh(w, { type: d, root: x, attach: g, primitive: !0 });
    } else {
      const w = sb[S];
      if (!w)
        throw new Error(
          `R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(m))
        throw new Error("R3F: The args prop must be an array!");
      _ = dh(new w(...m), {
        type: d,
        root: x,
        attach: g,
        memoizedProps: { args: m },
      });
    }
    return (
      _.__r3f.attach === void 0 &&
        (_ instanceof sn
          ? (_.__r3f.attach = "geometry")
          : _ instanceof zi && (_.__r3f.attach = "material")),
      S !== "inject" && R1(_, y),
      _
    );
  }
  function r(d, m) {
    let g = !1;
    if (m) {
      var y, x;
      (y = m.__r3f) != null && y.attach
        ? A1(d, m, m.__r3f.attach)
        : m.isObject3D && d.isObject3D && (d.add(m), (g = !0)),
        g || (x = d.__r3f) == null || x.objects.push(m),
        m.__r3f || dh(m, {}),
        (m.__r3f.parent = d),
        AS(m),
        hh(m);
    }
  }
  function i(d, m, g) {
    let y = !1;
    if (m) {
      var x, S;
      if ((x = m.__r3f) != null && x.attach) A1(d, m, m.__r3f.attach);
      else if (m.isObject3D && d.isObject3D) {
        (m.parent = d),
          m.dispatchEvent({ type: "added" }),
          d.dispatchEvent({ type: "childadded", child: m });
        const _ = d.children.filter((T) => T !== m),
          w = _.indexOf(g);
        (d.children = [..._.slice(0, w), m, ..._.slice(w)]), (y = !0);
      }
      y || (S = d.__r3f) == null || S.objects.push(m),
        m.__r3f || dh(m, {}),
        (m.__r3f.parent = d),
        AS(m),
        hh(m);
    }
  }
  function o(d, m, g = !1) {
    d && [...d].forEach((y) => s(m, y, g));
  }
  function s(d, m, g) {
    if (m) {
      var y, x, S;
      if (
        (m.__r3f && (m.__r3f.parent = null),
        (y = d.__r3f) != null &&
          y.objects &&
          (d.__r3f.objects = d.__r3f.objects.filter((A) => A !== m)),
        (x = m.__r3f) != null && x.attach)
      )
        v2(d, m, m.__r3f.attach);
      else if (m.isObject3D && d.isObject3D) {
        var _;
        d.remove(m), (_ = m.__r3f) != null && _.root && dG(E0(m), m);
      }
      const T = (S = m.__r3f) == null ? void 0 : S.primitive,
        M = !T && (g === void 0 ? m.dispose !== null : g);
      if (!T) {
        var w;
        o((w = m.__r3f) == null ? void 0 : w.objects, m, M),
          o(m.children, m, M);
      }
      if ((delete m.__r3f, M && m.dispose && m.type !== "Scene")) {
        const A = () => {
          try {
            m.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? d2.unstable_scheduleCallback(d2.unstable_IdlePriority, A)
          : A();
      }
      hh(d);
    }
  }
  function a(d, m, g, y) {
    var x;
    const S = (x = d.__r3f) == null ? void 0 : x.parent;
    if (!S) return;
    const _ = t(m, g, d.__r3f.root);
    if (d.children) {
      for (const w of d.children) w.__r3f && r(_, w);
      d.children = d.children.filter((w) => !w.__r3f);
    }
    d.__r3f.objects.forEach((w) => r(_, w)),
      (d.__r3f.objects = []),
      d.__r3f.autoRemovedBeforeAppend || s(S, d),
      _.parent && (_.__r3f.autoRemovedBeforeAppend = !0),
      r(S, _),
      _.raycast &&
        _.__r3f.eventCount &&
        E0(_).getState().internal.interaction.push(_),
      [y, y.alternate].forEach((w) => {
        w !== null &&
          ((w.stateNode = _),
          w.ref &&
            (typeof w.ref == "function" ? w.ref(_) : (w.ref.current = _)));
      });
  }
  const u = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: QW({
      createInstance: t,
      removeChild: s,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (d, m) => {
        if (!m) return;
        const g = d.getState().scene;
        g.__r3f && ((g.__r3f.root = d), r(g, m));
      },
      removeChildFromContainer: (d, m) => {
        m && s(d.getState().scene, m);
      },
      insertInContainerBefore: (d, m, g) => {
        if (!m || !g) return;
        const y = d.getState().scene;
        y.__r3f && i(y, m, g);
      },
      getRootHostContext: () => null,
      getChildHostContext: (d) => d,
      finalizeInitialChildren(d) {
        var m;
        return !!((m = d == null ? void 0 : d.__r3f) != null ? m : {}).handlers;
      },
      prepareUpdate(d, m, g, y) {
        var x;
        if (
          ((x = d == null ? void 0 : d.__r3f) != null ? x : {}).primitive &&
          y.object &&
          y.object !== d
        )
          return [!0];
        {
          const { args: _ = [], children: w, ...T } = y,
            { args: M = [], children: A, ...R } = g;
          if (!Array.isArray(_))
            throw new Error("R3F: the args prop must be an array!");
          if (_.some((P, U) => P !== M[U])) return [!0];
          const D = OP(d, T, R, !0);
          return D.changes.length ? [!1, D] : null;
        }
      },
      commitUpdate(d, [m, g], y, x, S, _) {
        m ? a(d, y, S, _) : R1(d, g);
      },
      commitMount(d, m, g, y) {
        var x;
        const S = (x = d.__r3f) != null ? x : {};
        d.raycast &&
          S.handlers &&
          S.eventCount &&
          E0(d).getState().internal.interaction.push(d);
      },
      getPublicInstance: (d) => d,
      prepareForCommit: () => null,
      preparePortalMount: (d) => dh(d.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(d) {
        var m;
        const { attach: g, parent: y } = (m = d.__r3f) != null ? m : {};
        g && y && v2(y, d, g), d.isObject3D && (d.visible = !1), hh(d);
      },
      unhideInstance(d, m) {
        var g;
        const { attach: y, parent: x } = (g = d.__r3f) != null ? g : {};
        y && x && A1(x, d, y),
          ((d.isObject3D && m.visible == null) || m.visible) &&
            (d.visible = !0),
          hh(d);
      },
      createTextInstance: u,
      hideTextInstance: u,
      unhideTextInstance: u,
      getCurrentEventPriority: () => (e ? e() : xh.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Qn.fun(performance.now)
          ? performance.now
          : Qn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Qn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Qn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: R1,
  };
}
var h2, p2;
const C1 = (n) => "colorSpace" in n || "outputColorSpace" in n,
  RP = () => {
    var n;
    return (n = sb.ColorManagement) != null ? n : null;
  },
  PP = (n) => n && n.isOrthographicCamera,
  oG = (n) => n && n.hasOwnProperty("current"),
  vg =
    typeof window < "u" &&
    (((h2 = window.document) != null && h2.createElement) ||
      ((p2 = window.navigator) == null ? void 0 : p2.product) === "ReactNative")
      ? X.useLayoutEffect
      : X.useEffect;
function IP(n) {
  const e = X.useRef(n);
  return vg(() => void (e.current = n), [n]), e;
}
function sG({ set: n }) {
  return vg(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class LP extends X.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
LP.getDerivedStateFromError = () => ({ error: !0 });
const DP = "__default",
  m2 = new Map(),
  aG = (n) => n && !!n.memoized && !!n.changes;
function kP(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const Jp = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function E0(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Qn = {
  obj: (n) => n === Object(n) && !Qn.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (Qn.str(n) || Qn.num(n) || Qn.boo(n)) return n === e;
    const o = Qn.obj(n);
    if (o && r === "reference") return n === e;
    const s = Qn.arr(n);
    if (s && t === "reference") return n === e;
    if ((s || o) && n === e) return !0;
    let a;
    for (a in n) if (!(a in e)) return !1;
    if (o && t === "shallow" && r === "shallow") {
      for (a in i ? e : n)
        if (!Qn.equ(n[a], e[a], { strict: i, objects: "reference" })) return !1;
    } else for (a in i ? e : n) if (n[a] !== e[a]) return !1;
    if (Qn.und(a)) {
      if (
        (s && n.length === 0 && e.length === 0) ||
        (o && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function lG(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function uG(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function dh(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function CS(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (t = r.reduce((o, s) => o[s], n)), { target: t, key: i };
  } else return { target: t, key: e };
}
const g2 = /-\d+$/;
function A1(n, e, t) {
  if (Qn.str(t)) {
    if (g2.test(t)) {
      const o = t.replace(g2, ""),
        { target: s, key: a } = CS(n, o);
      Array.isArray(s[a]) || (s[a] = []);
    }
    const { target: r, key: i } = CS(n, t);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function v2(n, e, t) {
  var r, i;
  if (Qn.str(t)) {
    const { target: o, key: s } = CS(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete o[s] : (o[s] = a);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function OP(
  n,
  { children: e, key: t, ref: r, ...i },
  { children: o, key: s, ref: a, ...u } = {},
  c = !1
) {
  const d = n.__r3f,
    m = Object.entries(i),
    g = [];
  if (c) {
    const x = Object.keys(u);
    for (let S = 0; S < x.length; S++)
      i.hasOwnProperty(x[S]) || m.unshift([x[S], DP + "remove"]);
  }
  m.forEach(([x, S]) => {
    var _;
    if (
      ((_ = n.__r3f) != null && _.primitive && x === "object") ||
      Qn.equ(S, u[x])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(x))
      return g.push([x, S, !0, []]);
    let w = [];
    x.includes("-") && (w = x.split("-")), g.push([x, S, !1, w]);
    for (const T in i) {
      const M = i[T];
      T.startsWith(`${x}-`) && g.push([T, M, !1, T.split("-")]);
    }
  });
  const y = { ...i };
  return (
    d != null &&
      d.memoizedProps &&
      d != null &&
      d.memoizedProps.args &&
      (y.args = d.memoizedProps.args),
    d != null &&
      d.memoizedProps &&
      d != null &&
      d.memoizedProps.attach &&
      (y.attach = d.memoizedProps.attach),
    { memoized: y, changes: g }
  );
}
function R1(n, e) {
  var t;
  const r = n.__r3f,
    i = r == null ? void 0 : r.root,
    o = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: s, changes: a } = aG(e) ? e : OP(n, e),
    u = r == null ? void 0 : r.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = s);
  for (let d = 0; d < a.length; d++) {
    let [m, g, y, x] = a[d];
    if (C1(n)) {
      const T = "srgb",
        M = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (g = g === 3001 ? T : M))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (g = g === 3001 ? T : M));
    }
    let S = n,
      _ = S[m];
    if (x.length && ((_ = x.reduce((w, T) => w[T], n)), !(_ && _.set))) {
      const [w, ...T] = x.reverse();
      (S = T.reverse().reduce((M, A) => M[A], n)), (m = w);
    }
    if (g === DP + "remove")
      if (S.constructor) {
        let w = m2.get(S.constructor);
        w || ((w = new S.constructor()), m2.set(S.constructor, w)), (g = w[m]);
      } else g = 0;
    if (y && r)
      g ? (r.handlers[m] = g) : delete r.handlers[m],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (_ && _.set && (_.copy || _ instanceof Sf)) {
      if (Array.isArray(g)) _.fromArray ? _.fromArray(g) : _.set(...g);
      else if (_.copy && g && g.constructor && _.constructor === g.constructor)
        _.copy(g);
      else if (g !== void 0) {
        const w = _ instanceof St;
        !w && _.setScalar
          ? _.setScalar(g)
          : _ instanceof Sf && g instanceof Sf
          ? (_.mask = g.mask)
          : _.set(g),
          !RP() && o && !o.linear && w && _.convertSRGBToLinear();
      }
    } else if (
      ((S[m] = g),
      S[m] instanceof er && S[m].format === no && S[m].type === pa && o)
    ) {
      const w = S[m];
      C1(w) && C1(o.gl)
        ? (w.colorSpace = o.gl.outputColorSpace)
        : (w.encoding = o.gl.outputEncoding);
    }
    hh(n);
  }
  if (r && r.parent && n.raycast && u !== r.eventCount) {
    const d = E0(n).getState().internal,
      m = d.interaction.indexOf(n);
    m > -1 && d.interaction.splice(m, 1), r.eventCount && d.interaction.push(n);
  }
  return (
    !(a.length === 1 && a[0][0] === "onUpdate") &&
      a.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      AS(n),
    n
  );
}
function hh(n) {
  var e, t;
  const r =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function AS(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function cG(n, e) {
  n.manual ||
    (PP(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function c0(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function fG() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return xh.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return xh.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return xh.ContinuousEventPriority;
    default:
      return xh.DefaultEventPriority;
  }
}
function NP(n, e, t, r) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function dG(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((r) => r !== e)),
    (t.initialHits = t.initialHits.filter((r) => r !== e)),
    t.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((r, i) => {
      NP(t.capturedMap, e, r, i);
    });
}
function hG(n) {
  function e(u) {
    const { internal: c } = n.getState(),
      d = u.offsetX - c.initialClick[0],
      m = u.offsetY - c.initialClick[1];
    return Math.round(Math.sqrt(d * d + m * m));
  }
  function t(u) {
    return u.filter((c) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((d) => {
        var m;
        return (m = c.__r3f) == null ? void 0 : m.handlers["onPointer" + d];
      })
    );
  }
  function r(u, c) {
    const d = n.getState(),
      m = new Set(),
      g = [],
      y = c ? c(d.internal.interaction) : d.internal.interaction;
    for (let w = 0; w < y.length; w++) {
      const T = Jp(y[w]);
      T && (T.raycaster.camera = void 0);
    }
    d.previousRoot || d.events.compute == null || d.events.compute(u, d);
    function x(w) {
      const T = Jp(w);
      if (!T || !T.events.enabled || T.raycaster.camera === null) return [];
      if (T.raycaster.camera === void 0) {
        var M;
        T.events.compute == null ||
          T.events.compute(
            u,
            T,
            (M = T.previousRoot) == null ? void 0 : M.getState()
          ),
          T.raycaster.camera === void 0 && (T.raycaster.camera = null);
      }
      return T.raycaster.camera ? T.raycaster.intersectObject(w, !0) : [];
    }
    let S = y
      .flatMap(x)
      .sort((w, T) => {
        const M = Jp(w.object),
          A = Jp(T.object);
        return !M || !A
          ? w.distance - T.distance
          : A.events.priority - M.events.priority || w.distance - T.distance;
      })
      .filter((w) => {
        const T = c0(w);
        return m.has(T) ? !1 : (m.add(T), !0);
      });
    d.events.filter && (S = d.events.filter(S, d));
    for (const w of S) {
      let T = w.object;
      for (; T; ) {
        var _;
        (_ = T.__r3f) != null &&
          _.eventCount &&
          g.push({ ...w, eventObject: T }),
          (T = T.parent);
      }
    }
    if ("pointerId" in u && d.internal.capturedMap.has(u.pointerId))
      for (let w of d.internal.capturedMap.get(u.pointerId).values())
        m.has(c0(w.intersection)) || g.push(w.intersection);
    return g;
  }
  function i(u, c, d, m) {
    const g = n.getState();
    if (u.length) {
      const y = { stopped: !1 };
      for (const x of u) {
        const S = Jp(x.object) || g,
          { raycaster: _, pointer: w, camera: T, internal: M } = S,
          A = new oe(w.x, w.y, 0).unproject(T),
          R = (L) => {
            var H, W;
            return (H =
              (W = M.capturedMap.get(L)) == null
                ? void 0
                : W.has(x.eventObject)) != null
              ? H
              : !1;
          },
          D = (L) => {
            const H = { intersection: x, target: c.target };
            M.capturedMap.has(L)
              ? M.capturedMap.get(L).set(x.eventObject, H)
              : M.capturedMap.set(L, new Map([[x.eventObject, H]])),
              c.target.setPointerCapture(L);
          },
          P = (L) => {
            const H = M.capturedMap.get(L);
            H && NP(M.capturedMap, x.eventObject, H, L);
          };
        let U = {};
        for (let L in c) {
          let H = c[L];
          typeof H != "function" && (U[L] = H);
        }
        let O = {
          ...x,
          ...U,
          pointer: w,
          intersections: u,
          stopped: y.stopped,
          delta: d,
          unprojectedPoint: A,
          ray: _.ray,
          camera: T,
          stopPropagation() {
            const L = "pointerId" in c && M.capturedMap.get(c.pointerId);
            if (
              (!L || L.has(x.eventObject)) &&
              ((O.stopped = y.stopped = !0),
              M.hovered.size &&
                Array.from(M.hovered.values()).find(
                  (H) => H.eventObject === x.eventObject
                ))
            ) {
              const H = u.slice(0, u.indexOf(x));
              o([...H, x]);
            }
          },
          target: {
            hasPointerCapture: R,
            setPointerCapture: D,
            releasePointerCapture: P,
          },
          currentTarget: {
            hasPointerCapture: R,
            setPointerCapture: D,
            releasePointerCapture: P,
          },
          nativeEvent: c,
        };
        if ((m(O), y.stopped === !0)) break;
      }
    }
    return u;
  }
  function o(u) {
    const { internal: c } = n.getState();
    for (const d of c.hovered.values())
      if (
        !u.length ||
        !u.find(
          (m) =>
            m.object === d.object &&
            m.index === d.index &&
            m.instanceId === d.instanceId
        )
      ) {
        const g = d.eventObject.__r3f,
          y = g == null ? void 0 : g.handlers;
        if ((c.hovered.delete(c0(d)), g != null && g.eventCount)) {
          const x = { ...d, intersections: u };
          y.onPointerOut == null || y.onPointerOut(x),
            y.onPointerLeave == null || y.onPointerLeave(x);
        }
      }
  }
  function s(u, c) {
    for (let d = 0; d < c.length; d++) {
      const m = c[d].__r3f;
      m == null ||
        m.handlers.onPointerMissed == null ||
        m.handlers.onPointerMissed(u);
    }
  }
  function a(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (c) => {
          const { internal: d } = n.getState();
          "pointerId" in c &&
            d.capturedMap.has(c.pointerId) &&
            requestAnimationFrame(() => {
              d.capturedMap.has(c.pointerId) &&
                (d.capturedMap.delete(c.pointerId), o([]));
            });
        };
    }
    return function (d) {
      const { onPointerMissed: m, internal: g } = n.getState();
      g.lastEvent.current = d;
      const y = u === "onPointerMove",
        x = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick",
        _ = r(d, y ? t : void 0),
        w = x ? e(d) : 0;
      u === "onPointerDown" &&
        ((g.initialClick = [d.offsetX, d.offsetY]),
        (g.initialHits = _.map((M) => M.eventObject))),
        x && !_.length && w <= 2 && (s(d, g.interaction), m && m(d)),
        y && o(_);
      function T(M) {
        const A = M.eventObject,
          R = A.__r3f,
          D = R == null ? void 0 : R.handlers;
        if (R != null && R.eventCount)
          if (y) {
            if (
              D.onPointerOver ||
              D.onPointerEnter ||
              D.onPointerOut ||
              D.onPointerLeave
            ) {
              const P = c0(M),
                U = g.hovered.get(P);
              U
                ? U.stopped && M.stopPropagation()
                : (g.hovered.set(P, M),
                  D.onPointerOver == null || D.onPointerOver(M),
                  D.onPointerEnter == null || D.onPointerEnter(M));
            }
            D.onPointerMove == null || D.onPointerMove(M);
          } else {
            const P = D[u];
            P
              ? (!x || g.initialHits.includes(A)) &&
                (s(
                  d,
                  g.interaction.filter((U) => !g.initialHits.includes(U))
                ),
                P(M))
              : x &&
                g.initialHits.includes(A) &&
                s(
                  d,
                  g.interaction.filter((U) => !g.initialHits.includes(U))
                );
          }
      }
      i(_, d, w, T);
    };
  }
  return { handlePointer: a };
}
const UP = (n) => !!(n != null && n.render),
  FP = X.createContext(null),
  pG = (n, e) => {
    const t = YW((a, u) => {
        const c = new oe(),
          d = new oe(),
          m = new oe();
        function g(w = u().camera, T = d, M = u().size) {
          const { width: A, height: R, top: D, left: P } = M,
            U = A / R;
          T instanceof oe ? m.copy(T) : m.set(...T);
          const O = w.getWorldPosition(c).distanceTo(m);
          if (PP(w))
            return {
              width: A / w.zoom,
              height: R / w.zoom,
              top: D,
              left: P,
              factor: 1,
              distance: O,
              aspect: U,
            };
          {
            const L = (w.fov * Math.PI) / 180,
              H = 2 * Math.tan(L / 2) * O,
              W = H * (A / R);
            return {
              width: W,
              height: H,
              top: D,
              left: P,
              factor: A / W,
              distance: O,
              aspect: U,
            };
          }
        }
        let y;
        const x = (w) =>
            a((T) => ({ performance: { ...T.performance, current: w } })),
          S = new tt();
        return {
          set: a,
          get: u,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (w = 1) => n(u(), w),
          advance: (w, T) => e(w, T, u()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new tb(),
          pointer: S,
          mouse: S,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const w = u();
              y && clearTimeout(y),
                w.performance.current !== w.performance.min &&
                  x(w.performance.min),
                (y = setTimeout(
                  () => x(u().performance.max),
                  w.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: g,
          },
          setEvents: (w) => a((T) => ({ ...T, events: { ...T.events, ...w } })),
          setSize: (w, T, M, A, R) => {
            const D = u().camera,
              P = {
                width: w,
                height: T,
                top: A || 0,
                left: R || 0,
                updateStyle: M,
              };
            a((U) => ({ size: P, viewport: { ...U.viewport, ...g(D, d, P) } }));
          },
          setDpr: (w) =>
            a((T) => {
              const M = kP(w);
              return {
                viewport: {
                  ...T.viewport,
                  dpr: M,
                  initialDpr: T.viewport.initialDpr || M,
                },
              };
            }),
          setFrameloop: (w = "always") => {
            const T = u().clock;
            T.stop(),
              (T.elapsedTime = 0),
              w !== "never" && (T.start(), (T.elapsedTime = 0)),
              a(() => ({ frameloop: w }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: X.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (w, T, M) => {
              const A = u().internal;
              return (
                (A.priority = A.priority + (T > 0 ? 1 : 0)),
                A.subscribers.push({ ref: w, priority: T, store: M }),
                (A.subscribers = A.subscribers.sort(
                  (R, D) => R.priority - D.priority
                )),
                () => {
                  const R = u().internal;
                  R != null &&
                    R.subscribers &&
                    ((R.priority = R.priority - (T > 0 ? 1 : 0)),
                    (R.subscribers = R.subscribers.filter((D) => D.ref !== w)));
                }
              );
            },
          },
        };
      }),
      r = t.getState();
    let i = r.size,
      o = r.viewport.dpr,
      s = r.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: u, viewport: c, gl: d, set: m } = t.getState();
        if (u.width !== i.width || u.height !== i.height || c.dpr !== o) {
          var g;
          (i = u), (o = c.dpr), cG(a, u), d.setPixelRatio(c.dpr);
          const y =
            (g = u.updateStyle) != null
              ? g
              : typeof HTMLCanvasElement < "u" &&
                d.domElement instanceof HTMLCanvasElement;
          d.setSize(u.width, u.height, y);
        }
        a !== s &&
          ((s = a),
          m((y) => ({
            viewport: { ...y.viewport, ...y.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let f0,
  mG = new Set(),
  gG = new Set(),
  vG = new Set();
function P1(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Qp(n, e) {
  switch (n) {
    case "before":
      return P1(mG, e);
    case "after":
      return P1(gG, e);
    case "tail":
      return P1(vG, e);
  }
}
let I1, L1;
function D1(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((r = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      I1 = e.internal.subscribers,
      f0 = 0;
    f0 < I1.length;
    f0++
  )
    (L1 = I1[f0]), L1.ref.current(L1.store.getState(), r, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function yG(n) {
  let e = !1,
    t = !1,
    r,
    i,
    o;
  function s(c) {
    (i = requestAnimationFrame(s)),
      (e = !0),
      (r = 0),
      Qp("before", c),
      (t = !0);
    for (const m of n.values()) {
      var d;
      (o = m.store.getState()),
        o.internal.active &&
          (o.frameloop === "always" || o.internal.frames > 0) &&
          !((d = o.gl.xr) != null && d.isPresenting) &&
          (r += D1(c, o));
    }
    if (((t = !1), Qp("after", c), r === 0))
      return Qp("tail", c), (e = !1), cancelAnimationFrame(i);
  }
  function a(c, d = 1) {
    var m;
    if (!c) return n.forEach((g) => a(g.store.getState(), d));
    ((m = c.gl.xr) != null && m.isPresenting) ||
      !c.internal.active ||
      c.frameloop === "never" ||
      (d > 1
        ? (c.internal.frames = Math.min(60, c.internal.frames + d))
        : t
        ? (c.internal.frames = 2)
        : (c.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function u(c, d = !0, m, g) {
    if ((d && Qp("before", c), m)) D1(c, m, g);
    else for (const y of n.values()) D1(c, y.store.getState());
    d && Qp("after", c);
  }
  return { loop: s, invalidate: a, advance: u };
}
function BP() {
  const n = X.useContext(FP);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function ua(n = (t) => t, e) {
  return BP()(n, e);
}
function yg(n, e = 0) {
  const t = BP(),
    r = t.getState().internal.subscribe,
    i = IP(n);
  return vg(() => r(i, e, t), [e, r, t]), null;
}
const y2 = new WeakMap();
function zP(n, e) {
  return function (t, ...r) {
    let i = y2.get(t);
    return (
      i || ((i = new t()), y2.set(t, i)),
      n && n(i),
      Promise.all(
        r.map(
          (o) =>
            new Promise((s, a) =>
              i.load(
                o,
                (u) => {
                  u.scene && Object.assign(u, lG(u.scene)), s(u);
                },
                e,
                (u) =>
                  a(
                    new Error(
                      `Could not load ${o}: ${u == null ? void 0 : u.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function xg(n, e, t, r) {
  const i = Array.isArray(e) ? e : [e],
    o = AP(zP(t, r), [n, ...i], { equal: Qn.equ });
  return Array.isArray(e) ? o : o[0];
}
xg.preload = function (n, e, t) {
  const r = Array.isArray(e) ? e : [e];
  return tG(zP(t), [n, ...r]);
};
xg.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return nG([n, ...t]);
};
const kh = new Map(),
  { invalidate: x2, advance: _2 } = yG(kh),
  { reconciler: Sy, applyProps: oh } = iG(kh, fG),
  sh = { objects: "shallow", strict: !1 },
  xG = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return UP(t)
      ? t
      : new IR({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function _G(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: o, left: s, updateStyle: a = t } = e;
    return { width: r, height: i, top: o, left: s, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: o,
      left: s,
    } = n.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: o, left: s, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function SG(n) {
  const e = kh.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    o = r || pG(x2, _2),
    s =
      t ||
      Sy.createContainer(o, xh.ConcurrentRoot, null, !1, null, "", i, null);
  e || kh.set(n, { fiber: s, store: o });
  let a,
    u = !1,
    c;
  return {
    configure(d = {}) {
      let {
          gl: m,
          size: g,
          scene: y,
          events: x,
          onCreated: S,
          shadows: _ = !1,
          linear: w = !1,
          flat: T = !1,
          legacy: M = !1,
          orthographic: A = !1,
          frameloop: R = "always",
          dpr: D = [1, 2],
          performance: P,
          raycaster: U,
          camera: O,
          onPointerMissed: L,
        } = d,
        H = o.getState(),
        W = H.gl;
      H.gl || H.set({ gl: (W = xG(m, n)) });
      let $ = H.raycaster;
      $ || H.set({ raycaster: ($ = new wP()) });
      const { params: K, ...Z } = U || {};
      if (
        (Qn.equ(Z, $, sh) || oh($, { ...Z }),
        Qn.equ(K, $.params, sh) || oh($, { params: { ...$.params, ...K } }),
        !H.camera || (H.camera === c && !Qn.equ(c, O, sh)))
      ) {
        c = O;
        const F = O instanceof ug,
          V = F
            ? O
            : A
            ? new Xu(0, 0, 0, 0, 0.1, 1e3)
            : new Nr(75, 0, 0.1, 1e3);
        F ||
          ((V.position.z = 5),
          O &&
            (oh(V, O),
            ("aspect" in O ||
              "left" in O ||
              "right" in O ||
              "bottom" in O ||
              "top" in O) &&
              ((V.manual = !0), V.updateProjectionMatrix())),
          !H.camera && !(O != null && O.rotation) && V.lookAt(0, 0, 0)),
          H.set({ camera: V }),
          ($.camera = V);
      }
      if (!H.scene) {
        let F;
        y instanceof gy ? (F = y) : ((F = new gy()), y && oh(F, y)),
          H.set({ scene: dh(F) });
      }
      if (!H.xr) {
        var Y;
        const F = (ae, J) => {
            const se = o.getState();
            se.frameloop !== "never" && _2(ae, !0, se, J);
          },
          V = () => {
            const ae = o.getState();
            (ae.gl.xr.enabled = ae.gl.xr.isPresenting),
              ae.gl.xr.setAnimationLoop(ae.gl.xr.isPresenting ? F : null),
              ae.gl.xr.isPresenting || x2(ae);
          },
          ne = {
            connect() {
              const ae = o.getState().gl;
              ae.xr.addEventListener("sessionstart", V),
                ae.xr.addEventListener("sessionend", V);
            },
            disconnect() {
              const ae = o.getState().gl;
              ae.xr.removeEventListener("sessionstart", V),
                ae.xr.removeEventListener("sessionend", V);
            },
          };
        typeof ((Y = W.xr) == null ? void 0 : Y.addEventListener) ==
          "function" && ne.connect(),
          H.set({ xr: ne });
      }
      if (W.shadowMap) {
        const F = W.shadowMap.enabled,
          V = W.shadowMap.type;
        if (((W.shadowMap.enabled = !!_), Qn.boo(_))) W.shadowMap.type = hm;
        else if (Qn.str(_)) {
          var re;
          const ne = { basic: wA, percentage: Wy, soft: hm, variance: la };
          W.shadowMap.type = (re = ne[_]) != null ? re : hm;
        } else Qn.obj(_) && Object.assign(W.shadowMap, _);
        (F !== W.shadowMap.enabled || V !== W.shadowMap.type) &&
          (W.shadowMap.needsUpdate = !0);
      }
      const G = RP();
      G &&
        ("enabled" in G
          ? (G.enabled = !M)
          : "legacyMode" in G && (G.legacyMode = M)),
        u ||
          oh(W, { outputEncoding: w ? 3e3 : 3001, toneMapping: T ? Za : yw }),
        H.legacy !== M && H.set(() => ({ legacy: M })),
        H.linear !== w && H.set(() => ({ linear: w })),
        H.flat !== T && H.set(() => ({ flat: T })),
        m && !Qn.fun(m) && !UP(m) && !Qn.equ(m, W, sh) && oh(W, m),
        x && !H.events.handlers && H.set({ events: x(o) });
      const te = _G(n, g);
      return (
        Qn.equ(te, H.size, sh) ||
          H.setSize(te.width, te.height, te.updateStyle, te.top, te.left),
        D && H.viewport.dpr !== kP(D) && H.setDpr(D),
        H.frameloop !== R && H.setFrameloop(R),
        H.onPointerMissed || H.set({ onPointerMissed: L }),
        P &&
          !Qn.equ(P, H.performance, sh) &&
          H.set((F) => ({ performance: { ...F.performance, ...P } })),
        (a = S),
        (u = !0),
        this
      );
    },
    render(d) {
      return (
        u || this.configure(),
        Sy.updateContainer(
          Q.jsx(wG, { store: o, children: d, onCreated: a, rootElement: n }),
          s,
          null,
          () => {}
        ),
        o
      );
    },
    unmount() {
      HP(n);
    },
  };
}
function wG({ store: n, children: e, onCreated: t, rootElement: r }) {
  return (
    vg(() => {
      const i = n.getState();
      i.set((o) => ({ internal: { ...o.internal, active: !0 } })),
        t && t(i),
        n.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    Q.jsx(FP.Provider, { value: n, children: e })
  );
}
function HP(n, e) {
  const t = kh.get(n),
    r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      Sy.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var o, s, a, u;
              i.events.disconnect == null || i.events.disconnect(),
                (o = i.gl) == null ||
                  (s = o.renderLists) == null ||
                  s.dispose == null ||
                  s.dispose(),
                (a = i.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (u = i.gl) != null && u.xr && i.xr.disconnect(),
                uG(i),
                kh.delete(n);
            } catch {}
          }, 500);
      });
  }
}
Sy.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: X.version,
});
function S2(n, e) {
  let t;
  return (...r) => {
    window.clearTimeout(t), (t = window.setTimeout(() => n(...r), e));
  };
}
function bG(
  { debounce: n, scroll: e, polyfill: t, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, s] = X.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    a = X.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
      orientationHandler: null,
    }),
    u = n ? (typeof n == "number" ? n : n.scroll) : null,
    c = n ? (typeof n == "number" ? n : n.resize) : null,
    d = X.useRef(!1);
  X.useEffect(() => ((d.current = !0), () => void (d.current = !1)));
  const [m, g, y] = X.useMemo(() => {
    const w = () => {
      if (!a.current.element) return;
      const {
          left: T,
          top: M,
          width: A,
          height: R,
          bottom: D,
          right: P,
          x: U,
          y: O,
        } = a.current.element.getBoundingClientRect(),
        L = {
          left: T,
          top: M,
          width: A,
          height: R,
          bottom: D,
          right: P,
          x: U,
          y: O,
        };
      a.current.element instanceof HTMLElement &&
        r &&
        ((L.height = a.current.element.offsetHeight),
        (L.width = a.current.element.offsetWidth)),
        Object.freeze(L),
        d.current &&
          !CG(a.current.lastBounds, L) &&
          s((a.current.lastBounds = L));
    };
    return [w, c ? S2(w, c) : w, u ? S2(w, u) : w];
  }, [s, r, u, c]);
  function x() {
    a.current.scrollContainers &&
      (a.current.scrollContainers.forEach((w) =>
        w.removeEventListener("scroll", y, !0)
      ),
      (a.current.scrollContainers = null)),
      a.current.resizeObserver &&
        (a.current.resizeObserver.disconnect(),
        (a.current.resizeObserver = null)),
      a.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              a.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              a.current.orientationHandler
            ));
  }
  function S() {
    a.current.element &&
      ((a.current.resizeObserver = new i(y)),
      a.current.resizeObserver.observe(a.current.element),
      e &&
        a.current.scrollContainers &&
        a.current.scrollContainers.forEach((w) =>
          w.addEventListener("scroll", y, { capture: !0, passive: !0 })
        ),
      (a.current.orientationHandler = () => {
        y();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            a.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            a.current.orientationHandler
          ));
  }
  const _ = (w) => {
    !w ||
      w === a.current.element ||
      (x(), (a.current.element = w), (a.current.scrollContainers = VP(w)), S());
  };
  return (
    EG(y, !!e),
    MG(g),
    X.useEffect(() => {
      x(), S();
    }, [e, y, g]),
    X.useEffect(() => x, []),
    [_, o, m]
  );
}
function MG(n) {
  X.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function EG(n, e) {
  X.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function VP(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(n);
  return (
    [t, r, i].some((o) => o === "auto" || o === "scroll") && e.push(n),
    [...e, ...VP(n.parentElement)]
  );
}
const TG = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  CG = (n, e) => TG.every((t) => n[t] === e[t]);
var AG = Object.defineProperty,
  RG = Object.defineProperties,
  PG = Object.getOwnPropertyDescriptors,
  w2 = Object.getOwnPropertySymbols,
  IG = Object.prototype.hasOwnProperty,
  LG = Object.prototype.propertyIsEnumerable,
  b2 = (n, e, t) =>
    e in n
      ? AG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  M2 = (n, e) => {
    for (var t in e || (e = {})) IG.call(e, t) && b2(n, t, e[t]);
    if (w2) for (var t of w2(e)) LG.call(e, t) && b2(n, t, e[t]);
    return n;
  },
  DG = (n, e) => RG(n, PG(e)),
  E2,
  T2;
typeof window < "u" &&
(((E2 = window.document) != null && E2.createElement) ||
  ((T2 = window.navigator) == null ? void 0 : T2.product) === "ReactNative")
  ? X.useLayoutEffect
  : X.useEffect;
function WP(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = n.child;
  for (; r; ) {
    const i = WP(r, e, t);
    if (i) return i;
    r = r.sibling;
  }
}
function GP(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const C2 = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = C2;
    return;
  }
  return C2.apply(this, arguments);
};
const ab = GP(X.createContext(null));
class jP extends X.Component {
  render() {
    return X.createElement(
      ab.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function kG() {
  const n = X.useContext(ab);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = X.useId();
  return X.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r) continue;
      const i = WP(r, !1, (o) => {
        let s = o.memoizedState;
        for (; s; ) {
          if (s.memoizedState === e) return !0;
          s = s.next;
        }
      });
      if (i) return i;
    }
  }, [n, e]);
}
function OG() {
  const n = kG(),
    [e] = X.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      i && i !== ab && !e.has(i) && e.set(i, X.useContext(GP(i)));
    }
    t = t.return;
  }
  return e;
}
function NG() {
  const n = OG();
  return X.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (r) =>
          X.createElement(
            e,
            null,
            X.createElement(t.Provider, DG(M2({}, r), { value: n.get(t) }))
          ),
        (e) => X.createElement(jP, M2({}, e))
      ),
    [n]
  );
}
const k1 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function UG(n) {
  const { handlePointer: e } = hG(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(
        (t.offsetX / r.size.width) * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(k1).reduce((t, r) => ({ ...t, [r]: e(r) }), {}),
    update: () => {
      var t;
      const { events: r, internal: i } = n.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const { set: i, events: o } = n.getState();
      o.disconnect == null || o.disconnect(),
        i((s) => ({ events: { ...s.events, connected: t } })),
        Object.entries((r = o.handlers) != null ? r : []).forEach(([s, a]) => {
          const [u, c] = k1[s];
          t.addEventListener(u, a, { passive: c });
        });
    },
    disconnect: () => {
      const { set: t, events: r } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([o, s]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [a] = k1[o];
            r.connected.removeEventListener(a, s);
          }
        }),
          t((o) => ({ events: { ...o.events, connected: void 0 } }));
      }
    },
  };
}
const FG = X.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: r,
      style: i,
      gl: o,
      events: s = UG,
      eventSource: a,
      eventPrefix: u,
      shadows: c,
      linear: d,
      flat: m,
      legacy: g,
      orthographic: y,
      frameloop: x,
      dpr: S,
      performance: _,
      raycaster: w,
      camera: T,
      scene: M,
      onPointerMissed: A,
      onCreated: R,
      ...D
    },
    P
  ) {
    X.useMemo(() => rG(WW), []);
    const U = NG(),
      [O, L] = bG({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      H = X.useRef(null),
      W = X.useRef(null);
    X.useImperativeHandle(P, () => H.current);
    const $ = IP(A),
      [K, Z] = X.useState(!1),
      [Y, re] = X.useState(!1);
    if (K) throw K;
    if (Y) throw Y;
    const G = X.useRef(null);
    vg(() => {
      const F = H.current;
      L.width > 0 &&
        L.height > 0 &&
        F &&
        (G.current || (G.current = SG(F)),
        G.current.configure({
          gl: o,
          events: s,
          shadows: c,
          linear: d,
          flat: m,
          legacy: g,
          orthographic: y,
          frameloop: x,
          dpr: S,
          performance: _,
          raycaster: w,
          camera: T,
          scene: M,
          size: L,
          onPointerMissed: (...V) =>
            $.current == null ? void 0 : $.current(...V),
          onCreated: (V) => {
            V.events.connect == null ||
              V.events.connect(a ? (oG(a) ? a.current : a) : W.current),
              u &&
                V.setEvents({
                  compute: (ne, ae) => {
                    const J = ne[u + "X"],
                      se = ne[u + "Y"];
                    ae.pointer.set(
                      (J / ae.size.width) * 2 - 1,
                      -(se / ae.size.height) * 2 + 1
                    ),
                      ae.raycaster.setFromCamera(ae.pointer, ae.camera);
                  },
                }),
              R == null || R(V);
          },
        }),
        G.current.render(
          Q.jsx(U, {
            children: Q.jsx(LP, {
              set: re,
              children: Q.jsx(X.Suspense, {
                fallback: Q.jsx(sG, { set: Z }),
                children: e,
              }),
            }),
          })
        ));
    }),
      X.useEffect(() => {
        const F = H.current;
        if (F) return () => HP(F);
      }, []);
    const te = a ? "none" : "auto";
    return Q.jsx("div", {
      ref: W,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: te,
        ...i,
      },
      ...D,
      children: Q.jsx("div", {
        ref: O,
        style: { width: "100%", height: "100%" },
        children: Q.jsx("canvas", {
          ref: H,
          style: { display: "block" },
          children: t,
        }),
      }),
    });
  }),
  $P = X.forwardRef(function (e, t) {
    return Q.jsx(jP, { children: Q.jsx(FG, { ...e, ref: t }) });
  }),
  XP = parseInt(og.replace(/\D+/g, "")),
  YP = XP >= 125 ? "uv1" : "uv2";
var BG = Object.defineProperty,
  zG = (n, e, t) =>
    e in n
      ? BG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  HG = (n, e, t) => (zG(n, e + "", t), t);
class VG {
  constructor() {
    HG(this, "_listeners");
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
}
var WG = Object.defineProperty,
  GG = (n, e, t) =>
    e in n
      ? WG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  Wt = (n, e, t) => (GG(n, typeof e != "symbol" ? e + "" : e, t), t);
const d0 = new Df(),
  A2 = new Ll(),
  jG = Math.cos(70 * (Math.PI / 180)),
  R2 = (n, e) => ((n % e) + e) % e;
let $G = class extends VG {
  constructor(e, t) {
    super(),
      Wt(this, "object"),
      Wt(this, "domElement"),
      Wt(this, "enabled", !0),
      Wt(this, "target", new oe()),
      Wt(this, "minDistance", 0),
      Wt(this, "maxDistance", 1 / 0),
      Wt(this, "minZoom", 0),
      Wt(this, "maxZoom", 1 / 0),
      Wt(this, "minPolarAngle", 0),
      Wt(this, "maxPolarAngle", Math.PI),
      Wt(this, "minAzimuthAngle", -1 / 0),
      Wt(this, "maxAzimuthAngle", 1 / 0),
      Wt(this, "enableDamping", !1),
      Wt(this, "dampingFactor", 0.05),
      Wt(this, "enableZoom", !0),
      Wt(this, "zoomSpeed", 1),
      Wt(this, "enableRotate", !0),
      Wt(this, "rotateSpeed", 1),
      Wt(this, "enablePan", !0),
      Wt(this, "panSpeed", 1),
      Wt(this, "screenSpacePanning", !0),
      Wt(this, "keyPanSpeed", 7),
      Wt(this, "zoomToCursor", !1),
      Wt(this, "autoRotate", !1),
      Wt(this, "autoRotateSpeed", 2),
      Wt(this, "reverseOrbit", !1),
      Wt(this, "reverseHorizontalOrbit", !1),
      Wt(this, "reverseVerticalOrbit", !1),
      Wt(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      Wt(this, "mouseButtons", {
        LEFT: rf.ROTATE,
        MIDDLE: rf.DOLLY,
        RIGHT: rf.PAN,
      }),
      Wt(this, "touches", { ONE: of.ROTATE, TWO: of.DOLLY_PAN }),
      Wt(this, "target0"),
      Wt(this, "position0"),
      Wt(this, "zoom0"),
      Wt(this, "_domElementKeyEvents", null),
      Wt(this, "getPolarAngle"),
      Wt(this, "getAzimuthalAngle"),
      Wt(this, "setPolarAngle"),
      Wt(this, "setAzimuthalAngle"),
      Wt(this, "getDistance"),
      Wt(this, "getZoomScale"),
      Wt(this, "listenToKeyEvents"),
      Wt(this, "stopListenToKeyEvents"),
      Wt(this, "saveState"),
      Wt(this, "reset"),
      Wt(this, "update"),
      Wt(this, "connect"),
      Wt(this, "dispose"),
      Wt(this, "dollyIn"),
      Wt(this, "dollyOut"),
      Wt(this, "getScale"),
      Wt(this, "setScale"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => d.phi),
      (this.getAzimuthalAngle = () => d.theta),
      (this.setPolarAngle = (he) => {
        let Je = R2(he, 2 * Math.PI),
          me = d.phi;
        me < 0 && (me += 2 * Math.PI), Je < 0 && (Je += 2 * Math.PI);
        let Ve = Math.abs(Je - me);
        2 * Math.PI - Ve < Ve &&
          (Je < me ? (Je += 2 * Math.PI) : (me += 2 * Math.PI)),
          (m.phi = Je - me),
          r.update();
      }),
      (this.setAzimuthalAngle = (he) => {
        let Je = R2(he, 2 * Math.PI),
          me = d.theta;
        me < 0 && (me += 2 * Math.PI), Je < 0 && (Je += 2 * Math.PI);
        let Ve = Math.abs(Je - me);
        2 * Math.PI - Ve < Ve &&
          (Je < me ? (Je += 2 * Math.PI) : (me += 2 * Math.PI)),
          (m.theta = Je - me),
          r.update();
      }),
      (this.getDistance = () => r.object.position.distanceTo(r.target)),
      (this.listenToKeyEvents = (he) => {
        he.addEventListener("keydown", Be), (this._domElementKeyEvents = he);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Be),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = () => {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(i),
          r.update(),
          (u = a.NONE);
      }),
      (this.update = (() => {
        const he = new oe(),
          Je = new oe(0, 1, 0),
          me = new io().setFromUnitVectors(e.up, Je),
          Ve = me.clone().invert(),
          Re = new oe(),
          Ue = new io(),
          it = 2 * Math.PI;
        return function () {
          const gt = r.object.position;
          me.setFromUnitVectors(e.up, Je),
            Ve.copy(me).invert(),
            he.copy(gt).sub(r.target),
            he.applyQuaternion(me),
            d.setFromVector3(he),
            r.autoRotate && u === a.NONE && K(W()),
            r.enableDamping
              ? ((d.theta += m.theta * r.dampingFactor),
                (d.phi += m.phi * r.dampingFactor))
              : ((d.theta += m.theta), (d.phi += m.phi));
          let Nt = r.minAzimuthAngle,
            Ut = r.maxAzimuthAngle;
          isFinite(Nt) &&
            isFinite(Ut) &&
            (Nt < -Math.PI ? (Nt += it) : Nt > Math.PI && (Nt -= it),
            Ut < -Math.PI ? (Ut += it) : Ut > Math.PI && (Ut -= it),
            Nt <= Ut
              ? (d.theta = Math.max(Nt, Math.min(Ut, d.theta)))
              : (d.theta =
                  d.theta > (Nt + Ut) / 2
                    ? Math.max(Nt, d.theta)
                    : Math.min(Ut, d.theta))),
            (d.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, d.phi)
            )),
            d.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(y, r.dampingFactor)
              : r.target.add(y),
            (r.zoomToCursor && O) || r.object.isOrthographicCamera
              ? (d.radius = ae(d.radius))
              : (d.radius = ae(d.radius * g)),
            he.setFromSpherical(d),
            he.applyQuaternion(Ve),
            gt.copy(r.target).add(he),
            r.object.matrixAutoUpdate || r.object.updateMatrix(),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((m.theta *= 1 - r.dampingFactor),
                (m.phi *= 1 - r.dampingFactor),
                y.multiplyScalar(1 - r.dampingFactor))
              : (m.set(0, 0, 0), y.set(0, 0, 0));
          let ht = !1;
          if (r.zoomToCursor && O) {
            let $t = null;
            if (r.object instanceof Nr && r.object.isPerspectiveCamera) {
              const un = he.length();
              $t = ae(un * g);
              const bn = un - $t;
              r.object.position.addScaledVector(P, bn),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const un = new oe(U.x, U.y, 0);
              un.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / g)
                )),
                r.object.updateProjectionMatrix(),
                (ht = !0);
              const bn = new oe(U.x, U.y, 0);
              bn.unproject(r.object),
                r.object.position.sub(bn).add(un),
                r.object.updateMatrixWorld(),
                ($t = he.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            $t !== null &&
              (r.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar($t)
                    .add(r.object.position)
                : (d0.origin.copy(r.object.position),
                  d0.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(d0.direction)) < jG
                    ? e.lookAt(r.target)
                    : (A2.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      d0.intersectPlane(A2, r.target))));
          } else
            r.object instanceof Xu &&
              r.object.isOrthographicCamera &&
              ((ht = g !== 1),
              ht &&
                ((r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / g)
                )),
                r.object.updateProjectionMatrix()));
          return (
            (g = 1),
            (O = !1),
            ht ||
            Re.distanceToSquared(r.object.position) > c ||
            8 * (1 - Ue.dot(r.object.quaternion)) > c
              ? (r.dispatchEvent(i),
                Re.copy(r.object.position),
                Ue.copy(r.object.quaternion),
                (ht = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (he) => {
        (r.domElement = he),
          (r.domElement.style.touchAction = "none"),
          r.domElement.addEventListener("contextmenu", nt),
          r.domElement.addEventListener("pointerdown", ve),
          r.domElement.addEventListener("pointercancel", _e),
          r.domElement.addEventListener("wheel", Fe);
      }),
      (this.dispose = () => {
        var he, Je, me, Ve, Re, Ue;
        r.domElement && (r.domElement.style.touchAction = "auto"),
          (he = r.domElement) == null ||
            he.removeEventListener("contextmenu", nt),
          (Je = r.domElement) == null ||
            Je.removeEventListener("pointerdown", ve),
          (me = r.domElement) == null ||
            me.removeEventListener("pointercancel", _e),
          (Ve = r.domElement) == null || Ve.removeEventListener("wheel", Fe),
          (Re = r.domElement) == null ||
            Re.ownerDocument.removeEventListener("pointermove", Se),
          (Ue = r.domElement) == null ||
            Ue.ownerDocument.removeEventListener("pointerup", _e),
          r._domElementKeyEvents !== null &&
            r._domElementKeyEvents.removeEventListener("keydown", Be);
      });
    const r = this,
      i = { type: "change" },
      o = { type: "start" },
      s = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let u = a.NONE;
    const c = 1e-6,
      d = new TS(),
      m = new TS();
    let g = 1;
    const y = new oe(),
      x = new tt(),
      S = new tt(),
      _ = new tt(),
      w = new tt(),
      T = new tt(),
      M = new tt(),
      A = new tt(),
      R = new tt(),
      D = new tt(),
      P = new oe(),
      U = new tt();
    let O = !1;
    const L = [],
      H = {};
    function W() {
      return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function $() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function K(he) {
      r.reverseOrbit || r.reverseHorizontalOrbit
        ? (m.theta += he)
        : (m.theta -= he);
    }
    function Z(he) {
      r.reverseOrbit || r.reverseVerticalOrbit ? (m.phi += he) : (m.phi -= he);
    }
    const Y = (() => {
        const he = new oe();
        return function (me, Ve) {
          he.setFromMatrixColumn(Ve, 0), he.multiplyScalar(-me), y.add(he);
        };
      })(),
      re = (() => {
        const he = new oe();
        return function (me, Ve) {
          r.screenSpacePanning === !0
            ? he.setFromMatrixColumn(Ve, 1)
            : (he.setFromMatrixColumn(Ve, 0), he.crossVectors(r.object.up, he)),
            he.multiplyScalar(me),
            y.add(he);
        };
      })(),
      G = (() => {
        const he = new oe();
        return function (me, Ve) {
          const Re = r.domElement;
          if (Re && r.object instanceof Nr && r.object.isPerspectiveCamera) {
            const Ue = r.object.position;
            he.copy(Ue).sub(r.target);
            let it = he.length();
            (it *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              Y((2 * me * it) / Re.clientHeight, r.object.matrix),
              re((2 * Ve * it) / Re.clientHeight, r.object.matrix);
          } else
            Re && r.object instanceof Xu && r.object.isOrthographicCamera
              ? (Y(
                  (me * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    Re.clientWidth,
                  r.object.matrix
                ),
                re(
                  (Ve * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    Re.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function te(he) {
      (r.object instanceof Nr && r.object.isPerspectiveCamera) ||
      (r.object instanceof Xu && r.object.isOrthographicCamera)
        ? (g = he)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function F(he) {
      te(g / he);
    }
    function V(he) {
      te(g * he);
    }
    function ne(he) {
      if (!r.zoomToCursor || !r.domElement) return;
      O = !0;
      const Je = r.domElement.getBoundingClientRect(),
        me = he.clientX - Je.left,
        Ve = he.clientY - Je.top,
        Re = Je.width,
        Ue = Je.height;
      (U.x = (me / Re) * 2 - 1),
        (U.y = -(Ve / Ue) * 2 + 1),
        P.set(U.x, U.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function ae(he) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, he));
    }
    function J(he) {
      x.set(he.clientX, he.clientY);
    }
    function se(he) {
      ne(he), A.set(he.clientX, he.clientY);
    }
    function de(he) {
      w.set(he.clientX, he.clientY);
    }
    function le(he) {
      S.set(he.clientX, he.clientY),
        _.subVectors(S, x).multiplyScalar(r.rotateSpeed);
      const Je = r.domElement;
      Je &&
        (K((2 * Math.PI * _.x) / Je.clientHeight),
        Z((2 * Math.PI * _.y) / Je.clientHeight)),
        x.copy(S),
        r.update();
    }
    function fe(he) {
      R.set(he.clientX, he.clientY),
        D.subVectors(R, A),
        D.y > 0 ? F($()) : D.y < 0 && V($()),
        A.copy(R),
        r.update();
    }
    function Me(he) {
      T.set(he.clientX, he.clientY),
        M.subVectors(T, w).multiplyScalar(r.panSpeed),
        G(M.x, M.y),
        w.copy(T),
        r.update();
    }
    function ge(he) {
      ne(he), he.deltaY < 0 ? V($()) : he.deltaY > 0 && F($()), r.update();
    }
    function xe(he) {
      let Je = !1;
      switch (he.code) {
        case r.keys.UP:
          G(0, r.keyPanSpeed), (Je = !0);
          break;
        case r.keys.BOTTOM:
          G(0, -r.keyPanSpeed), (Je = !0);
          break;
        case r.keys.LEFT:
          G(r.keyPanSpeed, 0), (Je = !0);
          break;
        case r.keys.RIGHT:
          G(-r.keyPanSpeed, 0), (Je = !0);
          break;
      }
      Je && (he.preventDefault(), r.update());
    }
    function j() {
      if (L.length == 1) x.set(L[0].pageX, L[0].pageY);
      else {
        const he = 0.5 * (L[0].pageX + L[1].pageX),
          Je = 0.5 * (L[0].pageY + L[1].pageY);
        x.set(he, Je);
      }
    }
    function we() {
      if (L.length == 1) w.set(L[0].pageX, L[0].pageY);
      else {
        const he = 0.5 * (L[0].pageX + L[1].pageX),
          Je = 0.5 * (L[0].pageY + L[1].pageY);
        w.set(he, Je);
      }
    }
    function Ae() {
      const he = L[0].pageX - L[1].pageX,
        Je = L[0].pageY - L[1].pageY,
        me = Math.sqrt(he * he + Je * Je);
      A.set(0, me);
    }
    function Oe() {
      r.enableZoom && Ae(), r.enablePan && we();
    }
    function Ie() {
      r.enableZoom && Ae(), r.enableRotate && j();
    }
    function rt(he) {
      if (L.length == 1) S.set(he.pageX, he.pageY);
      else {
        const me = et(he),
          Ve = 0.5 * (he.pageX + me.x),
          Re = 0.5 * (he.pageY + me.y);
        S.set(Ve, Re);
      }
      _.subVectors(S, x).multiplyScalar(r.rotateSpeed);
      const Je = r.domElement;
      Je &&
        (K((2 * Math.PI * _.x) / Je.clientHeight),
        Z((2 * Math.PI * _.y) / Je.clientHeight)),
        x.copy(S);
    }
    function De(he) {
      if (L.length == 1) T.set(he.pageX, he.pageY);
      else {
        const Je = et(he),
          me = 0.5 * (he.pageX + Je.x),
          Ve = 0.5 * (he.pageY + Je.y);
        T.set(me, Ve);
      }
      M.subVectors(T, w).multiplyScalar(r.panSpeed), G(M.x, M.y), w.copy(T);
    }
    function Xe(he) {
      const Je = et(he),
        me = he.pageX - Je.x,
        Ve = he.pageY - Je.y,
        Re = Math.sqrt(me * me + Ve * Ve);
      R.set(0, Re),
        D.set(0, Math.pow(R.y / A.y, r.zoomSpeed)),
        F(D.y),
        A.copy(R);
    }
    function ee(he) {
      r.enableZoom && Xe(he), r.enablePan && De(he);
    }
    function B(he) {
      r.enableZoom && Xe(he), r.enableRotate && rt(he);
    }
    function ve(he) {
      var Je, me;
      r.enabled !== !1 &&
        (L.length === 0 &&
          ((Je = r.domElement) == null ||
            Je.ownerDocument.addEventListener("pointermove", Se),
          (me = r.domElement) == null ||
            me.ownerDocument.addEventListener("pointerup", _e)),
        xt(he),
        he.pointerType === "touch" ? Ge(he) : Te(he));
    }
    function Se(he) {
      r.enabled !== !1 && (he.pointerType === "touch" ? Ye(he) : at(he));
    }
    function _e(he) {
      var Je, me, Ve;
      $e(he),
        L.length === 0 &&
          ((Je = r.domElement) == null ||
            Je.releasePointerCapture(he.pointerId),
          (me = r.domElement) == null ||
            me.ownerDocument.removeEventListener("pointermove", Se),
          (Ve = r.domElement) == null ||
            Ve.ownerDocument.removeEventListener("pointerup", _e)),
        r.dispatchEvent(s),
        (u = a.NONE);
    }
    function Te(he) {
      let Je;
      switch (he.button) {
        case 0:
          Je = r.mouseButtons.LEFT;
          break;
        case 1:
          Je = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Je = r.mouseButtons.RIGHT;
          break;
        default:
          Je = -1;
      }
      switch (Je) {
        case rf.DOLLY:
          if (r.enableZoom === !1) return;
          se(he), (u = a.DOLLY);
          break;
        case rf.ROTATE:
          if (he.ctrlKey || he.metaKey || he.shiftKey) {
            if (r.enablePan === !1) return;
            de(he), (u = a.PAN);
          } else {
            if (r.enableRotate === !1) return;
            J(he), (u = a.ROTATE);
          }
          break;
        case rf.PAN:
          if (he.ctrlKey || he.metaKey || he.shiftKey) {
            if (r.enableRotate === !1) return;
            J(he), (u = a.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            de(he), (u = a.PAN);
          }
          break;
        default:
          u = a.NONE;
      }
      u !== a.NONE && r.dispatchEvent(o);
    }
    function at(he) {
      if (r.enabled !== !1)
        switch (u) {
          case a.ROTATE:
            if (r.enableRotate === !1) return;
            le(he);
            break;
          case a.DOLLY:
            if (r.enableZoom === !1) return;
            fe(he);
            break;
          case a.PAN:
            if (r.enablePan === !1) return;
            Me(he);
            break;
        }
    }
    function Fe(he) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        (u !== a.NONE && u !== a.ROTATE) ||
        (he.preventDefault(), r.dispatchEvent(o), ge(he), r.dispatchEvent(s));
    }
    function Be(he) {
      r.enabled === !1 || r.enablePan === !1 || xe(he);
    }
    function Ge(he) {
      switch ((qe(he), L.length)) {
        case 1:
          switch (r.touches.ONE) {
            case of.ROTATE:
              if (r.enableRotate === !1) return;
              j(), (u = a.TOUCH_ROTATE);
              break;
            case of.PAN:
              if (r.enablePan === !1) return;
              we(), (u = a.TOUCH_PAN);
              break;
            default:
              u = a.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case of.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              Oe(), (u = a.TOUCH_DOLLY_PAN);
              break;
            case of.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              Ie(), (u = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              u = a.NONE;
          }
          break;
        default:
          u = a.NONE;
      }
      u !== a.NONE && r.dispatchEvent(o);
    }
    function Ye(he) {
      switch ((qe(he), u)) {
        case a.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          rt(he), r.update();
          break;
        case a.TOUCH_PAN:
          if (r.enablePan === !1) return;
          De(he), r.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          ee(he), r.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          B(he), r.update();
          break;
        default:
          u = a.NONE;
      }
    }
    function nt(he) {
      r.enabled !== !1 && he.preventDefault();
    }
    function xt(he) {
      L.push(he);
    }
    function $e(he) {
      delete H[he.pointerId];
      for (let Je = 0; Je < L.length; Je++)
        if (L[Je].pointerId == he.pointerId) {
          L.splice(Je, 1);
          return;
        }
    }
    function qe(he) {
      let Je = H[he.pointerId];
      Je === void 0 && ((Je = new tt()), (H[he.pointerId] = Je)),
        Je.set(he.pageX, he.pageY);
    }
    function et(he) {
      const Je = he.pointerId === L[0].pointerId ? L[1] : L[0];
      return H[Je.pointerId];
    }
    (this.dollyIn = (he = $()) => {
      V(he), r.update();
    }),
      (this.dollyOut = (he = $()) => {
        F(he), r.update();
      }),
      (this.getScale = () => g),
      (this.setScale = (he) => {
        te(he), r.update();
      }),
      (this.getZoomScale = () => $()),
      t !== void 0 && this.connect(t),
      this.update();
  }
};
const P2 = new ci(),
  h0 = new oe();
class lb extends Mx {
  constructor() {
    super(),
      (this.isLineSegmentsGeometry = !0),
      (this.type = "LineSegmentsGeometry");
    const e = [
        -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1,
        -1, 0,
      ],
      t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
      r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r),
      this.setAttribute("position", new Pt(e, 3)),
      this.setAttribute("uv", new Pt(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart,
      r = this.attributes.instanceEnd;
    return (
      t !== void 0 &&
        (t.applyMatrix4(e), r.applyMatrix4(e), (t.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array
      ? (t = e)
      : Array.isArray(e) && (t = new Float32Array(e));
    const r = new _y(t, 6, 1);
    return (
      this.setAttribute("instanceStart", new as(r, 3, 0)),
      this.setAttribute("instanceEnd", new as(r, 3, 3)),
      this.computeBoundingBox(),
      this.computeBoundingSphere(),
      this
    );
  }
  setColors(e, t = 3) {
    let r;
    e instanceof Float32Array
      ? (r = e)
      : Array.isArray(e) && (r = new Float32Array(e));
    const i = new _y(r, t * 2, 1);
    return (
      this.setAttribute("instanceColorStart", new as(i, t, 0)),
      this.setAttribute("instanceColorEnd", new as(i, t, t)),
      this
    );
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new Xw(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ci());
    const e = this.attributes.instanceStart,
      t = this.attributes.instanceEnd;
    e !== void 0 &&
      t !== void 0 &&
      (this.boundingBox.setFromBufferAttribute(e),
      P2.setFromBufferAttribute(t),
      this.boundingBox.union(P2));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fi()),
      this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart,
      t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let i = 0;
      for (let o = 0, s = e.count; o < s; o++)
        h0.fromBufferAttribute(e, o),
          (i = Math.max(i, r.distanceToSquared(h0))),
          h0.fromBufferAttribute(t, o),
          (i = Math.max(i, r.distanceToSquared(h0)));
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
            this
          );
    }
  }
  toJSON() {}
  applyMatrix(e) {
    return (
      console.warn(
        "THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."
      ),
      this.applyMatrix4(e)
    );
  }
}
class qP extends lb {
  constructor() {
    super(), (this.isLineGeometry = !0), (this.type = "LineGeometry");
  }
  setPositions(e) {
    const t = e.length - 3,
      r = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      (r[2 * i] = e[i]),
        (r[2 * i + 1] = e[i + 1]),
        (r[2 * i + 2] = e[i + 2]),
        (r[2 * i + 3] = e[i + 3]),
        (r[2 * i + 4] = e[i + 4]),
        (r[2 * i + 5] = e[i + 5]);
    return super.setPositions(r), this;
  }
  setColors(e, t = 3) {
    const r = e.length - t,
      i = new Float32Array(2 * r);
    if (t === 3)
      for (let o = 0; o < r; o += t)
        (i[2 * o] = e[o]),
          (i[2 * o + 1] = e[o + 1]),
          (i[2 * o + 2] = e[o + 2]),
          (i[2 * o + 3] = e[o + 3]),
          (i[2 * o + 4] = e[o + 4]),
          (i[2 * o + 5] = e[o + 5]);
    else
      for (let o = 0; o < r; o += t)
        (i[2 * o] = e[o]),
          (i[2 * o + 1] = e[o + 1]),
          (i[2 * o + 2] = e[o + 2]),
          (i[2 * o + 3] = e[o + 3]),
          (i[2 * o + 4] = e[o + 4]),
          (i[2 * o + 5] = e[o + 5]),
          (i[2 * o + 6] = e[o + 6]),
          (i[2 * o + 7] = e[o + 7]);
    return super.setColors(i, t), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class ub extends Ds {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: $m.clone(
        $m.merge([
          vt.common,
          vt.fog,
          {
            worldUnits: { value: 1 },
            linewidth: { value: 1 },
            resolution: { value: new tt(1, 1) },
            dashOffset: { value: 0 },
            dashScale: { value: 1 },
            dashSize: { value: 1 },
            gapSize: { value: 1 },
          },
        ])
      ),
      vertexShader: `
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,
      fragmentShader: `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${XP >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,
      clipping: !0,
    }),
      (this.isLineMaterial = !0),
      (this.onBeforeCompile = function () {
        this.transparent
          ? (this.defines.USE_LINE_COLOR_ALPHA = "1")
          : delete this.defines.USE_LINE_COLOR_ALPHA;
      }),
      Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value;
          },
          set: function (t) {
            this.uniforms.diffuse.value = t;
          },
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines;
          },
          set: function (t) {
            t === !0
              ? (this.defines.WORLD_UNITS = "")
              : delete this.defines.WORLD_UNITS;
          },
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value;
          },
          set: function (t) {
            this.uniforms.linewidth.value = t;
          },
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return "USE_DASH" in this.defines;
          },
          set(t) {
            !!t != "USE_DASH" in this.defines && (this.needsUpdate = !0),
              t === !0
                ? (this.defines.USE_DASH = "")
                : delete this.defines.USE_DASH;
          },
        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value;
          },
          set: function (t) {
            this.uniforms.dashScale.value = t;
          },
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value;
          },
          set: function (t) {
            this.uniforms.dashSize.value = t;
          },
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value;
          },
          set: function (t) {
            this.uniforms.dashOffset.value = t;
          },
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value;
          },
          set: function (t) {
            this.uniforms.gapSize.value = t;
          },
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value;
          },
          set: function (t) {
            this.uniforms.opacity.value = t;
          },
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value;
          },
          set: function (t) {
            this.uniforms.resolution.value.copy(t);
          },
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return "USE_ALPHA_TO_COVERAGE" in this.defines;
          },
          set: function (t) {
            !!t != "USE_ALPHA_TO_COVERAGE" in this.defines &&
              (this.needsUpdate = !0),
              t === !0
                ? ((this.defines.USE_ALPHA_TO_COVERAGE = ""),
                  (this.extensions.derivatives = !0))
                : (delete this.defines.USE_ALPHA_TO_COVERAGE,
                  (this.extensions.derivatives = !1));
          },
        },
      }),
      this.setValues(e);
  }
}
const O1 = new dn(),
  I2 = new oe(),
  L2 = new oe(),
  ki = new dn(),
  Oi = new dn(),
  Ha = new dn(),
  N1 = new oe(),
  U1 = new Gt(),
  Ui = new bP(),
  D2 = new oe(),
  p0 = new ci(),
  m0 = new fi(),
  Va = new dn();
let $a, bf;
function k2(n, e, t) {
  return (
    Va.set(0, 0, -e, 1).applyMatrix4(n.projectionMatrix),
    Va.multiplyScalar(1 / Va.w),
    (Va.x = bf / t.width),
    (Va.y = bf / t.height),
    Va.applyMatrix4(n.projectionMatrixInverse),
    Va.multiplyScalar(1 / Va.w),
    Math.abs(Math.max(Va.x, Va.y))
  );
}
function XG(n, e) {
  const t = n.matrixWorld,
    r = n.geometry,
    i = r.attributes.instanceStart,
    o = r.attributes.instanceEnd,
    s = Math.min(r.instanceCount, i.count);
  for (let a = 0, u = s; a < u; a++) {
    Ui.start.fromBufferAttribute(i, a),
      Ui.end.fromBufferAttribute(o, a),
      Ui.applyMatrix4(t);
    const c = new oe(),
      d = new oe();
    $a.distanceSqToSegment(Ui.start, Ui.end, d, c),
      d.distanceTo(c) < bf * 0.5 &&
        e.push({
          point: d,
          pointOnLine: c,
          distance: $a.origin.distanceTo(d),
          object: n,
          face: null,
          faceIndex: a,
          uv: null,
          [YP]: null,
        });
  }
}
function YG(n, e, t) {
  const r = e.projectionMatrix,
    o = n.material.resolution,
    s = n.matrixWorld,
    a = n.geometry,
    u = a.attributes.instanceStart,
    c = a.attributes.instanceEnd,
    d = Math.min(a.instanceCount, u.count),
    m = -e.near;
  $a.at(1, Ha),
    (Ha.w = 1),
    Ha.applyMatrix4(e.matrixWorldInverse),
    Ha.applyMatrix4(r),
    Ha.multiplyScalar(1 / Ha.w),
    (Ha.x *= o.x / 2),
    (Ha.y *= o.y / 2),
    (Ha.z = 0),
    N1.copy(Ha),
    U1.multiplyMatrices(e.matrixWorldInverse, s);
  for (let g = 0, y = d; g < y; g++) {
    if (
      (ki.fromBufferAttribute(u, g),
      Oi.fromBufferAttribute(c, g),
      (ki.w = 1),
      (Oi.w = 1),
      ki.applyMatrix4(U1),
      Oi.applyMatrix4(U1),
      ki.z > m && Oi.z > m)
    )
      continue;
    if (ki.z > m) {
      const M = ki.z - Oi.z,
        A = (ki.z - m) / M;
      ki.lerp(Oi, A);
    } else if (Oi.z > m) {
      const M = Oi.z - ki.z,
        A = (Oi.z - m) / M;
      Oi.lerp(ki, A);
    }
    ki.applyMatrix4(r),
      Oi.applyMatrix4(r),
      ki.multiplyScalar(1 / ki.w),
      Oi.multiplyScalar(1 / Oi.w),
      (ki.x *= o.x / 2),
      (ki.y *= o.y / 2),
      (Oi.x *= o.x / 2),
      (Oi.y *= o.y / 2),
      Ui.start.copy(ki),
      (Ui.start.z = 0),
      Ui.end.copy(Oi),
      (Ui.end.z = 0);
    const S = Ui.closestPointToPointParameter(N1, !0);
    Ui.at(S, D2);
    const _ = mR.lerp(ki.z, Oi.z, S),
      w = _ >= -1 && _ <= 1,
      T = N1.distanceTo(D2) < bf * 0.5;
    if (w && T) {
      Ui.start.fromBufferAttribute(u, g),
        Ui.end.fromBufferAttribute(c, g),
        Ui.start.applyMatrix4(s),
        Ui.end.applyMatrix4(s);
      const M = new oe(),
        A = new oe();
      $a.distanceSqToSegment(Ui.start, Ui.end, A, M),
        t.push({
          point: A,
          pointOnLine: M,
          distance: $a.origin.distanceTo(A),
          object: n,
          face: null,
          faceIndex: g,
          uv: null,
          [YP]: null,
        });
    }
  }
}
class KP extends ur {
  constructor(e = new lb(), t = new ub({ color: Math.random() * 16777215 })) {
    super(e, t), (this.isLineSegments2 = !0), (this.type = "LineSegments2");
  }
  computeLineDistances() {
    const e = this.geometry,
      t = e.attributes.instanceStart,
      r = e.attributes.instanceEnd,
      i = new Float32Array(2 * t.count);
    for (let s = 0, a = 0, u = t.count; s < u; s++, a += 2)
      I2.fromBufferAttribute(t, s),
        L2.fromBufferAttribute(r, s),
        (i[a] = a === 0 ? 0 : i[a - 1]),
        (i[a + 1] = i[a] + I2.distanceTo(L2));
    const o = new _y(i, 2, 1);
    return (
      e.setAttribute("instanceDistanceStart", new as(o, 1, 0)),
      e.setAttribute("instanceDistanceEnd", new as(o, 1, 1)),
      this
    );
  }
  raycast(e, t) {
    const r = this.material.worldUnits,
      i = e.camera;
    i === null &&
      !r &&
      console.error(
        'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'
      );
    const o = (e.params.Line2 !== void 0 && e.params.Line2.threshold) || 0;
    $a = e.ray;
    const s = this.matrixWorld,
      a = this.geometry,
      u = this.material;
    (bf = u.linewidth + o),
      a.boundingSphere === null && a.computeBoundingSphere(),
      m0.copy(a.boundingSphere).applyMatrix4(s);
    let c;
    if (r) c = bf * 0.5;
    else {
      const m = Math.max(i.near, m0.distanceToPoint($a.origin));
      c = k2(i, m, u.resolution);
    }
    if (((m0.radius += c), $a.intersectsSphere(m0) === !1)) return;
    a.boundingBox === null && a.computeBoundingBox(),
      p0.copy(a.boundingBox).applyMatrix4(s);
    let d;
    if (r) d = bf * 0.5;
    else {
      const m = Math.max(i.near, p0.distanceToPoint($a.origin));
      d = k2(i, m, u.resolution);
    }
    p0.expandByScalar(d),
      $a.intersectsBox(p0) !== !1 && (r ? XG(this, t) : YG(this, i, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t &&
      t.resolution &&
      (e.getViewport(O1),
      this.material.uniforms.resolution.value.set(O1.z, O1.w));
  }
}
class qG extends KP {
  constructor(e = new qP(), t = new ub({ color: Math.random() * 16777215 })) {
    super(e, t), (this.isLine2 = !0), (this.type = "Line2");
  }
}
const ZP = X.forwardRef(function (
  {
    points: e,
    color: t = 16777215,
    vertexColors: r,
    linewidth: i,
    lineWidth: o,
    segments: s,
    dashed: a,
    ...u
  },
  c
) {
  var d, m;
  const g = ua((w) => w.size),
    y = X.useMemo(() => (s ? new KP() : new qG()), [s]),
    [x] = X.useState(() => new ub()),
    S = (r == null || (d = r[0]) == null ? void 0 : d.length) === 4 ? 4 : 3,
    _ = X.useMemo(() => {
      const w = s ? new lb() : new qP(),
        T = e.map((M) => {
          const A = Array.isArray(M);
          return M instanceof oe || M instanceof dn
            ? [M.x, M.y, M.z]
            : M instanceof tt
            ? [M.x, M.y, 0]
            : A && M.length === 3
            ? [M[0], M[1], M[2]]
            : A && M.length === 2
            ? [M[0], M[1], 0]
            : M;
        });
      if ((w.setPositions(T.flat()), r)) {
        t = 16777215;
        const M = r.map((A) => (A instanceof St ? A.toArray() : A));
        w.setColors(M.flat(), S);
      }
      return w;
    }, [e, s, r, S]);
  return (
    X.useLayoutEffect(() => {
      y.computeLineDistances();
    }, [e, y]),
    X.useLayoutEffect(() => {
      a ? (x.defines.USE_DASH = "") : delete x.defines.USE_DASH,
        (x.needsUpdate = !0);
    }, [a, x]),
    X.useEffect(() => () => _.dispose(), [_]),
    X.createElement(
      "primitive",
      ue({ object: y, ref: c }, u),
      X.createElement("primitive", { object: _, attach: "geometry" }),
      X.createElement(
        "primitive",
        ue(
          {
            object: x,
            attach: "material",
            color: t,
            vertexColors: !!r,
            resolution: [g.width, g.height],
            linewidth: (m = i ?? o) !== null && m !== void 0 ? m : 1,
            dashed: a,
            transparent: S === 4,
          },
          u
        )
      )
    )
  );
});
function KG() {
  var n = Object.create(null);
  function e(i, o) {
    var s = i.id,
      a = i.name,
      u = i.dependencies;
    u === void 0 && (u = []);
    var c = i.init;
    c === void 0 && (c = function () {});
    var d = i.getTransferables;
    if ((d === void 0 && (d = null), !n[s]))
      try {
        (u = u.map(function (g) {
          return (
            g &&
              g.isWorkerModule &&
              (e(g, function (y) {
                if (y instanceof Error) throw y;
              }),
              (g = n[g.id].value)),
            g
          );
        })),
          (c = r("<" + a + ">.init", c)),
          d && (d = r("<" + a + ">.getTransferables", d));
        var m = null;
        typeof c == "function"
          ? (m = c.apply(void 0, u))
          : console.error("worker module init function failed to rehydrate"),
          (n[s] = { id: s, value: m, getTransferables: d }),
          o(m);
      } catch (g) {
        (g && g.noLog) || console.error(g), o(g);
      }
  }
  function t(i, o) {
    var s,
      a = i.id,
      u = i.args;
    (!n[a] || typeof n[a].value != "function") &&
      o(
        new Error(
          "Worker module " +
            a +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var c = (s = n[a]).value.apply(s, u);
      c && typeof c.then == "function"
        ? c.then(d, function (m) {
            return o(m instanceof Error ? m : new Error("" + m));
          })
        : d(c);
    } catch (m) {
      o(m);
    }
    function d(m) {
      try {
        var g = n[a].getTransferables && n[a].getTransferables(m);
        (!g || !Array.isArray(g) || !g.length) && (g = void 0), o(m, g);
      } catch (y) {
        console.error(y), o(y);
      }
    }
  }
  function r(i, o) {
    var s = void 0;
    self.troikaDefine = function (u) {
      return (s = u);
    };
    var a = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            i.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            o +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(a);
    } catch (u) {
      console.error(u);
    }
    return URL.revokeObjectURL(a), delete self.troikaDefine, s;
  }
  self.addEventListener("message", function (i) {
    var o = i.data,
      s = o.messageId,
      a = o.action,
      u = o.data;
    try {
      a === "registerModule" &&
        e(u, function (c) {
          c instanceof Error
            ? postMessage({ messageId: s, success: !1, error: c.message })
            : postMessage({
                messageId: s,
                success: !0,
                result: { isCallable: typeof c == "function" },
              });
        }),
        a === "callModule" &&
          t(u, function (c, d) {
            c instanceof Error
              ? postMessage({ messageId: s, success: !1, error: c.message })
              : postMessage(
                  { messageId: s, success: !0, result: c },
                  d || void 0
                );
          });
    } catch (c) {
      postMessage({ messageId: s, success: !1, error: c.stack });
    }
  });
}
function ZG(n) {
  var e = function () {
    for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
    return e._getInitResult().then(function (i) {
      if (typeof i == "function") return i.apply(void 0, t);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var t = n.dependencies,
        r = n.init;
      t = Array.isArray(t)
        ? t.map(function (o) {
            return o && o._getInitResult ? o._getInitResult() : o;
          })
        : [];
      var i = Promise.all(t).then(function (o) {
        return r.apply(null, o);
      });
      return (
        (e._getInitResult = function () {
          return i;
        }),
        i
      );
    }),
    e
  );
}
var JP = function () {
    var n = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        e.terminate(), (n = !0);
      } catch (t) {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
            t.message +
            "]"
        );
      }
    return (
      (JP = function () {
        return n;
      }),
      n
    );
  },
  JG = 0,
  QG = 0,
  F1 = !1,
  bm = Object.create(null),
  Mm = Object.create(null),
  RS = Object.create(null);
function $h(n) {
  if ((!n || typeof n.init != "function") && !F1)
    throw new Error("requires `options.init` function");
  var e = n.dependencies,
    t = n.init,
    r = n.getTransferables,
    i = n.workerId;
  if (!JP()) return ZG(n);
  i == null && (i = "#default");
  var o = "workerModule" + ++JG,
    s = n.name || o,
    a = null;
  e =
    e &&
    e.map(function (c) {
      return (
        typeof c == "function" &&
          !c.workerModuleData &&
          ((F1 = !0),
          (c = $h({
            workerId: i,
            name: "<" + s + "> function dependency: " + c.name,
            init:
              `function(){return (
` +
              T0(c) +
              `
)}`,
          })),
          (F1 = !1)),
        c && c.workerModuleData && (c = c.workerModuleData),
        c
      );
    });
  function u() {
    for (var c = [], d = arguments.length; d--; ) c[d] = arguments[d];
    if (!a) {
      a = O2(i, "registerModule", u.workerModuleData);
      var m = function () {
        (a = null), Mm[i].delete(m);
      };
      (Mm[i] || (Mm[i] = new Set())).add(m);
    }
    return a.then(function (g) {
      var y = g.isCallable;
      if (y) return O2(i, "callModule", { id: o, args: c });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (u.workerModuleData = {
      isWorkerModule: !0,
      id: o,
      name: s,
      dependencies: e,
      init: T0(t),
      getTransferables: r && T0(r),
    }),
    u
  );
}
function e9(n) {
  Mm[n] &&
    Mm[n].forEach(function (e) {
      e();
    }),
    bm[n] && (bm[n].terminate(), delete bm[n]);
}
function T0(n) {
  var e = n.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
  );
}
function t9(n) {
  var e = bm[n];
  if (!e) {
    var t = T0(KG);
    (e = bm[n] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                n.replace(/\*/g, "") +
                ` **/

;(` +
                t +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (e.onmessage = function (r) {
        var i = r.data,
          o = i.messageId,
          s = RS[o];
        if (!s)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete RS[o], s(i);
      });
  }
  return e;
}
function O2(n, e, t) {
  return new Promise(function (r, i) {
    var o = ++QG;
    (RS[o] = function (s) {
      s.success
        ? r(s.result)
        : i(new Error("Error in worker " + e + " call: " + s.error));
    }),
      t9(n).postMessage({ messageId: o, action: e, data: t });
  });
}
function QP() {
  var n = (function (e) {
    function t(te, F, V, ne, ae, J, se, de) {
      var le = 1 - se;
      (de.x = le * le * te + 2 * le * se * V + se * se * ae),
        (de.y = le * le * F + 2 * le * se * ne + se * se * J);
    }
    function r(te, F, V, ne, ae, J, se, de, le, fe) {
      var Me = 1 - le;
      (fe.x =
        Me * Me * Me * te +
        3 * Me * Me * le * V +
        3 * Me * le * le * ae +
        le * le * le * se),
        (fe.y =
          Me * Me * Me * F +
          3 * Me * Me * le * ne +
          3 * Me * le * le * J +
          le * le * le * de);
    }
    function i(te, F) {
      for (
        var V = /([MLQCZ])([^MLQCZ]*)/g, ne, ae, J, se, de;
        (ne = V.exec(te));

      ) {
        var le = ne[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (fe) {
            return parseFloat(fe);
          });
        switch (ne[1]) {
          case "M":
            (se = ae = le[0]), (de = J = le[1]);
            break;
          case "L":
            (le[0] !== se || le[1] !== de) &&
              F("L", se, de, (se = le[0]), (de = le[1]));
            break;
          case "Q": {
            F("Q", se, de, (se = le[2]), (de = le[3]), le[0], le[1]);
            break;
          }
          case "C": {
            F(
              "C",
              se,
              de,
              (se = le[4]),
              (de = le[5]),
              le[0],
              le[1],
              le[2],
              le[3]
            );
            break;
          }
          case "Z":
            (se !== ae || de !== J) && F("L", se, de, ae, J);
            break;
        }
      }
    }
    function o(te, F, V) {
      V === void 0 && (V = 16);
      var ne = { x: 0, y: 0 };
      i(te, function (ae, J, se, de, le, fe, Me, ge, xe) {
        switch (ae) {
          case "L":
            F(J, se, de, le);
            break;
          case "Q": {
            for (var j = J, we = se, Ae = 1; Ae < V; Ae++)
              t(J, se, fe, Me, de, le, Ae / (V - 1), ne),
                F(j, we, ne.x, ne.y),
                (j = ne.x),
                (we = ne.y);
            break;
          }
          case "C": {
            for (var Oe = J, Ie = se, rt = 1; rt < V; rt++)
              r(J, se, fe, Me, ge, xe, de, le, rt / (V - 1), ne),
                F(Oe, Ie, ne.x, ne.y),
                (Oe = ne.x),
                (Ie = ne.y);
            break;
          }
        }
      });
    }
    var s =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      a =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      u = new WeakMap(),
      c = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function d(te, F) {
      var V = te.getContext ? te.getContext("webgl", c) : te,
        ne = u.get(V);
      if (!ne) {
        let Oe = function (B) {
            var ve = J[B];
            if (!ve && ((ve = J[B] = V.getExtension(B)), !ve))
              throw new Error(B + " not supported");
            return ve;
          },
          Ie = function (B, ve) {
            var Se = V.createShader(ve);
            return V.shaderSource(Se, B), V.compileShader(Se), Se;
          },
          rt = function (B, ve, Se, _e) {
            if (!se[B]) {
              var Te = {},
                at = {},
                Fe = V.createProgram();
              V.attachShader(Fe, Ie(ve, V.VERTEX_SHADER)),
                V.attachShader(Fe, Ie(Se, V.FRAGMENT_SHADER)),
                V.linkProgram(Fe),
                (se[B] = {
                  program: Fe,
                  transaction: function (Ge) {
                    V.useProgram(Fe),
                      Ge({
                        setUniform: function (nt, xt) {
                          for (
                            var $e = [], qe = arguments.length - 2;
                            qe-- > 0;

                          )
                            $e[qe] = arguments[qe + 2];
                          var et =
                            at[xt] || (at[xt] = V.getUniformLocation(Fe, xt));
                          V["uniform" + nt].apply(V, [et].concat($e));
                        },
                        setAttribute: function (nt, xt, $e, qe, et) {
                          var he = Te[nt];
                          he ||
                            (he = Te[nt] =
                              {
                                buf: V.createBuffer(),
                                loc: V.getAttribLocation(Fe, nt),
                                data: null,
                              }),
                            V.bindBuffer(V.ARRAY_BUFFER, he.buf),
                            V.vertexAttribPointer(
                              he.loc,
                              xt,
                              V.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            V.enableVertexAttribArray(he.loc),
                            ae
                              ? V.vertexAttribDivisor(he.loc, qe)
                              : Oe(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(he.loc, qe),
                            et !== he.data &&
                              (V.bufferData(V.ARRAY_BUFFER, et, $e),
                              (he.data = et));
                        },
                      });
                  },
                });
            }
            se[B].transaction(_e);
          },
          De = function (B, ve) {
            le++;
            try {
              V.activeTexture(V.TEXTURE0 + le);
              var Se = de[B];
              Se ||
                ((Se = de[B] = V.createTexture()),
                V.bindTexture(V.TEXTURE_2D, Se),
                V.texParameteri(V.TEXTURE_2D, V.TEXTURE_MIN_FILTER, V.NEAREST),
                V.texParameteri(V.TEXTURE_2D, V.TEXTURE_MAG_FILTER, V.NEAREST)),
                V.bindTexture(V.TEXTURE_2D, Se),
                ve(Se, le);
            } finally {
              le--;
            }
          },
          Xe = function (B, ve, Se) {
            var _e = V.createFramebuffer();
            fe.push(_e),
              V.bindFramebuffer(V.FRAMEBUFFER, _e),
              V.activeTexture(V.TEXTURE0 + ve),
              V.bindTexture(V.TEXTURE_2D, B),
              V.framebufferTexture2D(
                V.FRAMEBUFFER,
                V.COLOR_ATTACHMENT0,
                V.TEXTURE_2D,
                B,
                0
              );
            try {
              Se(_e);
            } finally {
              V.deleteFramebuffer(_e),
                V.bindFramebuffer(V.FRAMEBUFFER, fe[--fe.length - 1] || null);
            }
          },
          ee = function () {
            (J = {}), (se = {}), (de = {}), (le = -1), (fe.length = 0);
          };
        var Me = Oe,
          ge = Ie,
          xe = rt,
          j = De,
          we = Xe,
          Ae = ee,
          ae =
            typeof WebGL2RenderingContext < "u" &&
            V instanceof WebGL2RenderingContext,
          J = {},
          se = {},
          de = {},
          le = -1,
          fe = [];
        V.canvas.addEventListener(
          "webglcontextlost",
          function (B) {
            ee(), B.preventDefault();
          },
          !1
        ),
          u.set(
            V,
            (ne = {
              gl: V,
              isWebGL2: ae,
              getExtension: Oe,
              withProgram: rt,
              withTexture: De,
              withTextureFramebuffer: Xe,
              handleContextLoss: ee,
            })
          );
      }
      F(ne);
    }
    function m(te, F, V, ne, ae, J, se, de) {
      se === void 0 && (se = 15),
        de === void 0 && (de = null),
        d(te, function (le) {
          var fe = le.gl,
            Me = le.withProgram,
            ge = le.withTexture;
          ge("copy", function (xe, j) {
            fe.texImage2D(
              fe.TEXTURE_2D,
              0,
              fe.RGBA,
              ae,
              J,
              0,
              fe.RGBA,
              fe.UNSIGNED_BYTE,
              F
            ),
              Me("copy", s, a, function (we) {
                var Ae = we.setUniform,
                  Oe = we.setAttribute;
                Oe(
                  "aUV",
                  2,
                  fe.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  Ae("1i", "image", j),
                  fe.bindFramebuffer(fe.FRAMEBUFFER, de || null),
                  fe.disable(fe.BLEND),
                  fe.colorMask(se & 8, se & 4, se & 2, se & 1),
                  fe.viewport(V, ne, ae, J),
                  fe.scissor(V, ne, ae, J),
                  fe.drawArrays(fe.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function g(te, F, V) {
      var ne = te.width,
        ae = te.height;
      d(te, function (J) {
        var se = J.gl,
          de = new Uint8Array(ne * ae * 4);
        se.readPixels(0, 0, ne, ae, se.RGBA, se.UNSIGNED_BYTE, de),
          (te.width = F),
          (te.height = V),
          m(se, de, 0, 0, ne, ae);
      });
    }
    var y = Object.freeze({
      __proto__: null,
      withWebGLContext: d,
      renderImageData: m,
      resizeWebGLCanvasWithoutClearing: g,
    });
    function x(te, F, V, ne, ae, J) {
      J === void 0 && (J = 1);
      var se = new Uint8Array(te * F),
        de = ne[2] - ne[0],
        le = ne[3] - ne[1],
        fe = [];
      o(V, function (Oe, Ie, rt, De) {
        fe.push({
          x1: Oe,
          y1: Ie,
          x2: rt,
          y2: De,
          minX: Math.min(Oe, rt),
          minY: Math.min(Ie, De),
          maxX: Math.max(Oe, rt),
          maxY: Math.max(Ie, De),
        });
      }),
        fe.sort(function (Oe, Ie) {
          return Oe.maxX - Ie.maxX;
        });
      for (var Me = 0; Me < te; Me++)
        for (var ge = 0; ge < F; ge++) {
          var xe = we(
              ne[0] + (de * (Me + 0.5)) / te,
              ne[1] + (le * (ge + 0.5)) / F
            ),
            j = Math.pow(1 - Math.abs(xe) / ae, J) / 2;
          xe < 0 && (j = 1 - j),
            (j = Math.max(0, Math.min(255, Math.round(j * 255)))),
            (se[ge * te + Me] = j);
        }
      return se;
      function we(Oe, Ie) {
        for (var rt = 1 / 0, De = 1 / 0, Xe = fe.length; Xe--; ) {
          var ee = fe[Xe];
          if (ee.maxX + De <= Oe) break;
          if (Oe + De > ee.minX && Ie - De < ee.maxY && Ie + De > ee.minY) {
            var B = w(Oe, Ie, ee.x1, ee.y1, ee.x2, ee.y2);
            B < rt && ((rt = B), (De = Math.sqrt(rt)));
          }
        }
        return Ae(Oe, Ie) && (De = -De), De;
      }
      function Ae(Oe, Ie) {
        for (var rt = 0, De = fe.length; De--; ) {
          var Xe = fe[De];
          if (Xe.maxX <= Oe) break;
          var ee =
            Xe.y1 > Ie != Xe.y2 > Ie &&
            Oe < ((Xe.x2 - Xe.x1) * (Ie - Xe.y1)) / (Xe.y2 - Xe.y1) + Xe.x1;
          ee && (rt += Xe.y1 < Xe.y2 ? 1 : -1);
        }
        return rt !== 0;
      }
    }
    function S(te, F, V, ne, ae, J, se, de, le, fe) {
      J === void 0 && (J = 1),
        de === void 0 && (de = 0),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        _(te, F, V, ne, ae, J, se, null, de, le, fe);
    }
    function _(te, F, V, ne, ae, J, se, de, le, fe, Me) {
      J === void 0 && (J = 1),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        Me === void 0 && (Me = 0);
      for (
        var ge = x(te, F, V, ne, ae, J),
          xe = new Uint8Array(ge.length * 4),
          j = 0;
        j < ge.length;
        j++
      )
        xe[j * 4 + Me] = ge[j];
      m(se, xe, le, fe, te, F, 1 << (3 - Me), de);
    }
    function w(te, F, V, ne, ae, J) {
      var se = ae - V,
        de = J - ne,
        le = se * se + de * de,
        fe = le
          ? Math.max(0, Math.min(1, ((te - V) * se + (F - ne) * de) / le))
          : 0,
        Me = te - (V + fe * se),
        ge = F - (ne + fe * de);
      return Me * Me + ge * ge;
    }
    var T = Object.freeze({
        __proto__: null,
        generate: x,
        generateIntoCanvas: S,
        generateIntoFramebuffer: _,
      }),
      M =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      A =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      R =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      D = new Float32Array([0, 0, 2, 0, 0, 2]),
      P = null,
      U = !1,
      O = {},
      L = new WeakMap();
    function H(te) {
      if (!U && !Z(te)) throw new Error("WebGL generation not supported");
    }
    function W(te, F, V, ne, ae, J, se) {
      if (
        (J === void 0 && (J = 1),
        se === void 0 && (se = null),
        !se && ((se = P), !se))
      ) {
        var de =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!de) throw new Error("OffscreenCanvas or DOM canvas not supported");
        se = P = de.getContext("webgl", { depth: !1 });
      }
      H(se);
      var le = new Uint8Array(te * F * 4);
      d(se, function (xe) {
        var j = xe.gl,
          we = xe.withTexture,
          Ae = xe.withTextureFramebuffer;
        we("readable", function (Oe, Ie) {
          j.texImage2D(
            j.TEXTURE_2D,
            0,
            j.RGBA,
            te,
            F,
            0,
            j.RGBA,
            j.UNSIGNED_BYTE,
            null
          ),
            Ae(Oe, Ie, function (rt) {
              K(te, F, V, ne, ae, J, j, rt, 0, 0, 0),
                j.readPixels(0, 0, te, F, j.RGBA, j.UNSIGNED_BYTE, le);
            });
        });
      });
      for (
        var fe = new Uint8Array(te * F), Me = 0, ge = 0;
        Me < le.length;
        Me += 4
      )
        fe[ge++] = le[Me];
      return fe;
    }
    function $(te, F, V, ne, ae, J, se, de, le, fe) {
      J === void 0 && (J = 1),
        de === void 0 && (de = 0),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        K(te, F, V, ne, ae, J, se, null, de, le, fe);
    }
    function K(te, F, V, ne, ae, J, se, de, le, fe, Me) {
      J === void 0 && (J = 1),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0),
        Me === void 0 && (Me = 0),
        H(se);
      var ge = [];
      o(V, function (xe, j, we, Ae) {
        ge.push(xe, j, we, Ae);
      }),
        (ge = new Float32Array(ge)),
        d(se, function (xe) {
          var j = xe.gl,
            we = xe.isWebGL2,
            Ae = xe.getExtension,
            Oe = xe.withProgram,
            Ie = xe.withTexture,
            rt = xe.withTextureFramebuffer,
            De = xe.handleContextLoss;
          if (
            (Ie("rawDistances", function (Xe, ee) {
              (te !== Xe._lastWidth || F !== Xe._lastHeight) &&
                j.texImage2D(
                  j.TEXTURE_2D,
                  0,
                  j.RGBA,
                  (Xe._lastWidth = te),
                  (Xe._lastHeight = F),
                  0,
                  j.RGBA,
                  j.UNSIGNED_BYTE,
                  null
                ),
                Oe("main", M, A, function (B) {
                  var ve = B.setAttribute,
                    Se = B.setUniform,
                    _e = !we && Ae("ANGLE_instanced_arrays"),
                    Te = !we && Ae("EXT_blend_minmax");
                  ve("aUV", 2, j.STATIC_DRAW, 0, D),
                    ve("aLineSegment", 4, j.DYNAMIC_DRAW, 1, ge),
                    Se.apply(void 0, ["4f", "uGlyphBounds"].concat(ne)),
                    Se("1f", "uMaxDistance", ae),
                    Se("1f", "uExponent", J),
                    rt(Xe, ee, function (at) {
                      j.enable(j.BLEND),
                        j.colorMask(!0, !0, !0, !0),
                        j.viewport(0, 0, te, F),
                        j.scissor(0, 0, te, F),
                        j.blendFunc(j.ONE, j.ONE),
                        j.blendEquationSeparate(
                          j.FUNC_ADD,
                          we ? j.MAX : Te.MAX_EXT
                        ),
                        j.clear(j.COLOR_BUFFER_BIT),
                        we
                          ? j.drawArraysInstanced(
                              j.TRIANGLES,
                              0,
                              3,
                              ge.length / 4
                            )
                          : _e.drawArraysInstancedANGLE(
                              j.TRIANGLES,
                              0,
                              3,
                              ge.length / 4
                            );
                    });
                }),
                Oe("post", s, R, function (B) {
                  B.setAttribute("aUV", 2, j.STATIC_DRAW, 0, D),
                    B.setUniform("1i", "tex", ee),
                    j.bindFramebuffer(j.FRAMEBUFFER, de),
                    j.disable(j.BLEND),
                    j.colorMask(Me === 0, Me === 1, Me === 2, Me === 3),
                    j.viewport(le, fe, te, F),
                    j.scissor(le, fe, te, F),
                    j.drawArrays(j.TRIANGLES, 0, 3);
                });
            }),
            j.isContextLost())
          )
            throw (De(), new Error("webgl context lost"));
        });
    }
    function Z(te) {
      var F = !te || te === P ? O : te.canvas || te,
        V = L.get(F);
      if (V === void 0) {
        U = !0;
        var ne = null;
        try {
          var ae = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            J = W(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, te);
          (V =
            J &&
            ae.length === J.length &&
            J.every(function (se, de) {
              return se === ae[de];
            })),
            V || ((ne = "bad trial run results"), console.info(ae, J));
        } catch (se) {
          (V = !1), (ne = se.message);
        }
        ne && console.warn("WebGL SDF generation not supported:", ne),
          (U = !1),
          L.set(F, V);
      }
      return V;
    }
    var Y = Object.freeze({
      __proto__: null,
      generate: W,
      generateIntoCanvas: $,
      generateIntoFramebuffer: K,
      isSupported: Z,
    });
    function re(te, F, V, ne, ae, J) {
      ae === void 0 && (ae = Math.max(ne[2] - ne[0], ne[3] - ne[1]) / 2),
        J === void 0 && (J = 1);
      try {
        return W.apply(Y, arguments);
      } catch (se) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", se),
          x.apply(T, arguments)
        );
      }
    }
    function G(te, F, V, ne, ae, J, se, de, le, fe) {
      ae === void 0 && (ae = Math.max(ne[2] - ne[0], ne[3] - ne[1]) / 2),
        J === void 0 && (J = 1),
        de === void 0 && (de = 0),
        le === void 0 && (le = 0),
        fe === void 0 && (fe = 0);
      try {
        return $.apply(Y, arguments);
      } catch (Me) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", Me),
          S.apply(T, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = i),
      (e.generate = re),
      (e.generateIntoCanvas = G),
      (e.javascript = T),
      (e.pathToLineSegments = o),
      (e.webgl = Y),
      (e.webglUtils = y),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
function n9() {
  var n = (function (e) {
    var t = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      r = {},
      i = {};
    (r.L = 1),
      (i[1] = "L"),
      Object.keys(t).forEach(function (De, Xe) {
        (r[De] = 1 << (Xe + 1)), (i[r[De]] = De);
      }),
      Object.freeze(r);
    var o = r.LRI | r.RLI | r.FSI,
      s = r.L | r.R | r.AL,
      a = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI,
      u = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF,
      c = r.S | r.WS | r.B | o | r.PDI | u,
      d = null;
    function m() {
      if (!d) {
        d = new Map();
        var De = function (ee) {
          if (t.hasOwnProperty(ee)) {
            var B = 0;
            t[ee].split(",").forEach(function (ve) {
              var Se = ve.split("+"),
                _e = Se[0],
                Te = Se[1];
              (_e = parseInt(_e, 36)),
                (Te = Te ? parseInt(Te, 36) : 0),
                d.set((B += _e), r[ee]);
              for (var at = 0; at < Te; at++) d.set(++B, r[ee]);
            });
          }
        };
        for (var Xe in t) De(Xe);
      }
    }
    function g(De) {
      return m(), d.get(De.codePointAt(0)) || r.L;
    }
    function y(De) {
      return i[g(De)];
    }
    var x = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function S(De, Xe) {
      var ee = 36,
        B = 0,
        ve = new Map(),
        Se = Xe && new Map(),
        _e;
      return (
        De.split(",").forEach(function Te(at) {
          if (at.indexOf("+") !== -1) for (var Fe = +at; Fe--; ) Te(_e);
          else {
            _e = at;
            var Be = at.split(">"),
              Ge = Be[0],
              Ye = Be[1];
            (Ge = String.fromCodePoint((B += parseInt(Ge, ee)))),
              (Ye = String.fromCodePoint((B += parseInt(Ye, ee)))),
              ve.set(Ge, Ye),
              Xe && Se.set(Ye, Ge);
          }
        }),
        { map: ve, reverseMap: Se }
      );
    }
    var _, w, T;
    function M() {
      if (!_) {
        var De = S(x.pairs, !0),
          Xe = De.map,
          ee = De.reverseMap;
        (_ = Xe), (w = ee), (T = S(x.canonical, !1).map);
      }
    }
    function A(De) {
      return M(), _.get(De) || null;
    }
    function R(De) {
      return M(), w.get(De) || null;
    }
    function D(De) {
      return M(), T.get(De) || null;
    }
    var P = r.L,
      U = r.R,
      O = r.EN,
      L = r.ES,
      H = r.ET,
      W = r.AN,
      $ = r.CS,
      K = r.B,
      Z = r.S,
      Y = r.ON,
      re = r.BN,
      G = r.NSM,
      te = r.AL,
      F = r.LRO,
      V = r.RLO,
      ne = r.LRE,
      ae = r.RLE,
      J = r.PDF,
      se = r.LRI,
      de = r.RLI,
      le = r.FSI,
      fe = r.PDI;
    function Me(De, Xe) {
      for (
        var ee = 125, B = new Uint32Array(De.length), ve = 0;
        ve < De.length;
        ve++
      )
        B[ve] = g(De[ve]);
      var Se = new Map();
      function _e(_r, Ir) {
        var dr = B[_r];
        (B[_r] = Ir),
          Se.set(dr, Se.get(dr) - 1),
          dr & a && Se.set(a, Se.get(a) - 1),
          Se.set(Ir, (Se.get(Ir) || 0) + 1),
          Ir & a && Se.set(a, (Se.get(a) || 0) + 1);
      }
      for (
        var Te = new Uint8Array(De.length),
          at = new Map(),
          Fe = [],
          Be = null,
          Ge = 0;
        Ge < De.length;
        Ge++
      )
        Be ||
          Fe.push(
            (Be = {
              start: Ge,
              end: De.length - 1,
              level: Xe === "rtl" ? 1 : Xe === "ltr" ? 0 : Gr(Ge, !1),
            })
          ),
          B[Ge] & K && ((Be.end = Ge), (Be = null));
      for (
        var Ye = ae | ne | V | F | o | fe | J | K,
          nt = function (_r) {
            return _r + (_r & 1 ? 1 : 2);
          },
          xt = function (_r) {
            return _r + (_r & 1 ? 2 : 1);
          },
          $e = 0;
        $e < Fe.length;
        $e++
      ) {
        Be = Fe[$e];
        var qe = [{ _level: Be.level, _override: 0, _isolate: 0 }],
          et = void 0,
          he = 0,
          Je = 0,
          me = 0;
        Se.clear();
        for (var Ve = Be.start; Ve <= Be.end; Ve++) {
          var Re = B[Ve];
          if (
            ((et = qe[qe.length - 1]),
            Se.set(Re, (Se.get(Re) || 0) + 1),
            Re & a && Se.set(a, (Se.get(a) || 0) + 1),
            Re & Ye)
          )
            if (Re & (ae | ne)) {
              Te[Ve] = et._level;
              var Ue = (Re === ae ? xt : nt)(et._level);
              Ue <= ee && !he && !Je
                ? qe.push({ _level: Ue, _override: 0, _isolate: 0 })
                : he || Je++;
            } else if (Re & (V | F)) {
              Te[Ve] = et._level;
              var it = (Re === V ? xt : nt)(et._level);
              it <= ee && !he && !Je
                ? qe.push({
                    _level: it,
                    _override: Re & V ? U : P,
                    _isolate: 0,
                  })
                : he || Je++;
            } else if (Re & o) {
              Re & le && (Re = Gr(Ve + 1, !0) === 1 ? de : se),
                (Te[Ve] = et._level),
                et._override && _e(Ve, et._override);
              var mt = (Re === de ? xt : nt)(et._level);
              mt <= ee && he === 0 && Je === 0
                ? (me++,
                  qe.push({
                    _level: mt,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: Ve,
                  }))
                : he++;
            } else if (Re & fe) {
              if (he > 0) he--;
              else if (me > 0) {
                for (Je = 0; !qe[qe.length - 1]._isolate; ) qe.pop();
                var gt = qe[qe.length - 1]._isolInitIndex;
                gt != null && (at.set(gt, Ve), at.set(Ve, gt)), qe.pop(), me--;
              }
              (et = qe[qe.length - 1]),
                (Te[Ve] = et._level),
                et._override && _e(Ve, et._override);
            } else
              Re & J
                ? (he === 0 &&
                    (Je > 0
                      ? Je--
                      : !et._isolate &&
                        qe.length > 1 &&
                        (qe.pop(), (et = qe[qe.length - 1]))),
                  (Te[Ve] = et._level))
                : Re & K && (Te[Ve] = Be.level);
          else
            (Te[Ve] = et._level),
              et._override && Re !== re && _e(Ve, et._override);
        }
        for (var Nt = [], Ut = null, ht = Be.start; ht <= Be.end; ht++) {
          var $t = B[ht];
          if (!($t & u)) {
            var un = Te[ht],
              bn = $t & o,
              yn = $t === fe;
            Ut && un === Ut._level
              ? ((Ut._end = ht), (Ut._endsWithIsolInit = bn))
              : Nt.push(
                  (Ut = {
                    _start: ht,
                    _end: ht,
                    _level: un,
                    _startsWithPDI: yn,
                    _endsWithIsolInit: bn,
                  })
                );
          }
        }
        for (var cr = [], Hi = 0; Hi < Nt.length; Hi++) {
          var yr = Nt[Hi];
          if (!yr._startsWithPDI || (yr._startsWithPDI && !at.has(yr._start))) {
            for (
              var Fr = [(Ut = yr)], Ar = void 0;
              Ut && Ut._endsWithIsolInit && (Ar = at.get(Ut._end)) != null;

            )
              for (var Br = Hi + 1; Br < Nt.length; Br++)
                if (Nt[Br]._start === Ar) {
                  Fr.push((Ut = Nt[Br]));
                  break;
                }
            for (var xr = [], So = 0; So < Fr.length; So++)
              for (var ql = Fr[So], oo = ql._start; oo <= ql._end; oo++)
                xr.push(oo);
            for (
              var Kl = Te[xr[0]], ie = Be.level, Ce = xr[0] - 1;
              Ce >= 0;
              Ce--
            )
              if (!(B[Ce] & u)) {
                ie = Te[Ce];
                break;
              }
            var ze = xr[xr.length - 1],
              We = Te[ze],
              Le = Be.level;
            if (!(B[ze] & o)) {
              for (var ut = ze + 1; ut <= Be.end; ut++)
                if (!(B[ut] & u)) {
                  Le = Te[ut];
                  break;
                }
            }
            cr.push({
              _seqIndices: xr,
              _sosType: Math.max(ie, Kl) % 2 ? U : P,
              _eosType: Math.max(Le, We) % 2 ? U : P,
            });
          }
        }
        for (var yt = 0; yt < cr.length; yt++) {
          var Et = cr[yt],
            Ke = Et._seqIndices,
            kt = Et._sosType,
            Ft = Et._eosType,
            At = Te[Ke[0]] & 1 ? U : P;
          if (Se.get(G))
            for (var tn = 0; tn < Ke.length; tn++) {
              var An = Ke[tn];
              if (B[An] & G) {
                for (var pn = kt, Mn = tn - 1; Mn >= 0; Mn--)
                  if (!(B[Ke[Mn]] & u)) {
                    pn = B[Ke[Mn]];
                    break;
                  }
                _e(An, pn & (o | fe) ? Y : pn);
              }
            }
          if (Se.get(O))
            for (var wt = 0; wt < Ke.length; wt++) {
              var dt = Ke[wt];
              if (B[dt] & O)
                for (var Jt = wt - 1; Jt >= -1; Jt--) {
                  var zt = Jt === -1 ? kt : B[Ke[Jt]];
                  if (zt & s) {
                    zt === te && _e(dt, W);
                    break;
                  }
                }
            }
          if (Se.get(te))
            for (var En = 0; En < Ke.length; En++) {
              var ii = Ke[En];
              B[ii] & te && _e(ii, U);
            }
          if (Se.get(L) || Se.get($))
            for (var Rn = 1; Rn < Ke.length - 1; Rn++) {
              var jn = Ke[Rn];
              if (B[jn] & (L | $)) {
                for (
                  var cn = 0, zr = 0, ds = Rn - 1;
                  ds >= 0 && ((cn = B[Ke[ds]]), !!(cn & u));
                  ds--
                );
                for (
                  var fr = Rn + 1;
                  fr < Ke.length && ((zr = B[Ke[fr]]), !!(zr & u));
                  fr++
                );
                cn === zr &&
                  (B[jn] === L ? cn === O : cn & (O | W)) &&
                  _e(jn, cn);
              }
            }
          if (Se.get(O))
            for (var Rr = 0; Rr < Ke.length; Rr++) {
              var pi = Ke[Rr];
              if (B[pi] & O) {
                for (var Wo = Rr - 1; Wo >= 0 && B[Ke[Wo]] & (H | u); Wo--)
                  _e(Ke[Wo], O);
                for (Rr++; Rr < Ke.length && B[Ke[Rr]] & (H | u | O); Rr++)
                  B[Ke[Rr]] !== O && _e(Ke[Rr], O);
              }
            }
          if (Se.get(H) || Se.get(L) || Se.get($))
            for (var Go = 0; Go < Ke.length; Go++) {
              var Uf = Ke[Go];
              if (B[Uf] & (H | L | $)) {
                _e(Uf, Y);
                for (var jo = Go - 1; jo >= 0 && B[Ke[jo]] & u; jo--)
                  _e(Ke[jo], Y);
                for (var ln = Go + 1; ln < Ke.length && B[Ke[ln]] & u; ln++)
                  _e(Ke[ln], Y);
              }
            }
          if (Se.get(O))
            for (var hs = 0, ya = kt; hs < Ke.length; hs++) {
              var Zl = Ke[hs],
                Jl = B[Zl];
              Jl & O ? ya === P && _e(Zl, P) : Jl & s && (ya = Jl);
            }
          if (Se.get(a)) {
            var ps = U | O | W,
              rl = ps | P,
              wo = [];
            {
              for (var $o = [], oi = 0; oi < Ke.length; oi++)
                if (B[Ke[oi]] & a) {
                  var Xt = De[Ke[oi]],
                    bo = void 0;
                  if (A(Xt) !== null)
                    if ($o.length < 63) $o.push({ char: Xt, seqIndex: oi });
                    else break;
                  else if ((bo = R(Xt)) !== null)
                    for (var so = $o.length - 1; so >= 0; so--) {
                      var ms = $o[so].char;
                      if (ms === bo || ms === R(D(Xt)) || A(D(ms)) === Xt) {
                        wo.push([$o[so].seqIndex, oi]), ($o.length = so);
                        break;
                      }
                    }
                }
              wo.sort(function (_r, Ir) {
                return _r[0] - Ir[0];
              });
            }
            for (var Mo = 0; Mo < wo.length; Mo++) {
              for (
                var Ff = wo[Mo],
                  qn = Ff[0],
                  Xo = Ff[1],
                  Bf = !1,
                  mi = 0,
                  xa = qn + 1;
                xa < Xo;
                xa++
              ) {
                var _a = Ke[xa];
                if (B[_a] & rl) {
                  Bf = !0;
                  var ao = B[_a] & ps ? U : P;
                  if (ao === At) {
                    mi = ao;
                    break;
                  }
                }
              }
              if (Bf && !mi) {
                mi = kt;
                for (var Ns = qn - 1; Ns >= 0; Ns--) {
                  var Sa = Ke[Ns];
                  if (B[Sa] & rl) {
                    var Hr = B[Sa] & ps ? U : P;
                    Hr !== At ? (mi = Hr) : (mi = At);
                    break;
                  }
                }
              }
              if (mi) {
                if (((B[Ke[qn]] = B[Ke[Xo]] = mi), mi !== At)) {
                  for (var Vr = qn + 1; Vr < Ke.length; Vr++)
                    if (!(B[Ke[Vr]] & u)) {
                      g(De[Ke[Vr]]) & G && (B[Ke[Vr]] = mi);
                      break;
                    }
                }
                if (mi !== At) {
                  for (var gs = Xo + 1; gs < Ke.length; gs++)
                    if (!(B[Ke[gs]] & u)) {
                      g(De[Ke[gs]]) & G && (B[Ke[gs]] = mi);
                      break;
                    }
                }
              }
            }
            for (var Eo = 0; Eo < Ke.length; Eo++)
              if (B[Ke[Eo]] & a) {
                for (var il = Eo, wa = Eo, gi = kt, ba = Eo - 1; ba >= 0; ba--)
                  if (B[Ke[ba]] & u) il = ba;
                  else {
                    gi = B[Ke[ba]] & ps ? U : P;
                    break;
                  }
                for (var Vi = Ft, Us = Eo + 1; Us < Ke.length; Us++)
                  if (B[Ke[Us]] & (a | u)) wa = Us;
                  else {
                    Vi = B[Ke[Us]] & ps ? U : P;
                    break;
                  }
                for (var Wr = il; Wr <= wa; Wr++)
                  B[Ke[Wr]] = gi === Vi ? gi : At;
                Eo = wa;
              }
          }
        }
        for (var Pr = Be.start; Pr <= Be.end; Pr++) {
          var Fs = Te[Pr],
            Wi = B[Pr];
          if (
            (Fs & 1
              ? Wi & (P | O | W) && Te[Pr]++
              : Wi & U
              ? Te[Pr]++
              : Wi & (W | O) && (Te[Pr] += 2),
            Wi & u && (Te[Pr] = Pr === 0 ? Be.level : Te[Pr - 1]),
            Pr === Be.end || g(De[Pr]) & (Z | K))
          )
            for (var Bs = Pr; Bs >= 0 && g(De[Bs]) & c; Bs--) Te[Bs] = Be.level;
        }
      }
      return { levels: Te, paragraphs: Fe };
      function Gr(_r, Ir) {
        for (var dr = _r; dr < De.length; dr++) {
          var tr = B[dr];
          if (tr & (U | te)) return 1;
          if (tr & (K | P) || (Ir && tr === fe)) return 0;
          if (tr & o) {
            var bi = zs(dr);
            dr = bi === -1 ? De.length : bi;
          }
        }
        return 0;
      }
      function zs(_r) {
        for (var Ir = 1, dr = _r + 1; dr < De.length; dr++) {
          var tr = B[dr];
          if (tr & K) break;
          if (tr & fe) {
            if (--Ir === 0) return dr;
          } else tr & o && Ir++;
        }
        return -1;
      }
    }
    var ge =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      xe;
    function j() {
      if (!xe) {
        var De = S(ge, !0),
          Xe = De.map,
          ee = De.reverseMap;
        ee.forEach(function (B, ve) {
          Xe.set(ve, B);
        }),
          (xe = Xe);
      }
    }
    function we(De) {
      return j(), xe.get(De) || null;
    }
    function Ae(De, Xe, ee, B) {
      var ve = De.length;
      (ee = Math.max(0, ee == null ? 0 : +ee)),
        (B = Math.min(ve - 1, B == null ? ve - 1 : +B));
      for (var Se = new Map(), _e = ee; _e <= B; _e++)
        if (Xe[_e] & 1) {
          var Te = we(De[_e]);
          Te !== null && Se.set(_e, Te);
        }
      return Se;
    }
    function Oe(De, Xe, ee, B) {
      var ve = De.length;
      (ee = Math.max(0, ee == null ? 0 : +ee)),
        (B = Math.min(ve - 1, B == null ? ve - 1 : +B));
      var Se = [];
      return (
        Xe.paragraphs.forEach(function (_e) {
          var Te = Math.max(ee, _e.start),
            at = Math.min(B, _e.end);
          if (Te < at) {
            for (
              var Fe = Xe.levels.slice(Te, at + 1), Be = at;
              Be >= Te && g(De[Be]) & c;
              Be--
            )
              Fe[Be] = _e.level;
            for (var Ge = _e.level, Ye = 1 / 0, nt = 0; nt < Fe.length; nt++) {
              var xt = Fe[nt];
              xt > Ge && (Ge = xt), xt < Ye && (Ye = xt | 1);
            }
            for (var $e = Ge; $e >= Ye; $e--)
              for (var qe = 0; qe < Fe.length; qe++)
                if (Fe[qe] >= $e) {
                  for (var et = qe; qe + 1 < Fe.length && Fe[qe + 1] >= $e; )
                    qe++;
                  qe > et && Se.push([et + Te, qe + Te]);
                }
          }
        }),
        Se
      );
    }
    function Ie(De, Xe, ee, B) {
      var ve = rt(De, Xe, ee, B),
        Se = [].concat(De);
      return (
        ve.forEach(function (_e, Te) {
          Se[Te] = (Xe.levels[_e] & 1 ? we(De[_e]) : null) || De[_e];
        }),
        Se.join("")
      );
    }
    function rt(De, Xe, ee, B) {
      for (var ve = Oe(De, Xe, ee, B), Se = [], _e = 0; _e < De.length; _e++)
        Se[_e] = _e;
      return (
        ve.forEach(function (Te) {
          for (
            var at = Te[0],
              Fe = Te[1],
              Be = Se.slice(at, Fe + 1),
              Ge = Be.length;
            Ge--;

          )
            Se[Fe - Ge] = Be[Ge];
        }),
        Se
      );
    }
    return (
      (e.closingToOpeningBracket = R),
      (e.getBidiCharType = g),
      (e.getBidiCharTypeName = y),
      (e.getCanonicalBracket = D),
      (e.getEmbeddingLevels = Me),
      (e.getMirroredCharacter = we),
      (e.getMirroredCharactersMap = Ae),
      (e.getReorderSegments = Oe),
      (e.getReorderedIndices = rt),
      (e.getReorderedString = Ie),
      (e.openingToClosingBracket = A),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
const e3 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function PS(n) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, i) {
    let o = rn[i];
    return o ? PS(o) : r;
  }
  return n.replace(e, t);
}
const Ni = [];
for (let n = 0; n < 256; n++) Ni[n] = (n < 16 ? "0" : "") + n.toString(16);
function r9() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Ni[n & 255] +
    Ni[(n >> 8) & 255] +
    Ni[(n >> 16) & 255] +
    Ni[(n >> 24) & 255] +
    "-" +
    Ni[e & 255] +
    Ni[(e >> 8) & 255] +
    "-" +
    Ni[((e >> 16) & 15) | 64] +
    Ni[(e >> 24) & 255] +
    "-" +
    Ni[(t & 63) | 128] +
    Ni[(t >> 8) & 255] +
    "-" +
    Ni[(t >> 16) & 255] +
    Ni[(t >> 24) & 255] +
    Ni[r & 255] +
    Ni[(r >> 8) & 255] +
    Ni[(r >> 16) & 255] +
    Ni[(r >> 24) & 255]
  ).toUpperCase();
}
const Zc =
    Object.assign ||
    function () {
      let n = arguments[0];
      for (let e = 1, t = arguments.length; e < t; e++) {
        let r = arguments[e];
        if (r)
          for (let i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }
      return n;
    },
  i9 = Date.now(),
  N2 = new WeakMap(),
  U2 = new Map();
let o9 = 1e10;
function IS(n, e) {
  const t = u9(e);
  let r = N2.get(n);
  if ((r || N2.set(n, (r = Object.create(null))), r[t])) return new r[t]();
  const i = `_onBeforeCompile${t}`,
    o = function (c, d) {
      n.onBeforeCompile.call(this, c, d);
      const m =
        this.customProgramCacheKey() +
        "|" +
        c.vertexShader +
        "|" +
        c.fragmentShader;
      let g = U2[m];
      if (!g) {
        const y = s9(this, c, e, t);
        g = U2[m] = y;
      }
      (c.vertexShader = g.vertexShader),
        (c.fragmentShader = g.fragmentShader),
        Zc(c.uniforms, this.uniforms),
        e.timeUniform &&
          (c.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - i9;
            },
          }),
        this[i] && this[i](c);
    },
    s = function () {
      return a(e.chained ? n : n.clone());
    },
    a = function (c) {
      const d = Object.create(c, u);
      return (
        Object.defineProperty(d, "baseMaterial", { value: n }),
        Object.defineProperty(d, "id", { value: o9++ }),
        (d.uuid = r9()),
        (d.uniforms = Zc({}, c.uniforms, e.uniforms)),
        (d.defines = Zc({}, c.defines, e.defines)),
        (d.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = ""),
        (d.extensions = Zc({}, c.extensions, e.extensions)),
        (d._listeners = void 0),
        d
      );
    },
    u = {
      constructor: { value: s },
      isDerivedMaterial: { value: !0 },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return n.customProgramCacheKey() + "|" + t;
        },
      },
      onBeforeCompile: {
        get() {
          return o;
        },
        set(c) {
          this[i] = c;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (c) {
          return (
            n.copy.call(this, c),
            !n.isShaderMaterial &&
              !n.isDerivedMaterial &&
              (Zc(this.extensions, c.extensions),
              Zc(this.defines, c.defines),
              Zc(this.uniforms, $m.clone(c.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const c = new n.constructor();
          return a(c).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._depthMaterial;
          return (
            c ||
              ((c = this._depthMaterial =
                IS(
                  n.isDerivedMaterial
                    ? n.getDepthMaterial()
                    : new tx({ depthPacking: Pw }),
                  e
                )),
              (c.defines.IS_DEPTH_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._distanceMaterial;
          return (
            c ||
              ((c = this._distanceMaterial =
                IS(
                  n.isDerivedMaterial ? n.getDistanceMaterial() : new nx(),
                  e
                )),
              (c.defines.IS_DISTANCE_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: c, _distanceMaterial: d } = this;
          c && c.dispose(), d && d.dispose(), n.dispose.call(this);
        },
      },
    };
  return (r[t] = s), new s();
}
function s9(n, { vertexShader: e, fragmentShader: t }, r, i) {
  let {
    vertexDefs: o,
    vertexMainIntro: s,
    vertexMainOutro: a,
    vertexTransform: u,
    fragmentDefs: c,
    fragmentMainIntro: d,
    fragmentMainOutro: m,
    fragmentColorTransform: g,
    customRewriter: y,
    timeUniform: x,
  } = r;
  if (
    ((o = o || ""),
    (s = s || ""),
    (a = a || ""),
    (c = c || ""),
    (d = d || ""),
    (m = m || ""),
    (u || y) && (e = PS(e)),
    (g || y) &&
      ((t = t.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (t = PS(t))),
    y)
  ) {
    let S = y({ vertexShader: e, fragmentShader: t });
    (e = S.vertexShader), (t = S.fragmentShader);
  }
  if (g) {
    let S = [];
    (t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (_) => (S.push(_), "")
    )),
      (m = `${g}
${S.join(`
`)}
${m}`);
  }
  if (x) {
    const S = `
uniform float ${x};
`;
    (o = S + o), (c = S + c);
  }
  return (
    u &&
      ((e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`),
      (o = `${o}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u}
}
`),
      (s = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${s}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (S, _, w, T) =>
        /\battribute\s+vec[23]\s+$/.test(T.substr(0, w))
          ? _
          : `troika_${_}_${i}`
      )),
      (n.map && n.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    (e = F2(e, i, o, s, a)),
    (t = F2(t, i, c, d, m)),
    { vertexShader: e, fragmentShader: t }
  );
}
function F2(n, e, t, r, i) {
  return (
    (r || i || t) &&
      ((n = n.replace(
        e3,
        `
${t}
void troikaOrigMain${e}() {`
      )),
      (n += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`)),
    n
  );
}
function a9(n, e) {
  return n === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let l9 = 0;
const B2 = new Map();
function u9(n) {
  const e = JSON.stringify(n, a9);
  let t = B2.get(e);
  return t == null && B2.set(e, (t = ++l9)), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function c9() {
  return (
    typeof window > "u" && (self.window = self),
    (function (n) {
      var e = {
        parse: function (i) {
          var o = e._bin,
            s = new Uint8Array(i);
          if (o.readASCII(s, 0, 4) == "ttcf") {
            var a = 4;
            o.readUshort(s, a), (a += 2), o.readUshort(s, a), (a += 2);
            var u = o.readUint(s, a);
            a += 4;
            for (var c = [], d = 0; d < u; d++) {
              var m = o.readUint(s, a);
              (a += 4), c.push(e._readFont(s, m));
            }
            return c;
          }
          return [e._readFont(s, 0)];
        },
        _readFont: function (i, o) {
          var s = e._bin,
            a = o;
          s.readFixed(i, o), (o += 4);
          var u = s.readUshort(i, o);
          (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2);
          for (
            var c = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              d = { _data: i, _offset: a },
              m = {},
              g = 0;
            g < u;
            g++
          ) {
            var y = s.readASCII(i, o, 4);
            (o += 4), s.readUint(i, o), (o += 4);
            var x = s.readUint(i, o);
            o += 4;
            var S = s.readUint(i, o);
            (o += 4), (m[y] = { offset: x, length: S });
          }
          for (g = 0; g < c.length; g++) {
            var _ = c[g];
            m[_] &&
              (d[_.trim()] = e[_.trim()].parse(i, m[_].offset, m[_].length, d));
          }
          return d;
        },
        _tabOffset: function (i, o, s) {
          for (
            var a = e._bin, u = a.readUshort(i, s + 4), c = s + 12, d = 0;
            d < u;
            d++
          ) {
            var m = a.readASCII(i, c, 4);
            (c += 4), a.readUint(i, c), (c += 4);
            var g = a.readUint(i, c);
            if (((c += 4), a.readUint(i, c), (c += 4), m == o)) return g;
          }
          return 0;
        },
      };
      (e._bin = {
        readFixed: function (i, o) {
          return (
            ((i[o] << 8) | i[o + 1]) + ((i[o + 2] << 8) | i[o + 3]) / 65540
          );
        },
        readF2dot14: function (i, o) {
          return e._bin.readShort(i, o) / 16384;
        },
        readInt: function (i, o) {
          return e._bin._view(i).getInt32(o);
        },
        readInt8: function (i, o) {
          return e._bin._view(i).getInt8(o);
        },
        readShort: function (i, o) {
          return e._bin._view(i).getInt16(o);
        },
        readUshort: function (i, o) {
          return e._bin._view(i).getUint16(o);
        },
        readUshorts: function (i, o, s) {
          for (var a = [], u = 0; u < s; u++)
            a.push(e._bin.readUshort(i, o + 2 * u));
          return a;
        },
        readUint: function (i, o) {
          return e._bin._view(i).getUint32(o);
        },
        readUint64: function (i, o) {
          return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4);
        },
        readASCII: function (i, o, s) {
          for (var a = "", u = 0; u < s; u++)
            a += String.fromCharCode(i[o + u]);
          return a;
        },
        readUnicode: function (i, o, s) {
          for (var a = "", u = 0; u < s; u++) {
            var c = (i[o++] << 8) | i[o++];
            a += String.fromCharCode(c);
          }
          return a;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (i, o, s) {
          var a = e._bin._tdec;
          return a && o == 0 && s == i.length
            ? a.decode(i)
            : e._bin.readASCII(i, o, s);
        },
        readBytes: function (i, o, s) {
          for (var a = [], u = 0; u < s; u++) a.push(i[o + u]);
          return a;
        },
        readASCIIArray: function (i, o, s) {
          for (var a = [], u = 0; u < s; u++)
            a.push(String.fromCharCode(i[o + u]));
          return a;
        },
        _view: function (i) {
          return (
            i._dataView ||
            (i._dataView = i.buffer
              ? new DataView(i.buffer, i.byteOffset, i.byteLength)
              : new DataView(new Uint8Array(i).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (i, o, s, a, u) {
          var c = e._bin,
            d = {},
            m = o;
          c.readFixed(i, o), (o += 4);
          var g = c.readUshort(i, o);
          o += 2;
          var y = c.readUshort(i, o);
          o += 2;
          var x = c.readUshort(i, o);
          return (
            (o += 2),
            (d.scriptList = e._lctf.readScriptList(i, m + g)),
            (d.featureList = e._lctf.readFeatureList(i, m + y)),
            (d.lookupList = e._lctf.readLookupList(i, m + x, u)),
            d
          );
        }),
        (e._lctf.readLookupList = function (i, o, s) {
          var a = e._bin,
            u = o,
            c = [],
            d = a.readUshort(i, o);
          o += 2;
          for (var m = 0; m < d; m++) {
            var g = a.readUshort(i, o);
            o += 2;
            var y = e._lctf.readLookupTable(i, u + g, s);
            c.push(y);
          }
          return c;
        }),
        (e._lctf.readLookupTable = function (i, o, s) {
          var a = e._bin,
            u = o,
            c = { tabs: [] };
          (c.ltype = a.readUshort(i, o)),
            (o += 2),
            (c.flag = a.readUshort(i, o)),
            (o += 2);
          var d = a.readUshort(i, o);
          o += 2;
          for (var m = c.ltype, g = 0; g < d; g++) {
            var y = a.readUshort(i, o);
            o += 2;
            var x = s(i, m, u + y, c);
            c.tabs.push(x);
          }
          return c;
        }),
        (e._lctf.numOfOnes = function (i) {
          for (var o = 0, s = 0; s < 32; s++) ((i >>> s) & 1) != 0 && o++;
          return o;
        }),
        (e._lctf.readClassDef = function (i, o) {
          var s = e._bin,
            a = [],
            u = s.readUshort(i, o);
          if (((o += 2), u == 1)) {
            var c = s.readUshort(i, o);
            o += 2;
            var d = s.readUshort(i, o);
            o += 2;
            for (var m = 0; m < d; m++)
              a.push(c + m),
                a.push(c + m),
                a.push(s.readUshort(i, o)),
                (o += 2);
          }
          if (u == 2) {
            var g = s.readUshort(i, o);
            for (o += 2, m = 0; m < g; m++)
              a.push(s.readUshort(i, o)),
                (o += 2),
                a.push(s.readUshort(i, o)),
                (o += 2),
                a.push(s.readUshort(i, o)),
                (o += 2);
          }
          return a;
        }),
        (e._lctf.getInterval = function (i, o) {
          for (var s = 0; s < i.length; s += 3) {
            var a = i[s],
              u = i[s + 1];
            if ((i[s + 2], a <= o && o <= u)) return s;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (i, o) {
          var s = e._bin,
            a = {};
          (a.fmt = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          return (
            (o += 2),
            a.fmt == 1 && (a.tab = s.readUshorts(i, o, u)),
            a.fmt == 2 && (a.tab = s.readUshorts(i, o, 3 * u)),
            a
          );
        }),
        (e._lctf.coverageIndex = function (i, o) {
          var s = i.tab;
          if (i.fmt == 1) return s.indexOf(o);
          if (i.fmt == 2) {
            var a = e._lctf.getInterval(s, o);
            if (a != -1) return s[a + 2] + (o - s[a]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (i, o) {
          var s = e._bin,
            a = o,
            u = [],
            c = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < c; d++) {
            var m = s.readASCII(i, o, 4);
            o += 4;
            var g = s.readUshort(i, o);
            o += 2;
            var y = e._lctf.readFeatureTable(i, a + g);
            (y.tag = m.trim()), u.push(y);
          }
          return u;
        }),
        (e._lctf.readFeatureTable = function (i, o) {
          var s = e._bin,
            a = o,
            u = {},
            c = s.readUshort(i, o);
          (o += 2), c > 0 && (u.featureParams = a + c);
          var d = s.readUshort(i, o);
          (o += 2), (u.tab = []);
          for (var m = 0; m < d; m++) u.tab.push(s.readUshort(i, o + 2 * m));
          return u;
        }),
        (e._lctf.readScriptList = function (i, o) {
          var s = e._bin,
            a = o,
            u = {},
            c = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < c; d++) {
            var m = s.readASCII(i, o, 4);
            o += 4;
            var g = s.readUshort(i, o);
            (o += 2), (u[m.trim()] = e._lctf.readScriptTable(i, a + g));
          }
          return u;
        }),
        (e._lctf.readScriptTable = function (i, o) {
          var s = e._bin,
            a = o,
            u = {},
            c = s.readUshort(i, o);
          (o += 2), c > 0 && (u.default = e._lctf.readLangSysTable(i, a + c));
          var d = s.readUshort(i, o);
          o += 2;
          for (var m = 0; m < d; m++) {
            var g = s.readASCII(i, o, 4);
            o += 4;
            var y = s.readUshort(i, o);
            (o += 2), (u[g.trim()] = e._lctf.readLangSysTable(i, a + y));
          }
          return u;
        }),
        (e._lctf.readLangSysTable = function (i, o) {
          var s = e._bin,
            a = {};
          s.readUshort(i, o),
            (o += 2),
            (a.reqFeature = s.readUshort(i, o)),
            (o += 2);
          var u = s.readUshort(i, o);
          return (o += 2), (a.features = s.readUshorts(i, o, u)), a;
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (i, o, s) {
          var a = e._bin;
          (i = new Uint8Array(i.buffer, o, s))[(o = 0)],
            i[++o],
            i[++o],
            i[++o],
            o++;
          var u = [];
          o = e.CFF.readIndex(i, o, u);
          for (var c = [], d = 0; d < u.length - 1; d++)
            c.push(a.readASCII(i, o + u[d], u[d + 1] - u[d]));
          o += u[u.length - 1];
          var m = [];
          o = e.CFF.readIndex(i, o, m);
          var g = [];
          for (d = 0; d < m.length - 1; d++)
            g.push(e.CFF.readDict(i, o + m[d], o + m[d + 1]));
          o += m[m.length - 1];
          var y = g[0],
            x = [];
          o = e.CFF.readIndex(i, o, x);
          var S = [];
          for (d = 0; d < x.length - 1; d++)
            S.push(a.readASCII(i, o + x[d], x[d + 1] - x[d]));
          if (
            ((o += x[x.length - 1]), e.CFF.readSubrs(i, o, y), y.CharStrings)
          ) {
            (o = y.CharStrings), (x = []), (o = e.CFF.readIndex(i, o, x));
            var _ = [];
            for (d = 0; d < x.length - 1; d++)
              _.push(a.readBytes(i, o + x[d], x[d + 1] - x[d]));
            y.CharStrings = _;
          }
          if (y.ROS) {
            o = y.FDArray;
            var w = [];
            for (
              o = e.CFF.readIndex(i, o, w), y.FDArray = [], d = 0;
              d < w.length - 1;
              d++
            ) {
              var T = e.CFF.readDict(i, o + w[d], o + w[d + 1]);
              e.CFF._readFDict(i, T, S), y.FDArray.push(T);
            }
            (o += w[w.length - 1]), (o = y.FDSelect), (y.FDSelect = []);
            var M = i[o];
            if ((o++, M != 3)) throw M;
            var A = a.readUshort(i, o);
            for (o += 2, d = 0; d < A + 1; d++)
              y.FDSelect.push(a.readUshort(i, o), i[o + 2]), (o += 3);
          }
          return (
            y.Encoding &&
              (y.Encoding = e.CFF.readEncoding(
                i,
                y.Encoding,
                y.CharStrings.length
              )),
            y.charset &&
              (y.charset = e.CFF.readCharset(
                i,
                y.charset,
                y.CharStrings.length
              )),
            e.CFF._readFDict(i, y, S),
            y
          );
        }),
        (e.CFF._readFDict = function (i, o, s) {
          var a;
          for (var u in (o.Private &&
            ((a = o.Private[1]),
            (o.Private = e.CFF.readDict(i, a, a + o.Private[0])),
            o.Private.Subrs &&
              e.CFF.readSubrs(i, a + o.Private.Subrs, o.Private)),
          o))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(u) != -1 && (o[u] = s[o[u] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (i, o, s) {
          var a = e._bin,
            u = [];
          o = e.CFF.readIndex(i, o, u);
          var c,
            d = u.length;
          (c = d < 1240 ? 107 : d < 33900 ? 1131 : 32768),
            (s.Bias = c),
            (s.Subrs = []);
          for (var m = 0; m < u.length - 1; m++)
            s.Subrs.push(a.readBytes(i, o + u[m], u[m + 1] - u[m]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (i, o) {
          for (var s = 0; s < i.charset.length; s++)
            if (i.charset[s] == o) return s;
          return -1;
        }),
        (e.CFF.glyphBySE = function (i, o) {
          return o < 0 || o > 255
            ? -1
            : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]);
        }),
        (e.CFF.readEncoding = function (i, o, s) {
          e._bin;
          var a = [".notdef"],
            u = i[o];
          if ((o++, u != 0)) throw "error: unknown encoding format: " + u;
          var c = i[o];
          o++;
          for (var d = 0; d < c; d++) a.push(i[o + d]);
          return a;
        }),
        (e.CFF.readCharset = function (i, o, s) {
          var a = e._bin,
            u = [".notdef"],
            c = i[o];
          if ((o++, c == 0))
            for (var d = 0; d < s; d++) {
              var m = a.readUshort(i, o);
              (o += 2), u.push(m);
            }
          else {
            if (c != 1 && c != 2) throw "error: format: " + c;
            for (; u.length < s; ) {
              (m = a.readUshort(i, o)), (o += 2);
              var g = 0;
              for (
                c == 1
                  ? ((g = i[o]), o++)
                  : ((g = a.readUshort(i, o)), (o += 2)),
                  d = 0;
                d <= g;
                d++
              )
                u.push(m), m++;
            }
          }
          return u;
        }),
        (e.CFF.readIndex = function (i, o, s) {
          var a = e._bin,
            u = a.readUshort(i, o) + 1,
            c = i[(o += 2)];
          if ((o++, c == 1)) for (var d = 0; d < u; d++) s.push(i[o + d]);
          else if (c == 2)
            for (d = 0; d < u; d++) s.push(a.readUshort(i, o + 2 * d));
          else if (c == 3)
            for (d = 0; d < u; d++)
              s.push(16777215 & a.readUint(i, o + 3 * d - 1));
          else if (u != 1)
            throw "unsupported offset size: " + c + ", count: " + u;
          return (o += u * c) - 1;
        }),
        (e.CFF.getCharString = function (i, o, s) {
          var a = e._bin,
            u = i[o],
            c = i[o + 1];
          i[o + 2], i[o + 3], i[o + 4];
          var d = 1,
            m = null,
            g = null;
          u <= 20 && ((m = u), (d = 1)),
            u == 12 && ((m = 100 * u + c), (d = 2)),
            21 <= u && u <= 27 && ((m = u), (d = 1)),
            u == 28 && ((g = a.readShort(i, o + 1)), (d = 3)),
            29 <= u && u <= 31 && ((m = u), (d = 1)),
            32 <= u && u <= 246 && ((g = u - 139), (d = 1)),
            247 <= u && u <= 250 && ((g = 256 * (u - 247) + c + 108), (d = 2)),
            251 <= u && u <= 254 && ((g = 256 * -(u - 251) - c - 108), (d = 2)),
            u == 255 && ((g = a.readInt(i, o + 1) / 65535), (d = 5)),
            (s.val = g ?? "o" + m),
            (s.size = d);
        }),
        (e.CFF.readCharString = function (i, o, s) {
          for (var a = o + s, u = e._bin, c = []; o < a; ) {
            var d = i[o],
              m = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var g = 1,
              y = null,
              x = null;
            d <= 20 && ((y = d), (g = 1)),
              d == 12 && ((y = 100 * d + m), (g = 2)),
              (d != 19 && d != 20) || ((y = d), (g = 2)),
              21 <= d && d <= 27 && ((y = d), (g = 1)),
              d == 28 && ((x = u.readShort(i, o + 1)), (g = 3)),
              29 <= d && d <= 31 && ((y = d), (g = 1)),
              32 <= d && d <= 246 && ((x = d - 139), (g = 1)),
              247 <= d &&
                d <= 250 &&
                ((x = 256 * (d - 247) + m + 108), (g = 2)),
              251 <= d &&
                d <= 254 &&
                ((x = 256 * -(d - 251) - m - 108), (g = 2)),
              d == 255 && ((x = u.readInt(i, o + 1) / 65535), (g = 5)),
              c.push(x ?? "o" + y),
              (o += g);
          }
          return c;
        }),
        (e.CFF.readDict = function (i, o, s) {
          for (var a = e._bin, u = {}, c = []; o < s; ) {
            var d = i[o],
              m = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var g = 1,
              y = null,
              x = null;
            if (
              (d == 28 && ((x = a.readShort(i, o + 1)), (g = 3)),
              d == 29 && ((x = a.readInt(i, o + 1)), (g = 5)),
              32 <= d && d <= 246 && ((x = d - 139), (g = 1)),
              247 <= d &&
                d <= 250 &&
                ((x = 256 * (d - 247) + m + 108), (g = 2)),
              251 <= d &&
                d <= 254 &&
                ((x = 256 * -(d - 251) - m - 108), (g = 2)),
              d == 255)
            )
              throw (
                ((x = a.readInt(i, o + 1) / 65535), (g = 5), "unknown number")
              );
            if (d == 30) {
              var S = [];
              for (g = 1; ; ) {
                var _ = i[o + g];
                g++;
                var w = _ >> 4,
                  T = 15 & _;
                if ((w != 15 && S.push(w), T != 15 && S.push(T), T == 15))
                  break;
              }
              for (
                var M = "",
                  A = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  R = 0;
                R < S.length;
                R++
              )
                M += A[S[R]];
              x = parseFloat(M);
            }
            d <= 21 &&
              ((y = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][d]),
              (g = 1),
              d == 12 &&
                ((y = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][m]),
                (g = 2))),
              y != null
                ? ((u[y] = c.length == 1 ? c[0] : c), (c = []))
                : c.push(x),
              (o += g);
          }
          return u;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (i, o, s) {
          (i = new Uint8Array(i.buffer, o, s)), (o = 0);
          var a = e._bin,
            u = {};
          a.readUshort(i, o), (o += 2);
          var c = a.readUshort(i, o);
          o += 2;
          var d = [];
          u.tables = [];
          for (var m = 0; m < c; m++) {
            var g = a.readUshort(i, o);
            o += 2;
            var y = a.readUshort(i, o);
            o += 2;
            var x = a.readUint(i, o);
            o += 4;
            var S = "p" + g + "e" + y,
              _ = d.indexOf(x);
            if (_ == -1) {
              var w;
              (_ = u.tables.length), d.push(x);
              var T = a.readUshort(i, x);
              T == 0
                ? (w = e.cmap.parse0(i, x))
                : T == 4
                ? (w = e.cmap.parse4(i, x))
                : T == 6
                ? (w = e.cmap.parse6(i, x))
                : T == 12
                ? (w = e.cmap.parse12(i, x))
                : console.debug("unknown format: " + T, g, y, x),
                u.tables.push(w);
            }
            if (u[S] != null) throw "multiple tables for one platform+encoding";
            u[S] = _;
          }
          return u;
        }),
        (e.cmap.parse0 = function (i, o) {
          var s = e._bin,
            a = {};
          (a.format = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2), (a.map = []);
          for (var c = 0; c < u - 6; c++) a.map.push(i[o + c]);
          return a;
        }),
        (e.cmap.parse4 = function (i, o) {
          var s = e._bin,
            a = o,
            u = {};
          (u.format = s.readUshort(i, o)), (o += 2);
          var c = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2);
          var d = s.readUshort(i, o);
          o += 2;
          var m = d / 2;
          (u.searchRange = s.readUshort(i, o)),
            (o += 2),
            (u.entrySelector = s.readUshort(i, o)),
            (o += 2),
            (u.rangeShift = s.readUshort(i, o)),
            (o += 2),
            (u.endCount = s.readUshorts(i, o, m)),
            (o += 2 * m),
            (o += 2),
            (u.startCount = s.readUshorts(i, o, m)),
            (o += 2 * m),
            (u.idDelta = []);
          for (var g = 0; g < m; g++)
            u.idDelta.push(s.readShort(i, o)), (o += 2);
          for (
            u.idRangeOffset = s.readUshorts(i, o, m),
              o += 2 * m,
              u.glyphIdArray = [];
            o < a + c;

          )
            u.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return u;
        }),
        (e.cmap.parse6 = function (i, o) {
          var s = e._bin,
            a = {};
          (a.format = s.readUshort(i, o)),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            (a.firstCode = s.readUshort(i, o)),
            (o += 2);
          var u = s.readUshort(i, o);
          (o += 2), (a.glyphIdArray = []);
          for (var c = 0; c < u; c++)
            a.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return a;
        }),
        (e.cmap.parse12 = function (i, o) {
          var s = e._bin,
            a = {};
          (a.format = s.readUshort(i, o)),
            (o += 2),
            (o += 2),
            s.readUint(i, o),
            (o += 4),
            s.readUint(i, o),
            (o += 4);
          var u = s.readUint(i, o);
          (o += 4), (a.groups = []);
          for (var c = 0; c < u; c++) {
            var d = o + 12 * c,
              m = s.readUint(i, d + 0),
              g = s.readUint(i, d + 4),
              y = s.readUint(i, d + 8);
            a.groups.push([m, g, y]);
          }
          return a;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (i, o, s, a) {
          for (var u = [], c = 0; c < a.maxp.numGlyphs; c++) u.push(null);
          return u;
        }),
        (e.glyf._parseGlyf = function (i, o) {
          var s = e._bin,
            a = i._data,
            u = e._tabOffset(a, "glyf", i._offset) + i.loca[o];
          if (i.loca[o] == i.loca[o + 1]) return null;
          var c = {};
          if (
            ((c.noc = s.readShort(a, u)),
            (u += 2),
            (c.xMin = s.readShort(a, u)),
            (u += 2),
            (c.yMin = s.readShort(a, u)),
            (u += 2),
            (c.xMax = s.readShort(a, u)),
            (u += 2),
            (c.yMax = s.readShort(a, u)),
            (u += 2),
            c.xMin >= c.xMax || c.yMin >= c.yMax)
          )
            return null;
          if (c.noc > 0) {
            c.endPts = [];
            for (var d = 0; d < c.noc; d++)
              c.endPts.push(s.readUshort(a, u)), (u += 2);
            var m = s.readUshort(a, u);
            if (((u += 2), a.length - u < m)) return null;
            (c.instructions = s.readBytes(a, u, m)), (u += m);
            var g = c.endPts[c.noc - 1] + 1;
            for (c.flags = [], d = 0; d < g; d++) {
              var y = a[u];
              if ((u++, c.flags.push(y), (8 & y) != 0)) {
                var x = a[u];
                u++;
                for (var S = 0; S < x; S++) c.flags.push(y), d++;
              }
            }
            for (c.xs = [], d = 0; d < g; d++) {
              var _ = (2 & c.flags[d]) != 0,
                w = (16 & c.flags[d]) != 0;
              _
                ? (c.xs.push(w ? a[u] : -a[u]), u++)
                : w
                ? c.xs.push(0)
                : (c.xs.push(s.readShort(a, u)), (u += 2));
            }
            for (c.ys = [], d = 0; d < g; d++)
              (_ = (4 & c.flags[d]) != 0),
                (w = (32 & c.flags[d]) != 0),
                _
                  ? (c.ys.push(w ? a[u] : -a[u]), u++)
                  : w
                  ? c.ys.push(0)
                  : (c.ys.push(s.readShort(a, u)), (u += 2));
            var T = 0,
              M = 0;
            for (d = 0; d < g; d++)
              (T += c.xs[d]), (M += c.ys[d]), (c.xs[d] = T), (c.ys[d] = M);
          } else {
            var A;
            c.parts = [];
            do {
              (A = s.readUshort(a, u)), (u += 2);
              var R = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (c.parts.push(R),
                (R.glyphIndex = s.readUshort(a, u)),
                (u += 2),
                1 & A)
              ) {
                var D = s.readShort(a, u);
                u += 2;
                var P = s.readShort(a, u);
                u += 2;
              } else (D = s.readInt8(a, u)), u++, (P = s.readInt8(a, u)), u++;
              2 & A ? ((R.m.tx = D), (R.m.ty = P)) : ((R.p1 = D), (R.p2 = P)),
                8 & A
                  ? ((R.m.a = R.m.d = s.readF2dot14(a, u)), (u += 2))
                  : 64 & A
                  ? ((R.m.a = s.readF2dot14(a, u)),
                    (u += 2),
                    (R.m.d = s.readF2dot14(a, u)),
                    (u += 2))
                  : 128 & A &&
                    ((R.m.a = s.readF2dot14(a, u)),
                    (u += 2),
                    (R.m.b = s.readF2dot14(a, u)),
                    (u += 2),
                    (R.m.c = s.readF2dot14(a, u)),
                    (u += 2),
                    (R.m.d = s.readF2dot14(a, u)),
                    (u += 2));
            } while (32 & A);
            if (256 & A) {
              var U = s.readUshort(a, u);
              for (u += 2, c.instr = [], d = 0; d < U; d++)
                c.instr.push(a[u]), u++;
            }
          }
          return c;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (i, o, s, a) {
          var u = o;
          o += 4;
          var c = e._bin.readUshort(i, o);
          return {
            glyphClassDef: c === 0 ? null : e._lctf.readClassDef(i, u + c),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (i, o, s, a) {
          return e._lctf.parse(i, o, s, a, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (i, o, s, a) {
          var u = e._bin,
            c = s,
            d = {};
          if (
            ((d.fmt = u.readUshort(i, s)),
            (s += 2),
            o == 1 || o == 2 || o == 3 || o == 7 || (o == 8 && d.fmt <= 2))
          ) {
            var m = u.readUshort(i, s);
            (s += 2), (d.coverage = e._lctf.readCoverage(i, m + c));
          }
          if (o == 1 && d.fmt == 1) {
            var g = u.readUshort(i, s);
            (s += 2), g != 0 && (d.pos = e.GPOS.readValueRecord(i, s, g));
          } else if (o == 2 && d.fmt >= 1 && d.fmt <= 2) {
            (g = u.readUshort(i, s)), (s += 2);
            var y = u.readUshort(i, s);
            s += 2;
            var x = e._lctf.numOfOnes(g),
              S = e._lctf.numOfOnes(y);
            if (d.fmt == 1) {
              d.pairsets = [];
              var _ = u.readUshort(i, s);
              s += 2;
              for (var w = 0; w < _; w++) {
                var T = c + u.readUshort(i, s);
                s += 2;
                var M = u.readUshort(i, T);
                T += 2;
                for (var A = [], R = 0; R < M; R++) {
                  var D = u.readUshort(i, T);
                  (T += 2),
                    g != 0 &&
                      ((W = e.GPOS.readValueRecord(i, T, g)), (T += 2 * x)),
                    y != 0 &&
                      (($ = e.GPOS.readValueRecord(i, T, y)), (T += 2 * S)),
                    A.push({ gid2: D, val1: W, val2: $ });
                }
                d.pairsets.push(A);
              }
            }
            if (d.fmt == 2) {
              var P = u.readUshort(i, s);
              s += 2;
              var U = u.readUshort(i, s);
              s += 2;
              var O = u.readUshort(i, s);
              s += 2;
              var L = u.readUshort(i, s);
              for (
                s += 2,
                  d.classDef1 = e._lctf.readClassDef(i, c + P),
                  d.classDef2 = e._lctf.readClassDef(i, c + U),
                  d.matrix = [],
                  w = 0;
                w < O;
                w++
              ) {
                var H = [];
                for (R = 0; R < L; R++) {
                  var W = null,
                    $ = null;
                  g != 0 &&
                    ((W = e.GPOS.readValueRecord(i, s, g)), (s += 2 * x)),
                    y != 0 &&
                      (($ = e.GPOS.readValueRecord(i, s, y)), (s += 2 * S)),
                    H.push({ val1: W, val2: $ });
                }
                d.matrix.push(H);
              }
            }
          } else if (o == 4 && d.fmt == 1)
            (d.markCoverage = e._lctf.readCoverage(i, u.readUshort(i, s) + c)),
              (d.baseCoverage = e._lctf.readCoverage(
                i,
                u.readUshort(i, s + 2) + c
              )),
              (d.markClassCount = u.readUshort(i, s + 4)),
              (d.markArray = e.GPOS.readMarkArray(
                i,
                u.readUshort(i, s + 6) + c
              )),
              (d.baseArray = e.GPOS.readBaseArray(
                i,
                u.readUshort(i, s + 8) + c,
                d.markClassCount
              ));
          else if (o == 6 && d.fmt == 1)
            (d.mark1Coverage = e._lctf.readCoverage(i, u.readUshort(i, s) + c)),
              (d.mark2Coverage = e._lctf.readCoverage(
                i,
                u.readUshort(i, s + 2) + c
              )),
              (d.markClassCount = u.readUshort(i, s + 4)),
              (d.mark1Array = e.GPOS.readMarkArray(
                i,
                u.readUshort(i, s + 6) + c
              )),
              (d.mark2Array = e.GPOS.readBaseArray(
                i,
                u.readUshort(i, s + 8) + c,
                d.markClassCount
              ));
          else {
            if (o == 9 && d.fmt == 1) {
              var K = u.readUshort(i, s);
              s += 2;
              var Z = u.readUint(i, s);
              if (((s += 4), a.ltype == 9)) a.ltype = K;
              else if (a.ltype != K) throw "invalid extension substitution";
              return e.GPOS.subt(i, a.ltype, c + Z);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              o,
              "format",
              d.fmt
            );
          }
          return d;
        }),
        (e.GPOS.readValueRecord = function (i, o, s) {
          var a = e._bin,
            u = [];
          return (
            u.push(1 & s ? a.readShort(i, o) : 0),
            (o += 1 & s ? 2 : 0),
            u.push(2 & s ? a.readShort(i, o) : 0),
            (o += 2 & s ? 2 : 0),
            u.push(4 & s ? a.readShort(i, o) : 0),
            (o += 4 & s ? 2 : 0),
            u.push(8 & s ? a.readShort(i, o) : 0),
            (o += 8 & s ? 2 : 0),
            u
          );
        }),
        (e.GPOS.readBaseArray = function (i, o, s) {
          var a = e._bin,
            u = [],
            c = o,
            d = a.readUshort(i, o);
          o += 2;
          for (var m = 0; m < d; m++) {
            for (var g = [], y = 0; y < s; y++)
              g.push(e.GPOS.readAnchorRecord(i, c + a.readUshort(i, o))),
                (o += 2);
            u.push(g);
          }
          return u;
        }),
        (e.GPOS.readMarkArray = function (i, o) {
          var s = e._bin,
            a = [],
            u = o,
            c = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < c; d++) {
            var m = e.GPOS.readAnchorRecord(i, s.readUshort(i, o + 2) + u);
            (m.markClass = s.readUshort(i, o)), a.push(m), (o += 4);
          }
          return a;
        }),
        (e.GPOS.readAnchorRecord = function (i, o) {
          var s = e._bin,
            a = {};
          return (
            (a.fmt = s.readUshort(i, o)),
            (a.x = s.readShort(i, o + 2)),
            (a.y = s.readShort(i, o + 4)),
            a
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (i, o, s, a) {
          return e._lctf.parse(i, o, s, a, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (i, o, s, a) {
          var u = e._bin,
            c = s,
            d = {};
          if (
            ((d.fmt = u.readUshort(i, s)),
            (s += 2),
            o != 1 && o != 2 && o != 4 && o != 5 && o != 6)
          )
            return null;
          if (
            o == 1 ||
            o == 2 ||
            o == 4 ||
            (o == 5 && d.fmt <= 2) ||
            (o == 6 && d.fmt <= 2)
          ) {
            var m = u.readUshort(i, s);
            (s += 2), (d.coverage = e._lctf.readCoverage(i, c + m));
          }
          if (o == 1 && d.fmt >= 1 && d.fmt <= 2) {
            if (d.fmt == 1) (d.delta = u.readShort(i, s)), (s += 2);
            else if (d.fmt == 2) {
              var g = u.readUshort(i, s);
              (s += 2),
                (d.newg = u.readUshorts(i, s, g)),
                (s += 2 * d.newg.length);
            }
          } else if (o == 2 && d.fmt == 1) {
            (g = u.readUshort(i, s)), (s += 2), (d.seqs = []);
            for (var y = 0; y < g; y++) {
              var x = u.readUshort(i, s) + c;
              s += 2;
              var S = u.readUshort(i, x);
              d.seqs.push(u.readUshorts(i, x + 2, S));
            }
          } else if (o == 4)
            for (
              d.vals = [], g = u.readUshort(i, s), s += 2, y = 0;
              y < g;
              y++
            ) {
              var _ = u.readUshort(i, s);
              (s += 2), d.vals.push(e.GSUB.readLigatureSet(i, c + _));
            }
          else if (o == 5 && d.fmt == 2) {
            if (d.fmt == 2) {
              var w = u.readUshort(i, s);
              (s += 2),
                (d.cDef = e._lctf.readClassDef(i, c + w)),
                (d.scset = []);
              var T = u.readUshort(i, s);
              for (s += 2, y = 0; y < T; y++) {
                var M = u.readUshort(i, s);
                (s += 2),
                  d.scset.push(
                    M == 0 ? null : e.GSUB.readSubClassSet(i, c + M)
                  );
              }
            }
          } else if (o == 6 && d.fmt == 3) {
            if (d.fmt == 3) {
              for (y = 0; y < 3; y++) {
                (g = u.readUshort(i, s)), (s += 2);
                for (var A = [], R = 0; R < g; R++)
                  A.push(
                    e._lctf.readCoverage(i, c + u.readUshort(i, s + 2 * R))
                  );
                (s += 2 * g),
                  y == 0 && (d.backCvg = A),
                  y == 1 && (d.inptCvg = A),
                  y == 2 && (d.ahedCvg = A);
              }
              (g = u.readUshort(i, s)),
                (s += 2),
                (d.lookupRec = e.GSUB.readSubstLookupRecords(i, s, g));
            }
          } else {
            if (o == 7 && d.fmt == 1) {
              var D = u.readUshort(i, s);
              s += 2;
              var P = u.readUint(i, s);
              if (((s += 4), a.ltype == 9)) a.ltype = D;
              else if (a.ltype != D) throw "invalid extension substitution";
              return e.GSUB.subt(i, a.ltype, c + P);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              o,
              "format",
              d.fmt
            );
          }
          return d;
        }),
        (e.GSUB.readSubClassSet = function (i, o) {
          var s = e._bin.readUshort,
            a = o,
            u = [],
            c = s(i, o);
          o += 2;
          for (var d = 0; d < c; d++) {
            var m = s(i, o);
            (o += 2), u.push(e.GSUB.readSubClassRule(i, a + m));
          }
          return u;
        }),
        (e.GSUB.readSubClassRule = function (i, o) {
          var s = e._bin.readUshort,
            a = {},
            u = s(i, o),
            c = s(i, (o += 2));
          (o += 2), (a.input = []);
          for (var d = 0; d < u - 1; d++) a.input.push(s(i, o)), (o += 2);
          return (
            (a.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, c)), a
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (i, o, s) {
          for (var a = e._bin.readUshort, u = [], c = 0; c < s; c++)
            u.push(a(i, o), a(i, o + 2)), (o += 4);
          return u;
        }),
        (e.GSUB.readChainSubClassSet = function (i, o) {
          var s = e._bin,
            a = o,
            u = [],
            c = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < c; d++) {
            var m = s.readUshort(i, o);
            (o += 2), u.push(e.GSUB.readChainSubClassRule(i, a + m));
          }
          return u;
        }),
        (e.GSUB.readChainSubClassRule = function (i, o) {
          for (
            var s = e._bin,
              a = {},
              u = ["backtrack", "input", "lookahead"],
              c = 0;
            c < u.length;
            c++
          ) {
            var d = s.readUshort(i, o);
            (o += 2),
              c == 1 && d--,
              (a[u[c]] = s.readUshorts(i, o, d)),
              (o += 2 * a[u[c]].length);
          }
          return (
            (d = s.readUshort(i, o)),
            (o += 2),
            (a.subst = s.readUshorts(i, o, 2 * d)),
            (o += 2 * a.subst.length),
            a
          );
        }),
        (e.GSUB.readLigatureSet = function (i, o) {
          var s = e._bin,
            a = o,
            u = [],
            c = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < c; d++) {
            var m = s.readUshort(i, o);
            (o += 2), u.push(e.GSUB.readLigature(i, a + m));
          }
          return u;
        }),
        (e.GSUB.readLigature = function (i, o) {
          var s = e._bin,
            a = { chain: [] };
          (a.nglyph = s.readUshort(i, o)), (o += 2);
          var u = s.readUshort(i, o);
          o += 2;
          for (var c = 0; c < u - 1; c++)
            a.chain.push(s.readUshort(i, o)), (o += 2);
          return a;
        }),
        (e.head = {}),
        (e.head.parse = function (i, o, s) {
          var a = e._bin,
            u = {};
          return (
            a.readFixed(i, o),
            (o += 4),
            (u.fontRevision = a.readFixed(i, o)),
            (o += 4),
            a.readUint(i, o),
            (o += 4),
            a.readUint(i, o),
            (o += 4),
            (u.flags = a.readUshort(i, o)),
            (o += 2),
            (u.unitsPerEm = a.readUshort(i, o)),
            (o += 2),
            (u.created = a.readUint64(i, o)),
            (o += 8),
            (u.modified = a.readUint64(i, o)),
            (o += 8),
            (u.xMin = a.readShort(i, o)),
            (o += 2),
            (u.yMin = a.readShort(i, o)),
            (o += 2),
            (u.xMax = a.readShort(i, o)),
            (o += 2),
            (u.yMax = a.readShort(i, o)),
            (o += 2),
            (u.macStyle = a.readUshort(i, o)),
            (o += 2),
            (u.lowestRecPPEM = a.readUshort(i, o)),
            (o += 2),
            (u.fontDirectionHint = a.readShort(i, o)),
            (o += 2),
            (u.indexToLocFormat = a.readShort(i, o)),
            (o += 2),
            (u.glyphDataFormat = a.readShort(i, o)),
            (o += 2),
            u
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (i, o, s) {
          var a = e._bin,
            u = {};
          return (
            a.readFixed(i, o),
            (o += 4),
            (u.ascender = a.readShort(i, o)),
            (o += 2),
            (u.descender = a.readShort(i, o)),
            (o += 2),
            (u.lineGap = a.readShort(i, o)),
            (o += 2),
            (u.advanceWidthMax = a.readUshort(i, o)),
            (o += 2),
            (u.minLeftSideBearing = a.readShort(i, o)),
            (o += 2),
            (u.minRightSideBearing = a.readShort(i, o)),
            (o += 2),
            (u.xMaxExtent = a.readShort(i, o)),
            (o += 2),
            (u.caretSlopeRise = a.readShort(i, o)),
            (o += 2),
            (u.caretSlopeRun = a.readShort(i, o)),
            (o += 2),
            (u.caretOffset = a.readShort(i, o)),
            (o += 2),
            (o += 8),
            (u.metricDataFormat = a.readShort(i, o)),
            (o += 2),
            (u.numberOfHMetrics = a.readUshort(i, o)),
            (o += 2),
            u
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (i, o, s, a) {
          for (
            var u = e._bin,
              c = { aWidth: [], lsBearing: [] },
              d = 0,
              m = 0,
              g = 0;
            g < a.maxp.numGlyphs;
            g++
          )
            g < a.hhea.numberOfHMetrics &&
              ((d = u.readUshort(i, o)),
              (o += 2),
              (m = u.readShort(i, o)),
              (o += 2)),
              c.aWidth.push(d),
              c.lsBearing.push(m);
          return c;
        }),
        (e.kern = {}),
        (e.kern.parse = function (i, o, s, a) {
          var u = e._bin,
            c = u.readUshort(i, o);
          if (((o += 2), c == 1)) return e.kern.parseV1(i, o - 2, s, a);
          var d = u.readUshort(i, o);
          o += 2;
          for (var m = { glyph1: [], rval: [] }, g = 0; g < d; g++) {
            (o += 2), (s = u.readUshort(i, o)), (o += 2);
            var y = u.readUshort(i, o);
            o += 2;
            var x = y >>> 8;
            if ((x &= 15) != 0) throw "unknown kern table format: " + x;
            o = e.kern.readFormat0(i, o, m);
          }
          return m;
        }),
        (e.kern.parseV1 = function (i, o, s, a) {
          var u = e._bin;
          u.readFixed(i, o), (o += 4);
          var c = u.readUint(i, o);
          o += 4;
          for (var d = { glyph1: [], rval: [] }, m = 0; m < c; m++) {
            u.readUint(i, o), (o += 4);
            var g = u.readUshort(i, o);
            (o += 2), u.readUshort(i, o), (o += 2);
            var y = g >>> 8;
            if ((y &= 15) != 0) throw "unknown kern table format: " + y;
            o = e.kern.readFormat0(i, o, d);
          }
          return d;
        }),
        (e.kern.readFormat0 = function (i, o, s) {
          var a = e._bin,
            u = -1,
            c = a.readUshort(i, o);
          (o += 2),
            a.readUshort(i, o),
            (o += 2),
            a.readUshort(i, o),
            (o += 2),
            a.readUshort(i, o),
            (o += 2);
          for (var d = 0; d < c; d++) {
            var m = a.readUshort(i, o);
            o += 2;
            var g = a.readUshort(i, o);
            o += 2;
            var y = a.readShort(i, o);
            (o += 2),
              m != u &&
                (s.glyph1.push(m), s.rval.push({ glyph2: [], vals: [] }));
            var x = s.rval[s.rval.length - 1];
            x.glyph2.push(g), x.vals.push(y), (u = m);
          }
          return o;
        }),
        (e.loca = {}),
        (e.loca.parse = function (i, o, s, a) {
          var u = e._bin,
            c = [],
            d = a.head.indexToLocFormat,
            m = a.maxp.numGlyphs + 1;
          if (d == 0)
            for (var g = 0; g < m; g++)
              c.push(u.readUshort(i, o + (g << 1)) << 1);
          if (d == 1)
            for (g = 0; g < m; g++) c.push(u.readUint(i, o + (g << 2)));
          return c;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (i, o, s) {
          var a = e._bin,
            u = {},
            c = a.readUint(i, o);
          return (
            (o += 4),
            (u.numGlyphs = a.readUshort(i, o)),
            (o += 2),
            c == 65536 &&
              ((u.maxPoints = a.readUshort(i, o)),
              (o += 2),
              (u.maxContours = a.readUshort(i, o)),
              (o += 2),
              (u.maxCompositePoints = a.readUshort(i, o)),
              (o += 2),
              (u.maxCompositeContours = a.readUshort(i, o)),
              (o += 2),
              (u.maxZones = a.readUshort(i, o)),
              (o += 2),
              (u.maxTwilightPoints = a.readUshort(i, o)),
              (o += 2),
              (u.maxStorage = a.readUshort(i, o)),
              (o += 2),
              (u.maxFunctionDefs = a.readUshort(i, o)),
              (o += 2),
              (u.maxInstructionDefs = a.readUshort(i, o)),
              (o += 2),
              (u.maxStackElements = a.readUshort(i, o)),
              (o += 2),
              (u.maxSizeOfInstructions = a.readUshort(i, o)),
              (o += 2),
              (u.maxComponentElements = a.readUshort(i, o)),
              (o += 2),
              (u.maxComponentDepth = a.readUshort(i, o)),
              (o += 2)),
            u
          );
        }),
        (e.name = {}),
        (e.name.parse = function (i, o, s) {
          var a = e._bin,
            u = {};
          a.readUshort(i, o), (o += 2);
          var c = a.readUshort(i, o);
          (o += 2), a.readUshort(i, o);
          for (
            var d,
              m = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              g = (o += 2),
              y = 0;
            y < c;
            y++
          ) {
            var x = a.readUshort(i, o);
            o += 2;
            var S = a.readUshort(i, o);
            o += 2;
            var _ = a.readUshort(i, o);
            o += 2;
            var w = a.readUshort(i, o);
            o += 2;
            var T = a.readUshort(i, o);
            o += 2;
            var M = a.readUshort(i, o);
            o += 2;
            var A,
              R = m[w],
              D = g + 12 * c + M;
            if (x == 0) A = a.readUnicode(i, D, T / 2);
            else if (x == 3 && S == 0) A = a.readUnicode(i, D, T / 2);
            else if (S == 0) A = a.readASCII(i, D, T);
            else if (S == 1) A = a.readUnicode(i, D, T / 2);
            else if (S == 3) A = a.readUnicode(i, D, T / 2);
            else {
              if (x != 1) throw "unknown encoding " + S + ", platformID: " + x;
              (A = a.readASCII(i, D, T)),
                console.debug(
                  "reading unknown MAC encoding " + S + " as ASCII"
                );
            }
            var P = "p" + x + "," + _.toString(16);
            u[P] == null && (u[P] = {}),
              (u[P][R !== void 0 ? R : w] = A),
              (u[P]._lang = _);
          }
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 1033) return u[U];
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 0) return u[U];
          for (var U in u)
            if (u[U].postScriptName != null && u[U]._lang == 3084) return u[U];
          for (var U in u) if (u[U].postScriptName != null) return u[U];
          for (var U in u) {
            d = U;
            break;
          }
          return (
            console.debug("returning name table with languageID " + u[d]._lang),
            u[d]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (i, o, s) {
          var a = e._bin.readUshort(i, o);
          o += 2;
          var u = {};
          if (a == 0) e["OS/2"].version0(i, o, u);
          else if (a == 1) e["OS/2"].version1(i, o, u);
          else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(i, o, u);
          else {
            if (a != 5) throw "unknown OS/2 table version: " + a;
            e["OS/2"].version5(i, o, u);
          }
          return u;
        }),
        (e["OS/2"].version0 = function (i, o, s) {
          var a = e._bin;
          return (
            (s.xAvgCharWidth = a.readShort(i, o)),
            (o += 2),
            (s.usWeightClass = a.readUshort(i, o)),
            (o += 2),
            (s.usWidthClass = a.readUshort(i, o)),
            (o += 2),
            (s.fsType = a.readUshort(i, o)),
            (o += 2),
            (s.ySubscriptXSize = a.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYSize = a.readShort(i, o)),
            (o += 2),
            (s.ySubscriptXOffset = a.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYOffset = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXSize = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYSize = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXOffset = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYOffset = a.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutSize = a.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutPosition = a.readShort(i, o)),
            (o += 2),
            (s.sFamilyClass = a.readShort(i, o)),
            (o += 2),
            (s.panose = a.readBytes(i, o, 10)),
            (o += 10),
            (s.ulUnicodeRange1 = a.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange2 = a.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange3 = a.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange4 = a.readUint(i, o)),
            (o += 4),
            (s.achVendID = [
              a.readInt8(i, o),
              a.readInt8(i, o + 1),
              a.readInt8(i, o + 2),
              a.readInt8(i, o + 3),
            ]),
            (o += 4),
            (s.fsSelection = a.readUshort(i, o)),
            (o += 2),
            (s.usFirstCharIndex = a.readUshort(i, o)),
            (o += 2),
            (s.usLastCharIndex = a.readUshort(i, o)),
            (o += 2),
            (s.sTypoAscender = a.readShort(i, o)),
            (o += 2),
            (s.sTypoDescender = a.readShort(i, o)),
            (o += 2),
            (s.sTypoLineGap = a.readShort(i, o)),
            (o += 2),
            (s.usWinAscent = a.readUshort(i, o)),
            (o += 2),
            (s.usWinDescent = a.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version1 = function (i, o, s) {
          var a = e._bin;
          return (
            (o = e["OS/2"].version0(i, o, s)),
            (s.ulCodePageRange1 = a.readUint(i, o)),
            (o += 4),
            (s.ulCodePageRange2 = a.readUint(i, o)),
            (o += 4)
          );
        }),
        (e["OS/2"].version2 = function (i, o, s) {
          var a = e._bin;
          return (
            (o = e["OS/2"].version1(i, o, s)),
            (s.sxHeight = a.readShort(i, o)),
            (o += 2),
            (s.sCapHeight = a.readShort(i, o)),
            (o += 2),
            (s.usDefault = a.readUshort(i, o)),
            (o += 2),
            (s.usBreak = a.readUshort(i, o)),
            (o += 2),
            (s.usMaxContext = a.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version5 = function (i, o, s) {
          var a = e._bin;
          return (
            (o = e["OS/2"].version2(i, o, s)),
            (s.usLowerOpticalPointSize = a.readUshort(i, o)),
            (o += 2),
            (s.usUpperOpticalPointSize = a.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (i, o, s) {
          var a = e._bin,
            u = {};
          return (
            (u.version = a.readFixed(i, o)),
            (o += 4),
            (u.italicAngle = a.readFixed(i, o)),
            (o += 4),
            (u.underlinePosition = a.readShort(i, o)),
            (o += 2),
            (u.underlineThickness = a.readShort(i, o)),
            (o += 2),
            u
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (i, o) {
          var s = i.cmap,
            a = -1;
          if (
            (s.p0e4 != null
              ? (a = s.p0e4)
              : s.p3e1 != null
              ? (a = s.p3e1)
              : s.p1e0 != null
              ? (a = s.p1e0)
              : s.p0e3 != null && (a = s.p0e3),
            a == -1)
          )
            throw "no familiar platform and encoding!";
          var u = s.tables[a];
          if (u.format == 0) return o >= u.map.length ? 0 : u.map[o];
          if (u.format == 4) {
            for (var c = -1, d = 0; d < u.endCount.length; d++)
              if (o <= u.endCount[d]) {
                c = d;
                break;
              }
            return c == -1 || u.startCount[c] > o
              ? 0
              : 65535 &
                  (u.idRangeOffset[c] != 0
                    ? u.glyphIdArray[
                        o -
                          u.startCount[c] +
                          (u.idRangeOffset[c] >> 1) -
                          (u.idRangeOffset.length - c)
                      ]
                    : o + u.idDelta[c]);
          }
          if (u.format == 12) {
            if (o > u.groups[u.groups.length - 1][1]) return 0;
            for (d = 0; d < u.groups.length; d++) {
              var m = u.groups[d];
              if (m[0] <= o && o <= m[1]) return m[2] + (o - m[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + u.format;
        }),
        (e.U.glyphToPath = function (i, o) {
          var s = { cmds: [], crds: [] };
          if (i.SVG && i.SVG.entries[o]) {
            var a = i.SVG.entries[o];
            return a == null
              ? s
              : (typeof a == "string" &&
                  ((a = e.SVG.toPath(a)), (i.SVG.entries[o] = a)),
                a);
          }
          if (i.CFF) {
            var u = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              c = i.CFF,
              d = i.CFF.Private;
            if (c.ROS) {
              for (var m = 0; c.FDSelect[m + 2] <= o; ) m += 2;
              d = c.FDArray[c.FDSelect[m + 1]].Private;
            }
            e.U._drawCFF(i.CFF.CharStrings[o], u, c, d, s);
          } else i.glyf && e.U._drawGlyf(o, i, s);
          return s;
        }),
        (e.U._drawGlyf = function (i, o, s) {
          var a = o.glyf[i];
          a == null && (a = o.glyf[i] = e.glyf._parseGlyf(o, i)),
            a != null &&
              (a.noc > -1 ? e.U._simpleGlyph(a, s) : e.U._compoGlyph(a, o, s));
        }),
        (e.U._simpleGlyph = function (i, o) {
          for (var s = 0; s < i.noc; s++) {
            for (
              var a = s == 0 ? 0 : i.endPts[s - 1] + 1, u = i.endPts[s], c = a;
              c <= u;
              c++
            ) {
              var d = c == a ? u : c - 1,
                m = c == u ? a : c + 1,
                g = 1 & i.flags[c],
                y = 1 & i.flags[d],
                x = 1 & i.flags[m],
                S = i.xs[c],
                _ = i.ys[c];
              if (c == a)
                if (g) {
                  if (!y) {
                    e.U.P.moveTo(o, S, _);
                    continue;
                  }
                  e.U.P.moveTo(o, i.xs[d], i.ys[d]);
                } else
                  y
                    ? e.U.P.moveTo(o, i.xs[d], i.ys[d])
                    : e.U.P.moveTo(o, (i.xs[d] + S) / 2, (i.ys[d] + _) / 2);
              g
                ? y && e.U.P.lineTo(o, S, _)
                : x
                ? e.U.P.qcurveTo(o, S, _, i.xs[m], i.ys[m])
                : e.U.P.qcurveTo(o, S, _, (S + i.xs[m]) / 2, (_ + i.ys[m]) / 2);
            }
            e.U.P.closePath(o);
          }
        }),
        (e.U._compoGlyph = function (i, o, s) {
          for (var a = 0; a < i.parts.length; a++) {
            var u = { cmds: [], crds: [] },
              c = i.parts[a];
            e.U._drawGlyf(c.glyphIndex, o, u);
            for (var d = c.m, m = 0; m < u.crds.length; m += 2) {
              var g = u.crds[m],
                y = u.crds[m + 1];
              s.crds.push(g * d.a + y * d.b + d.tx),
                s.crds.push(g * d.c + y * d.d + d.ty);
            }
            for (m = 0; m < u.cmds.length; m++) s.cmds.push(u.cmds[m]);
          }
        }),
        (e.U._getGlyphClass = function (i, o) {
          var s = e._lctf.getInterval(o, i);
          return s == -1 ? 0 : o[s + 2];
        }),
        (e.U._applySubs = function (i, o, s, a) {
          for (var u = i.length - o - 1, c = 0; c < s.tabs.length; c++)
            if (s.tabs[c] != null) {
              var d,
                m = s.tabs[c];
              if (
                !m.coverage ||
                (d = e._lctf.coverageIndex(m.coverage, i[o])) != -1
              ) {
                if (s.ltype == 1)
                  i[o],
                    m.fmt == 1 ? (i[o] = i[o] + m.delta) : (i[o] = m.newg[d]);
                else if (s.ltype == 4)
                  for (var g = m.vals[d], y = 0; y < g.length; y++) {
                    var x = g[y],
                      S = x.chain.length;
                    if (!(S > u)) {
                      for (var _ = !0, w = 0, T = 0; T < S; T++) {
                        for (; i[o + w + (1 + T)] == -1; ) w++;
                        x.chain[T] != i[o + w + (1 + T)] && (_ = !1);
                      }
                      if (_) {
                        for (i[o] = x.nglyph, T = 0; T < S + w; T++)
                          i[o + T + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (s.ltype == 5 && m.fmt == 2)
                  for (
                    var M = e._lctf.getInterval(m.cDef, i[o]),
                      A = m.cDef[M + 2],
                      R = m.scset[A],
                      D = 0;
                    D < R.length;
                    D++
                  ) {
                    var P = R[D],
                      U = P.input;
                    if (!(U.length > u)) {
                      for (_ = !0, T = 0; T < U.length; T++) {
                        var O = e._lctf.getInterval(m.cDef, i[o + 1 + T]);
                        if (M == -1 && m.cDef[O + 2] != U[T]) {
                          _ = !1;
                          break;
                        }
                      }
                      if (_) {
                        var L = P.substLookupRecords;
                        for (y = 0; y < L.length; y += 2) L[y], L[y + 1];
                      }
                    }
                  }
                else if (s.ltype == 6 && m.fmt == 3) {
                  if (
                    !e.U._glsCovered(i, m.backCvg, o - m.backCvg.length) ||
                    !e.U._glsCovered(i, m.inptCvg, o) ||
                    !e.U._glsCovered(i, m.ahedCvg, o + m.inptCvg.length)
                  )
                    continue;
                  var H = m.lookupRec;
                  for (D = 0; D < H.length; D += 2) {
                    M = H[D];
                    var W = a[H[D + 1]];
                    e.U._applySubs(i, o + M, W, a);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (i, o, s) {
          for (var a = 0; a < o.length; a++)
            if (e._lctf.coverageIndex(o[a], i[s + a]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (i, o, s) {
          for (
            var a = { cmds: [], crds: [] }, u = 0, c = 0;
            c < o.length;
            c++
          ) {
            var d = o[c];
            if (d != -1) {
              for (
                var m = c < o.length - 1 && o[c + 1] != -1 ? o[c + 1] : 0,
                  g = e.U.glyphToPath(i, d),
                  y = 0;
                y < g.crds.length;
                y += 2
              )
                a.crds.push(g.crds[y] + u), a.crds.push(g.crds[y + 1]);
              for (s && a.cmds.push(s), y = 0; y < g.cmds.length; y++)
                a.cmds.push(g.cmds[y]);
              s && a.cmds.push("X"),
                (u += i.hmtx.aWidth[d]),
                c < o.length - 1 && (u += e.U.getPairAdjustment(i, d, m));
            }
          }
          return a;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (i, o, s) {
          i.cmds.push("M"), i.crds.push(o, s);
        }),
        (e.U.P.lineTo = function (i, o, s) {
          i.cmds.push("L"), i.crds.push(o, s);
        }),
        (e.U.P.curveTo = function (i, o, s, a, u, c, d) {
          i.cmds.push("C"), i.crds.push(o, s, a, u, c, d);
        }),
        (e.U.P.qcurveTo = function (i, o, s, a, u) {
          i.cmds.push("Q"), i.crds.push(o, s, a, u);
        }),
        (e.U.P.closePath = function (i) {
          i.cmds.push("Z");
        }),
        (e.U._drawCFF = function (i, o, s, a, u) {
          for (
            var c = o.stack,
              d = o.nStems,
              m = o.haveWidth,
              g = o.width,
              y = o.open,
              x = 0,
              S = o.x,
              _ = o.y,
              w = 0,
              T = 0,
              M = 0,
              A = 0,
              R = 0,
              D = 0,
              P = 0,
              U = 0,
              O = 0,
              L = 0,
              H = { val: 0, size: 0 };
            x < i.length;

          ) {
            e.CFF.getCharString(i, x, H);
            var W = H.val;
            if (((x += H.size), W == "o1" || W == "o18"))
              c.length % 2 != 0 && !m && (g = c.shift() + a.nominalWidthX),
                (d += c.length >> 1),
                (c.length = 0),
                (m = !0);
            else if (W == "o3" || W == "o23")
              c.length % 2 != 0 && !m && (g = c.shift() + a.nominalWidthX),
                (d += c.length >> 1),
                (c.length = 0),
                (m = !0);
            else if (W == "o4")
              c.length > 1 &&
                !m &&
                ((g = c.shift() + a.nominalWidthX), (m = !0)),
                y && e.U.P.closePath(u),
                (_ += c.pop()),
                e.U.P.moveTo(u, S, _),
                (y = !0);
            else if (W == "o5")
              for (; c.length > 0; )
                (S += c.shift()), (_ += c.shift()), e.U.P.lineTo(u, S, _);
            else if (W == "o6" || W == "o7")
              for (var $ = c.length, K = W == "o6", Z = 0; Z < $; Z++) {
                var Y = c.shift();
                K ? (S += Y) : (_ += Y), (K = !K), e.U.P.lineTo(u, S, _);
              }
            else if (W == "o8" || W == "o24") {
              $ = c.length;
              for (var re = 0; re + 6 <= $; )
                (w = S + c.shift()),
                  (T = _ + c.shift()),
                  (M = w + c.shift()),
                  (A = T + c.shift()),
                  (S = M + c.shift()),
                  (_ = A + c.shift()),
                  e.U.P.curveTo(u, w, T, M, A, S, _),
                  (re += 6);
              W == "o24" &&
                ((S += c.shift()), (_ += c.shift()), e.U.P.lineTo(u, S, _));
            } else {
              if (W == "o11") break;
              if (W == "o1234" || W == "o1235" || W == "o1236" || W == "o1237")
                W == "o1234" &&
                  ((T = _),
                  (M = (w = S + c.shift()) + c.shift()),
                  (L = A = T + c.shift()),
                  (D = A),
                  (U = _),
                  (S =
                    (P = (R = (O = M + c.shift()) + c.shift()) + c.shift()) +
                    c.shift()),
                  e.U.P.curveTo(u, w, T, M, A, O, L),
                  e.U.P.curveTo(u, R, D, P, U, S, _)),
                  W == "o1235" &&
                    ((w = S + c.shift()),
                    (T = _ + c.shift()),
                    (M = w + c.shift()),
                    (A = T + c.shift()),
                    (O = M + c.shift()),
                    (L = A + c.shift()),
                    (R = O + c.shift()),
                    (D = L + c.shift()),
                    (P = R + c.shift()),
                    (U = D + c.shift()),
                    (S = P + c.shift()),
                    (_ = U + c.shift()),
                    c.shift(),
                    e.U.P.curveTo(u, w, T, M, A, O, L),
                    e.U.P.curveTo(u, R, D, P, U, S, _)),
                  W == "o1236" &&
                    ((w = S + c.shift()),
                    (T = _ + c.shift()),
                    (M = w + c.shift()),
                    (L = A = T + c.shift()),
                    (D = A),
                    (P = (R = (O = M + c.shift()) + c.shift()) + c.shift()),
                    (U = D + c.shift()),
                    (S = P + c.shift()),
                    e.U.P.curveTo(u, w, T, M, A, O, L),
                    e.U.P.curveTo(u, R, D, P, U, S, _)),
                  W == "o1237" &&
                    ((w = S + c.shift()),
                    (T = _ + c.shift()),
                    (M = w + c.shift()),
                    (A = T + c.shift()),
                    (O = M + c.shift()),
                    (L = A + c.shift()),
                    (R = O + c.shift()),
                    (D = L + c.shift()),
                    (P = R + c.shift()),
                    (U = D + c.shift()),
                    Math.abs(P - S) > Math.abs(U - _)
                      ? (S = P + c.shift())
                      : (_ = U + c.shift()),
                    e.U.P.curveTo(u, w, T, M, A, O, L),
                    e.U.P.curveTo(u, R, D, P, U, S, _));
              else if (W == "o14") {
                if (
                  (c.length > 0 &&
                    !m &&
                    ((g = c.shift() + s.nominalWidthX), (m = !0)),
                  c.length == 4)
                ) {
                  var G = c.shift(),
                    te = c.shift(),
                    F = c.shift(),
                    V = c.shift(),
                    ne = e.CFF.glyphBySE(s, F),
                    ae = e.CFF.glyphBySE(s, V);
                  e.U._drawCFF(s.CharStrings[ne], o, s, a, u),
                    (o.x = G),
                    (o.y = te),
                    e.U._drawCFF(s.CharStrings[ae], o, s, a, u);
                }
                y && (e.U.P.closePath(u), (y = !1));
              } else if (W == "o19" || W == "o20")
                c.length % 2 != 0 && !m && (g = c.shift() + a.nominalWidthX),
                  (d += c.length >> 1),
                  (c.length = 0),
                  (m = !0),
                  (x += (d + 7) >> 3);
              else if (W == "o21")
                c.length > 2 &&
                  !m &&
                  ((g = c.shift() + a.nominalWidthX), (m = !0)),
                  (_ += c.pop()),
                  (S += c.pop()),
                  y && e.U.P.closePath(u),
                  e.U.P.moveTo(u, S, _),
                  (y = !0);
              else if (W == "o22")
                c.length > 1 &&
                  !m &&
                  ((g = c.shift() + a.nominalWidthX), (m = !0)),
                  (S += c.pop()),
                  y && e.U.P.closePath(u),
                  e.U.P.moveTo(u, S, _),
                  (y = !0);
              else if (W == "o25") {
                for (; c.length > 6; )
                  (S += c.shift()), (_ += c.shift()), e.U.P.lineTo(u, S, _);
                (w = S + c.shift()),
                  (T = _ + c.shift()),
                  (M = w + c.shift()),
                  (A = T + c.shift()),
                  (S = M + c.shift()),
                  (_ = A + c.shift()),
                  e.U.P.curveTo(u, w, T, M, A, S, _);
              } else if (W == "o26")
                for (c.length % 2 && (S += c.shift()); c.length > 0; )
                  (w = S),
                    (T = _ + c.shift()),
                    (S = M = w + c.shift()),
                    (_ = (A = T + c.shift()) + c.shift()),
                    e.U.P.curveTo(u, w, T, M, A, S, _);
              else if (W == "o27")
                for (c.length % 2 && (_ += c.shift()); c.length > 0; )
                  (T = _),
                    (M = (w = S + c.shift()) + c.shift()),
                    (A = T + c.shift()),
                    (S = M + c.shift()),
                    (_ = A),
                    e.U.P.curveTo(u, w, T, M, A, S, _);
              else if (W == "o10" || W == "o29") {
                var J = W == "o10" ? a : s;
                if (c.length == 0) console.debug("error: empty stack");
                else {
                  var se = c.pop(),
                    de = J.Subrs[se + J.Bias];
                  (o.x = S),
                    (o.y = _),
                    (o.nStems = d),
                    (o.haveWidth = m),
                    (o.width = g),
                    (o.open = y),
                    e.U._drawCFF(de, o, s, a, u),
                    (S = o.x),
                    (_ = o.y),
                    (d = o.nStems),
                    (m = o.haveWidth),
                    (g = o.width),
                    (y = o.open);
                }
              } else if (W == "o30" || W == "o31") {
                var le = c.length,
                  fe = ((re = 0), W == "o31");
                for (re += le - ($ = -3 & le); re < $; )
                  fe
                    ? ((T = _),
                      (M = (w = S + c.shift()) + c.shift()),
                      (_ = (A = T + c.shift()) + c.shift()),
                      $ - re == 5 ? ((S = M + c.shift()), re++) : (S = M),
                      (fe = !1))
                    : ((w = S),
                      (T = _ + c.shift()),
                      (M = w + c.shift()),
                      (A = T + c.shift()),
                      (S = M + c.shift()),
                      $ - re == 5 ? ((_ = A + c.shift()), re++) : (_ = A),
                      (fe = !0)),
                    e.U.P.curveTo(u, w, T, M, A, S, _),
                    (re += 4);
              } else {
                if ((W + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + W, i), W);
                c.push(W);
              }
            }
          }
          (o.x = S),
            (o.y = _),
            (o.nStems = d),
            (o.haveWidth = m),
            (o.width = g),
            (o.open = y);
        });
      var t = e,
        r = { Typr: t };
      return (
        (n.Typr = t),
        (n.default = r),
        Object.defineProperty(n, "__esModule", { value: !0 }),
        n
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function f9() {
  return (function (n) {
    var e = Uint8Array,
      t = Uint16Array,
      r = Uint32Array,
      i = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      o = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      s = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      a = function (W, $) {
        for (var K = new t(31), Z = 0; Z < 31; ++Z) K[Z] = $ += 1 << W[Z - 1];
        var Y = new r(K[30]);
        for (Z = 1; Z < 30; ++Z)
          for (var re = K[Z]; re < K[Z + 1]; ++re)
            Y[re] = ((re - K[Z]) << 5) | Z;
        return [K, Y];
      },
      u = a(i, 2),
      c = u[0],
      d = u[1];
    (c[28] = 258), (d[258] = 28);
    for (var m = a(o, 0)[0], g = new t(32768), y = 0; y < 32768; ++y) {
      var x = ((43690 & y) >>> 1) | ((21845 & y) << 1);
      (x =
        ((61680 & (x = ((52428 & x) >>> 2) | ((13107 & x) << 2))) >>> 4) |
        ((3855 & x) << 4)),
        (g[y] = (((65280 & x) >>> 8) | ((255 & x) << 8)) >>> 1);
    }
    var S = function (W, $, K) {
        for (var Z = W.length, Y = 0, re = new t($); Y < Z; ++Y) ++re[W[Y] - 1];
        var G,
          te = new t($);
        for (Y = 0; Y < $; ++Y) te[Y] = (te[Y - 1] + re[Y - 1]) << 1;
        {
          G = new t(1 << $);
          var F = 15 - $;
          for (Y = 0; Y < Z; ++Y)
            if (W[Y])
              for (
                var V = (Y << 4) | W[Y],
                  ne = $ - W[Y],
                  ae = te[W[Y] - 1]++ << ne,
                  J = ae | ((1 << ne) - 1);
                ae <= J;
                ++ae
              )
                G[g[ae] >>> F] = V;
        }
        return G;
      },
      _ = new e(288);
    for (y = 0; y < 144; ++y) _[y] = 8;
    for (y = 144; y < 256; ++y) _[y] = 9;
    for (y = 256; y < 280; ++y) _[y] = 7;
    for (y = 280; y < 288; ++y) _[y] = 8;
    var w = new e(32);
    for (y = 0; y < 32; ++y) w[y] = 5;
    var T = S(_, 9),
      M = S(w, 5),
      A = function (W) {
        for (var $ = W[0], K = 1; K < W.length; ++K) W[K] > $ && ($ = W[K]);
        return $;
      },
      R = function (W, $, K) {
        var Z = ($ / 8) | 0;
        return ((W[Z] | (W[Z + 1] << 8)) >> (7 & $)) & K;
      },
      D = function (W, $) {
        var K = ($ / 8) | 0;
        return (W[K] | (W[K + 1] << 8) | (W[K + 2] << 16)) >> (7 & $);
      },
      P = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      U = function (W, $, K) {
        var Z = new Error($ || P[W]);
        if (
          ((Z.code = W),
          Error.captureStackTrace && Error.captureStackTrace(Z, U),
          !K)
        )
          throw Z;
        return Z;
      },
      O = function (W, $, K) {
        var Z = W.length;
        if (!Z || (K && !K.l && Z < 5)) return $ || new e(0);
        var Y = !$ || K,
          re = !K || K.i;
        K || (K = {}), $ || ($ = new e(3 * Z));
        var G,
          te = function (et) {
            var he = $.length;
            if (et > he) {
              var Je = new e(Math.max(2 * he, et));
              Je.set($), ($ = Je);
            }
          },
          F = K.f || 0,
          V = K.p || 0,
          ne = K.b || 0,
          ae = K.l,
          J = K.d,
          se = K.m,
          de = K.n,
          le = 8 * Z;
        do {
          if (!ae) {
            K.f = F = R(W, V, 1);
            var fe = R(W, V + 1, 3);
            if (((V += 3), !fe)) {
              var Me =
                  W[(ee = (((G = V) / 8) | 0) + (7 & G && 1) + 4) - 4] |
                  (W[ee - 3] << 8),
                ge = ee + Me;
              if (ge > Z) {
                re && U(0);
                break;
              }
              Y && te(ne + Me),
                $.set(W.subarray(ee, ge), ne),
                (K.b = ne += Me),
                (K.p = V = 8 * ge);
              continue;
            }
            if (fe == 1) (ae = T), (J = M), (se = 9), (de = 5);
            else if (fe == 2) {
              var xe = R(W, V, 31) + 257,
                j = R(W, V + 10, 15) + 4,
                we = xe + R(W, V + 5, 31) + 1;
              V += 14;
              for (var Ae = new e(we), Oe = new e(19), Ie = 0; Ie < j; ++Ie)
                Oe[s[Ie]] = R(W, V + 3 * Ie, 7);
              V += 3 * j;
              var rt = A(Oe),
                De = (1 << rt) - 1,
                Xe = S(Oe, rt);
              for (Ie = 0; Ie < we; ) {
                var ee,
                  B = Xe[R(W, V, De)];
                if (((V += 15 & B), (ee = B >>> 4) < 16)) Ae[Ie++] = ee;
                else {
                  var ve = 0,
                    Se = 0;
                  for (
                    ee == 16
                      ? ((Se = 3 + R(W, V, 3)), (V += 2), (ve = Ae[Ie - 1]))
                      : ee == 17
                      ? ((Se = 3 + R(W, V, 7)), (V += 3))
                      : ee == 18 && ((Se = 11 + R(W, V, 127)), (V += 7));
                    Se--;

                  )
                    Ae[Ie++] = ve;
                }
              }
              var _e = Ae.subarray(0, xe),
                Te = Ae.subarray(xe);
              (se = A(_e)), (de = A(Te)), (ae = S(_e, se)), (J = S(Te, de));
            } else U(1);
            if (V > le) {
              re && U(0);
              break;
            }
          }
          Y && te(ne + 131072);
          for (var at = (1 << se) - 1, Fe = (1 << de) - 1, Be = V; ; Be = V) {
            var Ge = (ve = ae[D(W, V) & at]) >>> 4;
            if ((V += 15 & ve) > le) {
              re && U(0);
              break;
            }
            if ((ve || U(2), Ge < 256)) $[ne++] = Ge;
            else {
              if (Ge == 256) {
                (Be = V), (ae = null);
                break;
              }
              var Ye = Ge - 254;
              if (Ge > 264) {
                var nt = i[(Ie = Ge - 257)];
                (Ye = R(W, V, (1 << nt) - 1) + c[Ie]), (V += nt);
              }
              var xt = J[D(W, V) & Fe],
                $e = xt >>> 4;
              if (
                (xt || U(3),
                (V += 15 & xt),
                (Te = m[$e]),
                $e > 3 &&
                  ((nt = o[$e]), (Te += D(W, V) & ((1 << nt) - 1)), (V += nt)),
                V > le)
              ) {
                re && U(0);
                break;
              }
              Y && te(ne + 131072);
              for (var qe = ne + Ye; ne < qe; ne += 4)
                ($[ne] = $[ne - Te]),
                  ($[ne + 1] = $[ne + 1 - Te]),
                  ($[ne + 2] = $[ne + 2 - Te]),
                  ($[ne + 3] = $[ne + 3 - Te]);
              ne = qe;
            }
          }
          (K.l = ae),
            (K.p = Be),
            (K.b = ne),
            ae && ((F = 1), (K.m = se), (K.d = J), (K.n = de));
        } while (!F);
        return ne == $.length
          ? $
          : (function (et, he, Je) {
              (Je == null || Je > et.length) && (Je = et.length);
              var me = new (et instanceof t ? t : et instanceof r ? r : e)(
                Je - he
              );
              return me.set(et.subarray(he, Je)), me;
            })($, 0, ne);
      },
      L = new e(0),
      H = typeof TextDecoder < "u" && new TextDecoder();
    try {
      H.decode(L, { stream: !0 });
    } catch {}
    return (
      (n.convert_streams = function (W) {
        var $ = new DataView(W),
          K = 0;
        function Z() {
          var xe = $.getUint16(K);
          return (K += 2), xe;
        }
        function Y() {
          var xe = $.getUint32(K);
          return (K += 4), xe;
        }
        function re(xe) {
          Me.setUint16(ge, xe), (ge += 2);
        }
        function G(xe) {
          Me.setUint32(ge, xe), (ge += 4);
        }
        for (
          var te = {
              signature: Y(),
              flavor: Y(),
              length: Y(),
              numTables: Z(),
              reserved: Z(),
              totalSfntSize: Y(),
              majorVersion: Z(),
              minorVersion: Z(),
              metaOffset: Y(),
              metaLength: Y(),
              metaOrigLength: Y(),
              privOffset: Y(),
              privLength: Y(),
            },
            F = 0;
          Math.pow(2, F) <= te.numTables;

        )
          F++;
        F--;
        for (
          var V = 16 * Math.pow(2, F),
            ne = 16 * te.numTables - V,
            ae = 12,
            J = [],
            se = 0;
          se < te.numTables;
          se++
        )
          J.push({
            tag: Y(),
            offset: Y(),
            compLength: Y(),
            origLength: Y(),
            origChecksum: Y(),
          }),
            (ae += 16);
        var de,
          le = new Uint8Array(
            12 +
              16 * J.length +
              J.reduce(function (xe, j) {
                return xe + j.origLength + 4;
              }, 0)
          ),
          fe = le.buffer,
          Me = new DataView(fe),
          ge = 0;
        return (
          G(te.flavor),
          re(te.numTables),
          re(V),
          re(F),
          re(ne),
          J.forEach(function (xe) {
            G(xe.tag),
              G(xe.origChecksum),
              G(ae),
              G(xe.origLength),
              (xe.outOffset = ae),
              (ae += xe.origLength) % 4 != 0 && (ae += 4 - (ae % 4));
          }),
          J.forEach(function (xe) {
            var j,
              we = W.slice(xe.offset, xe.offset + xe.compLength);
            if (xe.compLength != xe.origLength) {
              var Ae = new Uint8Array(xe.origLength);
              (j = new Uint8Array(we, 2)), O(j, Ae);
            } else Ae = new Uint8Array(we);
            le.set(Ae, xe.outOffset);
            var Oe = 0;
            (ae = xe.outOffset + xe.origLength) % 4 != 0 && (Oe = 4 - (ae % 4)),
              le.set(new Uint8Array(Oe).buffer, xe.outOffset + xe.origLength),
              (de = ae + Oe);
          }),
          fe.slice(0, de)
        );
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({}).convert_streams;
}
function d9(n, e) {
  const t = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    r = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    i = 1,
    o = 2,
    s = 4,
    a = 8,
    u = 16,
    c = 32;
  let d;
  function m(P) {
    if (!d) {
      const U = { R: o, L: i, D: s, C: u, U: c, T: a };
      d = new Map();
      for (let O in r) {
        let L = 0;
        r[O].split(",").forEach((H) => {
          let [W, $] = H.split("+");
          (W = parseInt(W, 36)),
            ($ = $ ? parseInt($, 36) : 0),
            d.set((L += W), U[O]);
          for (let K = $; K--; ) d.set(++L, U[O]);
        });
      }
    }
    return d.get(P) || c;
  }
  const g = 1,
    y = 2,
    x = 3,
    S = 4,
    _ = [null, "isol", "init", "fina", "medi"];
  function w(P) {
    const U = new Uint8Array(P.length);
    let O = c,
      L = g,
      H = -1;
    for (let W = 0; W < P.length; W++) {
      const $ = P.codePointAt(W);
      let K = m($) | 0,
        Z = g;
      K & a ||
        (O & (i | s | u)
          ? K & (o | s | u)
            ? ((Z = x), (L === g || L === x) && U[H]++)
            : K & (i | c) && (L === y || L === S) && U[H]--
          : O & (o | c) && (L === y || L === S) && U[H]--,
        (L = U[W] = Z),
        (O = K),
        (H = W),
        $ > 65535 && W++);
    }
    return U;
  }
  function T(P, U) {
    const O = [];
    for (let H = 0; H < U.length; H++) {
      const W = U.codePointAt(H);
      W > 65535 && H++, O.push(n.U.codeToGlyph(P, W));
    }
    const L = P.GSUB;
    if (L) {
      const { lookupList: H, featureList: W } = L;
      let $;
      const K = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        Z = [];
      W.forEach((Y) => {
        if (K.test(Y.tag))
          for (let re = 0; re < Y.tab.length; re++) {
            if (Z[Y.tab[re]]) continue;
            Z[Y.tab[re]] = !0;
            const G = H[Y.tab[re]],
              te = /^(isol|init|fina|medi)$/.test(Y.tag);
            te && !$ && ($ = w(U));
            for (let F = 0; F < O.length; F++)
              (!$ || !te || _[$[F]] === Y.tag) && n.U._applySubs(O, F, G, H);
          }
      });
    }
    return O;
  }
  function M(P, U) {
    const O = new Int16Array(U.length * 3);
    let L = 0;
    for (; L < U.length; L++) {
      const K = U[L];
      if (K === -1) continue;
      O[L * 3 + 2] = P.hmtx.aWidth[K];
      const Z = P.GPOS;
      if (Z) {
        const Y = Z.lookupList;
        for (let re = 0; re < Y.length; re++) {
          const G = Y[re];
          for (let te = 0; te < G.tabs.length; te++) {
            const F = G.tabs[te];
            if (G.ltype === 1) {
              if (n._lctf.coverageIndex(F.coverage, K) !== -1 && F.pos) {
                $(F.pos, L);
                break;
              }
            } else if (G.ltype === 2) {
              let V = null,
                ne = H();
              if (ne !== -1) {
                const ae = n._lctf.coverageIndex(F.coverage, U[ne]);
                if (ae !== -1) {
                  if (F.fmt === 1) {
                    const J = F.pairsets[ae];
                    for (let se = 0; se < J.length; se++)
                      J[se].gid2 === K && (V = J[se]);
                  } else if (F.fmt === 2) {
                    const J = n.U._getGlyphClass(U[ne], F.classDef1),
                      se = n.U._getGlyphClass(K, F.classDef2);
                    V = F.matrix[J][se];
                  }
                  if (V) {
                    V.val1 && $(V.val1, ne), V.val2 && $(V.val2, L);
                    break;
                  }
                }
              }
            } else if (G.ltype === 4) {
              const V = n._lctf.coverageIndex(F.markCoverage, K);
              if (V !== -1) {
                const ne = H(W),
                  ae =
                    ne === -1
                      ? -1
                      : n._lctf.coverageIndex(F.baseCoverage, U[ne]);
                if (ae !== -1) {
                  const J = F.markArray[V],
                    se = F.baseArray[ae][J.markClass];
                  (O[L * 3] = se.x - J.x + O[ne * 3] - O[ne * 3 + 2]),
                    (O[L * 3 + 1] = se.y - J.y + O[ne * 3 + 1]);
                  break;
                }
              }
            } else if (G.ltype === 6) {
              const V = n._lctf.coverageIndex(F.mark1Coverage, K);
              if (V !== -1) {
                const ne = H();
                if (ne !== -1) {
                  const ae = U[ne];
                  if (A(P, ae) === 3) {
                    const J = n._lctf.coverageIndex(F.mark2Coverage, ae);
                    if (J !== -1) {
                      const se = F.mark1Array[V],
                        de = F.mark2Array[J][se.markClass];
                      (O[L * 3] = de.x - se.x + O[ne * 3] - O[ne * 3 + 2]),
                        (O[L * 3 + 1] = de.y - se.y + O[ne * 3 + 1]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (P.kern && !P.cff) {
        const Y = H();
        if (Y !== -1) {
          const re = P.kern.glyph1.indexOf(U[Y]);
          if (re !== -1) {
            const G = P.kern.rval[re].glyph2.indexOf(K);
            G !== -1 && (O[Y * 3 + 2] += P.kern.rval[re].vals[G]);
          }
        }
      }
    }
    return O;
    function H(K) {
      for (let Z = L - 1; Z >= 0; Z--)
        if (U[Z] !== -1 && (!K || K(U[Z]))) return Z;
      return -1;
    }
    function W(K) {
      return A(P, K) === 1;
    }
    function $(K, Z) {
      for (let Y = 0; Y < 3; Y++) O[Z * 3 + Y] += K[Y] || 0;
    }
  }
  function A(P, U) {
    const O = P.GDEF && P.GDEF.glyphClassDef;
    return O ? n.U._getGlyphClass(U, O) : 0;
  }
  function R(...P) {
    for (let U = 0; U < P.length; U++) if (typeof P[U] == "number") return P[U];
  }
  function D(P) {
    const U = Object.create(null),
      O = P["OS/2"],
      L = P.hhea,
      H = P.head.unitsPerEm,
      W = R(O && O.sTypoAscender, L && L.ascender, H),
      $ = {
        unitsPerEm: H,
        ascender: W,
        descender: R(O && O.sTypoDescender, L && L.descender, 0),
        capHeight: R(O && O.sCapHeight, W),
        xHeight: R(O && O.sxHeight, W),
        lineGap: R(O && O.sTypoLineGap, L && L.lineGap),
        supportsCodePoint(K) {
          return n.U.codeToGlyph(P, K) > 0;
        },
        forEachGlyph(K, Z, Y, re) {
          let G = 0;
          const te = (1 / $.unitsPerEm) * Z,
            F = T(P, K);
          let V = 0;
          const ne = M(P, F);
          return (
            F.forEach((ae, J) => {
              if (ae !== -1) {
                let se = U[ae];
                if (!se) {
                  const { cmds: de, crds: le } = n.U.glyphToPath(P, ae);
                  let fe = "",
                    Me = 0;
                  for (let Ae = 0, Oe = de.length; Ae < Oe; Ae++) {
                    const Ie = t[de[Ae]];
                    fe += de[Ae];
                    for (let rt = 1; rt <= Ie; rt++)
                      fe += (rt > 1 ? "," : "") + le[Me++];
                  }
                  let ge, xe, j, we;
                  if (le.length) {
                    (ge = xe = 1 / 0), (j = we = -1 / 0);
                    for (let Ae = 0, Oe = le.length; Ae < Oe; Ae += 2) {
                      let Ie = le[Ae],
                        rt = le[Ae + 1];
                      Ie < ge && (ge = Ie),
                        rt < xe && (xe = rt),
                        Ie > j && (j = Ie),
                        rt > we && (we = rt);
                    }
                  } else ge = j = xe = we = 0;
                  se = U[ae] = {
                    index: ae,
                    advanceWidth: P.hmtx.aWidth[ae],
                    xMin: ge,
                    yMin: xe,
                    xMax: j,
                    yMax: we,
                    path: fe,
                  };
                }
                re.call(null, se, G + ne[J * 3] * te, ne[J * 3 + 1] * te, V),
                  (G += ne[J * 3 + 2] * te),
                  Y && (G += Y * Z);
              }
              V += K.codePointAt(V) > 65535 ? 2 : 1;
            }),
            G
          );
        },
      };
    return $;
  }
  return function (U) {
    const O = new Uint8Array(U, 0, 4),
      L = n._bin.readASCII(O, 0, 4);
    if (L === "wOFF") U = e(U);
    else if (L === "wOF2") throw new Error("woff2 fonts not supported");
    return D(n.parse(U)[0]);
  };
}
const h9 = $h({
  name: "Typr Font Parser",
  dependencies: [c9, f9, d9],
  init(n, e, t) {
    const r = n(),
      i = e();
    return t(r, i);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function p9() {
  return (function (n) {
    var e = function () {
      this.buckets = new Map();
    };
    (e.prototype.add = function (M) {
      var A = M >> 5;
      this.buckets.set(A, (this.buckets.get(A) || 0) | (1 << (31 & M)));
    }),
      (e.prototype.has = function (M) {
        var A = this.buckets.get(M >> 5);
        return A !== void 0 && (A & (1 << (31 & M))) != 0;
      }),
      (e.prototype.serialize = function () {
        var M = [];
        return (
          this.buckets.forEach(function (A, R) {
            M.push((+R).toString(36) + ":" + A.toString(36));
          }),
          M.join(",")
        );
      }),
      (e.prototype.deserialize = function (M) {
        var A = this;
        this.buckets.clear(),
          M.split(",").forEach(function (R) {
            var D = R.split(":");
            A.buckets.set(parseInt(D[0], 36), parseInt(D[1], 36));
          });
      });
    var t = Math.pow(2, 8),
      r = t - 1,
      i = ~r;
    function o(M) {
      var A = (function (D) {
          return D & i;
        })(M).toString(16),
        R = (function (D) {
          return (D & i) + t - 1;
        })(M).toString(16);
      return "codepoint-index/plane" + (M >> 16) + "/" + A + "-" + R + ".json";
    }
    function s(M, A) {
      var R = M & r,
        D = A.codePointAt((R / 6) | 0);
      return ((D = (D || 48) - 48) & (1 << R % 6)) != 0;
    }
    function a(M, A) {
      var R;
      ((R = M),
      R.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (D) {
          return D.split("-").map(function (P) {
            return parseInt(P.trim(), 16);
          });
        })).forEach(function (D) {
        var P = D[0],
          U = D[1];
        U === void 0 && (U = P), A(P, U);
      });
    }
    function u(M, A) {
      a(M, function (R, D) {
        for (var P = R; P <= D; P++) A(P);
      });
    }
    var c = {},
      d = {},
      m = new WeakMap(),
      g =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function y(M) {
      var A = m.get(M);
      return (
        A ||
          ((A = new e()),
          u(M.ranges, function (R) {
            return A.add(R);
          }),
          m.set(M, A)),
        A
      );
    }
    var x,
      S = new Map();
    function _(M, A, R) {
      return M[A]
        ? A
        : M[R]
        ? R
        : (function (D) {
            for (var P in D) return P;
          })(M);
    }
    function w(M, A) {
      var R = A;
      if (!M.includes(R)) {
        R = 1 / 0;
        for (var D = 0; D < M.length; D++)
          Math.abs(M[D] - A) < Math.abs(R - A) && (R = M[D]);
      }
      return R;
    }
    function T(M) {
      return (
        x ||
          ((x = new Set()),
          u("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (A) {
            x.add(A);
          })),
        x.has(M)
      );
    }
    return (
      (n.CodePointSet = e),
      (n.clearCache = function () {
        (c = {}), (d = {});
      }),
      (n.getFontsForString = function (M, A) {
        A === void 0 && (A = {});
        var R,
          D = A.lang;
        D === void 0 &&
          (D = new RegExp("\\p{Script=Hangul}", "u").test((R = M))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                R
              )
            ? "ja"
            : "en");
        var P = A.category;
        P === void 0 && (P = "sans-serif");
        var U = A.style;
        U === void 0 && (U = "normal");
        var O = A.weight;
        O === void 0 && (O = 400);
        var L = (A.dataUrl || g).replace(/\/$/g, ""),
          H = new Map(),
          W = new Uint8Array(M.length),
          $ = {},
          K = {},
          Z = new Array(M.length),
          Y = new Map(),
          re = !1;
        function G(V) {
          var ne = S.get(V);
          return (
            ne ||
              ((ne = fetch(L + "/" + V)
                .then(function (ae) {
                  if (!ae.ok) throw new Error(ae.statusText);
                  return ae.json().then(function (J) {
                    if (!Array.isArray(J) || J[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + J[0]
                      );
                    return J[1];
                  });
                })
                .catch(function (ae) {
                  if (L !== g)
                    return (
                      re ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            L +
                            '", trying default CDN. ' +
                            ae.message
                        ),
                        (re = !0)),
                      (L = g),
                      S.delete(V),
                      G(V)
                    );
                  throw ae;
                })),
              S.set(V, ne)),
            ne
          );
        }
        for (
          var te = function (V) {
              var ne = M.codePointAt(V),
                ae = o(ne);
              (Z[V] = ae),
                c[ae] ||
                  Y.has(ae) ||
                  Y.set(
                    ae,
                    G(ae).then(function (J) {
                      c[ae] = J;
                    })
                  ),
                ne > 65535 && (V++, (F = V));
            },
            F = 0;
          F < M.length;
          F++
        )
          te(F);
        return Promise.all(Y.values())
          .then(function () {
            Y.clear();
            for (
              var V = function (ae) {
                  var J = M.codePointAt(ae),
                    se = null,
                    de = c[Z[ae]],
                    le = void 0;
                  for (var fe in de) {
                    var Me = K[fe];
                    if (
                      (Me === void 0 &&
                        (Me = K[fe] = new RegExp(fe).test(D || "en")),
                      Me)
                    ) {
                      for (var ge in ((le = fe), de[fe]))
                        if (s(J, de[fe][ge])) {
                          se = ge;
                          break;
                        }
                      break;
                    }
                  }
                  if (!se) {
                    e: for (var xe in de)
                      if (xe !== le) {
                        for (var j in de[xe])
                          if (s(J, de[xe][j])) {
                            se = j;
                            break e;
                          }
                      }
                  }
                  se ||
                    (console.debug("No font coverage for U+" + J.toString(16)),
                    (se = "latin")),
                    (Z[ae] = se),
                    d[se] ||
                      Y.has(se) ||
                      Y.set(
                        se,
                        G("font-meta/" + se + ".json").then(function (we) {
                          d[se] = we;
                        })
                      ),
                    J > 65535 && (ae++, (ne = ae));
                },
                ne = 0;
              ne < M.length;
              ne++
            )
              V(ne);
            return Promise.all(Y.values());
          })
          .then(function () {
            for (var V, ne = null, ae = 0; ae < M.length; ae++) {
              var J = M.codePointAt(ae);
              if (ne && (T(J) || y(ne).has(J))) W[ae] = W[ae - 1];
              else {
                ne = d[Z[ae]];
                var se = $[ne.id];
                if (!se) {
                  var de = ne.typeforms,
                    le = _(de, P, "sans-serif"),
                    fe = _(de[le], U, "normal"),
                    Me = w(
                      (V = de[le]) === null || V === void 0 ? void 0 : V[fe],
                      O
                    );
                  se = $[ne.id] =
                    L +
                    "/font-files/" +
                    ne.id +
                    "/" +
                    le +
                    "." +
                    fe +
                    "." +
                    Me +
                    ".woff";
                }
                var ge = H.get(se);
                ge == null && ((ge = H.size), H.set(se, ge)), (W[ae] = ge);
              }
              J > 65535 && (ae++, (W[ae] = W[ae - 1]));
            }
            return { fontUrls: Array.from(H.keys()), chars: W };
          });
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({});
}
function m9(n, e) {
  const t = Object.create(null),
    r = Object.create(null);
  function i(s, a) {
    const u = (c) => {
      console.error(`Failure loading font ${s}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", s, !0),
        (c.responseType = "arraybuffer"),
        (c.onload = function () {
          if (c.status >= 400) u(new Error(c.statusText));
          else if (c.status > 0)
            try {
              const d = n(c.response);
              (d.src = s), a(d);
            } catch (d) {
              u(d);
            }
        }),
        (c.onerror = u),
        c.send();
    } catch (c) {
      u(c);
    }
  }
  function o(s, a) {
    let u = t[s];
    u
      ? a(u)
      : r[s]
      ? r[s].push(a)
      : ((r[s] = [a]),
        i(s, (c) => {
          (c.src = s), (t[s] = c), r[s].forEach((d) => d(c)), delete r[s];
        }));
  }
  return function (
    s,
    a,
    {
      lang: u,
      fonts: c = [],
      style: d = "normal",
      weight: m = "normal",
      unicodeFontsURL: g,
    } = {}
  ) {
    const y = new Uint8Array(s.length),
      x = [];
    s.length || T();
    const S = new Map(),
      _ = [];
    if (
      (d !== "italic" && (d = "normal"),
      typeof m != "number" && (m = m === "bold" ? 700 : 400),
      c && !Array.isArray(c) && (c = [c]),
      (c = c
        .slice()
        .filter((A) => !A.lang || A.lang.test(u))
        .reverse()),
      c.length)
    ) {
      let P = 0;
      (function U(O = 0) {
        for (let L = O, H = s.length; L < H; L++) {
          const W = s.codePointAt(L);
          if ((P === 1 && x[y[L - 1]].supportsCodePoint(W)) || /\s/.test(s[L]))
            (y[L] = y[L - 1]), P === 2 && (_[_.length - 1][1] = L);
          else
            for (let $ = y[L], K = c.length; $ <= K; $++)
              if ($ === K) {
                const Z = P === 2 ? _[_.length - 1] : (_[_.length] = [L, L]);
                (Z[1] = L), (P = 2);
              } else {
                y[L] = $;
                const { src: Z, unicodeRange: Y } = c[$];
                if (!Y || M(W, Y)) {
                  const re = t[Z];
                  if (!re) {
                    o(Z, () => {
                      U(L);
                    });
                    return;
                  }
                  if (re.supportsCodePoint(W)) {
                    let G = S.get(re);
                    typeof G != "number" &&
                      ((G = x.length), x.push(re), S.set(re, G)),
                      (y[L] = G),
                      (P = 1);
                    break;
                  }
                }
              }
          W > 65535 &&
            L + 1 < H &&
            ((y[L + 1] = y[L]), L++, P === 2 && (_[_.length - 1][1] = L));
        }
        w();
      })();
    } else _.push([0, s.length - 1]), w();
    function w() {
      if (_.length) {
        const A = _.map((R) => s.substring(R[0], R[1] + 1)).join(`
`);
        e.getFontsForString(A, {
          lang: u || void 0,
          style: d,
          weight: m,
          dataUrl: g,
        }).then(({ fontUrls: R, chars: D }) => {
          const P = x.length;
          let U = 0;
          _.forEach((L) => {
            for (let H = 0, W = L[1] - L[0]; H <= W; H++)
              y[L[0] + H] = D[U++] + P;
            U++;
          });
          let O = 0;
          R.forEach((L, H) => {
            o(L, (W) => {
              (x[H + P] = W), ++O === R.length && T();
            });
          });
        });
      } else T();
    }
    function T() {
      a({ chars: y, fonts: x });
    }
    function M(A, R) {
      for (let D = 0; D < R.length; D++) {
        const [P, U = P] = R[D];
        if (P <= A && A <= U) return !0;
      }
      return !1;
    }
  };
}
const g9 = $h({
  name: "FontResolver",
  dependencies: [m9, h9, p9],
  init(n, e, t) {
    return n(e, t());
  },
});
function v9(n, e) {
  const r =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    i = "[^\\S\\u00A0]",
    o = new RegExp(
      `${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function s(
    {
      text: x,
      lang: S,
      fonts: _,
      style: w,
      weight: T,
      preResolvedFonts: M,
      unicodeFontsURL: A,
    },
    R
  ) {
    const D = ({ chars: P, fonts: U }) => {
      let O, L;
      const H = [];
      for (let W = 0; W < P.length; W++)
        P[W] !== L
          ? ((L = P[W]), H.push((O = { start: W, end: W, fontObj: U[P[W]] })))
          : (O.end = W);
      R(H);
    };
    M
      ? D(M)
      : n(x, D, { lang: S, fonts: _, style: w, weight: T, unicodeFontsURL: A });
  }
  function a(
    {
      text: x = "",
      font: S,
      lang: _,
      sdfGlyphSize: w = 64,
      fontSize: T = 400,
      fontWeight: M = 1,
      fontStyle: A = "normal",
      letterSpacing: R = 0,
      lineHeight: D = "normal",
      maxWidth: P = 1 / 0,
      direction: U,
      textAlign: O = "left",
      textIndent: L = 0,
      whiteSpace: H = "normal",
      overflowWrap: W = "normal",
      anchorX: $ = 0,
      anchorY: K = 0,
      metricsOnly: Z = !1,
      unicodeFontsURL: Y,
      preResolvedFonts: re = null,
      includeCaretPositions: G = !1,
      chunkedBoundsSize: te = 8192,
      colorRanges: F = null,
    },
    V
  ) {
    const ne = m(),
      ae = { fontLoad: 0, typesetting: 0 };
    x.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (x = x
        .replace(
          /\r\n/g,
          `
`
        )
        .replace(
          /\r/g,
          `
`
        ))),
      (T = +T),
      (R = +R),
      (P = +P),
      (D = D || "normal"),
      (L = +L),
      s(
        {
          text: x,
          lang: _,
          style: A,
          weight: M,
          fonts: typeof S == "string" ? [{ src: S }] : S,
          unicodeFontsURL: Y,
          preResolvedFonts: re,
        },
        (J) => {
          ae.fontLoad = m() - ne;
          const se = isFinite(P);
          let de = null,
            le = null,
            fe = null,
            Me = null,
            ge = null,
            xe = null,
            j = null,
            we = null,
            Ae = 0,
            Oe = 0,
            Ie = H !== "nowrap";
          const rt = new Map(),
            De = m();
          let Xe = L,
            ee = 0,
            B = new g();
          const ve = [B];
          J.forEach((Fe) => {
            const { fontObj: Be } = Fe,
              {
                ascender: Ge,
                descender: Ye,
                unitsPerEm: nt,
                lineGap: xt,
                capHeight: $e,
                xHeight: qe,
              } = Be;
            let et = rt.get(Be);
            if (!et) {
              const Re = T / nt,
                Ue = D === "normal" ? (Ge - Ye + xt) * Re : D * T,
                it = (Ue - (Ge - Ye) * Re) / 2,
                mt = Math.min(Ue, (Ge - Ye) * Re),
                gt = ((Ge + Ye) / 2) * Re + mt / 2;
              (et = {
                index: rt.size,
                src: Be.src,
                fontObj: Be,
                fontSizeMult: Re,
                unitsPerEm: nt,
                ascender: Ge * Re,
                descender: Ye * Re,
                capHeight: $e * Re,
                xHeight: qe * Re,
                lineHeight: Ue,
                baseline: -it - Ge * Re,
                caretTop: ((Ge + Ye) / 2) * Re + mt / 2,
                caretBottom: gt - mt,
              }),
                rt.set(Be, et);
            }
            const { fontSizeMult: he } = et,
              Je = x.slice(Fe.start, Fe.end + 1);
            let me, Ve;
            Be.forEachGlyph(Je, T, R, (Re, Ue, it, mt) => {
              (Ue += ee), (mt += Fe.start), (me = Ue), (Ve = Re);
              const gt = x.charAt(mt),
                Nt = Re.advanceWidth * he,
                Ut = B.count;
              let ht;
              if (
                ("isEmpty" in Re ||
                  ((Re.isWhitespace = !!gt && new RegExp(i).test(gt)),
                  (Re.canBreakAfter = !!gt && o.test(gt)),
                  (Re.isEmpty =
                    Re.xMin === Re.xMax || Re.yMin === Re.yMax || r.test(gt))),
                !Re.isWhitespace && !Re.isEmpty && Oe++,
                Ie && se && !Re.isWhitespace && Ue + Nt + Xe > P && Ut)
              ) {
                if (B.glyphAt(Ut - 1).glyphObj.canBreakAfter)
                  (ht = new g()), (Xe = -Ue);
                else
                  for (let un = Ut; un--; )
                    if (un === 0 && W === "break-word") {
                      (ht = new g()), (Xe = -Ue);
                      break;
                    } else if (B.glyphAt(un).glyphObj.canBreakAfter) {
                      ht = B.splitAt(un + 1);
                      const bn = ht.glyphAt(0).x;
                      Xe -= bn;
                      for (let yn = ht.count; yn--; ) ht.glyphAt(yn).x -= bn;
                      break;
                    }
                ht && ((B.isSoftWrapped = !0), (B = ht), ve.push(B), (Ae = P));
              }
              let $t = B.glyphAt(B.count);
              ($t.glyphObj = Re),
                ($t.x = Ue + Xe),
                ($t.y = it),
                ($t.width = Nt),
                ($t.charIndex = mt),
                ($t.fontData = et),
                gt ===
                  `
` && ((B = new g()), ve.push(B), (Xe = -(Ue + Nt + R * T) + L));
            }),
              (ee = me + Ve.advanceWidth * he + R * T);
          });
          let Se = 0;
          ve.forEach((Fe) => {
            let Be = !0;
            for (let Ge = Fe.count; Ge--; ) {
              const Ye = Fe.glyphAt(Ge);
              Be &&
                !Ye.glyphObj.isWhitespace &&
                ((Fe.width = Ye.x + Ye.width),
                Fe.width > Ae && (Ae = Fe.width),
                (Be = !1));
              let {
                lineHeight: nt,
                capHeight: xt,
                xHeight: $e,
                baseline: qe,
              } = Ye.fontData;
              nt > Fe.lineHeight && (Fe.lineHeight = nt);
              const et = qe - Fe.baseline;
              et < 0 && ((Fe.baseline += et), (Fe.cap += et), (Fe.ex += et)),
                (Fe.cap = Math.max(Fe.cap, Fe.baseline + xt)),
                (Fe.ex = Math.max(Fe.ex, Fe.baseline + $e));
            }
            (Fe.baseline -= Se),
              (Fe.cap -= Se),
              (Fe.ex -= Se),
              (Se += Fe.lineHeight);
          });
          let _e = 0,
            Te = 0;
          if (
            ($ &&
              (typeof $ == "number"
                ? (_e = -$)
                : typeof $ == "string" &&
                  (_e =
                    -Ae *
                    ($ === "left"
                      ? 0
                      : $ === "center"
                      ? 0.5
                      : $ === "right"
                      ? 1
                      : c($)))),
            K &&
              (typeof K == "number"
                ? (Te = -K)
                : typeof K == "string" &&
                  (Te =
                    K === "top"
                      ? 0
                      : K === "top-baseline"
                      ? -ve[0].baseline
                      : K === "top-cap"
                      ? -ve[0].cap
                      : K === "top-ex"
                      ? -ve[0].ex
                      : K === "middle"
                      ? Se / 2
                      : K === "bottom"
                      ? Se
                      : K === "bottom-baseline"
                      ? ve[ve.length - 1].baseline
                      : c(K) * Se)),
            !Z)
          ) {
            const Fe = e.getEmbeddingLevels(x, U);
            (de = new Uint16Array(Oe)),
              (le = new Uint8Array(Oe)),
              (fe = new Float32Array(Oe * 2)),
              (Me = {}),
              (j = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (we = []),
              G && (xe = new Float32Array(x.length * 4)),
              F && (ge = new Uint8Array(Oe * 3));
            let Be = 0,
              Ge = -1,
              Ye = -1,
              nt,
              xt;
            if (
              (ve.forEach(($e, qe) => {
                let { count: et, width: he } = $e;
                if (et > 0) {
                  let Je = 0;
                  for (
                    let mt = et;
                    mt-- && $e.glyphAt(mt).glyphObj.isWhitespace;

                  )
                    Je++;
                  let me = 0,
                    Ve = 0;
                  if (O === "center") me = (Ae - he) / 2;
                  else if (O === "right") me = Ae - he;
                  else if (O === "justify" && $e.isSoftWrapped) {
                    let mt = 0;
                    for (let gt = et - Je; gt--; )
                      $e.glyphAt(gt).glyphObj.isWhitespace && mt++;
                    Ve = (Ae - he) / mt;
                  }
                  if (Ve || me) {
                    let mt = 0;
                    for (let gt = 0; gt < et; gt++) {
                      let Nt = $e.glyphAt(gt);
                      const Ut = Nt.glyphObj;
                      (Nt.x += me + mt),
                        Ve !== 0 &&
                          Ut.isWhitespace &&
                          gt < et - Je &&
                          ((mt += Ve), (Nt.width += Ve));
                    }
                  }
                  const Re = e.getReorderSegments(
                    x,
                    Fe,
                    $e.glyphAt(0).charIndex,
                    $e.glyphAt($e.count - 1).charIndex
                  );
                  for (let mt = 0; mt < Re.length; mt++) {
                    const [gt, Nt] = Re[mt];
                    let Ut = 1 / 0,
                      ht = -1 / 0;
                    for (let $t = 0; $t < et; $t++)
                      if ($e.glyphAt($t).charIndex >= gt) {
                        let un = $t,
                          bn = $t;
                        for (; bn < et; bn++) {
                          let yn = $e.glyphAt(bn);
                          if (yn.charIndex > Nt) break;
                          bn < et - Je &&
                            ((Ut = Math.min(Ut, yn.x)),
                            (ht = Math.max(ht, yn.x + yn.width)));
                        }
                        for (let yn = un; yn < bn; yn++) {
                          const cr = $e.glyphAt(yn);
                          cr.x = ht - (cr.x + cr.width - Ut);
                        }
                        break;
                      }
                  }
                  let Ue;
                  const it = (mt) => (Ue = mt);
                  for (let mt = 0; mt < et; mt++) {
                    const gt = $e.glyphAt(mt);
                    Ue = gt.glyphObj;
                    const Nt = Ue.index,
                      Ut = Fe.levels[gt.charIndex] & 1;
                    if (Ut) {
                      const ht = e.getMirroredCharacter(x[gt.charIndex]);
                      ht && gt.fontData.fontObj.forEachGlyph(ht, 0, 0, it);
                    }
                    if (G) {
                      const { charIndex: ht, fontData: $t } = gt,
                        un = gt.x + _e,
                        bn = gt.x + gt.width + _e;
                      (xe[ht * 4] = Ut ? bn : un),
                        (xe[ht * 4 + 1] = Ut ? un : bn),
                        (xe[ht * 4 + 2] = $e.baseline + $t.caretBottom + Te),
                        (xe[ht * 4 + 3] = $e.baseline + $t.caretTop + Te);
                      const yn = ht - Ge;
                      yn > 1 && d(xe, Ge, yn), (Ge = ht);
                    }
                    if (F) {
                      const { charIndex: ht } = gt;
                      for (; ht > Ye; )
                        Ye++, F.hasOwnProperty(Ye) && (xt = F[Ye]);
                    }
                    if (!Ue.isWhitespace && !Ue.isEmpty) {
                      const ht = Be++,
                        { fontSizeMult: $t, src: un, index: bn } = gt.fontData,
                        yn = Me[un] || (Me[un] = {});
                      yn[Nt] ||
                        (yn[Nt] = {
                          path: Ue.path,
                          pathBounds: [Ue.xMin, Ue.yMin, Ue.xMax, Ue.yMax],
                        });
                      const cr = gt.x + _e,
                        Hi = gt.y + $e.baseline + Te;
                      (fe[ht * 2] = cr), (fe[ht * 2 + 1] = Hi);
                      const yr = cr + Ue.xMin * $t,
                        Fr = Hi + Ue.yMin * $t,
                        Ar = cr + Ue.xMax * $t,
                        Br = Hi + Ue.yMax * $t;
                      yr < j[0] && (j[0] = yr),
                        Fr < j[1] && (j[1] = Fr),
                        Ar > j[2] && (j[2] = Ar),
                        Br > j[3] && (j[3] = Br),
                        ht % te === 0 &&
                          ((nt = {
                            start: ht,
                            end: ht,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          we.push(nt)),
                        nt.end++;
                      const xr = nt.rect;
                      if (
                        (yr < xr[0] && (xr[0] = yr),
                        Fr < xr[1] && (xr[1] = Fr),
                        Ar > xr[2] && (xr[2] = Ar),
                        Br > xr[3] && (xr[3] = Br),
                        (de[ht] = Nt),
                        (le[ht] = bn),
                        F)
                      ) {
                        const So = ht * 3;
                        (ge[So] = (xt >> 16) & 255),
                          (ge[So + 1] = (xt >> 8) & 255),
                          (ge[So + 2] = xt & 255);
                      }
                    }
                  }
                }
              }),
              xe)
            ) {
              const $e = x.length - Ge;
              $e > 1 && d(xe, Ge, $e);
            }
          }
          const at = [];
          rt.forEach(
            ({
              index: Fe,
              src: Be,
              unitsPerEm: Ge,
              ascender: Ye,
              descender: nt,
              lineHeight: xt,
              capHeight: $e,
              xHeight: qe,
            }) => {
              at[Fe] = {
                src: Be,
                unitsPerEm: Ge,
                ascender: Ye,
                descender: nt,
                lineHeight: xt,
                capHeight: $e,
                xHeight: qe,
              };
            }
          ),
            (ae.typesetting = m() - De),
            V({
              glyphIds: de,
              glyphFontIndices: le,
              glyphPositions: fe,
              glyphData: Me,
              fontData: at,
              caretPositions: xe,
              glyphColors: ge,
              chunkedBounds: we,
              fontSize: T,
              topBaseline: Te + ve[0].baseline,
              blockBounds: [_e, Te - Se, _e + Ae, Te],
              visibleBounds: j,
              timings: ae,
            });
        }
      );
  }
  function u(x, S) {
    a({ ...x, metricsOnly: !0 }, (_) => {
      const [w, T, M, A] = _.blockBounds;
      S({ width: M - w, height: A - T });
    });
  }
  function c(x) {
    let S = x.match(/^([\d.]+)%$/),
      _ = S ? parseFloat(S[1]) : NaN;
    return isNaN(_) ? 0 : _ / 100;
  }
  function d(x, S, _) {
    const w = x[S * 4],
      T = x[S * 4 + 1],
      M = x[S * 4 + 2],
      A = x[S * 4 + 3],
      R = (T - w) / _;
    for (let D = 0; D < _; D++) {
      const P = (S + D) * 4;
      (x[P] = w + R * D),
        (x[P + 1] = w + R * (D + 1)),
        (x[P + 2] = M),
        (x[P + 3] = A);
    }
  }
  function m() {
    return (self.performance || Date).now();
  }
  function g() {
    this.data = [];
  }
  const y = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (g.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / y.length);
      },
      glyphAt(x) {
        let S = g.flyweight;
        return (S.data = this.data), (S.index = x), S;
      },
      splitAt(x) {
        let S = new g();
        return (S.data = this.data.splice(x * y.length)), S;
      },
    }),
    (g.flyweight = y.reduce(
      (x, S, _, w) => (
        Object.defineProperty(x, S, {
          get() {
            return this.data[this.index * y.length + _];
          },
          set(T) {
            this.data[this.index * y.length + _] = T;
          },
        }),
        x
      ),
      { data: null, index: 0 }
    )),
    { typeset: a, measure: u }
  );
}
const Mf = () => (self.performance || Date).now(),
  Ex = QP();
let z2;
function y9(n, e, t, r, i, o, s, a, u, c, d = !0) {
  return d
    ? _9(n, e, t, r, i, o, s, a, u, c).then(
        null,
        (m) => (
          z2 ||
            (console.warn("WebGL SDF generation failed, falling back to JS", m),
            (z2 = !0)),
          V2(n, e, t, r, i, o, s, a, u, c)
        )
      )
    : V2(n, e, t, r, i, o, s, a, u, c);
}
const C0 = [],
  x9 = 5;
let LS = 0;
function t3() {
  const n = Mf();
  for (; C0.length && Mf() - n < x9; ) C0.shift()();
  LS = C0.length ? setTimeout(t3, 0) : 0;
}
const _9 = (...n) =>
    new Promise((e, t) => {
      C0.push(() => {
        const r = Mf();
        try {
          Ex.webgl.generateIntoCanvas(...n), e({ timing: Mf() - r });
        } catch (i) {
          t(i);
        }
      }),
        LS || (LS = setTimeout(t3, 0));
    }),
  S9 = 4,
  w9 = 2e3,
  H2 = {};
let b9 = 0;
function V2(n, e, t, r, i, o, s, a, u, c) {
  const d = "TroikaTextSDFGenerator_JS_" + (b9++ % S9);
  let m = H2[d];
  return (
    m ||
      (m = H2[d] =
        {
          workerModule: $h({
            name: d,
            workerId: d,
            dependencies: [QP, Mf],
            init(g, y) {
              const x = g().javascript.generate;
              return function (...S) {
                const _ = y();
                return { textureData: x(...S), timing: y() - _ };
              };
            },
            getTransferables(g) {
              return [g.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    m.requests++,
    clearTimeout(m.idleTimer),
    m.workerModule(n, e, t, r, i, o).then(({ textureData: g, timing: y }) => {
      const x = Mf(),
        S = new Uint8Array(g.length * 4);
      for (let _ = 0; _ < g.length; _++) S[_ * 4 + c] = g[_];
      return (
        Ex.webglUtils.renderImageData(s, S, a, u, n, e, 1 << (3 - c)),
        (y += Mf() - x),
        --m.requests === 0 &&
          (m.idleTimer = setTimeout(() => {
            e9(d);
          }, w9)),
        { timing: y }
      );
    })
  );
}
function M9(n) {
  n._warm || (Ex.webgl.isSupported(n), (n._warm = !0));
}
const E9 = Ex.webglUtils.resizeWebGLCanvasWithoutClearing,
  am = {
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  T9 = new St();
function ah() {
  return (self.performance || Date).now();
}
const W2 = Object.create(null);
function n3(n, e) {
  n = R9({}, n);
  const t = ah(),
    r = [];
  if (
    (n.font && r.push({ label: "user", src: P9(n.font) }),
    (n.font = r),
    (n.text = "" + n.text),
    (n.sdfGlyphSize = n.sdfGlyphSize || am.sdfGlyphSize),
    (n.unicodeFontsURL = n.unicodeFontsURL || am.unicodeFontsURL),
    n.colorRanges != null)
  ) {
    let m = {};
    for (let g in n.colorRanges)
      if (n.colorRanges.hasOwnProperty(g)) {
        let y = n.colorRanges[g];
        typeof y != "number" && (y = T9.set(y).getHex()), (m[g] = y);
      }
    n.colorRanges = m;
  }
  Object.freeze(n);
  const { textureWidth: i, sdfExponent: o } = am,
    { sdfGlyphSize: s } = n,
    a = (i / s) * 4;
  let u = W2[s];
  if (!u) {
    const m = document.createElement("canvas");
    (m.width = i),
      (m.height = (s * 256) / a),
      (u = W2[s] =
        {
          glyphCount: 0,
          sdfGlyphSize: s,
          sdfCanvas: m,
          sdfTexture: new er(m, void 0, void 0, void 0, Cr, Cr),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (u.sdfTexture.generateMipmaps = !1),
      C9(u);
  }
  const { sdfTexture: c, sdfCanvas: d } = u;
  L9(n).then((m) => {
    const {
        glyphIds: g,
        glyphFontIndices: y,
        fontData: x,
        glyphPositions: S,
        fontSize: _,
        timings: w,
      } = m,
      T = [],
      M = new Float32Array(g.length * 4);
    let A = 0,
      R = 0;
    const D = ah(),
      P = x.map((W) => {
        let $ = u.glyphsByFont.get(W.src);
        return $ || u.glyphsByFont.set(W.src, ($ = new Map())), $;
      });
    g.forEach((W, $) => {
      const K = y[$],
        { src: Z, unitsPerEm: Y } = x[K];
      let re = P[K].get(W);
      if (!re) {
        const { path: ne, pathBounds: ae } = m.glyphData[Z][W],
          J =
            (Math.max(ae[2] - ae[0], ae[3] - ae[1]) / s) *
            (am.sdfMargin * s + 0.5),
          se = u.glyphCount++,
          de = [ae[0] - J, ae[1] - J, ae[2] + J, ae[3] + J];
        P[K].set(W, (re = { path: ne, atlasIndex: se, sdfViewBox: de })),
          T.push(re);
      }
      const { sdfViewBox: G } = re,
        te = S[R++],
        F = S[R++],
        V = _ / Y;
      (M[A++] = te + G[0] * V),
        (M[A++] = F + G[1] * V),
        (M[A++] = te + G[2] * V),
        (M[A++] = F + G[3] * V),
        (g[$] = re.atlasIndex);
    }),
      (w.quads = (w.quads || 0) + (ah() - D));
    const U = ah();
    w.sdf = {};
    const O = d.height,
      L = Math.ceil(u.glyphCount / a),
      H = Math.pow(2, Math.ceil(Math.log2(L * s)));
    H > O &&
      (console.info(`Increasing SDF texture size ${O}->${H}`),
      E9(d, i, H),
      c.dispose()),
      Promise.all(
        T.map((W) =>
          r3(W, u, n.gpuAccelerateSDF).then(({ timing: $ }) => {
            w.sdf[W.atlasIndex] = $;
          })
        )
      ).then(() => {
        T.length && !u.contextLost && (i3(u), (c.needsUpdate = !0)),
          (w.sdfTotal = ah() - U),
          (w.total = ah() - t),
          e(
            Object.freeze({
              parameters: n,
              sdfTexture: c,
              sdfGlyphSize: s,
              sdfExponent: o,
              glyphBounds: M,
              glyphAtlasIndices: g,
              glyphColors: m.glyphColors,
              caretPositions: m.caretPositions,
              chunkedBounds: m.chunkedBounds,
              ascender: m.ascender,
              descender: m.descender,
              lineHeight: m.lineHeight,
              capHeight: m.capHeight,
              xHeight: m.xHeight,
              topBaseline: m.topBaseline,
              blockBounds: m.blockBounds,
              visibleBounds: m.visibleBounds,
              timings: m.timings,
            })
          );
      });
  }),
    Promise.resolve().then(() => {
      u.contextLost || M9(d);
    });
}
function r3(
  { path: n, atlasIndex: e, sdfViewBox: t },
  { sdfGlyphSize: r, sdfCanvas: i, contextLost: o },
  s
) {
  if (o) return Promise.resolve({ timing: -1 });
  const { textureWidth: a, sdfExponent: u } = am,
    c = Math.max(t[2] - t[0], t[3] - t[1]),
    d = Math.floor(e / 4),
    m = (d % (a / r)) * r,
    g = Math.floor(d / (a / r)) * r,
    y = e % 4;
  return y9(r, r, n, t, c, u, i, m, g, y, s);
}
function C9(n) {
  const e = n.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), (n.contextLost = !0);
  }),
    e.addEventListener("webglcontextrestored", (t) => {
      console.log("Context Restored", t), (n.contextLost = !1);
      const r = [];
      n.glyphsByFont.forEach((i) => {
        i.forEach((o) => {
          r.push(r3(o, n, !0));
        });
      }),
        Promise.all(r).then(() => {
          i3(n), (n.sdfTexture.needsUpdate = !0);
        });
    });
}
function A9({ font: n, characters: e, sdfGlyphSize: t }, r) {
  let i = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  n3({ font: n, sdfGlyphSize: t, text: i }, r);
}
function R9(n, e) {
  for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
  return n;
}
let g0;
function P9(n) {
  return (
    g0 || (g0 = typeof document > "u" ? {} : document.createElement("a")),
    (g0.href = n),
    g0.href
  );
}
function i3(n) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = n,
      { width: r, height: i } = e,
      o = n.sdfCanvas.getContext("webgl");
    let s = t.image.data;
    (!s || s.length !== r * i * 4) &&
      ((s = new Uint8Array(r * i * 4)),
      (t.image = { width: r, height: i, data: s }),
      (t.flipY = !1),
      (t.isDataTexture = !0)),
      o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, s);
  }
}
const I9 = $h({
    name: "Typesetter",
    dependencies: [v9, g9, n9],
    init(n, e, t) {
      return n(e, t());
    },
  }),
  L9 = $h({
    name: "Typesetter",
    dependencies: [I9],
    init(n) {
      return function (e) {
        return new Promise((t) => {
          n.typeset(e, t);
        });
      };
    },
    getTransferables(n) {
      const e = [];
      for (let t in n) n[t] && n[t].buffer && e.push(n[t].buffer);
      return e;
    },
  }),
  G2 = {};
function D9(n) {
  let e = G2[n];
  if (!e) {
    const t = new Yl(1, 1, n, n),
      r = t.clone(),
      i = t.attributes,
      o = r.attributes,
      s = new sn(),
      a = i.uv.count;
    for (let u = 0; u < a; u++)
      (o.position.array[u * 3] *= -1), (o.normal.array[u * 3 + 2] *= -1);
    ["position", "normal", "uv"].forEach((u) => {
      s.setAttribute(u, new Pt([...i[u].array, ...o[u].array], i[u].itemSize));
    }),
      s.setIndex([...t.index.array, ...r.index.array.map((u) => u + a)]),
      s.translate(0.5, 0.5, 0),
      (e = G2[n] = s);
  }
  return e;
}
const k9 = "aTroikaGlyphBounds",
  j2 = "aTroikaGlyphIndex",
  O9 = "aTroikaGlyphColor";
class N9 extends Mx {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new fi()),
      (this.boundingBox = new ci());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === ro ? t / 2 : 0, e === Ps ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      (this._detail = e), (typeof e != "number" || e < 1) && (e = 1);
      let t = D9(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }),
        this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, t, r, i, o) {
    B1(this, k9, e, 4),
      B1(this, j2, t, 1),
      B1(this, O9, o, 3),
      (this._blockBounds = r),
      (this._chunkedBounds = i),
      (this.instanceCount = t.length),
      this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: i, floor: o, min: s, max: a, sin: u, cos: c } = Math,
          d = i / 2,
          m = i * 2,
          g = Math.abs(t),
          y = e[0] / g,
          x = e[2] / g,
          S = o((y + d) / m) !== o((x + d) / m) ? -g : s(u(y) * g, u(x) * g),
          _ = o((y - d) / m) !== o((x - d) / m) ? g : a(u(y) * g, u(x) * g),
          w =
            o((y + i) / m) !== o((x + i) / m)
              ? g * 2
              : a(g - c(y) * g, g - c(x) * g);
        r.min.set(S, e[1], t < 0 ? -w : 0), r.max.set(_, e[3], t < 0 ? 0 : w);
      } else r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let t = this.getAttribute(j2).count,
      r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        t = r[i].end;
        let o = r[i].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x) break;
      }
    this.instanceCount = t;
  }
}
function B1(n, e, t, r) {
  const i = n.getAttribute(e);
  t
    ? i && i.array.length === t.length
      ? (i.array.set(t), (i.needsUpdate = !0))
      : (n.setAttribute(e, new Rf(t, r)),
        delete n._maxInstanceCount,
        n.dispose())
    : i && n.deleteAttribute(e);
}
const U9 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  F9 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  B9 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  z9 = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function H9(n) {
  const e = IS(n, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new tt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new dn(0, 0, 0, 0) },
      uTroikaClipRect: { value: new dn(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new tt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new St() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new en() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: U9,
    vertexTransform: F9,
    fragmentDefs: B9,
    fragmentColorTransform: z9,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return (
        i.test(r) &&
          ((r = r
            .replace(i, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          i.test(t) ||
            (t = t.replace(
              e3,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: t, fragmentShader: r }
      );
    },
  });
  return (
    (e.transparent = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const cb = new Xl({ color: 16777215, side: Ps, transparent: !0 }),
  $2 = 8421504,
  X2 = new Gt(),
  v0 = new oe(),
  z1 = new oe(),
  em = [],
  V9 = new oe(),
  H1 = "+x+y";
function Y2(n) {
  return Array.isArray(n) ? n[0] : n;
}
let o3 = () => {
    const n = new ur(new Yl(1, 1), cb);
    return (o3 = () => n), n;
  },
  s3 = () => {
    const n = new ur(new Yl(1, 1, 32, 1), cb);
    return (s3 = () => n), n;
  };
const W9 = { type: "syncstart" },
  G9 = { type: "synccomplete" },
  a3 = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  j9 = a3.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let l3 = class extends ur {
  constructor() {
    const e = new N9();
    super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = $2),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = H1),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(W9),
          n3(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (t) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = t),
                this.geometry.updateGlyphs(
                  t.glyphBounds,
                  t.glyphAtlasIndices,
                  t.blockBounds,
                  t.chunkedBounds,
                  t.glyphColors
                );
              const r = this._queuedSyncs;
              r &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  r.forEach((i) => i && i());
                })),
                this.dispatchEvent(G9),
                e && e();
            }
          )));
  }
  onBeforeRender(e, t, r, i, o, s) {
    this.sync(),
      o.isTroikaTextMaterial && this._prepareForRender(o),
      (o._hadOwnSide = o.hasOwnProperty("side")),
      this.geometry.setSide((o._actualSide = o.side)),
      (o.side = el);
  }
  onAfterRender(e, t, r, i, o, s) {
    o._hadOwnSide ? (o.side = o._actualSide) : delete o.side;
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  get material() {
    let e = this._derivedMaterial;
    const t =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = cb.clone());
    if (
      ((!e || e.baseMaterial !== t) &&
        ((e = this._derivedMaterial = H9(t)),
        t.addEventListener("dispose", function r() {
          t.removeEventListener("dispose", r), e.dispose();
        })),
      this.outlineWidth ||
        this.outlineBlur ||
        this.outlineOffsetX ||
        this.outlineOffsetY)
    ) {
      let r = e._outlineMtl;
      return (
        r ||
          ((r = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (r.isTextOutlineMaterial = !0),
          (r.depthWrite = !1),
          (r.map = null),
          e.addEventListener("dispose", function i() {
            e.removeEventListener("dispose", i), r.dispose();
          })),
        [r, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return Y2(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return Y2(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial,
      r = e.uniforms,
      i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: a, blockBounds: u } = i;
      (r.uTroikaSDFTexture.value = a),
        r.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height),
        (r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize),
        (r.uTroikaSDFExponent.value = i.sdfExponent),
        r.uTroikaTotalBounds.value.fromArray(u),
        (r.uTroikaUseGlyphColors.value = !t && !!i.glyphColors);
      let c = 0,
        d = 0,
        m = 0,
        g,
        y,
        x,
        S = 0,
        _ = 0;
      if (t) {
        let {
          outlineWidth: T,
          outlineOffsetX: M,
          outlineOffsetY: A,
          outlineBlur: R,
          outlineOpacity: D,
        } = this;
        (c = this._parsePercent(T) || 0),
          (d = Math.max(0, this._parsePercent(R) || 0)),
          (g = D),
          (S = this._parsePercent(M) || 0),
          (_ = this._parsePercent(A) || 0);
      } else
        (m = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          m &&
            ((x = this.strokeColor),
            r.uTroikaStrokeColor.value.set(x ?? $2),
            (y = this.strokeOpacity),
            y == null && (y = 1)),
          (g = this.fillOpacity);
      (r.uTroikaDistanceOffset.value = c),
        r.uTroikaPositionOffset.value.set(S, _),
        (r.uTroikaBlurRadius.value = d),
        (r.uTroikaStrokeWidth.value = m),
        (r.uTroikaStrokeOpacity.value = y),
        (r.uTroikaFillOpacity.value = g ?? 1),
        (r.uTroikaCurveRadius.value = this.curveRadius || 0);
      let w = this.clipRect;
      if (w && Array.isArray(w) && w.length === 4)
        r.uTroikaClipRect.value.fromArray(w);
      else {
        const T = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(u[0] - T, u[1] - T, u[2] + T, u[3] + T);
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    (r.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0);
    const o = t ? this.outlineColor || 0 : this.color;
    if (o == null) delete e.color;
    else {
      const a = e.hasOwnProperty("color") ? e.color : (e.color = new St());
      (o !== a._input || typeof o == "object") && a.set((a._input = o));
    }
    let s = this.orientation || H1;
    if (s !== e._orientation) {
      let a = r.uTroikaOrient.value;
      s = s.replace(/[^-+xyz]/g, "");
      let u = s !== H1 && s.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (u) {
        let [, c, d, m, g] = u;
        (v0.set(0, 0, 0)[d] = c === "-" ? 1 : -1),
          (z1.set(0, 0, 0)[g] = m === "-" ? -1 : 1),
          X2.lookAt(V9, v0.cross(z1), z1),
          a.setFromMatrix4(X2);
      } else a.identity();
      e._orientation = s;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/),
        r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, t = new tt()) {
    t.copy(e);
    const r = this.curveRadius;
    return (
      r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t
    );
  }
  worldPositionToTextCoords(e, t = new tt()) {
    return v0.copy(e), this.localPositionToTextCoords(this.worldToLocal(v0), t);
  }
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const o = r.blockBounds,
        s = i ? s3() : o3(),
        a = s.geometry,
        { position: u, uv: c } = a.attributes;
      for (let d = 0; d < c.count; d++) {
        let m = o[0] + c.getX(d) * (o[2] - o[0]);
        const g = o[1] + c.getY(d) * (o[3] - o[1]);
        let y = 0;
        i && ((y = i - Math.cos(m / i) * i), (m = Math.sin(m / i) * i)),
          u.setXYZ(d, m, g, y);
      }
      (a.boundingSphere = this.geometry.boundingSphere),
        (a.boundingBox = this.geometry.boundingBox),
        (s.matrixWorld = this.matrixWorld),
        (s.material.side = this.material.side),
        (em.length = 0),
        s.raycast(e, em);
      for (let d = 0; d < em.length; d++) (em[d].object = this), t.push(em[d]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return (
      super.copy(e),
      (this.geometry = t),
      j9.forEach((r) => {
        this[r] = e[r];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
a3.forEach((n) => {
  const e = "_private_" + n;
  Object.defineProperty(l3.prototype, n, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && ((this[e] = t), (this._needsSync = !0));
    },
  });
});
const wy = X.forwardRef(
    (
      {
        sdfGlyphSize: n = 64,
        anchorX: e = "center",
        anchorY: t = "middle",
        font: r,
        fontSize: i = 1,
        children: o,
        characters: s,
        onSync: a,
        ...u
      },
      c
    ) => {
      const d = ua(({ invalidate: x }) => x),
        [m] = X.useState(() => new l3()),
        [g, y] = X.useMemo(() => {
          const x = [];
          let S = "";
          return (
            X.Children.forEach(o, (_) => {
              typeof _ == "string" || typeof _ == "number"
                ? (S += _)
                : x.push(_);
            }),
            [x, S]
          );
        }, [o]);
      return (
        AP(
          () => new Promise((x) => A9({ font: r, characters: s }, x)),
          ["troika-text", r, s]
        ),
        X.useLayoutEffect(
          () =>
            void m.sync(() => {
              d(), a && a(m);
            })
        ),
        X.useEffect(() => () => m.dispose(), [m]),
        X.createElement(
          "primitive",
          ue(
            {
              object: m,
              ref: c,
              font: r,
              text: y,
              anchorX: e,
              anchorY: t,
              fontSize: i,
              sdfGlyphSize: n,
            },
            u
          ),
          g
        )
      );
    }
  ),
  V1 = (n) => n === Object(n) && !Array.isArray(n) && typeof n != "function";
function fb(n, e) {
  const t = ua((o) => o.gl),
    r = xg(wx, V1(n) ? Object.values(n) : n);
  return (
    X.useLayoutEffect(() => {
      e == null || e(r);
    }, [e]),
    X.useEffect(() => {
      if ("initTexture" in t) {
        let o = [];
        Array.isArray(r)
          ? (o = r)
          : r instanceof er
          ? (o = [r])
          : V1(r) && (o = Object.values(r)),
          o.forEach((s) => {
            s instanceof er && t.initTexture(s);
          });
      }
    }, [t, r]),
    X.useMemo(() => {
      if (V1(n)) {
        const o = {};
        let s = 0;
        for (const a in n) o[a] = r[s++];
        return o;
      } else return r;
    }, [n, r])
  );
}
fb.preload = (n) => xg.preload(wx, n);
fb.clear = (n) => xg.clear(wx, n);
const u3 = X.forwardRef(
    (
      {
        makeDefault: n,
        camera: e,
        regress: t,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: o = !1,
        onChange: s,
        onStart: a,
        onEnd: u,
        ...c
      },
      d
    ) => {
      const m = ua((D) => D.invalidate),
        g = ua((D) => D.camera),
        y = ua((D) => D.gl),
        x = ua((D) => D.events),
        S = ua((D) => D.setEvents),
        _ = ua((D) => D.set),
        w = ua((D) => D.get),
        T = ua((D) => D.performance),
        M = e || g,
        A = r || x.connected || y.domElement,
        R = X.useMemo(() => new $G(M), [M]);
      return (
        yg(() => {
          R.enabled && R.update();
        }, -1),
        X.useEffect(
          () => (
            o && R.connect(o === !0 ? A : o),
            R.connect(A),
            () => void R.dispose()
          ),
          [o, A, t, R, m]
        ),
        X.useEffect(() => {
          const D = (O) => {
              m(), t && T.regress(), s && s(O);
            },
            P = (O) => {
              a && a(O);
            },
            U = (O) => {
              u && u(O);
            };
          return (
            R.addEventListener("change", D),
            R.addEventListener("start", P),
            R.addEventListener("end", U),
            () => {
              R.removeEventListener("start", P),
                R.removeEventListener("end", U),
                R.removeEventListener("change", D);
            }
          );
        }, [s, a, u, R, m, S]),
        X.useEffect(() => {
          if (n) {
            const D = w().controls;
            return _({ controls: R }), () => _({ controls: D });
          }
        }, [n, R]),
        X.createElement(
          "primitive",
          ue({ ref: d, object: R, enableDamping: i }, c)
        )
      );
    }
  ),
  $9 = "images/contractImage-CFOn4leh.png";
function X9({ nodes: n }) {
  const { contractAnimation: e } = Qu((s) => s.simulation),
    t = X.useRef(),
    [r, i] = X.useState(0),
    o = fb($9);
  return (
    X.useEffect(() => {
      e && i(0);
    }, [e]),
    yg((s, a) => {
      e && r < 1 && i((u) => Math.min(u + a / 8, 3));
    }),
    e
      ? Q.jsx("group", {
          ref: t,
          children: n.map((s, a) => {
            const u = [s.position[0] * 1.6, 2, s.position[2] * 1.6],
              c = s.position,
              d = u[0] + (c[0] - u[0]) * r,
              m = u[1] + (c[1] - u[1]) * r,
              g = u[2] + (c[2] - u[2]) * r;
            return Q.jsxs(
              "mesh",
              {
                position: [d, m, g],
                children: [
                  Q.jsx("boxGeometry", { args: [1.9, 1.9, 1.9] }),
                  Q.jsx("meshBasicMaterial", {
                    map: o,
                    transparent: !0,
                    opacity: 1 - r,
                  }),
                ],
              },
              a
            );
          }),
        })
      : null
  );
}
Sn.enabled = !0;
const y0 = 5,
  q2 = 1,
  ja = Array.from({ length: 10 }, (n, e) => {
    const t = (e / 10) * 2 * Math.PI,
      r = Math.cos(t) * y0,
      i = Math.sin(t) * y0,
      o = Math.cos(t) * (y0 + q2),
      s = Math.sin(t) * (y0 + q2);
    return {
      id: e,
      position: [r, 0, i],
      labelPosition: [o, 0.4, s],
      label: ` ${e + 1}`,
    };
  }),
  c3 = [];
for (let n = 0; n < ja.length; n++)
  for (let e = n + 1; e < ja.length; e++)
    c3.push({ start: ja[n].position, end: ja[e].position, key: `${n}-${e}` });
function Y9({
  position: n,
  label: e,
  isValidator: t,
  isSender: r,
  isReceiver: i,
  isHighlighted: o,
  phase: s,
}) {
  const a = X.useRef();
  yg(({ camera: c }) => {
    a.current && a.current.quaternion.copy(c.quaternion);
  });
  let u = "#000000";
  return (
    s === "transaction" && r
      ? (u = "red")
      : s === "transaction" && i
      ? (u = "#2e7d32")
      : t && o && (u = "blue"),
    Q.jsxs("group", {
      position: n,
      scale: [0.5, 0.5, 0.5],
      children: [
        Q.jsxs("mesh", {
          children: [
            Q.jsx("sphereGeometry", { args: [0.7, 32, 32] }),
            Q.jsx("meshBasicMaterial", { color: u }),
          ],
        }),
        Q.jsx(wy, {
          ref: a,
          position: [0, 1, 0],
          fontSize: 0.7,
          color: "white",
          anchorX: "center",
          anchorY: "middle",
          fontWeight: 1500,
          children: e,
        }),
      ],
    })
  );
}
function q9({ start: n, end: e, isActive: t }) {
  return Q.jsx(ZP, {
    points: [n, e],
    color: t ? "yellow" : "#00695c",
    lineWidth: t ? 2 : 0.5,
  });
}
function K9({ start: n, end: e, progress: t }) {
  const r = Qu((o) => o.simulation.encryptedData),
    i = [
      n[0] + (e[0] - n[0]) * t,
      n[1] + (e[1] - n[1]) * t,
      n[2] + (e[2] - n[2]) * t,
    ];
  return Q.jsxs("mesh", {
    position: i,
    children: [
      Q.jsx("boxGeometry", { args: [0.3, 0.3, 0.3] }),
      Q.jsx("meshBasicMaterial", { color: "#2e7d32" }),
      Q.jsx(wy, {
        position: [0, 0, 0.2],
        fontSize: 0.2,
        color: "white",
        anchorX: "center",
        anchorY: "middle",
        children: r,
      }),
    ],
  });
}
function Z9({ start: n, end: e, progress: t }) {
  const r = [
    n[0] + (e[0] - n[0]) * t,
    n[1] + (e[1] - n[1]) * t,
    n[2] + (e[2] - n[2]) * t,
  ];
  return Q.jsxs("mesh", {
    position: r,
    children: [
      Q.jsx("boxGeometry", { args: [0.3, 0.3, 0.3] }),
      Q.jsx("meshBasicMaterial", { color: "blue" }),
    ],
  });
}
function J9({ controlsRef: n }) {
  const e = OS(),
    {
      sender: t,
      receiver: r,
      validator: i,
      phase: o,
      transactionProgress: s,
      contractAnimation: a,
    } = Qu((y) => y.simulation);
  console.log("Contract animation", a);
  const [u, c] = X.useState(0);
  X.useEffect(() => {
    console.log("Scene phase:", o), o === "idle" && c(0);
  }, [o]),
    yg((y, x) => {
      if (o === "transaction" && s < 1) {
        const S = Math.min(s + x / 5, 1);
        e(O_(S)), S >= 1 && e(F4());
      } else if (o === "validation")
        c((S) => S + x), u >= 2 && (e(B4()), e(O_(0)), c(0));
      else if (o === "broadcast" && s < 1) {
        const S = Math.min(s + x / 4, 1);
        e(O_(S)), S >= 1 && setTimeout(() => e(z4()), 1e3);
      }
    });
  const d = t !== null ? ja[t] : null,
    m = r !== null ? ja[r] : null,
    g = i !== null ? ja[i] : null;
  return Q.jsxs(Q.Fragment, {
    children: [
      Q.jsx("ambientLight", { intensity: 0.5 }),
      Q.jsx("pointLight", { position: [10, 10, 10], intensity: 1 }),
      ja.map((y) =>
        Q.jsx(
          Y9,
          {
            position: y.position,
            label: y.label,
            isValidator: g && y.id === g.id,
            isSender: d && y.id === d.id,
            isReceiver: m && y.id === m.id,
            isHighlighted:
              o === "validation" || o === "broadcast" || o === "complete",
            phase: o,
          },
          y.id
        )
      ),
      c3.map((y) => {
        const x =
          o === "transaction" &&
          d &&
          m &&
          ((y.start === d.position && y.end === m.position) ||
            (y.start === m.position && y.end === d.position));
        return Q.jsx(q9, { start: y.start, end: y.end, isActive: x }, y.key);
      }),
      o === "transaction" &&
        d &&
        m &&
        s < 1 &&
        Q.jsx(K9, { start: d.position, end: m.position, progress: s }),
      o === "broadcast" &&
        g &&
        ja
          .filter((y) => y.id !== g.id)
          .map((y) =>
            Q.jsx(
              Z9,
              { start: g.position, end: y.position, progress: s },
              `broadcast-${y.id}`
            )
          ),
      (o === "validation" || o === "broadcast" || o === "complete") &&
        g &&
        Q.jsx(Q.Fragment, {}),
      a && Q.jsx(X9, { nodes: ja }),
      Q.jsx(u3, {
        ref: n,
        enablePan: !0,
        enableZoom: !0,
        enableRotate: !0,
        target: [0, 0, 0],
      }),
    ],
  });
}
function K2({ position: n, opacity: e = 1 }) {
  return Q.jsxs("mesh", {
    position: n,
    scale: [1, 1, 1],
    children: [
      Q.jsx("boxGeometry", { args: [0.8, 0.8, 0.8] }),
      Q.jsx("meshBasicMaterial", {
        color: "#2e7d32",
        opacity: e,
        transparent: !0,
      }),
    ],
  });
}
function Q9({ start: n, end: e }) {
  return Q.jsx(ZP, { points: [n, e], color: "#b0bec5", lineWidth: 0.5 });
}
function ej({ phase: n }) {
  const [e, t] = X.useState([
      { id: 1, x: -12 },
      { id: 2, x: -9 },
      { id: 3, x: -6 },
      { id: 4, x: -3 },
    ]),
    [r, i] = X.useState(null),
    [o, s] = X.useState(null),
    [a, u] = X.useState(!1),
    [c, d] = X.useState(null),
    m = [
      { id: 1, x: -12 },
      { id: 2, x: -9 },
      { id: 3, x: -6 },
      { id: 4, x: -3 },
    ];
  X.useEffect(() => {
    if ((console.log("Ledger phase:", n, "LedgerBlocks:", e), n === "idle"))
      t(m), i(null), s(null), u(!1), d(null), console.log("Ledger reset");
    else if (n === "broadcast" && !r && !a) {
      const y = e.length + 1;
      i({ id: y }), s(4), u(!0), console.log("New block initialized at x=4.0");
    } else
      n === "complete" &&
        (u(!1), console.log("Reset hasAddedBlock for next cycle"));
  }, [n, r, a, e.length]),
    yg((y, x) => {
      r &&
        o !== null &&
        s((S) => {
          const w = Math.max(S - (x * 4) / 2, 0);
          return (
            console.log(`New block x: ${w}`),
            w <= 0 &&
              (t((T) => [...T, { id: r.id, x: 0 }]),
              d(r.id),
              i(null),
              s(null),
              console.log("New block added to ledger at x=0.0, id:", r.id)),
            w
          );
        });
    });
  const g = [];
  for (let y = 0; y < e.length - 1; y++)
    g.push({
      start: [e[y].x + 0.4, 0, 0],
      end: [e[y + 1].x - 0.4, 0, 0],
      key: `line-${y}`,
    });
  if (r && o !== null && o <= 0.5 && e.length > 0) {
    const y = e[e.length - 1].x;
    g.push({
      start: [y + 0.4, 0, 0],
      end: [o - 0.4, 0, 0],
      key: `line-new-${r.id}`,
    }),
      console.log(`Line: start=${y + 0.4}, end=${o - 0.4}`);
  }
  return Q.jsxs(Q.Fragment, {
    children: [
      Q.jsx("ambientLight", { intensity: 0.5 }),
      Q.jsx("pointLight", { position: [10, 10, 10], intensity: 1 }),
      e.map((y) =>
        Q.jsxs(
          Is.Fragment,
          {
            children: [
              Q.jsx(K2, { position: [y.x, 0, 0] }),
              y.id === c &&
                Q.jsx(wy, {
                  position: [y.x, -0.8, 0.1],
                  fontSize: 0.5,
                  color: "white",
                  anchorX: "center",
                  anchorY: "middle",
                  children: "Newly Mined Block",
                }),
            ],
          },
          y.id
        )
      ),
      r &&
        o !== null &&
        Q.jsx(K2, { position: [o, 0, 0], opacity: (4 - o) / 4 }, `new-${r.id}`),
      g.map((y) => Q.jsx(Q9, { start: y.start, end: y.end }, y.key)),
      Q.jsx(wy, {
        position: [-7.5, -1, 0],
        fontSize: 0.5,
        color: "white",
        anchorX: "center",
        anchorY: "middle",
        children: "Ledger",
      }),
    ],
  });
}
function tj({ phase: n }) {
  const [e, t] = X.useState("2d"),
    r = X.useRef(),
    i = () => {
      t("3d");
    };
  return (
    X.useEffect(() => {
      console.log("Ledger viewMode:", e);
      const o = r.current;
      if (o)
        return (
          o.addEventListener("start", i),
          () => o.removeEventListener("start", i)
        );
    }, []),
    Q.jsx(fn, {
      sx: {
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
      },
      children: Q.jsxs($P, {
        orthographic: e === "2d",
        camera:
          e === "2d"
            ? {
                position: [0, 0, 10],
                zoom: 40,
                up: [0, 1, 0],
                near: 0.1,
                far: 1e3,
              }
            : { position: [0, 15, 20], fov: 60, near: 0.1, far: 1e3 },
        style: { width: "100%", height: "150px", maxHeight: "700px" },
        children: [
          Q.jsx(ej, { phase: n }),
          Q.jsx(u3, {
            ref: r,
            enablePan: !0,
            enableZoom: !0,
            enableRotate: !0,
            target: [-6, 0, 0],
          }),
        ],
      }),
    })
  );
}
function nj() {
  return Q.jsx(fn, {
    sx: {
      width: "100%",
      backgroundColor: "#1a202c",
      color: "white",
      padding: 2,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
    },
    children: Q.jsxs(tA, {
      spacing: 1,
      children: [
        Q.jsxs(fn, {
          display: "flex",
          alignItems: "center",
          children: [
            Q.jsx(fn, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "red",
                marginRight: 1,
              },
            }),
            Q.jsx(vn, { variant: "body2", children: "Loser" }),
          ],
        }),
        Q.jsxs(fn, {
          display: "flex",
          alignItems: "center",
          children: [
            Q.jsx(fn, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "#2e7d32",
                marginRight: 1,
              },
            }),
            Q.jsx(vn, { variant: "body2", children: "Winner" }),
          ],
        }),
        Q.jsxs(fn, {
          display: "flex",
          alignItems: "center",
          children: [
            Q.jsx(fn, {
              sx: {
                width: 20,
                height: 20,
                backgroundColor: "blue",
                marginRight: 1,
              },
            }),
            Q.jsx(vn, { variant: "body2", children: "Miner" }),
          ],
        }),
      ],
    }),
  });
}
function rj() {
  const { phase: n, validatorName: e } = Qu((o) => o.simulation),
    [t, r] = X.useState([]);
  X.useEffect(() => {
    n === "idle" ||
      (n === "transaction" && !t.includes("step1")
        ? r((o) => [...o, "step1"])
        : n === "broadcast" && !t.includes("step2")
        ? r((o) => [...o, "step2"])
        : n === "complete" &&
          !t.includes("step3") &&
          r((o) => [...o, "step3"]));
  }, [n, t]);
  const i = (o) => {
    switch (o) {
      case "step1":
        return "Step 1: The loser in the Bet Game initiates a transaction to transfer the reward to the winner.";
      case "step2":
        return `Step 2: Validator node ${e} verifies the transaction, creates a new block, and propagates it to all nodes in the network.`;
      case "step3":
        return "Step 3: The transaction is finalized on the blockchain. The deployed smart contract enforces predefined rules to ensure trust and transparency. The validator verifies the transfer of money from the losing player to the winning player, records the transaction in a new block, and synchronizes the updated ledger across all nodes, demonstrating decentralized consensus.";
      default:
        return "";
    }
  };
  return Q.jsx(fn, {
    sx: {
      width: "100%",
      backgroundColor: "#1a202c",
      color: "white",
      padding: { xs: 2, sm: 3 },
      display: "flex",
      flexDirection: "column",
      overflow: "auto",
      flexGrow: 1,
      "&::-webkit-scrollbar": { display: "none" },
      scrollbarWidth: "none",
      msOverflowStyle: "none",
    },
    children: Q.jsxs(tA, {
      spacing: 1.5,
      children: [
        t.map((o, s) =>
          Q.jsx(
            vn,
            {
              variant: "body2",
              sx: {
                lineHeight: 1.7,
                fontSize: { xs: "0.85rem", sm: "0.95rem", md: "1rem" },
                whiteSpace: "normal",
                overflowWrap: "break-word",
                display: "block",
                paddingRight: { xs: 1, sm: 3, md: 5 },
                color: o === "step3" ? "#FFD700" : "white",
              },
              children: i(o),
            },
            s
          )
        ),
        Q.jsx(nj, {}),
        Q.jsxs(fn, {
          sx: { mt: 2, border: "1px solid #555", borderRadius: 2, p: 2 },
          children: [
            Q.jsx(vn, {
              variant: "h6",
              sx: { fontSize: { xs: "1rem", md: "1.25rem", color: "white" } },
              children: "Controls",
            }),
            Q.jsx(vn, {
              variant: "body2",
              sx: {
                fontSize: {
                  xs: "0.85rem",
                  sm: "0.95rem",
                  md: "1rem",
                  color: "white",
                },
                mt: 1,
              },
              children:
                " Left-click + drag  Rotate the figure (vertically & horizontally).",
            }),
            Q.jsx(vn, {
              variant: "body2",
              sx: {
                fontSize: {
                  xs: "0.85rem",
                  sm: "0.95rem",
                  md: "1rem",
                  color: "white",
                },
              },
              children: " Scroll wheel  Zoom in / Zoom out.",
            }),
          ],
        }),
      ],
    }),
  });
}
function ij() {
  const [n, e] = X.useState("2d"),
    t = X.useRef(),
    {
      phase: r,
      contractAnimation: i,
      smartContract: o,
      deploying: s,
      contractDeployed: a,
      winner: u,
      validator: c,
      sender: d,
    } = Qu((w) => w.simulation),
    m = Array.from({ length: 10 }, (w, T) => ({
      id: T,
      name: `User ${T + 1}`,
    })),
    g = () => {
      e("3d");
    };
  X.useEffect(() => {
    console.log("DecagonSimulation phase:", r);
    const w = t.current;
    if (w)
      return (
        w.addEventListener("start", g), () => w.removeEventListener("start", g)
      );
  }, [r]);
  const [y, x] = X.useState(
      "This is the existing blockchain network where the smart contract you created will be deployed"
    ),
    [S, _] = X.useState("#2196F3");
  return (
    X.useEffect(() => {
      var w;
      r === "transaction"
        ? (_("#2196f3"),
          x(
            `Sending reward money to ${u} from ${
              m.find((T) => T.id === d).name
            }`
          ))
        : r === "broadcast"
        ? (_("#00acc1"),
          x(
            `${
              (w = m.find((T) => T.id === c)) == null ? void 0 : w.name
            } is sending the verification results to each nodes (players) in the blockchain network`
          ))
        : r === "complete"
        ? (_("#4caf50"),
          x("Transaction completed and verified successfully"),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 4e3))
        : (_("#2196F3"),
          x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          ));
    }, [r]),
    X.useEffect(() => {
      var w;
      r === "validation" &&
        (_("#fbc02d"),
        x(
          `${
            (w = m.find((T) => T.id === c)) == null ? void 0 : w.name
          } is verifying the transaction`
        ));
    }, [r === "validation"]),
    X.useEffect(() => {
      s
        ? (_("#ffeb3b"), x("Smart contract deployment in progress"))
        : (_("#2196F3"),
          x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          ));
    }, [s]),
    X.useEffect(() => {
      a
        ? (_("#4caf50"),
          x("Smart contract deployed on blockchain network"),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 3e3))
        : x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          );
    }, [a]),
    X.useEffect(() => {
      u
        ? (_("#4CAF50"),
          x(`${u} is the winner in the Bet Game`),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 3e3))
        : x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          );
    }, [u]),
    X.useEffect(() => {
      var w;
      c
        ? (_("#4CAF50"),
          x(
            `${
              (w = m.find((T) => T.id === c)) == null ? void 0 : w.name
            } is selected as the miner to validate the transaction`
          ),
          setTimeout(() => {
            _("#2196F3"),
              x(
                "This is the existing blockchain network where the smart contract you created will be deployed"
              );
          }, 3e3))
        : x(
            "This is the existing blockchain network where the smart contract you created will be deployed"
          );
    }, [c]),
    Q.jsxs(fn, {
      sx: {
        display: "flex",
        height: "100%",
        width: "100%",
        flexDirection: { xs: "column", md: "row" },
        "&::-webkit-scrollbar": { display: "none" },
        scrollbarWidth: "none",
        msOverflowStyle: "none",
      },
      children: [
        Q.jsxs(fn, {
          sx: {
            paddingLeft: { xs: "0px", md: "30px" },
            width: { xs: "100%", md: "75%" },
            height: { xs: "60%", md: "100%" },
            display: "flex",
            flexDirection: "column",
          },
          children: [
            Q.jsx(fn, {
              sx: {
                padding: { xs: 0.5, md: 1 },
                textAlign: "center",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
              },
            }),
            Q.jsx(fn, {
              sx: { flexGrow: 1, overflow: "hidden" },
              children: Q.jsx($P, {
                orthographic: n === "2d",
                camera:
                  n === "2d"
                    ? {
                        position: [0, 10, 0],
                        zoom: 30,
                        up: [0, 1, 0],
                        near: 0.1,
                        far: 1e3,
                      }
                    : { position: [0, 10, 15], fov: 60, near: 0.1, far: 1e3 },
                style: { width: "100%", height: "100%" },
                gl: { outputEncoding: void 0 },
                children: Q.jsx(J9, { controlsRef: t }),
              }),
            }),
            Q.jsx(tj, { phase: r }),
            Q.jsx(fn, {
              sx: {
                paddingLeft: { xs: "8px", md: "200px" },
                bgcolor: S,
                borderRadius: 2,
                mx: { xs: 1, sm: 2 },
                my: 1,
                px: { xs: 1, md: 2 },
                py: { xs: 0.5, md: 1 },
                textAlign: "left",
                opacity: 1,
                transform: "translateX(0)",
                transition: "opacity 0.6s ease, transform 0.6s ease",
              },
              className: "message-box",
              children: Q.jsx(vn, {
                variant: "body2",
                sx: {
                  color: s ? "black" : "white",
                  fontSize: { xs: "1rem", sm: "1.25rem" },
                },
                children: y,
              }),
            }),
          ],
        }),
        Q.jsx(fn, {
          sx: {
            width: { xs: "100%", md: "25%" },
            minWidth: { xs: "100%", sm: "280px", md: "280px" },
            display: "flex",
            flexDirection: "column",
            height: { xs: "40%", md: "100%" },
            boxSizing: "border-box",
            padding: { xs: 0.5, md: 0.5 },
            "&::-webkit-scrollbar": { display: "none" },
            scrollbarWidth: "none",
            msOverflowStyle: "none",
          },
          children: Q.jsx(rj, {}),
        }),
      ],
    })
  );
}
function oj(n) {
  const { rootElementName: e = "" } = n,
    [t, r] = X.useState(e.toUpperCase()),
    i = X.useCallback((o) => {
      var s;
      r((s = o == null ? void 0 : o.tagName) != null ? s : "");
    }, []);
  return [t, i];
}
function sj(n = {}) {
  const {
      disabled: e = !1,
      focusableWhenDisabled: t,
      href: r,
      rootRef: i,
      tabIndex: o,
      to: s,
      type: a,
      rootElementName: u,
    } = n,
    c = X.useRef(null),
    [d, m] = X.useState(!1),
    { isFocusVisibleRef: g, onFocus: y, onBlur: x, ref: S } = JS(),
    [_, w] = X.useState(!1);
  e && !t && _ && w(!1),
    X.useEffect(() => {
      g.current = _;
    }, [_, g]);
  const [T, M] = oj({ rootElementName: u ?? (r || s ? "a" : void 0) }),
    A = (Z) => (Y) => {
      var re;
      _ && Y.preventDefault(), (re = Z.onMouseLeave) == null || re.call(Z, Y);
    },
    R = (Z) => (Y) => {
      var re;
      x(Y), g.current === !1 && w(!1), (re = Z.onBlur) == null || re.call(Z, Y);
    },
    D = (Z) => (Y) => {
      var re;
      if (
        (c.current || (c.current = Y.currentTarget), y(Y), g.current === !0)
      ) {
        var G;
        w(!0), (G = Z.onFocusVisible) == null || G.call(Z, Y);
      }
      (re = Z.onFocus) == null || re.call(Z, Y);
    },
    P = () => {
      const Z = c.current;
      return (
        T === "BUTTON" ||
        (T === "INPUT" &&
          ["button", "submit", "reset"].includes(
            Z == null ? void 0 : Z.type
          )) ||
        (T === "A" && (Z == null ? void 0 : Z.href))
      );
    },
    U = (Z) => (Y) => {
      if (!e) {
        var re;
        (re = Z.onClick) == null || re.call(Z, Y);
      }
    },
    O = (Z) => (Y) => {
      var re;
      e ||
        (m(!0),
        document.addEventListener(
          "mouseup",
          () => {
            m(!1);
          },
          { once: !0 }
        )),
        (re = Z.onMouseDown) == null || re.call(Z, Y);
    },
    L = (Z) => (Y) => {
      var re;
      if (
        ((re = Z.onKeyDown) == null || re.call(Z, Y),
        !Y.defaultMuiPrevented &&
          (Y.target === Y.currentTarget &&
            !P() &&
            Y.key === " " &&
            Y.preventDefault(),
          Y.target === Y.currentTarget && Y.key === " " && !e && m(!0),
          Y.target === Y.currentTarget && !P() && Y.key === "Enter" && !e))
      ) {
        var G;
        (G = Z.onClick) == null || G.call(Z, Y), Y.preventDefault();
      }
    },
    H = (Z) => (Y) => {
      var re;
      if (
        (Y.target === Y.currentTarget && m(!1),
        (re = Z.onKeyUp) == null || re.call(Z, Y),
        Y.target === Y.currentTarget &&
          !P() &&
          !e &&
          Y.key === " " &&
          !Y.defaultMuiPrevented)
      ) {
        var G;
        (G = Z.onClick) == null || G.call(Z, Y);
      }
    },
    W = ri(M, i, S, c),
    $ = {};
  return (
    o !== void 0 && ($.tabIndex = o),
    T === "BUTTON"
      ? (($.type = a ?? "button"),
        t ? ($["aria-disabled"] = e) : ($.disabled = e))
      : T === "INPUT"
      ? a &&
        ["button", "submit", "reset"].includes(a) &&
        (t ? ($["aria-disabled"] = e) : ($.disabled = e))
      : T !== "" &&
        (!r && !s && (($.role = "button"), ($.tabIndex = o ?? 0)),
        e && (($["aria-disabled"] = e), ($.tabIndex = t ? o ?? 0 : -1))),
    {
      getRootProps: (Z = {}) => {
        const Y = ue({}, I0(n), I0(Z)),
          re = ue({ type: a }, Y, $, Z, {
            onBlur: R(Y),
            onClick: U(Y),
            onFocus: D(Y),
            onKeyDown: L(Y),
            onKeyUp: H(Y),
            onMouseDown: O(Y),
            onMouseLeave: A(Y),
            ref: W,
          });
        return delete re.onFocusVisible, re;
      },
      focusVisible: _,
      setFocusVisible: w,
      active: d,
      rootRef: W,
    }
  );
}
const f3 = "$$joy",
  aj = ue({}, Fh, {
    borderRadius: { themeKey: "radius" },
    boxShadow: { themeKey: "shadow" },
    fontFamily: { themeKey: "fontFamily" },
    fontSize: { themeKey: "fontSize" },
    fontWeight: { themeKey: "fontWeight" },
    letterSpacing: { themeKey: "letterSpacing" },
    lineHeight: { themeKey: "lineHeight" },
  }),
  tm = {
    grey: {
      50: "#FBFCFE",
      100: "#F0F4F8",
      200: "#DDE7EE",
      300: "#CDD7E1",
      400: "#9FA6AD",
      500: "#636B74",
      600: "#555E68",
      700: "#32383E",
      800: "#171A1C",
      900: "#0B0D0E",
    },
    blue: {
      50: "#EDF5FD",
      100: "#E3EFFB",
      200: "#C7DFF7",
      300: "#97C3F0",
      400: "#4393E4",
      500: "#0B6BCB",
      600: "#185EA5",
      700: "#12467B",
      800: "#0A2744",
      900: "#051423",
    },
    yellow: {
      50: "#FEFAF6",
      100: "#FDF0E1",
      200: "#FCE1C2",
      300: "#F3C896",
      400: "#EA9A3E",
      500: "#9A5B13",
      600: "#72430D",
      700: "#492B08",
      800: "#2E1B05",
      900: "#1D1002",
    },
    red: {
      50: "#FEF6F6",
      100: "#FCE4E4",
      200: "#F7C5C5",
      300: "#F09898",
      400: "#E47474",
      500: "#C41C1C",
      600: "#A51818",
      700: "#7D1212",
      800: "#430A0A",
      900: "#240505",
    },
    green: {
      50: "#F6FEF6",
      100: "#E3FBE3",
      200: "#C7F7C7",
      300: "#A1E8A1",
      400: "#51BC51",
      500: "#1F7A1F",
      600: "#136C13",
      700: "#0A470A",
      800: "#042F04",
      900: "#021D02",
    },
  };
function lj(n) {
  var e;
  return (
    !!n[0].match(/^(typography|variants|breakpoints)$/) ||
    !!n[0].match(/sxConfig$/) ||
    (n[0] === "palette" && !!((e = n[1]) != null && e.match(/^(mode)$/))) ||
    (n[0] === "focus" && n[1] !== "thickness")
  );
}
const db = (n, e) => Fn(n, e, "Mui"),
  d3 = (n, e) => Ln(n, e, "Mui"),
  uj = (n) =>
    n &&
    typeof n == "object" &&
    Object.keys(n).some((e) => {
      var t;
      return (t = e.match) == null
        ? void 0
        : t.call(
            e,
            /^(plain(Hover|Active|Disabled)?(Color|Bg)|outlined(Hover|Active|Disabled)?(Color|Border|Bg)|soft(Hover|Active|Disabled)?(Color|Bg)|solid(Hover|Active|Disabled)?(Color|Bg))$/
          );
    }),
  Z2 = (n, e, t) => {
    e.includes("Color") && (n.color = t),
      e.includes("Bg") && (n.backgroundColor = t),
      e.includes("Border") && (n.borderColor = t);
  },
  J2 = (n, e, t) => {
    const r = {};
    return (
      Object.entries(e || {}).forEach(([i, o]) => {
        if (i.match(new RegExp(`${n}(color|bg|border)`, "i")) && o) {
          const s = t ? t(i) : o;
          i.includes("Disabled") &&
            ((r.pointerEvents = "none"),
            (r.cursor = "default"),
            (r["--Icon-color"] = "currentColor")),
            i.match(/(Hover|Active|Disabled)/) ||
              (r["--variant-borderWidth"] ||
                (r["--variant-borderWidth"] = "0px"),
              i.includes("Border") &&
                ((r["--variant-borderWidth"] = "1px"),
                (r.border = "var(--variant-borderWidth) solid"))),
            Z2(r, i, s);
        }
      }),
      r
    );
  },
  Qi = (n, e) => {
    let t = {};
    if (e) {
      const { getCssVar: r, palette: i } = e;
      Object.entries(i).forEach((o) => {
        const [s, a] = o;
        uj(a) &&
          typeof a == "object" &&
          (t = ue({}, t, {
            [s]: J2(
              n,
              a,
              (u) => `var(--variant-${u}, ${r(`palette-${s}-${u}`, i[s][u])})`
            ),
          }));
      });
    }
    return (
      (t.context = J2(n, {
        plainColor: "var(--variant-plainColor)",
        plainHoverColor: "var(--variant-plainHoverColor)",
        plainHoverBg: "var(--variant-plainHoverBg)",
        plainActiveBg: "var(--variant-plainActiveBg)",
        plainDisabledColor: "var(--variant-plainDisabledColor)",
        outlinedColor: "var(--variant-outlinedColor)",
        outlinedBorder: "var(--variant-outlinedBorder)",
        outlinedHoverColor: "var(--variant-outlinedHoverColor)",
        outlinedHoverBorder: "var(--variant-outlinedHoverBorder)",
        outlinedHoverBg: "var(--variant-outlinedHoverBg)",
        outlinedActiveBg: "var(--variant-outlinedActiveBg)",
        outlinedDisabledColor: "var(--variant-outlinedDisabledColor)",
        outlinedDisabledBorder: "var(--variant-outlinedDisabledBorder)",
        softColor: "var(--variant-softColor)",
        softBg: "var(--variant-softBg)",
        softHoverColor: "var(--variant-softHoverColor)",
        softHoverBg: "var(--variant-softHoverBg)",
        softActiveBg: "var(--variant-softActiveBg)",
        softDisabledColor: "var(--variant-softDisabledColor)",
        softDisabledBg: "var(--variant-softDisabledBg)",
        solidColor: "var(--variant-solidColor)",
        solidBg: "var(--variant-solidBg)",
        solidHoverBg: "var(--variant-solidHoverBg)",
        solidActiveBg: "var(--variant-solidActiveBg)",
        solidDisabledColor: "var(--variant-solidDisabledColor)",
        solidDisabledBg: "var(--variant-solidDisabledBg)",
      })),
      t
    );
  },
  cj = [
    "cssVarPrefix",
    "breakpoints",
    "spacing",
    "components",
    "variants",
    "shouldSkipGeneratingVar",
  ],
  fj = ["colorSchemes"],
  dj = (n = "joy") => ik(n);
function hj(n) {
  var e, t, r, i, o, s, a, u, c, d;
  const m = {},
    {
      cssVarPrefix: g = "joy",
      breakpoints: y,
      spacing: x,
      components: S,
      variants: _,
      shouldSkipGeneratingVar: w = lj,
    } = m,
    T = It(m, cj),
    M = dj(g),
    A = {
      primary: tm.blue,
      neutral: tm.grey,
      danger: tm.red,
      success: tm.green,
      warning: tm.yellow,
      common: { white: "#FFF", black: "#000" },
    },
    R = (fe) => {
      var Me;
      const ge = fe.split("-"),
        xe = ge[1],
        j = ge[2];
      return M(fe, (Me = A[xe]) == null ? void 0 : Me[j]);
    },
    D = (fe) => ({
      plainColor: R(`palette-${fe}-500`),
      plainHoverBg: R(`palette-${fe}-100`),
      plainActiveBg: R(`palette-${fe}-200`),
      plainDisabledColor: R("palette-neutral-400"),
      outlinedColor: R(`palette-${fe}-500`),
      outlinedBorder: R(`palette-${fe}-300`),
      outlinedHoverBg: R(`palette-${fe}-100`),
      outlinedActiveBg: R(`palette-${fe}-200`),
      outlinedDisabledColor: R("palette-neutral-400"),
      outlinedDisabledBorder: R("palette-neutral-200"),
      softColor: R(`palette-${fe}-700`),
      softBg: R(`palette-${fe}-100`),
      softHoverBg: R(`palette-${fe}-200`),
      softActiveColor: R(`palette-${fe}-800`),
      softActiveBg: R(`palette-${fe}-300`),
      softDisabledColor: R("palette-neutral-400"),
      softDisabledBg: R("palette-neutral-50"),
      solidColor: R("palette-common-white"),
      solidBg: R(`palette-${fe}-500`),
      solidHoverBg: R(`palette-${fe}-600`),
      solidActiveBg: R(`palette-${fe}-700`),
      solidDisabledColor: R("palette-neutral-400"),
      solidDisabledBg: R("palette-neutral-100"),
    }),
    P = (fe) => ({
      plainColor: R(`palette-${fe}-300`),
      plainHoverBg: R(`palette-${fe}-800`),
      plainActiveBg: R(`palette-${fe}-700`),
      plainDisabledColor: R("palette-neutral-500"),
      outlinedColor: R(`palette-${fe}-200`),
      outlinedBorder: R(`palette-${fe}-700`),
      outlinedHoverBg: R(`palette-${fe}-800`),
      outlinedActiveBg: R(`palette-${fe}-700`),
      outlinedDisabledColor: R("palette-neutral-500"),
      outlinedDisabledBorder: R("palette-neutral-800"),
      softColor: R(`palette-${fe}-200`),
      softBg: R(`palette-${fe}-800`),
      softHoverBg: R(`palette-${fe}-700`),
      softActiveColor: R(`palette-${fe}-100`),
      softActiveBg: R(`palette-${fe}-600`),
      softDisabledColor: R("palette-neutral-500"),
      softDisabledBg: R("palette-neutral-800"),
      solidColor: R("palette-common-white"),
      solidBg: R(`palette-${fe}-500`),
      solidHoverBg: R(`palette-${fe}-600`),
      solidActiveBg: R(`palette-${fe}-700`),
      solidDisabledColor: R("palette-neutral-500"),
      solidDisabledBg: R("palette-neutral-800"),
    }),
    U = {
      palette: {
        mode: "light",
        primary: ue({}, A.primary, D("primary")),
        neutral: ue({}, A.neutral, D("neutral"), {
          plainColor: R("palette-neutral-700"),
          plainHoverColor: R("palette-neutral-900"),
          outlinedColor: R("palette-neutral-700"),
        }),
        danger: ue({}, A.danger, D("danger")),
        success: ue({}, A.success, D("success")),
        warning: ue({}, A.warning, D("warning")),
        common: { white: "#FFF", black: "#000" },
        text: {
          primary: R("palette-neutral-800"),
          secondary: R("palette-neutral-700"),
          tertiary: R("palette-neutral-600"),
          icon: R("palette-neutral-500"),
        },
        background: {
          body: R("palette-common-white"),
          surface: R("palette-neutral-50"),
          popup: R("palette-common-white"),
          level1: R("palette-neutral-100"),
          level2: R("palette-neutral-200"),
          level3: R("palette-neutral-300"),
          tooltip: R("palette-neutral-500"),
          backdrop: `rgba(${M(
            "palette-neutral-darkChannel",
            Dc(A.neutral[900])
          )} / 0.25)`,
        },
        divider: `rgba(${M(
          "palette-neutral-mainChannel",
          Dc(A.neutral[500])
        )} / 0.2)`,
        focusVisible: R("palette-primary-500"),
      },
      shadowRing: "0 0 #000",
      shadowChannel: "21 21 21",
      shadowOpacity: "0.08",
    },
    O = {
      palette: {
        mode: "dark",
        primary: ue({}, A.primary, P("primary")),
        neutral: ue({}, A.neutral, P("neutral"), {
          plainColor: R("palette-neutral-300"),
          plainHoverColor: R("palette-neutral-300"),
        }),
        danger: ue({}, A.danger, P("danger")),
        success: ue({}, A.success, P("success")),
        warning: ue({}, A.warning, P("warning")),
        common: { white: "#FFF", black: "#000" },
        text: {
          primary: R("palette-neutral-100"),
          secondary: R("palette-neutral-300"),
          tertiary: R("palette-neutral-400"),
          icon: R("palette-neutral-400"),
        },
        background: {
          body: R("palette-common-black"),
          surface: R("palette-neutral-900"),
          popup: R("palette-common-black"),
          level1: R("palette-neutral-800"),
          level2: R("palette-neutral-700"),
          level3: R("palette-neutral-600"),
          tooltip: R("palette-neutral-600"),
          backdrop: `rgba(${M(
            "palette-neutral-darkChannel",
            Dc(A.neutral[50])
          )} / 0.25)`,
        },
        divider: `rgba(${M(
          "palette-neutral-mainChannel",
          Dc(A.neutral[500])
        )} / 0.16)`,
        focusVisible: R("palette-primary-500"),
      },
      shadowRing: "0 0 #000",
      shadowChannel: "0 0 0",
      shadowOpacity: "0.6",
    },
    L =
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    H = ue(
      {
        body: `"Inter", ${M(`fontFamily-fallback, ${L}`)}`,
        display: `"Inter", ${M(`fontFamily-fallback, ${L}`)}`,
        code: "Source Code Pro,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace",
        fallback: L,
      },
      T.fontFamily
    ),
    W = ue({ sm: 300, md: 500, lg: 600, xl: 700 }, T.fontWeight),
    $ = ue(
      {
        xs: "0.75rem",
        sm: "0.875rem",
        md: "1rem",
        lg: "1.125rem",
        xl: "1.25rem",
        xl2: "1.5rem",
        xl3: "1.875rem",
        xl4: "2.25rem",
      },
      T.fontSize
    ),
    K = ue(
      { xs: "1.33334", sm: "1.42858", md: "1.5", lg: "1.55556", xl: "1.66667" },
      T.lineHeight
    ),
    Z =
      (e =
        (t = T.colorSchemes) == null || (t = t.light) == null
          ? void 0
          : t.shadowRing) != null
        ? e
        : U.shadowRing,
    Y =
      (r =
        (i = T.colorSchemes) == null || (i = i.light) == null
          ? void 0
          : i.shadowChannel) != null
        ? r
        : U.shadowChannel,
    re =
      (o =
        (s = T.colorSchemes) == null || (s = s.light) == null
          ? void 0
          : s.shadowOpacity) != null
        ? o
        : U.shadowOpacity,
    G = {
      colorSchemes: { light: U, dark: O },
      fontSize: $,
      fontFamily: H,
      fontWeight: W,
      focus: {
        thickness: "2px",
        selector: `&.${db("", "focusVisible")}, &:focus-visible`,
        default: {
          outlineOffset: `var(--focus-outline-offset, ${M(
            "focus-thickness",
            (a = (u = T.focus) == null ? void 0 : u.thickness) != null
              ? a
              : "2px"
          )})`,
          outline: `${M(
            "focus-thickness",
            (c = (d = T.focus) == null ? void 0 : d.thickness) != null
              ? c
              : "2px"
          )} solid ${M("palette-focusVisible", A.primary[500])}`,
        },
      },
      lineHeight: K,
      radius: { xs: "2px", sm: "6px", md: "8px", lg: "12px", xl: "16px" },
      shadow: {
        xs: `${M("shadowRing", Z)}, 0px 1px 2px 0px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)})`,
        sm: `${M("shadowRing", Z)}, 0px 1px 2px 0px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)}), 0px 2px 4px 0px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)})`,
        md: `${M("shadowRing", Z)}, 0px 2px 8px -2px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)}), 0px 6px 12px -2px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)})`,
        lg: `${M("shadowRing", Z)}, 0px 2px 8px -2px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)}), 0px 12px 16px -4px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)})`,
        xl: `${M("shadowRing", Z)}, 0px 2px 8px -2px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)}), 0px 20px 24px -4px rgba(${M(
          "shadowChannel",
          Y
        )} / ${M("shadowOpacity", re)})`,
      },
      zIndex: {
        badge: 1,
        table: 10,
        popup: 1e3,
        modal: 1300,
        snackbar: 1400,
        tooltip: 1500,
      },
      typography: {
        h1: {
          fontFamily: M(`fontFamily-display, ${H.display}`),
          fontWeight: M(`fontWeight-xl, ${W.xl}`),
          fontSize: M(`fontSize-xl4, ${$.xl4}`),
          lineHeight: M(`lineHeight-xs, ${K.xs}`),
          letterSpacing: "-0.025em",
          color: M(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h2: {
          fontFamily: M(`fontFamily-display, ${H.display}`),
          fontWeight: M(`fontWeight-xl, ${W.xl}`),
          fontSize: M(`fontSize-xl3, ${$.xl3}`),
          lineHeight: M(`lineHeight-xs, ${K.xs}`),
          letterSpacing: "-0.025em",
          color: M(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h3: {
          fontFamily: M(`fontFamily-display, ${H.display}`),
          fontWeight: M(`fontWeight-lg, ${W.lg}`),
          fontSize: M(`fontSize-xl2, ${$.xl2}`),
          lineHeight: M(`lineHeight-xs, ${K.xs}`),
          letterSpacing: "-0.025em",
          color: M(`palette-text-primary, ${U.palette.text.primary}`),
        },
        h4: {
          fontFamily: M(`fontFamily-display, ${H.display}`),
          fontWeight: M(`fontWeight-lg, ${W.lg}`),
          fontSize: M(`fontSize-xl, ${$.xl}`),
          lineHeight: M(`lineHeight-md, ${K.md}`),
          letterSpacing: "-0.025em",
          color: M(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-lg": {
          fontFamily: M(`fontFamily-body, ${H.body}`),
          fontWeight: M(`fontWeight-lg, ${W.lg}`),
          fontSize: M(`fontSize-lg, ${$.lg}`),
          lineHeight: M(`lineHeight-xs, ${K.xs}`),
          color: M(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-md": {
          fontFamily: M(`fontFamily-body, ${H.body}`),
          fontWeight: M(`fontWeight-md, ${W.md}`),
          fontSize: M(`fontSize-md, ${$.md}`),
          lineHeight: M(`lineHeight-md, ${K.md}`),
          color: M(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "title-sm": {
          fontFamily: M(`fontFamily-body, ${H.body}`),
          fontWeight: M(`fontWeight-md, ${W.md}`),
          fontSize: M(`fontSize-sm, ${$.sm}`),
          lineHeight: M(`lineHeight-sm, ${K.sm}`),
          color: M(`palette-text-primary, ${U.palette.text.primary}`),
        },
        "body-lg": {
          fontFamily: M(`fontFamily-body, ${H.body}`),
          fontSize: M(`fontSize-lg, ${$.lg}`),
          lineHeight: M(`lineHeight-md, ${K.md}`),
          color: M(`palette-text-secondary, ${U.palette.text.secondary}`),
        },
        "body-md": {
          fontFamily: M(`fontFamily-body, ${H.body}`),
          fontSize: M(`fontSize-md, ${$.md}`),
          lineHeight: M(`lineHeight-md, ${K.md}`),
          color: M(`palette-text-secondary, ${U.palette.text.secondary}`),
        },
        "body-sm": {
          fontFamily: M(`fontFamily-body, ${H.body}`),
          fontSize: M(`fontSize-sm, ${$.sm}`),
          lineHeight: M(`lineHeight-md, ${K.md}`),
          color: M(`palette-text-tertiary, ${U.palette.text.tertiary}`),
        },
        "body-xs": {
          fontFamily: M(`fontFamily-body, ${H.body}`),
          fontWeight: M(`fontWeight-md, ${W.md}`),
          fontSize: M(`fontSize-xs, ${$.xs}`),
          lineHeight: M(`lineHeight-md, ${K.md}`),
          color: M(`palette-text-tertiary, ${U.palette.text.tertiary}`),
        },
      },
    },
    te = T ? ni(G, T) : G,
    { colorSchemes: F } = te,
    V = It(te, fj),
    ne = ue({ colorSchemes: F }, V, {
      breakpoints: VS(y ?? {}),
      components: ni(
        {
          MuiSvgIcon: {
            defaultProps: { fontSize: "xl2" },
            styleOverrides: {
              root: ({ ownerState: fe, theme: Me }) => {
                var ge;
                const xe = fe.instanceFontSize;
                return ue(
                  { margin: "var(--Icon-margin)" },
                  fe.fontSize &&
                    fe.fontSize !== "inherit" && {
                      fontSize: `var(--Icon-fontSize, ${
                        Me.vars.fontSize[fe.fontSize]
                      })`,
                    },
                  !fe.htmlColor &&
                    ue(
                      {
                        color: `var(--Icon-color, ${ne.vars.palette.text.icon})`,
                      },
                      fe.color &&
                        fe.color !== "inherit" &&
                        Me.vars.palette[fe.color] && {
                          color: `rgba(${
                            (ge = Me.vars.palette[fe.color]) == null
                              ? void 0
                              : ge.mainChannel
                          } / 1)`,
                        }
                    ),
                  xe &&
                    xe !== "inherit" && {
                      "--Icon-fontSize": Me.vars.fontSize[xe],
                    }
                );
              },
            },
          },
        },
        S
      ),
      cssVarPrefix: g,
      getCssVar: M,
      spacing: LC(x),
    });
  function ae(fe, Me) {
    Object.keys(Me).forEach((ge) => {
      const xe = { main: "500", light: "200", dark: "700" };
      fe === "dark" && (xe.main = 400),
        !Me[ge].mainChannel &&
          Me[ge][xe.main] &&
          (Me[ge].mainChannel = Dc(Me[ge][xe.main])),
        !Me[ge].lightChannel &&
          Me[ge][xe.light] &&
          (Me[ge].lightChannel = Dc(Me[ge][xe.light])),
        !Me[ge].darkChannel &&
          Me[ge][xe.dark] &&
          (Me[ge].darkChannel = Dc(Me[ge][xe.dark]));
    });
  }
  Object.entries(ne.colorSchemes).forEach(([fe, Me]) => {
    ae(fe, Me.palette);
  });
  const J = { prefix: g, shouldSkipGeneratingVar: w },
    { vars: se, generateCssVars: de } = uk(ue({ colorSchemes: F }, V), J);
  (ne.vars = se),
    (ne.generateCssVars = de),
    (ne.unstable_sxConfig = ue({}, aj, void 0)),
    (ne.unstable_sx = function (Me) {
      return If({ sx: Me, theme: this });
    }),
    (ne.getColorSchemeSelector = (fe) =>
      fe === "light"
        ? "&"
        : `&[data-joy-color-scheme="${fe}"], [data-joy-color-scheme="${fe}"] &`);
  const le = { getCssVar: M, palette: ne.colorSchemes.light.palette };
  return (
    (ne.variants = ni(
      {
        plain: Qi("plain", le),
        plainHover: Qi("plainHover", le),
        plainActive: Qi("plainActive", le),
        plainDisabled: Qi("plainDisabled", le),
        outlined: Qi("outlined", le),
        outlinedHover: Qi("outlinedHover", le),
        outlinedActive: Qi("outlinedActive", le),
        outlinedDisabled: Qi("outlinedDisabled", le),
        soft: Qi("soft", le),
        softHover: Qi("softHover", le),
        softActive: Qi("softActive", le),
        softDisabled: Qi("softDisabled", le),
        solid: Qi("solid", le),
        solidHover: Qi("solidHover", le),
        solidActive: Qi("solidActive", le),
        solidDisabled: Qi("solidDisabled", le),
      },
      _
    )),
    (ne.palette = ue({}, ne.colorSchemes.light.palette, {
      colorScheme: "light",
    })),
    (ne.shouldSkipGeneratingVar = w),
    (ne.applyStyles = YS),
    ne
  );
}
const h3 = hj(),
  rc = FC({ defaultTheme: h3, themeId: f3 });
function p3({ props: n, name: e }) {
  return zC({
    props: n,
    name: e,
    defaultTheme: ue({}, h3, { components: {} }),
    themeId: f3,
  });
}
const pj = [
    "className",
    "elementType",
    "ownerState",
    "externalForwardedProps",
    "getSlotOwnerState",
    "internalForwardedProps",
  ],
  mj = ["component", "slots", "slotProps"],
  gj = ["component"];
function Gu(n, e) {
  const {
      className: t,
      elementType: r,
      ownerState: i,
      externalForwardedProps: o,
      getSlotOwnerState: s,
      internalForwardedProps: a,
    } = e,
    u = It(e, pj),
    {
      component: c,
      slots: d = { [n]: void 0 },
      slotProps: m = { [n]: void 0 },
    } = o,
    g = It(o, mj),
    y = d[n] || r,
    x = XC(m[n], i),
    S = $C(
      ue({ className: t }, u, {
        externalForwardedProps: n === "root" ? g : void 0,
        externalSlotProps: x,
      })
    ),
    {
      props: { component: _ },
      internalRef: w,
    } = S,
    T = It(S.props, gj),
    M = ri(w, x == null ? void 0 : x.ref, e.ref),
    A = s ? s(T) : {},
    R = ue({}, i, A),
    D = n === "root" ? _ || c : _,
    P = jC(
      y,
      ue(
        {},
        n === "root" && !c && !d[n] && a,
        n !== "root" && !d[n] && a,
        T,
        D && { as: D },
        { ref: M }
      ),
      R
    );
  return (
    Object.keys(A).forEach((U) => {
      delete P[U];
    }),
    [y, P]
  );
}
function vj(n) {
  return db("MuiCircularProgress", n);
}
d3("MuiCircularProgress", [
  "root",
  "determinate",
  "svg",
  "track",
  "progress",
  "colorPrimary",
  "colorNeutral",
  "colorDanger",
  "colorSuccess",
  "colorWarning",
  "colorContext",
  "sizeSm",
  "sizeMd",
  "sizeLg",
  "variantPlain",
  "variantOutlined",
  "variantSoft",
  "variantSolid",
]);
let yj = (n) => n,
  Q2;
const xj = ["color", "backgroundColor"],
  _j = [
    "children",
    "className",
    "color",
    "size",
    "variant",
    "thickness",
    "determinate",
    "value",
    "component",
    "slots",
    "slotProps",
  ],
  Sj = ng({
    "0%": { transform: "rotate(-90deg)" },
    "100%": { transform: "rotate(270deg)" },
  }),
  wj = (n) => {
    const { determinate: e, color: t, variant: r, size: i } = n,
      o = {
        root: [
          "root",
          e && "determinate",
          t && `color${an(t)}`,
          r && `variant${an(r)}`,
          i && `size${an(i)}`,
        ],
        svg: ["svg"],
        track: ["track"],
        progress: ["progress"],
      };
    return Bn(o, vj, {});
  };
function lh(n, e) {
  return `var(--CircularProgress-${n}Thickness, var(--CircularProgress-thickness, ${e}))`;
}
const bj = rc("span", {
    name: "JoyCircularProgress",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })(({ ownerState: n, theme: e }) => {
    var t, r, i, o;
    const s = ((t = e.variants[n.variant]) == null ? void 0 : t[n.color]) || {},
      { color: a, backgroundColor: u } = s,
      c = It(s, xj);
    return ue(
      {
        "--Icon-fontSize": "calc(0.4 * var(--_root-size))",
        "--CircularProgress-trackColor": u,
        "--CircularProgress-progressColor": a,
        "--CircularProgress-percent": n.value,
        "--CircularProgress-linecap": "round",
      },
      n.size === "sm" && {
        "--_root-size": "var(--CircularProgress-size, 24px)",
        "--_track-thickness": lh("track", "3px"),
        "--_progress-thickness": lh("progress", "3px"),
      },
      n.instanceSize === "sm" && { "--CircularProgress-size": "24px" },
      n.size === "md" && {
        "--_track-thickness": lh("track", "6px"),
        "--_progress-thickness": lh("progress", "6px"),
        "--_root-size": "var(--CircularProgress-size, 40px)",
      },
      n.instanceSize === "md" && { "--CircularProgress-size": "40px" },
      n.size === "lg" && {
        "--_track-thickness": lh("track", "8px"),
        "--_progress-thickness": lh("progress", "8px"),
        "--_root-size": "var(--CircularProgress-size, 64px)",
      },
      n.instanceSize === "lg" && { "--CircularProgress-size": "64px" },
      n.thickness && {
        "--_track-thickness": `${n.thickness}px`,
        "--_progress-thickness": `${n.thickness}px`,
      },
      {
        "--_thickness-diff":
          "calc(var(--_track-thickness) - var(--_progress-thickness))",
        "--_inner-size":
          "calc(var(--_root-size) - 2 * var(--variant-borderWidth, 0px))",
        "--_outlined-inset":
          "max(var(--_track-thickness), var(--_progress-thickness))",
        width: "var(--_root-size)",
        height: "var(--_root-size)",
        borderRadius: "var(--_root-size)",
        margin: "var(--CircularProgress-margin)",
        boxSizing: "border-box",
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        flexShrink: 0,
        position: "relative",
        color: a,
      },
      n.children && {
        fontFamily: e.vars.fontFamily.body,
        fontWeight: e.vars.fontWeight.md,
        fontSize: "calc(0.2 * var(--_root-size))",
      },
      c,
      n.variant === "outlined" && {
        "&::before": ue(
          {
            content: '""',
            display: "block",
            position: "absolute",
            borderRadius: "inherit",
            top: "var(--_outlined-inset)",
            left: "var(--_outlined-inset)",
            right: "var(--_outlined-inset)",
            bottom: "var(--_outlined-inset)",
          },
          c
        ),
      },
      n.variant === "soft" && {
        "--CircularProgress-trackColor":
          e.variants.soft.neutral.backgroundColor,
        "--CircularProgress-progressColor":
          (r = e.variants.solid) == null ? void 0 : r[n.color].backgroundColor,
      },
      n.variant === "solid" && {
        "--CircularProgress-trackColor":
          (i = e.variants.softHover) == null
            ? void 0
            : i[n.color].backgroundColor,
        "--CircularProgress-progressColor":
          (o = e.variants.solid) == null ? void 0 : o[n.color].backgroundColor,
      }
    );
  }),
  Mj = rc("svg", {
    name: "JoyCircularProgress",
    slot: "Svg",
    overridesResolver: (n, e) => e.svg,
  })({
    width: "inherit",
    height: "inherit",
    display: "inherit",
    boxSizing: "inherit",
    position: "absolute",
    top: "calc(-1 * var(--variant-borderWidth, 0px))",
    left: "calc(-1 * var(--variant-borderWidth, 0px))",
  }),
  Ej = rc("circle", {
    name: "JoyCircularProgress",
    slot: "track",
    overridesResolver: (n, e) => e.track,
  })({
    cx: "50%",
    cy: "50%",
    r: "calc(var(--_inner-size) / 2 - var(--_track-thickness) / 2 + min(0px, var(--_thickness-diff) / 2))",
    fill: "transparent",
    strokeWidth: "var(--_track-thickness)",
    stroke: "var(--CircularProgress-trackColor)",
  }),
  Tj = rc("circle", {
    name: "JoyCircularProgress",
    slot: "progress",
    overridesResolver: (n, e) => e.progress,
  })(
    {
      "--_progress-radius":
        "calc(var(--_inner-size) / 2 - var(--_progress-thickness) / 2 - max(0px, var(--_thickness-diff) / 2))",
      "--_progress-length": "calc(2 * 3.1415926535 * var(--_progress-radius))",
      cx: "50%",
      cy: "50%",
      r: "var(--_progress-radius)",
      fill: "transparent",
      strokeWidth: "var(--_progress-thickness)",
      stroke: "var(--CircularProgress-progressColor)",
      strokeLinecap: "var(--CircularProgress-linecap, round)",
      strokeDasharray: "var(--_progress-length)",
      strokeDashoffset:
        "calc(var(--_progress-length) - var(--CircularProgress-percent) * var(--_progress-length) / 100)",
      transformOrigin: "center",
      transform: "rotate(-90deg)",
    },
    ({ ownerState: n }) =>
      !n.determinate &&
      zS(
        Q2 ||
          (Q2 = yj`
      animation: var(--CircularProgress-circulation, 0.8s linear 0s infinite normal none running)
        ${0};
    `),
        Sj
      )
  ),
  Cj = X.forwardRef(function (e, t) {
    const r = p3({ props: e, name: "JoyCircularProgress" }),
      {
        children: i,
        className: o,
        color: s = "primary",
        size: a = "md",
        variant: u = "soft",
        thickness: c,
        determinate: d = !1,
        value: m = d ? 0 : 25,
        component: g,
        slots: y = {},
        slotProps: x = {},
      } = r,
      S = It(r, _j),
      _ = ue({}, r, {
        color: s,
        size: a,
        variant: u,
        thickness: c,
        value: m,
        determinate: d,
        instanceSize: e.size,
      }),
      w = wj(_),
      T = ue({}, S, { component: g, slots: y, slotProps: x }),
      [M, A] = Gu("root", {
        ref: t,
        className: Zt(w.root, o),
        elementType: bj,
        externalForwardedProps: T,
        ownerState: _,
        additionalProps: ue(
          { role: "progressbar", style: { "--CircularProgress-percent": m } },
          m &&
            d && {
              "aria-valuenow": Math.round(
                typeof m == "number" ? m : Number(m || 0)
              ),
            }
        ),
      }),
      [R, D] = Gu("svg", {
        className: w.svg,
        elementType: Mj,
        externalForwardedProps: T,
        ownerState: _,
      }),
      [P, U] = Gu("track", {
        className: w.track,
        elementType: Ej,
        externalForwardedProps: T,
        ownerState: _,
      }),
      [O, L] = Gu("progress", {
        className: w.progress,
        elementType: Tj,
        externalForwardedProps: T,
        ownerState: _,
      });
    return Q.jsxs(
      M,
      ue({}, A, {
        children: [
          Q.jsxs(
            R,
            ue({}, D, { children: [Q.jsx(P, ue({}, U)), Q.jsx(O, ue({}, L))] })
          ),
          i,
        ],
      })
    );
  });
function Aj(n) {
  return db("MuiButton", n);
}
const eC = d3("MuiButton", [
    "root",
    "colorPrimary",
    "colorNeutral",
    "colorDanger",
    "colorSuccess",
    "colorWarning",
    "colorContext",
    "variantPlain",
    "variantOutlined",
    "variantSoft",
    "variantSolid",
    "focusVisible",
    "disabled",
    "sizeSm",
    "sizeMd",
    "sizeLg",
    "fullWidth",
    "startDecorator",
    "endDecorator",
    "loading",
    "loadingIndicatorCenter",
  ]),
  Rj = X.createContext({}),
  Pj = X.createContext(void 0),
  Ij = [
    "children",
    "action",
    "color",
    "variant",
    "size",
    "fullWidth",
    "startDecorator",
    "endDecorator",
    "loading",
    "loadingPosition",
    "loadingIndicator",
    "disabled",
    "component",
    "slots",
    "slotProps",
  ],
  Lj = (n) => {
    const {
        color: e,
        disabled: t,
        focusVisible: r,
        focusVisibleClassName: i,
        fullWidth: o,
        size: s,
        variant: a,
        loading: u,
      } = n,
      c = {
        root: [
          "root",
          t && "disabled",
          r && "focusVisible",
          o && "fullWidth",
          a && `variant${an(a)}`,
          e && `color${an(e)}`,
          s && `size${an(s)}`,
          u && "loading",
        ],
        startDecorator: ["startDecorator"],
        endDecorator: ["endDecorator"],
        loadingIndicatorCenter: ["loadingIndicatorCenter"],
      },
      d = Bn(c, Aj, {});
    return r && i && (d.root += ` ${i}`), d;
  },
  Dj = rc("span", {
    name: "JoyButton",
    slot: "StartDecorator",
    overridesResolver: (n, e) => e.startDecorator,
  })({
    "--Icon-margin": "0 0 0 calc(var(--Button-gap) / -2)",
    "--CircularProgress-margin": "0 0 0 calc(var(--Button-gap) / -2)",
    display: "inherit",
    marginRight: "var(--Button-gap)",
  }),
  kj = rc("span", {
    name: "JoyButton",
    slot: "EndDecorator",
    overridesResolver: (n, e) => e.endDecorator,
  })({
    "--Icon-margin": "0 calc(var(--Button-gap) / -2) 0 0",
    "--CircularProgress-margin": "0 calc(var(--Button-gap) / -2) 0 0",
    display: "inherit",
    marginLeft: "var(--Button-gap)",
  }),
  Oj = rc("span", {
    name: "JoyButton",
    slot: "LoadingCenter",
    overridesResolver: (n, e) => e.loadingIndicatorCenter,
  })(({ theme: n, ownerState: e }) => {
    var t, r;
    return ue(
      {
        display: "inherit",
        position: "absolute",
        left: "50%",
        transform: "translateX(-50%)",
        color:
          (t = n.variants[e.variant]) == null || (t = t[e.color]) == null
            ? void 0
            : t.color,
      },
      e.disabled && {
        color:
          (r = n.variants[`${e.variant}Disabled`]) == null ||
          (r = r[e.color]) == null
            ? void 0
            : r.color,
      }
    );
  }),
  Nj = ({ theme: n, ownerState: e }) => {
    var t, r, i, o;
    return [
      ue(
        {
          "--Icon-margin": "initial",
          "--Icon-color":
            e.color !== "neutral" || e.variant === "solid"
              ? "currentColor"
              : n.vars.palette.text.icon,
        },
        e.size === "sm" && {
          "--Icon-fontSize": n.vars.fontSize.lg,
          "--CircularProgress-size": "20px",
          "--CircularProgress-thickness": "2px",
          "--Button-gap": "0.375rem",
          minHeight: "var(--Button-minHeight, 2rem)",
          fontSize: n.vars.fontSize.sm,
          paddingBlock: "var(--Button-paddingBlock, 0.25rem)",
          paddingInline: "0.75rem",
        },
        e.size === "md" && {
          "--Icon-fontSize": n.vars.fontSize.xl,
          "--CircularProgress-size": "20px",
          "--CircularProgress-thickness": "2px",
          "--Button-gap": "0.5rem",
          minHeight: "var(--Button-minHeight, 2.25rem)",
          fontSize: n.vars.fontSize.sm,
          paddingBlock: "var(--Button-paddingBlock, 0.375rem)",
          paddingInline: "1rem",
        },
        e.size === "lg" && {
          "--Icon-fontSize": n.vars.fontSize.xl2,
          "--CircularProgress-size": "28px",
          "--CircularProgress-thickness": "4px",
          "--Button-gap": "0.75rem",
          minHeight: "var(--Button-minHeight, 2.75rem)",
          fontSize: n.vars.fontSize.md,
          paddingBlock: "var(--Button-paddingBlock, 0.5rem)",
          paddingInline: "1.5rem",
        },
        {
          WebkitTapHighlightColor: "transparent",
          boxSizing: "border-box",
          borderRadius: `var(--Button-radius, ${n.vars.radius.sm})`,
          margin: "var(--Button-margin)",
          border: "none",
          backgroundColor: "transparent",
          cursor: "pointer",
          userSelect: "none",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          position: "relative",
          textDecoration: "none",
          fontFamily: n.vars.fontFamily.body,
          fontWeight: n.vars.fontWeight.lg,
          lineHeight: n.vars.lineHeight.md,
        },
        e.fullWidth && { width: "100%" },
        { [n.focus.selector]: n.focus.default }
      ),
      ue(
        {},
        (t = n.variants[e.variant]) == null ? void 0 : t[e.color],
        {
          "&:hover": {
            "@media (hover: hover)":
              (r = n.variants[`${e.variant}Hover`]) == null
                ? void 0
                : r[e.color],
          },
          '&:active, &[aria-pressed="true"]':
            (i = n.variants[`${e.variant}Active`]) == null
              ? void 0
              : i[e.color],
          [`&.${eC.disabled}`]:
            (o = n.variants[`${e.variant}Disabled`]) == null
              ? void 0
              : o[e.color],
        },
        e.loadingPosition === "center" && {
          [`&.${eC.loading}`]: { color: "transparent" },
        }
      ),
    ];
  },
  Uj = rc("button", {
    name: "JoyButton",
    slot: "Root",
    overridesResolver: (n, e) => e.root,
  })(Nj),
  m3 = X.forwardRef(function (e, t) {
    var r;
    const i = p3({ props: e, name: "JoyButton" }),
      {
        children: o,
        action: s,
        color: a = "primary",
        variant: u = "solid",
        size: c = "md",
        fullWidth: d = !1,
        startDecorator: m,
        endDecorator: g,
        loading: y = !1,
        loadingPosition: x = "center",
        loadingIndicator: S,
        disabled: _,
        component: w,
        slots: T = {},
        slotProps: M = {},
      } = i,
      A = It(i, Ij),
      R = X.useContext(Rj),
      D = X.useContext(Pj),
      P = e.variant || R.variant || u,
      U = e.size || R.size || c,
      O = e.color || R.color || a,
      L = (r = e.loading || e.disabled) != null ? r : R.disabled || y || _,
      H = X.useRef(null),
      W = ri(H, t),
      {
        focusVisible: $,
        setFocusVisible: K,
        getRootProps: Z,
      } = sj(ue({}, i, { disabled: L, rootRef: W })),
      Y =
        S ??
        Q.jsx(Cj, { color: O, thickness: { sm: 2, md: 3, lg: 4 }[U] || 3 });
    X.useImperativeHandle(
      s,
      () => ({
        focusVisible: () => {
          var ge;
          K(!0), (ge = H.current) == null || ge.focus();
        },
      }),
      [K]
    );
    const re = ue({}, i, {
        color: O,
        fullWidth: d,
        variant: P,
        size: U,
        focusVisible: $,
        loading: y,
        loadingPosition: x,
        disabled: L,
      }),
      G = Lj(re),
      te = (ge) => {
        var xe;
        let j = i.onClick;
        if (
          (typeof M.root == "function"
            ? (j = M.root(re).onClick)
            : M.root && (j = M.root.onClick),
          (xe = j) == null || xe(ge),
          D)
        ) {
          var we;
          (we = D.onClick) == null || we.call(D, ge, i.value);
        }
      };
    let F = i["aria-pressed"];
    typeof M.root == "function"
      ? (F = M.root(re)["aria-pressed"])
      : M.root && (F = M.root["aria-pressed"]),
      D != null &&
        D.value &&
        (Array.isArray(D.value)
          ? (F = D.value.indexOf(i.value) !== -1)
          : (F = D.value === i.value));
    const V = ue({}, A, { component: w, slots: T, slotProps: M }),
      [ne, ae] = Gu("root", {
        ref: t,
        className: G.root,
        elementType: Uj,
        externalForwardedProps: V,
        getSlotProps: Z,
        ownerState: re,
        additionalProps: { onClick: te, "aria-pressed": F },
      }),
      [J, se] = Gu("startDecorator", {
        className: G.startDecorator,
        elementType: Dj,
        externalForwardedProps: V,
        ownerState: re,
      }),
      [de, le] = Gu("endDecorator", {
        className: G.endDecorator,
        elementType: kj,
        externalForwardedProps: V,
        ownerState: re,
      }),
      [fe, Me] = Gu("loadingIndicatorCenter", {
        className: G.loadingIndicatorCenter,
        elementType: Oj,
        externalForwardedProps: V,
        ownerState: re,
      });
    return Q.jsxs(
      ne,
      ue({}, ae, {
        children: [
          (m || (y && x === "start")) &&
            Q.jsx(J, ue({}, se, { children: y && x === "start" ? Y : m })),
          o,
          y && x === "center" && Q.jsx(fe, ue({}, Me, { children: Y })),
          (g || (y && x === "end")) &&
            Q.jsx(de, ue({}, le, { children: y && x === "end" ? Y : g })),
        ],
      })
    );
  });
m3.muiName = "Button";
const Fj = Lf(
    Q.jsx("path", {
      d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z",
    }),
    "ArrowDownward"
  ),
  Jc = Lf(Q.jsx("path", { d: "m10 17 5-5-5-5z" }), "ArrowRight"),
  Bj = Lf(
    Q.jsx("path", {
      d: "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96M10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41z",
    }),
    "CloudDone"
  ),
  zj = Lf(
    Q.jsx("path", { d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z" }),
    "KeyboardArrowRight"
  ),
  Hj = Lf(
    Q.jsx("path", {
      d: "M9.19 6.35c-2.04 2.29-3.44 5.58-3.57 5.89L2 10.69l4.05-4.05c.47-.47 1.15-.68 1.81-.55zM11.17 17s3.74-1.55 5.89-3.7c5.4-5.4 4.5-9.62 4.21-10.57-.95-.3-5.17-1.19-10.57 4.21C8.55 9.09 7 12.83 7 12.83zm6.48-2.19c-2.29 2.04-5.58 3.44-5.89 3.57L13.31 22l4.05-4.05c.47-.47.68-1.15.55-1.81zM9 18c0 .83-.34 1.58-.88 2.12C6.94 21.3 2 22 2 22s.7-4.94 1.88-6.12C4.42 15.34 5.17 15 6 15c1.66 0 3 1.34 3 3m4-9c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2",
    }),
    "RocketLaunch"
  ),
  Vj = ({ onStart: n }) =>
    Q.jsxs("div", {
      style: {
        minHeight: "100vh",
        display: "flex",
        flexDirection: "column",
        backgroundColor: "#1A202C",
        justifyContent: "center",
        alignItems: "center",
        textAlign: "center",
        padding: "20px",
      },
      children: [
        Q.jsx("h1", {
          style: {
            color: "white",
            marginBottom: "20px",
            fontSize: "clamp(1.2rem, 3vw, 2rem)",
          },
          children: "Demonstration of Smart Contract",
        }),
        Q.jsxs("video", {
          controls: !0,
          className: "animation-video",
          style: {
            width: "90%",
            maxWidth: "800px",
            height: "auto",
            borderRadius: "10px",
            boxShadow: "0 0 10px rgba(0,0,0,0.3)",
          },
          children: [
            Q.jsx("source", { src: "images/Smart-contract.mp4", type: "video/mp4" }),
            "Your browser does not support the video tag.",
          ],
        }),
        Q.jsx("div", {
          style: {
            marginTop: "20px",
            width: "90%",
            maxWidth: "800px",
            display: "flex",
            justifyContent: "flex-end",
          },
          children: Q.jsx(m3, {
            endDecorator: Q.jsx(zj, {}),
            color: "success",
            size: "lg",
            onClick: n,
            sx: {
              fontSize: { xs: "0.8rem", sm: "0.9rem", md: "1rem" },
              px: { xs: 2, sm: 3, md: 4 },
              py: { xs: 1, sm: 1.2, md: 1.5 },
              borderRadius: "10px",
            },
            children: "Go to Simulation",
          }),
        }),
      ],
    });
var nm = {},
  W1 = {};
const Wj = Gl(sO);
var tC;
function Gj() {
  return (
    tC ||
      ((tC = 1),
      (function (n) {
        "use client";
        Object.defineProperty(n, "__esModule", { value: !0 }),
          Object.defineProperty(n, "default", {
            enumerable: !0,
            get: function () {
              return e.createSvgIcon;
            },
          });
        var e = Wj;
      })(W1)),
    W1
  );
}
var nC;
function jj() {
  if (nC) return nm;
  nC = 1;
  var n = QS();
  Object.defineProperty(nm, "__esModule", { value: !0 }), (nm.default = void 0);
  var e = n(Gj()),
    t = rC();
  return (
    (nm.default = (0, e.default)(
      (0, t.jsx)("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z",
      }),
      "CheckCircle"
    )),
    nm
  );
}
var $j = jj();
const Xj = Oh($j);
function Yj() {
  var le, fe, Me;
  const {
      sender: n,
      receiver: e,
      validator: t,
      phase: r,
      contractDeployed: i,
      contractHash: o,
      smartContract: s,
      winner: a,
      initialContract: u,
    } = Qu((ge) => ge.simulation),
    [c, d] = X.useState(0),
    [m, g] = X.useState(""),
    [y, x] = X.useState(""),
    [S, _] = X.useState(null),
    [w, T] = X.useState(""),
    [M, A] = X.useState(""),
    [R, D] = X.useState(""),
    [P, U] = X.useState(!1),
    [O, L] = X.useState(""),
    [H, W] = X.useState(""),
    [$, K] = X.useState(""),
    [Z, Y] = X.useState(u),
    [re, G] = X.useState("");
  kD("(max-width:600px)");
  const te = [
      {
        text: "Who will win in Barcelona vs Real Madrid?",
        answers: ["Barcelona", "Real Madrid", "Draw"],
      },
      {
        text: "Who will score the first goal in Manchester United vs Liverpool?",
        answers: ["Manchester United", "Liverpool", "No Goal"],
      },
      {
        text: "Who will win the 2026 FIFA World Cup?",
        answers: ["Argentina", "Brazil", "France", "Germany", "Other"],
      },
      {
        text: "Which team will qualify first for the Champions League semi-final?",
        answers: [
          "Manchester City",
          "Bayern Munich",
          "PSG",
          "Barcelona",
          "Other",
        ],
      },
      {
        text: "Who will win the next El Clasico?",
        answers: ["Barcelona", "Real Madrid", "Draw"],
      },
      {
        text: "Which player will get the Ballon d'Or next year?",
        answers: ["Messi", "Ronaldo", "Mbappe", "Haaland", "Other"],
      },
      {
        text: "Who will score more goals this season?",
        answers: ["Messi", "Ronaldo", "Equal"],
      },
      {
        text: "Which club will win the UEFA Champions League Final?",
        answers: [
          "Real Madrid",
          "Manchester City",
          "PSG",
          "Bayern Munich",
          "Other",
        ],
      },
    ],
    F = OS(),
    [V, ne] = X.useState({ open: !1, message: "", severity: "success" });
  X.useEffect(() => {
    s &&
      ne({
        open: !0,
        message: "Successfully created smart contract",
        severity: "success",
      });
  }, [s]),
    X.useEffect(() => {
      s &&
        ne({
          open: !0,
          message: "Successfully created smart contract",
          severity: "success",
        }),
        a &&
          ne({
            open: !0,
            message: `${a} is the winner in the Bet Game`,
            severity: "success",
          });
    }, [a]),
    X.useEffect(() => {
      i &&
        ne({
          open: !0,
          message: "Smart Contract Deployed!",
          severity: "success",
        });
    }, [i]);
  const ae = Array.from({ length: 10 }, (ge, xe) => ({
      id: xe,
      name: `User ${xe + 1}`,
    })),
    J = ae.filter((ge) => ge.id !== w && ge.id !== M && ge.id !== 0),
    se = () => {
      const ge = [m, y].filter((xe) => xe.trim() !== "");
      if (ge.length > 0) {
        const xe = ge[Math.floor(Math.random() * ge.length)];
        _(xe),
          xe === m
            ? (F(EE(H)), G($), F(k_(w)), F(D_(M)))
            : (F(EE($)), G(H), F(k_(M)), F(D_(w)));
      }
    };
  X.useEffect(() => {
    if (i) {
      d(0);
      let ge = 1;
      const xe = setInterval(() => {
        d(ge), ge++, ge > 6 && clearInterval(xe);
      }, 3e3);
      return () => clearInterval(xe);
    }
  }, [i]);
  const de = (ge) => ({
    opacity: c >= ge ? 1 : 0,
    transform: c >= ge ? "translateY(0)" : "translateY(10px)",
    transition: "opacity 0.6s ease, transform 0.6s ease",
  });
  return Q.jsx(fn, {
    sx: {
      paddingLeft: "50px",
      width: "90%",
      maxWidth: { xs: "100%", sm: "600px" },
      mx: "auto",
      px: { xs: 1.5, sm: 2 },
      py: 2,
    },
    children:
      s &&
      Q.jsxs(Q.Fragment, {
        children: [
          Q.jsx(jF, {
            label: "Smart Contract",
            value: Z,
            onChange: (ge) => F(Y(ge.target.value)),
            multiline: !0,
            fullWidth: !0,
            minRows: 8,
            spellCheck: !1,
            InputProps: {
              sx: {
                bgcolor: "#0b0b0b",
                borderRadius: 2,
                "& .MuiInputBase-input": {
                  fontFamily:
                    'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
                  fontSize: 14,
                  lineHeight: 1.6,
                },
                "& textarea": {
                  color: "#e6e6e6",
                  caretColor: "#e6e6e6",
                  whiteSpace: "pre",
                  overflow: "auto",
                },
              },
            },
            sx: {
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "#333" },
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "#555",
              },
              "& .Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "#888",
              },
              "& .MuiInputLabel-root": { color: "#bdbdbd" },
              "& .MuiInputLabel-root.Mui-focused": { color: "#d0d0d0" },
              "& textarea": { maxHeight: { xs: "200px", sm: "300px" } },
            },
            placeholder: "// Write your contract here...",
          }),
          Q.jsxs(fn, {
            sx: {
              display: "flex",
              flexDirection: "column",
              gap: 2,
              mt: 3,
              width: "100%",
            },
            children: [
              Q.jsxs(lf, {
                elevation: 3,
                sx: {
                  p: 2,
                  borderRadius: 2,
                  bgcolor: "#1e1e1e",
                  color: "white",
                  display: "flex",
                  alignItems: "center",
                  gap: 1.5,
                },
                children: [
                  Q.jsx(Xj, { sx: { color: "lightgreen" } }),
                  Q.jsx(vn, {
                    children: "Smart contract created successfully.",
                  }),
                ],
              }),
              Q.jsxs(lf, {
                elevation: 3,
                sx: {
                  p: 2,
                  borderRadius: 2,
                  bgcolor: "#1e1e1e",
                  color: "white",
                  display: "flex",
                  alignItems: "center",
                  gap: 1.5,
                },
                children: [
                  Q.jsx(Hj, { sx: { color: "#ffb74d" } }),
                  Q.jsxs(vn, {
                    children: [
                      "Next, click the",
                      " ",
                      Q.jsx("span", {
                        style: { fontWeight: 700, color: "#1976d2" },
                        children: "Deploy",
                      }),
                      " ",
                      "button.",
                    ],
                  }),
                ],
              }),
              i &&
                Q.jsxs(lf, {
                  elevation: 3,
                  sx: {
                    p: 2,
                    borderRadius: 2,
                    bgcolor: "#1e1e1e",
                    color: "white",
                    display: "flex",
                    alignItems: "center",
                    gap: 1.5,
                  },
                  children: [
                    Q.jsx(Bj, { sx: { color: "greenyellow" } }),
                    Q.jsx(vn, {
                      children:
                        "Smart contract deployed on blockchain network.",
                    }),
                  ],
                }),
              i &&
                Q.jsxs(Q.Fragment, {
                  children: [
                    Q.jsxs(lf, {
                      elevation: 3,
                      sx: {
                        p: 2,
                        borderRadius: 2,
                        bgcolor: "#1e1e1e",
                        color: "white",
                        display: "flex",
                        alignItems: "center",
                        gap: 1.5,
                        ...de(2),
                      },
                      children: [
                        Q.jsx(vn, {
                          children:
                            "Lets move to the Bet game, which works on the deployed smart contract.",
                        }),
                        Q.jsx(Fj, {
                          sx: {
                            color: "#4dabf7",
                            fontSize: 20,
                            animation: "blink 1s infinite",
                            "@keyframes blink": {
                              "0%, 50%, 100%": { opacity: 1 },
                              "25%, 75%": { opacity: 0 },
                            },
                          },
                        }),
                      ],
                    }),
                    Q.jsxs(lf, {
                      elevation: 3,
                      sx: {
                        p: 2,
                        borderRadius: 2,
                        bgcolor: "#e0e0e0",
                        color: "black",
                        ...de(3),
                      },
                      children: [
                        Q.jsx(vn, {
                          variant: "h6",
                          sx: { mb: 2, fontWeight: "bold", color: "#5862f5ff" },
                          children: " Bet Game Instructions",
                        }),
                        Q.jsxs(rA, {
                          sx: de(4),
                          children: [
                            Q.jsxs(Nc, {
                              alignItems: "flex-start",
                              children: [
                                Q.jsx(Uc, {
                                  children: Q.jsx(Jc, {
                                    sx: { color: "#4dabf7" },
                                  }),
                                }),
                                Q.jsx(Fc, {
                                  primary:
                                    "First, select a question for the Bet Game.",
                                  primaryTypographyProps: { sx: { mb: 1 } },
                                }),
                              ],
                            }),
                            Q.jsx(fn, {
                              sx: {
                                bgcolor: "white",
                                p: 2,
                                borderRadius: 2,
                                mb: 2,
                              },
                              children: Q.jsxs(tf, {
                                fullWidth: !0,
                                children: [
                                  Q.jsx(ch, { children: "Question" }),
                                  Q.jsx(uf, {
                                    disabled: !i,
                                    value: O,
                                    onChange: (ge) => {
                                      L(ge.target.value), D_(""), k_("");
                                    },
                                    children: te.map((ge, xe) =>
                                      Q.jsx(
                                        Up,
                                        { value: ge.text, children: ge.text },
                                        xe
                                      )
                                    ),
                                  }),
                                ],
                              }),
                            }),
                            O &&
                              Q.jsxs(Q.Fragment, {
                                children: [
                                  Q.jsxs(Nc, {
                                    alignItems: "flex-start",
                                    children: [
                                      Q.jsx(Uc, {
                                        children: Q.jsx(Jc, {
                                          sx: { color: "#4dabf7" },
                                        }),
                                      }),
                                      Q.jsx(Fc, {
                                        primary:
                                          "Next, select two players and choose their respective answers. Each block in the blockchain network represents a player participating in the Bet Game.",
                                        primaryTypographyProps: {
                                          sx: { mb: 1 },
                                        },
                                      }),
                                    ],
                                  }),
                                  Q.jsxs(fn, {
                                    sx: {
                                      bgcolor: "white",
                                      p: 2,
                                      borderRadius: 2,
                                      mb: 2,
                                      display: "flex",
                                      flexDirection: "column",
                                      gap: 2,
                                    },
                                    children: [
                                      Q.jsxs(fn, {
                                        sx: {
                                          display: "flex",
                                          gap: 2,
                                          flexDirection: {
                                            xs: "column",
                                            sm: "row",
                                          },
                                          bgcolor:
                                            a && H === a
                                              ? "#d8fadbff"
                                              : re && H === re
                                              ? "#f5796bff"
                                              : "#ffffff",
                                        },
                                        children: [
                                          Q.jsxs(tf, {
                                            fullWidth: !0,
                                            disabled: r !== "idle",
                                            children: [
                                              Q.jsx(ch, {
                                                children: "Player 1",
                                              }),
                                              Q.jsx(uf, {
                                                disabled: !i,
                                                value: w,
                                                onChange: (ge) => {
                                                  T(ge.target.value);
                                                  const xe = ae.find(
                                                    (j) =>
                                                      j.id === ge.target.value
                                                  );
                                                  W(xe.name);
                                                },
                                                children: ae
                                                  .filter((ge) => ge.id !== M)
                                                  .map((ge) =>
                                                    Q.jsx(
                                                      Up,
                                                      {
                                                        value: ge.id,
                                                        children: ge.name,
                                                      },
                                                      ge.id
                                                    )
                                                  ),
                                              }),
                                            ],
                                          }),
                                          Q.jsxs(tf, {
                                            fullWidth: !0,
                                            disabled: !O,
                                            children: [
                                              Q.jsx(ch, { children: "Answer" }),
                                              Q.jsx(uf, {
                                                disabled: !i,
                                                value: m,
                                                onChange: (ge) =>
                                                  g(ge.target.value),
                                                children:
                                                  (le = te.find(
                                                    (ge) => ge.text === O
                                                  )) == null
                                                    ? void 0
                                                    : le.answers
                                                        .filter(
                                                          (ge) => ge !== y
                                                        )
                                                        .map((ge, xe) =>
                                                          Q.jsx(
                                                            Up,
                                                            {
                                                              value: ge,
                                                              children: ge,
                                                            },
                                                            xe
                                                          )
                                                        ),
                                              }),
                                            ],
                                          }),
                                        ],
                                      }),
                                      Q.jsxs(fn, {
                                        sx: {
                                          display: "flex",
                                          gap: 2,
                                          flexDirection: {
                                            xs: "column",
                                            sm: "row",
                                          },
                                          bgcolor:
                                            a && $ === a
                                              ? "#d8fadbff"
                                              : re && $ === re
                                              ? "#f5796bff"
                                              : "#ffffff",
                                        },
                                        children: [
                                          Q.jsxs(tf, {
                                            fullWidth: !0,
                                            disabled: r !== "idle",
                                            children: [
                                              Q.jsx(ch, {
                                                children: "Player 2",
                                              }),
                                              Q.jsx(uf, {
                                                disabled: !i,
                                                value: M,
                                                onChange: (ge) => {
                                                  A(ge.target.value);
                                                  const xe = ae.find(
                                                    (j) =>
                                                      j.id === ge.target.value
                                                  );
                                                  K(xe.name);
                                                },
                                                children: ae
                                                  .filter((ge) => ge.id !== w)
                                                  .map((ge) =>
                                                    Q.jsx(
                                                      Up,
                                                      {
                                                        value: ge.id,
                                                        children: ge.name,
                                                      },
                                                      ge.id
                                                    )
                                                  ),
                                              }),
                                            ],
                                          }),
                                          Q.jsxs(tf, {
                                            fullWidth: !0,
                                            disabled: !O,
                                            children: [
                                              Q.jsx(ch, { children: "Answer" }),
                                              Q.jsx(uf, {
                                                disabled: !i,
                                                value: y,
                                                onChange: (ge) =>
                                                  x(ge.target.value),
                                                children:
                                                  (fe = te.find(
                                                    (ge) => ge.text === O
                                                  )) == null
                                                    ? void 0
                                                    : fe.answers
                                                        .filter(
                                                          (ge) => ge !== m
                                                        )
                                                        .map((ge, xe) =>
                                                          Q.jsx(
                                                            Up,
                                                            {
                                                              value: ge,
                                                              children: ge,
                                                            },
                                                            xe
                                                          )
                                                        ),
                                              }),
                                            ],
                                          }),
                                        ],
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                            w !== "" &&
                              M !== "" &&
                              m !== "" &&
                              y !== "" &&
                              Q.jsxs(Q.Fragment, {
                                children: [
                                  Q.jsxs(Nc, {
                                    alignItems: "flex-start",
                                    children: [
                                      Q.jsx(Uc, {
                                        children: Q.jsx(Jc, {
                                          sx: { color: "#4dabf7" },
                                        }),
                                      }),
                                      Q.jsx(Fc, {
                                        primary: Q.jsxs(vn, {
                                          component: "span",
                                          children: [
                                            "After clicking the",
                                            " ",
                                            Q.jsx(vn, {
                                              component: "span",
                                              sx: {
                                                fontWeight: 700,
                                                color: "#4a19d2ff",
                                              },
                                              children: "Play",
                                            }),
                                            " ",
                                            "button, the system randomly determines the winning answer.",
                                          ],
                                        }),
                                      }),
                                    ],
                                  }),
                                  Q.jsx(fn, {
                                    sx: {
                                      bgcolor: "white",
                                      p: 2,
                                      borderRadius: 2,
                                      mb: 2,
                                    },
                                    children: Q.jsxs(fn, {
                                      sx: {
                                        display: "flex",
                                        gap: 2,
                                        flexDirection: {
                                          xs: "column",
                                          sm: "row",
                                        },
                                        alignItems: {
                                          xs: "stretch",
                                          sm: "center",
                                        },
                                      },
                                      children: [
                                        Q.jsx(cm, {
                                          disabled:
                                            !i ||
                                            w === "" ||
                                            M === "" ||
                                            m === "" ||
                                            y === "" ||
                                            !O ||
                                            S !== null,
                                          variant: "contained",
                                          color: "primary",
                                          onClick: se,
                                          sx: {
                                            borderRadius: "8px",
                                            textTransform: "none",
                                            fontWeight: 600,
                                            flex: 1,
                                          },
                                          children: "Play",
                                        }),
                                        S !== null &&
                                          Q.jsx(fn, {
                                            sx: {
                                              color: "black",
                                              flex: 1,
                                              p: 1,
                                              bgcolor: "#ffffff",
                                              borderRadius: "6px",
                                              textAlign: "center",
                                              fontWeight: 600,
                                            },
                                            children: S,
                                          }),
                                      ],
                                    }),
                                  }),
                                ],
                              }),
                            S !== null &&
                              Q.jsxs(Q.Fragment, {
                                children: [
                                  Q.jsxs(Nc, {
                                    children: [
                                      Q.jsx(Uc, {
                                        children: Q.jsx(Jc, {
                                          sx: { color: "#4caf50" },
                                        }),
                                      }),
                                      Q.jsx(Fc, {
                                        primary:
                                          "The player whose answer is selected is declared the winner.",
                                      }),
                                    ],
                                  }),
                                  Q.jsxs(Nc, {
                                    children: [
                                      Q.jsx(Uc, {
                                        children: Q.jsx(Jc, {
                                          sx: { color: "#4caf50" },
                                        }),
                                      }),
                                      Q.jsx(Fc, {
                                        primary:
                                          "Next, select a miner from the remaining players in the network.",
                                      }),
                                    ],
                                  }),
                                  Q.jsxs(Nc, {
                                    children: [
                                      Q.jsx(Uc, {
                                        children: Q.jsx(Jc, {
                                          sx: { color: "#4caf50" },
                                        }),
                                      }),
                                      Q.jsx(Fc, {
                                        primary: Q.jsxs(vn, {
                                          component: "span",
                                          children: [
                                            "Click the",
                                            " ",
                                            Q.jsx(vn, {
                                              component: "span",
                                              sx: {
                                                fontWeight: 700,
                                                color: "#9c27b0",
                                              },
                                              children: "Find Miner",
                                            }),
                                            " ",
                                            "button to continue.",
                                          ],
                                        }),
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                            a &&
                              Q.jsx(tf, {
                                fullWidth: !0,
                                disabled:
                                  w === null || M === null || r !== "idle",
                                children: Q.jsx(fn, {
                                  sx: {
                                    display: "flex",
                                    flexDirection: "column",
                                    gap: 1,
                                    mt: 2,
                                  },
                                  children: R
                                    ? R === "finding"
                                      ? Q.jsx(vn, {
                                          sx: {
                                            color: "orange",
                                            fontWeight: 600,
                                          },
                                          children: "Miners solving puzzles...",
                                        })
                                      : Q.jsxs(vn, {
                                          sx: {
                                            color: "blue",
                                            fontWeight: 600,
                                          },
                                          children: [
                                            (Me = ae.find(
                                              (ge) => ge.id === R
                                            )) == null
                                              ? void 0
                                              : Me.name,
                                            " solved the puzzle first and is selected as the miner. ",
                                          ],
                                        })
                                    : Q.jsx(cm, {
                                        disabled:
                                          !i ||
                                          w === "" ||
                                          M === "" ||
                                          m === "" ||
                                          y === "" ||
                                          !O ||
                                          !S,
                                        variant: "contained",
                                        color: "secondary",
                                        onClick: () => {
                                          D("finding"),
                                            setTimeout(() => {
                                              const ge =
                                                J[
                                                  Math.floor(
                                                    Math.random() * J.length
                                                  )
                                                ];
                                              D(ge.id), F(uS(ge.id));
                                            }, 1500);
                                        },
                                        children: "Find Miner",
                                      }),
                                }),
                              }),
                            R &&
                              Q.jsxs(Nc, {
                                children: [
                                  Q.jsx(Uc, {
                                    children: Q.jsx(Jc, {
                                      sx: { color: "#ff7043" },
                                    }),
                                  }),
                                  Q.jsx(Fc, {
                                    primary: Q.jsxs(vn, {
                                      component: "span",
                                      children: [
                                        "Click the",
                                        " ",
                                        Q.jsx(vn, {
                                          component: "span",
                                          sx: {
                                            fontWeight: 700,
                                            color: "#1976d2",
                                          },
                                          children: "Initiate Transaction",
                                        }),
                                        " ",
                                        "button in the left panel to proceed.",
                                      ],
                                    }),
                                  }),
                                ],
                              }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
            ],
          }),
        ],
      }),
  });
}
function qj() {
  const [n, e] = X.useState(!1),
    [t, r] = X.useState(0),
    {
      showNetwork: i,
      smartContract: o,
      contractDeployed: s,
      validator: a,
      phase: u,
    } = Qu((x) => x.simulation),
    c = X.useRef(null),
    d = X.useRef(null),
    m = X.useRef(null),
    g = () => {
      e(!0);
    },
    y = () => {
      r((x) => x + 1);
    };
  return (
    X.useEffect(() => {
      s &&
        m.current &&
        m.current.scrollIntoView({ behavior: "smooth", block: "center" }),
        setTimeout(() => {
          d.current &&
            d.current.scrollIntoView({ behavior: "smooth", block: "center" });
        }, 4e3);
    }, [s]),
    X.useEffect(() => {
      i &&
        c.current &&
        c.current.scrollIntoView({ behavior: "smooth", block: "center" });
    }, [i]),
    X.useEffect(() => {
      u === "transaction" &&
        c.current &&
        c.current.scrollIntoView({ behavior: "smooth", block: "center" });
    }, [u === "transaction"]),
    X.useEffect(() => {
      a &&
        m.current &&
        setTimeout(() => {
          m.current.scrollIntoView({ behavior: "smooth", block: "center" });
        }, 2e3);
    }, [a]),
    X.useEffect(() => {
      o &&
        d.current &&
        d.current.scrollIntoView({ behavior: "smooth", block: "center" }),
        setTimeout(() => {
          m.current &&
            m.current.scrollIntoView({ behavior: "smooth", block: "center" });
        }, 3e3);
    }, [o]),
    Q.jsx(uC, {
      store: xA,
      children: n
        ? Q.jsxs(
            fn,
            {
              sx: {
                height: "100vh",
                width: "100vw",
                display: "flex",
                flexDirection: { xs: "column", lg: "row" },
                bgcolor: i || o || !n ? "#1a202c" : "#f5f5f5",
                position: "relative",
                overflow: "auto",
                margin: 0,
                padding: 0,
                "&::-webkit-scrollbar": { display: "none" },
                scrollbarWidth: "none",
                msOverflowStyle: "none",
              },
              children: [
                Q.jsx(fn, {
                  ref: m,
                  sx: {
                    width: {
                      xs: "100%",
                      sm: "100%",
                      md: "100%",
                      lg: i ? "18%" : "100%",
                    },
                    minHeight: {
                      xs: "100vh",
                      sm: "100vh",
                      md: "100vh",
                      lg: "100%",
                    },
                    zIndex: 1,
                  },
                  children: Q.jsx(V4, { onReset: y }),
                }),
                i &&
                  Q.jsx(fn, {
                    ref: c,
                    sx: {
                      width: { xs: "100%", sm: "100%", md: "100%", lg: "54%" },
                      minHeight: {
                        xs: "100vh",
                        sm: "100vh",
                        md: "100vh",
                        lg: "100%",
                      },
                      zIndex: 1,
                    },
                    children: Q.jsx(ij, {}),
                  }),
                Q.jsx(fn, {
                  ref: d,
                  padding: "30px",
                  sx: {
                    width: {
                      xs: "100%",
                      sm: "100%",
                      md: "100%",
                      lg: i ? "28%" : o ? "82%" : "0%",
                    },
                    minHeight: {
                      xs: "100vh",
                      sm: "100vh",
                      md: "100vh",
                      lg: "100%",
                    },
                    position: i
                      ? { xs: "relative", lg: "relative" }
                      : "relative",
                    zIndex: i ? { xs: 1, lg: 1 } : 1,
                    bgcolor: i
                      ? { xs: "transparent", lg: "transparent" }
                      : "transparent",
                    overflowY: "auto",
                  },
                  children: Q.jsx(Yj, {}),
                }),
              ],
            },
            t
          )
        : Q.jsx(Vj, { onStart: g }),
    })
  );
}
Y3.createRoot(document.getElementById("root")).render(
  Q.jsx(Is.StrictMode, {
    children: Q.jsx(uC, { store: xA, children: Q.jsx(qj, {}) }),
  })
);
